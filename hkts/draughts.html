<!DOCTYPE HTML>
<html lang="en" class="latte sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Draughts Game - Higher-Kinded Types and Optics for Java</title>


        <!-- Custom HTML head -->


            <meta name="description" content="Explore Higher-Kinded Types (HKTs) and Optcs in Java with the Higher-Kinded-J library. Learn about Functors, Applicatives, Monads, Transformers, practical functional patterns, and how to write cleaner, more composable Java code for your projects using Optics.">


        <meta name="keywords" content="Higher-Kinded Types, Higher-Kinded-J, Higher-Kinded Java, Higher Kinded Java, HKT, Java, Optics, Lens, Prism, Traversal, Iso, Functional Programming, Monad, Functor, Applicative, Transformer, Monoid, Traverse, higherkindedj">
        
        <meta property="og:title" content="Draughts Game - Higher-Kinded Types and Optics for Java"> 
            <meta property="og:description" content="Explore Higher-Kinded Types (HKTs) and Optcs in Java with the Higher-Kinded-J library. Learn about Functors, Applicatives, Monads, Transformers, practical functional patterns, and how to write cleaner, more composable Java code for your projects using Optics.">
        <meta property="og:type" content="website">
        <meta property="og:url" content="https://higher-kinded-j.github.io/"> 
        
        <meta property="og:image" content="https://higher-kinded-j.github.io/preview.png" />
        <meta property="og:site_name" content="Higher-Kinded-J Documentation" />
        
        
        <meta name="twitter:card" content="summary_large_image" /> <meta name="twitter:title" content="Draughts Game - Higher-Kinded Types and Optics for Java - Higher-Kinded-J" />
        <meta name="twitter:description" content="Bringing Higher-Kinded Types and Optics to Java functional patterns" />
        <meta name="twitter:image" content="https://higher-kinded-j.github.io/preview.png" />
        <meta name="description" content="Explore Higher-Kinded Types (HKTs) and Optcs in Java with the Higher-Kinded-J library. Learn about Functors, Applicatives, Monads, Transformers, practical functional patterns, and how to write cleaner, more composable Java code for your projects using Optics.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">
        <meta name="google-site-verification" content="X-xsiAq2cKMLOzh9dexUrX8Onx2h_YMUFgp5lHHUwSg" />
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href=".././mdbook-admonish.css">
        <link rel="stylesheet" href=".././theme/catppuccin.css">
        <link rel="stylesheet" href=".././theme/catppuccin-admonish.css">
        <link rel="stylesheet" href=".././theme/catppuccin-alerts.css">
        <link rel="stylesheet" href=".././theme/additional-hkj.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "latte";
            const default_dark_theme = "macchiato";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('latte')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="latte">Latte</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="frappe">Frapp√©</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="macchiato">Macchiato</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mocha">Mocha</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Higher-Kinded Types and Optics for Java</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/higher-kinded-j/higher-kinded-j" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/higher-kinded-j/higher-kinded-j/edit/main/hkj-book/src/hkts/draughts.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="building-a-playable-draughts-game"><a class="header" href="#building-a-playable-draughts-game">Building a Playable Draughts Game</a></h1>
<p><img src="../images/draughts_board.png" alt="draughts_board.png" /></p>
<p>This tutorial will guide you through building a complete and playable command-line draughts (checkers) game.</p>
<p>We will provide all the necessary code, broken down into manageable files. More importantly, we will demonstrate how <code>higher-kinded-j</code> makes this process more robust, maintainable, and functionally elegant by cleanly separating game logic, user interaction, and state management.</p>
<h3 id="the-functional-approach"><a class="header" href="#the-functional-approach">The Functional Approach</a></h3>
<p>At its core, a game like draughts involves several key aspects where functional patterns can shine:</p>
<ul>
<li><strong>State Management</strong>: The board, the position of pieces, whose turn it is ‚Äì this is all game state. Managing this immutably can prevent a host of bugs.</li>
<li><strong>User Input</strong>: Players will enter moves, which might be valid, invalid, or incorrectly formatted.</li>
<li><strong>Game Logic</strong>: Operations like validating a move, capturing a piece, checking for kings, or determining a winner.</li>
<li><strong>Side Effects</strong>: Interacting with the console for input and output.</li>
</ul>
<p><code>higher-kinded-j</code> provides monads that are perfect for these tasks:</p>
<ul>
<li><strong><a href="../monads/state_monad.html"><code>State</code> Monad</a></strong>: For cleanly managing and transitioning the game state without mutable variables.</li>
<li><strong><a href="../monads/either_monad.html"><code>Either</code> Monad</a></strong>: For handling input parsing and move validation, clearly distinguishing between success and different kinds of errors.</li>
<li><strong><a href="../monads/io_monad.html"><code>IO</code> Monad</a></strong>: For encapsulating side effects like reading from and printing to the console, keeping the core logic pure.</li>
<li><a href="../functional/for_comprehension.html"><code>For</code> Comprehension</a>: To flatten sequences of monadic operations (<code>flatMap</code> calls) into a more readable, sequential style.</li>
</ul>
<p>By using these, we can build a more declarative and composable game.</p>
<h3 id="the-complete-code"><a class="header" href="#the-complete-code">The Complete Code</a></h3>
<p>you can find the complete code in the package:</p>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/tree/main/hkj-examples/src/main/java/org/higherkindedj/example/draughts"><code>org.higherkindedj.example.draughts</code></a></li>
</ul>
<h3 id="step-1-core-concepts-quick-recap"><a class="header" href="#step-1-core-concepts-quick-recap">Step 1: Core Concepts Quick Recap</a></h3>
<p>Before we write game code, let's briefly revisit <em>why</em><code>higher-kinded-j</code> is necessary. Java doesn't let us write, for example, a generic function that works for <em>any</em> container <code>F&lt;A&gt;</code> (like <code>List&lt;A&gt;</code> or <code>Optional&lt;A&gt;</code>). <code>higher-kinded-j</code> simulates this with:</p>
<ul>
<li><strong><code>Kind&lt;F, A&gt;</code></strong>: A bridge interface representing a type <code>A</code> within a context <code>F</code>.</li>
<li><strong>Witness Types</strong>: Marker types that stand in for <code>F</code> (the type constructor).</li>
<li><strong>Type Classes</strong>: Interfaces like <code>Functor</code>, <code>Applicative</code>, <code>Monad</code>, and <code>MonadError</code> that define operations (like <code>map</code>, <code>flatMap</code>, <code>handleErrorWith</code>) which work over these <code>Kind</code>s.</li>
</ul>
<p>For a deeper dive, check out the <a href="core-concepts.html">Core Concepts of Higher-Kinded-J</a> and the <a href="usage-guide.html">Usage Guide</a>.</p>
<h3 id="step-2-defining-the-draughts-game-state"><a class="header" href="#step-2-defining-the-draughts-game-state">Step 2: Defining the Draughts Game State</a></h3>
<p>Our game state needs to track the board, pieces, and current player.
First, we need to define the core data structures of our game. These are simple, immutable records represent the game's state.</p>
<pre><code class="language-java">// Enum for the two players
enum Player { RED, BLACK }

// Enum for the type of piece
enum PieceType { MAN, KING }

// A piece on the board, owned by a player with a certain type
record Piece(Player owner, PieceType type) {}

// A square on the 8x8 board, identified by row and column
record Square(int row, int col) {
  @Override
  public @NonNull String toString() {
    return "" + (char)('a' + col) + (row + 1);
  }
}

// Represents an error during move parsing or validation
record GameError(String description) {}

// The command to make a move from one square to another
record MoveCommand(Square from, Square to) {}

// The outcome of a move attempt
enum MoveOutcome { SUCCESS, INVALID_MOVE, CAPTURE_MADE, GAME_WON }
record MoveResult(MoveOutcome outcome, String message) {}

</code></pre>
<p>We can define a <code>GameState</code> record:</p>
<pre><code class="language-java">// The complete, immutable state of the game at any point in time
public record GameState(Map&lt;Square, Piece&gt; board, Player currentPlayer, String message, boolean isGameOver) {

  public static GameState initial() {
    Map&lt;Square, Piece&gt; startingBoard = new HashMap&lt;&gt;();
    // Place BLACK pieces
    for (int r = 0; r &lt; 3; r++) {
      for (int c = (r % 2 != 0) ? 0 : 1; c &lt; 8; c += 2) {
        startingBoard.put(new Square(r, c), new Piece(Player.BLACK, PieceType.MAN));
      }
    }
    // Place RED pieces
    for (int r = 5; r &lt; 8; r++) {
      for (int c = (r % 2 != 0) ? 0 : 1; c &lt; 8; c += 2) {
        startingBoard.put(new Square(r, c), new Piece(Player.RED, PieceType.MAN));
      }
    }
    return new GameState(Collections.unmodifiableMap(startingBoard), Player.RED, "Game started. RED's turn.", false);
  }

   GameState withBoard(Map&lt;Square, Piece&gt; newBoard) {
    return new GameState(Collections.unmodifiableMap(newBoard), this.currentPlayer, this.message, this.isGameOver);
  }

   GameState withCurrentPlayer(Player nextPlayer) {
    return new GameState(this.board, nextPlayer, this.message, this.isGameOver);
  }

   GameState withMessage(String newMessage) {
    return new GameState(this.board, this.currentPlayer, newMessage, this.isGameOver);
  }

  GameState withGameOver() {
    return new GameState(this.board, this.currentPlayer, this.message, true);
  }

   GameState togglePlayer() {
    Player next = (this.currentPlayer == Player.RED) ? Player.BLACK : Player.RED;
    return withCurrentPlayer(next).withMessage(next + "'s turn.");
  }
}

</code></pre>
<p>We'll use the <code>State&lt;S, A&gt;</code> monad from <code>higher-kinded-j</code> to manage this <code>GameState</code>. A <code>State&lt;GameState, A&gt;</code> represents a computation that takes an initial <code>GameState</code> and produces a result <code>A</code> along with a new, updated <code>GameState</code>. Explore the <a href="../monads/state_monad.html">State Monad documentation</a> for more.</p>
<h3 id="step-3-handling-user-input-with-io-and-either"><a class="header" href="#step-3-handling-user-input-with-io-and-either">Step 3: Handling User Input with <code>IO</code> and <code>Either</code></a></h3>
<p>This class handles reading user input from the console. The <code>readMoveCommand</code> method returns an <code>IO&lt;Either&lt;GameError, MoveCommand&gt;&gt;</code>. This type signature is very descriptive: it tells us the action is an <code>IO</code> side effect, and its result will be either a <code>GameError</code> or a valid <code>MoveCommand</code>.</p>
<pre><code class="language-java">class InputHandler {
  private static final Scanner scanner = new Scanner(System.in);

   static Kind&lt;IOKind.Witness, Either&lt;GameError, MoveCommand&gt;&gt; readMoveCommand() {
    return IOKindHelper.IO_OP.delay(() -&gt; {
      System.out.print("Enter move for " + " (e.g., 'a3 b4') or 'quit': ");
      String line = scanner.nextLine();

      if ("quit".equalsIgnoreCase(line.trim())) {
        return Either.left(new GameError("Player quit the game."));
      }

      String[] parts = line.trim().split("\\s+");
      if (parts.length != 2) {
        return Either.left(new GameError("Invalid input. Use 'from to' format (e.g., 'c3 d4')."));
      }
      try {
        Square from = parseSquare(parts[0]);
        Square to = parseSquare(parts[1]);
        return Either.right(new MoveCommand(from, to));
      } catch (IllegalArgumentException e) {
        return Either.left(new GameError(e.getMessage()));
      }
    });
  }

  private static Square parseSquare(String s) throws IllegalArgumentException {
    if (s == null || s.length() != 2) throw new IllegalArgumentException("Invalid square format: " + s);
    char colChar = s.charAt(0);
    char rowChar = s.charAt(1);
    if (colChar &lt; 'a' || colChar &gt; 'h' || rowChar &lt; '1' || rowChar &gt; '8') {
      throw new IllegalArgumentException("Square out of bounds (a1-h8): " + s);
    }
    int col = colChar - 'a';
    int row = rowChar - '1';
    return new Square(row, col);
  }
}

</code></pre>
<p>Learn more about the <a href="../monads/io_monad.html">IO Monad</a> and <a href="../monads/either_monad.html">Either Monad</a>.</p>
<hr />
<h3 id="step-4-game-logic-as-state-transitions"><a class="header" href="#step-4-game-logic-as-state-transitions">Step 4: Game Logic as State Transitions</a></h3>
<p>This is the heart of our application. It contains the rules of draughts. The <code>applyMove</code> method takes a <code>MoveCommand </code>and returns a <code>State</code> computation. This computation, when run, will validate the move against the current <code>GameState</code>, and if valid, produce a <code>MoveResult</code> and the new <code>GameState</code>. <em>This entire class has no side effects.</em></p>
<pre><code class="language-java">public class GameLogicSimple {

  static Kind&lt;StateKind.Witness&lt;GameState&gt;, MoveResult&gt; applyMove(MoveCommand command) {
    return StateKindHelper.STATE.widen(
        State.of(
            currentState -&gt; {
              // Unpack command for easier access
              Square from = command.from();
              Square to = command.to();
              Piece piece = currentState.board().get(from);
              String invalidMsg; // To hold error messages

              // Validate the move based on currentState and command
              //    - Is it the current player's piece?
              //    - Is the move diagonal?
              //    - Is the destination square empty or an opponent's piece for a jump?

              if (piece == null) {
                invalidMsg = "No piece at " + from;
                return new StateTuple&lt;&gt;(
                    new MoveResult(MoveOutcome.INVALID_MOVE, invalidMsg),
                    currentState.withMessage(invalidMsg));
              }
              if (piece.owner() != currentState.currentPlayer()) {
                invalidMsg = "Not your piece.";
                return new StateTuple&lt;&gt;(
                    new MoveResult(MoveOutcome.INVALID_MOVE, invalidMsg),
                    currentState.withMessage(invalidMsg));
              }
              if (currentState.board().containsKey(to)) {
                invalidMsg = "Destination square " + to + " is occupied.";
                return new StateTuple&lt;&gt;(
                    new MoveResult(MoveOutcome.INVALID_MOVE, invalidMsg),
                    currentState.withMessage(invalidMsg));
              }

              int rowDiff = to.row() - from.row();
              int colDiff = to.col() - from.col();

              // Simple move or jump?
              if (Math.abs(rowDiff) == 1 &amp;&amp; Math.abs(colDiff) == 1) { // Simple move
                if (piece.type() == PieceType.MAN) {
                  if ((piece.owner() == Player.RED &amp;&amp; rowDiff &gt; 0)
                      || (piece.owner() == Player.BLACK &amp;&amp; rowDiff &lt; 0)) {
                    invalidMsg = "Men can only move forward.";
                    return new StateTuple&lt;&gt;(
                        new MoveResult(MoveOutcome.INVALID_MOVE, invalidMsg),
                        currentState.withMessage(invalidMsg));
                  }
                }
                return performMove(currentState, command, piece);
              } else if (Math.abs(rowDiff) == 2 &amp;&amp; Math.abs(colDiff) == 2) { // Jump move
                Square jumpedSquare =
                    new Square(from.row() + rowDiff / 2, from.col() + colDiff / 2);
                Piece jumpedPiece = currentState.board().get(jumpedSquare);

                if (jumpedPiece == null || jumpedPiece.owner() == currentState.currentPlayer()) {
                  invalidMsg = "Invalid jump. Must jump over an opponent's piece.";
                  return new StateTuple&lt;&gt;(
                      new MoveResult(MoveOutcome.INVALID_MOVE, invalidMsg),
                      currentState.withMessage(invalidMsg));
                }

                return performJump(currentState, command, piece, jumpedSquare);
              } else {
                invalidMsg = "Move must be diagonal by 1 or 2 squares.";
                return new StateTuple&lt;&gt;(
                    new MoveResult(MoveOutcome.INVALID_MOVE, invalidMsg),
                    currentState.withMessage(invalidMsg));
              }
            }));
  }

  private static StateTuple&lt;GameState, MoveResult&gt; performMove(
      GameState state, MoveCommand command, Piece piece) {
    Map&lt;Square, Piece&gt; newBoard = new HashMap&lt;&gt;(state.board());
    newBoard.remove(command.from());
    newBoard.put(command.to(), piece);

    GameState movedState = state.withBoard(newBoard);
    GameState finalState = checkAndKingPiece(movedState, command.to());

    return new StateTuple&lt;&gt;(
        new MoveResult(MoveOutcome.SUCCESS, "Move successful."), finalState.togglePlayer());
  }

  private static StateTuple&lt;GameState, MoveResult&gt; performJump(
      GameState state, MoveCommand command, Piece piece, Square jumpedSquare) {
    Map&lt;Square, Piece&gt; newBoard = new HashMap&lt;&gt;(state.board());
    newBoard.remove(command.from());
    newBoard.remove(jumpedSquare);
    newBoard.put(command.to(), piece);

    GameState jumpedState = state.withBoard(newBoard);
    GameState finalState = checkAndKingPiece(jumpedState, command.to());

    // Check for win condition
    boolean blackWins =
        finalState.board().values().stream().noneMatch(p -&gt; p.owner() == Player.RED);
    boolean redWins =
        finalState.board().values().stream().noneMatch(p -&gt; p.owner() == Player.BLACK);

    if (blackWins || redWins) {
      String winner = blackWins ? "BLACK" : "RED";
      return new StateTuple&lt;&gt;(
          new MoveResult(MoveOutcome.GAME_WON, winner + " wins!"),
          finalState.withGameOver().withMessage(winner + " has captured all pieces!"));
    }

    return new StateTuple&lt;&gt;(
        new MoveResult(MoveOutcome.CAPTURE_MADE, "Capture successful."), finalState.togglePlayer());
  }

  private static GameState checkAndKingPiece(GameState state, Square to) {
    Piece piece = state.board().get(to);
    if (piece != null &amp;&amp; piece.type() == PieceType.MAN) {
      // A RED piece is kinged on row index 0 (the "1st" row).
      // A BLACK piece is kinged on row index 7 (the "8th" row).
      if ((piece.owner() == Player.RED &amp;&amp; to.row() == 0)
          || (piece.owner() == Player.BLACK &amp;&amp; to.row() == 7)) {
        Map&lt;Square, Piece&gt; newBoard = new HashMap&lt;&gt;(state.board());
        newBoard.put(to, new Piece(piece.owner(), PieceType.KING));
        return state
            .withBoard(newBoard)
            .withMessage(piece.owner() + "'s piece at " + to + " has been kinged!");
      }
    }
    return state;
  }
}
</code></pre>
<p>This uses <code>State.of</code> to create a stateful computation. <code>State.get()</code>, <code>State.set()</code>, and <code>State.modify()</code> are other invaluable tools from the State monad.</p>
<hr />
<h3 id="step-5-composing-with-flatmap---the-monadic-power"><a class="header" href="#step-5-composing-with-flatmap---the-monadic-power">Step 5: Composing with <code>flatMap</code> - The Monadic Power</a></h3>
<p>Now, we combine these pieces. The main loop needs to:</p>
<ol>
<li>Display the board (<code>IO</code>).</li>
<li>Read user input (<code>IO</code>).</li>
<li>If the input is valid, apply it to the game logic (<code>State</code>).</li>
<li>Loop with the new game state.</li>
</ol>
<p>This sequence of operations is a goodt use case for a <code>For</code> comprehension to improve on nested <code>flatMap</code> calls.</p>
<pre><code class="language-java">
public class Draughts {

  private static final IOMonad ioMonad = IOMonad.INSTANCE;
  
  // Processes a single turn of the game
  private static Kind&lt;IOKind.Witness, GameState&gt; processTurn(GameState currentGameState) {
  
    // 1. Use 'For' to clearly sequence the display and read actions.
    var sequence = For.from(ioMonad, BoardDisplay.displayBoard(currentGameState))
        .from(ignored -&gt; InputHandler.readMoveCommand())
        .yield((ignored, eitherResult) -&gt; eitherResult); // Yield the result of the read action

    // 2. The result of the 'For' is an IO&lt;Either&lt;...&gt;&gt;.
    //    Now, flatMap that single result to handle the branching.
    return ioMonad.flatMap(
        eitherResult -&gt;
            eitherResult.fold(
                error -&gt; { // Left case: Input error
                  return IOKindHelper.IO_OP.delay(
                      () -&gt; {
                        System.out.println("Error: " + error.description());
                        return currentGameState;
                      });
                },
                moveCommand -&gt; { // Right case: Valid input
                  var stateComputation = GameLogic.applyMove(moveCommand);
                  var resultTuple = StateKindHelper.STATE.runState(stateComputation, currentGameState);
                  return ioMonad.of(resultTuple.state());
                }),
        sequence);
  }

  
  // other methods....
}

</code></pre>
<p>The <code>For</code> comprehension flattens the <code>display -&gt; read</code> sequence, making the primary workflow more declarative and easier to read than nested callbacks.</p>
<p>The <a href="order-walkthrough.html">Order Processing Example</a> in the <code>higher-kinded-j</code> docs shows a more complex scenario using <code>CompletableFuture</code> and <code>EitherT</code>, which is a great reference for getting started with monad transformers.</p>
<hr />
<h3 id="step-6-the-game-loop"><a class="header" href="#step-6-the-game-loop">Step 6: The Game Loop</a></h3>
<pre><code class="language-java">
public class Draughts {

  private static final IOMonad ioMonad = IOMonad.INSTANCE;

  // The main game loop as a single, recursive IO computation
  private static Kind&lt;IOKind.Witness, Unit&gt; gameLoop(GameState gameState) {
    if (gameState.isGameOver()) {
      // Base case: game is over, just display the final board and message.
      return BoardDisplay.displayBoard(gameState);
    }

    // Recursive step: process one turn and then loop with the new state
    return ioMonad.flatMap(Draughts::gameLoop, processTurn(gameState));
  }

  // processTurn as before....

  public static void main(String[] args) {
    // Get the initial state
    GameState initialState = GameState.initial();
    // Create the full game IO program
    Kind&lt;IOKind.Witness, Unit&gt; fullGame = gameLoop(initialState);
    // Execute the program. This is the only place where side effects are actually run.
    IOKindHelper.IO_OP.unsafeRunSync(fullGame);
    System.out.println("Thank you for playing!");
  }
}

</code></pre>
<p>Key methods like <code>IOKindHelper.IO_OP.unsafeRunSync()</code> and <code>StateKindHelper.STATE.runState()</code> are used to execute the monadic computations at the "edge" of the application.</p>
<h3 id="step-7-displaying-the-board"><a class="header" href="#step-7-displaying-the-board">Step 7: Displaying the Board</a></h3>
<p>A simple text representation will do the trick.
This class is responsible for rendering the GameState to the console. Notice how the displayBoard method doesn't perform the printing directly; it returns an <code>IO&lt;Unit&gt;</code> which is a description of the printing action. This keeps the method pure.</p>
<pre><code class="language-java">
public class BoardDisplay {

  public static Kind&lt;IOKind.Witness, Unit&gt; displayBoard(GameState gameState) {
    return IOKindHelper.IO_OP.delay(
        () -&gt; {
          System.out.println("\n  a b c d e f g h");
          System.out.println(" +-----------------+");
          for (int r = 7; r &gt;= 0; r--) { // Print from row 8 down to 1
            System.out.print((r + 1) + "| ");
            for (int c = 0; c &lt; 8; c++) {
              Piece p = gameState.board().get(new Square(r, c));
              if (p == null) {
                System.out.print(". ");
              } else {
                char pieceChar = (p.owner() == Player.RED) ? 'r' : 'b';
                if (p.type() == PieceType.KING) pieceChar = Character.toUpperCase(pieceChar);
                System.out.print(pieceChar + " ");
              }
            }
            System.out.println("|" + (r + 1));
          }
          System.out.println(" +-----------------+");
          System.out.println("  a b c d e f g h");
          System.out.println("\n" + gameState.message());
          if (!gameState.isGameOver()) {
            System.out.println("Current Player: " + gameState.currentPlayer());
          }
          return Unit.INSTANCE;
        });
  }
}

</code></pre>
<h3 id="playing-the-game"><a class="header" href="#playing-the-game">Playing the game</a></h3>
<p><img src="../images/draughts_game.png" alt="draughts_game.png" /></p>
<p>In the game we can see the black has "kinged" a piece by reaching <code>e8</code>.</p>
<h3 id="step-8-refactoring-for-multiple-captures"><a class="header" href="#step-8-refactoring-for-multiple-captures">Step 8: Refactoring for Multiple Captures</a></h3>
<p>A key rule in draughts is that if a capture is available, it must be taken, and if a capture leads to another possible capture for the same piece, that jump must also be taken.</p>
<p>The beauty of our functional approach is that we only need to modify the core rules in <code>GameLogic.java</code>. <code>The Draughts.java</code> game loop, the IO handlers, and the data models don't need to change at all.</p>
<p>The core idea is to modify the <code>performJump</code> method. After a jump is completed, we will check if the piece that just moved can make another jump from its new position.</p>
<p>We do this by adding a helper <code>canPieceJump</code> and modify <code>performJump</code> to check for subsequent jumps.</p>
<p>If another jump is possible, the player's turn does not end., we will update the board state but not switch the current player, forcing them to make another capture.
If another jump is not possible, we will switch the player as normal.</p>
<pre><code class="language-java">
/** Check if a piece at a given square has any valid jumps. */
  private static boolean canPieceJump(GameState state, Square from) {
    Piece piece = state.board().get(from);
    if (piece == null) return false;

    int[] directions = {-2, 2};
    for (int rowOffset : directions) {
      for (int colOffset : directions) {
        if (piece.type() == PieceType.MAN) {
          if ((piece.owner() == Player.RED &amp;&amp; rowOffset &gt; 0)
              || (piece.owner() == Player.BLACK &amp;&amp; rowOffset &lt; 0)) {
            continue; // Invalid forward direction for man
          }
        }

        Square to = new Square(from.row() + rowOffset, from.col() + colOffset);
        if (to.row() &lt; 0
            || to.row() &gt; 7
            || to.col() &lt; 0
            || to.col() &gt; 7
            || state.board().containsKey(to)) {
          continue; // Off board or destination occupied
        }

        Square jumpedSquare = new Square(from.row() + rowOffset / 2, from.col() + colOffset / 2);
        Piece jumpedPiece = state.board().get(jumpedSquare);
        if (jumpedPiece != null &amp;&amp; jumpedPiece.owner() != piece.owner()) {
          return true; // Found a valid jump
        }
      }
    }
    return false;
  }

  /** Now it checks for further jumps after a capture. */
  private static StateTuple&lt;GameState, MoveResult&gt; performJump(
      GameState state, MoveCommand command, Piece piece, Square jumpedSquare) {
    // Perform the jump and update board
    Map&lt;Square, Piece&gt; newBoard = new HashMap&lt;&gt;(state.board());
    newBoard.remove(command.from());
    newBoard.remove(jumpedSquare);
    newBoard.put(command.to(), piece);
    GameState jumpedState = state.withBoard(newBoard);

    // Check for kinging after the jump
    GameState stateAfterKinging = checkAndKingPiece(jumpedState, command.to());

    // Check for win condition after the capture
    boolean blackWins =
        !stateAfterKinging.board().values().stream().anyMatch(p -&gt; p.owner() == Player.RED);
    boolean redWins =
        !stateAfterKinging.board().values().stream().anyMatch(p -&gt; p.owner() == Player.BLACK);
    if (blackWins || redWins) {
      String winner = blackWins ? "BLACK" : "RED";
      return new StateTuple&lt;&gt;(
          new MoveResult(MoveOutcome.GAME_WON, winner + " wins!"),
          stateAfterKinging.withGameOver().withMessage(winner + " has captured all pieces!"));
    }

    // Check if the same piece can make another jump
    boolean anotherJumpPossible = canPieceJump(stateAfterKinging, command.to());

    if (anotherJumpPossible) {
      // If another jump exists, DO NOT toggle the player.
      // Update the message to prompt for the next jump.
      String msg = "Capture successful. You must jump again with the same piece.";
      return new StateTuple&lt;&gt;(
          new MoveResult(MoveOutcome.CAPTURE_MADE, msg), stateAfterKinging.withMessage(msg));
    } else {
      // No more jumps, so end the turn and toggle the player.
      return new StateTuple&lt;&gt;(
          new MoveResult(MoveOutcome.CAPTURE_MADE, "Capture successful."),
          stateAfterKinging.togglePlayer());
    }
  }

</code></pre>
<h3 id="why-this-functional-approach-is-better"><a class="header" href="#why-this-functional-approach-is-better">Why This Functional Approach is Better</a></h3>
<p>Having seen the complete code, let's reflect on the benefits:</p>
<ul>
<li><strong>Testability</strong>: The <code>GameLogic</code> class is completely pure. It has no side effects and doesn't depend on <code>System.in</code> or <code>System.out</code>. You can test the entire rules engine by simply providing a <code>GameState</code> and a <code>MoveCommand</code> and asserting on the resulting <code>GameState</code> and <code>MoveResult</code>. This is significantly easier than testing code that is tangled with console I/O.</li>
<li><strong>Composability</strong>: The <code>gameLoop</code> in <code>Draughts.java</code> is a beautiful example of composition. It clearly and declaratively lays out the sequence of events for a game turn: <code>display -&gt; read -&gt; process</code>. The <code>flatMap</code> calls hide all the messy details of passing state and results from one step to the next.</li>
<li><strong>Reasoning</strong>: The type signatures tell a story. <code>IO&lt;Either&lt;GameError, MoveCommand&gt;&gt;</code> is far more descriptive than a method that returns a <code>MoveCommand</code> but might throw an exception or return <code>null</code>. It explicitly forces the caller to handle both the success and error cases.</li>
<li><strong>Maintainability</strong>: If you want to change from a command-line interface to a graphical one, you only need to replace <code>BoardDisplay</code> and <code>InputHandler</code>. The entire core <code>GameLogic</code> remains untouched because it's completely decoupled from the presentation layer.</li>
</ul>
<p>This tutorial has only scratched the surface. You could extend this by exploring other constructs from the library, like using <code>Validated</code> to accumulate multiple validation errors or using the <code>Reader</code> monad to inject different sets of game rules.</p>
<p>Java may not have native HKTs, but with <a href="https://higher-kinded-j.github.io/home.html"><strong>Higher-Kinded-J</strong></a>, you can absolutely utilise these powerful and elegant functional patterns to write better, more robust applications.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../hkts/order-walkthrough.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../optics/optics_intro.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../hkts/order-walkthrough.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../optics/optics_intro.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
