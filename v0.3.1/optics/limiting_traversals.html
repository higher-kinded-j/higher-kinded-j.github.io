<!DOCTYPE HTML>
<html lang="en" class="latte sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Limiting Traversals - Higher-Kinded-J: Composable Effects and Advanced Optics for Java</title>


        <!-- Custom HTML head -->


            <meta name="description" content="The most comprehensive functional programming library for Java. Unify error handling, optional values, and immutable data navigation with the Effect Path API and Focus DSL. Features advanced optics with code generation for Java records, filtered traversals, indexed optics, and seamless Spring Boot integration.">


        <meta name="keywords" content="Higher-Kinded Types, Higher-Kinded-J, HKT, Java, Optics, Lens, Prism, Traversal, Iso, Affine, Focus DSL, Effect Path API, Functional Programming, Monad, Functor, Applicative, EitherPath, MaybePath, TryPath, ValidationPath, Java Records, Sealed Interface, Error Handling, Immutable Data">
        
        <meta property="og:title" content="Limiting Traversals - Higher-Kinded-J: Composable Effects and Advanced Optics for Java">
            <meta property="og:description" content="The most comprehensive functional programming library for Java. Unify error handling, optional values, and immutable data navigation with the Effect Path API and Focus DSL. Features advanced optics with code generation for Java records, filtered traversals, indexed optics, and seamless Spring Boot integration.">
        <meta property="og:type" content="website">
        <meta property="og:url" content="https://higher-kinded-j.github.io/">
        <meta property="og:image" content="https://higher-kinded-j.github.io/preview.png">
        <meta property="og:image:width" content="1200">
        <meta property="og:image:height" content="630">
        <meta property="og:site_name" content="Higher-Kinded-J Documentation">
        <meta property="og:locale" content="en_GB">
        
        <meta name="twitter:card" content="summary_large_image">
        <meta name="twitter:title" content="Limiting Traversals - Higher-Kinded-J: Composable Effects and Advanced Optics for Java">
        <meta name="twitter:description" content="Unifying Composable Effects and Advanced Optics for Java. Effect Path API, Focus DSL, and the most comprehensive optics implementation in the Java ecosystem.">
        <meta name="twitter:image" content="https://higher-kinded-j.github.io/preview.png">
        <meta name="twitter:image:alt" content="Higher-Kinded-J: Composable Effects and Advanced Optics for Java">
        <meta name="description" content="The most comprehensive functional programming library for Java. Unify error handling, optional values, and immutable data navigation with the Effect Path API and Focus DSL. Features advanced optics with code generation for Java records, filtered traversals, indexed optics, and seamless Spring Boot integration.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">
        <meta name="google-site-verification" content="X-xsiAq2cKMLOzh9dexUrX8Onx2h_YMUFgp5lHHUwSg" />
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href=".././mdbook-admonish.css">
        <link rel="stylesheet" href=".././theme/catppuccin.css">
        <link rel="stylesheet" href=".././theme/catppuccin-admonish.css">
        <link rel="stylesheet" href=".././theme/catppuccin-alerts.css">
        <link rel="stylesheet" href=".././theme/additional-hkj.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "latte";
            const default_dark_theme = "macchiato";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('latte')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="latte">Latte</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="frappe">Frappé</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="macchiato">Macchiato</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mocha">Mocha</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        <div class="version-selector-container">
                            <select id="version-selector" class="version-selector" aria-label="Select documentation version" title="Select documentation version">
                                <option value="">Loading versions...</option>
                            </select>
                        </div>
                    </div>

                    <h1 class="menu-title">Higher-Kinded-J: Composable Effects and Advanced Optics for Java</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/higher-kinded-j/higher-kinded-j" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/higher-kinded-j/higher-kinded-j/edit/main/hkj-book/src/optics/limiting_traversals.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="limiting-traversals-focusing-on-list-portions"><a class="header" href="#limiting-traversals-focusing-on-list-portions">Limiting Traversals: Focusing on List Portions</a></h1>
<h2 id="declarative-slicing-for-targeted-operations"><a class="header" href="#declarative-slicing-for-targeted-operations"><em>Declarative Slicing for Targeted Operations</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to focus on specific portions of lists (first n, last n, slices)</li>
<li>Using <code>ListTraversals</code> factory methods for index-based operations</li>
<li>The difference between limiting traversals and Stream's <code>limit()</code>/<code>skip()</code></li>
<li>Composing limiting traversals with lenses, prisms, and filtered optics</li>
<li>Understanding edge case handling (negative indices, bounds exceeding list size)</li>
<li>Real-world patterns for pagination, batch processing, and time-series windowing</li>
<li>When to use limiting traversals vs Stream API vs manual loops</li>
</ul>
</div>
</div>
<div id="admonition-example-code" class="admonition admonish-note" role="note" aria-labelledby="admonition-example-code-title">
<div class="admonition-title">
<div id="admonition-example-code-title">
<p>Example Code</p>
</div>
<a class="admonition-anchor-link" href="#admonition-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/ListTraversalsExample.java">ListTraversalsExample</a></p>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/PaginationExample.java">PaginationExample</a></p>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/BatchProcessingExample.java">BatchProcessingExample</a></p>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/TimeSeriesWindowingExample.java">TimeSeriesWindowingExample</a></p>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/PredicateListTraversalsExample.java">PredicateListTraversalsExample</a></p>
</div>
</div>
<p>In our journey through optics, we've seen how <strong>Traversal</strong> handles bulk operations on all elements of a collection, and how <strong>filtered optics</strong> let us focus on elements matching a predicate. But what about focusing on elements by <em>position</em>: the first few items, the last few, or a specific slice?</p>
<p>Traditionally, working with list portions requires breaking out of your optic composition to use streams or manual index manipulation. <strong>Limiting traversals</strong> solve this elegantly by making positional focus a first-class part of your optic composition.</p>
<hr />
<h2 id="the-scenario-product-catalogue-management"><a class="header" href="#the-scenario-product-catalogue-management">The Scenario: Product Catalogue Management</a></h2>
<p>Imagine you're building an e-commerce platform where you need to:</p>
<ul>
<li>Display only the <strong>first 10 products</strong> on a landing page</li>
<li>Apply discounts to <strong>all except the last 3</strong> featured items</li>
<li>Process customer orders in <strong>chunks of 50</strong> for batch shipping</li>
<li>Analyse <strong>the most recent 7 days</strong> of time-series sales data</li>
<li>Update metadata for products <strong>between positions 5 and 15</strong> in a ranked list</li>
</ul>
<p><strong>The Data Model:</strong></p>
<pre><code class="language-java">@GenerateLenses
public record Product(String sku, String name, double price, int stock) {
    Product applyDiscount(double percentage) {
        return new Product(sku, name, price * (1 - percentage), stock);
    }
}

@GenerateLenses
public record Catalogue(String name, List&lt;Product&gt; products) {}

@GenerateLenses
public record Order(String id, List&lt;LineItem&gt; items, LocalDateTime created) {}

@GenerateLenses
public record LineItem(Product product, int quantity) {}

@GenerateLenses
public record SalesMetric(LocalDate date, double revenue, int transactions) {}
</code></pre>
<p><strong>The Traditional Approach:</strong></p>
<pre><code class="language-java">// Verbose: Manual slicing breaks optic composition
List&lt;Product&gt; firstTen = catalogue.products().subList(0, Math.min(10, catalogue.products().size()));
List&lt;Product&gt; discounted = firstTen.stream()
    .map(p -&gt; p.applyDiscount(0.1))
    .collect(Collectors.toList());
// Now reconstruct the full list... tedious!
List&lt;Product&gt; fullList = new ArrayList&lt;&gt;(discounted);
fullList.addAll(catalogue.products().subList(Math.min(10, catalogue.products().size()), catalogue.products().size()));
Catalogue updated = new Catalogue(catalogue.name(), fullList);

// Even worse with nested structures
List&lt;Order&gt; chunk = orders.subList(startIndex, Math.min(startIndex + chunkSize, orders.size()));
// Process chunk... then what? How do we put it back?
</code></pre>
<p>This approach forces you to abandon the declarative power of optics, manually managing indices, bounds checking, and list reconstruction. <strong>Limiting traversals</strong> let you express this intent directly within your optic composition.</p>
<hr />
<h2 id="think-of-limiting-traversals-like"><a class="header" href="#think-of-limiting-traversals-like">Think of Limiting Traversals Like...</a></h2>
<ul>
<li><strong>Java Stream's <code>limit()</code> and <code>skip()</code></strong>: Like <code>stream.limit(n)</code> and <code>stream.skip(n)</code>, but composable with immutable data transformations and integrated into optic pipelines</li>
<li><strong>SQL's LIMIT and OFFSET clauses</strong>: Like database pagination (<code>LIMIT 10 OFFSET 20</code>), but for in-memory immutable structures, enabling declarative pagination logic</li>
<li><strong>Spring Batch chunk processing</strong>: Similar to Spring Batch's chunk-oriented processing: divide a list into manageable segments for targeted transformation whilst preserving the complete dataset</li>
<li><strong>ArrayList.subList() but better</strong>: Like <code>List.subList(from, to)</code>, but instead of a mutable view, you get an immutable optic that composes with lenses, prisms, and filtered traversals</li>
</ul>
<p>The key insight: positional focus becomes part of your optic's <em>identity</em>, not an external slicing operation applied afterwards.</p>
<hr />
<h2 id="five-ways-to-limit-focus"><a class="header" href="#five-ways-to-limit-focus">Five Ways to Limit Focus</a></h2>
<p>Higher-kinded-j's <code>ListTraversals</code> utility class provides five complementary factory methods:</p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Description</th><th>SQL Equivalent</th></tr></thead><tbody>
<tr><td><strong><code>taking(n)</code></strong></td><td>Focus on first n elements</td><td><code>LIMIT n</code></td></tr>
<tr><td><strong><code>dropping(n)</code></strong></td><td>Skip first n, focus on rest</td><td><code>OFFSET n</code> (then all)</td></tr>
<tr><td><strong><code>takingLast(n)</code></strong></td><td>Focus on last n elements</td><td><code>ORDER BY id DESC LIMIT n</code></td></tr>
<tr><td><strong><code>droppingLast(n)</code></strong></td><td>Focus on all except last n</td><td><code>LIMIT (size - n)</code></td></tr>
<tr><td><strong><code>slicing(from, to)</code></strong></td><td>Focus on range [from, to)</td><td><code>LIMIT (to-from) OFFSET from</code></td></tr>
</tbody></table>
</div>
<p>Each serves different needs, and they can be combined with other optics for powerful compositions.</p>
<hr />
<h2 id="a-step-by-step-walkthrough"><a class="header" href="#a-step-by-step-walkthrough">A Step-by-Step Walkthrough</a></h2>
<h3 id="step-1-basic-usage--takingint-n"><a class="header" href="#step-1-basic-usage--takingint-n">Step 1: Basic Usage – <code>taking(int n)</code></a></h3>
<p>The most intuitive method: focus on at most the first <code>n</code> elements.</p>
<pre><code class="language-java">import org.higherkindedj.optics.util.ListTraversals;
import org.higherkindedj.optics.util.Traversals;

// Create a traversal for first 3 products
Traversal&lt;List&lt;Product&gt;, Product&gt; first3 = ListTraversals.taking(3);

List&lt;Product&gt; products = List.of(
    new Product("SKU001", "Widget", 10.0, 100),
    new Product("SKU002", "Gadget", 25.0, 50),
    new Product("SKU003", "Gizmo", 15.0, 75),
    new Product("SKU004", "Doohickey", 30.0, 25),
    new Product("SKU005", "Thingamajig", 20.0, 60)
);

// Apply 10% discount to ONLY first 3 products
List&lt;Product&gt; result = Traversals.modify(first3, p -&gt; p.applyDiscount(0.1), products);
// First 3 discounted; last 2 preserved unchanged

// Extract ONLY first 3 products
List&lt;Product&gt; firstThree = Traversals.getAll(first3, products);
// Returns: [Widget, Gadget, Gizmo]
</code></pre>
<p><strong>Critical Semantic</strong>: During <strong>modification</strong>, non-focused elements are <em>preserved unchanged</em> in the structure. During <strong>queries</strong> (like <code>getAll</code>), they are <em>excluded</em> from the results. This preserves the overall structure whilst focusing operations on the subset you care about.</p>
<h3 id="step-2-skipping-elements--droppingint-n"><a class="header" href="#step-2-skipping-elements--droppingint-n">Step 2: Skipping Elements – <code>dropping(int n)</code></a></h3>
<p>Focus on all elements <em>after</em> skipping the first <code>n</code>:</p>
<pre><code class="language-java">// Skip first 2, focus on the rest
Traversal&lt;List&lt;Product&gt;, Product&gt; afterFirst2 = ListTraversals.dropping(2);

List&lt;Product&gt; result = Traversals.modify(afterFirst2, p -&gt; p.applyDiscount(0.15), products);
// First 2 unchanged; last 3 get 15% discount

List&lt;Product&gt; skipped = Traversals.getAll(afterFirst2, products);
// Returns: [Gizmo, Doohickey, Thingamajig]
</code></pre>
<h3 id="step-3-focusing-on-the-end--takinglastint-n"><a class="header" href="#step-3-focusing-on-the-end--takinglastint-n">Step 3: Focusing on the End – <code>takingLast(int n)</code></a></h3>
<p>Focus on the last <code>n</code> elements, perfect for "most recent" scenarios:</p>
<pre><code class="language-java">// Focus on last 2 products
Traversal&lt;List&lt;Product&gt;, Product&gt; last2 = ListTraversals.takingLast(2);

List&lt;Product&gt; result = Traversals.modify(last2, p -&gt; p.applyDiscount(0.2), products);
// First 3 unchanged; last 2 get 20% discount

List&lt;Product&gt; lastTwo = Traversals.getAll(last2, products);
// Returns: [Doohickey, Thingamajig]
</code></pre>
<h3 id="step-4-excluding-from-the-end--droppinglastint-n"><a class="header" href="#step-4-excluding-from-the-end--droppinglastint-n">Step 4: Excluding from the End – <code>droppingLast(int n)</code></a></h3>
<p>Focus on all elements <em>except</em> the last <code>n</code>:</p>
<pre><code class="language-java">// Focus on all except last 2
Traversal&lt;List&lt;Product&gt;, Product&gt; exceptLast2 = ListTraversals.droppingLast(2);

List&lt;Product&gt; result = Traversals.modify(exceptLast2, p -&gt; p.applyDiscount(0.05), products);
// First 3 get 5% discount; last 2 unchanged

List&lt;Product&gt; allButLastTwo = Traversals.getAll(exceptLast2, products);
// Returns: [Widget, Gadget, Gizmo]
</code></pre>
<h3 id="step-5-precise-slicing--slicingint-from-int-to"><a class="header" href="#step-5-precise-slicing--slicingint-from-int-to">Step 5: Precise Slicing – <code>slicing(int from, int to)</code></a></h3>
<p>Focus on elements within a half-open range <code>[from, to)</code>, exactly like <code>List.subList()</code>:</p>
<pre><code class="language-java">// Focus on indices 1, 2, 3 (0-indexed, exclusive end)
Traversal&lt;List&lt;Product&gt;, Product&gt; slice = ListTraversals.slicing(1, 4);

List&lt;Product&gt; result = Traversals.modify(slice, p -&gt; p.applyDiscount(0.12), products);
// Index 0 unchanged; indices 1-3 discounted; index 4 unchanged

List&lt;Product&gt; sliced = Traversals.getAll(slice, products);
// Returns: [Gadget, Gizmo, Doohickey]
</code></pre>
<hr />
<h2 id="predicate-based-focusing-beyond-fixed-indices"><a class="header" href="#predicate-based-focusing-beyond-fixed-indices">Predicate-Based Focusing: Beyond Fixed Indices</a></h2>
<p>Whilst index-based limiting is powerful, many real-world scenarios require <strong>conditional focusing</strong>: stopping when a condition is met rather than at a fixed position. <code>ListTraversals</code> provides three predicate-based methods that complement the fixed-index approaches:</p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Description</th><th>Use Case</th></tr></thead><tbody>
<tr><td><strong><code>takingWhile(Predicate)</code></strong></td><td>Focus on longest prefix where predicate holds</td><td>Processing ordered data until threshold</td></tr>
<tr><td><strong><code>droppingWhile(Predicate)</code></strong></td><td>Skip prefix whilst predicate holds</td><td>Ignoring header/preamble sections</td></tr>
<tr><td><strong><code>element(int)</code></strong></td><td>Focus on single element at index (0-1 cardinality)</td><td>Safe indexed access without exceptions</td></tr>
</tbody></table>
</div>
<p>These methods enable <strong>runtime-determined focusing</strong>: the number of elements in focus depends on the data itself, not a predetermined count.</p>
<h3 id="step-6-conditional-prefix-with-takingwhilepredicate"><a class="header" href="#step-6-conditional-prefix-with-takingwhilepredicate">Step 6: Conditional Prefix with <code>takingWhile(Predicate)</code></a></h3>
<p>The <code>takingWhile()</code> method focuses on the <strong>longest prefix</strong> of elements satisfying a predicate. Once an element fails the test, traversal stops, even if later elements would pass.</p>
<pre><code class="language-java">// Focus on products whilst price &lt; 20
Traversal&lt;List&lt;Product&gt;, Product&gt; affordablePrefix =
    ListTraversals.takingWhile(p -&gt; p.price() &lt; 20.0);

List&lt;Product&gt; products = List.of(
    new Product("SKU001", "Widget", 10.0, 100),
    new Product("SKU002", "Gadget", 15.0, 50),
    new Product("SKU003", "Gizmo", 25.0, 75),   // Stops here
    new Product("SKU004", "Thing", 12.0, 25)    // Not included despite &lt; 20
);

// Apply discount only to initial affordable items
List&lt;Product&gt; result = Traversals.modify(
    affordablePrefix,
    p -&gt; p.applyDiscount(0.1),
    products
);
// Widget and Gadget discounted; Gizmo and Thing unchanged

// Extract the affordable prefix
List&lt;Product&gt; affordable = Traversals.getAll(affordablePrefix, products);
// Returns: [Widget, Gadget]  (stops at first expensive item)
</code></pre>
<p><strong>Key Semantic</strong>: Unlike <code>filtered()</code>, which tests all elements, <code>takingWhile()</code> is <strong>sequential and prefix-oriented</strong>. It's the optics equivalent of Stream's <code>takeWhile()</code>.</p>
<p><strong>Real-World Use Cases</strong>:</p>
<ul>
<li><strong>Time-series data</strong>: Process events before a timestamp threshold</li>
<li><strong>Sorted lists</strong>: Extract items below a value boundary</li>
<li><strong>Log processing</strong>: Capture startup messages before first error</li>
<li><strong>Priority queues</strong>: Handle high-priority items before switching logic</li>
</ul>
<pre><code class="language-java">// Time-series: Process transactions before cutoff
LocalDateTime cutoff = LocalDateTime.of(2025, 1, 1, 0, 0);
Traversal&lt;List&lt;Transaction&gt;, Transaction&gt; beforeCutoff =
    ListTraversals.takingWhile(t -&gt; t.timestamp().isBefore(cutoff));

List&lt;Transaction&gt; processed = Traversals.modify(
    beforeCutoff,
    t -&gt; t.withStatus("PROCESSED"),
    transactions
);
</code></pre>
<h3 id="step-7-skipping-prefix-with-droppingwhilepredicate"><a class="header" href="#step-7-skipping-prefix-with-droppingwhilepredicate">Step 7: Skipping Prefix with <code>droppingWhile(Predicate)</code></a></h3>
<p>The <code>droppingWhile()</code> method is the complement to <code>takingWhile()</code>: it <strong>skips the prefix</strong> whilst the predicate holds, then focuses on all remaining elements.</p>
<pre><code class="language-java">// Skip low-stock products, focus on well-stocked ones
Traversal&lt;List&lt;Product&gt;, Product&gt; wellStocked =
    ListTraversals.droppingWhile(p -&gt; p.stock() &lt; 50);

List&lt;Product&gt; products = List.of(
    new Product("SKU001", "Widget", 10.0, 20),
    new Product("SKU002", "Gadget", 25.0, 30),
    new Product("SKU003", "Gizmo", 15.0, 75),   // First to pass
    new Product("SKU004", "Thing", 12.0, 25)    // Included despite &lt; 50
);

// Restock only well-stocked items (and everything after)
List&lt;Product&gt; restocked = Traversals.modify(
    wellStocked,
    p -&gt; new Product(p.sku(), p.name(), p.price(), p.stock() + 50),
    products
);
// Widget and Gadget unchanged; Gizmo and Thing restocked

List&lt;Product&gt; focused = Traversals.getAll(wellStocked, products);
// Returns: [Gizmo, Thing]
</code></pre>
<p><strong>Real-World Use Cases</strong>:</p>
<ul>
<li><strong>Skipping headers</strong>: Process CSV data after metadata rows</li>
<li><strong>Log analysis</strong>: Ignore initialisation messages, focus on runtime</li>
<li><strong>Pagination</strong>: Skip already-processed records in batch jobs</li>
<li><strong>Protocol parsing</strong>: Discard handshake, process payload</li>
</ul>
<pre><code class="language-java">// Skip configuration lines in log file
Traversal&lt;String, String&gt; runtimeLogs =
    StringTraversals.lined()
        .filtered(line -&gt; !line.startsWith("[CONFIG]"));

// Apply to log data
String logs = "[CONFIG] Database URL\n[CONFIG] Port\nINFO: System started\nERROR: Connection failed";
String result = Traversals.modify(runtimeLogs, String::toUpperCase, logs);
// Result: "[CONFIG] Database URL\n[CONFIG] Port\nINFO: SYSTEM STARTED\nERROR: CONNECTION FAILED"
</code></pre>
<h3 id="step-8-single-element-access-with-elementint"><a class="header" href="#step-8-single-element-access-with-elementint">Step 8: Single Element Access with <code>element(int)</code></a></h3>
<p>The <code>element()</code> method creates an <strong>affine traversal</strong> (0-1 cardinality) focusing on a single element at the given index. Unlike direct array access, it never throws <code>IndexOutOfBoundsException</code>.</p>
<pre><code class="language-java">// Focus on element at index 2
Traversal&lt;List&lt;Product&gt;, Product&gt; thirdProduct = ListTraversals.element(2);

List&lt;Product&gt; products = List.of(
    new Product("SKU001", "Widget", 10.0, 100),
    new Product("SKU002", "Gadget", 25.0, 50),
    new Product("SKU003", "Gizmo", 15.0, 75)
);

// Modify only the third product
List&lt;Product&gt; updated = Traversals.modify(
    thirdProduct,
    p -&gt; p.applyDiscount(0.2),
    products
);
// Only Gizmo discounted

// Extract the element (if present)
List&lt;Product&gt; element = Traversals.getAll(thirdProduct, products);
// Returns: [Gizmo]

// Out of bounds: gracefully returns empty
List&lt;Product&gt; outOfBounds = Traversals.getAll(
    ListTraversals.element(10),
    products
);
// Returns: [] (no exception)
</code></pre>
<p><strong>When to Use <code>element()</code> vs <code>Ixed</code></strong>:</p>
<ul>
<li><strong><code>element()</code></strong>: For composition with other traversals, when index is known at construction time</li>
<li><strong><code>Ixed</code></strong>: For dynamic indexed access, more general type class approach</li>
</ul>
<pre><code class="language-java">// Compose element() with nested structures
Traversal&lt;List&lt;List&lt;Product&gt;&gt;, Product&gt; secondListThirdProduct =
    ListTraversals.element(1)  // Second list
        .andThen(ListTraversals.element(2));  // Third product in that list

// Ixed for dynamic access
IxedInstances.listIxed().ix(userProvidedIndex).getOptional(products);
</code></pre>
<h3 id="combining-predicate-based-and-index-based-traversals"><a class="header" href="#combining-predicate-based-and-index-based-traversals">Combining Predicate-Based and Index-Based Traversals</a></h3>
<p>The real power emerges when mixing approaches:</p>
<pre><code class="language-java">// Take first 10 products where stock &gt; 0, then filter by price
Traversal&lt;List&lt;Product&gt;, Product&gt; topAffordableInStock =
    ListTraversals.taking(10)
        .andThen(ListTraversals.takingWhile(p -&gt; p.stock() &gt; 0))
        .filtered(p -&gt; p.price() &lt; 30.0);

// Skip warmup period, then take next 100 events
Traversal&lt;List&lt;Event&gt;, Event&gt; steadyState =
    ListTraversals.droppingWhile(e -&gt; e.isWarmup())
        .andThen(ListTraversals.taking(100));
</code></pre>
<hr />
<h2 id="edge-case-handling"><a class="header" href="#edge-case-handling">Edge Case Handling</a></h2>
<p>All limiting traversal methods handle edge cases gracefully and consistently:</p>
<div class="table-wrapper"><table><thead><tr><th>Edge Case</th><th>Behaviour</th><th>Rationale</th></tr></thead><tbody>
<tr><td><strong><code>n &lt; 0</code></strong></td><td>Treated as 0 (identity traversal)</td><td>Graceful degradation, no exceptions</td></tr>
<tr><td><strong><code>n &gt; list.size()</code></strong></td><td>Clamped to list bounds</td><td>Focus on all available elements</td></tr>
<tr><td><strong>Empty list</strong></td><td>Returns empty list unchanged</td><td>No elements to focus on</td></tr>
<tr><td><strong><code>from &gt;= to</code> in slicing</strong></td><td>Identity traversal (no focus)</td><td>Empty range semantics</td></tr>
<tr><td><strong>Negative <code>from</code> in slicing</strong></td><td>Clamped to 0</td><td>Start from beginning</td></tr>
</tbody></table>
</div>
<pre><code class="language-java">// Examples of edge case handling
List&lt;Integer&gt; numbers = List.of(1, 2, 3);

// n &gt; size: focuses on all elements
List&lt;Integer&gt; result1 = Traversals.getAll(ListTraversals.taking(100), numbers);
// Returns: [1, 2, 3]

// Negative n: identity (no focus)
List&lt;Integer&gt; result2 = Traversals.getAll(ListTraversals.taking(-5), numbers);
// Returns: []

// Inverted range: no focus
List&lt;Integer&gt; result3 = Traversals.getAll(ListTraversals.slicing(3, 1), numbers);
// Returns: []

// Empty list: safe operation
List&lt;Integer&gt; result4 = Traversals.modify(ListTraversals.taking(3), x -&gt; x * 2, List.of());
// Returns: []
</code></pre>
<p>This philosophy ensures <strong>no runtime exceptions</strong> from index bounds, making limiting traversals safe for dynamic data.</p>
<hr />
<h2 id="composing-limiting-traversals"><a class="header" href="#composing-limiting-traversals">Composing Limiting Traversals</a></h2>
<p>The real power emerges when you compose limiting traversals with other optics:</p>
<h3 id="with-lenses--deep-updates"><a class="header" href="#with-lenses--deep-updates">With Lenses – Deep Updates</a></h3>
<pre><code class="language-java">Traversal&lt;List&lt;Product&gt;, Product&gt; first5 = ListTraversals.taking(5);
Lens&lt;Product, Double&gt; priceLens = ProductLenses.price();

// Compose: first 5 products → their prices
Traversal&lt;List&lt;Product&gt;, Double&gt; first5Prices =
    first5.andThen(priceLens.asTraversal());

// Increase prices of first 5 products by 10%
List&lt;Product&gt; result = Traversals.modify(first5Prices, price -&gt; price * 1.1, products);
</code></pre>
<h3 id="with-filtered-traversals--conditional-slicing"><a class="header" href="#with-filtered-traversals--conditional-slicing">With Filtered Traversals – Conditional Slicing</a></h3>
<pre><code class="language-java">// First 10 products that are also low stock
Traversal&lt;List&lt;Product&gt;, Product&gt; first10LowStock =
    ListTraversals.taking(10).filtered(p -&gt; p.stock() &lt; 50);

// Restock only first 10 low-stock products
List&lt;Product&gt; restocked = Traversals.modify(
    first10LowStock,
    p -&gt; new Product(p.sku(), p.name(), p.price(), p.stock() + 100),
    products
);
</code></pre>
<h3 id="with-nested-structures--batch-processing"><a class="header" href="#with-nested-structures--batch-processing">With Nested Structures – Batch Processing</a></h3>
<pre><code class="language-java">// Focus on first 50 orders
Traversal&lt;List&lt;Order&gt;, Order&gt; first50Orders = ListTraversals.taking(50);

// Focus on all line items in those orders
Traversal&lt;List&lt;Order&gt;, LineItem&gt; first50OrderItems =
    first50Orders.andThen(OrderTraversals.items());

// Apply bulk discount to items in first 50 orders
List&lt;Order&gt; processed = Traversals.modify(
    first50OrderItems,
    item -&gt; new LineItem(item.product().applyDiscount(0.05), item.quantity()),
    orders
);
</code></pre>
<hr />
<h2 id="when-to-use-limiting-traversals-vs-other-approaches"><a class="header" href="#when-to-use-limiting-traversals-vs-other-approaches">When to Use Limiting Traversals vs Other Approaches</a></h2>
<h3 id="use-limiting-traversals-when"><a class="header" href="#use-limiting-traversals-when">Use Limiting Traversals When:</a></h3>
<ul>
<li><strong>Positional focus</strong> - You need to operate on elements by index position</li>
<li><strong>Structural preservation</strong> - Non-focused elements must remain in the list</li>
<li><strong>Composable pipelines</strong> - Building complex optic chains with lenses and prisms</li>
<li><strong>Immutable updates</strong> - Transforming portions whilst keeping data immutable</li>
<li><strong>Reusable logic</strong> - Define once, compose everywhere</li>
</ul>
<pre><code class="language-java">// Perfect: Declarative, composable, reusable
Traversal&lt;Catalogue, Double&gt; first10Prices =
    CatalogueLenses.products().asTraversal()
        .andThen(ListTraversals.taking(10))
        .andThen(ProductLenses.price().asTraversal());

Catalogue updated = Traversals.modify(first10Prices, p -&gt; p * 0.9, catalogue);
</code></pre>
<h3 id="use-stream-api-when"><a class="header" href="#use-stream-api-when">Use Stream API When:</a></h3>
<ul>
<li><strong>Terminal operations</strong> - Counting, finding, collecting to new structures</li>
<li><strong>Complex transformations</strong> - Multiple chained operations with sorting/grouping</li>
<li><strong>No structural preservation needed</strong> - You're extracting data, not updating in place</li>
<li><strong>Performance-critical paths</strong> - Minimal abstraction overhead</li>
</ul>
<pre><code class="language-java">// Better with streams: Complex aggregation
int totalStock = products.stream()
    .limit(100)
    .mapToInt(Product::stock)
    .sum();
</code></pre>
<h3 id="use-manual-loops-when"><a class="header" href="#use-manual-loops-when">Use Manual Loops When:</a></h3>
<ul>
<li><strong>Early termination with side effects</strong> - Need to break out of loop</li>
<li><strong>Index-dependent logic</strong> - Processing depends on knowing the exact index</li>
<li><strong>Imperative control flow</strong> - Complex branching based on position</li>
</ul>
<pre><code class="language-java">// Sometimes explicit indexing is clearest
for (int i = 0; i &lt; Math.min(10, products.size()); i++) {
    if (products.get(i).stock() == 0) {
        notifyOutOfStock(products.get(i), i);
        break;
    }
}
</code></pre>
<hr />
<h2 id="common-pitfalls"><a class="header" href="#common-pitfalls">Common Pitfalls</a></h2>
<h3 id="dont-do-this"><a class="header" href="#dont-do-this">Don't Do This:</a></h3>
<pre><code class="language-java">// Inefficient: Recreating traversals in loops
for (int page = 0; page &lt; totalPages; page++) {
    var slice = ListTraversals.slicing(page * 10, (page + 1) * 10);
    processPage(Traversals.getAll(slice, products));
}

// Confusing: Mixing with Stream operations unnecessarily
List&lt;Product&gt; result = Traversals.getAll(ListTraversals.taking(5), products)
    .stream()
    .limit(3)  // Why limit again? Already took 5!
    .collect(toList());

// Wrong expectation: Thinking it removes elements
Traversal&lt;List&lt;Product&gt;, Product&gt; first3 = ListTraversals.taking(3);
List&lt;Product&gt; modified = Traversals.modify(first3, Product::applyDiscount, products);
// modified.size() == products.size()! Structure preserved, not truncated

// Over-engineering: Using slicing for single element
Traversal&lt;List&lt;Product&gt;, Product&gt; atIndex5 = ListTraversals.slicing(5, 6);
// Consider using Ixed type class for single-element access instead
</code></pre>
<h3 id="do-this-instead"><a class="header" href="#do-this-instead">Do This Instead:</a></h3>
<pre><code class="language-java">// Efficient: Create traversal once, vary parameters
Traversal&lt;List&lt;Product&gt;, Product&gt; takeN(int n) {
    return ListTraversals.taking(n);
}
// Or store commonly used ones as constants
static final Traversal&lt;List&lt;Product&gt;, Product&gt; FIRST_PAGE = ListTraversals.taking(10);

// Clear: Keep operations at appropriate abstraction level
List&lt;Product&gt; firstFive = Traversals.getAll(ListTraversals.taking(5), products);
// If you need further processing, do it separately

// Correct expectation: Use getAll for extraction, modify for transformation
List&lt;Product&gt; onlyFirst5 = Traversals.getAll(first5, products);  // Extracts subset
List&lt;Product&gt; allWithFirst5Updated = Traversals.modify(first5, p -&gt; p.applyDiscount(0.1), products);  // Updates in place

// Right tool: Use Ixed for single indexed access
Optional&lt;Product&gt; fifth = IxedInstances.listIxed().ix(4).getOptional(products);
</code></pre>
<hr />
<h2 id="performance-notes"><a class="header" href="#performance-notes">Performance Notes</a></h2>
<p>Limiting traversals are optimised for efficiency:</p>
<ul>
<li><strong>Single pass</strong>: No intermediate list creation; slicing happens during traversal</li>
<li><strong>Structural sharing</strong>: Unchanged portions of the list are reused, not copied</li>
<li><strong>Lazy bounds checking</strong>: Index calculations are minimal and performed once</li>
<li><strong>No boxing overhead</strong>: Direct list operations without stream intermediaries</li>
<li><strong>Composable without penalty</strong>: Chaining with other optics adds no extra iteration</li>
</ul>
<p><strong>Best Practice</strong>: Store frequently-used limiting traversals as constants:</p>
<pre><code class="language-java">public class CatalogueOptics {
    // Pagination constants
    public static final int PAGE_SIZE = 20;

    public static Traversal&lt;List&lt;Product&gt;, Product&gt; page(int pageNum) {
        return ListTraversals.slicing(pageNum * PAGE_SIZE, (pageNum + 1) * PAGE_SIZE);
    }

    // Featured products (first 5)
    public static final Traversal&lt;Catalogue, Product&gt; FEATURED =
        CatalogueLenses.products().asTraversal()
            .andThen(ListTraversals.taking(5));

    // Latest additions (last 10)
    public static final Traversal&lt;Catalogue, Product&gt; LATEST =
        CatalogueLenses.products().asTraversal()
            .andThen(ListTraversals.takingLast(10));

    // Exclude promotional items at end
    public static final Traversal&lt;Catalogue, Product&gt; NON_PROMOTIONAL =
        CatalogueLenses.products().asTraversal()
            .andThen(ListTraversals.droppingLast(3));
}
</code></pre>
<hr />
<h2 id="real-world-example-e-commerce-pagination"><a class="header" href="#real-world-example-e-commerce-pagination">Real-World Example: E-Commerce Pagination</a></h2>
<p>Here's a comprehensive example demonstrating limiting traversals in a business context:</p>
<pre><code class="language-java">package org.higherkindedj.example.optics;

import org.higherkindedj.optics.*;
import org.higherkindedj.optics.util.*;
import java.util.*;

public class PaginationExample {

    public record Product(String sku, String name, double price, boolean featured) {
        Product applyDiscount(double pct) {
            return new Product(sku, name, price * (1 - pct), featured);
        }
    }

    public static void main(String[] args) {
        List&lt;Product&gt; catalogue = createCatalogue();

        System.out.println("=== E-COMMERCE PAGINATION WITH LIMITING TRAVERSALS ===\n");

        // --- Scenario 1: Basic Pagination ---
        System.out.println("--- Scenario 1: Paginated Product Display ---");

        int pageSize = 3;
        int totalPages = (int) Math.ceil(catalogue.size() / (double) pageSize);

        for (int page = 0; page &lt; totalPages; page++) {
            Traversal&lt;List&lt;Product&gt;, Product&gt; pageTraversal =
                ListTraversals.slicing(page * pageSize, (page + 1) * pageSize);

            List&lt;Product&gt; pageProducts = Traversals.getAll(pageTraversal, catalogue);
            System.out.printf("Page %d: %s%n", page + 1,
                pageProducts.stream().map(Product::name).toList());
        }

        // --- Scenario 2: Featured Products ---
        System.out.println("\n--- Scenario 2: Featured Products (First 3) ---");

        Traversal&lt;List&lt;Product&gt;, Product&gt; featured = ListTraversals.taking(3);
        List&lt;Product&gt; featuredProducts = Traversals.getAll(featured, catalogue);
        featuredProducts.forEach(p -&gt;
            System.out.printf("  %s - £%.2f%n", p.name(), p.price()));

        // --- Scenario 3: Apply Discount to Featured ---
        System.out.println("\n--- Scenario 3: 10% Discount on Featured ---");

        List&lt;Product&gt; withDiscount = Traversals.modify(featured, p -&gt; p.applyDiscount(0.1), catalogue);
        System.out.println("After discount on first 3:");
        withDiscount.forEach(p -&gt; System.out.printf("  %s: £%.2f%n", p.name(), p.price()));

        // --- Scenario 4: Exclude Last Items ---
        System.out.println("\n--- Scenario 4: All Except Last 2 (Clearance) ---");

        Traversal&lt;List&lt;Product&gt;, Product&gt; nonClearance = ListTraversals.droppingLast(2);
        List&lt;Product&gt; regularStock = Traversals.getAll(nonClearance, catalogue);
        System.out.println("Regular stock: " + regularStock.stream().map(Product::name).toList());

        System.out.println("\n=== PAGINATION COMPLETE ===");
    }

    private static List&lt;Product&gt; createCatalogue() {
        return List.of(
            new Product("SKU001", "Laptop", 999.99, true),
            new Product("SKU002", "Mouse", 29.99, false),
            new Product("SKU003", "Keyboard", 79.99, true),
            new Product("SKU004", "Monitor", 349.99, true),
            new Product("SKU005", "Webcam", 89.99, false),
            new Product("SKU006", "Headset", 149.99, false),
            new Product("SKU007", "USB Hub", 39.99, false),
            new Product("SKU008", "Desk Lamp", 44.99, false)
        );
    }
}
</code></pre>
<p><strong>Expected Output:</strong></p>
<pre><code>=== E-COMMERCE PAGINATION WITH LIMITING TRAVERSALS ===

--- Scenario 1: Paginated Product Display ---
Page 1: [Laptop, Mouse, Keyboard]
Page 2: [Monitor, Webcam, Headset]
Page 3: [USB Hub, Desk Lamp]

--- Scenario 2: Featured Products (First 3) ---
  Laptop - £999.99
  Mouse - £29.99
  Keyboard - £79.99

--- Scenario 3: 10% Discount on Featured ---
After discount on first 3:
  Laptop: £899.99
  Mouse: £26.99
  Keyboard: £71.99
  Monitor: £349.99
  Webcam: £89.99
  Headset: £149.99
  USB Hub: £39.99
  Desk Lamp: £44.99

--- Scenario 4: All Except Last 2 (Clearance) ---
Regular stock: [Laptop, Mouse, Keyboard, Monitor, Webcam, Headset]

=== PAGINATION COMPLETE ===
</code></pre>
<hr />
<h2 id="the-relationship-to-functional-programming-libraries"><a class="header" href="#the-relationship-to-functional-programming-libraries">The Relationship to Functional Programming Libraries</a></h2>
<p>For those familiar with functional programming, higher-kinded-j's limiting traversals are inspired by similar patterns in:</p>
<h3 id="haskells-lens-library"><a class="header" href="#haskells-lens-library">Haskell's Lens Library</a></h3>
<p>The <a href="https://hackage.haskell.org/package/lens-5.2.3/docs/Control-Lens-Traversal.html"><code>Control.Lens.Traversal</code></a> module provides:</p>
<pre><code class="language-haskell">taking :: Int -&gt; Traversal' [a] a
dropping :: Int -&gt; Traversal' [a] a
</code></pre>
<p>These create traversals that focus on the first/remaining elements, exactly what our <code>ListTraversals.taking()</code> and <code>dropping()</code> do.</p>
<h3 id="scalas-monocle-library"><a class="header" href="#scalas-monocle-library">Scala's Monocle Library</a></h3>
<p><a href="https://www.optics.dev/Monocle/">Monocle</a> provides similar index-based optics:</p>
<pre><code class="language-scala">import monocle.function.Index._

// Focus on element at index
val atIndex: Optional[List[A], A] = index(3)

// Take first n (via custom combinator)
val firstN: Traversal[List[A], A] = ...
</code></pre>
<h3 id="key-differences-in-higher-kinded-j"><a class="header" href="#key-differences-in-higher-kinded-j">Key Differences in Higher-Kinded-J</a></h3>
<ul>
<li><strong>Explicit Applicative instances</strong> rather than implicit type class resolution</li>
<li><strong>Java's type system</strong> requires more explicit composition steps</li>
<li><strong>Additional methods</strong> like <code>takingLast</code> and <code>droppingLast</code> not standard in Haskell lens</li>
<li><strong>Edge case handling</strong> follows Java conventions (no exceptions, graceful clamping)</li>
</ul>
<p><strong>Further Reading:</strong></p>
<ul>
<li><a href="https://hackage.haskell.org/package/lens-tutorial-1.0.4/docs/Control-Lens-Tutorial.html">Haskell Lens Tutorial</a> - Original inspiration for optics</li>
<li><a href="https://leanpub.com/optics-by-example">Optics By Example</a> by Chris Penner - Comprehensive book on optics in Haskell</li>
<li><a href="https://www.optics.dev/Monocle/">Monocle Documentation</a> - Scala optics library with similar patterns</li>
<li><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/stream/Stream.html">Java Stream API</a> - Comparison with <code>limit()</code> and <code>skip()</code></li>
</ul>
<hr />
<h2 id="summary-the-power-of-limiting-traversals"><a class="header" href="#summary-the-power-of-limiting-traversals">Summary: The Power of Limiting Traversals</a></h2>
<p>Limiting traversals bring <strong>positional focus</strong> into the heart of your optic compositions:</p>
<ul>
<li><strong><code>taking(n)</code></strong>: Focus on first n elements</li>
<li><strong><code>dropping(n)</code></strong>: Skip first n, focus on rest</li>
<li><strong><code>takingLast(n)</code></strong>: Focus on last n elements</li>
<li><strong><code>droppingLast(n)</code></strong>: Focus on all except last n</li>
<li><strong><code>slicing(from, to)</code></strong>: Focus on index range [from, to)</li>
</ul>
<p>These tools transform how you work with list portions in immutable data structures:</p>
<div class="table-wrapper"><table><thead><tr><th>Before (Imperative)</th><th>After (Declarative)</th></tr></thead><tbody>
<tr><td>Manual <code>subList()</code> with bounds checking</td><td>Single limiting traversal</td></tr>
<tr><td>Index manipulation breaking composition</td><td>Positional focus as part of optic chain</td></tr>
<tr><td>Explicit list reconstruction</td><td>Automatic structural preservation</td></tr>
<tr><td>Mix of "what" and "how"</td><td>Pure expression of intent</td></tr>
</tbody></table>
</div>
<p>By incorporating limiting traversals into your toolkit, you gain:</p>
<ul>
<li><strong>Expressiveness</strong>: Say "first 10 products" once, compose with other optics</li>
<li><strong>Safety</strong>: No <code>IndexOutOfBoundsException</code>; graceful edge case handling</li>
<li><strong>Composability</strong>: Chain with lenses, prisms, filtered traversals seamlessly</li>
<li><strong>Immutability</strong>: Structure preserved, only focused elements transformed</li>
<li><strong>Clarity</strong>: Business logic separate from index arithmetic</li>
</ul>
<p>Limiting traversals represent the natural evolution of optics for list manipulation: where Stream's <code>limit()</code> and <code>skip()</code> meet the composable, type-safe world of functional optics, all whilst maintaining full referential transparency and structural preservation.</p>
<hr />
<p><strong>Previous:</strong> <a href="common_data_structure_traversals.html">Common Data Structures</a>
<strong>Next:</strong> <a href="list_decomposition.html">List Decomposition</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../optics/common_data_structure_traversals.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../optics/list_decomposition.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../optics/common_data_structure_traversals.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../optics/list_decomposition.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../version-switcher.js"></script>
        <script src=".././theme/version-switcher.js"></script>
        <script src=".././theme/sidebar-nav-link.js"></script>


    </div>
    </body>
</html>
