<!DOCTYPE HTML>
<html lang="en" class="latte sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Spring Boot Integration - Higher-Kinded-J: Composable Effects and Advanced Optics for Java</title>


        <!-- Custom HTML head -->


            <meta name="description" content="The most comprehensive functional programming library for Java. Unify error handling, optional values, and immutable data navigation with the Effect Path API and Focus DSL. Features advanced optics with code generation for Java records, filtered traversals, indexed optics, and seamless Spring Boot integration.">


        <meta name="keywords" content="Higher-Kinded Types, Higher-Kinded-J, HKT, Java, Optics, Lens, Prism, Traversal, Iso, Affine, Focus DSL, Effect Path API, Functional Programming, Monad, Functor, Applicative, EitherPath, MaybePath, TryPath, ValidationPath, Java Records, Sealed Interface, Error Handling, Immutable Data">
        
        <meta property="og:title" content="Spring Boot Integration - Higher-Kinded-J: Composable Effects and Advanced Optics for Java">
            <meta property="og:description" content="The most comprehensive functional programming library for Java. Unify error handling, optional values, and immutable data navigation with the Effect Path API and Focus DSL. Features advanced optics with code generation for Java records, filtered traversals, indexed optics, and seamless Spring Boot integration.">
        <meta property="og:type" content="website">
        <meta property="og:url" content="https://higher-kinded-j.github.io/">
        <meta property="og:image" content="https://higher-kinded-j.github.io/preview.png">
        <meta property="og:image:width" content="1200">
        <meta property="og:image:height" content="630">
        <meta property="og:site_name" content="Higher-Kinded-J Documentation">
        <meta property="og:locale" content="en_GB">
        
        <meta name="twitter:card" content="summary_large_image">
        <meta name="twitter:title" content="Spring Boot Integration - Higher-Kinded-J: Composable Effects and Advanced Optics for Java">
        <meta name="twitter:description" content="Unifying Composable Effects and Advanced Optics for Java. Effect Path API, Focus DSL, and the most comprehensive optics implementation in the Java ecosystem.">
        <meta name="twitter:image" content="https://higher-kinded-j.github.io/preview.png">
        <meta name="twitter:image:alt" content="Higher-Kinded-J: Composable Effects and Advanced Optics for Java">
        <meta name="description" content="The most comprehensive functional programming library for Java. Unify error handling, optional values, and immutable data navigation with the Effect Path API and Focus DSL. Features advanced optics with code generation for Java records, filtered traversals, indexed optics, and seamless Spring Boot integration.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">
        <meta name="google-site-verification" content="X-xsiAq2cKMLOzh9dexUrX8Onx2h_YMUFgp5lHHUwSg" />
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href=".././mdbook-admonish.css">
        <link rel="stylesheet" href=".././theme/catppuccin.css">
        <link rel="stylesheet" href=".././theme/catppuccin-admonish.css">
        <link rel="stylesheet" href=".././theme/catppuccin-alerts.css">
        <link rel="stylesheet" href=".././theme/additional-hkj.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "latte";
            const default_dark_theme = "macchiato";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('latte')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="latte">Latte</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="frappe">Frappé</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="macchiato">Macchiato</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mocha">Mocha</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        <div class="version-selector-container">
                            <select id="version-selector" class="version-selector" aria-label="Select documentation version" title="Select documentation version">
                                <option value="">Loading versions...</option>
                            </select>
                        </div>
                    </div>

                    <h1 class="menu-title">Higher-Kinded-J: Composable Effects and Advanced Optics for Java</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/higher-kinded-j/higher-kinded-j" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/higher-kinded-j/higher-kinded-j/edit/main/hkj-book/src/spring/spring_boot_integration.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="spring-boot-integration-functional-patterns-for-enterprise-applications"><a class="header" href="#spring-boot-integration-functional-patterns-for-enterprise-applications">Spring Boot Integration: Functional Patterns for Enterprise Applications</a></h1>
<h2 id="bringing-type-safe-error-handling-to-your-rest-apis"><a class="header" href="#bringing-type-safe-error-handling-to-your-rest-apis"><em>Bringing Type-Safe Error Handling to Your REST APIs</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to use Either, Validated, and CompletableFuturePath as Spring controller return types</li>
<li>Zero-configuration setup with the hkj-spring-boot-starter</li>
<li>Automatic JSON serialisation with customisable formats</li>
<li>Monitoring functional operations with Spring Boot Actuator</li>
<li>Securing endpoints with functional error handling patterns</li>
<li>Building production-ready applications with explicit, typed errors</li>
<li>Testing functional controllers with MockMvc</li>
</ul>
</div>
</div>
<div id="admonition-example-application" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-application-title">
<div class="admonition-title">
<div id="admonition-example-application-title">
<p>Example Application</p>
</div>
<a class="admonition-anchor-link" href="#admonition-example-application"></a>
</div>
<div>
<p>A complete working example is available in the <a href="https://github.com/higher-kinded-j/higher-kinded-j/tree/main/hkj-spring/example">hkj-spring example module</a>. Run it with:</p>
<pre><code class="language-bash">./gradlew :hkj-spring:example:bootRun
</code></pre>
</div>
</div>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Building REST APIs with Spring Boot is straightforward, but error handling often becomes a source of complexity and inconsistency. Traditional exception-based approaches scatter error handling logic across <code>@ExceptionHandler</code> methods, lose type safety, and make it difficult to reason about what errors a given endpoint can produce.</p>
<p>The <strong>hkj-spring-boot-starter</strong> solves these problems by bringing functional programming patterns seamlessly into Spring applications. Return <code>Either&lt;Error, Data&gt;</code>, <code>Validated&lt;Errors, Data&gt;</code>, or <code>CompletableFuturePath</code> from your controllers, and the framework automatically handles the rest: converting functional types to appropriate HTTP responses whilst preserving type safety and composability.</p>
<p><strong>The key insight:</strong> Errors become explicit in your method signatures, not hidden in implementation details or exception hierarchies.</p>
<hr />
<h2 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h2>
<h3 id="step-1-add-the-dependency"><a class="header" href="#step-1-add-the-dependency">Step 1: Add the Dependency</a></h3>
<p>Add the starter to your Spring Boot project:</p>
<pre><code class="language-gradle">// build.gradle.kts
dependencies {
    implementation("io.github.higher-kinded-j:hkj-spring-boot-starter:LATEST_VERSION")
}
</code></pre>
<p>Or with Maven:</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;io.github.higher-kinded-j&lt;/groupId&gt;
    &lt;artifactId&gt;hkj-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;LATEST_VERSION&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="step-2-return-functional-types-from-controllers"><a class="header" href="#step-2-return-functional-types-from-controllers">Step 2: Return Functional Types from Controllers</a></h3>
<pre><code class="language-java">@RestController
@RequestMapping("/api/users")
public class UserController {

    @Autowired
    private UserService userService;

    @GetMapping("/{id}")
    public Either&lt;DomainError, User&gt; getUser(@PathVariable String id) {
        return userService.findById(id);
        // Right(user) → HTTP 200 with JSON body
        // Left(UserNotFoundError) → HTTP 404 with error details
    }

    @PostMapping
    public Validated&lt;List&lt;ValidationError&gt;, User&gt; createUser(@RequestBody UserRequest request) {
        return userService.validateAndCreate(request);
        // Valid(user) → HTTP 200 with user JSON
        // Invalid(errors) → HTTP 400 with all validation errors accumulated
    }
}
</code></pre>
<h3 id="step-3-run-your-application"><a class="header" href="#step-3-run-your-application">Step 3: Run Your Application</a></h3>
<p>That's it! The starter auto-configures everything:</p>
<ul>
<li>Either to HTTP response conversion with automatic status code mapping</li>
<li>Validated to HTTP response with error accumulation</li>
<li>CompletableFuturePath support for async operations</li>
<li>JSON serialisation for functional types</li>
<li>Customisable error type to HTTP status code mapping</li>
</ul>
<hr />
<h2 id="why-use-functional-error-handling"><a class="header" href="#why-use-functional-error-handling">Why Use Functional Error Handling?</a></h2>
<h3 id="the-problem-with-exceptions"><a class="header" href="#the-problem-with-exceptions">The Problem with Exceptions</a></h3>
<p>Traditional Spring Boot error handling relies on exceptions and <code>@ExceptionHandler</code> methods:</p>
<pre><code class="language-java">@GetMapping("/{id}")
public User getUser(@PathVariable String id) {
    return userService.findById(id);  // What errors can this throw?
}

@ExceptionHandler(UserNotFoundException.class)
public ResponseEntity&lt;ErrorResponse&gt; handleNotFound(UserNotFoundException ex) {
    return ResponseEntity.status(404).body(new ErrorResponse(ex.getMessage()));
}

@ExceptionHandler(ValidationException.class)
public ResponseEntity&lt;ErrorResponse&gt; handleValidation(ValidationException ex) {
    return ResponseEntity.status(400).body(new ErrorResponse(ex.getMessage()));
}
</code></pre>
<p><strong>Problems:</strong></p>
<ul>
<li>Errors are invisible in the method signature</li>
<li>No compile-time guarantee that all errors are handled</li>
<li>Exception handlers become a catch-all for unrelated errors</li>
<li>Difficult to compose operations whilst maintaining error information</li>
<li>Testing requires catching exceptions or using <code>@ExceptionHandler</code> integration</li>
</ul>
<h3 id="the-functional-solution"><a class="header" href="#the-functional-solution">The Functional Solution</a></h3>
<p>With functional error handling, errors become explicit and composable:</p>
<pre><code class="language-java">@GetMapping("/{id}")
public Either&lt;DomainError, User&gt; getUser(@PathVariable String id) {
    return userService.findById(id);  // Clear: returns User or DomainError
}

@GetMapping("/{id}/orders")
public Either&lt;DomainError, List&lt;Order&gt;&gt; getUserOrders(@PathVariable String id) {
    return userService.findById(id)
        .flatMap(orderService::getOrdersForUser);  // Compose operations naturally
}
</code></pre>
<p><strong>Benefits:</strong></p>
<ul>
<li>Errors are explicit in the type signature</li>
<li>Compiler ensures error handling at call sites</li>
<li>Functional composition with <code>map</code>, <code>flatMap</code>, <code>fold</code></li>
<li>Automatic HTTP response conversion</li>
<li>Easy to test, no exception catching required</li>
</ul>
<hr />
<h2 id="core-features"><a class="header" href="#core-features">Core Features</a></h2>
<h3 id="1-either-success-or-typed-error"><a class="header" href="#1-either-success-or-typed-error">1. Either: Success or Typed Error</a></h3>
<p><code>Either&lt;L, R&gt;</code> represents a computation that can succeed with a <code>Right(value)</code> or fail with a <code>Left(error)</code>.</p>
<h4 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h4>
<pre><code class="language-java">@RestController
@RequestMapping("/api/users")
public class UserController {

    @GetMapping("/{id}")
    public Either&lt;DomainError, User&gt; getUser(@PathVariable String id) {
        return userService.findById(id);
    }
}
</code></pre>
<p><strong>Response Mapping:</strong></p>
<ul>
<li><code>Right(user)</code> → HTTP 200 with JSON: <code>{"id": "1", "email": "alice@example.com", ...}</code></li>
<li><code>Left(UserNotFoundError)</code> → HTTP 404 with JSON: <code>{"success": false, "error": {"type": "UserNotFoundError", ...}}</code></li>
</ul>
<h4 id="error-type--http-status-mapping"><a class="header" href="#error-type--http-status-mapping">Error Type → HTTP Status Mapping</a></h4>
<p>The framework automatically maps error types to HTTP status codes by examining class names:</p>
<pre><code class="language-java">public sealed interface DomainError permits
    UserNotFoundError,      // Contains "NotFound" → 404
    ValidationError,        // Contains "Validation" → 400
    AuthorizationError,     // Contains "Authorization" → 403
    AuthenticationError {}  // Contains "Authentication" → 401

// Custom errors default to 400 Bad Request
</code></pre>
<h4 id="composing-operations"><a class="header" href="#composing-operations">Composing Operations</a></h4>
<pre><code class="language-java">@GetMapping("/{userId}/orders/{orderId}")
public Either&lt;DomainError, Order&gt; getUserOrder(
        @PathVariable String userId,
        @PathVariable String orderId) {

    return userService.findById(userId)
        .flatMap(user -&gt; orderService.findById(orderId))
        .flatMap(order -&gt; orderService.verifyOwnership(order, userId));

    // Short-circuits on first Left
}
</code></pre>
<p>See the <a href="../monads/either_monad.html">Either Monad documentation</a> for comprehensive usage patterns.</p>
<hr />
<h3 id="2-validated-accumulating-multiple-errors"><a class="header" href="#2-validated-accumulating-multiple-errors">2. Validated: Accumulating Multiple Errors</a></h3>
<p><code>Validated&lt;E, A&gt;</code> is designed for validation scenarios where you want to accumulate <strong>all</strong> errors, not just the first one.</p>
<h4 id="basic-usage-1"><a class="header" href="#basic-usage-1">Basic Usage</a></h4>
<pre><code class="language-java">@PostMapping
public Validated&lt;List&lt;ValidationError&gt;, User&gt; createUser(@RequestBody UserRequest request) {
    return userService.validateAndCreate(request);
}
</code></pre>
<p><strong>Response Mapping:</strong></p>
<ul>
<li><code>Valid(user)</code> → HTTP 200 with JSON: <code>{"id": "1", "email": "alice@example.com", ...}</code></li>
<li><code>Invalid(errors)</code> → HTTP 400 with JSON: <code>{"success": false, "errors": [{"field": "email", "message": "Invalid format"}, ...]}</code></li>
</ul>
<h4 id="validation-example"><a class="header" href="#validation-example">Validation Example</a></h4>
<pre><code class="language-java">@Service
public class UserService {

    public Validated&lt;List&lt;ValidationError&gt;, User&gt; validateAndCreate(UserRequest request) {
        return Validated.validateAll(
            validateEmail(request.email()),
            validateName(request.firstName()),
            validateName(request.lastName())
        ).map(tuple -&gt; new User(
            UUID.randomUUID().toString(),
            tuple._1(),  // email
            tuple._2(),  // firstName
            tuple._3()   // lastName
        ));
    }

    private Validated&lt;ValidationError, String&gt; validateEmail(String email) {
        if (email == null || !email.contains("@")) {
            return Validated.invalid(new ValidationError("email", "Invalid email format"));
        }
        return Validated.valid(email);
    }

    private Validated&lt;ValidationError, String&gt; validateName(String name) {
        if (name == null || name.trim().isEmpty()) {
            return Validated.invalid(new ValidationError("name", "Name cannot be empty"));
        }
        return Validated.valid(name);
    }
}
</code></pre>
<p><strong>Key Difference from Either:</strong></p>
<ul>
<li><code>Either</code> short-circuits on first error (fail-fast)</li>
<li><code>Validated</code> accumulates all errors (fail-slow)</li>
</ul>
<p>See the <a href="../monads/validated_monad.html">Validated Monad documentation</a> for detailed usage.</p>
<hr />
<h3 id="3-completablefuturepath-async-operations-with-typed-errors"><a class="header" href="#3-completablefuturepath-async-operations-with-typed-errors">3. CompletableFuturePath: Async Operations with Typed Errors</a></h3>
<p><code>CompletableFuturePath&lt;A&gt;</code> wraps asynchronous computation in the Effect Path API, allowing you to compose async operations with <code>map</code>, <code>via</code>, and <code>recover</code>.</p>
<h4 id="basic-usage-2"><a class="header" href="#basic-usage-2">Basic Usage</a></h4>
<pre><code class="language-java">@GetMapping("/{id}/async")
public CompletableFuturePath&lt;User&gt; getUserAsync(@PathVariable String id) {
    return asyncUserService.findByIdAsync(id);
    // Automatically handles async to sync HTTP response conversion
}
</code></pre>
<h4 id="async-composition"><a class="header" href="#async-composition">Async Composition</a></h4>
<pre><code class="language-java">@Service
public class AsyncOrderService {

    public CompletableFuturePath&lt;OrderSummary&gt; processOrderAsync(
            String userId, OrderRequest request) {

        return asyncUserService.findByIdAsync(userId)
            .via(user -&gt; asyncInventoryService.checkAvailability(request.items()))
            .via(availability -&gt; asyncPaymentService.processPayment(request.payment()))
            .map(payment -&gt; new OrderSummary(userId, request, payment));

        // Each step runs asynchronously
        // Composes naturally with other Path types
    }
}
</code></pre>
<p><strong>Response Handling:</strong>
The framework uses Spring's async request processing:</p>
<ol>
<li>Controller returns <code>CompletableFuturePath</code></li>
<li>Framework extracts the underlying <code>CompletableFuture</code></li>
<li>Spring's async mechanism handles the future</li>
<li>When complete, result is converted to HTTP response</li>
</ol>
<p>See the <a href="../effect/path_types.html">Effect Path API documentation</a> for comprehensive examples.</p>
<hr />
<h2 id="json-serialisation"><a class="header" href="#json-serialisation">JSON Serialisation</a></h2>
<p>The starter provides flexible JSON serialisation for functional types.</p>
<h3 id="configuration"><a class="header" href="#configuration">Configuration</a></h3>
<p>Configure serialisation format in <code>application.yml</code>:</p>
<pre><code class="language-yaml">hkj:
  jackson:
    custom-serializers-enabled: true  # Enable custom serialisers (default: true)
    either-format: TAGGED             # TAGGED, UNWRAPPED, or DIRECT
    validated-format: TAGGED          # TAGGED, UNWRAPPED, or DIRECT
    maybe-format: TAGGED              # TAGGED, UNWRAPPED, or DIRECT
</code></pre>
<h3 id="serialisation-formats"><a class="header" href="#serialisation-formats">Serialisation Formats</a></h3>
<h4 id="tagged-default"><a class="header" href="#tagged-default">TAGGED (Default)</a></h4>
<p>Wraps the value with metadata indicating success/failure:</p>
<pre><code class="language-json">// Right(user)
{
  "success": true,
  "value": {
    "id": "1",
    "email": "alice@example.com"
  }
}

// Left(error)
{
  "success": false,
  "error": {
    "type": "UserNotFoundError",
    "userId": "999"
  }
}
</code></pre>
<h4 id="unwrapped"><a class="header" href="#unwrapped">UNWRAPPED</a></h4>
<p>Returns just the value or error without wrapper:</p>
<pre><code class="language-json">// Right(user)
{
  "id": "1",
  "email": "alice@example.com"
}

// Left(error)
{
  "type": "UserNotFoundError",
  "userId": "999"
}
</code></pre>
<h4 id="direct"><a class="header" href="#direct">DIRECT</a></h4>
<p>Uses Either's default <code>toString()</code> representation (useful for debugging):</p>
<pre><code class="language-json">"Right(value=User[id=1, email=alice@example.com])"
</code></pre>
<p>For complete serialisation details, see <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-spring/JACKSON_SERIALIZATION.md">hkj-spring/JACKSON_SERIALIZATION.md</a>.</p>
<hr />
<h2 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h2>
<h3 id="web-configuration"><a class="header" href="#web-configuration">Web Configuration</a></h3>
<pre><code class="language-yaml">hkj:
  web:
    either-path-enabled: true               # Enable EitherPath handler (default: true)
    validated-path-enabled: true            # Enable ValidationPath handler (default: true)
    completable-future-path-enabled: true   # Enable CompletableFuturePath handler (default: true)
    default-error-status: 400               # Default HTTP status for unmapped errors
</code></pre>
<h3 id="async-executor-configuration"><a class="header" href="#async-executor-configuration">Async Executor Configuration</a></h3>
<p>For CompletableFuturePath operations, configure the async thread pool:</p>
<pre><code class="language-yaml">hkj:
  async:
    core-pool-size: 10                 # Minimum threads
    max-pool-size: 20                  # Maximum threads
    queue-capacity: 100                # Queue size before rejection
    thread-name-prefix: "hkj-async-"   # Thread naming pattern
</code></pre>
<p>For complete configuration options, see <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-spring/CONFIGURATION.md">hkj-spring/CONFIGURATION.md</a>.</p>
<hr />
<h2 id="real-world-examples"><a class="header" href="#real-world-examples">Real-World Examples</a></h2>
<h3 id="example-1-user-management-api"><a class="header" href="#example-1-user-management-api">Example 1: User Management API</a></h3>
<p>A typical CRUD API with validation and error handling:</p>
<pre><code class="language-java">@RestController
@RequestMapping("/api/users")
public class UserController {

    @Autowired
    private UserService userService;

    // Get all users (always succeeds)
    @GetMapping
    public List&lt;User&gt; getAllUsers() {
        return userService.findAll();
    }

    // Get single user (may not exist)
    @GetMapping("/{id}")
    public Either&lt;DomainError, User&gt; getUser(@PathVariable String id) {
        return userService.findById(id);
        // Right(user) → 200 OK
        // Left(UserNotFoundError) → 404 Not Found
    }

    // Create user (validate all fields)
    @PostMapping
    public Validated&lt;List&lt;ValidationError&gt;, User&gt; createUser(@RequestBody UserRequest request) {
        return userService.validateAndCreate(request);
        // Valid(user) → 200 OK
        // Invalid([errors...]) → 400 Bad Request with all validation errors
    }

    // Update user (may not exist + validation)
    @PutMapping("/{id}")
    public Either&lt;DomainError, User&gt; updateUser(
            @PathVariable String id,
            @RequestBody UserRequest request) {

        return userService.findById(id)
            .flatMap(existingUser -&gt;
                userService.validateUpdate(request)
                    .toEither()  // Convert Validated to Either
                    .map(validRequest -&gt; userService.update(id, validRequest)));

        // Combines existence check + validation
    }

    // Delete user (may not exist)
    @DeleteMapping("/{id}")
    public Either&lt;DomainError, Void&gt; deleteUser(@PathVariable String id) {
        return userService.delete(id);
        // Right(null) → 200 OK
        // Left(UserNotFoundError) → 404 Not Found
    }

    // Get user's email (composition example)
    @GetMapping("/{id}/email")
    public Either&lt;DomainError, String&gt; getUserEmail(@PathVariable String id) {
        return userService.findById(id)
            .map(User::email);

        // Automatic error propagation
    }
}
</code></pre>
<h3 id="example-2-async-order-processing"><a class="header" href="#example-2-async-order-processing">Example 2: Async Order Processing</a></h3>
<p>Processing orders asynchronously with multiple external services:</p>
<pre><code class="language-java">@RestController
@RequestMapping("/api/orders")
public class OrderController {

    @Autowired
    private AsyncOrderService orderService;

    @PostMapping
    public CompletableFuturePath&lt;Order&gt; createOrder(@RequestBody OrderRequest request) {
        return orderService.processOrder(request);
        // Each step runs asynchronously:
        // 1. Validate user
        // 2. Check inventory
        // 3. Process payment
        // 4. Create order record

        // Composes naturally with other Path types
        // Returns 200 on success, appropriate error code on failure
    }

    @GetMapping("/{id}")
    public CompletableFuturePath&lt;Order&gt; getOrder(@PathVariable String id) {
        return orderService.findByIdAsync(id);
    }
}

@Service
public class AsyncOrderService {

    @Autowired
    private AsyncUserService userService;
    @Autowired
    private AsyncInventoryService inventoryService;
    @Autowired
    private AsyncPaymentService paymentService;
    @Autowired
    private OrderRepository orderRepository;

    public CompletableFuturePath&lt;Order&gt; processOrder(OrderRequest request) {
        return userService.findByIdAsync(request.userId())
            .via(user -&gt; inventoryService.checkAvailabilityAsync(request.items()))
            .via(availability -&gt; {
                if (!availability.allAvailable()) {
                    return Path.completableFuture(
                        CompletableFuture.failedFuture(
                            new OutOfStockException(availability.unavailableItems())
                        )
                    );
                }
                return Path.completableFuture(
                    CompletableFuture.completedFuture(availability)
                );
            })
            .via(availability -&gt; paymentService.processPaymentAsync(request.payment()))
            .map(payment -&gt; createOrderRecord(request, payment));
    }
}
</code></pre>
<p>For complete working examples, see the <a href="https://github.com/higher-kinded-j/higher-kinded-j/tree/main/hkj-spring/example">hkj-spring example module</a>.</p>
<hr />
<h2 id="spring-security-integration"><a class="header" href="#spring-security-integration">Spring Security Integration</a></h2>
<p>The hkj-spring-boot-starter provides optional Spring Security integration with functional error handling patterns.</p>
<h3 id="enabling-security-integration"><a class="header" href="#enabling-security-integration">Enabling Security Integration</a></h3>
<pre><code class="language-yaml">hkj:
  security:
    enabled: true                       # Enable functional security (default: false)
    validated-user-details: true        # Use Validated for user loading
    either-authentication: true         # Use Either for authentication
    either-authorization: true          # Use Either for authorisation
</code></pre>
<h3 id="functional-user-details-service"><a class="header" href="#functional-user-details-service">Functional User Details Service</a></h3>
<p>Use <code>Validated</code> to accumulate authentication errors:</p>
<pre><code class="language-java">@Service
public class CustomUserDetailsService implements ValidatedUserDetailsService {

    @Override
    public Validated&lt;List&lt;SecurityError&gt;, UserDetails&gt; loadUserByUsername(String username) {
        return Validated.validateAll(
            validateUsername(username),
            validateAccountStatus(username),
            validateCredentials(username)
        ).map(tuple -&gt; new User(
            tuple._1(),  // username
            tuple._2(),  // password
            tuple._3()   // authorities
        ));

        // Returns ALL validation errors at once
        // e.g., "Username too short" + "Account locked"
    }
}
</code></pre>
<h3 id="functional-authentication"><a class="header" href="#functional-authentication">Functional Authentication</a></h3>
<p>Use <code>Either</code> for JWT authentication with typed errors:</p>
<pre><code class="language-java">@Component
public class JwtAuthenticationConverter {

    public Either&lt;AuthenticationError, Authentication&gt; convert(Jwt jwt) {
        return extractUsername(jwt)
            .flatMap(this::validateToken)
            .flatMap(this::extractAuthorities)
            .map(authorities -&gt; new JwtAuthenticationToken(jwt, authorities));

        // Short-circuits on first error
    }
}
</code></pre>
<p>For complete security integration details, see <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-spring/SECURITY.md">hkj-spring/SECURITY.md</a>.</p>
<hr />
<h2 id="monitoring-with-spring-boot-actuator"><a class="header" href="#monitoring-with-spring-boot-actuator">Monitoring with Spring Boot Actuator</a></h2>
<p>Track functional programming patterns in production with built-in Actuator integration.</p>
<h3 id="enabling-actuator-integration"><a class="header" href="#enabling-actuator-integration">Enabling Actuator Integration</a></h3>
<pre><code class="language-yaml">hkj:
  actuator:
    metrics:
      enabled: true                     # Enable metrics tracking
    health:
      async-executor:
        enabled: true                   # Monitor CompletableFuturePath thread pool

management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,hkj
</code></pre>
<h3 id="available-metrics"><a class="header" href="#available-metrics">Available Metrics</a></h3>
<p>The starter automatically tracks:</p>
<ul>
<li><strong>EitherPath metrics:</strong> Success/error counts and rates</li>
<li><strong>ValidationPath metrics:</strong> Valid/invalid counts and error distributions</li>
<li><strong>CompletableFuturePath metrics:</strong> Async operation durations and success rates</li>
<li><strong>Thread pool health:</strong> Active threads, queue size, saturation</li>
</ul>
<h3 id="custom-hkj-endpoint"><a class="header" href="#custom-hkj-endpoint">Custom HKJ Endpoint</a></h3>
<p>Access functional programming metrics via the custom actuator endpoint:</p>
<pre><code class="language-bash">curl http://localhost:8080/actuator/hkj
</code></pre>
<p>Response:</p>
<pre><code class="language-json">{
  "configuration": {
    "web": {
      "eitherPathEnabled": true,
      "validatedPathEnabled": true,
      "completableFuturePathEnabled": true
    },
    "jackson": {
      "eitherFormat": "TAGGED",
      "validatedFormat": "TAGGED"
    }
  },
  "metrics": {
    "eitherPath": {
      "successCount": 1547,
      "errorCount": 123,
      "totalCount": 1670,
      "successRate": 0.926
    },
    "validationPath": {
      "validCount": 892,
      "invalidCount": 45,
      "totalCount": 937,
      "validRate": 0.952
    },
    "completableFuturePath": {
      "successCount": 234,
      "errorCount": 12,
      "totalCount": 246,
      "successRate": 0.951
    }
  }
}
</code></pre>
<h3 id="prometheus-integration"><a class="header" href="#prometheus-integration">Prometheus Integration</a></h3>
<p>Export metrics to Prometheus for monitoring and alerting:</p>
<pre><code class="language-yaml">management:
  metrics:
    export:
      prometheus:
        enabled: true
</code></pre>
<p>Example Prometheus queries:</p>
<pre><code class="language-promql"># EitherPath error rate
rate(hkj_either_path_invocations_total{result="error"}[5m])

# CompletableFuturePath p95 latency
histogram_quantile(0.95,
  rate(hkj_completable_future_path_async_duration_seconds_bucket[5m]))

# ValidationPath success rate
sum(rate(hkj_validation_path_invocations_total{result="valid"}[5m]))
  / sum(rate(hkj_validation_path_invocations_total[5m]))
</code></pre>
<p>For complete Actuator integration details, see <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-spring/ACTUATOR.md">hkj-spring/ACTUATOR.md</a>.</p>
<hr />
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<p>Testing functional controllers is straightforward with MockMvc.</p>
<h3 id="testing-either-responses"><a class="header" href="#testing-either-responses">Testing Either Responses</a></h3>
<pre><code class="language-java">@SpringBootTest
@AutoConfigureMockMvc
class UserControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    void shouldReturn200ForExistingUser() throws Exception {
        mockMvc.perform(get("/api/users/1"))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.success").value(true))
            .andExpect(jsonPath("$.value.id").value("1"))
            .andExpect(jsonPath("$.value.email").value("alice@example.com"));
    }

    @Test
    void shouldReturn404ForMissingUser() throws Exception {
        mockMvc.perform(get("/api/users/999"))
            .andExpect(status().isNotFound())
            .andExpect(jsonPath("$.success").value(false))
            .andExpect(jsonPath("$.error.type").value("UserNotFoundError"));
    }
}
</code></pre>
<h3 id="testing-validated-responses"><a class="header" href="#testing-validated-responses">Testing Validated Responses</a></h3>
<pre><code class="language-java">@Test
void shouldAccumulateValidationErrors() throws Exception {
    String invalidRequest = """
        {
          "email": "invalid",
          "firstName": "",
          "lastName": "x"
        }
        """;

    mockMvc.perform(post("/api/users")
            .contentType(MediaType.APPLICATION_JSON)
            .content(invalidRequest))
        .andExpect(status().isBadRequest())
        .andExpect(jsonPath("$.success").value(false))
        .andExpect(jsonPath("$.errors").isArray())
        .andExpect(jsonPath("$.errors.length()").value(3));  // All errors returned
}
</code></pre>
<h3 id="testing-completablefuturepath-async-responses"><a class="header" href="#testing-completablefuturepath-async-responses">Testing CompletableFuturePath Async Responses</a></h3>
<pre><code class="language-java">@Test
void shouldHandleAsyncCompletableFuturePathResponse() throws Exception {
    MvcResult result = mockMvc.perform(get("/api/users/1/async"))
        .andExpect(request().asyncStarted())  // Verify async started
        .andReturn();

    mockMvc.perform(asyncDispatch(result))   // Dispatch async result
        .andExpect(status().isOk())
        .andExpect(jsonPath("$.id").value("1"));
}
</code></pre>
<h3 id="unit-testing-services"><a class="header" href="#unit-testing-services">Unit Testing Services</a></h3>
<p>Services returning functional types are easy to test without mocking frameworks:</p>
<pre><code class="language-java">class UserServiceTest {

    private UserService service;

    @Test
    void shouldReturnRightWhenUserExists() {
        Either&lt;DomainError, User&gt; result = service.findById("1");

        assertThat(result.isRight()).isTrue();
        User user = result.getRight();
        assertThat(user.id()).isEqualTo("1");
    }

    @Test
    void shouldReturnLeftWhenUserNotFound() {
        Either&lt;DomainError, User&gt; result = service.findById("999");

        assertThat(result.isLeft()).isTrue();
        DomainError error = result.getLeft();
        assertThat(error).isInstanceOf(UserNotFoundError.class);
    }

    @Test
    void shouldAccumulateValidationErrors() {
        UserRequest invalid = new UserRequest("bad-email", "", "x");

        Validated&lt;List&lt;ValidationError&gt;, User&gt; result =
            service.validateAndCreate(invalid);

        assertThat(result.isInvalid()).isTrue();
        List&lt;ValidationError&gt; errors = result.getErrors();
        assertThat(errors).hasSize(3);
    }
}
</code></pre>
<p>For comprehensive testing examples, see <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-spring/example/TESTING.md">hkj-spring/example/TESTING.md</a>.</p>
<hr />
<h2 id="migration-guide"><a class="header" href="#migration-guide">Migration Guide</a></h2>
<p>Migrating from exception-based error handling to functional patterns is straightforward and can be done incrementally.</p>
<p>See the <a href="./migrating_to_functional_errors.html">Migration Guide</a> for a complete step-by-step walkthrough of:</p>
<ul>
<li>Converting exception-throwing methods to Either</li>
<li>Replacing <code>@ExceptionHandler</code> methods with functional patterns</li>
<li>Migrating validation logic to Validated</li>
<li>Converting async operations to CompletableFuturePath</li>
<li>Maintaining backwards compatibility during migration</li>
</ul>
<hr />
<h2 id="architecture-and-design"><a class="header" href="#architecture-and-design">Architecture and Design</a></h2>
<h3 id="auto-configuration"><a class="header" href="#auto-configuration">Auto-Configuration</a></h3>
<p>The starter uses Spring Boot 4.x auto-configuration:</p>
<pre><code class="language-java">@AutoConfiguration
@ConditionalOnClass({DispatcherServlet.class, Kind.class})
@ConditionalOnWebApplication(type = SERVLET)
public class HkjWebMvcAutoConfiguration implements WebMvcConfigurer {

    @Override
    public void addReturnValueHandlers(List&lt;HandlerMethodReturnValueHandler&gt; handlers) {
        handlers.add(new EitherPathReturnValueHandler(properties));
        handlers.add(new ValidationPathReturnValueHandler(properties));
        handlers.add(new CompletableFuturePathReturnValueHandler(properties));
    }
}
</code></pre>
<p>Auto-configuration activates when:</p>
<ul>
<li><code>higher-kinded-j-core</code> is on the classpath</li>
<li>Spring Web MVC is present</li>
<li>Application is a servlet web app</li>
</ul>
<h3 id="return-value-handlers"><a class="header" href="#return-value-handlers">Return Value Handlers</a></h3>
<p>Each functional type has a dedicated handler:</p>
<ol>
<li><strong>EitherPathReturnValueHandler:</strong> Converts <code>EitherPath&lt;L, R&gt;</code> to HTTP responses</li>
<li><strong>ValidationPathReturnValueHandler:</strong> Converts <code>ValidationPath&lt;E, A&gt;</code> to HTTP responses</li>
<li><strong>CompletableFuturePathReturnValueHandler:</strong> Unwraps <code>CompletableFuturePath&lt;A&gt;</code> for async processing</li>
</ol>
<p>Handlers are registered automatically and integrated seamlessly with Spring's request processing lifecycle.</p>
<h3 id="non-invasive-design"><a class="header" href="#non-invasive-design">Non-Invasive Design</a></h3>
<p>The integration doesn't modify existing Spring Boot behaviour:</p>
<ul>
<li>Standard Spring MVC types work unchanged</li>
<li>Exception handling still functions normally</li>
<li>Can be disabled via configuration</li>
<li>Coexists with traditional <code>ResponseEntity</code> endpoints</li>
</ul>
<hr />
<h2 id="frequently-asked-questions"><a class="header" href="#frequently-asked-questions">Frequently Asked Questions</a></h2>
<h3 id="can-i-mix-functional-and-traditional-exception-handling"><a class="header" href="#can-i-mix-functional-and-traditional-exception-handling">Can I mix functional and traditional exception handling?</a></h3>
<p>Yes! The integration is non-invasive. You can use <code>EitherPath</code>, <code>ValidationPath</code>, and <code>CompletableFuturePath</code> alongside traditional <code>ResponseEntity</code> and exception-based endpoints in the same application.</p>
<h3 id="does-this-work-with-spring-webflux"><a class="header" href="#does-this-work-with-spring-webflux">Does this work with Spring WebFlux?</a></h3>
<p>Currently, the starter supports Spring Web MVC (servlet-based). WebFlux support is planned for a future release.</p>
<h3 id="can-i-customise-the-error--http-status-mapping"><a class="header" href="#can-i-customise-the-error--http-status-mapping">Can I customise the error → HTTP status mapping?</a></h3>
<p>Yes. Implement a custom return value handler or use the configuration properties to set default status codes. See <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-spring/CONFIGURATION.md">CONFIGURATION.md</a> for details.</p>
<h3 id="how-does-performance-compare-to-exceptions"><a class="header" href="#how-does-performance-compare-to-exceptions">How does performance compare to exceptions?</a></h3>
<p>Functional error handling is generally faster than exception-throwing for expected error cases, as it avoids stack trace generation and exception propagation overhead. For success cases, performance is equivalent.</p>
<h3 id="can-i-use-this-with-spring-data-repositories"><a class="header" href="#can-i-use-this-with-spring-data-repositories">Can I use this with Spring Data repositories?</a></h3>
<p>Yes. Wrap repository calls in your service layer:</p>
<pre><code class="language-java">@Service
public class UserService {

    @Autowired
    private UserRepository repository;

    public Either&lt;DomainError, User&gt; findById(String id) {
        return repository.findById(id)
            .map(Either::&lt;DomainError, User&gt;right)
            .orElseGet(() -&gt; Either.left(new UserNotFoundError(id)));
    }
}
</code></pre>
<h3 id="does-this-work-with-validation-annotations-valid"><a class="header" href="#does-this-work-with-validation-annotations-valid">Does this work with validation annotations (<code>@Valid</code>)?</a></h3>
<p>The integration focuses on functional validation patterns. For Spring's <code>@Valid</code> integration, you can convert <code>BindingResult</code> to <code>Validated</code> in your controllers.</p>
<hr />
<h2 id="related-documentation"><a class="header" href="#related-documentation">Related Documentation</a></h2>
<ul>
<li><a href="../monads/either_monad.html">Either Monad</a> - Comprehensive Either usage</li>
<li><a href="../monads/validated_monad.html">Validated Monad</a> - Validation patterns</li>
<li><a href="../effect/path_types.html">Effect Path API</a> - Path types and async composition</li>
<li><a href="./migrating_to_functional_errors.html">Migration Guide</a> - Step-by-step migration</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-spring/CONFIGURATION.md">Configuration Guide</a> - Complete configuration options</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-spring/JACKSON_SERIALIZATION.md">Jackson Serialisation</a> - JSON format details</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-spring/SECURITY.md">Security Integration</a> - Spring Security patterns</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-spring/ACTUATOR.md">Actuator Monitoring</a> - Metrics and health checks</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-spring/example/TESTING.md">Testing Guide</a> - Testing patterns</li>
</ul>
<hr />
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>The hkj-spring-boot-starter brings functional programming patterns seamlessly into Spring Boot applications:</p>
<ul>
<li><strong>Return functional types from controllers:</strong> EitherPath, ValidationPath, CompletableFuturePath</li>
<li><strong>Automatic HTTP response conversion:</strong> No boilerplate required</li>
<li><strong>Explicit, type-safe error handling:</strong> Errors in method signatures</li>
<li><strong>Composable operations:</strong> Functional composition with map/via/flatMap</li>
<li><strong>Zero configuration:</strong> Auto-configuration handles everything</li>
<li><strong>Production-ready:</strong> Actuator metrics, security integration</li>
<li><strong>Easy to test:</strong> No exception mocking required</li>
</ul>
<p>Get started today by adding the dependency and returning functional types from your controllers. The framework handles the rest!</p>
<hr />
<p><strong>Previous:</strong> <a href="ch_intro.html">Introduction</a>
<strong>Next:</strong> <a href="migrating_to_functional_errors.html">Migrating to Functional Errors</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../spring/ch_intro.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../spring/migrating_to_functional_errors.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../spring/ch_intro.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../spring/migrating_to_functional_errors.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../version-switcher.js"></script>
        <script src=".././theme/version-switcher.js"></script>
        <script src=".././theme/sidebar-nav-link.js"></script>


    </div>
    </body>
</html>
