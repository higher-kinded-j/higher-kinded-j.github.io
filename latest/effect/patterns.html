<!DOCTYPE HTML>
<html lang="en" class="latte sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Patterns and Recipes - Higher-Kinded Types and Optics for Java</title>


        <!-- Custom HTML head -->


            <meta name="description" content="Explore Higher-Kinded Types (HKTs) and Optcs in Java with the Higher-Kinded-J library. Learn about Functors, Applicatives, Monads, Transformers, practical functional patterns, and how to write cleaner, more composable Java code for your projects using Optics.">


        <meta name="keywords" content="Higher-Kinded Types, Higher-Kinded-J, Higher-Kinded Java, Higher Kinded Java, HKT, Java, Optics, Lens, Prism, Traversal, Iso, Functional Programming, Monad, Functor, Applicative, Transformer, Monoid, Traverse, higherkindedj">
        
        <meta property="og:title" content="Patterns and Recipes - Higher-Kinded Types and Optics for Java"> 
            <meta property="og:description" content="Explore Higher-Kinded Types (HKTs) and Optcs in Java with the Higher-Kinded-J library. Learn about Functors, Applicatives, Monads, Transformers, practical functional patterns, and how to write cleaner, more composable Java code for your projects using Optics.">
        <meta property="og:type" content="website">
        <meta property="og:url" content="https://higher-kinded-j.github.io/"> 
        
        <meta property="og:image" content="https://higher-kinded-j.github.io/preview.png" />
        <meta property="og:site_name" content="Higher-Kinded-J Documentation" />
        
        
        <meta name="twitter:card" content="summary_large_image" /> <meta name="twitter:title" content="Patterns and Recipes - Higher-Kinded Types and Optics for Java - Higher-Kinded-J" />
        <meta name="twitter:description" content="Bringing Higher-Kinded Types and Optics to Java functional patterns" />
        <meta name="twitter:image" content="https://higher-kinded-j.github.io/preview.png" />
        <meta name="description" content="Explore Higher-Kinded Types (HKTs) and Optcs in Java with the Higher-Kinded-J library. Learn about Functors, Applicatives, Monads, Transformers, practical functional patterns, and how to write cleaner, more composable Java code for your projects using Optics.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">
        <meta name="google-site-verification" content="X-xsiAq2cKMLOzh9dexUrX8Onx2h_YMUFgp5lHHUwSg" />
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href=".././mdbook-admonish.css">
        <link rel="stylesheet" href=".././theme/catppuccin.css">
        <link rel="stylesheet" href=".././theme/catppuccin-admonish.css">
        <link rel="stylesheet" href=".././theme/catppuccin-alerts.css">
        <link rel="stylesheet" href=".././theme/additional-hkj.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "latte";
            const default_dark_theme = "macchiato";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('latte')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="latte">Latte</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="frappe">Frapp√©</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="macchiato">Macchiato</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mocha">Mocha</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        <div class="version-selector-container">
                            <select id="version-selector" class="version-selector" aria-label="Select documentation version" title="Select documentation version">
                                <option value="">Loading versions...</option>
                            </select>
                        </div>
                    </div>

                    <h1 class="menu-title">Higher-Kinded Types and Optics for Java</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/higher-kinded-j/higher-kinded-j" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/higher-kinded-j/higher-kinded-j/edit/main/hkj-book/src/effect/patterns.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="patterns-and-recipes"><a class="header" href="#patterns-and-recipes">Patterns and Recipes</a></h1>
<p>Every application faces the same challenges: validating input, orchestrating services, handling errors gracefully, and testing complex workflows. This chapter shows how the Effect Path API addresses these challenges with reusable patterns.</p>
<p>The patterns here are not academic exercises. They come from real codebases where tangled error handling was replaced with clear, composable pipelines. Each pattern solves a specific problem that you will recognise from your own projects.</p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>Validation pipeline patterns for single fields and combined validations</li>
<li>Service layer patterns for repositories and chained service calls</li>
<li>IO effect patterns for resource management and composing effects</li>
<li>Error handling strategies: enrichment, recovery with logging, circuit breakers</li>
<li>Testing patterns for Path-returning methods</li>
<li>Integration patterns with existing code</li>
</ul>
</div>
</div>
<h2 id="validation-pipelines"><a class="header" href="#validation-pipelines">Validation Pipelines</a></h2>
<p>User input cannot be trusted. Every field might be missing, malformed, or malicious. Traditional validation scatters null checks and conditionals throughout your code. The Path API lets you build validation as composable pipelines where each rule is a small, testable function.</p>
<h3 id="single-field-validation"><a class="header" href="#single-field-validation">Single Field Validation</a></h3>
<p><strong>The pattern:</strong> Each field gets its own validation function that returns a Path. Success carries the validated value (possibly transformed); failure carries an error message.</p>
<pre><code class="language-java">private EitherPath&lt;String, String&gt; validateEmail(String email) {
    return switch (email) {
        case null -&gt; Path.left("Email is required");
        case String e when e.isBlank() -&gt; Path.left("Email is required");
        case String e when !e.contains("@") -&gt; Path.left("Email must contain @");
        case String e when !e.contains(".") -&gt; Path.left("Email must contain a domain");
        case String e -&gt; Path.right(e.toLowerCase().trim());
    };
}
</code></pre>
<h3 id="combining-validations"><a class="header" href="#combining-validations">Combining Validations</a></h3>
<p><strong>The pattern:</strong> When multiple fields must all be valid to construct an object, use <code>zipWith</code> to combine them. The first error stops processing (fail-fast behaviour).</p>
<pre><code class="language-java">record User(String name, String email, int age) {}

EitherPath&lt;String, User&gt; validateUser(UserInput input) {
    EitherPath&lt;String, String&gt; name = validateName(input.name());
    EitherPath&lt;String, String&gt; email = validateEmail(input.email());
    EitherPath&lt;String, Integer&gt; age = validateAge(input.age());

    return name.zipWith3(email, age, User::new);
}
</code></pre>
<p><strong>Why this works:</strong> <code>zipWith3</code> only calls <code>User::new</code> if all three validations succeed. If any fails, the error propagates immediately.</p>
<h3 id="nested-validation"><a class="header" href="#nested-validation">Nested Validation</a></h3>
<pre><code class="language-java">record Registration(User user, Address address) {}

EitherPath&lt;String, Registration&gt; validateRegistration(RegistrationInput input) {
    // Validate user
    EitherPath&lt;String, User&gt; userValidation = validateUser(input.user());

    // Validate address
    EitherPath&lt;String, Address&gt; addressValidation =
        validateStreet(input.street())
            .zipWith3(
                validateCity(input.city()),
                validateZipCode(input.zipCode()),
                Address::new);

    // Combine
    return userValidation.zipWith(addressValidation, Registration::new);
}
</code></pre>
<div id="admonition-accumulating-all-errors" class="admonition admonish-tip" role="note" aria-labelledby="admonition-accumulating-all-errors-title">
<div class="admonition-title">
<div id="admonition-accumulating-all-errors-title">
<p>Accumulating All Errors</p>
</div>
<a class="admonition-anchor-link" href="#admonition-accumulating-all-errors"></a>
</div>
<div>
<p>For user-facing forms where you want to show <em>all</em> validation errors at once, use <code>ValidationPath</code> with <code>zipWithAccum</code> instead of <code>EitherPath</code> with <code>zipWith</code>. See <a href="path_types.html#validationpath">ValidationPath</a> for details.</p>
</div>
</div>
<hr />
<h2 id="service-layer-patterns"><a class="header" href="#service-layer-patterns">Service Layer Patterns</a></h2>
<p>Service layers orchestrate multiple operations: fetching data, applying business rules, calling external services. Each step might fail, and each failure needs different handling. The Path API makes this orchestration explicit and composable.</p>
<h3 id="repository-pattern"><a class="header" href="#repository-pattern">Repository Pattern</a></h3>
<p><strong>The problem:</strong> Repositories return optional values (user might not exist), but services need to turn "not found" into meaningful errors.</p>
<pre><code class="language-java">public class UserRepository {
    // Returns Maybe - absence is expected
    public Maybe&lt;User&gt; findById(String id) {
        return Maybe.fromOptional(jdbcTemplate.queryForOptional(...));
    }

    public Maybe&lt;User&gt; findByEmail(String email) {
        return Maybe.fromOptional(jdbcTemplate.queryForOptional(...));
    }
}

public class UserService {
    private final UserRepository repository;

    // Returns EitherPath - errors are meaningful
    public EitherPath&lt;UserError, User&gt; getUserById(String id) {
        return Path.maybe(repository.findById(id))
            .toEitherPath(() -&gt; new UserError.NotFound(id));
    }

    public EitherPath&lt;UserError, User&gt; getUserByEmail(String email) {
        return Path.maybe(repository.findByEmail(email))
            .toEitherPath(() -&gt; new UserError.NotFound(email));
    }
}
</code></pre>
<h3 id="chained-service-calls"><a class="header" href="#chained-service-calls">Chained Service Calls</a></h3>
<pre><code class="language-java">public class OrderService {
    private final UserService users;
    private final InventoryService inventory;
    private final PaymentService payments;

    public EitherPath&lt;OrderError, Order&gt; placeOrder(String userId, List&lt;Item&gt; items) {
        return users.getUserById(userId)
            .mapError(OrderError::fromUserError)
            .via(user -&gt; inventory.reserve(items)
                .mapError(OrderError::fromInventoryError))
            .via(reservation -&gt; payments.charge(user, reservation.total())
                .mapError(OrderError::fromPaymentError))
            .via(payment -&gt; createOrder(user, items, payment));
    }
}
</code></pre>
<h3 id="service-with-fallbacks"><a class="header" href="#service-with-fallbacks">Service with Fallbacks</a></h3>
<pre><code class="language-java">public class ConfigService {
    public EitherPath&lt;ConfigError, Config&gt; loadConfig() {
        return Path.either(loadFromFile())
            .recoverWith(e -&gt; {
                log.warn("File config failed: {}", e.getMessage());
                return Path.either(loadFromEnvironment());
            })
            .recoverWith(e -&gt; {
                log.warn("Env config failed: {}", e.getMessage());
                return Path.right(Config.defaults());
            });
    }
}
</code></pre>
<hr />
<h2 id="io-effect-patterns"><a class="header" href="#io-effect-patterns">IO Effect Patterns</a></h2>
<h3 id="resource-management"><a class="header" href="#resource-management">Resource Management</a></h3>
<pre><code class="language-java">public class FileProcessor {
    public IOPath&lt;ProcessResult&gt; processFile(Path path) {
        return Path.io(() -&gt; {
                var reader = new BufferedReader(new FileReader(path.toFile()));
                return reader;
            })
            .via(reader -&gt; Path.io(() -&gt; processContent(reader)))
            .ensuring(() -&gt; {
                // Cleanup runs regardless of success/failure
                log.debug("Processing complete for: {}", path);
            });
    }
}
</code></pre>
<h3 id="composing-effects"><a class="header" href="#composing-effects">Composing Effects</a></h3>
<pre><code class="language-java">public class DataPipeline {
    public IOPath&lt;Report&gt; generateReport(ReportRequest request) {
        return Path.io(() -&gt; log.info("Starting report generation"))
            .then(() -&gt; Path.io(() -&gt; fetchData(request)))
            .via(data -&gt; Path.io(() -&gt; transformData(data)))
            .via(transformed -&gt; Path.io(() -&gt; aggregateResults(transformed)))
            .via(aggregated -&gt; Path.io(() -&gt; formatReport(aggregated)))
            .peek(report -&gt; log.info("Report generated: {} rows", report.rowCount()));
    }
}
</code></pre>
<h3 id="parallel-io-conceptual"><a class="header" href="#parallel-io-conceptual">Parallel IO (Conceptual)</a></h3>
<pre><code class="language-java">// While IOPath itself doesn't parallelize, you can use zipWith
// to express independent computations:
IOPath&lt;CombinedData&gt; fetchAll() {
    IOPath&lt;UserData&gt; users = Path.io(() -&gt; fetchUsers());
    IOPath&lt;ProductData&gt; products = Path.io(() -&gt; fetchProducts());
    IOPath&lt;OrderData&gt; orders = Path.io(() -&gt; fetchOrders());

    return users.zipWith3(products, orders, CombinedData::new);
}
</code></pre>
<hr />
<h2 id="error-handling-strategies"><a class="header" href="#error-handling-strategies">Error Handling Strategies</a></h2>
<h3 id="error-enrichment"><a class="header" href="#error-enrichment">Error Enrichment</a></h3>
<pre><code class="language-java">public class EnrichedErrorHandler {
    public &lt;A&gt; EitherPath&lt;DetailedError, A&gt; withContext(
            EitherPath&lt;Error, A&gt; path,
            String operation,
            Map&lt;String, Object&gt; context) {

        return path.mapError(error -&gt; new DetailedError(
            error,
            operation,
            context,
            Instant.now()
        ));
    }
}

// Usage
return withContext(
    userService.getUser(id),
    "getUser",
    Map.of("userId", id, "requestId", requestId)
);
</code></pre>
<h3 id="error-recovery-with-logging"><a class="header" href="#error-recovery-with-logging">Error Recovery with Logging</a></h3>
<pre><code class="language-java">public &lt;A&gt; EitherPath&lt;Error, A&gt; withRecoveryLogging(
        EitherPath&lt;Error, A&gt; path,
        A fallback,
        String operation) {

    return path.recover(error -&gt; {
        log.warn("Operation {} failed: {}. Using fallback.", operation, error);
        return fallback;
    });
}
</code></pre>
<h3 id="circuit-breaker-pattern"><a class="header" href="#circuit-breaker-pattern">Circuit Breaker Pattern</a></h3>
<pre><code class="language-java">public class CircuitBreaker&lt;E, A&gt; {
    private final AtomicInteger failures = new AtomicInteger(0);
    private final int threshold;
    private final Supplier&lt;EitherPath&lt;E, A&gt;&gt; fallback;

    public EitherPath&lt;E, A&gt; execute(Supplier&lt;EitherPath&lt;E, A&gt;&gt; operation) {
        if (failures.get() &gt;= threshold) {
            return fallback.get();
        }

        return operation.get()
            .peek(success -&gt; failures.set(0))
            .recoverWith(error -&gt; {
                failures.incrementAndGet();
                return Path.left(error);
            });
    }
}
</code></pre>
<hr />
<h2 id="testing-patterns"><a class="header" href="#testing-patterns">Testing Patterns</a></h2>
<p>Path-returning methods are inherently testable. The explicit success/failure encoding means you can verify both happy paths and error cases without exception handling in your tests. The lawful behaviour of Path types also enables property-based testing that catches edge cases you might not think to test manually.</p>
<h3 id="testing-success-and-failure-paths"><a class="header" href="#testing-success-and-failure-paths">Testing Success and Failure Paths</a></h3>
<p><strong>The pattern:</strong> Call <code>.run()</code> to extract the underlying type, then assert on its state. Test both the success case and relevant failure cases.</p>
<pre><code class="language-java">@Test
void shouldReturnUserWhenFound() {
    // Given
    when(repository.findById("123")).thenReturn(Maybe.just(testUser));

    // When
    EitherPath&lt;UserError, User&gt; result = service.getUserById("123");

    // Then
    assertThat(result.run().isRight()).isTrue();
    assertThat(result.run().getRight()).isEqualTo(testUser);
}

@Test
void shouldReturnErrorWhenNotFound() {
    // Given
    when(repository.findById("123")).thenReturn(Maybe.nothing());

    // When
    EitherPath&lt;UserError, User&gt; result = service.getUserById("123");

    // Then
    assertThat(result.run().isLeft()).isTrue();
    assertThat(result.run().getLeft()).isInstanceOf(UserError.NotFound.class);
}
</code></pre>
<h3 id="testing-error-propagation"><a class="header" href="#testing-error-propagation">Testing Error Propagation</a></h3>
<p><strong>The problem:</strong> When chaining multiple operations, you need to verify that errors from any step propagate correctly.</p>
<p><strong>The pattern:</strong> Create inputs that fail at specific steps and verify the error emerges unchanged.</p>
<pre><code class="language-java">@Test
void shouldPropagateFirstError() {
    // Given validation that fails on name
    EitherPath&lt;String, String&gt; invalidName = Path.left("Name too short");
    EitherPath&lt;String, String&gt; validEmail = Path.right("test@example.com");

    // When combining
    EitherPath&lt;String, User&gt; result = invalidName.zipWith(validEmail, User::new);

    // Then first error is returned (not swallowed or transformed)
    assertThat(result.run().getLeft()).isEqualTo("Name too short");
}

@Test
void shouldPropagateErrorThroughChain() {
    // Given a chain where the second step fails
    EitherPath&lt;String, Integer&gt; result =
        Path.right("hello")
            .via(s -&gt; Path.left("Error in step 2"))
            .via(x -&gt; Path.right(42));  // Never reached

    // Then the error from step 2 propagates
    assertThat(result.run().getLeft()).isEqualTo("Error in step 2");
}
</code></pre>
<h3 id="testing-with-mocked-dependencies"><a class="header" href="#testing-with-mocked-dependencies">Testing with Mocked Dependencies</a></h3>
<p><strong>The pattern:</strong> Mock repository and service dependencies to return specific Path values, then verify the orchestration logic.</p>
<pre><code class="language-java">@Test
void shouldCombineUserAndOrderData() {
    // Given
    when(userService.getUser(userId)).thenReturn(Path.right(testUser));
    when(orderService.getOrders(testUser)).thenReturn(Path.right(testOrders));

    // When
    EitherPath&lt;Error, UserWithOrders&gt; result =
        compositeService.getUserWithOrders(userId);

    // Then
    assertThat(result.run().isRight()).isTrue();
    UserWithOrders data = result.run().getRight();
    assertThat(data.user()).isEqualTo(testUser);
    assertThat(data.orders()).isEqualTo(testOrders);
}

@Test
void shouldFailIfUserServiceFails() {
    // Given
    when(userService.getUser(userId))
        .thenReturn(Path.left(new Error.UserNotFound(userId)));

    // When
    EitherPath&lt;Error, UserWithOrders&gt; result =
        compositeService.getUserWithOrders(userId);

    // Then - order service should never be called
    verify(orderService, never()).getOrders(any());
    assertThat(result.run().isLeft()).isTrue();
}
</code></pre>
<h3 id="property-based-testing"><a class="header" href="#property-based-testing">Property-Based Testing</a></h3>
<p><strong>The pattern:</strong> Use property-based testing (with jqwik or similar) to verify that Path types obey their laws across many random inputs. This catches edge cases that example-based tests miss.</p>
<pre><code class="language-java">@Property
void functorIdentityLaw(@ForAll @StringLength(min = 1, max = 100) String value) {
    // Law: path.map(identity) == path
    MaybePath&lt;String&gt; path = Path.just(value);
    MaybePath&lt;String&gt; result = path.map(Function.identity());

    assertThat(result.run()).isEqualTo(path.run());
}

@Property
void monadLeftIdentity(
        @ForAll @IntRange(min = -100, max = 100) int value,
        @ForAll("intToMaybeStringFunctions") Function&lt;Integer, MaybePath&lt;String&gt;&gt; f) {

    // Law: Path.just(a).via(f) == f(a)
    MaybePath&lt;String&gt; leftSide = Path.just(value).via(f);
    MaybePath&lt;String&gt; rightSide = f.apply(value);

    assertThat(leftSide.run()).isEqualTo(rightSide.run());
}

@Property
void recoverAlwaysSucceeds(@ForAll String errorMessage, @ForAll String fallback) {
    // Property: recover always produces a success
    EitherPath&lt;String, String&gt; failed = Path.left(errorMessage);
    EitherPath&lt;String, String&gt; recovered = failed.recover(e -&gt; fallback);

    assertThat(recovered.run().isRight()).isTrue();
    assertThat(recovered.run().getRight()).isEqualTo(fallback);
}
</code></pre>
<h3 id="testing-iopath-effects"><a class="header" href="#testing-iopath-effects">Testing IOPath Effects</a></h3>
<p><strong>The problem:</strong> IOPath defers execution until <code>run()</code> is called. You need to verify both that the effect is properly deferred and that it executes correctly.</p>
<pre><code class="language-java">@Test
void shouldDeferExecution() {
    AtomicInteger callCount = new AtomicInteger(0);
    IOPath&lt;Integer&gt; io = Path.io(() -&gt; callCount.incrementAndGet());

    // Effect not yet executed
    assertThat(callCount.get()).isEqualTo(0);

    // Execute
    int result = io.unsafeRun();

    // Now executed exactly once
    assertThat(callCount.get()).isEqualTo(1);
    assertThat(result).isEqualTo(1);
}

@Test
void shouldCaptureExceptionInRunSafe() {
    IOPath&lt;String&gt; failing = Path.io(() -&gt; {
        throw new RuntimeException("test error");
    });

    Try&lt;String&gt; result = failing.runSafe();

    assertThat(result.isFailure()).isTrue();
    assertThat(result.getCause().getMessage()).isEqualTo("test error");
}
</code></pre>
<hr />
<h2 id="integration-with-existing-code"><a class="header" href="#integration-with-existing-code">Integration with Existing Code</a></h2>
<p>Real projects do not start with a blank slate. You have existing code that throws exceptions, returns <code>Optional</code>, or uses other patterns. The Path API provides bridges to work with this code without rewriting everything.</p>
<h3 id="wrapping-exception-throwing-apis"><a class="header" href="#wrapping-exception-throwing-apis">Wrapping Exception-Throwing APIs</a></h3>
<p><strong>The problem:</strong> Legacy code throws exceptions, but you want to use Path composition.</p>
<p><strong>The solution:</strong> Use <code>Path.tryOf</code> to capture exceptions as <code>TryPath</code> failures.</p>
<pre><code class="language-java">public class LegacyWrapper {
    private final LegacyService legacy;

    public TryPath&lt;Data&gt; fetchData(String id) {
        return Path.tryOf(() -&gt; legacy.fetchData(id));  // May throw
    }

    public EitherPath&lt;ServiceError, Data&gt; fetchDataSafe(String id) {
        return Path.tryOf(() -&gt; legacy.fetchData(id))
            .toEitherPath(ex -&gt; new ServiceError("Fetch failed", ex));
    }
}
</code></pre>
<h3 id="wrapping-optional-returning-apis"><a class="header" href="#wrapping-optional-returning-apis">Wrapping Optional-returning APIs</a></h3>
<pre><code class="language-java">public class OptionalWrapper {
    private final ModernService modern;

    public MaybePath&lt;User&gt; findUser(String id) {
        Optional&lt;User&gt; result = modern.findUser(id);
        return Path.maybe(Maybe.fromOptional(result));
    }
}
</code></pre>
<h3 id="exposing-to-non-path-consumers"><a class="header" href="#exposing-to-non-path-consumers">Exposing to Non-Path Consumers</a></h3>
<pre><code class="language-java">public class ServiceAdapter {
    private final PathBasedService service;

    // For consumers that expect Optional
    public Optional&lt;User&gt; findUser(String id) {
        return service.findUser(id).run().toOptional();
    }

    // For consumers that expect exceptions
    public User getUser(String id) throws UserNotFoundException {
        Either&lt;UserError, User&gt; result = service.getUser(id).run();
        if (result.isLeft()) {
            throw new UserNotFoundException(result.getLeft().message());
        }
        return result.getRight();
    }
}
</code></pre>
<hr />
<h2 id="common-pitfalls"><a class="header" href="#common-pitfalls">Common Pitfalls</a></h2>
<p>The Path API is straightforward, but a few patterns can trip up newcomers. These pitfalls come from treating Paths like regular values when they are actually descriptions of computations.</p>
<h3 id="pitfall-1-unnecessary-conversions"><a class="header" href="#pitfall-1-unnecessary-conversions">Pitfall 1: Unnecessary Conversions</a></h3>
<p><strong>The issue:</strong> Converting between path types repeatedly wastes effort and obscures intent.</p>
<pre><code class="language-java">// Bad: Converting back and forth
Path.maybe(findUser(id))
    .toEitherPath(() -&gt; error)
    .toMaybePath()  // Why?
    .toEitherPath(() -&gt; error);  // Wasteful

// Good: Convert once
Path.maybe(findUser(id))
    .toEitherPath(() -&gt; error);
</code></pre>
<h3 id="pitfall-2-forgetting-to-run"><a class="header" href="#pitfall-2-forgetting-to-run">Pitfall 2: Forgetting to Run</a></h3>
<p><strong>The issue:</strong> Paths are lazy descriptions. Without calling <code>.run()</code>, nothing actually happens.</p>
<pre><code class="language-java">// Bug: path is never executed
void processUser(String id) {
    Path.maybe(findUser(id))
        .map(this::processUser);  // Nothing happens!
}

// Correct: extract the result
void processUser(String id) {
    Path.maybe(findUser(id))
        .map(this::processUser)
        .run();  // Now it executes
}
</code></pre>
<h3 id="pitfall-3-side-effects-in-map"><a class="header" href="#pitfall-3-side-effects-in-map">Pitfall 3: Side Effects in map</a></h3>
<p><strong>The issue:</strong> The <code>map</code> function should be pure (no side effects). Side effects in <code>map</code> break referential transparency and can lead to surprising behaviour.</p>
<pre><code class="language-java">// Bad: Side effect in map
path.map(user -&gt; {
    database.save(user);  // Side effect!
    return user;
});

// Good: Use peek for side effects
path.peek(user -&gt; database.save(user));

// Or use IOPath for deferred effects
Path.io(() -&gt; database.save(user));
</code></pre>
<hr />
<h2 id="quick-reference"><a class="header" href="#quick-reference">Quick Reference</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Pattern</th><th>Use Case</th><th>Example</th></tr></thead><tbody>
<tr><td>Validation</td><td>Combine validations</td><td><code>name.zipWith(email, User::new)</code></td></tr>
<tr><td>Service chain</td><td>Dependent calls</td><td><code>path.via(x -&gt; nextService(x))</code></td></tr>
<tr><td>Fallback</td><td>Default on error</td><td><code>path.recover(e -&gt; default)</code></td></tr>
<tr><td>Error transform</td><td>Change error type</td><td><code>path.mapError(ApiError::new)</code></td></tr>
<tr><td>Type conversion</td><td>Change path type</td><td><code>path.toEitherPath(err)</code></td></tr>
<tr><td>Debug</td><td>Add logging</td><td><code>path.peek(x -&gt; log(x))</code></td></tr>
<tr><td>Resource</td><td>Cleanup</td><td><code>path.ensuring(() -&gt; cleanup())</code></td></tr>
</tbody></table>
</div>
<hr />
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>The Effect Path API provides a consistent vocabulary for working with effectful computations:</p>
<ul>
<li><strong>Create</strong> paths with <code>Path.just()</code>, <code>Path.right()</code>, <code>Path.tryOf()</code>, <code>Path.io()</code>, <code>Path.valid()</code></li>
<li><strong>Transform</strong> with <code>map()</code></li>
<li><strong>Chain</strong> with <code>via()</code> for dependent computations</li>
<li><strong>Combine</strong> with <code>zipWith()</code> for independent computations (fail-fast)</li>
<li><strong>Accumulate</strong> with <code>zipWithAccum()</code> for validation (collect all errors)</li>
<li><strong>Convert</strong> between types with <code>toEitherPath()</code>, <code>toValidationPath()</code>, etc.</li>
<li><strong>Handle errors</strong> with <code>recover()</code>, <code>recoverWith()</code>, <code>mapError()</code></li>
<li><strong>Extract</strong> with <code>run()</code>, <code>getOrElse()</code>, <code>unsafeRun()</code></li>
</ul>
<p>The patterns in this chapter demonstrate how these operations compose to solve real-world problems while keeping code clear and maintainable.</p>
<div id="admonition-see-also" class="admonition admonish-tip" role="note" aria-labelledby="admonition-see-also-title">
<div class="admonition-title">
<div id="admonition-see-also-title">
<p>See Also</p>
</div>
<a class="admonition-anchor-link" href="#admonition-see-also"></a>
</div>
<div>
<ul>
<li><a href="../monads/validated_monad.html">Validated Monad</a> - Accumulating validation errors</li>
<li><a href="../functional/monad_error.html">MonadError</a> - The type class behind error recovery</li>
<li><a href="../monads/io_monad.html">IO Monad</a> - Deferred effect execution</li>
</ul>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="conversions.html">Type Conversions</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../effect/conversions.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../transformers/ch_intro.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../effect/conversions.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../transformers/ch_intro.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../version-switcher.js"></script>
        <script src=".././theme/version-switcher.js"></script>
        <script src=".././theme/sidebar-nav-link.js"></script>


    </div>
    </body>
</html>
