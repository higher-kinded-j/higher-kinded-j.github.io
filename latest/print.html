<!DOCTYPE HTML>
<html lang="en" class="latte sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Higher-Kinded-J: Composable Effects and Advanced Optics for Java</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->


            <meta name="description" content="The most comprehensive functional programming library for Java. Unify error handling, optional values, and immutable data navigation with the Effect Path API and Focus DSL. Features advanced optics with code generation for Java records, filtered traversals, indexed optics, and seamless Spring Boot integration.">


        <meta name="keywords" content="Higher-Kinded Types, Higher-Kinded-J, HKT, Java, Optics, Lens, Prism, Traversal, Iso, Affine, Focus DSL, Effect Path API, Functional Programming, Monad, Functor, Applicative, EitherPath, MaybePath, TryPath, ValidationPath, Java Records, Sealed Interface, Error Handling, Immutable Data">
        
        <meta property="og:title" content="Higher-Kinded-J: Composable Effects and Advanced Optics for Java">
            <meta property="og:description" content="The most comprehensive functional programming library for Java. Unify error handling, optional values, and immutable data navigation with the Effect Path API and Focus DSL. Features advanced optics with code generation for Java records, filtered traversals, indexed optics, and seamless Spring Boot integration.">
        <meta property="og:type" content="website">
        <meta property="og:url" content="https://higher-kinded-j.github.io/">
        <meta property="og:image" content="https://higher-kinded-j.github.io/preview.png">
        <meta property="og:image:width" content="1200">
        <meta property="og:image:height" content="630">
        <meta property="og:site_name" content="Higher-Kinded-J Documentation">
        <meta property="og:locale" content="en_GB">
        
        <meta name="twitter:card" content="summary_large_image">
        <meta name="twitter:title" content="Higher-Kinded-J: Composable Effects and Advanced Optics for Java">
        <meta name="twitter:description" content="Unifying Composable Effects and Advanced Optics for Java. Effect Path API, Focus DSL, and the most comprehensive optics implementation in the Java ecosystem.">
        <meta name="twitter:image" content="https://higher-kinded-j.github.io/preview.png">
        <meta name="twitter:image:alt" content="Higher-Kinded-J: Composable Effects and Advanced Optics for Java">
        <meta name="description" content="The most comprehensive functional programming library for Java. Unify error handling, optional values, and immutable data navigation with the Effect Path API and Focus DSL. Features advanced optics with code generation for Java records, filtered traversals, indexed optics, and seamless Spring Boot integration.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">
        <meta name="google-site-verification" content="X-xsiAq2cKMLOzh9dexUrX8Onx2h_YMUFgp5lHHUwSg" />
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./mdbook-admonish.css">
        <link rel="stylesheet" href="./theme/catppuccin.css">
        <link rel="stylesheet" href="./theme/catppuccin-admonish.css">
        <link rel="stylesheet" href="./theme/catppuccin-alerts.css">
        <link rel="stylesheet" href="./theme/additional-hkj.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "latte";
            const default_dark_theme = "macchiato";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('latte')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="latte">Latte</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="frappe">Frappé</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="macchiato">Macchiato</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mocha">Mocha</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        <div class="version-selector-container">
                            <select id="version-selector" class="version-selector" aria-label="Select documentation version" title="Select documentation version">
                                <option value="">Loading versions...</option>
                            </select>
                        </div>
                    </div>

                    <h1 class="menu-title">Higher-Kinded-J: Composable Effects and Advanced Optics for Java</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/higher-kinded-j/higher-kinded-j" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<pre><code> _   _ _       _                      _   ___           _          _        ___
| | | (_)     | |                    | | / (_)         | |        | |      |_  |
| |_| |_  __ _| |__   ___ _ __ ______| |/ / _ _ __   __| | ___  __| |______  | |
|  _  | |/ _` | '_ \ / _ \ '__|______|    \| | '_ \ / _` |/ _ \/ _` |______| | |
| | | | | (_| | | | |  __/ |         | |\  \ | | | | (_| |  __/ (_| |    /\__/ /
\_| |_/_|\__, |_| |_|\___|_|         \_| \_/_|_| |_|\__,_|\___|\__,_|    \____/
          __/ |
         |___/
</code></pre>
<h2 id="unifying-composable-effects-and-advanced-optics-for-java"><a class="header" href="#unifying-composable-effects-and-advanced-optics-for-java"><a href="https://github.com/higher-kinded-j/higher-kinded-j"><em>Unifying Composable Effects and Advanced Optics for Java</em></a></a></h2>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j"><img src="https://img.shields.io/badge/code-blue?logo=github" alt="Static Badge" />
</a>
<a href="https://codecov.io/gh/higher-kinded-j/higher-kinded-j"><img src="https://img.shields.io/codecov/c/github/higher-kinded-j/higher-kinded-j?token=VR0K0ZEDHD" alt="Codecov" /></a> <a href="https://central.sonatype.com/artifact/io.github.higher-kinded-j/hkj-core"><img src="https://img.shields.io/maven-central/v/io.github.higher-kinded-j/hkj-core" alt="Maven Central Version" /></a> <a href="https://github.com/higher-kinded-j/higher-kinded-j/discussions"><img src="https://img.shields.io/github/discussions/higher-kinded-j/higher-kinded-j" alt="GitHub Discussions" /></a> <a href="https://techhub.social/@ultramagnetic"><img src="https://img.shields.io/mastodon/follow/109367467120571209?domain=techhub.social&amp;style=plastic&amp;logoSize=auto" alt="Mastodon Follow" /></a></p>
<hr />
<p>Higher-Kinded-J brings two capabilities that Java has long needed: composable error handling through the <strong>Effect Path API</strong>, and type-safe immutable data navigation through the <strong>Focus DSL</strong>. Each is powerful alone. Together, they form a unified approach to building robust applications, where effects and structure compose seamlessly.</p>
<p>No more pyramids of nested checks. No more scattered validation logic. Just clean, flat pipelines that read like the business logic they represent.</p>
<hr />
<h2 id="the-effect-path-api"><a class="header" href="#the-effect-path-api">The Effect Path API</a></h2>
<p>At the heart of Higher-Kinded-J lies the <strong>Effect Path API</strong>: a railway model for computation where success travels one track and failure travels another. Operations like <code>map</code>, <code>via</code>, and <code>recover</code> work identically across all effect types, whether you are handling optional values, typed errors, accumulated validations, or deferred side effects.</p>
<pre><code class="language-java">// Traditional Java: pyramid of nested checks
if (user != null) {
    if (validator.validate(request).isValid()) {
        try {
            return paymentService.charge(user, amount);
        } catch (PaymentException e) { ... }
    }
}

// Effect Path API: flat, composable railway
return Path.maybe(findUser(userId))
    .toEitherPath(() -&gt; new UserNotFound(userId))
    .via(user -&gt; Path.either(validator.validate(request)))
    .via(valid -&gt; Path.tryOf(() -&gt; paymentService.charge(user, amount)))
    .map(OrderResult::success);
</code></pre>
<p>The nesting is gone. Each step follows the same pattern. Failures propagate automatically. The business logic reads top-to-bottom, not outside-in.</p>
<p><strong><a href="effect/ch_intro.html">Explore the Effect Path API →</a></strong></p>
<hr />
<h2 id="the-bridge-effects-meet-optics"><a class="header" href="#the-bridge-effects-meet-optics">The Bridge: Effects Meet Optics</a></h2>
<p>What makes Higher-Kinded-J unique is the seamless integration between <strong>Effect Paths</strong> and the <strong>Focus DSL</strong>. Where Effect Paths navigate <em>computational effects</em>, Focus Paths navigate <em>data structures</em>. Both use the same vocabulary. Both compose with <code>via</code>. And when you need to cross between them, the bridge API connects both worlds.</p>
<pre><code>                    THE EFFECT-OPTICS BRIDGE

  EFFECTS DOMAIN                           OPTICS DOMAIN
  ══════════════                           ═════════════

  EitherPath&lt;E, User&gt;  ────┐         ┌──── FocusPath&lt;User, Address&gt;
  TryPath&lt;Config&gt;      ────┤         ├──── AffinePath&lt;User, Email&gt;
  IOPath&lt;Data&gt;         ────┤         ├──── TraversalPath&lt;Team, Player&gt;
  ValidationPath&lt;E, A&gt; ────┘         └────
                            │       │
                            ▼       ▼
                       ┌─────────────────┐
                       │  .focus(path)   │
                       │  .toEitherPath  │
                       │  .toMaybePath   │
                       └─────────────────┘
                              │
                              ▼
                    UNIFIED COMPOSITION
                    ════════════════════

  userService.findById(id)        // Effect: fetch
      .focus(UserFocus.address()) // Optics: navigate
      .via(validateAddress)       // Effect: validate
      .focus(AddressFocus.city()) // Optics: extract
      .map(String::toUpperCase)   // Transform
</code></pre>
<pre><code class="language-java">// Fetch user (effect) → navigate to address (optics) →
// extract postcode (optics) → validate (effect)
EitherPath&lt;Error, String&gt; result =
    userService.findById(userId)           // EitherPath&lt;Error, User&gt;
        .focus(UserFocus.address())        // EitherPath&lt;Error, Address&gt;
        .focus(AddressFocus.postcode())    // EitherPath&lt;Error, String&gt;
        .via(code -&gt; validatePostcode(code));
</code></pre>
<p>This is the unification that Java has been missing: effects and structure, composition and navigation, all speaking the same language.</p>
<p><strong><a href="effect/focus_integration.html">Discover Focus-Effect Integration →</a></strong></p>
<hr />
<h2 id="two-foundations"><a class="header" href="#two-foundations">Two Foundations</a></h2>
<p>The Effect Path API is built on two powerful functional programming pillars:</p>
<h3 id="higher-kinded-types"><a class="header" href="#higher-kinded-types"><a href="hkts/hkt_introduction.html">Higher-Kinded Types</a></a></h3>
<p>Java lacks native support for abstracting over type constructors like <code>Optional&lt;A&gt;</code>, <code>List&lt;A&gt;</code>, or <code>CompletableFuture&lt;A&gt;</code>. Higher-Kinded-J simulates HKTs using defunctionalisation, unlocking:</p>
<ul>
<li><strong>Polymorphic functions</strong> that work across optionality, asynchrony, and error handling</li>
<li><strong>Type classes</strong> like <code>Functor</code>, <code>Applicative</code>, and <code>Monad</code> with consistent interfaces</li>
<li><strong>Monad transformers</strong> for composing effect stacks (<code>EitherT</code>, <code>StateT</code>, <code>ReaderT</code>)</li>
</ul>
<h3 id="advanced-optics"><a class="header" href="#advanced-optics"><a href="optics/optics_intro.html">Advanced Optics</a></a></h3>
<p>Higher-Kinded-J provides the most comprehensive optics implementation available for Java. Working with immutable records means verbose "copy-and-update" logic; the Optics library treats data access as first-class values:</p>
<ul>
<li><strong>Complete optic hierarchy:</strong> Lenses, Prisms, Isos, Affines, Traversals, Folds, and Setters</li>
<li><strong>Automatic generation</strong> via annotation processor for Java records and sealed interfaces</li>
<li><strong>Filtered traversals</strong> for predicate-based focusing within collections</li>
<li><strong>Indexed optics</strong> for position-aware transformations</li>
<li><strong>Profunctor architecture</strong> enabling adaptation between different data shapes</li>
<li><strong>Focus DSL</strong> for type-safe, fluent path navigation</li>
<li><strong>Effect integration</strong> bridging optics with the Effect Path API</li>
</ul>
<hr />
<h2 id="why-higher-kinded-j"><a class="header" href="#why-higher-kinded-j">Why Higher-Kinded-J?</a></h2>
<p>Higher-Kinded-J offers the most advanced optics implementation in the Java ecosystem, combined with a unified effect system that no other library provides.</p>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th style="text-align: center">Higher-Kinded-J</th><th style="text-align: center">Functional Java</th><th style="text-align: center">Fugue Optics</th><th style="text-align: center">Derive4J</th></tr></thead><tbody>
<tr><td><strong>Lens</strong></td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td style="text-align: center">✓^1^</td></tr>
<tr><td><strong>Prism</strong></td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td style="text-align: center">✓^1^</td></tr>
<tr><td><strong>Iso</strong></td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td style="text-align: center">✗</td></tr>
<tr><td><strong>Affine/Optional</strong></td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td style="text-align: center">✓^1^</td></tr>
<tr><td><strong>Traversal</strong></td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td style="text-align: center">✗</td></tr>
<tr><td><strong>Filtered Traversals</strong></td><td style="text-align: center">✓</td><td style="text-align: center">✗</td><td style="text-align: center">✗</td><td style="text-align: center">✗</td></tr>
<tr><td><strong>Indexed Optics</strong></td><td style="text-align: center">✓</td><td style="text-align: center">✗</td><td style="text-align: center">✗</td><td style="text-align: center">✗</td></tr>
<tr><td><strong>Code Generation</strong></td><td style="text-align: center">✓</td><td style="text-align: center">✗</td><td style="text-align: center">✗</td><td style="text-align: center">✓^1^</td></tr>
<tr><td><strong>Java Records Support</strong></td><td style="text-align: center">✓</td><td style="text-align: center">✗</td><td style="text-align: center">✗</td><td style="text-align: center">✗</td></tr>
<tr><td><strong>Sealed Interface Support</strong></td><td style="text-align: center">✓</td><td style="text-align: center">✗</td><td style="text-align: center">✗</td><td style="text-align: center">✗</td></tr>
<tr><td><strong>Effect Integration</strong></td><td style="text-align: center">✓</td><td style="text-align: center">✗</td><td style="text-align: center">✗</td><td style="text-align: center">✗</td></tr>
<tr><td><strong>Focus DSL</strong></td><td style="text-align: center">✓</td><td style="text-align: center">✗</td><td style="text-align: center">✗</td><td style="text-align: center">✗</td></tr>
<tr><td><strong>Profunctor Architecture</strong></td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td style="text-align: center">✗</td></tr>
<tr><td><strong>Fluent API</strong></td><td style="text-align: center">✓</td><td style="text-align: center">✗</td><td style="text-align: center">✗</td><td style="text-align: center">✗</td></tr>
<tr><td><strong>Modern Java (21+)</strong></td><td style="text-align: center">✓</td><td style="text-align: center">✗</td><td style="text-align: center">✗</td><td style="text-align: center">✗</td></tr>
</tbody></table>
</div>
<p>^1^ <em>Derive4J generates getters/setters but requires Functional Java for actual optic classes</em></p>
<hr />
<h2 id="path-types-at-a-glance"><a class="header" href="#path-types-at-a-glance">Path Types at a Glance</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Path Type</th><th>When to Reach for It</th></tr></thead><tbody>
<tr><td><code>MaybePath&lt;A&gt;</code></td><td>Absence is normal, not an error</td></tr>
<tr><td><code>EitherPath&lt;E, A&gt;</code></td><td>Errors carry typed, structured information</td></tr>
<tr><td><code>TryPath&lt;A&gt;</code></td><td>Wrapping code that throws exceptions</td></tr>
<tr><td><code>ValidationPath&lt;E, A&gt;</code></td><td>Collecting <em>all</em> errors, not just the first</td></tr>
<tr><td><code>IOPath&lt;A&gt;</code></td><td>Side effects you want to defer and sequence</td></tr>
<tr><td><code>TrampolinePath&lt;A&gt;</code></td><td>Stack-safe recursion</td></tr>
<tr><td><code>CompletableFuturePath&lt;A&gt;</code></td><td>Async operations</td></tr>
<tr><td><code>FreePath&lt;F, A&gt;</code> / <code>FreeApPath&lt;F, A&gt;</code></td><td>DSL building and interpretation</td></tr>
</tbody></table>
</div>
<p>Each Path wraps its underlying effect and provides <code>map</code>, <code>via</code>, <code>run</code>, <code>recover</code>, and integration with the Focus DSL.</p>
<hr />
<h2 id="learn-by-doing"><a class="header" href="#learn-by-doing">Learn by Doing</a></h2>
<p>The fastest way to master Higher-Kinded-J is through our <strong>interactive tutorial series</strong>. Eight journeys guide you through hands-on exercises with immediate test feedback.</p>
<div class="table-wrapper"><table><thead><tr><th>Journey</th><th>Focus</th><th>Duration</th><th>Exercises</th></tr></thead><tbody>
<tr><td><strong><a href="tutorials/coretypes/foundations_journey.html">Core: Foundations</a></strong></td><td>HKT simulation, Functor, Applicative, Monad</td><td>~38 min</td><td>24</td></tr>
<tr><td><strong><a href="tutorials/coretypes/error_handling_journey.html">Core: Error Handling</a></strong></td><td>MonadError, concrete types, real-world patterns</td><td>~30 min</td><td>20</td></tr>
<tr><td><strong><a href="tutorials/coretypes/advanced_journey.html">Core: Advanced</a></strong></td><td>Natural Transformations, Coyoneda, Free Applicative</td><td>~26 min</td><td>16</td></tr>
<tr><td><strong><a href="tutorials/effect/effect_journey.html">Effect API</a></strong></td><td>Effect paths, ForPath, Effect Contexts</td><td>~65 min</td><td>15</td></tr>
<tr><td><strong><a href="tutorials/optics/lens_prism_journey.html">Optics: Lens &amp; Prism</a></strong></td><td>Lens basics, Prism, Affine</td><td>~40 min</td><td>30</td></tr>
<tr><td><strong><a href="tutorials/optics/traversals_journey.html">Optics: Traversals</a></strong></td><td>Traversals, composition, practical applications</td><td>~40 min</td><td>27</td></tr>
<tr><td><strong><a href="tutorials/optics/fluent_free_journey.html">Optics: Fluent &amp; Free</a></strong></td><td>Fluent API, Free Monad DSL</td><td>~37 min</td><td>22</td></tr>
<tr><td><strong><a href="tutorials/optics/focus_dsl_journey.html">Optics: Focus DSL</a></strong></td><td>Type-safe path navigation</td><td>~22 min</td><td>18</td></tr>
</tbody></table>
</div>
<p>Perfect for developers who prefer learning by building. <a href="tutorials/tutorials_intro.html">Get started →</a></p>
<hr />
<h2 id="spring-boot-integration"><a class="header" href="#spring-boot-integration"><a href="spring/spring_boot_integration.html">Spring Boot Integration</a></a></h2>
<p>Building enterprise applications with Spring Boot? The <strong>hkj-spring-boot-starter</strong> brings functional programming patterns seamlessly into your REST APIs, eliminating exception-based error handling whilst maintaining Spring's familiar conventions.</p>
<p><strong>With Spring Boot Integration, you can:</strong></p>
<ul>
<li><strong>Return Functional Types from Controllers:</strong> Use <code>Either&lt;Error, Data&gt;</code>, <code>Validated&lt;Errors, Data&gt;</code>, and <code>EitherT</code> as return types with automatic HTTP response conversion.</li>
<li><strong>Eliminate Exception Handling Boilerplate:</strong> No more try-catch blocks or <code>@ExceptionHandler</code> methods; errors are explicit in your return types.</li>
<li><strong>Compose Operations Naturally:</strong> Chain operations with <code>map</code> and <code>flatMap</code> whilst preserving type safety and error information.</li>
<li><strong>Accumulate Validation Errors:</strong> Use <code>Validated</code> to collect <strong>all</strong> validation errors in a single request, improving user experience.</li>
<li><strong>Handle Async Operations:</strong> Use <code>EitherT</code> to compose asynchronous operations with typed errors seamlessly.</li>
<li><strong>Monitor in Production:</strong> Track Either success rates, Validated error distributions, and EitherT async performance with Spring Boot Actuator metrics.</li>
<li><strong>Secure Functionally:</strong> Integrate Spring Security with Either-based authentication and Validated-based authorisation logic.</li>
<li><strong>Zero Configuration Required:</strong> Auto-configuration handles everything; just add the dependency and start coding.</li>
</ul>
<div id="admonition-quick-example" class="admonition admonish-example" role="note" aria-labelledby="admonition-quick-example-title">
<div class="admonition-title">
<div id="admonition-quick-example-title">
<p>Quick Example</p>
</div>
<a class="admonition-anchor-link" href="home.html#admonition-quick-example"></a>
</div>
<div>
<pre><code class="language-java">@RestController
@RequestMapping("/api/users")
public class UserController {

    @GetMapping("/{id}")
    public Either&lt;DomainError, User&gt; getUser(@PathVariable String id) {
        return userService.findById(id);
        // Right(user) → HTTP 200 with JSON
        // Left(UserNotFoundError) → HTTP 404 with error details
    }

    @PostMapping
    public Validated&lt;List&lt;ValidationError&gt;, User&gt; createUser(@RequestBody UserRequest request) {
        return userService.validateAndCreate(request);
        // Valid(user) → HTTP 200
        // Invalid(errors) → HTTP 400 with ALL validation errors
    }
}
</code></pre>
</div>
</div>
<p><strong><a href="spring/spring_boot_integration.html">Get Started with Spring Boot Integration →</a></strong></p>
<hr />
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<div class="mdbook-alerts mdbook-alerts-note">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  note
</p>
<p>Before diving in, ensure you have the following:
<strong>Java Development Kit (JDK): Version 25</strong> or later. The library makes use of features available in this version.</p>
</div>
<p>Add the following dependencies to your <code>build.gradle.kts</code>:</p>
<pre><code class="language-gradle">dependencies {
    implementation("io.github.higher-kinded-j:hkj-core:LATEST_VERSION")
    annotationProcessor("io.github.higher-kinded-j:hkj-processor:LATEST_VERSION")
    annotationProcessor("io.github.higher-kinded-j:hkj-processor-plugins:LATEST_VERSION")
}
</code></pre>
<p>The annotation processor generates Focus paths and Effect paths for your records, enabling seamless integration between effects and data navigation.</p>
<p><strong>For Spring Boot Integration:</strong></p>
<pre><code class="language-gradle">dependencies {
    implementation("io.github.higher-kinded-j:hkj-spring-boot-starter:LATEST_VERSION")
}
</code></pre>
<p><strong>For SNAPSHOTS:</strong></p>
<pre><code class="language-gradle">repositories {
    mavenCentral()
    maven {
        url = uri("https://central.sonatype.com/repository/maven-snapshots/")
    }
}
</code></pre>
<hr />
<h2 id="documentation-guide"><a class="header" href="#documentation-guide">Documentation Guide</a></h2>
<div id="admonition-recommended-starting-point" class="admonition admonish-tip" role="note" aria-labelledby="admonition-recommended-starting-point-title">
<div class="admonition-title">
<div id="admonition-recommended-starting-point-title">
<p>Recommended Starting Point</p>
</div>
<a class="admonition-anchor-link" href="home.html#admonition-recommended-starting-point"></a>
</div>
<div>
<p>Start with the <strong>Effect Path API</strong> section below. It is the primary user-facing API of Higher-Kinded-J and provides everything most applications need.</p>
</div>
</div>
<h3 id="effect-path-api-start-here"><a class="header" href="#effect-path-api-start-here">Effect Path API (Start Here)</a></h3>
<ol>
<li><strong><a href="effect/effect_path_overview.html">Effect Path Overview</a>:</strong> The railway model, creating paths, core operations</li>
<li><strong><a href="effect/capabilities.html">Capability Interfaces</a>:</strong> The powers that paths possess</li>
<li><strong><a href="effect/path_types.html">Path Types</a>:</strong> When to use each path type</li>
<li><strong><a href="effect/focus_integration.html">Focus-Effect Integration</a>:</strong> Bridging optics and effects</li>
</ol>
<h3 id="optics-guides"><a class="header" href="#optics-guides">Optics Guides</a></h3>
<ol>
<li><strong><a href="optics/optics_intro.html">Introduction to Optics</a>:</strong> What optics are and the problems they solve</li>
<li><strong><a href="optics/lenses.html">Practical Guide: Lenses</a>:</strong> Nested immutable updates</li>
<li><strong><a href="optics/prisms.html">Practical Guide: Prisms</a>:</strong> Working with sum types</li>
<li><strong><a href="optics/focus_dsl.html">Focus DSL</a>:</strong> Type-safe structural navigation</li>
<li><strong><a href="optics/profunctor_optics.html">Profunctor Optics</a>:</strong> Adapting optics to different data shapes</li>
</ol>
<h3 id="foundations-reference"><a class="header" href="#foundations-reference">Foundations (Reference)</a></h3>
<p>These sections document the underlying machinery. Most users can start with Effect Paths directly.</p>
<ol>
<li><strong><a href="hkts/hkt_introduction.html">Higher-Kinded Types</a>:</strong> The simulation and why it matters</li>
<li><strong><a href="functional/ch_intro.html">Type Classes</a>:</strong> Functor, Monad, and other type classes</li>
<li><strong><a href="monads/ch_intro.html">Core Types</a>:</strong> Either, Maybe, Try, and other effect types</li>
<li><strong><a href="hkts/order-walkthrough.html">Order Example Walkthrough</a>:</strong> A complete workflow with monad transformers</li>
</ol>
<h3 id="history"><a class="header" href="#history">History</a></h3>
<p><strong>Higher-Kinded-J evolved from a simulation</strong> originally created for the blog post <a href="https://blog.scottlogic.com/2025/04/11/higher-kinded-types-with-java-and-scala.html">Higher Kinded Types with Java and Scala</a>. Since then it has grown into a comprehensive functional programming toolkit, with the Effect Path API providing the unifying layer that connects HKTs, type classes, and optics into a coherent whole.</p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="effect-path-api-navigating-computational-territory"><a class="header" href="#effect-path-api-navigating-computational-territory">Effect Path API: Navigating Computational Territory</a></h1>
<blockquote>
<p><em>"A map is not the territory it represents, but, if correct, it has a similar
structure to the territory, which accounts for its usefulness."</em></p>
<p>— Alfred Korzybski, <em>Science and Sanity</em></p>
</blockquote>
<hr />
<p>Every Java application navigates territory that doesn't appear on any class diagram: the landscape of <em>what might go wrong</em>. A database connection that refuses to connect. A user ID that points to nobody. A file that was there yesterday. A validation rule that nobody told you about.</p>
<p>Traditional Java handles this territory with a patchwork of approaches: nulls here, exceptions there, <code>Optional</code> when someone remembered, raw booleans when they didn't. Each approach speaks a different dialect. None compose cleanly with the others.</p>
<p>The Effect Path API provides a unified map for this territory.</p>
<p>Rather than learning separate idioms for absence (<code>Optional</code>), failure (<code>try-catch</code>), typed errors (<code>Either</code>), and deferred effects (<code>CompletableFuture</code>), you work with <strong>Path types</strong>: thin, composable wrappers that share a common vocabulary. The same <code>map</code>, <code>via</code>, and <code>recover</code> operations work regardless of what kind of effect you're handling. The underlying complexity remains (it must), but the Path contains it.</p>
<p>If you've used the Focus DSL from the optics chapters, the patterns will feel familiar. Where FocusPath navigates through <em>data structures</em>, EffectPath navigates through <em>computational effects</em>. Both use <code>via</code> for composition. Both provide fluent, chainable operations. The territory differs; the cartography rhymes. And when you need to cross between territories—extracting structured data into effect pipelines, or drilling into effect results with optics—the bridge API connects both worlds seamlessly.</p>
<hr />
<div id="admonition-in-this-chapter" class="admonition admonish-info" role="note" aria-labelledby="admonition-in-this-chapter-title">
<div class="admonition-title">
<div id="admonition-in-this-chapter-title">
<p>In This Chapter</p>
</div>
<a class="admonition-anchor-link" href="effect/ch_intro.html#admonition-in-this-chapter"></a>
</div>
<div>
<ul>
<li>
<p><strong><a href="effect/effect_path_overview.html">Effect Path Overview</a></strong> – The problem that Path types solve, the railway model of effect composition, and your first taste of the API.</p>
</li>
<li>
<p><strong><a href="effect/capabilities.html">Capability Interfaces</a></strong> – The hierarchy of powers that Path types possess: Composable, Combinable, Chainable, Recoverable, Effectful, and Accumulating. What each unlocks, and why the layering matters.</p>
</li>
<li>
<p><strong><a href="effect/path_types.html">Path Types</a></strong> – The full arsenal: <code>MaybePath</code>, <code>EitherPath</code>, <code>TryPath</code>, <code>IOPath</code>, <code>ValidationPath</code>, <code>TrampolinePath</code>, <code>FreePath</code>, <code>FreeApPath</code>, and more. When to reach for each, and what distinguishes them.</p>
</li>
<li>
<p><strong><a href="effect/composition.html">Composition Patterns</a></strong> – Sequential chains, independent combination, parallel execution, debugging with <code>peek</code>, and the art of mixing composition styles.</p>
</li>
<li>
<p><strong><a href="effect/conversions.html">Type Conversions</a></strong> – Moving between Path types as your needs change. The bridges between <code>Maybe</code> and <code>Either</code>, between <code>Try</code> and <code>Validation</code>, and the rules that govern safe passage.</p>
</li>
<li>
<p><strong><a href="effect/focus_integration.html">Focus-Effect Integration</a></strong> – Bridging optics and effects. Converting FocusPath to EffectPath for validation pipelines, using <code>focus()</code> to navigate within effect contexts, and patterns that combine both domains.</p>
</li>
<li>
<p><strong><a href="effect/patterns.html">Patterns and Recipes</a></strong> – Real-world patterns distilled from production code: validation pipelines, service orchestration, fallback chains, resilience with retry, and the pitfalls that await the unwary.</p>
</li>
<li>
<p><strong><a href="effect/advanced_effects.html">Advanced Effects</a></strong> – Reader, State, and Writer paths for environment access, stateful computation, and logging accumulation.</p>
</li>
<li>
<p><strong><a href="effect/advanced_topics.html">Advanced Topics</a></strong> – Stack-safe recursion, DSL building with Free structures, resource management, parallel execution, and resilience patterns.</p>
</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code</p>
</div>
<a class="admonition-anchor-link" href="effect/ch_intro.html#admonition-see-example-code"></a>
</div>
<div>
<p><strong>Core Patterns:</strong></p>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/effect/BasicPathExample.java">BasicPathExample.java</a> - Creating and transforming paths</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/effect/ChainedComputationsExample.java">ChainedComputationsExample.java</a> - Fluent chaining patterns</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/effect/ErrorHandlingExample.java">ErrorHandlingExample.java</a> - Recovery and error handling</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/effect/ServiceLayerExample.java">ServiceLayerExample.java</a> - Real-world service patterns</li>
</ul>
<p><strong>Advanced Effects:</strong></p>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/effect/AdvancedEffectsExample.java">AdvancedEffectsExample.java</a> - Reader, State, and Writer paths</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/effect/LazyPathExample.java">LazyPathExample.java</a> - Deferred, memoised computations</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/effect/CompletableFuturePathExample.java">CompletableFuturePathExample.java</a> - Async operations</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/effect/CollectionPathsExample.java">CollectionPathsExample.java</a> - List and Stream effects</li>
</ul>
<p><strong>Stack-Safety, Resources, Parallelism &amp; Resilience:</strong></p>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/effect/TrampolinePathExample.java">TrampolinePathExample.java</a> - Stack-safe recursion</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/effect/FreePathExample.java">FreePathExample.java</a> - DSL building and interpretation</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/effect/ResourceManagementExample.java">ResourceManagementExample.java</a> - bracket, withResource, guarantee</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/effect/ParallelExecutionExample.java">ParallelExecutionExample.java</a> - parZipWith, parSequence, race</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/effect/ResilienceExample.java">ResilienceExample.java</a> - RetryPolicy and backoff patterns</li>
</ul>
</div>
</div>
<h2 id="chapter-contents"><a class="header" href="#chapter-contents">Chapter Contents</a></h2>
<ol>
<li><a href="effect/effect_path_overview.html">Effect Path Overview</a> - The problem, the model, the first steps</li>
<li><a href="effect/capabilities.html">Capability Interfaces</a> - The interface hierarchy powering composition</li>
<li><a href="effect/path_types.html">Path Types</a> - Detailed coverage of each Path type</li>
<li><a href="effect/composition.html">Composition Patterns</a> - Chaining, combining, parallel execution, and debugging</li>
<li><a href="effect/conversions.html">Type Conversions</a> - Moving between different Path types</li>
<li><a href="effect/focus_integration.html">Focus-Effect Integration</a> - Bridging optics and effects</li>
<li><a href="effect/patterns.html">Patterns and Recipes</a> - Real-world patterns, resilience, and hard-won wisdom</li>
<li><a href="effect/advanced_effects.html">Advanced Effects</a> - Reader, State, and Writer patterns</li>
<li><a href="effect/advanced_topics.html">Advanced Topics</a> - Stack-safety, DSLs, resources, parallelism, resilience</li>
</ol>
<hr />
<p><strong>Next:</strong> <a href="effect/effect_path_overview.html">Effect Path Overview</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="effect-path-overview"><a class="header" href="#effect-path-overview">Effect Path Overview</a></h1>
<blockquote>
<p><em>"There is no real direction here, neither lines of power nor cooperation.
Decisions are never really made; at best they manage to emerge, from a chaos
of peeves, whims, hallucinations and all-round assholery."</em></p>
<p>— Thomas Pynchon, <em>Gravity's Rainbow</em></p>
</blockquote>
<p>Pynchon was describing wartime bureaucracy, but he might as well have been
reading a poorly implemented service layer on a Monday morning.</p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="effect/effect_path_overview.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>Why traditional Java error handling creates pyramids of nested chaos</li>
<li>The railway model: effects as tracks, errors as switching points</li>
<li>Creating Path types with factory methods</li>
<li>Transforming values with <code>map</code>, chaining with <code>via</code>, extracting with <code>run</code></li>
<li>Debugging pipelines with <code>peek</code></li>
</ul>
</div>
</div>
<hr />
<h2 id="the-pyramid-of-doom"><a class="header" href="#the-pyramid-of-doom">The Pyramid of Doom</a></h2>
<p>You've seen this shape before. You may have even written it, promising yourself to refactor it later:</p>
<pre><code class="language-java">public OrderResult processOrder(String userId, OrderRequest request) {
    User user = userRepository.findById(userId);
    if (user == null) {
        return OrderResult.error("User not found");
    }

    try {
        ValidationResult validation = validator.validate(request);
        if (!validation.isValid()) {
            return OrderResult.error(validation.getErrors().get(0));
        }

        InventoryCheck inventory = inventoryService.check(request.getItems());
        if (!inventory.isAvailable()) {
            return OrderResult.error("Items unavailable");
        }

        try {
            PaymentResult payment = paymentService.charge(user, inventory.getTotal());
            if (payment.isFailed()) {
                return OrderResult.error(payment.getFailureReason());
            }

            return OrderResult.success(createOrder(user, request, payment));
        } catch (PaymentException e) {
            return OrderResult.error("Payment failed: " + e.getMessage());
        }
    } catch (ValidationException e) {
        return OrderResult.error("Validation error: " + e.getMessage());
    }
}
</code></pre>
<p>Five levels of nesting. Three different error-handling idioms. The actual
business logic, <em>create an order</em>, buried at the bottom like a punchline
nobody can find. And this is a simple example. I've witnessed far worse in Production.</p>
<p>The problem isn't any single technique. Null checks are sometimes appropriate.
Exceptions have their place. The problem is that they don't <em>compose</em>. Each
approach speaks its own dialect, demands its own syntax, follows its own rules
for propagating failure. String enough of them together, and you get Pynchon's
chaos: decisions that don't so much get made as reluctantly emerge.</p>
<hr />
<h2 id="the-railway-model"><a class="header" href="#the-railway-model">The Railway Model</a></h2>
<p>Functional programmers solved this problem decades ago with a simple model:
the <strong>railway</strong>.</p>
<pre><code>                         THE EFFECT RAILWAY

    Success ═══●═══●═══●═══●═══●═══════════════════▶  Result
               │   │   │   │   │
              map via map via run
                   │       │
                   ╳       │         error occurs, switch tracks
                   │       │
    Failure  ──────●───────┼───────────────────────▶  Error
                   │       │
                mapError  recover
                           │
                           ╳                         recovery, switch back
</code></pre>
<p>Your data travels along the <strong>success track</strong>. Operations like <code>map</code> and <code>via</code>
transform it as it goes. If something fails, the data switches to the
<strong>failure track</strong> and subsequent operations are skipped, no explicit checks
required, no nested conditionals. Recovery operations (<code>recover</code>, <code>recoverWith</code>)
can switch the data back to the success track if you have a sensible fallback.</p>
<p>This is what Path types implement. The railway is the model; Paths are the
rolling stock.</p>
<hr />
<h2 id="the-same-logic-flattened"><a class="header" href="#the-same-logic-flattened">The Same Logic, Flattened</a></h2>
<p>Here's that order processing code rewritten with Effect Paths:</p>
<pre><code class="language-java">public EitherPath&lt;OrderError, Order&gt; processOrder(String userId, OrderRequest request) {
    return Path.maybe(userRepository.findById(userId))
        .toEitherPath(() -&gt; new OrderError.UserNotFound(userId))
        .via(user -&gt; Path.either(validator.validate(request))
            .mapError(OrderError.ValidationFailed::new))
        .via(validated -&gt; Path.either(inventoryService.check(request.getItems()))
            .mapError(OrderError.InventoryError::new))
        .via(inventory -&gt; Path.tryOf(() -&gt; paymentService.charge(user, inventory.getTotal()))
            .toEitherPath(OrderError.PaymentFailed::new))
        .via(payment -&gt; Path.right(createOrder(user, request, payment)));
}
</code></pre>
<p>The nesting has gone. Each step follows the same pattern: transform or chain,
handle errors consistently, let failures propagate automatically. The business
logic reads top-to-bottom instead of outside-in.</p>
<p>This isn't magic. The underlying complexity hasn't vanished; you still need
to handle the same failure cases. But the <em>accidental</em> complexity (the
pyramids, the repeated null checks, the catch blocks that just wrap and
rethrow) are gone. What remains is the essential shape of your logic.</p>
<hr />
<h2 id="path-types-at-a-glance-1"><a class="header" href="#path-types-at-a-glance-1">Path Types at a Glance</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Path Type</th><th>Underlying Effect</th><th>When to Reach for It</th></tr></thead><tbody>
<tr><td><code>MaybePath&lt;A&gt;</code></td><td><code>Maybe&lt;A&gt;</code></td><td>Absence is normal, not an error</td></tr>
<tr><td><code>EitherPath&lt;E, A&gt;</code></td><td><code>Either&lt;E, A&gt;</code></td><td>Errors carry typed information</td></tr>
<tr><td><code>TryPath&lt;A&gt;</code></td><td><code>Try&lt;A&gt;</code></td><td>Wrapping code that throws exceptions</td></tr>
<tr><td><code>IOPath&lt;A&gt;</code></td><td><code>IO&lt;A&gt;</code></td><td>Side effects you want to defer</td></tr>
<tr><td><code>ValidationPath&lt;E, A&gt;</code></td><td><code>Validated&lt;E, A&gt;</code></td><td>Collecting <em>all</em> errors, not just the first</td></tr>
<tr><td><code>IdPath&lt;A&gt;</code></td><td><code>Id&lt;A&gt;</code></td><td>The trivial case: always succeeds</td></tr>
<tr><td><code>OptionalPath&lt;A&gt;</code></td><td><code>Optional&lt;A&gt;</code></td><td>Bridging to Java's standard library</td></tr>
<tr><td><code>GenericPath&lt;F, A&gt;</code></td><td><code>Kind&lt;F, A&gt;</code></td><td>Custom monads, when nothing else fits</td></tr>
</tbody></table>
</div>
<p>Each Path type wraps its underlying effect and provides:</p>
<ul>
<li><code>map(f)</code> - Transform the success value</li>
<li><code>via(f)</code> - Chain to another Path (monadic bind)</li>
<li><code>run()</code> - Extract the underlying effect</li>
<li>Type-specific operations for recovery, error transformation, and more</li>
</ul>
<hr />
<h2 id="creating-paths"><a class="header" href="#creating-paths">Creating Paths</a></h2>
<p>The <code>Path</code> class provides factory methods for all Path types. A small sampler:</p>
<pre><code class="language-java">// MaybePath: optional values
MaybePath&lt;String&gt; greeting = Path.just("Hello");
MaybePath&lt;String&gt; empty = Path.nothing();
MaybePath&lt;User&gt; user = Path.maybe(repository.findById(id));

// EitherPath: typed errors
EitherPath&lt;String, Integer&gt; success = Path.right(42);
EitherPath&lt;String, Integer&gt; failure = Path.left("Something went wrong");

// TryPath: exception handling
TryPath&lt;Config&gt; config = Path.tryOf(() -&gt; loadConfig());

// IOPath: deferred side effects
IOPath&lt;String&gt; readFile = Path.io(() -&gt; Files.readString(path));
</code></pre>
<hr />
<h2 id="transforming-with-map"><a class="header" href="#transforming-with-map">Transforming with <code>map</code></a></h2>
<p>All Path types support <code>map</code> for transforming the success value:</p>
<pre><code class="language-java">MaybePath&lt;String&gt; greeting = Path.just("hello");
MaybePath&lt;String&gt; upper = greeting.map(String::toUpperCase);
// → Just("HELLO")

MaybePath&lt;String&gt; empty = Path.nothing();
MaybePath&lt;String&gt; stillEmpty = empty.map(String::toUpperCase);
// → Nothing (map doesn't run on empty paths)
</code></pre>
<p>The function inside <code>map</code> only executes if the Path is on the success track.
Failures pass through unchanged. No defensive checks required.</p>
<hr />
<h2 id="chaining-with-via"><a class="header" href="#chaining-with-via">Chaining with <code>via</code></a></h2>
<p>The <code>via</code> method chains computations where each step depends on the previous
result:</p>
<pre><code class="language-java">EitherPath&lt;Error, Invoice&gt; invoice =
    Path.either(findUser(userId))
        .via(user -&gt; Path.either(getCart(user)))
        .via(cart -&gt; Path.either(calculateTotal(cart)))
        .via(total -&gt; Path.either(createInvoice(total)));
</code></pre>
<p>Each <code>via</code> receives the success value and returns a new Path. If any step
fails, subsequent steps are skipped; the failure propagates to the end.</p>
<p>The name <code>via</code> mirrors the Focus DSL from the optics chapters. Where FocusPath
uses <code>via</code> to navigate through lenses, EffectPath uses <code>via</code> to navigate through
effects. Different territory, same verb.</p>
<hr />
<h2 id="extracting-results"><a class="header" href="#extracting-results">Extracting Results</a></h2>
<p>Eventually you need to leave the railway and extract a result:</p>
<pre><code class="language-java">// MaybePath
Maybe&lt;String&gt; maybe = path.run();
String value = path.getOrElse("default");
String value = path.getOrThrow(() -&gt; new NoSuchElementException());

// EitherPath
Either&lt;Error, User&gt; either = path.run();
String result = either.fold(
    error -&gt; "Failed: " + error,
    user -&gt; "Found: " + user.name()
);

// IOPath: actually runs the effect
String content = ioPath.unsafeRun();      // may throw
Try&lt;String&gt; safe = ioPath.runSafe();      // captures exceptions
</code></pre>
<hr />
<h2 id="debugging-with-peek"><a class="header" href="#debugging-with-peek">Debugging with <code>peek</code></a></h2>
<p>When a pipeline misbehaves, <code>peek</code> lets you observe values mid-flow without
disrupting the computation:</p>
<pre><code class="language-java">EitherPath&lt;Error, User&gt; result =
    Path.either(validateInput(input))
        .peek(valid -&gt; log.debug("Input validated: {}", valid))
        .via(valid -&gt; Path.either(createUser(valid)))
        .peek(user -&gt; log.info("User created: {}", user.getId()));
</code></pre>
<p>For failure paths, <code>peek</code> only executes on success. Failures pass through
silently, which is usually what you want when debugging the happy path.</p>
<hr />
<h2 id="structural-navigation-with-focus"><a class="header" href="#structural-navigation-with-focus">Structural Navigation with <code>focus</code></a></h2>
<p>Effect paths integrate with the Focus DSL, enabling structural navigation within effect contexts.
Where <code>map</code> transforms values and <code>via</code> chains effects, <code>focus</code> drills into nested structures
using optics.</p>
<pre><code>                         FOCUS WITHIN EFFECTS

    EitherPath&lt;Error, User&gt;
            │
            │  focus(namePath)         ← optic navigation
            ▼
    EitherPath&lt;Error, String&gt;
            │
            │  map(String::toUpperCase)  ← value transformation
            ▼
    EitherPath&lt;Error, String&gt;
            │
            │  via(validateName)         ← effect chaining
            ▼
    EitherPath&lt;Error, ValidName&gt;
</code></pre>
<h3 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h3>
<pre><code class="language-java">// Given a FocusPath from the optics domain
FocusPath&lt;User, String&gt; namePath = UserFocus.name();

// Apply within an effect
EitherPath&lt;Error, User&gt; userResult = fetchUser(userId);
EitherPath&lt;Error, String&gt; nameResult = userResult.focus(namePath);
</code></pre>
<p>The focus preserves the effect's semantics: if <code>userResult</code> is <code>Left</code>, <code>nameResult</code> is also <code>Left</code>.
Only <code>Right</code> values are navigated.</p>
<h3 id="handling-optional-focus"><a class="header" href="#handling-optional-focus">Handling Optional Focus</a></h3>
<p>When using <code>AffinePath</code> (for optional fields), provide an error for the absent case:</p>
<pre><code class="language-java">// AffinePath for Optional&lt;String&gt; email
AffinePath&lt;User, String&gt; emailPath = UserFocus.email();

// Must provide error if email is absent
EitherPath&lt;Error, String&gt; emailResult =
    userResult.focus(emailPath, new Error("Email not configured"));
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>FocusPath</th><th>AffinePath</th></tr></thead><tbody>
<tr><td>Always succeeds (value guaranteed)</td><td>May fail (value optional)</td></tr>
<tr><td><code>focus(path)</code></td><td><code>focus(path, errorIfAbsent)</code></td></tr>
</tbody></table>
</div>
<h3 id="effect-specific-behaviour"><a class="header" href="#effect-specific-behaviour">Effect-Specific Behaviour</a></h3>
<p>Each effect type handles absent focuses differently:</p>
<div class="table-wrapper"><table><thead><tr><th>Effect</th><th>FocusPath Result</th><th>AffinePath Absent Result</th></tr></thead><tbody>
<tr><td><code>MaybePath</code></td><td><code>Just(focused)</code></td><td><code>Nothing</code></td></tr>
<tr><td><code>EitherPath</code></td><td><code>Right(focused)</code></td><td><code>Left(providedError)</code></td></tr>
<tr><td><code>TryPath</code></td><td><code>Success(focused)</code></td><td><code>Failure(providedException)</code></td></tr>
<tr><td><code>IOPath</code></td><td><code>IO(focused)</code></td><td><code>IO(throw exception)</code></td></tr>
<tr><td><code>ValidationPath</code></td><td><code>Valid(focused)</code></td><td><code>Invalid(providedError)</code></td></tr>
</tbody></table>
</div>
<h3 id="chaining-focus-with-effects"><a class="header" href="#chaining-focus-with-effects">Chaining Focus with Effects</a></h3>
<p>Focus composes naturally with other path operations:</p>
<pre><code class="language-java">// Complex pipeline: fetch → navigate → validate → transform
EitherPath&lt;Error, String&gt; result =
    fetchUser(userId)                              // → EitherPath&lt;Error, User&gt;
        .focus(UserFocus.address())                // → EitherPath&lt;Error, Address&gt;
        .focus(AddressFocus.postcode(), noPostcodeError)  // → EitherPath&lt;Error, String&gt;
        .via(code -&gt; validatePostcode(code))       // → EitherPath&lt;Error, ValidPostcode&gt;
        .map(ValidPostcode::formatted);            // → EitherPath&lt;Error, String&gt;
</code></pre>
<h3 id="when-to-use-focus-vs-via"><a class="header" href="#when-to-use-focus-vs-via">When to Use focus vs via</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Use When</th></tr></thead><tbody>
<tr><td><code>focus(path)</code></td><td>Extracting nested fields with optics</td></tr>
<tr><td><code>via(f)</code></td><td>Chaining to another effect computation</td></tr>
<tr><td><code>map(f)</code></td><td>Transforming the value without changing effect type</td></tr>
</tbody></table>
</div>
<pre><code class="language-java">// focus: structural navigation (optics)
path.focus(UserFocus.name())

// via: effect sequencing (monadic bind)
path.via(user -&gt; validateUser(user))

// map: value transformation (functor)
path.map(name -&gt; name.toUpperCase())
</code></pre>
<div id="admonition-see-also" class="admonition admonish-tip" role="note" aria-labelledby="admonition-see-also-title">
<div class="admonition-title">
<div id="admonition-see-also-title">
<p>See Also</p>
</div>
<a class="admonition-anchor-link" href="effect/effect_path_overview.html#admonition-see-also"></a>
</div>
<div>
<ul>
<li><a href="effect/../optics/focus_dsl.html">Focus DSL</a> - Complete guide to Focus paths and navigation</li>
<li><a href="effect/focus_integration.html">Focus-Effect Integration</a> - Complete bridging guide</li>
<li><a href="effect/capabilities.html">Capability Interfaces</a> - Type class foundations</li>
</ul>
</div>
</div>
<hr />
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>What It Does</th><th>Railway Metaphor</th></tr></thead><tbody>
<tr><td><code>Path.just(x)</code>, <code>Path.right(x)</code>, etc.</td><td>Create a Path on the success track</td><td>Board the train</td></tr>
<tr><td><code>map(f)</code></td><td>Transform the value, stay on same track</td><td>Redecorate your carriage</td></tr>
<tr><td><code>via(f)</code></td><td>Chain to a new Path</td><td>Transfer to connecting service</td></tr>
<tr><td><code>recover(f)</code></td><td>Switch from failure to success track</td><td>Emergency rescue</td></tr>
<tr><td><code>mapError(f)</code></td><td>Transform the error, stay on failure track</td><td>Relabel the delay announcement</td></tr>
<tr><td><code>run()</code></td><td>Exit the railway, extract the result</td><td>Arrive at destination</td></tr>
</tbody></table>
</div>
<p>Continue to <a href="effect/capabilities.html">Capability Interfaces</a> to understand the powers
that make this possible.</p>
<div id="admonition-see-also-1" class="admonition admonish-tip" role="note" aria-labelledby="admonition-see-also-1-title">
<div class="admonition-title">
<div id="admonition-see-also-1-title">
<p>See Also</p>
</div>
<a class="admonition-anchor-link" href="effect/effect_path_overview.html#admonition-see-also-1"></a>
</div>
<div>
<ul>
<li><a href="effect/../functional/monad.html">Monad</a> - The type class powering <code>via</code> and <code>flatMap</code></li>
<li><a href="effect/../functional/functor.html">Functor</a> - The type class powering <code>map</code></li>
<li><a href="effect/../monads/io_monad.html">IO Monad</a> - The underlying type for <code>IOPath</code></li>
</ul>
</div>
</div>
<div id="admonition-further-reading" class="admonition admonish-tip" role="note" aria-labelledby="admonition-further-reading-title">
<div class="admonition-title">
<div id="admonition-further-reading-title">
<p>Further Reading</p>
</div>
<a class="admonition-anchor-link" href="effect/effect_path_overview.html#admonition-further-reading"></a>
</div>
<div>
<ul>
<li><strong>Scott Wlaschin</strong>: <a href="https://vimeo.com/97344498">Railway Oriented Programming -- error handling in functional languages</a> - video</li>
<li><strong>Scott Wlaschin</strong>: <a href="https://www.slideshare.net/slideshow/railway-oriented-programming/32242318#1">Railway Oriented Programming -- error handling in functional languages</a> - slides)</li>
</ul>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="effect/ch_intro.html">Introduction</a>
<strong>Next:</strong> <a href="effect/capabilities.html">Capability Interfaces</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="capability-interfaces"><a class="header" href="#capability-interfaces">Capability Interfaces</a></h1>
<blockquote>
<p><em>"Caress the detail, the divine detail."</em></p>
<p>— Vladimir Nabokov</p>
</blockquote>
<p>Nabokov was speaking of prose, but the principle applies to API design. The
Effect Path API doesn't give every Path type every operation. Instead, it
builds a hierarchy of <strong>capabilities</strong>, interfaces that add specific powers
to types that genuinely possess them. A <code>MaybePath</code> can recover from absence;
an <code>IdPath</code> cannot fail in the first place, so recovery would be meaningless.
The type system prevents you from reaching for tools that don't apply.</p>
<p>This isn't bureaucratic fastidiousness. It's how the library stays honest
about what each type can do.</p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="effect/capabilities.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>The capability interface hierarchy: Composable, Combinable, Chainable, Recoverable, Effectful, and Accumulating</li>
<li>How each capability maps to functional programming concepts (Functor, Applicative, Monad, MonadError)</li>
<li>Which operations each capability provides</li>
<li>Which Path types implement which capabilities</li>
<li>Why the layering matters for code that composes correctly</li>
</ul>
</div>
</div>
<hr />
<h2 id="the-hierarchy"><a class="header" href="#the-hierarchy">The Hierarchy</a></h2>
<pre><code>┌──────────────────────────────────────────────────────────────────────────────┐
│                     CAPABILITY HIERARCHY                                     │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│                          ┌────────────────┐                                  │
│                          │   Composable   │  map(), peek()                   │
│                          │   (Functor)    │  "I can transform what's inside" │
│                          └───────┬────────┘                                  │
│                                  │                                           │
│                          ┌───────┴────────┐                                  │
│                          │   Combinable   │  zipWith(), map2()               │
│                          │ (Applicative)  │  "I can merge independent work"  │
│                          └───────┬────────┘                                  │
│                                  │                                           │
│                          ┌───────┴────────┐                                  │
│                          │   Chainable    │  via(), flatMap(), then()        │
│                          │    (Monad)     │  "I can sequence dependent work" │
│                          └───────┬────────┘                                  │
│                                  │                                           │
│      ┌───────────────────────────┼───────────────────────────┐               │
│      │                           │                           │               │
│ ┌────┴───────┐           ┌───────┴────────┐          ┌───────┴────────┐      │
│ │ Recoverable│           │   Effectful    │          │  Accumulating  │      │
│ │(MonadError)│           │     (IO)       │          │  (Validated)   │      │
│ │            │           │                │          │                │      │
│ │ "I can     │           │ "I defer until │          │ "I collect all │      │
│ │  handle    │           │  you're ready" │          │  the problems" │      │
│ │  failure"  │           │                │          │                │      │
│ └────────────┘           └────────────────┘          └────────────────┘      │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<p>Each level builds on the previous. A <code>Chainable</code> type can do everything a
<code>Combinable</code> can do, plus sequential chaining. The three leaf capabilities,
Recoverable, Effectful, and Accumulating, represent specialised powers that
only some types possess.</p>
<p>This isn't arbitrary taxonomy. It's how you avoid calling <code>recover()</code> on a
type that never fails, or <code>unsafeRun()</code> on a type that doesn't defer execution.
The compiler catches category errors before they become runtime surprises.</p>
<hr />
<h2 id="composable-functor"><a class="header" href="#composable-functor">Composable (Functor)</a></h2>
<p><strong>What it means:</strong> You can transform the value inside without changing the
surrounding structure.</p>
<p><strong>The analogy:</strong> A translator. The message changes; the envelope stays sealed.</p>
<pre><code class="language-java">public interface Composable&lt;A&gt; {
    &lt;B&gt; Composable&lt;B&gt; map(Function&lt;? super A, ? extends B&gt; f);
    Composable&lt;A&gt; peek(Consumer&lt;? super A&gt; action);
}
</code></pre>
<p>Every Path type is Composable. It's the minimum viable capability.</p>
<pre><code class="language-java">MaybePath&lt;String&gt; name = Path.just("alice");
MaybePath&lt;Integer&gt; length = name.map(String::length);  // Just(5)

MaybePath&lt;String&gt; empty = Path.nothing();
MaybePath&lt;Integer&gt; stillEmpty = empty.map(String::length);  // Nothing
</code></pre>
<p>The function passed to <code>map</code> only runs if there's a value to transform.
Failures, absences, and pending effects pass through unchanged. This is why
you don't need defensive null checks inside <code>map</code>; the structure handles it.</p>
<h3 id="the-functor-laws"><a class="header" href="#the-functor-laws">The Functor Laws</a></h3>
<p>All Path types satisfy these laws, which is what makes composition predictable:</p>
<ol>
<li><strong>Identity:</strong> <code>path.map(x -&gt; x)</code> equals <code>path</code></li>
<li><strong>Composition:</strong> <code>path.map(f).map(g)</code> equals <code>path.map(f.andThen(g))</code></li>
</ol>
<p>The first law says mapping with the identity function changes nothing. The
second says you can fuse consecutive maps into one. These aren't aspirational
guidelines; they're guarantees the implementation must honour.</p>
<hr />
<h2 id="combinable-applicative"><a class="header" href="#combinable-applicative">Combinable (Applicative)</a></h2>
<p><strong>What it means:</strong> You can merge the results of independent computations.</p>
<p><strong>The analogy:</strong> A meeting coordinator. Everyone works separately, then results
are combined at the end. If someone fails to deliver, there's nothing to combine.</p>
<pre><code class="language-java">public interface Combinable&lt;A&gt; extends Composable&lt;A&gt; {
    &lt;B, C&gt; Combinable&lt;C&gt; zipWith(
        Combinable&lt;B&gt; other,
        BiFunction&lt;? super A, ? super B, ? extends C&gt; f
    );

    &lt;B, C, D&gt; Combinable&lt;D&gt; zipWith3(
        Combinable&lt;B&gt; second,
        Combinable&lt;C&gt; third,
        TriFunction&lt;? super A, ? super B, ? super C, ? extends D&gt; f
    );
}
</code></pre>
<p>The key property is <strong>independence</strong>. Neither computation depends on the
other's result:</p>
<pre><code class="language-java">// These validations don't affect each other
EitherPath&lt;String, String&gt; name = validateName(input.name());
EitherPath&lt;String, String&gt; email = validateEmail(input.email());
EitherPath&lt;String, Integer&gt; age = validateAge(input.age());

// Combine all three
EitherPath&lt;String, User&gt; user = name.zipWith3(email, age, User::new);
</code></pre>
<p>If all three succeed, <code>User::new</code> receives the three values. If any fails,
the first failure propagates. (For collecting <em>all</em> failures, you need
<code>Accumulating</code>; patience.)</p>
<h3 id="zipwith-vs-via"><a class="header" href="#zipwith-vs-via"><code>zipWith</code> vs <code>via</code></a></h3>
<p>A common source of confusion, worth addressing directly:</p>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Relationship Between Computations</th></tr></thead><tbody>
<tr><td><code>zipWith</code></td><td>Independent: neither needs the other's result</td></tr>
<tr><td><code>via</code></td><td>Dependent: the second needs the first's result</td></tr>
</tbody></table>
</div>
<p>If you're validating a form, the fields are independent: use <code>zipWith</code>. If
you're fetching a user then loading their preferences, the second needs the
first: use <code>via</code>.</p>
<hr />
<h2 id="chainable-monad"><a class="header" href="#chainable-monad">Chainable (Monad)</a></h2>
<p><strong>What it means:</strong> You can sequence computations where each step depends on
the previous result.</p>
<p><strong>The analogy:</strong> A relay race. Each runner receives the baton from the previous
and decides what to do next. If someone drops the baton, the race ends there.</p>
<pre><code class="language-java">public interface Chainable&lt;A&gt; extends Combinable&lt;A&gt; {
    &lt;B&gt; Chainable&lt;B&gt; via(Function&lt;? super A, ? extends Chainable&lt;B&gt;&gt; f);
    &lt;B&gt; Chainable&lt;B&gt; flatMap(Function&lt;? super A, ? extends Chainable&lt;B&gt;&gt; f);
    &lt;B&gt; Chainable&lt;B&gt; then(Supplier&lt;? extends Chainable&lt;B&gt;&gt; next);
}
</code></pre>
<p>The <code>via</code> method is the workhorse:</p>
<pre><code class="language-java">EitherPath&lt;Error, Invoice&gt; invoice =
    Path.either(findUser(userId))
        .via(user -&gt; Path.either(getCart(user)))      // needs user
        .via(cart -&gt; Path.either(calculateTotal(cart))) // needs cart
        .via(total -&gt; Path.either(createInvoice(total))); // needs total
</code></pre>
<p>Each step receives the previous result and returns a new Path. The railway
metaphor applies: success continues forward, failure short-circuits to the end.</p>
<p><code>flatMap</code> is an alias for <code>via</code>, the same operation with the traditional name. Use
whichever reads better in context.</p>
<p><code>then</code> is for sequencing when you don't need the previous value:</p>
<pre><code class="language-java">IOPath&lt;Unit&gt; workflow =
    Path.io(() -&gt; log.info("Starting"))
        .then(() -&gt; Path.io(() -&gt; initialise()))
        .then(() -&gt; Path.io(() -&gt; process()));
</code></pre>
<h3 id="the-monad-laws"><a class="header" href="#the-monad-laws">The Monad Laws</a></h3>
<ol>
<li><strong>Left Identity:</strong> <code>Path.just(a).via(f)</code> equals <code>f.apply(a)</code></li>
<li><strong>Right Identity:</strong> <code>path.via(Path::just)</code> equals <code>path</code></li>
<li><strong>Associativity:</strong> <code>path.via(f).via(g)</code> equals <code>path.via(x -&gt; f.apply(x).via(g))</code></li>
</ol>
<p>These ensure that chaining behaves predictably regardless of how you group
operations. Refactoring a chain into helper methods won't change its behaviour.</p>
<hr />
<h2 id="recoverable-monaderror"><a class="header" href="#recoverable-monaderror">Recoverable (MonadError)</a></h2>
<p><strong>What it means:</strong> You can handle failures and potentially continue on the
success track.</p>
<p><strong>The analogy:</strong> A safety net. If you fall, something catches you. You might
climb back up, or you might stay down, but the fall doesn't have to be fatal.</p>
<pre><code class="language-java">public interface Recoverable&lt;E, A&gt; extends Chainable&lt;A&gt; {
    Recoverable&lt;E, A&gt; recover(Function&lt;? super E, ? extends A&gt; handler);
    Recoverable&lt;E, A&gt; recoverWith(
        Function&lt;? super E, ? extends Recoverable&lt;E, A&gt;&gt; handler
    );
    Recoverable&lt;E, A&gt; orElse(Supplier&lt;? extends Recoverable&lt;E, A&gt;&gt; alternative);
    &lt;F&gt; Recoverable&lt;F, A&gt; mapError(Function&lt;? super E, ? extends F&gt; f);
}
</code></pre>
<p>Different Path types have different notions of "error":</p>
<pre><code class="language-java">// MaybePath: "error" is absence
MaybePath&lt;User&gt; user = Path.maybe(findUser(id))
    .orElse(() -&gt; Path.just(User.guest()));

// EitherPath: "error" is a typed value
EitherPath&lt;Error, Config&gt; config = Path.either(loadConfig())
    .recover(error -&gt; Config.defaults())
    .mapError(e -&gt; new ConfigError("Load failed", e));

// TryPath: "error" is an exception
TryPath&lt;Integer&gt; parsed = Path.tryOf(() -&gt; Integer.parseInt(input))
    .recover(ex -&gt; 0);
</code></pre>
<p><code>Recoverable</code> is perhaps the most frequently used capability after <code>Chainable</code>,
which tells you something about the general state of affairs in software.</p>
<hr />
<h2 id="effectful-io"><a class="header" href="#effectful-io">Effectful (IO)</a></h2>
<p><strong>What it means:</strong> The computation is deferred until you explicitly run it.</p>
<p><strong>The analogy:</strong> A written contract. It describes what will happen, but nothing
happens until someone signs and executes it.</p>
<pre><code class="language-java">public interface Effectful&lt;A&gt; extends Chainable&lt;A&gt; {
    A unsafeRun();
    Try&lt;A&gt; runSafe();
    Effectful&lt;A&gt; handleError(Function&lt;? super Throwable, ? extends A&gt; handler);
    Effectful&lt;A&gt; handleErrorWith(
        Function&lt;? super Throwable, ? extends Effectful&lt;A&gt;&gt; handler
    );
    Effectful&lt;A&gt; ensuring(Runnable cleanup);
}
</code></pre>
<p>Only <code>IOPath</code> implements <code>Effectful</code>. All other Path types evaluate immediately
when you call <code>map</code> or <code>via</code>. With <code>IOPath</code>, nothing happens until you call
<code>unsafeRun()</code> or <code>runSafe()</code>:</p>
<pre><code class="language-java">IOPath&lt;String&gt; readFile = Path.io(() -&gt; {
    System.out.println("Reading file...");  // Not printed yet
    return Files.readString(path);
});

// Still nothing happens
IOPath&lt;Integer&gt; lineCount = readFile.map(s -&gt; s.split("\n").length);

// NOW it executes
Integer count = lineCount.unsafeRun();  // "Reading file..." printed
</code></pre>
<p>The <code>ensuring</code> method guarantees cleanup runs regardless of success or failure:</p>
<pre><code class="language-java">IOPath&lt;Data&gt; withCleanup = Path.io(() -&gt; acquireResource())
    .via(resource -&gt; Path.io(() -&gt; useResource(resource)))
    .ensuring(() -&gt; releaseResource());
</code></pre>
<p>The name <code>unsafeRun</code> is deliberate. It's a warning: side effects are about to
happen, referential transparency ends here. Call it at the edge of your system,
not scattered throughout.</p>
<hr />
<h2 id="accumulating-validated"><a class="header" href="#accumulating-validated">Accumulating (Validated)</a></h2>
<p><strong>What it means:</strong> You can combine independent computations while collecting
<em>all</em> errors, not just the first.</p>
<p><strong>The analogy:</strong> A code review. The reviewer notes every problem, then hands
back the full list. They don't stop at the first issue and declare the review
complete.</p>
<pre><code class="language-java">public interface Accumulating&lt;E, A&gt; extends Composable&lt;A&gt; {
    &lt;B, C&gt; Accumulating&lt;E, C&gt; zipWithAccum(
        Accumulating&lt;E, B&gt; other,
        BiFunction&lt;? super A, ? super B, ? extends C&gt; combiner
    );

    Accumulating&lt;E, A&gt; andAlso(Accumulating&lt;E, ?&gt; other);
}
</code></pre>
<p>Only <code>ValidationPath</code> implements <code>Accumulating</code>. The key difference from
<code>Combinable.zipWith</code>:</p>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>On Multiple Failures</th></tr></thead><tbody>
<tr><td><code>zipWith</code></td><td>Returns first error (short-circuits)</td></tr>
<tr><td><code>zipWithAccum</code></td><td>Combines all errors using Semigroup</td></tr>
</tbody></table>
</div>
<pre><code class="language-java">ValidationPath&lt;List&lt;String&gt;, String&gt; name = validateName(input);
ValidationPath&lt;List&lt;String&gt;, String&gt; email = validateEmail(input);
ValidationPath&lt;List&lt;String&gt;, Integer&gt; age = validateAge(input);

// Accumulate ALL errors
ValidationPath&lt;List&lt;String&gt;, User&gt; user = name.zipWith3Accum(
    email,
    age,
    User::new
);

// If name and email both fail: Invalid(["Name too short", "Invalid email"])
// Not just: Invalid(["Name too short"])
</code></pre>
<p>Error accumulation requires a <code>Semigroup</code> to define how errors combine. For
<code>List&lt;String&gt;</code>, errors concatenate. For <code>String</code>, they might join with <code>;</code>.
The Semigroup is provided when creating the <code>ValidationPath</code>.</p>
<p>Use <code>Accumulating</code> for user-facing validation where showing all problems at
once is kinder than making users fix them one by one.</p>
<hr />
<h2 id="which-capabilities-each-path-type-has"><a class="header" href="#which-capabilities-each-path-type-has">Which Capabilities Each Path Type Has</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Path Type</th><th style="text-align: center">Composable</th><th style="text-align: center">Combinable</th><th style="text-align: center">Chainable</th><th style="text-align: center">Recoverable</th><th style="text-align: center">Effectful</th><th style="text-align: center">Accumulating</th></tr></thead><tbody>
<tr><td>MaybePath</td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td style="text-align: center">·</td><td style="text-align: center">·</td></tr>
<tr><td>EitherPath</td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td style="text-align: center">·</td><td style="text-align: center">·</td></tr>
<tr><td>TryPath</td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td style="text-align: center">·</td><td style="text-align: center">·</td></tr>
<tr><td>IOPath</td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td style="text-align: center">·</td><td style="text-align: center">✓</td><td style="text-align: center">·</td></tr>
<tr><td>ValidationPath</td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td style="text-align: center">·</td><td style="text-align: center">✓</td></tr>
<tr><td>IdPath</td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td style="text-align: center">·</td><td style="text-align: center">·</td><td style="text-align: center">·</td></tr>
<tr><td>OptionalPath</td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td style="text-align: center">·</td><td style="text-align: center">·</td></tr>
<tr><td>GenericPath</td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td style="text-align: center">*</td><td style="text-align: center">·</td><td style="text-align: center">·</td></tr>
</tbody></table>
</div>
<p>* <code>GenericPath</code> recovery depends on the underlying monad.</p>
<p>Note that <code>IdPath</code> lacks <code>Recoverable</code>; it cannot fail, so recovery is
meaningless. <code>IOPath</code> lacks <code>Recoverable</code> but has <code>Effectful</code>, which includes
its own error handling via <code>handleError</code>. These aren't omissions; they're
the type system being honest about what makes sense.</p>
<hr />
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Capability</th><th>What It Adds</th><th>Key Operations</th></tr></thead><tbody>
<tr><td><strong>Composable</strong></td><td>Transform values</td><td><code>map</code>, <code>peek</code></td></tr>
<tr><td><strong>Combinable</strong></td><td>Merge independent work</td><td><code>zipWith</code>, <code>zipWith3</code></td></tr>
<tr><td><strong>Chainable</strong></td><td>Sequence dependent work</td><td><code>via</code>, <code>flatMap</code>, <code>then</code></td></tr>
<tr><td><strong>Recoverable</strong></td><td>Handle failure</td><td><code>recover</code>, <code>recoverWith</code>, <code>mapError</code>, <code>orElse</code></td></tr>
<tr><td><strong>Effectful</strong></td><td>Defer execution</td><td><code>unsafeRun</code>, <code>runSafe</code>, <code>handleError</code>, <code>ensuring</code></td></tr>
<tr><td><strong>Accumulating</strong></td><td>Collect all errors</td><td><code>zipWithAccum</code>, <code>andAlso</code></td></tr>
</tbody></table>
</div>
<p>The hierarchy is designed so you can write code at the appropriate level of
abstraction. If <code>map</code> suffices, use <code>map</code>. Reach for <code>via</code> only when you need
sequencing. The capabilities tell you what's available; the types ensure you
don't ask for more than a Path can deliver.</p>
<p>Continue to <a href="effect/path_types.html">Path Types</a> for detailed coverage of each type.</p>
<div id="admonition-see-also" class="admonition admonish-tip" role="note" aria-labelledby="admonition-see-also-title">
<div class="admonition-title">
<div id="admonition-see-also-title">
<p>See Also</p>
</div>
<a class="admonition-anchor-link" href="effect/capabilities.html#admonition-see-also"></a>
</div>
<div>
<ul>
<li><a href="effect/../functional/functor.html">Functor</a> - The type class behind Composable</li>
<li><a href="effect/../functional/applicative.html">Applicative</a> - The type class behind Combinable</li>
<li><a href="effect/../functional/monad.html">Monad</a> - The type class behind Chainable</li>
<li><a href="effect/../functional/monad_error.html">MonadError</a> - The type class behind Recoverable</li>
<li><a href="effect/../monads/validated_monad.html">Validated</a> - The type behind Accumulating</li>
</ul>
</div>
</div>
<div id="admonition-further-reading" class="admonition admonish-tip" role="note" aria-labelledby="admonition-further-reading-title">
<div class="admonition-title">
<div id="admonition-further-reading-title">
<p>Further Reading</p>
</div>
<a class="admonition-anchor-link" href="effect/capabilities.html#admonition-further-reading"></a>
</div>
<div>
<ul>
<li><strong>Mateusz Kubuszok</strong>: <a href="https://kubuszok.com/2018/the-f-words-functors-and-friends/#functor">The F-words: Functors and Friends</a> - An accessible introduction to Functor, Applicative, and Monad with practical examples</li>
</ul>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="effect/effect_path_overview.html">Effect Path Overview</a>
<strong>Next:</strong> <a href="effect/path_types.html">Path Types</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="path-types"><a class="header" href="#path-types">Path Types</a></h1>
<blockquote>
<p><em>"It is not down on any map; true places never are."</em></p>
<p>— Herman Melville, <em>Moby-Dick</em></p>
</blockquote>
<p>Melville was speaking of Queequeg's island home, but the observation applies
to software: the territory you're navigating (nullable returns, network
failures, validation errors, deferred effects) isn't marked on any class
diagram. You need to choose your vessel before setting sail.</p>
<p>This chapter covers each Path type in detail. But before cataloguing the
fleet, a more pressing question: <em>which one do you need?</em></p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="effect/path_types.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to choose the right Path type for your situation</li>
<li>Overview of all available Path types</li>
<li>When each type is the right tool, and when it isn't</li>
</ul>
</div>
</div>
<hr />
<h2 id="choosing-your-path"><a class="header" href="#choosing-your-path">Choosing Your Path</a></h2>
<p>Before diving into specifics, orient yourself by the problem you're solving:</p>
<h3 id="the-value-might-not-exist"><a class="header" href="#the-value-might-not-exist"><em>"The value might not exist"</em></a></h3>
<p>You're dealing with absence: a lookup that returns nothing, an optional
configuration, a field that might be null.</p>
<p><strong>Reach for <a href="effect/path_maybe.html"><code>MaybePath</code></a></strong> if absence is normal and expected, not an error
condition. Nobody needs to know <em>why</em> the value is missing.</p>
<p><strong>Reach for <a href="effect/path_optional.html"><code>OptionalPath</code></a></strong> if you're bridging to Java's <code>Optional</code> ecosystem
and want to stay close to the standard library.</p>
<h3 id="the-operation-might-fail-and-i-need-to-know-why"><a class="header" href="#the-operation-might-fail-and-i-need-to-know-why"><em>"The operation might fail, and I need to know why"</em></a></h3>
<p>Something can go wrong, and the error carries information: a validation
message, a typed error code, a domain-specific failure.</p>
<p><strong>Reach for <a href="effect/path_either.html"><code>EitherPath</code></a></strong> when you control the error type and want typed,
structured errors.</p>
<p><strong>Reach for <a href="effect/path_try.html"><code>TryPath</code></a></strong> when you're wrapping code that throws exceptions and
want to stay in exception-land (with <code>Throwable</code> as the error type).</p>
<h3 id="i-need-all-the-errors-not-just-the-first"><a class="header" href="#i-need-all-the-errors-not-just-the-first"><em>"I need ALL the errors, not just the first"</em></a></h3>
<p>Multiple independent validations, and stopping at the first failure would
be unkind to your users.</p>
<p><strong>Reach for <a href="effect/path_validation.html"><code>ValidationPath</code></a></strong> with <code>zipWithAccum</code> to accumulate every error.</p>
<h3 id="the-operation-has-side-effects-i-want-to-defer"><a class="header" href="#the-operation-has-side-effects-i-want-to-defer"><em>"The operation has side effects I want to defer"</em></a></h3>
<p>You're reading files, calling APIs, writing to databases, effects that
shouldn't happen until you're ready.</p>
<p><strong>Reach for <a href="effect/path_io.html"><code>IOPath</code></a></strong> to describe the effect without executing it. Nothing
runs until you call <code>unsafeRun()</code>.</p>
<h3 id="i-need-stack-safe-recursion"><a class="header" href="#i-need-stack-safe-recursion"><em>"I need stack-safe recursion"</em></a></h3>
<p>Deep recursive algorithms that would blow the stack with direct recursion.</p>
<p><strong>Reach for <a href="effect/path_trampoline.html"><code>TrampolinePath</code></a></strong> for guaranteed stack safety regardless of depth.</p>
<h3 id="i-want-to-build-an-interpretable-dsl"><a class="header" href="#i-want-to-build-an-interpretable-dsl"><em>"I want to build an interpretable DSL"</em></a></h3>
<p>Separate description from execution, test with mock interpreters, or support
multiple interpretation strategies.</p>
<p><strong>Reach for <a href="effect/path_free.html"><code>FreePath</code></a></strong> for sequential DSLs or
<a href="effect/path_freeap.html"><code>FreeApPath</code></a> for parallel/static-analysis-friendly DSLs.</p>
<h3 id="the-operation-always-succeeds"><a class="header" href="#the-operation-always-succeeds"><em>"The operation always succeeds"</em></a></h3>
<p>No failure case, no absence; you just want Path operations on a pure value.</p>
<p><strong>Reach for <a href="effect/path_id.html"><code>IdPath</code></a></strong> when you need a trivial Path for generic code or testing.</p>
<h3 id="none-of-the-above"><a class="header" href="#none-of-the-above"><em>"None of the above"</em></a></h3>
<p>You have a custom monad, or you're writing highly generic code.</p>
<p><strong>Reach for <a href="effect/path_generic.html"><code>GenericPath</code></a></strong> as the escape hatch; it wraps any <code>Kind&lt;F, A&gt;</code>
with a <code>Monad</code> instance.</p>
<hr />
<h2 id="quick-reference"><a class="header" href="#quick-reference">Quick Reference</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Path Type</th><th>Wraps</th><th>Error Type</th><th>Evaluation</th><th>Key Use Case</th></tr></thead><tbody>
<tr><td><a href="effect/path_maybe.html"><code>MaybePath&lt;A&gt;</code></a></td><td><code>Maybe&lt;A&gt;</code></td><td>None (absence)</td><td>Immediate</td><td>Optional values</td></tr>
<tr><td><a href="effect/path_either.html"><code>EitherPath&lt;E, A&gt;</code></a></td><td><code>Either&lt;E, A&gt;</code></td><td><code>E</code> (typed)</td><td>Immediate</td><td>Typed error handling</td></tr>
<tr><td><a href="effect/path_try.html"><code>TryPath&lt;A&gt;</code></a></td><td><code>Try&lt;A&gt;</code></td><td><code>Throwable</code></td><td>Immediate</td><td>Exception wrapping</td></tr>
<tr><td><a href="effect/path_io.html"><code>IOPath&lt;A&gt;</code></a></td><td><code>IO&lt;A&gt;</code></td><td><code>Throwable</code></td><td><strong>Deferred</strong></td><td>Side effects</td></tr>
<tr><td><a href="effect/path_validation.html"><code>ValidationPath&lt;E, A&gt;</code></a></td><td><code>Validated&lt;E, A&gt;</code></td><td><code>E</code> (accumulated)</td><td>Immediate</td><td>Form validation</td></tr>
<tr><td><a href="effect/path_id.html"><code>IdPath&lt;A&gt;</code></a></td><td><code>Id&lt;A&gt;</code></td><td>None (always succeeds)</td><td>Immediate</td><td>Pure values</td></tr>
<tr><td><a href="effect/path_optional.html"><code>OptionalPath&lt;A&gt;</code></a></td><td><code>Optional&lt;A&gt;</code></td><td>None (absence)</td><td>Immediate</td><td>Java stdlib bridge</td></tr>
<tr><td><a href="effect/path_generic.html"><code>GenericPath&lt;F, A&gt;</code></a></td><td><code>Kind&lt;F, A&gt;</code></td><td>Depends on monad</td><td>Depends</td><td>Custom monads</td></tr>
<tr><td><a href="effect/path_trampoline.html"><code>TrampolinePath&lt;A&gt;</code></a></td><td><code>Trampoline&lt;A&gt;</code></td><td>None</td><td><strong>Deferred</strong></td><td>Stack-safe recursion</td></tr>
<tr><td><a href="effect/path_free.html"><code>FreePath&lt;F, A&gt;</code></a></td><td><code>Free&lt;F, A&gt;</code></td><td>None</td><td>Interpreted</td><td>DSL building</td></tr>
<tr><td><a href="effect/path_freeap.html"><code>FreeApPath&lt;F, A&gt;</code></a></td><td><code>FreeAp&lt;F, A&gt;</code></td><td>None</td><td>Interpreted</td><td>Applicative DSLs</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="path-types-by-category"><a class="header" href="#path-types-by-category">Path Types by Category</a></h2>
<h3 id="value-containers-immediate-evaluation"><a class="header" href="#value-containers-immediate-evaluation">Value Containers (Immediate Evaluation)</a></h3>
<p>These types wrap values and evaluate operations immediately:</p>
<ul>
<li><strong><a href="effect/path_maybe.html">MaybePath</a></strong> - For values that might be absent</li>
<li><strong><a href="effect/path_optional.html">OptionalPath</a></strong> - Bridge to Java's <code>Optional</code></li>
<li><strong><a href="effect/path_id.html">IdPath</a></strong> - Always contains a value (identity)</li>
</ul>
<h3 id="error-handling-immediate-evaluation"><a class="header" href="#error-handling-immediate-evaluation">Error Handling (Immediate Evaluation)</a></h3>
<p>These types handle failures with different strategies:</p>
<ul>
<li><strong><a href="effect/path_either.html">EitherPath</a></strong> - Typed errors, short-circuit on first failure</li>
<li><strong><a href="effect/path_try.html">TryPath</a></strong> - Exception-based errors</li>
<li><strong><a href="effect/path_validation.html">ValidationPath</a></strong> - Accumulate all errors</li>
</ul>
<h3 id="deferred-computation"><a class="header" href="#deferred-computation">Deferred Computation</a></h3>
<p>These types describe computations without executing them:</p>
<ul>
<li><strong><a href="effect/path_io.html">IOPath</a></strong> - Side effects, runs when you call <code>unsafeRun()</code></li>
<li><strong><a href="effect/path_trampoline.html">TrampolinePath</a></strong> - Stack-safe recursion</li>
</ul>
<h3 id="dsl-building"><a class="header" href="#dsl-building">DSL Building</a></h3>
<p>These types support building domain-specific languages:</p>
<ul>
<li><strong><a href="effect/path_free.html">FreePath</a></strong> - Sequential, monadic DSLs</li>
<li><strong><a href="effect/path_freeap.html">FreeApPath</a></strong> - Parallel, applicative DSLs</li>
</ul>
<h3 id="universal"><a class="header" href="#universal">Universal</a></h3>
<ul>
<li><strong><a href="effect/path_generic.html">GenericPath</a></strong> - Works with any monad</li>
</ul>
<hr />
<h2 id="summary-choosing-your-vessel"><a class="header" href="#summary-choosing-your-vessel">Summary: Choosing Your Vessel</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Scenario</th><th>Path Type</th><th>Why</th></tr></thead><tbody>
<tr><td>Value might be absent</td><td><code>MaybePath</code></td><td>Simple presence/absence</td></tr>
<tr><td>Operation might fail with typed error</td><td><code>EitherPath</code></td><td>Structured error handling</td></tr>
<tr><td>Wrapping exception-throwing code</td><td><code>TryPath</code></td><td>Exception → functional bridge</td></tr>
<tr><td>Side effects to defer</td><td><code>IOPath</code></td><td>Lazy, referential transparency</td></tr>
<tr><td>Need ALL validation errors</td><td><code>ValidationPath</code></td><td>Error accumulation</td></tr>
<tr><td>Bridging Java's Optional</td><td><code>OptionalPath</code></td><td>Stdlib compatibility</td></tr>
<tr><td>Always succeeds, pure value</td><td><code>IdPath</code></td><td>Generic/testing contexts</td></tr>
<tr><td>Custom monad</td><td><code>GenericPath</code></td><td>Universal escape hatch</td></tr>
<tr><td>Deep recursion without stack overflow</td><td><code>TrampolinePath</code></td><td>Stack-safe trampolining</td></tr>
<tr><td>DSL with sequential operations</td><td><code>FreePath</code></td><td>Interpretable programs</td></tr>
<tr><td>DSL with independent operations</td><td><code>FreeApPath</code></td><td>Static analysis, parallel</td></tr>
</tbody></table>
</div>
<p>The choice isn't always obvious, and that's fine. You can convert between
types as your needs evolve (<code>MaybePath</code> to <code>EitherPath</code> when you need error
messages, <code>TryPath</code> to <code>EitherPath</code> when you want typed errors). The
<a href="effect/conversions.html">Type Conversions</a> chapter covers these conversions in detail.</p>
<div id="admonition-see-also" class="admonition admonish-tip" role="note" aria-labelledby="admonition-see-also-title">
<div class="admonition-title">
<div id="admonition-see-also-title">
<p>See Also</p>
</div>
<a class="admonition-anchor-link" href="effect/path_types.html#admonition-see-also"></a>
</div>
<div>
<ul>
<li><a href="effect/composition.html">Composition Patterns</a> - Combining and sequencing Path operations</li>
<li><a href="effect/conversions.html">Type Conversions</a> - Converting between Path types</li>
<li><a href="effect/patterns.html">Patterns and Recipes</a> - Common usage patterns</li>
</ul>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="effect/capabilities.html">Capability Interfaces</a>
<strong>Next:</strong> <a href="effect/path_maybe.html">MaybePath</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="maybepath"><a class="header" href="#maybepath">MaybePath</a></h1>
<p><code>MaybePath&lt;A&gt;</code> wraps <code>Maybe&lt;A&gt;</code> for computations that might produce nothing.
It's the simplest failure mode: either you have a value, or you don't.</p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="effect/path_maybe.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>Creating MaybePath instances</li>
<li>Core operations: map, via, zipWith</li>
<li>Recovery and filtering</li>
<li>Extraction patterns</li>
<li>When to use (and when not to)</li>
</ul>
</div>
</div>
<hr />
<h2 id="creation"><a class="header" href="#creation">Creation</a></h2>
<pre><code class="language-java">// From a value
MaybePath&lt;String&gt; greeting = Path.just("hello");

// Absence
MaybePath&lt;String&gt; nothing = Path.nothing();

// From existing Maybe
MaybePath&lt;User&gt; user = Path.maybe(repository.findById(id));

// From nullable (null becomes Nothing)
MaybePath&lt;String&gt; fromNullable = Path.fromNullable(possiblyNull);
</code></pre>
<hr />
<h2 id="core-operations"><a class="header" href="#core-operations">Core Operations</a></h2>
<pre><code class="language-java">MaybePath&lt;String&gt; name = Path.just("Alice");

// Transform
MaybePath&lt;Integer&gt; length = name.map(String::length);  // Just(5)

// Chain
MaybePath&lt;String&gt; upper = name.via(s -&gt; Path.just(s.toUpperCase()));

// Combine independent values
MaybePath&lt;Integer&gt; age = Path.just(25);
MaybePath&lt;String&gt; summary = name.zipWith(age, (n, a) -&gt; n + " is " + a);
// Just("Alice is 25")
</code></pre>
<hr />
<h2 id="recovery"><a class="header" href="#recovery">Recovery</a></h2>
<pre><code class="language-java">MaybePath&lt;User&gt; user = Path.maybe(findUser(id))
    .orElse(() -&gt; Path.just(User.guest()));

// Filter (returns Nothing if predicate fails)
MaybePath&lt;Integer&gt; positive = Path.just(42).filter(n -&gt; n &gt; 0);  // Just(42)
MaybePath&lt;Integer&gt; rejected = Path.just(-1).filter(n -&gt; n &gt; 0);  // Nothing
</code></pre>
<hr />
<h2 id="extraction"><a class="header" href="#extraction">Extraction</a></h2>
<pre><code class="language-java">MaybePath&lt;String&gt; path = Path.just("hello");

Maybe&lt;String&gt; maybe = path.run();
String value = path.getOrElse("default");
String value = path.getOrThrow(() -&gt; new NoSuchElementException());
</code></pre>
<hr />
<h2 id="when-to-use"><a class="header" href="#when-to-use">When to Use</a></h2>
<p><code>MaybePath</code> is right when:</p>
<ul>
<li>Absence is <strong>normal</strong>, not exceptional</li>
<li>You don't need to explain <em>why</em> the value is missing</li>
<li>You're modelling optional data (configuration, nullable fields, lookups)</li>
</ul>
<p><code>MaybePath</code> is wrong when:</p>
<ul>
<li>Callers need to know the reason for failure → use <a href="effect/path_either.html">EitherPath</a></li>
<li>You're wrapping code that throws → use <a href="effect/path_try.html">TryPath</a></li>
</ul>
<div id="admonition-see-also" class="admonition admonish-tip" role="note" aria-labelledby="admonition-see-also-title">
<div class="admonition-title">
<div id="admonition-see-also-title">
<p>See Also</p>
</div>
<a class="admonition-anchor-link" href="effect/path_maybe.html#admonition-see-also"></a>
</div>
<div>
<ul>
<li><a href="effect/../monads/maybe_monad.html">Maybe Monad</a> - Underlying type for MaybePath</li>
<li><a href="effect/path_optional.html">OptionalPath</a> - Similar, but wraps Java's <code>Optional</code></li>
</ul>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="effect/path_types.html">Path Types Overview</a>
<strong>Next:</strong> <a href="effect/path_either.html">EitherPath</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="eitherpath"><a class="header" href="#eitherpath">EitherPath</a></h1>
<p><code>EitherPath&lt;E, A&gt;</code> wraps <code>Either&lt;E, A&gt;</code> for computations with typed errors.
The left side carries failure; the right side carries success. (Right is
right, as the mnemonic goes.)</p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="effect/path_either.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>Creating EitherPath instances</li>
<li>Core operations and error handling</li>
<li>Bifunctor operations</li>
<li>Extraction patterns</li>
<li>When to use (and when not to)</li>
</ul>
</div>
</div>
<hr />
<h2 id="creation-1"><a class="header" href="#creation-1">Creation</a></h2>
<pre><code class="language-java">// Success
EitherPath&lt;Error, Integer&gt; success = Path.right(42);

// Failure
EitherPath&lt;Error, Integer&gt; failure = Path.left(new ValidationError("invalid"));

// From existing Either
EitherPath&lt;Error, User&gt; user = Path.either(validateUser(input));
</code></pre>
<hr />
<h2 id="core-operations-1"><a class="header" href="#core-operations-1">Core Operations</a></h2>
<pre><code class="language-java">EitherPath&lt;String, Integer&gt; number = Path.right(42);

// Transform success
EitherPath&lt;String, String&gt; formatted = number.map(n -&gt; "Value: " + n);

// Chain
EitherPath&lt;String, Integer&gt; doubled = number.via(n -&gt;
    n &gt; 0 ? Path.right(n * 2) : Path.left("Must be positive"));

// Combine independent values
EitherPath&lt;String, String&gt; name = Path.right("Alice");
EitherPath&lt;String, Integer&gt; age = Path.right(25);
EitherPath&lt;String, Person&gt; person = name.zipWith(age, Person::new);
</code></pre>
<hr />
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<pre><code class="language-java">EitherPath&lt;String, Config&gt; config = Path.either(loadConfig())
    // Provide fallback value
    .recover(error -&gt; Config.defaults())

    // Transform error type
    .mapError(e -&gt; new ConfigError(e))

    // Recover with another computation
    .recoverWith(error -&gt; Path.either(loadBackupConfig()))

    // Provide alternative path
    .orElse(() -&gt; Path.right(Config.defaults()));
</code></pre>
<hr />
<h2 id="bifunctor-operations"><a class="header" href="#bifunctor-operations">Bifunctor Operations</a></h2>
<p>Transform both sides simultaneously:</p>
<pre><code class="language-java">EitherPath&lt;String, Integer&gt; original = Path.right(42);

EitherPath&lt;Integer, String&gt; transformed = original.bimap(
    String::length,      // Transform error
    n -&gt; "Value: " + n   // Transform success
);
</code></pre>
<hr />
<h2 id="extraction-1"><a class="header" href="#extraction-1">Extraction</a></h2>
<pre><code class="language-java">EitherPath&lt;String, Integer&gt; path = Path.right(42);
Either&lt;String, Integer&gt; either = path.run();

// Pattern match
String result = either.fold(
    error -&gt; "Error: " + error,
    value -&gt; "Value: " + value
);

// Direct access (throws if wrong side)
if (either.isRight()) {
    Integer value = either.getRight();
}
</code></pre>
<hr />
<h2 id="when-to-use-1"><a class="header" href="#when-to-use-1">When to Use</a></h2>
<p><code>EitherPath</code> is right when:</p>
<ul>
<li>Errors carry meaningful, typed information</li>
<li>Different errors need different handling</li>
<li>You're building validation pipelines (with short-circuit semantics)</li>
<li>You want to transform errors as they propagate</li>
</ul>
<p><code>EitherPath</code> is wrong when:</p>
<ul>
<li>You need to collect <em>all</em> errors → use <a href="effect/path_validation.html">ValidationPath</a></li>
<li>Absence isn't really an error → use <a href="effect/path_maybe.html">MaybePath</a></li>
</ul>
<div id="admonition-see-also" class="admonition admonish-tip" role="note" aria-labelledby="admonition-see-also-title">
<div class="admonition-title">
<div id="admonition-see-also-title">
<p>See Also</p>
</div>
<a class="admonition-anchor-link" href="effect/path_either.html#admonition-see-also"></a>
</div>
<div>
<ul>
<li><a href="effect/../monads/either_monad.html">Either Monad</a> - Underlying type for EitherPath</li>
<li><a href="effect/path_validation.html">ValidationPath</a> - For accumulating errors</li>
</ul>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="effect/path_maybe.html">MaybePath</a>
<strong>Next:</strong> <a href="effect/path_try.html">TryPath</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="trypath"><a class="header" href="#trypath">TryPath</a></h1>
<p><code>TryPath&lt;A&gt;</code> wraps <code>Try&lt;A&gt;</code> for computations that might throw exceptions.
It bridges the gap between Java's exception-based world and functional
composition.</p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="effect/path_try.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>Creating TryPath instances</li>
<li>Core operations</li>
<li>Exception-based error handling</li>
<li>Extraction patterns</li>
<li>When to use (and when not to)</li>
</ul>
</div>
</div>
<hr />
<h2 id="creation-2"><a class="header" href="#creation-2">Creation</a></h2>
<pre><code class="language-java">// Successful value
TryPath&lt;Integer&gt; success = Path.success(42);

// Failed value
TryPath&lt;Integer&gt; failure = Path.failure(new RuntimeException("oops"));

// From computation that may throw
TryPath&lt;Integer&gt; parsed = Path.tryOf(() -&gt; Integer.parseInt(input));

// From existing Try
TryPath&lt;Config&gt; config = Path.tryPath(loadConfigTry());
</code></pre>
<hr />
<h2 id="core-operations-2"><a class="header" href="#core-operations-2">Core Operations</a></h2>
<pre><code class="language-java">TryPath&lt;String&gt; content = Path.tryOf(() -&gt; Files.readString(path));

// Transform
TryPath&lt;Integer&gt; lineCount = content.map(s -&gt; s.split("\n").length);

// Chain
TryPath&lt;Data&gt; data = content.via(c -&gt; Path.tryOf(() -&gt; parseJson(c)));

// Combine
TryPath&lt;String&gt; file1 = Path.tryOf(() -&gt; readFile("a.txt"));
TryPath&lt;String&gt; file2 = Path.tryOf(() -&gt; readFile("b.txt"));
TryPath&lt;String&gt; combined = file1.zipWith(file2, (a, b) -&gt; a + "\n" + b);
</code></pre>
<hr />
<h2 id="error-handling-1"><a class="header" href="#error-handling-1">Error Handling</a></h2>
<pre><code class="language-java">TryPath&lt;Integer&gt; parsed = Path.tryOf(() -&gt; Integer.parseInt(input))
    // Recover with value
    .recover(ex -&gt; 0)

    // Recover based on exception type
    .recoverWith(ex -&gt; {
        if (ex instanceof NumberFormatException) {
            return Path.success(-1);
        }
        return Path.failure(ex);
    })

    // Alternative
    .orElse(() -&gt; Path.success(defaultValue));
</code></pre>
<hr />
<h2 id="extraction-2"><a class="header" href="#extraction-2">Extraction</a></h2>
<pre><code class="language-java">TryPath&lt;Integer&gt; path = Path.success(42);
Try&lt;Integer&gt; tryValue = path.run();

Integer value = path.getOrElse(-1);

if (tryValue.isSuccess()) {
    System.out.println("Value: " + tryValue.get());
} else {
    System.out.println("Error: " + tryValue.getCause().getMessage());
}
</code></pre>
<hr />
<h2 id="when-to-use-2"><a class="header" href="#when-to-use-2">When to Use</a></h2>
<p><code>TryPath</code> is right when:</p>
<ul>
<li>You're wrapping APIs that throw exceptions</li>
<li>The specific exception type matters for recovery</li>
<li>You want exception-safe composition without try-catch blocks</li>
<li>Interoperating with legacy code</li>
</ul>
<p><code>TryPath</code> is wrong when:</p>
<ul>
<li>You want typed errors (not just <code>Throwable</code>) → use <a href="effect/path_either.html">EitherPath</a></li>
<li>The code doesn't throw → use <a href="effect/path_maybe.html">MaybePath</a> or <a href="effect/path_either.html">EitherPath</a></li>
</ul>
<div id="admonition-see-also" class="admonition admonish-tip" role="note" aria-labelledby="admonition-see-also-title">
<div class="admonition-title">
<div id="admonition-see-also-title">
<p>See Also</p>
</div>
<a class="admonition-anchor-link" href="effect/path_try.html#admonition-see-also"></a>
</div>
<div>
<ul>
<li><a href="effect/../monads/try_monad.html">Try Monad</a> - Underlying type for TryPath</li>
<li><a href="effect/path_either.html">EitherPath</a> - For typed errors</li>
</ul>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="effect/path_either.html">EitherPath</a>
<strong>Next:</strong> <a href="effect/path_io.html">IOPath</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="iopath"><a class="header" href="#iopath">IOPath</a></h1>
<p><code>IOPath&lt;A&gt;</code> wraps <code>IO&lt;A&gt;</code> for <strong>deferred</strong> side-effectful computations.
Unlike other Path types, nothing happens until you explicitly run it.</p>
<blockquote>
<p><em>"Buy the ticket, take the ride... and if it occasionally gets a little
heavier than what you had in mind, well... maybe chalk it up to forced
consciousness expansion."</em></p>
<p>— Hunter S. Thompson, <em>Fear and Loathing in Las Vegas</em></p>
</blockquote>
<p>Thompson's advice applies here. When you call <code>unsafeRun()</code>, you've bought
the ticket. The effects will happen. There's no going back. Until that moment,
an <code>IOPath</code> is just a description—a plan you haven't committed to yet.</p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="effect/path_io.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>Creating IOPath instances</li>
<li>Deferred execution model</li>
<li>Error handling patterns</li>
<li>Resource management (bracket, withResource)</li>
<li>Parallel execution</li>
<li>When to use (and when not to)</li>
</ul>
</div>
</div>
<hr />
<h2 id="creation-3"><a class="header" href="#creation-3">Creation</a></h2>
<pre><code class="language-java">// Pure value (no effects)
IOPath&lt;Integer&gt; pure = Path.ioPure(42);

// Deferred effect
IOPath&lt;String&gt; readFile = Path.io(() -&gt; Files.readString(Paths.get("data.txt")));

// From existing IO
IOPath&lt;Connection&gt; conn = Path.ioPath(databaseIO);
</code></pre>
<hr />
<h2 id="core-operations-all-deferred"><a class="header" href="#core-operations-all-deferred">Core Operations (All Deferred)</a></h2>
<pre><code class="language-java">IOPath&lt;String&gt; content = Path.io(() -&gt; fetchFromApi(url));

// Transform (deferred)
IOPath&lt;Data&gt; data = content.map(this::parse);

// Chain (deferred)
IOPath&lt;Result&gt; result = content.via(c -&gt; Path.io(() -&gt; process(c)));

// Combine (deferred)
IOPath&lt;String&gt; header = Path.io(() -&gt; readHeader());
IOPath&lt;String&gt; body = Path.io(() -&gt; readBody());
IOPath&lt;String&gt; combined = header.zipWith(body, (h, b) -&gt; h + "\n" + b);

// Sequence (discarding first result)
IOPath&lt;Unit&gt; setup = Path.ioRunnable(() -&gt; log("Starting..."));
IOPath&lt;Data&gt; withSetup = setup.then(() -&gt; Path.io(() -&gt; loadData()));
</code></pre>
<hr />
<h2 id="execution-buying-the-ticket"><a class="header" href="#execution-buying-the-ticket">Execution: Buying the Ticket</a></h2>
<pre><code class="language-java">IOPath&lt;String&gt; io = Path.io(() -&gt; fetchData());

// Execute (may throw)
String result = io.unsafeRun();

// Execute safely (captures exceptions)
Try&lt;String&gt; result = io.runSafe();

// Convert to TryPath (executes immediately)
TryPath&lt;String&gt; tryPath = io.toTryPath();
</code></pre>
<p>The naming is deliberate. <code>unsafeRun</code> warns you: referential transparency
ends here. Side effects are about to happen. Call it at the boundaries of
your system (in your <code>main</code> method, your HTTP handler, your message consumer),
not scattered throughout your business logic.</p>
<hr />
<h2 id="error-handling-2"><a class="header" href="#error-handling-2">Error Handling</a></h2>
<pre><code class="language-java">IOPath&lt;Config&gt; config = Path.io(() -&gt; loadConfig())
    // Handle any exception
    .handleError(ex -&gt; Config.defaults())

    // Handle with another effect
    .handleErrorWith(ex -&gt; Path.io(() -&gt; loadBackupConfig()))

    // Ensure cleanup runs regardless of outcome
    .guarantee(() -&gt; releaseResources());
</code></pre>
<hr />
<h2 id="resource-management"><a class="header" href="#resource-management">Resource Management</a></h2>
<h3 id="bracket"><a class="header" href="#bracket">bracket</a></h3>
<p>The <code>bracket</code> pattern ensures resources are properly released:</p>
<pre><code class="language-java">IOPath&lt;String&gt; content = IOPath.bracket(
    () -&gt; Files.newInputStream(path),      // acquire
    in -&gt; new String(in.readAllBytes()),   // use
    in -&gt; in.close()                       // release (always runs)
);
</code></pre>
<h3 id="withresource"><a class="header" href="#withresource">withResource</a></h3>
<p>For <code>AutoCloseable</code> resources:</p>
<pre><code class="language-java">IOPath&lt;String&gt; content = IOPath.withResource(
    () -&gt; Files.newBufferedReader(path),
    reader -&gt; reader.lines().collect(Collectors.joining("\n"))
);
// reader.close() is called automatically
</code></pre>
<hr />
<h2 id="parallel-execution"><a class="header" href="#parallel-execution">Parallel Execution</a></h2>
<pre><code class="language-java">IOPath&lt;String&gt; fetchA = Path.io(() -&gt; callServiceA());
IOPath&lt;String&gt; fetchB = Path.io(() -&gt; callServiceB());

// Run in parallel, combine results
IOPath&lt;String&gt; combined = fetchA.parZipWith(fetchB, (a, b) -&gt; a + b);

// Race: first to complete wins
IOPath&lt;String&gt; fastest = fetchA.race(fetchB);

// Run many in parallel
List&lt;IOPath&lt;String&gt;&gt; ios = List.of(io1, io2, io3);
IOPath&lt;List&lt;String&gt;&gt; all = PathOps.parSequenceIO(ios);
</code></pre>
<hr />
<h2 id="retry-with-resilience"><a class="header" href="#retry-with-resilience">Retry with Resilience</a></h2>
<pre><code class="language-java">IOPath&lt;String&gt; resilient = Path.io(() -&gt; callFlakyService())
    .retry(5, Duration.ofMillis(100))  // exponential backoff
    .withRetry(RetryPolicy.fixed(3, Duration.ofMillis(50)));
</code></pre>
<p>See <a href="effect/patterns.html">Patterns and Recipes</a> for more resilience patterns.</p>
<hr />
<h2 id="lazy-evaluation-in-action"><a class="header" href="#lazy-evaluation-in-action">Lazy Evaluation in Action</a></h2>
<pre><code class="language-java">IOPath&lt;String&gt; effect = Path.io(() -&gt; {
    System.out.println("Side effect!");  // Not printed yet
    return "result";
});

// Still nothing
IOPath&lt;Integer&gt; transformed = effect.map(String::length);

// NOW it runs
Integer length = transformed.unsafeRun();  // Prints "Side effect!"
</code></pre>
<hr />
<h2 id="when-to-use-3"><a class="header" href="#when-to-use-3">When to Use</a></h2>
<p><code>IOPath</code> is right when:</p>
<ul>
<li>You're performing side effects (file I/O, network, database)</li>
<li>You want lazy evaluation: describe now, execute later</li>
<li>You want referential transparency throughout your core logic</li>
<li>You need to compose complex effect pipelines before committing</li>
</ul>
<p><code>IOPath</code> is wrong when:</p>
<ul>
<li>You want immediate execution → use <a href="effect/path_try.html">TryPath</a></li>
<li>There are no side effects → use <a href="effect/path_either.html">EitherPath</a> or <a href="effect/path_maybe.html">MaybePath</a></li>
</ul>
<div id="admonition-see-also" class="admonition admonish-tip" role="note" aria-labelledby="admonition-see-also-title">
<div class="admonition-title">
<div id="admonition-see-also-title">
<p>See Also</p>
</div>
<a class="admonition-anchor-link" href="effect/path_io.html#admonition-see-also"></a>
</div>
<div>
<ul>
<li><a href="effect/../monads/io_monad.html">IO Monad</a> - Underlying type for IOPath</li>
<li><a href="effect/composition.html">Composition Patterns</a> - More composition techniques</li>
<li><a href="effect/patterns.html">Patterns and Recipes</a> - Resilience and resource patterns</li>
<li><a href="effect/advanced_topics.html">Advanced Topics</a> - Deep dive on IOPath features</li>
</ul>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="effect/path_try.html">TryPath</a>
<strong>Next:</strong> <a href="effect/path_validation.html">ValidationPath</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="validationpath"><a class="header" href="#validationpath">ValidationPath</a></h1>
<p><code>ValidationPath&lt;E, A&gt;</code> wraps <code>Validated&lt;E, A&gt;</code> for computations that
<strong>accumulate</strong> errors instead of short-circuiting on the first failure.</p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="effect/path_validation.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>Creating ValidationPath instances</li>
<li>Error accumulation with zipWithAccum</li>
<li>Semigroup for combining errors</li>
<li>Extraction patterns</li>
<li>When to use (and when not to)</li>
</ul>
</div>
</div>
<hr />
<h2 id="creation-4"><a class="header" href="#creation-4">Creation</a></h2>
<pre><code class="language-java">// Valid value
ValidationPath&lt;List&lt;String&gt;, Integer&gt; valid =
    Path.valid(42, Semigroups.list());

// Invalid value with errors
ValidationPath&lt;List&lt;String&gt;, Integer&gt; invalid =
    Path.invalid(List.of("Error 1", "Error 2"), Semigroups.list());

// From existing Validated
ValidationPath&lt;String, User&gt; user =
    Path.validation(validatedUser, Semigroups.first());
</code></pre>
<p>The <code>Semigroup&lt;E&gt;</code> parameter defines how errors combine when multiple
validations fail. Common choices:</p>
<ul>
<li><code>Semigroups.list()</code> - concatenate error lists</li>
<li><code>Semigroups.string("; ")</code> - join strings with separator</li>
</ul>
<hr />
<h2 id="core-operations-3"><a class="header" href="#core-operations-3">Core Operations</a></h2>
<pre><code class="language-java">ValidationPath&lt;List&lt;String&gt;, String&gt; name =
    Path.valid("Alice", Semigroups.list());

// Transform (same as other paths)
ValidationPath&lt;List&lt;String&gt;, Integer&gt; length = name.map(String::length);

// Chain with via (short-circuits on first error)
ValidationPath&lt;List&lt;String&gt;, String&gt; upper =
    name.via(s -&gt; Path.valid(s.toUpperCase(), Semigroups.list()));
</code></pre>
<hr />
<h2 id="error-accumulation-the-point-of-it-all"><a class="header" href="#error-accumulation-the-point-of-it-all">Error Accumulation: The Point of It All</a></h2>
<p>The key operation is <code>zipWithAccum</code>, which collects <strong>all</strong> errors:</p>
<pre><code class="language-java">ValidationPath&lt;List&lt;String&gt;, String&gt; nameV = validateName(input.name());
ValidationPath&lt;List&lt;String&gt;, String&gt; emailV = validateEmail(input.email());
ValidationPath&lt;List&lt;String&gt;, Integer&gt; ageV = validateAge(input.age());

// Accumulate ALL errors (does not short-circuit)
ValidationPath&lt;List&lt;String&gt;, User&gt; userV = nameV.zipWith3Accum(
    emailV,
    ageV,
    User::new
);

// If name and email both fail:
// Invalid(["Name too short", "Invalid email format"])
// NOT just Invalid(["Name too short"])
</code></pre>
<p>Compare with <code>zipWith</code>, which short-circuits:</p>
<pre><code class="language-java">// Short-circuits: only first error returned
ValidationPath&lt;List&lt;String&gt;, User&gt; shortCircuit =
    nameV.zipWith(emailV, ageV, User::new);
</code></pre>
<hr />
<h2 id="combining-validations"><a class="header" href="#combining-validations">Combining Validations</a></h2>
<pre><code class="language-java">// andAlso runs both, accumulating errors, keeping first value if both valid
ValidationPath&lt;List&lt;String&gt;, String&gt; thorough =
    checkNotEmpty(name)
        .andAlso(checkMaxLength(name, 100))
        .andAlso(checkNoSpecialChars(name));
// All three checks run; all errors collected
</code></pre>
<hr />
<h2 id="extraction-3"><a class="header" href="#extraction-3">Extraction</a></h2>
<pre><code class="language-java">ValidationPath&lt;List&lt;String&gt;, User&gt; path = validateUser(input);
Validated&lt;List&lt;String&gt;, User&gt; validated = path.run();

String result = validated.fold(
    errors -&gt; "Errors: " + String.join(", ", errors),
    user -&gt; "Valid user: " + user.name()
);
</code></pre>
<hr />
<h2 id="when-to-use-4"><a class="header" href="#when-to-use-4">When to Use</a></h2>
<p><code>ValidationPath</code> is right when:</p>
<ul>
<li>You want users to see <strong>all</strong> validation errors at once</li>
<li>Multiple independent checks must all run</li>
<li>Form validation, batch processing, comprehensive error reports</li>
<li>Being kind to users matters (it does)</li>
</ul>
<p><code>ValidationPath</code> is wrong when:</p>
<ul>
<li>You only need the first error → use <a href="effect/path_either.html">EitherPath</a></li>
<li>Subsequent validations depend on earlier ones passing → use <a href="effect/path_either.html">EitherPath</a> with <code>via</code></li>
</ul>
<div id="admonition-see-also" class="admonition admonish-tip" role="note" aria-labelledby="admonition-see-also-title">
<div class="admonition-title">
<div id="admonition-see-also-title">
<p>See Also</p>
</div>
<a class="admonition-anchor-link" href="effect/path_validation.html#admonition-see-also"></a>
</div>
<div>
<ul>
<li><a href="effect/../monads/validated_monad.html">Validated</a> - Underlying type for ValidationPath</li>
<li><a href="effect/path_either.html">EitherPath</a> - For short-circuit validation</li>
<li><a href="effect/../functional/semigroup_and_monoid.html">Semigroup and Monoid</a> - How errors combine</li>
</ul>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="effect/path_io.html">IOPath</a>
<strong>Next:</strong> <a href="effect/path_id.html">IdPath</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="idpath"><a class="header" href="#idpath">IdPath</a></h1>
<p><code>IdPath&lt;A&gt;</code> wraps <code>Id&lt;A&gt;</code>, the identity monad. It always contains a value
and never fails. This sounds useless until you need it.</p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="effect/path_id.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>Creating IdPath instances</li>
<li>Core operations</li>
<li>Use cases for the identity path</li>
<li>When to use (and when not to)</li>
</ul>
</div>
</div>
<hr />
<h2 id="creation-5"><a class="header" href="#creation-5">Creation</a></h2>
<pre><code class="language-java">IdPath&lt;String&gt; id = Path.id("hello");
IdPath&lt;User&gt; fromId = Path.idPath(idUser);
</code></pre>
<hr />
<h2 id="core-operations-4"><a class="header" href="#core-operations-4">Core Operations</a></h2>
<pre><code class="language-java">IdPath&lt;String&gt; name = Path.id("Alice");

IdPath&lt;Integer&gt; length = name.map(String::length);  // Id(5)
IdPath&lt;String&gt; upper = name.via(s -&gt; Path.id(s.toUpperCase()));
IdPath&lt;String&gt; combined = name.zipWith(Path.id(25), (n, a) -&gt; n + " is " + a);
</code></pre>
<hr />
<h2 id="extraction-4"><a class="header" href="#extraction-4">Extraction</a></h2>
<pre><code class="language-java">IdPath&lt;String&gt; path = Path.id("hello");
String value = path.run().value();  // "hello"
String value = path.get();          // "hello"
</code></pre>
<hr />
<h2 id="when-to-use-5"><a class="header" href="#when-to-use-5">When to Use</a></h2>
<p><code>IdPath</code> is right when:</p>
<ul>
<li>You're writing generic code that works over any Path type</li>
<li>Testing monadic code with known, predictable values</li>
<li>You need a "no-op" Path that always succeeds</li>
<li>Satisfying a type parameter that demands a Path</li>
</ul>
<p><code>IdPath</code> is wrong when:</p>
<ul>
<li>Failure is possible → you need one of the other types</li>
</ul>
<div id="admonition-generic-code-example" class="admonition admonish-example" role="note" aria-labelledby="admonition-generic-code-example-title">
<div class="admonition-title">
<div id="admonition-generic-code-example-title">
<p>Generic Code Example</p>
</div>
<a class="admonition-anchor-link" href="effect/path_id.html#admonition-generic-code-example"></a>
</div>
<div>
<pre><code class="language-java">// Works with any Path type
&lt;P extends Path&lt;P, A&gt;, A&gt; P process(P path) {
    return path.map(this::transform);
}

// Test with IdPath (no failures to worry about)
IdPath&lt;String&gt; testPath = Path.id("test");
IdPath&lt;String&gt; result = process(testPath);
</code></pre>
</div>
</div>
<div id="admonition-see-also" class="admonition admonish-tip" role="note" aria-labelledby="admonition-see-also-title">
<div class="admonition-title">
<div id="admonition-see-also-title">
<p>See Also</p>
</div>
<a class="admonition-anchor-link" href="effect/path_id.html#admonition-see-also"></a>
</div>
<div>
<ul>
<li><a href="effect/../monads/identity.html">Identity</a> - Underlying type for IdPath</li>
</ul>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="effect/path_validation.html">ValidationPath</a>
<strong>Next:</strong> <a href="effect/path_optional.html">OptionalPath</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="optionalpath"><a class="header" href="#optionalpath">OptionalPath</a></h1>
<p><code>OptionalPath&lt;A&gt;</code> wraps Java's <code>java.util.Optional&lt;A&gt;</code>, bridging the
standard library and the Path API.</p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="effect/path_optional.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>Creating OptionalPath instances</li>
<li>Core operations</li>
<li>Conversion to other types</li>
<li>When to use (and when not to)</li>
</ul>
</div>
</div>
<hr />
<h2 id="creation-6"><a class="header" href="#creation-6">Creation</a></h2>
<pre><code class="language-java">OptionalPath&lt;String&gt; present = Path.present("hello");
OptionalPath&lt;String&gt; absent = Path.absent();
OptionalPath&lt;User&gt; user = Path.optional(repository.findById(id));
</code></pre>
<hr />
<h2 id="core-operations-5"><a class="header" href="#core-operations-5">Core Operations</a></h2>
<pre><code class="language-java">OptionalPath&lt;String&gt; name = Path.present("Alice");

OptionalPath&lt;Integer&gt; length = name.map(String::length);
OptionalPath&lt;String&gt; upper = name.via(s -&gt; Path.present(s.toUpperCase()));
</code></pre>
<hr />
<h2 id="extraction-and-conversion"><a class="header" href="#extraction-and-conversion">Extraction and Conversion</a></h2>
<pre><code class="language-java">OptionalPath&lt;String&gt; path = Path.present("hello");

Optional&lt;String&gt; optional = path.run();
String value = path.getOrElse("default");
boolean hasValue = path.isPresent();

// Convert to MaybePath for richer operations
MaybePath&lt;String&gt; maybe = path.toMaybePath();
</code></pre>
<hr />
<h2 id="when-to-use-6"><a class="header" href="#when-to-use-6">When to Use</a></h2>
<p><code>OptionalPath</code> is right when:</p>
<ul>
<li>You're integrating with Java APIs that return <code>Optional</code></li>
<li>You prefer staying close to standard library semantics</li>
<li>Bridging between Higher-Kinded-J and existing codebases</li>
</ul>
<p><code>OptionalPath</code> is wrong when:</p>
<ul>
<li>You're not constrained by <code>Optional</code> → <a href="effect/path_maybe.html">MaybePath</a> is slightly richer</li>
</ul>
<div id="admonition-see-also" class="admonition admonish-tip" role="note" aria-labelledby="admonition-see-also-title">
<div class="admonition-title">
<div id="admonition-see-also-title">
<p>See Also</p>
</div>
<a class="admonition-anchor-link" href="effect/path_optional.html#admonition-see-also"></a>
</div>
<div>
<ul>
<li><a href="effect/../monads/optional_monad.html">Optional Monad</a> - Underlying type for OptionalPath</li>
<li><a href="effect/path_maybe.html">MaybePath</a> - Alternative for optional values</li>
</ul>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="effect/path_id.html">IdPath</a>
<strong>Next:</strong> <a href="effect/path_generic.html">GenericPath</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="genericpath"><a class="header" href="#genericpath">GenericPath</a></h1>
<p><code>GenericPath&lt;F, A&gt;</code> is the escape hatch. It wraps <em>any</em> <code>Kind&lt;F, A&gt;</code> with
a <code>Monad</code> instance, letting you use Path operations on custom types.</p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="effect/path_generic.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>Creating GenericPath instances</li>
<li>Working with custom monads</li>
<li>Extraction patterns</li>
<li>When to use (and when not to)</li>
</ul>
</div>
</div>
<hr />
<h2 id="creation-7"><a class="header" href="#creation-7">Creation</a></h2>
<pre><code class="language-java">Monad&lt;ListKind.Witness&gt; listMonad = ListMonad.INSTANCE;
Kind&lt;ListKind.Witness, Integer&gt; listKind =
    ListKindHelper.LIST.widen(List.of(1, 2, 3));

GenericPath&lt;ListKind.Witness, Integer&gt; listPath =
    Path.generic(listKind, listMonad);
</code></pre>
<hr />
<h2 id="core-operations-6"><a class="header" href="#core-operations-6">Core Operations</a></h2>
<pre><code class="language-java">GenericPath&lt;ListKind.Witness, Integer&gt; numbers = Path.generic(listKind, listMonad);

GenericPath&lt;ListKind.Witness, String&gt; strings = numbers.map(n -&gt; "n" + n);

GenericPath&lt;ListKind.Witness, Integer&gt; doubled = numbers.via(n -&gt;
    Path.generic(ListKindHelper.LIST.widen(List.of(n, n * 2)), listMonad));
</code></pre>
<hr />
<h2 id="extraction-5"><a class="header" href="#extraction-5">Extraction</a></h2>
<pre><code class="language-java">Kind&lt;ListKind.Witness, Integer&gt; kind = path.runKind();
List&lt;Integer&gt; list = ListKindHelper.LIST.narrow(kind);
</code></pre>
<hr />
<h2 id="when-to-use-7"><a class="header" href="#when-to-use-7">When to Use</a></h2>
<p><code>GenericPath</code> is right when:</p>
<ul>
<li>You have a custom monad not covered by specific Path types</li>
<li>Writing highly generic code across multiple monad types</li>
<li>Experimenting with new effect types</li>
</ul>
<div id="admonition-extensibility-by-design" class="admonition admonish-tip" role="note" aria-labelledby="admonition-extensibility-by-design-title">
<div class="admonition-title">
<div id="admonition-extensibility-by-design-title">
<p>Extensibility by Design</p>
</div>
<a class="admonition-anchor-link" href="effect/path_generic.html#admonition-extensibility-by-design"></a>
</div>
<div>
<p><code>GenericPath</code> demonstrates the power of higher-kinded types in Java: write
your algorithm once, and it works with <code>Maybe</code>, <code>Either</code>, <code>List</code>, <code>IO</code>, or
any custom monad. This is the same abstraction power that makes libraries
like Cats and ZIO flexible in Scala, now available in Java.</p>
</div>
</div>
<div id="admonition-see-also" class="admonition admonish-tip" role="note" aria-labelledby="admonition-see-also-title">
<div class="admonition-title">
<div id="admonition-see-also-title">
<p>See Also</p>
</div>
<a class="admonition-anchor-link" href="effect/path_generic.html#admonition-see-also"></a>
</div>
<div>
<ul>
<li><a href="effect/../hkts/hkt_introduction.html">HKT Introduction</a> - Higher-kinded type basics</li>
<li><a href="effect/../hkts/extending-simulation.html">Extending</a> - Creating custom types</li>
</ul>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="effect/path_optional.html">OptionalPath</a>
<strong>Next:</strong> <a href="effect/path_trampoline.html">TrampolinePath</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="trampolinepath"><a class="header" href="#trampolinepath">TrampolinePath</a></h1>
<p><code>TrampolinePath&lt;A&gt;</code> wraps <code>Trampoline&lt;A&gt;</code> for <strong>stack-safe recursion</strong>. Deep
recursive algorithms that would blow the stack with direct recursion become
safe with trampolining.</p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="effect/path_trampoline.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>Creating TrampolinePath instances</li>
<li>Stack-safe recursive patterns</li>
<li>When to use (and when not to)</li>
</ul>
</div>
</div>
<hr />
<h2 id="creation-8"><a class="header" href="#creation-8">Creation</a></h2>
<pre><code class="language-java">// Immediate value (already computed)
TrampolinePath&lt;Integer&gt; done = Path.trampolineDone(42);

// Suspended computation (thunked)
TrampolinePath&lt;Integer&gt; suspended = Path.trampolineSuspend(() -&gt; 42);

// From existing Trampoline
TrampolinePath&lt;Integer&gt; path = Path.trampoline(trampoline);
</code></pre>
<hr />
<h2 id="core-operations-7"><a class="header" href="#core-operations-7">Core Operations</a></h2>
<pre><code class="language-java">TrampolinePath&lt;Integer&gt; start = Path.trampolineDone(10);

TrampolinePath&lt;Integer&gt; doubled = start.map(n -&gt; n * 2);  // 20

TrampolinePath&lt;Integer&gt; chained = start.via(n -&gt;
    Path.trampolineDone(n + 5));  // 15
</code></pre>
<hr />
<h2 id="stack-safe-recursion"><a class="header" href="#stack-safe-recursion">Stack-Safe Recursion</a></h2>
<p>The real power is in recursive algorithms. Here's factorial without stack overflow:</p>
<pre><code class="language-java">TrampolinePath&lt;Long&gt; factorial(long n) {
    return factorialHelper(n, 1L);
}

TrampolinePath&lt;Long&gt; factorialHelper(long n, long acc) {
    if (n &lt;= 1) {
        return Path.trampolineDone(acc);
    }
    // Suspend to avoid stack growth
    return Path.trampolineSuspend(() -&gt;
        factorialHelper(n - 1, n * acc).run());
}

// Compute factorial of 10000 - no stack overflow!
Long result = factorial(10000L).run().run();
</code></pre>
<p>Compare with naive recursion:</p>
<pre><code class="language-java">// This WILL overflow the stack for large n
long naiveFactorial(long n) {
    if (n &lt;= 1) return 1;
    return n * naiveFactorial(n - 1);  // Stack frame per call!
}
</code></pre>
<hr />
<h2 id="mutual-recursion"><a class="header" href="#mutual-recursion">Mutual Recursion</a></h2>
<p>Trampolining also handles mutual recursion:</p>
<pre><code class="language-java">TrampolinePath&lt;Boolean&gt; isEven(int n) {
    if (n == 0) return Path.trampolineDone(true);
    return Path.trampolineSuspend(() -&gt; isOdd(n - 1).run());
}

TrampolinePath&lt;Boolean&gt; isOdd(int n) {
    if (n == 0) return Path.trampolineDone(false);
    return Path.trampolineSuspend(() -&gt; isEven(n - 1).run());
}

// Works for any depth
Boolean result = isEven(1_000_000).run().run();  // true
</code></pre>
<hr />
<h2 id="extraction-6"><a class="header" href="#extraction-6">Extraction</a></h2>
<pre><code class="language-java">TrampolinePath&lt;Integer&gt; path = Path.trampolineDone(42);

// Get the Trampoline
Trampoline&lt;Integer&gt; trampoline = path.run();

// Execute (runs the trampoline to completion)
Integer value = trampoline.run();

// Or chain: path.run().run()
</code></pre>
<hr />
<h2 id="when-to-use-8"><a class="header" href="#when-to-use-8">When to Use</a></h2>
<p><code>TrampolinePath</code> is right when:</p>
<ul>
<li>You have deep recursive algorithms that could overflow the stack</li>
<li>Tree traversal, graph algorithms, or mathematical computations</li>
<li>Mutual recursion patterns</li>
<li>You need guaranteed stack safety regardless of input size</li>
</ul>
<p><code>TrampolinePath</code> is wrong when:</p>
<ul>
<li>Recursion depth is bounded and small (regular recursion is simpler)</li>
<li>You're not doing recursion at all</li>
<li>Performance is critical and you can use iteration instead</li>
</ul>
<div id="admonition-how-it-works" class="admonition admonish-tip" role="note" aria-labelledby="admonition-how-it-works-title">
<div class="admonition-title">
<div id="admonition-how-it-works-title">
<p>How It Works</p>
</div>
<a class="admonition-anchor-link" href="effect/path_trampoline.html#admonition-how-it-works"></a>
</div>
<div>
<p>Trampolining converts recursive calls into a loop. Instead of each recursive
call adding a stack frame, it returns a "continue" instruction. The trampoline
runner loops until it gets a "done" instruction. Result: O(1) stack space
regardless of recursion depth.</p>
</div>
</div>
<div id="admonition-see-also" class="admonition admonish-tip" role="note" aria-labelledby="admonition-see-also-title">
<div class="admonition-title">
<div id="admonition-see-also-title">
<p>See Also</p>
</div>
<a class="admonition-anchor-link" href="effect/path_trampoline.html#admonition-see-also"></a>
</div>
<div>
<ul>
<li><a href="effect/../monads/trampoline.html">Trampoline</a> - Underlying type for TrampolinePath</li>
</ul>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="effect/path_generic.html">GenericPath</a>
<strong>Next:</strong> <a href="effect/path_free.html">FreePath</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="freepath"><a class="header" href="#freepath">FreePath</a></h1>
<p><code>FreePath&lt;F, A&gt;</code> wraps <code>Free&lt;F, A&gt;</code> for building <strong>domain-specific languages</strong>
(DSLs). It separates the <em>description</em> of a program from its <em>execution</em>,
enabling multiple interpreters for the same program.</p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="effect/path_free.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>Creating FreePath instances</li>
<li>Building DSL operations</li>
<li>Writing interpreters</li>
<li>When to use (and when not to)</li>
</ul>
</div>
</div>
<hr />
<h2 id="the-idea"><a class="header" href="#the-idea">The Idea</a></h2>
<p>Free monads let you:</p>
<ol>
<li><strong>Describe</strong> operations as data structures</li>
<li><strong>Compose</strong> descriptions into programs</li>
<li><strong>Interpret</strong> programs with different strategies</li>
</ol>
<p>This enables testing with mock interpreters, swapping implementations, and
reasoning about programs as data.</p>
<hr />
<h2 id="defining-a-dsl"><a class="header" href="#defining-a-dsl">Defining a DSL</a></h2>
<p>First, define your operations as a sum type (algebra):</p>
<pre><code class="language-java">// Console operations
sealed interface ConsoleOp&lt;A&gt; permits Ask, Tell {}

record Ask&lt;A&gt;(String prompt, Function&lt;String, A&gt; next) implements ConsoleOp&lt;A&gt; {}
record Tell&lt;A&gt;(String message, A next) implements ConsoleOp&lt;A&gt; {}
</code></pre>
<hr />
<h2 id="creating-programs"><a class="header" href="#creating-programs">Creating Programs</a></h2>
<p>Lift operations into <code>FreePath</code>:</p>
<pre><code class="language-java">FreePath&lt;ConsoleOp.Witness, String&gt; ask(String prompt) {
    return Path.freeLiftF(new Ask&lt;&gt;(prompt, Function.identity()));
}

FreePath&lt;ConsoleOp.Witness, Void&gt; tell(String message) {
    return Path.freeLiftF(new Tell&lt;&gt;(message, null));
}
</code></pre>
<p>Compose into programs:</p>
<pre><code class="language-java">FreePath&lt;ConsoleOp.Witness, String&gt; greetUser =
    ask("What is your name?").via(name -&gt;
        tell("Hello, " + name + "!").map(v -&gt; name));
</code></pre>
<hr />
<h2 id="core-operations-8"><a class="header" href="#core-operations-8">Core Operations</a></h2>
<pre><code class="language-java">// Pure value (no operations)
FreePath&lt;ConsoleOp.Witness, Integer&gt; pure = Path.freePure(42);

// Transform results
FreePath&lt;ConsoleOp.Witness, String&gt; asString = pure.map(n -&gt; "Value: " + n);

// Chain operations
FreePath&lt;ConsoleOp.Witness, Integer&gt; chained = pure.via(n -&gt;
    ask("Continue?").map(s -&gt; n + s.length()));
</code></pre>
<hr />
<h2 id="interpreters"><a class="header" href="#interpreters">Interpreters</a></h2>
<p>An interpreter is a natural transformation from your algebra to a target monad:</p>
<pre><code class="language-java">// Real console interpreter
NaturalTransformation&lt;ConsoleOp.Witness, IO.Witness&gt; realInterpreter =
    new NaturalTransformation&lt;&gt;() {
        public &lt;A&gt; Kind&lt;IO.Witness, A&gt; apply(Kind&lt;ConsoleOp.Witness, A&gt; fa) {
            ConsoleOp&lt;A&gt; op = ConsoleOpHelper.narrow(fa);
            return switch (op) {
                case Ask&lt;A&gt; a -&gt; IO.of(() -&gt; {
                    System.out.print(a.prompt() + " ");
                    return a.next().apply(scanner.nextLine());
                });
                case Tell&lt;A&gt; t -&gt; IO.of(() -&gt; {
                    System.out.println(t.message());
                    return t.next();
                });
            };
        }
    };

// Test interpreter (uses predefined responses)
NaturalTransformation&lt;ConsoleOp.Witness, State.Witness&gt; testInterpreter = ...;
</code></pre>
<hr />
<h2 id="running-programs"><a class="header" href="#running-programs">Running Programs</a></h2>
<pre><code class="language-java">FreePath&lt;ConsoleOp.Witness, String&gt; program = greetUser;

// Get the Free structure
Free&lt;ConsoleOp.Witness, String&gt; free = program.run();

// Interpret to IO
Kind&lt;IO.Witness, String&gt; io = free.foldMap(realInterpreter, ioMonad);

// Execute
String result = IOKindHelper.narrow(io).unsafeRunSync();
</code></pre>
<hr />
<h2 id="when-to-use-9"><a class="header" href="#when-to-use-9">When to Use</a></h2>
<p><code>FreePath</code> is right when:</p>
<ul>
<li>You want to separate description from execution</li>
<li>Multiple interpreters for the same program (prod/test/mock)</li>
<li>Building embedded DSLs for domain operations</li>
<li>You need to inspect or transform programs before running them</li>
</ul>
<p><code>FreePath</code> is wrong when:</p>
<ul>
<li>Simple direct effects suffice → use <a href="effect/path_io.html">IOPath</a></li>
<li>You don't need multiple interpreters</li>
<li>Performance is critical (free monads have overhead)</li>
<li>Operations can be parallelized → consider <a href="effect/path_freeap.html">FreeApPath</a></li>
</ul>
<div id="admonition-testing-with-mock-interpreter" class="admonition admonish-example" role="note" aria-labelledby="admonition-testing-with-mock-interpreter-title">
<div class="admonition-title">
<div id="admonition-testing-with-mock-interpreter-title">
<p>Testing with Mock Interpreter</p>
</div>
<a class="admonition-anchor-link" href="effect/path_free.html#admonition-testing-with-mock-interpreter"></a>
</div>
<div>
<pre><code class="language-java">// Production: real database
NaturalTransformation&lt;DbOp.Witness, IO.Witness&gt; prodInterpreter = ...;

// Test: in-memory map
NaturalTransformation&lt;DbOp.Witness, State.Witness&gt; testInterpreter = ...;

// Same program, different interpreters
FreePath&lt;DbOp.Witness, User&gt; program = findUser(userId);
Kind&lt;IO.Witness, User&gt; prod = program.run().foldMap(prodInterpreter, ioMonad);
Kind&lt;State.Witness, User&gt; test = program.run().foldMap(testInterpreter, stateMonad);
</code></pre>
</div>
</div>
<div id="admonition-see-also" class="admonition admonish-tip" role="note" aria-labelledby="admonition-see-also-title">
<div class="admonition-title">
<div id="admonition-see-also-title">
<p>See Also</p>
</div>
<a class="admonition-anchor-link" href="effect/path_free.html#admonition-see-also"></a>
</div>
<div>
<ul>
<li><a href="effect/../monads/free_monad.html">Free Monad</a> - Underlying type for FreePath</li>
<li><a href="effect/path_freeap.html">FreeApPath</a> - Applicative variant for parallel operations</li>
</ul>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="effect/path_trampoline.html">TrampolinePath</a>
<strong>Next:</strong> <a href="effect/path_freeap.html">FreeApPath</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="freeappath"><a class="header" href="#freeappath">FreeApPath</a></h1>
<p><code>FreeApPath&lt;F, A&gt;</code> wraps <code>FreeAp&lt;F, A&gt;</code> for building <strong>applicative DSLs</strong>.
Unlike <code>FreePath</code>, operations in <code>FreeApPath</code> can be analyzed and potentially
executed in parallel because they don't depend on each other's results.</p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="effect/path_freeap.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>Creating FreeApPath instances</li>
<li>Difference from FreePath</li>
<li>Static analysis of programs</li>
<li>Parallel execution</li>
<li>When to use (and when not to)</li>
</ul>
</div>
</div>
<hr />
<h2 id="the-key-difference"><a class="header" href="#the-key-difference">The Key Difference</a></h2>
<p><code>FreePath</code> (monadic): Each operation can depend on previous results.
<code>FreeApPath</code> (applicative): Operations are independent; results combine at the end.</p>
<pre><code class="language-java">// FreePath: second operation depends on first
FreePath&lt;F, String&gt; monadic = getUser(id).via(user -&gt;
    getOrders(user.id()));  // Sequential: must wait for user

// FreeApPath: operations are independent
FreeApPath&lt;F, Summary&gt; applicative =
    getUser(id).zipWith(getOrders(id), Summary::new);  // Parallel-safe!
</code></pre>
<hr />
<h2 id="creation-9"><a class="header" href="#creation-9">Creation</a></h2>
<pre><code class="language-java">// Pure value
FreeApPath&lt;ConfigOp.Witness, String&gt; pure = Path.freeApPure("default");

// Lift an operation
FreeApPath&lt;ConfigOp.Witness, String&gt; dbUrl =
    Path.freeApLift(new GetConfig("database.url"));
</code></pre>
<hr />
<h2 id="core-operations-9"><a class="header" href="#core-operations-9">Core Operations</a></h2>
<pre><code class="language-java">FreeApPath&lt;ConfigOp.Witness, String&gt; host = getConfig("host");
FreeApPath&lt;ConfigOp.Witness, Integer&gt; port = getConfig("port").map(Integer::parseInt);

// Combine independent operations
FreeApPath&lt;ConfigOp.Witness, String&gt; url =
    host.zipWith(port, (h, p) -&gt; "http://" + h + ":" + p);

// Map over results
FreeApPath&lt;ConfigOp.Witness, String&gt; upper = host.map(String::toUpperCase);
</code></pre>
<hr />
<h2 id="static-analysis"><a class="header" href="#static-analysis">Static Analysis</a></h2>
<p>Because operations are independent, you can analyze programs before running them:</p>
<pre><code class="language-java">// Collect all config keys that will be requested
Set&lt;String&gt; getRequestedKeys(FreeAp&lt;ConfigOp.Witness, ?&gt; program) {
    return program.analyze(op -&gt; {
        GetConfig config = ConfigOpHelper.narrow(op);
        return Set.of(config.key());
    }, Monoids.set());
}

FreeApPath&lt;ConfigOp.Witness, DbConfig&gt; program =
    getConfig("db.host")
        .zipWith(getConfig("db.port"), DbConfig::new);

Set&lt;String&gt; keys = getRequestedKeys(program.run());
// Set.of("db.host", "db.port")
</code></pre>
<p>This enables:</p>
<ul>
<li>Validation before execution</li>
<li>Optimization (batching, caching)</li>
<li>Documentation generation</li>
<li>Dependency analysis</li>
</ul>
<hr />
<h2 id="parallel-execution-1"><a class="header" href="#parallel-execution-1">Parallel Execution</a></h2>
<p>Interpreters can exploit independence for parallelism:</p>
<pre><code class="language-java">// Sequential interpreter
NaturalTransformation&lt;ConfigOp.Witness, IO.Witness&gt; sequential =
    op -&gt; IO.of(() -&gt; loadConfig(op.key()));

// Parallel interpreter (batch all requests)
Kind&lt;IO.Witness, Config&gt; parallel = program.run().foldMap(
    batchingInterpreter,
    ioApplicative
);
</code></pre>
<hr />
<h2 id="running-programs-1"><a class="header" href="#running-programs-1">Running Programs</a></h2>
<pre><code class="language-java">FreeApPath&lt;ConfigOp.Witness, DbConfig&gt; program =
    getConfig("host").zipWith(getConfig("port"), DbConfig::new);

// Get the FreeAp structure
FreeAp&lt;ConfigOp.Witness, DbConfig&gt; freeAp = program.run();

// Interpret
Kind&lt;IO.Witness, DbConfig&gt; io = freeAp.foldMap(interpreter, ioApplicative);

// Execute
DbConfig config = IOKindHelper.narrow(io).unsafeRunSync();
</code></pre>
<hr />
<h2 id="when-to-use-10"><a class="header" href="#when-to-use-10">When to Use</a></h2>
<p><code>FreeApPath</code> is right when:</p>
<ul>
<li>Operations are <strong>independent</strong> (don't depend on each other's results)</li>
<li>You want to analyze programs before running (static analysis)</li>
<li>Parallel/batched execution is beneficial</li>
<li>Building configuration loaders, query builders, validation pipelines</li>
</ul>
<p><code>FreeApPath</code> is wrong when:</p>
<ul>
<li>Operations depend on previous results → use <a href="effect/path_free.html">FreePath</a></li>
<li>You don't need static analysis or parallelism</li>
<li>Simpler direct effects suffice → use <a href="effect/path_io.html">IOPath</a></li>
</ul>
<div id="admonition-configuration-loading" class="admonition admonish-example" role="note" aria-labelledby="admonition-configuration-loading-title">
<div class="admonition-title">
<div id="admonition-configuration-loading-title">
<p>Configuration Loading</p>
</div>
<a class="admonition-anchor-link" href="effect/path_freeap.html#admonition-configuration-loading"></a>
</div>
<div>
<pre><code class="language-java">// Define config operations
FreeApPath&lt;ConfigOp.Witness, String&gt; dbHost = getConfig("db.host");
FreeApPath&lt;ConfigOp.Witness, Integer&gt; dbPort = getConfig("db.port").map(Integer::parseInt);
FreeApPath&lt;ConfigOp.Witness, String&gt; dbName = getConfig("db.name");

// Combine into complete config (all three fetched independently)
FreeApPath&lt;ConfigOp.Witness, DbConfig&gt; dbConfig =
    dbHost.zipWith3(dbPort, dbName, DbConfig::new);

// Analyze: what keys are needed?
Set&lt;String&gt; keys = analyze(dbConfig);  // {db.host, db.port, db.name}

// Execute: fetch all in parallel/batch
DbConfig config = run(dbConfig, parallelInterpreter);
</code></pre>
</div>
</div>
<div id="admonition-applicative-vs-monad" class="admonition admonish-tip" role="note" aria-labelledby="admonition-applicative-vs-monad-title">
<div class="admonition-title">
<div id="admonition-applicative-vs-monad-title">
<p>Applicative vs Monad</p>
</div>
<a class="admonition-anchor-link" href="effect/path_freeap.html#admonition-applicative-vs-monad"></a>
</div>
<div>
<p>Applicative is less powerful than Monad (you can't use previous results
to decide the next operation), but this limitation is a feature: it enables
static analysis and parallelism that monads cannot provide.</p>
</div>
</div>
<div id="admonition-see-also" class="admonition admonish-tip" role="note" aria-labelledby="admonition-see-also-title">
<div class="admonition-title">
<div id="admonition-see-also-title">
<p>See Also</p>
</div>
<a class="admonition-anchor-link" href="effect/path_freeap.html#admonition-see-also"></a>
</div>
<div>
<ul>
<li><a href="effect/../monads/free_applicative.html">Free Applicative</a> - Underlying type for FreeApPath</li>
<li><a href="effect/path_free.html">FreePath</a> - Monadic variant for dependent operations</li>
<li><a href="effect/../typeclasses/applicative.html">Applicative</a> - The Applicative typeclass</li>
</ul>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="effect/path_free.html">FreePath</a>
<strong>Next:</strong> <a href="effect/composition.html">Composition Patterns</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="composition-patterns"><a class="header" href="#composition-patterns">Composition Patterns</a></h1>
<blockquote>
<p><em>"The world, that understandable and lawful world, was slipping away."</em></p>
<p>— William Golding, <em>Lord of the Flies</em></p>
</blockquote>
<p>Golding's boys lost their grip on order gradually, one compromised rule at a
time. Code works the same way. A null check here, an uncaught exception there,
a boolean flag that means three different things depending on context, and
suddenly your "understandable and lawful" service layer has become something
you approach with trepidation.</p>
<p>Composition is how you hold the line. Each pattern in this chapter is a way
of connecting operations so that failures propagate predictably, successes
build on each other, and the logic remains visible even as complexity grows.</p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="effect/composition.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>Sequential composition with <code>via</code> and <code>then</code> for dependent computations</li>
<li>Independent combination with <code>zipWith</code> for parallel-style composition</li>
<li>Debugging techniques using <code>peek</code> and logging patterns</li>
<li>Error handling strategies: recovery, transformation, and fallback chains</li>
<li>When to mix composition styles, and how to do it cleanly</li>
</ul>
</div>
</div>
<hr />
<h2 id="sequential-composition-one-thing-after-another"><a class="header" href="#sequential-composition-one-thing-after-another">Sequential Composition: <em>One Thing After Another</em></a></h2>
<p>The <code>via</code> method chains computations where each step depends on the previous
result. It's the workhorse of effect composition.</p>
<pre><code class="language-java">EitherPath&lt;Error, Invoice&gt; pipeline =
    Path.either(findUser(userId))
        .via(user -&gt; Path.either(getCart(user)))
        .via(cart -&gt; Path.either(calculateTotal(cart)))
        .via(total -&gt; Path.either(createInvoice(total)));
</code></pre>
<p>Each <code>via</code> receives the success value and returns a new Path. The railway
model applies: travel along the success track until something fails, then
skip to the end.</p>
<h3 id="short-circuiting"><a class="header" href="#short-circuiting">Short-Circuiting</a></h3>
<p>When a step fails, subsequent steps don't execute:</p>
<pre><code class="language-java">EitherPath&lt;String, String&gt; result =
    Path.right("start")
        .via(s -&gt; Path.left("failed here"))     // Fails
        .via(s -&gt; Path.right(s + " never"))     // Skipped
        .via(s -&gt; Path.right(s + " reached"));  // Skipped

// result.run() → Left("failed here")
</code></pre>
<p>This isn't just convenient; it's essential. Without short-circuiting, you'd
need defensive checks at every step. The Path handles it structurally.</p>
<h3 id="then-sequencing-without-the-value"><a class="header" href="#then-sequencing-without-the-value"><code>then</code>: Sequencing Without the Value</a></h3>
<p>Sometimes you need sequencing but don't care about the previous result:</p>
<pre><code class="language-java">IOPath&lt;Result&gt; workflow =
    Path.io(() -&gt; log.info("Starting"))
        .then(() -&gt; Path.io(() -&gt; initialise()))
        .then(() -&gt; Path.io(() -&gt; process()))
        .then(() -&gt; Path.io(() -&gt; log.info("Done")));
</code></pre>
<p><code>then</code> discards the previous value and runs the next computation. Use it for
side effects that must happen in order but don't pass data forward.</p>
<hr />
<h2 id="independent-combination-all-together-now"><a class="header" href="#independent-combination-all-together-now">Independent Combination: <em>All Together Now</em></a></h2>
<p><code>zipWith</code> combines computations that don't depend on each other. Neither
needs the other's result to proceed.</p>
<pre><code class="language-java">EitherPath&lt;String, String&gt; name = validateName(input.name());
EitherPath&lt;String, String&gt; email = validateEmail(input.email());
EitherPath&lt;String, Integer&gt; age = validateAge(input.age());

EitherPath&lt;String, User&gt; user = name.zipWith3(email, age, User::new);
</code></pre>
<p>If all three succeed, <code>User::new</code> receives the values. If any fails, the
first failure propagates.</p>
<h3 id="the-difference-matters"><a class="header" href="#the-difference-matters">The Difference Matters</a></h3>
<p>This distinction trips people up, so let's be explicit:</p>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>What It Expresses</th></tr></thead><tbody>
<tr><td><code>via</code></td><td>"Do this, <strong>then</strong> use the result to decide what's next"</td></tr>
<tr><td><code>zipWith</code></td><td>"Do these <strong>independently</strong>, then combine the results"</td></tr>
</tbody></table>
</div>
<pre><code class="language-java">// WRONG: using via when computations are independent
Path.right(validateName(input))
    .via(name -&gt; Path.right(validateEmail(input)))  // Doesn't use name!
    .via(email -&gt; Path.right(validateAge(input)));  // Doesn't use email!

// RIGHT: using zipWith for independent computations
validateName(input).zipWith3(
    validateEmail(input),
    validateAge(input),
    User::new
);
</code></pre>
<p>The first version works but misleads readers into thinking there's a
dependency. The second says what it means.</p>
<h3 id="variants"><a class="header" href="#variants">Variants</a></h3>
<pre><code class="language-java">// Two values
pathA.zipWith(pathB, (a, b) -&gt; combine(a, b))

// Three values
pathA.zipWith3(pathB, pathC, (a, b, c) -&gt; combine(a, b, c))

// Four values
pathA.zipWith4(pathB, pathC, pathD, (a, b, c, d) -&gt; combine(a, b, c, d))
</code></pre>
<p>Beyond four, consider whether your design is asking too much of a single
expression.</p>
<hr />
<h2 id="mixed-composition-the-real-world"><a class="header" href="#mixed-composition-the-real-world">Mixed Composition: The Real World</a></h2>
<p>Production code rarely uses just one pattern. You validate independently,
then sequence dependent operations, then combine more independent work.
The key is clarity about which pattern you're using where.</p>
<pre><code class="language-java">EitherPath&lt;Error, Order&gt; createOrder(OrderInput input) {
    // Phase 1: Independent validation
    EitherPath&lt;Error, String&gt; name = validateName(input.name());
    EitherPath&lt;Error, String&gt; email = validateEmail(input.email());
    EitherPath&lt;Error, Address&gt; address = validateAddress(input.address());

    EitherPath&lt;Error, CustomerInfo&gt; customer =
        name.zipWith3(email, address, CustomerInfo::new);

    // Phase 2: Sequential operations that depend on customer
    return customer
        .via(info -&gt; Path.either(checkInventory(input.items())))
        .via(inventory -&gt; Path.either(calculatePricing(inventory)))
        .via(pricing -&gt; Path.either(createOrder(customer, pricing)));
}
</code></pre>
<p>The phases are distinct: independent validation first, then a sequential
pipeline that threads through the validated data. Readers can see the
structure at a glance.</p>
<hr />
<h2 id="parallel-composition"><a class="header" href="#parallel-composition">Parallel Composition</a></h2>
<blockquote>
<p><em>"The machine didn't think about one thing at a time. It thought about
many things, all at once, in parallel streams that only converged when
they had to."</em></p>
<p>— Neal Stephenson, <em>Cryptonomicon</em></p>
</blockquote>
<p>Sequential composition with <code>via</code> is appropriate when each step depends on
the previous. But when computations are genuinely independent, running them
in parallel can dramatically reduce total execution time.</p>
<h3 id="expressing-parallelism-with-parzipwith"><a class="header" href="#expressing-parallelism-with-parzipwith">Expressing Parallelism with parZipWith</a></h3>
<p><code>parZipWith</code> is <code>zipWith</code> with explicit parallel execution:</p>
<pre><code class="language-java">IOPath&lt;User&gt; fetchUser = IOPath.delay(() -&gt; userService.get(id));
IOPath&lt;Preferences&gt; fetchPrefs = IOPath.delay(() -&gt; prefService.get(id));

// Sequential: ~200ms (100ms + 100ms)
IOPath&lt;Profile&gt; sequential = fetchUser.zipWith(fetchPrefs, Profile::new);

// Parallel: ~100ms (max of both)
IOPath&lt;Profile&gt; parallel = fetchUser.parZipWith(fetchPrefs, Profile::new);
</code></pre>
<p>The operations are the same; the execution strategy differs. Use <code>parZipWith</code>
when you want to make the parallel intent explicit.</p>
<h3 id="n-ary-parallel-composition"><a class="header" href="#n-ary-parallel-composition">N-ary Parallel Composition</a></h3>
<p>For three or four independent paths, use <code>PathOps</code> utilities:</p>
<pre><code class="language-java">IOPath&lt;Dashboard&gt; dashboard = PathOps.parZip3(
    fetchMetrics(),
    fetchAlerts(),
    fetchUsers(),
    Dashboard::new
);

IOPath&lt;Report&gt; report = PathOps.parZip4(
    fetchSales(),
    fetchInventory(),
    fetchCustomers(),
    fetchTrends(),
    Report::new
);
</code></pre>
<h3 id="list-parallelism-with-parsequenceio"><a class="header" href="#list-parallelism-with-parsequenceio">List Parallelism with parSequenceIO</a></h3>
<p>When you have a dynamic number of independent operations:</p>
<pre><code class="language-java">List&lt;IOPath&lt;Product&gt;&gt; fetches = productIds.stream()
    .map(id -&gt; IOPath.delay(() -&gt; productService.get(id)))
    .toList();

// All fetches run concurrently
IOPath&lt;List&lt;Product&gt;&gt; products = PathOps.parSequenceIO(fetches);
</code></pre>
<h3 id="racing-computations"><a class="header" href="#racing-computations">Racing Computations</a></h3>
<p>Sometimes you want whichever completes first:</p>
<pre><code class="language-java">IOPath&lt;Config&gt; primary = IOPath.delay(() -&gt; fetchFromPrimary());
IOPath&lt;Config&gt; backup = IOPath.delay(() -&gt; fetchFromBackup());

// Returns whichever config arrives first
IOPath&lt;Config&gt; fastest = primary.race(backup);
</code></pre>
<h3 id="sequential-vs-parallel-the-decision"><a class="header" href="#sequential-vs-parallel-the-decision">Sequential vs Parallel: The Decision</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Scenario</th><th>Use</th></tr></thead><tbody>
<tr><td>B needs A's result</td><td><code>via</code> (sequential)</td></tr>
<tr><td>A and B independent, need both</td><td><code>parZipWith</code></td></tr>
<tr><td>3-4 independent operations</td><td><code>parZip3</code>, <code>parZip4</code></td></tr>
<tr><td>List of independent operations</td><td><code>parSequenceIO</code></td></tr>
<tr><td>Want fastest of alternatives</td><td><code>race</code></td></tr>
</tbody></table>
</div>
<p>The wrong choice doesn't break correctness—just performance. When in doubt,
prefer sequential; parallelise when profiling shows it matters.</p>
<div id="admonition-see-also" class="admonition admonish-tip" role="note" aria-labelledby="admonition-see-also-title">
<div class="admonition-title">
<div id="admonition-see-also-title">
<p>See Also</p>
</div>
<a class="admonition-anchor-link" href="effect/composition.html#admonition-see-also"></a>
</div>
<div>
<p>See <a href="effect/advanced_topics.html">Advanced Effect Topics</a> for comprehensive coverage of
parallel execution patterns including <code>parSequenceFuture</code> and <code>raceIO</code>.</p>
</div>
</div>
<hr />
<h2 id="debugging-with-peek-1"><a class="header" href="#debugging-with-peek-1">Debugging with <code>peek</code></a></h2>
<p>Effect chains can frustrate debugging. When something fails mid-pipeline,
you know <em>that</em> it failed but not <em>where</em>. Traditional print debugging
would break the chain. Debugger breakpoints are awkward with lambdas.</p>
<p><code>peek</code> solves this by letting you observe values without disrupting the flow:</p>
<pre><code class="language-java">EitherPath&lt;Error, User&gt; result =
    Path.either(validateInput(input))
        .peek(valid -&gt; log.debug("Validated: {}", valid))
        .via(valid -&gt; Path.either(createUser(valid)))
        .peek(user -&gt; log.info("Created user: {}", user.getId()))
        .via(user -&gt; Path.either(sendWelcomeEmail(user)))
        .peek(email -&gt; log.debug("Email sent"));
</code></pre>
<p><code>peek</code> only executes on the success track. Failures pass through silently,
which is usually what you want when tracing the happy path.</p>
<h3 id="a-debugging-helper"><a class="header" href="#a-debugging-helper">A Debugging Helper</a></h3>
<p>For detailed tracing, wrap the pattern:</p>
<pre><code class="language-java">&lt;A&gt; EitherPath&lt;Error, A&gt; traced(EitherPath&lt;Error, A&gt; path, String step) {
    return path.peek(v -&gt; log.debug("[{}] → {}", step, v));
}

EitherPath&lt;Error, Invoice&gt; pipeline =
    traced(Path.either(findUser(id)), "findUser")
        .via(user -&gt; traced(Path.either(getCart(user)), "getCart"))
        .via(cart -&gt; traced(Path.either(checkout(cart)), "checkout"));
</code></pre>
<p>When something goes wrong, the logs show exactly how far you got.</p>
<hr />
<h2 id="error-handling-strategies"><a class="header" href="#error-handling-strategies">Error Handling Strategies</a></h2>
<p>Not every error should halt processing. Sometimes you have a sensible
fallback. Sometimes you need to transform the error for the next layer.
Sometimes you want to try several approaches before giving up.</p>
<h3 id="strategy-1-recover-with-a-default"><a class="header" href="#strategy-1-recover-with-a-default">Strategy 1: <em>Recover with a Default</em></a></h3>
<p>The operation might fail, but you have a reasonable fallback:</p>
<pre><code class="language-java">MaybePath&lt;Config&gt; config = Path.maybe(loadConfig())
    .orElse(() -&gt; Path.just(Config.defaults()));

EitherPath&lt;Error, User&gt; user = Path.either(findUser(id))
    .recover(error -&gt; User.guest());
</code></pre>
<p>Use this when the fallback is genuinely acceptable, not when you're
papering over problems you should be handling properly.</p>
<h3 id="strategy-2-transform-the-error"><a class="header" href="#strategy-2-transform-the-error">Strategy 2: <em>Transform the Error</em></a></h3>
<p>Low-level errors leak implementation details. Transform them at layer
boundaries:</p>
<pre><code class="language-java">EitherPath&lt;ServiceError, Data&gt; result =
    Path.either(externalApi.fetch())
        .mapError(apiError -&gt; new ServiceError("API unavailable", apiError));
</code></pre>
<p>The original error is preserved as the cause; callers see a domain-appropriate
type.</p>
<h3 id="strategy-3-fallback-chain"><a class="header" href="#strategy-3-fallback-chain">Strategy 3: <em>Fallback Chain</em></a></h3>
<p>Multiple sources for the same data, each with trade-offs:</p>
<pre><code class="language-java">EitherPath&lt;Error, Config&gt; config =
    Path.either(loadFromFile())
        .recoverWith(e1 -&gt; {
            log.warn("File config failed: {}", e1);
            return Path.either(loadFromEnvironment());
        })
        .recoverWith(e2 -&gt; {
            log.warn("Env config failed: {}", e2);
            return Path.right(Config.defaults());
        });
</code></pre>
<p>Each <code>recoverWith</code> only triggers if the previous step failed. The first
success short-circuits the chain.</p>
<h3 id="strategy-4-accumulate-all-errors"><a class="header" href="#strategy-4-accumulate-all-errors">Strategy 4: <em>Accumulate All Errors</em></a></h3>
<p>For validation where users should see everything wrong at once:</p>
<pre><code class="language-java">ValidationPath&lt;List&lt;String&gt;, User&gt; user =
    validateName(input.name())
        .zipWith3Accum(
            validateEmail(input.email()),
            validateAge(input.age()),
            User::new
        );

// All three validations run; all errors collected
</code></pre>
<p>See <a href="effect/path_types.html#validationpath">ValidationPath</a> for the full API.</p>
<h3 id="strategy-5-error-enrichment"><a class="header" href="#strategy-5-error-enrichment">Strategy 5: <em>Error Enrichment</em></a></h3>
<p>Add context as errors propagate:</p>
<pre><code class="language-java">EitherPath&lt;DetailedError, Data&gt; enriched =
    path.mapError(error -&gt; new DetailedError(
        error,
        "During user lookup",
        Map.of("userId", userId, "timestamp", Instant.now())
    ));
</code></pre>
<p>When the error surfaces, you know not just <em>what</em> failed but <em>where</em> and
<em>with what context</em>.</p>
<hr />
<h2 id="conversion-between-paths"><a class="header" href="#conversion-between-paths">Conversion Between Paths</a></h2>
<p>As requirements evolve, you may need to switch Path types:</p>
<h3 id="maybepath--eitherpath"><a class="header" href="#maybepath--eitherpath">MaybePath → EitherPath</a></h3>
<p>Absence becomes a typed error:</p>
<pre><code class="language-java">MaybePath&lt;User&gt; maybe = Path.maybe(findUser(id));
EitherPath&lt;String, User&gt; either = maybe.toEitherPath("User not found");
</code></pre>
<h3 id="trypath--eitherpath"><a class="header" href="#trypath--eitherpath">TryPath → EitherPath</a></h3>
<p>Exception becomes a typed error:</p>
<pre><code class="language-java">TryPath&lt;Config&gt; tried = Path.tryOf(() -&gt; loadConfig());
EitherPath&lt;String, Config&gt; either = tried.toEitherPath(Throwable::getMessage);
</code></pre>
<h3 id="iopath--trypath"><a class="header" href="#iopath--trypath">IOPath → TryPath</a></h3>
<p>Execute the deferred effect and capture the result:</p>
<pre><code class="language-java">IOPath&lt;Data&gt; io = Path.io(() -&gt; fetchData());
TryPath&lt;Data&gt; tried = io.toTryPath();  // Executes immediately!
</code></pre>
<div id="admonition-io-execution" class="admonition admonish-warning" role="note" aria-labelledby="admonition-io-execution-title">
<div class="admonition-title">
<div id="admonition-io-execution-title">
<p>IO Execution</p>
</div>
<a class="admonition-anchor-link" href="effect/composition.html#admonition-io-execution"></a>
</div>
<div>
<p><code>toTryPath()</code> on an <code>IOPath</code> executes the effect. The result is no longer
deferred. Be intentional about when you cross this boundary.</p>
</div>
</div>
<h3 id="the-full-conversion-map"><a class="header" href="#the-full-conversion-map">The Full Conversion Map</a></h3>
<p>See <a href="effect/conversions.html">Type Conversions</a> for comprehensive coverage of all
conversion paths.</p>
<hr />
<h2 id="a-realistic-example"><a class="header" href="#a-realistic-example">A Realistic Example</a></h2>
<p>Bringing the patterns together:</p>
<pre><code class="language-java">public class OrderService {
    private final UserRepository users;
    private final InventoryService inventory;
    private final PaymentService payments;

    public EitherPath&lt;OrderError, Order&gt; placeOrder(OrderRequest request) {
        // Validate request (fail-fast)
        return validateRequest(request)
            .peek(v -&gt; log.debug("Request validated"))

            // Get user (convert Maybe → Either)
            .via(valid -&gt; Path.maybe(users.findById(valid.userId()))
                .toEitherPath(() -&gt; new OrderError.UserNotFound(valid.userId())))
            .peek(user -&gt; log.debug("Found user: {}", user.getId()))

            // Check inventory
            .via(user -&gt; Path.either(inventory.check(request.items()))
                .mapError(OrderError.InventoryError::new))

            // Process payment
            .via(available -&gt; Path.tryOf(() -&gt;
                    payments.charge(user, available.total()))
                .toEitherPath(OrderError.PaymentFailed::new))
            .peek(payment -&gt; log.info("Payment processed: {}", payment.getId()))

            // Create order
            .via(payment -&gt; Path.right(
                createOrder(user, request.items(), payment)));
    }

    private EitherPath&lt;OrderError, ValidatedRequest&gt; validateRequest(
            OrderRequest request) {
        if (request.items().isEmpty()) {
            return Path.left(new OrderError.EmptyCart());
        }
        return Path.right(new ValidatedRequest(request));
    }
}
</code></pre>
<p>The structure is visible: validate, fetch, check, charge, create. Errors
propagate with appropriate types. Logging traces the happy path. Each
conversion (<code>toEitherPath</code>, <code>mapError</code>) happens at a deliberate boundary.</p>
<hr />
<h2 id="common-mistakes"><a class="header" href="#common-mistakes">Common Mistakes</a></h2>
<h3 id="mistake-1-using-via-for-independent-operations"><a class="header" href="#mistake-1-using-via-for-independent-operations">Mistake 1: <em>Using <code>via</code> for Independent Operations</em></a></h3>
<pre><code class="language-java">// Misleading: suggests email validation depends on name
validateName(input)
    .via(name -&gt; validateEmail(input))  // Doesn't use name!

// Clearer: shows independence
validateName(input).zipWith(validateEmail(input), (n, e) -&gt; ...)
</code></pre>
<h3 id="mistake-2-side-effects-in-map"><a class="header" href="#mistake-2-side-effects-in-map">Mistake 2: <em>Side Effects in <code>map</code></em></a></h3>
<pre><code class="language-java">// Wrong: side effect hidden in map
path.map(user -&gt; {
    database.save(user);  // Side effect!
    return user;
});

// Right: use peek for side effects
path.peek(user -&gt; database.save(user));

// Or be explicit with IOPath
path.via(user -&gt; Path.io(() -&gt; {
    database.save(user);
    return user;
}));
</code></pre>
<h3 id="mistake-3-forgetting-to-run"><a class="header" href="#mistake-3-forgetting-to-run">Mistake 3: <em>Forgetting to Run</em></a></h3>
<pre><code class="language-java">// Bug: nothing happens
void processUser(String id) {
    Path.maybe(findUser(id))
        .map(this::process);  // Result discarded!
}

// Fixed: extract the result
void processUser(String id) {
    Path.maybe(findUser(id))
        .map(this::process)
        .run();
}
</code></pre>
<h3 id="mistake-4-converting-back-and-forth"><a class="header" href="#mistake-4-converting-back-and-forth">Mistake 4: <em>Converting Back and Forth</em></a></h3>
<pre><code class="language-java">// Wasteful: converting repeatedly
Path.maybe(findUser(id))
    .toEitherPath(() -&gt; error)
    .toMaybePath()
    .toEitherPath(() -&gt; error);  // Why?

// Clean: convert once
Path.maybe(findUser(id))
    .toEitherPath(() -&gt; error);
</code></pre>
<hr />
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Pattern</th><th>Method</th><th>When to Use</th></tr></thead><tbody>
<tr><td>Sequential</td><td><code>via</code></td><td>Each step depends on the previous</td></tr>
<tr><td>Sequential (ignore value)</td><td><code>then</code></td><td>Sequencing without data flow</td></tr>
<tr><td>Independent</td><td><code>zipWith</code></td><td>Combine unrelated computations</td></tr>
<tr><td>Parallel binary</td><td><code>parZipWith</code></td><td>Two independent computations</td></tr>
<tr><td>Parallel n-ary</td><td><code>parZip3</code>, <code>parZip4</code></td><td>3-4 independent computations</td></tr>
<tr><td>Parallel list</td><td><code>parSequenceIO</code></td><td>Dynamic number of computations</td></tr>
<tr><td>First-to-finish</td><td><code>race</code></td><td>Redundant sources, timeouts</td></tr>
<tr><td>Accumulate errors</td><td><code>zipWithAccum</code></td><td>Collect all validation failures</td></tr>
<tr><td>Debug</td><td><code>peek</code></td><td>Observe without disrupting</td></tr>
<tr><td>Default value</td><td><code>recover</code></td><td>Provide fallback on failure</td></tr>
<tr><td>Transform error</td><td><code>mapError</code></td><td>Change error type at boundaries</td></tr>
<tr><td>Fallback chain</td><td><code>recoverWith</code></td><td>Try alternatives in order</td></tr>
<tr><td>Type conversion</td><td><code>toEitherPath</code>, etc.</td><td>Change Path type</td></tr>
</tbody></table>
</div>
<p>The world remains understandable and lawful when each operation has a clear
purpose and failures propagate predictably. Composition is the discipline
that makes this possible.</p>
<p>Continue to <a href="effect/forpath_comprehension.html">ForPath Comprehension</a> for detailed coverage of
moving between Path types.</p>
<div id="admonition-see-also-1" class="admonition admonish-tip" role="note" aria-labelledby="admonition-see-also-1-title">
<div class="admonition-title">
<div id="admonition-see-also-1-title">
<p>See Also</p>
</div>
<a class="admonition-anchor-link" href="effect/composition.html#admonition-see-also-1"></a>
</div>
<div>
<ul>
<li><a href="effect/../functional/monad.html">Monad</a> - The type class behind <code>via</code></li>
<li><a href="effect/../functional/applicative.html">Applicative</a> - The type class behind <code>zipWith</code></li>
<li><a href="effect/../functional/for_comprehension.html">For Comprehension</a> - Alternative syntax for monadic composition</li>
</ul>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="effect/path_types.html">Path Types</a>
<strong>Next:</strong> <a href="effect/forpath_comprehension.html">ForPath Comprehension</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="forpath-for-comprehensions-with-effect-paths"><a class="header" href="#forpath-for-comprehensions-with-effect-paths">ForPath: For-Comprehensions with Effect Paths</a></h1>
<blockquote>
<p><em>"Though this be madness, yet there is method in't."</em></p>
<p>— William Shakespeare, <em>Hamlet</em></p>
</blockquote>
<p>And so it is with for-comprehensions: what appears to be arcane syntax hides a
deeply methodical approach to composing sequential operations.</p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="effect/forpath_comprehension.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How ForPath bridges the For comprehension system and the Effect Path API</li>
<li>Creating comprehensions directly with Path types (no manual <code>Kind</code> extraction)</li>
<li>Using generators (<code>.from()</code>), bindings (<code>.let()</code>), guards (<code>.when()</code>), and projections (<code>.yield()</code>)</li>
<li>Integrating optics with <code>.focus()</code> and <code>.match()</code> for structural navigation</li>
<li>Choosing between ForPath and the standard For class</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code:</p>
</div>
<a class="admonition-anchor-link" href="effect/forpath_comprehension.html#admonition-see-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/effect/ForPathExample.java">ForPathExample.java</a></p>
</div>
</div>
<hr />
<h2 id="the-problem-bridging-two-worlds"><a class="header" href="#the-problem-bridging-two-worlds">The Problem: Bridging Two Worlds</a></h2>
<p>The standard <a href="effect/../functional/for_comprehension.html">For</a> class provides powerful for-comprehension
syntax, but it operates on raw <code>Kind&lt;M, A&gt;</code> values and requires explicit <code>Monad</code> instances.
When working with the Effect Path API, this creates friction:</p>
<pre><code class="language-java">// Using standard For with Path types requires extraction and rewrapping
Kind&lt;MaybeKind.Witness, Integer&gt; kindResult = For.from(maybeMonad, path1.run().kind())
    .from(a -&gt; path2.run().kind())
    .yield((a, b) -&gt; a + b);

MaybePath&lt;Integer&gt; result = Path.maybe(MAYBE.narrow(kindResult));
</code></pre>
<p>The intent is clear, but the ceremony obscures it. <code>ForPath</code> eliminates this friction:</p>
<pre><code class="language-java">// ForPath works directly with Path types
MaybePath&lt;Integer&gt; result = ForPath.from(path1)
    .from(a -&gt; path2)
    .yield((a, b) -&gt; a + b);
</code></pre>
<p>The comprehension accepts Path types and returns Path types. No manual extraction,
no rewrapping, no boilerplate.</p>
<hr />
<h2 id="entry-points"><a class="header" href="#entry-points">Entry Points</a></h2>
<p><code>ForPath</code> provides entry points for each supported Path type:</p>
<div class="table-wrapper"><table><thead><tr><th>Path Type</th><th>Entry Point</th><th>Supports <code>when()</code></th></tr></thead><tbody>
<tr><td><code>MaybePath&lt;A&gt;</code></td><td><code>ForPath.from(maybePath)</code></td><td>Yes</td></tr>
<tr><td><code>OptionalPath&lt;A&gt;</code></td><td><code>ForPath.from(optionalPath)</code></td><td>Yes</td></tr>
<tr><td><code>EitherPath&lt;E, A&gt;</code></td><td><code>ForPath.from(eitherPath)</code></td><td>No</td></tr>
<tr><td><code>TryPath&lt;A&gt;</code></td><td><code>ForPath.from(tryPath)</code></td><td>No</td></tr>
<tr><td><code>IOPath&lt;A&gt;</code></td><td><code>ForPath.from(ioPath)</code></td><td>No</td></tr>
<tr><td><code>IdPath&lt;A&gt;</code></td><td><code>ForPath.from(idPath)</code></td><td>No</td></tr>
<tr><td><code>NonDetPath&lt;A&gt;</code></td><td><code>ForPath.from(nonDetPath)</code></td><td>Yes</td></tr>
<tr><td><code>GenericPath&lt;F, A&gt;</code></td><td><code>ForPath.from(genericPath)</code></td><td>Optional</td></tr>
</tbody></table>
</div>
<p>The <code>when()</code> guard operation is only available for Path types backed by <code>MonadZero</code>,
which can represent emptiness or failure.</p>
<hr />
<h2 id="core-operations-10"><a class="header" href="#core-operations-10">Core Operations</a></h2>
<h3 id="generators-from"><a class="header" href="#generators-from">Generators: <code>.from()</code></a></h3>
<p>The <code>.from()</code> operation extracts a value from the current step and chains to a new
Path-producing computation. This is the monadic bind (<code>flatMap</code>) in disguise.</p>
<pre><code class="language-java">MaybePath&lt;String&gt; result = ForPath.from(Path.just("Alice"))
    .from(name -&gt; Path.just(name.length()))         // a = "Alice", b = 5
    .from(t -&gt; Path.just(t._1() + ":" + t._2()))    // t is Tuple2&lt;String, Integer&gt;
    .yield((name, len, combined) -&gt; combined);      // "Alice:5"
</code></pre>
<p>Each <code>.from()</code> adds a new value to the accumulating tuple, making all previous
values available to subsequent steps.</p>
<h3 id="value-bindings-let"><a class="header" href="#value-bindings-let">Value Bindings: <code>.let()</code></a></h3>
<p>The <code>.let()</code> operation computes a pure value from accumulated results without
introducing a new effect. It's equivalent to <code>map</code> that carries the value forward.</p>
<pre><code class="language-java">MaybePath&lt;String&gt; result = ForPath.from(Path.just(10))
    .let(a -&gt; a * 2)                    // b = 20 (pure calculation)
    .let(t -&gt; t._1() + t._2())          // c = 30 (can access tuple)
    .yield((a, b, c) -&gt; "Sum: " + c);   // "Sum: 30"
</code></pre>
<h3 id="guards-when"><a class="header" href="#guards-when">Guards: <code>.when()</code></a></h3>
<p>For Path types with <code>MonadZero</code> (MaybePath, OptionalPath, NonDetPath), the <code>.when()</code>
operation filters results. When the predicate returns false, the computation
short-circuits to the monad's zero value (Nothing, empty, etc.).</p>
<pre><code class="language-java">MaybePath&lt;Integer&gt; evenOnly = ForPath.from(Path.just(4))
    .when(n -&gt; n % 2 == 0)              // passes: 4 is even
    .yield(n -&gt; n * 10);                // Just(40)

MaybePath&lt;Integer&gt; filtered = ForPath.from(Path.just(3))
    .when(n -&gt; n % 2 == 0)              // fails: 3 is odd
    .yield(n -&gt; n * 10);                // Nothing
</code></pre>
<h3 id="projection-yield"><a class="header" href="#projection-yield">Projection: <code>.yield()</code></a></h3>
<p>Every comprehension ends with <code>.yield()</code>, which maps the accumulated values to a
final result. You can access values individually or as a tuple:</p>
<pre><code class="language-java">// Individual parameters
.yield((a, b, c) -&gt; a + b + c)

// Or as a tuple for many values
.yield(t -&gt; t._1() + t._2() + t._3())
</code></pre>
<hr />
<h2 id="optics-integration"><a class="header" href="#optics-integration">Optics Integration</a></h2>
<p>ForPath integrates with the <a href="effect/../optics/focus_dsl.html">Focus DSL</a> for structural
navigation within comprehensions.</p>
<h3 id="extracting-with-focus"><a class="header" href="#extracting-with-focus">Extracting with <code>.focus()</code></a></h3>
<p>The <code>.focus()</code> operation uses a <code>FocusPath</code> to extract a nested value:</p>
<pre><code class="language-java">record User(String name, Address address) {}
record Address(String city, String postcode) {}

// Create lenses for each field
Lens&lt;User, Address&gt; addressLens = Lens.of(
    User::address, (u, a) -&gt; new User(u.name(), a));
Lens&lt;Address, String&gt; cityLens = Lens.of(
    Address::city, (a, c) -&gt; new Address(c, a.postcode()));

// Compose paths with via() for nested access
FocusPath&lt;User, Address&gt; addressPath = FocusPath.of(addressLens);
FocusPath&lt;User, String&gt; userCityPath = addressPath.via(FocusPath.of(cityLens));

MaybePath&lt;String&gt; result = ForPath.from(Path.just(user))
    .focus(userCityPath)                        // extract city directly
    .yield((user, city) -&gt; city.toUpperCase());
</code></pre>
<p>Alternatively, chain focus operations where the second takes a function:</p>
<pre><code class="language-java">FocusPath&lt;User, Address&gt; addressPath = FocusPath.of(addressLens);

MaybePath&lt;String&gt; result = ForPath.from(Path.just(user))
    .focus(addressPath)                         // extract address -&gt; Steps2
    .focus(t -&gt; t._2().city())                  // extract city from tuple
    .yield((user, address, city) -&gt; city.toUpperCase());
</code></pre>
<h3 id="pattern-matching-with-match"><a class="header" href="#pattern-matching-with-match">Pattern Matching with <code>.match()</code></a></h3>
<p>The <code>.match()</code> operation uses an <code>AffinePath</code> for optional extraction. When the
focus is absent, the comprehension short-circuits for <code>MonadZero</code> types:</p>
<pre><code class="language-java">sealed interface Result permits Success, Failure {}
record Success(String value) implements Result {}
record Failure(String error) implements Result {}

AffinePath&lt;Result, Success&gt; successPath = AffinePath.of(
    Affine.of(
        r -&gt; r instanceof Success s ? Optional.of(s) : Optional.empty(),
        (r, s) -&gt; s
    )
);

MaybePath&lt;String&gt; result = ForPath.from(Path.just((Result) new Success("data")))
    .match(successPath)                         // extract Success
    .yield((r, success) -&gt; success.value().toUpperCase());
// Just("DATA")

MaybePath&lt;String&gt; empty = ForPath.from(Path.just((Result) new Failure("error")))
    .match(successPath)                         // fails to match
    .yield((r, success) -&gt; success.value());
// Nothing
</code></pre>
<hr />
<h2 id="eitherpath-example"><a class="header" href="#eitherpath-example">EitherPath Example</a></h2>
<p>For error-handling scenarios, EitherPath comprehensions propagate failures automatically:</p>
<pre><code class="language-java">record User(String id, String name) {}
record Order(String orderId, User user) {}

Function&lt;String, EitherPath&lt;String, User&gt;&gt; findUser = id -&gt;
    id.equals("user-1")
        ? Path.right(new User("user-1", "Alice"))
        : Path.left("User not found: " + id);

Function&lt;User, EitherPath&lt;String, Order&gt;&gt; createOrder = user -&gt;
    Path.right(new Order("order-123", user));

EitherPath&lt;String, String&gt; result = ForPath.from(findUser.apply("user-1"))
    .from(user -&gt; createOrder.apply(user))
    .yield((user, order) -&gt; "Created " + order.orderId() + " for " + user.name());
// Right("Created order-123 for Alice")

EitherPath&lt;String, String&gt; failed = ForPath.from(findUser.apply("unknown"))
    .from(user -&gt; createOrder.apply(user))
    .yield((user, order) -&gt; "Created " + order.orderId());
// Left("User not found: unknown")
</code></pre>
<hr />
<h2 id="iopath-example"><a class="header" href="#iopath-example">IOPath Example</a></h2>
<p>IOPath comprehensions compose deferred side-effectful computations:</p>
<pre><code class="language-java">IOPath&lt;String&gt; readConfig = Path.io(() -&gt; "production");
IOPath&lt;Integer&gt; readPort = Path.io(() -&gt; 8080);

IOPath&lt;String&gt; serverInfo = ForPath.from(readConfig)
    .from(env -&gt; readPort)
    .let(t -&gt; t._1().toUpperCase())
    .yield((env, port, upperEnv) -&gt; upperEnv + " server on port " + port);

// Nothing executes until:
String result = serverInfo.unsafeRun();  // "PRODUCTION server on port 8080"
</code></pre>
<hr />
<h2 id="nondetpath-example"><a class="header" href="#nondetpath-example">NonDetPath Example</a></h2>
<p>NonDetPath (backed by List) generates all combinations:</p>
<pre><code class="language-java">NonDetPath&lt;String&gt; combinations = ForPath.from(Path.list("red", "blue"))
    .from(c -&gt; Path.list("S", "M", "L"))
    .when(t -&gt; !t._1().equals("blue") || !t._2().equals("S"))  // filter out blue-S
    .yield((colour, size) -&gt; colour + "-" + size);

List&lt;String&gt; result = combinations.run();
// ["red-S", "red-M", "red-L", "blue-M", "blue-L"]
</code></pre>
<hr />
<h2 id="when-to-use-forpath-vs-for"><a class="header" href="#when-to-use-forpath-vs-for">When to Use ForPath vs For</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Scenario</th><th>Use</th></tr></thead><tbody>
<tr><td>Working with Effect Path API</td><td><code>ForPath</code></td></tr>
<tr><td>Need Path types as output</td><td><code>ForPath</code></td></tr>
<tr><td>Working with raw <code>Kind&lt;M, A&gt;</code></td><td><code>For</code></td></tr>
<tr><td>Using monad transformers (StateT, EitherT)</td><td><code>For</code></td></tr>
<tr><td>Custom monads without Path wrappers</td><td><code>For</code> with <code>GenericPath</code> adapter</td></tr>
</tbody></table>
</div>
<p>For monad transformer stacks, the standard <code>For</code> class remains the appropriate choice
as it works directly with the transformer's <code>Kind</code> representation.</p>
<hr />
<div id="admonition-key-takeaways" class="admonition admonish-info" role="note" aria-labelledby="admonition-key-takeaways-title">
<div class="admonition-title">
<div id="admonition-key-takeaways-title">
<p>Key Takeaways</p>
</div>
<a class="admonition-anchor-link" href="effect/forpath_comprehension.html#admonition-key-takeaways"></a>
</div>
<div>
<ul>
<li><strong>ForPath eliminates boilerplate</strong> when composing Path types in for-comprehension style</li>
<li><strong>Entry points accept Path types directly</strong> and return Path types</li>
<li><strong>All For operations are supported</strong>: <code>from()</code>, <code>let()</code>, <code>when()</code> (where applicable), <code>yield()</code></li>
<li><strong>Optics integration</strong> via <code>focus()</code> and <code>match()</code> enables structural navigation</li>
<li><strong>Type safety is preserved</strong> throughout the comprehension</li>
</ul>
</div>
</div>
<div id="admonition-see-also" class="admonition admonish-tip" role="note" aria-labelledby="admonition-see-also-title">
<div class="admonition-title">
<div id="admonition-see-also-title">
<p>See Also</p>
</div>
<a class="admonition-anchor-link" href="effect/forpath_comprehension.html#admonition-see-also"></a>
</div>
<div>
<ul>
<li><a href="effect/../functional/for_comprehension.html">For Comprehension</a> - The underlying For class for raw <code>Kind</code> values</li>
<li><a href="effect/effect_path_overview.html">Effect Path Overview</a> - Introduction to the Effect Path API</li>
<li><a href="effect/../optics/focus_dsl.html">Focus DSL</a> - Optics integration for structural navigation</li>
</ul>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="effect/composition.html">Composition Patterns</a>
<strong>Next:</strong> <a href="effect/conversions.html">Type Conversions</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="type-conversions"><a class="header" href="#type-conversions">Type Conversions</a></h1>
<blockquote>
<p><em>"The system was invisible, as they had intended, until you looked."</em></p>
<p>— Don DeLillo, <em>Underworld</em></p>
</blockquote>
<p>DeLillo's observation captures the nature of type conversions in effect-oriented
code. The conversions exist invisibly, implicit in how the types relate to each
other. But once you see the system (the natural transformations between <code>Maybe</code>
and <code>Either</code>, the bridges from <code>Try</code> to <code>Validation</code>), the invisible becomes
navigable.</p>
<p>This chapter makes that system visible.</p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="effect/conversions.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>Converting between Path types: <code>MaybePath</code> ↔ <code>EitherPath</code> ↔ <code>TryPath</code> ↔ <code>ValidationPath</code></li>
<li>Converting to and from <code>IdPath</code>, <code>OptionalPath</code>, and <code>GenericPath</code></li>
<li>Lifting values into Path types with factory methods</li>
<li>Terminal operations for extracting results</li>
<li>Best practices for conversion at service boundaries</li>
</ul>
</div>
</div>
<h2 id="conversion-overview"><a class="header" href="#conversion-overview">Conversion Overview</a></h2>
<p>The Path API supports rich conversions between all path types. Some conversions preserve all information; others require additional context (like an error value when converting from <code>MaybePath</code> to <code>EitherPath</code>).</p>
<pre><code>┌──────────────────────────────────────────────────────────────────────────────────┐
│                           PATH TYPE CONVERSIONS                                  │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│  ERROR-HANDLING PATHS                                                            │
│  ────────────────────                                                            │
│    MaybePath ←──────────────────────────────────────────────→ EitherPath         │
│       │     toEitherPath(error)  /  toMaybePath()                  │             │
│       │                                                            │             │
│    TryPath ←────────────────────────────────────────────────→ EitherPath         │
│       │     toEitherPath(mapper) /  toTryPath()                    │             │
│       │                                                            │             │
│    TryPath ←────── toMaybePath() ────────────────────────────→ MaybePath         │
│       │                                                                          │
│    IOPath ──────── toTryPath() ──────────────────────────────→ TryPath           │
│                                                                                  │
│  VALIDATION PATHS                                                                │
│  ────────────────                                                                │
│    EitherPath ←─────────────────────────────────────────────→ ValidationPath     │
│              toValidationPath() / toEitherPath()                                 │
│                                                                                  │
│    TryPath ─────── toValidationPath(mapper) ────────────────→ ValidationPath     │
│                                                                                  │
│  UTILITY PATHS                                                                   │
│  ─────────────                                                                   │
│    IdPath ←──────── toIdPath() / toMaybePath() ─────────────→ MaybePath          │
│                                                                                  │
│    OptionalPath ←── toOptionalPath() / toMaybePath() ───────→ MaybePath          │
│                                                                                  │
│    GenericPath ←─── Wraps any Kind&lt;F, A&gt; with Monad instance                     │
│                                                                                  │
└──────────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<hr />
<h2 id="maybepath-conversions"><a class="header" href="#maybepath-conversions">MaybePath Conversions</a></h2>
<h3 id="maybepath--eitherpath-1"><a class="header" href="#maybepath--eitherpath-1">MaybePath → EitherPath</a></h3>
<p>Convert absence to a typed error:</p>
<pre><code class="language-java">MaybePath&lt;User&gt; maybeUser = Path.maybe(findUser(id));

// Provide error for Nothing case
EitherPath&lt;String, User&gt; withError =
    maybeUser.toEitherPath("User not found");

// With lazy error
EitherPath&lt;UserError, User&gt; withLazyError =
    maybeUser.toEitherPath(() -&gt; new UserError("User " + id + " not found"));
</code></pre>
<p>This is useful when:</p>
<ul>
<li>An optional value becomes a required value</li>
<li>You need to propagate error information downstream</li>
</ul>
<pre><code class="language-java">// Service that returns Maybe internally but Either externally
public EitherPath&lt;Error, User&gt; getUserOrError(String id) {
    return Path.maybe(userRepository.findById(id))
        .toEitherPath(() -&gt; new Error.UserNotFound(id));
}
</code></pre>
<h3 id="eitherpath--maybepath"><a class="header" href="#eitherpath--maybepath">EitherPath → MaybePath</a></h3>
<p>Discard error information:</p>
<pre><code class="language-java">EitherPath&lt;String, User&gt; eitherUser = Path.either(validateUser(input));

// Errors become Nothing
MaybePath&lt;User&gt; maybeUser = eitherUser.toMaybePath();
</code></pre>
<p>This is useful when:</p>
<ul>
<li>You only care about success/failure, not the error details</li>
<li>Integrating with APIs that expect Maybe</li>
</ul>
<hr />
<h2 id="trypath-conversions"><a class="header" href="#trypath-conversions">TryPath Conversions</a></h2>
<h3 id="trypath--eitherpath-1"><a class="header" href="#trypath--eitherpath-1">TryPath → EitherPath</a></h3>
<p>Convert exceptions to typed errors:</p>
<pre><code class="language-java">TryPath&lt;Config&gt; tryConfig = Path.tryOf(() -&gt; loadConfig());

// Keep the exception as the error type
EitherPath&lt;Throwable, Config&gt; withException =
    tryConfig.toEitherPath(ex -&gt; ex);

// Transform exception to your error type
EitherPath&lt;ConfigError, Config&gt; withTypedError =
    tryConfig.toEitherPath(ex -&gt; new ConfigError("Failed to load: " + ex.getMessage()));

// Extract just the message
EitherPath&lt;String, Config&gt; withMessage =
    tryConfig.toEitherPath(Throwable::getMessage);
</code></pre>
<h3 id="trypath--maybepath"><a class="header" href="#trypath--maybepath">TryPath → MaybePath</a></h3>
<p>Failures become Nothing:</p>
<pre><code class="language-java">TryPath&lt;Integer&gt; parsed = Path.tryOf(() -&gt; Integer.parseInt(input));

// Failure → Nothing, Success → Just
MaybePath&lt;Integer&gt; maybeParsed = parsed.toMaybePath();

// Use case: optional parsing
MaybePath&lt;Integer&gt; port = Path.tryOf(() -&gt; Integer.parseInt(config.get("port")))
    .toMaybePath()
    .orElse(() -&gt; Path.just(8080));  // Default port
</code></pre>
<h3 id="eitherpath--trypath"><a class="header" href="#eitherpath--trypath">EitherPath → TryPath</a></h3>
<p>Wrap error as exception:</p>
<pre><code class="language-java">EitherPath&lt;String, User&gt; eitherUser = validateUser(input);

// Error becomes RuntimeException
TryPath&lt;User&gt; tryUser = eitherUser.toTryPath();
</code></pre>
<hr />
<h2 id="iopath-conversions"><a class="header" href="#iopath-conversions">IOPath Conversions</a></h2>
<h3 id="iopath--trypath-1"><a class="header" href="#iopath--trypath-1">IOPath → TryPath</a></h3>
<p>Execute the IO and capture the result:</p>
<pre><code class="language-java">IOPath&lt;Data&gt; ioData = Path.io(() -&gt; fetchFromNetwork());

// Execute and capture in Try
TryPath&lt;Data&gt; tryData = ioData.toTryPath();
// The IO has been executed at this point!
</code></pre>
<div id="admonition-io-execution" class="admonition admonish-warning" role="note" aria-labelledby="admonition-io-execution-title">
<div class="admonition-title">
<div id="admonition-io-execution-title">
<p>IO Execution</p>
</div>
<a class="admonition-anchor-link" href="effect/conversions.html#admonition-io-execution"></a>
</div>
<div>
<p><code>toTryPath()</code> executes the IO immediately. The result is no longer deferred.</p>
</div>
</div>
<h3 id="iopath-safe-execution"><a class="header" href="#iopath-safe-execution">IOPath Safe Execution</a></h3>
<p>For explicit control over execution:</p>
<pre><code class="language-java">IOPath&lt;Data&gt; io = Path.io(() -&gt; fetchData());

// Execute safely (captures exceptions)
Try&lt;Data&gt; result = io.runSafe();

// Then convert to path if needed
TryPath&lt;Data&gt; tryPath = Path.of(result);
</code></pre>
<hr />
<h2 id="validationpath-conversions"><a class="header" href="#validationpath-conversions">ValidationPath Conversions</a></h2>
<h3 id="eitherpath--validationpath"><a class="header" href="#eitherpath--validationpath">EitherPath → ValidationPath</a></h3>
<p>Convert to accumulating validation mode:</p>
<pre><code class="language-java">EitherPath&lt;String, Integer&gt; eitherValue = Path.right(42);

// Convert to ValidationPath (preserves success/failure)
ValidationPath&lt;String, Integer&gt; validationValue = eitherValue.toValidationPath();

// Now can use accumulating operations
ValidationPath&lt;String, Integer&gt; other = Path.valid(10);
ValidationPath&lt;String, Integer&gt; combined = validationValue.zipWithAccum(
    other,
    Integer::sum,
    (e1, e2) -&gt; e1 + "; " + e2
);
</code></pre>
<h3 id="validationpath--eitherpath"><a class="header" href="#validationpath--eitherpath">ValidationPath → EitherPath</a></h3>
<p>Convert back to short-circuiting mode:</p>
<pre><code class="language-java">ValidationPath&lt;List&lt;String&gt;, User&gt; validated = validateUser(input);

// Convert to EitherPath for chaining
EitherPath&lt;List&lt;String&gt;, User&gt; either = validated.toEitherPath();

// Now can use via() for dependent operations
EitherPath&lt;List&lt;String&gt;, Order&gt; order = either
    .via(user -&gt; createOrder(user));
</code></pre>
<h3 id="trypath--validationpath"><a class="header" href="#trypath--validationpath">TryPath → ValidationPath</a></h3>
<p>Convert exceptions to validation errors:</p>
<pre><code class="language-java">TryPath&lt;Config&gt; tryConfig = Path.tryOf(() -&gt; loadConfig());

// Transform exception to error type
ValidationPath&lt;String, Config&gt; validConfig =
    tryConfig.toValidationPath(ex -&gt; "Config error: " + ex.getMessage());
</code></pre>
<h3 id="when-to-convert"><a class="header" href="#when-to-convert">When to Convert</a></h3>
<p>Convert <code>EitherPath</code> to <code>ValidationPath</code> when:</p>
<ul>
<li>You need to combine multiple independent validations</li>
<li>You want to accumulate all errors, not just the first</li>
</ul>
<p>Convert <code>ValidationPath</code> to <code>EitherPath</code> when:</p>
<ul>
<li>You need to chain dependent operations with <code>via</code></li>
<li>You want fail-fast behaviour for the next step</li>
</ul>
<hr />
<h2 id="idpath-conversions"><a class="header" href="#idpath-conversions">IdPath Conversions</a></h2>
<p><code>IdPath</code> wraps pure values with no failure case. Conversions are straightforward:</p>
<h3 id="idpath--maybepath"><a class="header" href="#idpath--maybepath">IdPath → MaybePath</a></h3>
<pre><code class="language-java">IdPath&lt;String&gt; idValue = Path.id("hello");

// Always becomes Just (IdPath cannot fail)
MaybePath&lt;String&gt; maybe = idValue.toMaybePath();
// → Just("hello")
</code></pre>
<h3 id="maybepath--idpath"><a class="header" href="#maybepath--idpath">MaybePath → IdPath</a></h3>
<pre><code class="language-java">MaybePath&lt;String&gt; maybe = Path.just("hello");

// Requires a default for Nothing case
IdPath&lt;String&gt; id = maybe.toIdPath("default");
// → Id("hello")

MaybePath&lt;String&gt; nothing = Path.nothing();
IdPath&lt;String&gt; idDefault = nothing.toIdPath("default");
// → Id("default")
</code></pre>
<h3 id="idpath-use-cases"><a class="header" href="#idpath-use-cases">IdPath Use Cases</a></h3>
<p><code>IdPath</code> is useful when:</p>
<ul>
<li>Working with generic code that expects a path type</li>
<li>You have a pure value but need path operations (<code>map</code>, <code>via</code>)</li>
<li>Testing monadic code with known values</li>
</ul>
<hr />
<h2 id="optionalpath-conversions"><a class="header" href="#optionalpath-conversions">OptionalPath Conversions</a></h2>
<p><code>OptionalPath</code> bridges Java's <code>java.util.Optional</code> with the Path API.</p>
<h3 id="optionalpath--maybepath"><a class="header" href="#optionalpath--maybepath">OptionalPath ↔ MaybePath</a></h3>
<pre><code class="language-java">// From Optional
Optional&lt;String&gt; javaOpt = Optional.of("hello");
OptionalPath&lt;String&gt; optPath = Path.optional(javaOpt);

// To MaybePath
MaybePath&lt;String&gt; maybe = optPath.toMaybePath();

// From MaybePath
MaybePath&lt;String&gt; maybe2 = Path.just("world");
OptionalPath&lt;String&gt; optPath2 = maybe2.toOptionalPath();

// To Optional
Optional&lt;String&gt; javaOpt2 = optPath2.run();
</code></pre>
<h3 id="optionalpath--eitherpath"><a class="header" href="#optionalpath--eitherpath">OptionalPath → EitherPath</a></h3>
<pre><code class="language-java">OptionalPath&lt;User&gt; optUser = Path.optional(findUser(id));

// Provide error for empty case
EitherPath&lt;String, User&gt; either = optUser.toEitherPath("User not found");
</code></pre>
<h3 id="when-to-use-optionalpath"><a class="header" href="#when-to-use-optionalpath">When to Use OptionalPath</a></h3>
<p>Use <code>OptionalPath</code> when:</p>
<ul>
<li>Integrating with Java APIs that return <code>Optional</code></li>
<li>You want path operations on Optional values</li>
<li>Bridging between Java stdlib and higher-kinded-j</li>
</ul>
<hr />
<h2 id="genericpath-conversions"><a class="header" href="#genericpath-conversions">GenericPath Conversions</a></h2>
<p><code>GenericPath</code> wraps any <code>Kind&lt;F, A&gt;</code> with a <code>Monad</code> instance, providing an escape hatch for custom types.</p>
<h3 id="creating-genericpath"><a class="header" href="#creating-genericpath">Creating GenericPath</a></h3>
<pre><code class="language-java">// Wrap any Kind with its Monad instance
Kind&lt;MaybeKind.Witness, String&gt; maybeKind = MaybeKind.widen(Maybe.just("hello"));
GenericPath&lt;MaybeKind.Witness, String&gt; generic = Path.generic(
    maybeKind,
    MaybeMonad.INSTANCE
);
</code></pre>
<h3 id="using-genericpath"><a class="header" href="#using-genericpath">Using GenericPath</a></h3>
<pre><code class="language-java">// All standard path operations work
GenericPath&lt;MaybeKind.Witness, Integer&gt; mapped = generic.map(String::length);

GenericPath&lt;MaybeKind.Witness, String&gt; chained = generic.via(s -&gt;
    Path.generic(MaybeKind.widen(Maybe.just(s.toUpperCase())), MaybeMonad.INSTANCE)
);

// Extract the underlying Kind
Kind&lt;MaybeKind.Witness, String&gt; underlying = generic.runKind();
</code></pre>
<h3 id="when-to-use-genericpath"><a class="header" href="#when-to-use-genericpath">When to Use GenericPath</a></h3>
<p>Use <code>GenericPath</code> when:</p>
<ul>
<li>Working with custom monad types not covered by specific Path types</li>
<li>Writing generic code that works with any monad</li>
<li>You need path operations for a third-party <code>Kind</code> type</li>
</ul>
<div id="admonition-genericpath-limitations" class="admonition admonish-note" role="note" aria-labelledby="admonition-genericpath-limitations-title">
<div class="admonition-title">
<div id="admonition-genericpath-limitations-title">
<p>GenericPath Limitations</p>
</div>
<a class="admonition-anchor-link" href="effect/conversions.html#admonition-genericpath-limitations"></a>
</div>
<div>
<p><code>GenericPath</code> provides <code>Chainable</code> operations but recovery operations depend on the underlying monad supporting error handling.</p>
</div>
</div>
<hr />
<h2 id="lifting-values"><a class="header" href="#lifting-values">Lifting Values</a></h2>
<h3 id="lifting-to-maybepath"><a class="header" href="#lifting-to-maybepath">Lifting to MaybePath</a></h3>
<pre><code class="language-java">// From a value
MaybePath&lt;String&gt; just = Path.just("hello");

// From Nothing
MaybePath&lt;String&gt; nothing = Path.nothing();

// From nullable
String nullable = possiblyNullValue();
MaybePath&lt;String&gt; maybe = Path.fromNullable(nullable);

// Conditional lifting
MaybePath&lt;Integer&gt; validated = value &gt; 0
    ? Path.just(value)
    : Path.nothing();
</code></pre>
<h3 id="lifting-to-eitherpath"><a class="header" href="#lifting-to-eitherpath">Lifting to EitherPath</a></h3>
<pre><code class="language-java">// Success
EitherPath&lt;Error, Integer&gt; success = Path.right(42);

// Failure
EitherPath&lt;Error, Integer&gt; failure = Path.left(new Error("failed"));

// Conditional lifting
EitherPath&lt;String, Integer&gt; validated = value &gt; 0
    ? Path.right(value)
    : Path.left("Value must be positive");
</code></pre>
<h3 id="lifting-to-trypath"><a class="header" href="#lifting-to-trypath">Lifting to TryPath</a></h3>
<pre><code class="language-java">// Success
TryPath&lt;Integer&gt; success = Path.success(42);

// Failure
TryPath&lt;Integer&gt; failure = Path.failure(new RuntimeException("error"));

// From computation
TryPath&lt;Config&gt; config = Path.tryOf(() -&gt; loadConfig());
</code></pre>
<h3 id="lifting-to-iopath"><a class="header" href="#lifting-to-iopath">Lifting to IOPath</a></h3>
<pre><code class="language-java">// Pure value (no side effects)
IOPath&lt;Integer&gt; pure = Path.ioPure(42);

// Deferred computation
IOPath&lt;String&gt; deferred = Path.io(() -&gt; readFile());
</code></pre>
<h3 id="lifting-to-validationpath"><a class="header" href="#lifting-to-validationpath">Lifting to ValidationPath</a></h3>
<pre><code class="language-java">// Valid value
ValidationPath&lt;String, Integer&gt; valid = Path.valid(42);

// Invalid value
ValidationPath&lt;String, Integer&gt; invalid = Path.invalid("Must be positive");

// From existing Validated
Validated&lt;String, User&gt; validated = validateUser(input);
ValidationPath&lt;String, User&gt; path = Path.validation(validated);
</code></pre>
<h3 id="lifting-to-idpath"><a class="header" href="#lifting-to-idpath">Lifting to IdPath</a></h3>
<pre><code class="language-java">// Wrap a pure value
IdPath&lt;String&gt; id = Path.id("hello");

// From existing Id
Id&lt;Integer&gt; idValue = Id.of(42);
IdPath&lt;Integer&gt; idPath = Path.idOf(idValue);
</code></pre>
<h3 id="lifting-to-optionalpath"><a class="header" href="#lifting-to-optionalpath">Lifting to OptionalPath</a></h3>
<pre><code class="language-java">// From Optional
OptionalPath&lt;String&gt; present = Path.optional(Optional.of("hello"));
OptionalPath&lt;String&gt; empty = Path.optional(Optional.empty());

// From nullable value
OptionalPath&lt;String&gt; fromNullable = Path.optionalOfNullable(possiblyNull);
</code></pre>
<h3 id="lifting-to-genericpath"><a class="header" href="#lifting-to-genericpath">Lifting to GenericPath</a></h3>
<pre><code class="language-java">// Wrap any Kind with its Monad
Kind&lt;ListKind.Witness, Integer&gt; listKind = ListKind.widen(List.of(1, 2, 3));
GenericPath&lt;ListKind.Witness, Integer&gt; genericList = Path.generic(listKind, ListMonad.INSTANCE);
</code></pre>
<hr />
<h2 id="terminal-operations"><a class="header" href="#terminal-operations">Terminal Operations</a></h2>
<h3 id="maybepath-extraction"><a class="header" href="#maybepath-extraction">MaybePath Extraction</a></h3>
<pre><code class="language-java">MaybePath&lt;String&gt; path = Path.just("hello");

// Get underlying Maybe
Maybe&lt;String&gt; maybe = path.run();

// Get or default
String value = path.getOrElse("default");

// Get or compute default
String value = path.getOrElse(() -&gt; computeDefault());

// Get or throw
String value = path.getOrThrow(() -&gt; new NoSuchElementException());

// Check presence
boolean hasValue = path.run().isJust();
</code></pre>
<h3 id="eitherpath-extraction"><a class="header" href="#eitherpath-extraction">EitherPath Extraction</a></h3>
<pre><code class="language-java">EitherPath&lt;String, Integer&gt; path = Path.right(42);

// Get underlying Either
Either&lt;String, Integer&gt; either = path.run();

// Pattern match with fold
String result = either.fold(
    error -&gt; "Error: " + error,
    value -&gt; "Value: " + value
);

// Get success (throws if Left)
Integer value = either.getRight();

// Get error (throws if Right)
String error = either.getLeft();

// Check state
boolean isSuccess = either.isRight();
</code></pre>
<h3 id="trypath-extraction"><a class="header" href="#trypath-extraction">TryPath Extraction</a></h3>
<pre><code class="language-java">TryPath&lt;Integer&gt; path = Path.success(42);

// Get underlying Try
Try&lt;Integer&gt; tryValue = path.run();

// Get or default
Integer value = path.getOrElse(-1);

// Get or compute
Integer value = path.getOrElse(() -&gt; computeDefault());

// Get (may throw)
Integer value = tryValue.get();

// Check state
boolean succeeded = tryValue.isSuccess();

// Get exception (if failure)
Throwable cause = tryValue.getCause();
</code></pre>
<h3 id="iopath-extraction"><a class="header" href="#iopath-extraction">IOPath Extraction</a></h3>
<pre><code class="language-java">IOPath&lt;String&gt; path = Path.io(() -&gt; readFile());

// Execute (may throw)
String result = path.unsafeRun();

// Execute safely
Try&lt;String&gt; result = path.runSafe();

// Convert to Try for further composition
TryPath&lt;String&gt; tryPath = path.toTryPath();
</code></pre>
<h3 id="validationpath-extraction"><a class="header" href="#validationpath-extraction">ValidationPath Extraction</a></h3>
<pre><code class="language-java">ValidationPath&lt;List&lt;String&gt;, User&gt; path = validateUser(input);

// Get underlying Validated
Validated&lt;List&lt;String&gt;, User&gt; validated = path.run();

// Pattern match with fold
String result = validated.fold(
    errors -&gt; "Errors: " + errors,
    user -&gt; "Valid: " + user.name()
);

// Check state
boolean isValid = validated.isValid();
boolean isInvalid = validated.isInvalid();
</code></pre>
<h3 id="idpath-extraction"><a class="header" href="#idpath-extraction">IdPath Extraction</a></h3>
<pre><code class="language-java">IdPath&lt;String&gt; path = Path.id("hello");

// Get underlying Id
Id&lt;String&gt; id = path.run();

// Get the value (always succeeds)
String value = id.value();
// or
String value = path.get();
</code></pre>
<h3 id="optionalpath-extraction"><a class="header" href="#optionalpath-extraction">OptionalPath Extraction</a></h3>
<pre><code class="language-java">OptionalPath&lt;String&gt; path = Path.optional(Optional.of("hello"));

// Get underlying Optional
Optional&lt;String&gt; opt = path.run();

// Get or default
String value = opt.orElse("default");

// Get or throw
String value = opt.orElseThrow(() -&gt; new NoSuchElementException());
</code></pre>
<h3 id="genericpath-extraction"><a class="header" href="#genericpath-extraction">GenericPath Extraction</a></h3>
<pre><code class="language-java">GenericPath&lt;MaybeKind.Witness, String&gt; path = Path.generic(
    MaybeKind.widen(maybe), MaybeMonad.INSTANCE);

// Get underlying Kind
Kind&lt;MaybeKind.Witness, String&gt; kind = path.runKind();

// Narrow to concrete type
Maybe&lt;String&gt; maybe = MaybeKind.narrow(kind);
</code></pre>
<hr />
<h2 id="conversion-chains"><a class="header" href="#conversion-chains">Conversion Chains</a></h2>
<p>Real code often chains multiple conversions:</p>
<pre><code class="language-java">// Start with Maybe, end with Either with error handling
EitherPath&lt;ServiceError, Order&gt; processOrder(String userId, OrderInput input) {
    return Path.maybe(userRepository.findById(userId))         // MaybePath&lt;User&gt;
        .toEitherPath(() -&gt; new ServiceError.UserNotFound())   // EitherPath&lt;ServiceError, User&gt;
        .via(user -&gt; Path.tryOf(() -&gt; validateOrder(input))    // Chain TryPath
            .toEitherPath(ServiceError.ValidationFailed::new)) // Convert to EitherPath
        .via(validated -&gt; Path.either(createOrder(user, validated)));
}
</code></pre>
<hr />
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="convert-at-boundaries"><a class="header" href="#convert-at-boundaries">Convert at Boundaries</a></h3>
<p>Convert at service boundaries, not throughout:</p>
<pre><code class="language-java">// Good: Convert once at the boundary
public EitherPath&lt;Error, User&gt; getUser(String id) {
    return Path.maybe(repository.findById(id))  // Internal Maybe
        .toEitherPath(() -&gt; Error.notFound(id)); // Convert at boundary
}

// Avoid: Converting back and forth
public EitherPath&lt;Error, User&gt; getUser(String id) {
    return Path.maybe(repository.findById(id))
        .toEitherPath(() -&gt; Error.notFound(id))
        .toMaybePath()  // Why convert back?
        .toEitherPath(() -&gt; Error.notFound(id)); // And forth again?
}
</code></pre>
<h3 id="match-error-granularity"><a class="header" href="#match-error-granularity">Match Error Granularity</a></h3>
<p>Choose the right error type for the layer:</p>
<pre><code class="language-java">// Repository: Maybe (absence is normal)
public Maybe&lt;User&gt; findById(String id) { ... }

// Service: Either with domain errors
public EitherPath&lt;UserError, User&gt; getUserById(String id) {
    return Path.maybe(repository.findById(id))
        .toEitherPath(() -&gt; UserError.NOT_FOUND);
}

// Controller: Either with HTTP-friendly errors
public EitherPath&lt;HttpError, UserDto&gt; getUser(String id) {
    return userService.getUserById(id)
        .mapError(this::toHttpError)
        .map(UserDto::from);
}
</code></pre>
<hr />
<h2 id="summary-3"><a class="header" href="#summary-3">Summary</a></h2>
<h3 id="error-handling-path-conversions"><a class="header" href="#error-handling-path-conversions">Error-Handling Path Conversions</a></h3>
<div class="table-wrapper"><table><thead><tr><th>From</th><th>To</th><th>Method</th><th>Notes</th></tr></thead><tbody>
<tr><td>MaybePath</td><td>EitherPath</td><td><code>toEitherPath(error)</code></td><td>Nothing → Left</td></tr>
<tr><td>EitherPath</td><td>MaybePath</td><td><code>toMaybePath()</code></td><td>Left → Nothing</td></tr>
<tr><td>TryPath</td><td>EitherPath</td><td><code>toEitherPath(mapper)</code></td><td>Exception → Left</td></tr>
<tr><td>TryPath</td><td>MaybePath</td><td><code>toMaybePath()</code></td><td>Failure → Nothing</td></tr>
<tr><td>EitherPath</td><td>TryPath</td><td><code>toTryPath()</code></td><td>Left → RuntimeException</td></tr>
<tr><td>IOPath</td><td>TryPath</td><td><code>toTryPath()</code></td><td>Executes the IO</td></tr>
</tbody></table>
</div>
<h3 id="validation-path-conversions"><a class="header" href="#validation-path-conversions">Validation Path Conversions</a></h3>
<div class="table-wrapper"><table><thead><tr><th>From</th><th>To</th><th>Method</th><th>Notes</th></tr></thead><tbody>
<tr><td>EitherPath</td><td>ValidationPath</td><td><code>toValidationPath()</code></td><td>Preserves success/failure</td></tr>
<tr><td>ValidationPath</td><td>EitherPath</td><td><code>toEitherPath()</code></td><td>Preserves valid/invalid</td></tr>
<tr><td>TryPath</td><td>ValidationPath</td><td><code>toValidationPath(mapper)</code></td><td>Exception → Invalid</td></tr>
</tbody></table>
</div>
<h3 id="utility-path-conversions"><a class="header" href="#utility-path-conversions">Utility Path Conversions</a></h3>
<div class="table-wrapper"><table><thead><tr><th>From</th><th>To</th><th>Method</th><th>Notes</th></tr></thead><tbody>
<tr><td>IdPath</td><td>MaybePath</td><td><code>toMaybePath()</code></td><td>Always Just</td></tr>
<tr><td>MaybePath</td><td>IdPath</td><td><code>toIdPath(default)</code></td><td>Nothing → default value</td></tr>
<tr><td>OptionalPath</td><td>MaybePath</td><td><code>toMaybePath()</code></td><td>Empty → Nothing</td></tr>
<tr><td>MaybePath</td><td>OptionalPath</td><td><code>toOptionalPath()</code></td><td>Nothing → Empty</td></tr>
<tr><td>OptionalPath</td><td>EitherPath</td><td><code>toEitherPath(error)</code></td><td>Empty → Left</td></tr>
<tr><td>Any Kind</td><td>GenericPath</td><td><code>Path.generic(kind, monad)</code></td><td>Universal wrapper</td></tr>
</tbody></table>
</div>
<p>Continue to <a href="effect/patterns.html">Patterns and Recipes</a> for real-world usage patterns.</p>
<div id="admonition-see-also" class="admonition admonish-tip" role="note" aria-labelledby="admonition-see-also-title">
<div class="admonition-title">
<div id="admonition-see-also-title">
<p>See Also</p>
</div>
<a class="admonition-anchor-link" href="effect/conversions.html#admonition-see-also"></a>
</div>
<div>
<ul>
<li><a href="effect/../functional/natural_transformation.html">Natural Transformation</a> - The concept behind converting between type constructors</li>
</ul>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="effect/forpath_comprehension.html">ForPath Comprehension</a>
<strong>Next:</strong> <a href="effect/focus_integration.html">Focus-Effect Integration</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="focus-effect-integration"><a class="header" href="#focus-effect-integration">Focus-Effect Integration</a></h1>
<h2 id="bridging-structural-navigation-and-effect-composition"><a class="header" href="#bridging-structural-navigation-and-effect-composition"><em>Bridging Structural Navigation and Effect Composition</em></a></h2>
<blockquote>
<p><em>"The knife had two edges: one was tempered for common use, but the other was keener than any blade that had ever existed before. It could cut through anything, even the fabric of the universe itself... With the right touch, you could open a window to another world."</em></p>
<p>— Philip Pullman, <em>The Subtle Knife</em></p>
</blockquote>
<hr />
<p>The Focus DSL and Effect Paths inhabit different worlds. One navigates the structure of data—drilling into records, unwrapping optionals, traversing collections. The other navigates the shape of computation—handling absence, failure, side effects, accumulated errors. Both worlds have their own grammar, their own rules, their own power.</p>
<p>But like the subtle knife, the bridge API lets you cut cleanly between them.</p>
<p>When you hold structured data and need the railway semantics of effects, the <code>toXxxPath</code> methods open a window from optics into effects. When you're deep in an effect pipeline and need to navigate the contained structure, <code>focus()</code> opens a window back. The passage is seamless. The types guide you. Each world remains itself, but now they connect.</p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="effect/focus_integration.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How Focus paths and Effect paths complement each other</li>
<li>Converting between optics and effects with bridge methods</li>
<li>Using <code>focus()</code> to navigate within effect contexts</li>
<li>Building validation pipelines that combine both domains</li>
<li>Common patterns and when to use each approach</li>
</ul>
</div>
</div>
<div id="admonition-hands-on-practice" class="admonition admonish-note" role="note" aria-labelledby="admonition-hands-on-practice-title">
<div class="admonition-title">
<div id="admonition-hands-on-practice-title">
<p>Hands On Practice</p>
</div>
<a class="admonition-anchor-link" href="effect/focus_integration.html#admonition-hands-on-practice"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/optics/Tutorial14_FocusEffectBridge.java">Tutorial14_FocusEffectBridge.java</a></p>
</div>
</div>
<hr />
<h2 id="the-two-domains"><a class="header" href="#the-two-domains">The Two Domains</a></h2>
<pre><code>    ┌─────────────────────────────────────────────────────────────────┐
    │                       OPTICS DOMAIN                             │
    │                                                                 │
    │   FocusPath&lt;S, A&gt;    ───── exactly one focus (Lens)             │
    │   AffinePath&lt;S, A&gt;   ───── zero or one focus (Affine)           │
    │   TraversalPath&lt;S, A&gt; ──── zero or more focuses (Traversal)     │
    │                                                                 │
    │   Navigation: get, set, modify, via(optic)                      │
    └─────────────────────────────────────────────────────────────────┘
                                    │
                                    │  Bridge API
                                    ▼
    ┌─────────────────────────────────────────────────────────────────┐
    │                       EFFECTS DOMAIN                            │
    │                                                                 │
    │   MaybePath&lt;A&gt;         ───── optional value                     │
    │   EitherPath&lt;E, A&gt;     ───── success or typed error             │
    │   TryPath&lt;A&gt;           ───── success or exception               │
    │   IOPath&lt;A&gt;            ───── deferred side effect               │
    │   ValidationPath&lt;E, A&gt; ───── accumulating errors                │
    │                                                                 │
    │   Navigation: map, via(effect), run, recover                    │
    └─────────────────────────────────────────────────────────────────┘
</code></pre>
<hr />
<h2 id="direction-1-optics--effects"><a class="header" href="#direction-1-optics--effects">Direction 1: Optics → Effects</a></h2>
<p>When you have a data structure and want to start an effect pipeline, use the <code>toXxxPath</code> methods
on Focus paths.</p>
<h3 id="focuspath-bridge-methods"><a class="header" href="#focuspath-bridge-methods">FocusPath Bridge Methods</a></h3>
<p><code>FocusPath</code> always has a value, so these methods always produce successful effects:</p>
<pre><code class="language-java">FocusPath&lt;User, String&gt; namePath = UserFocus.name();
User alice = new User("Alice", Optional.of("alice@example.com"));

// Lift into different effect types
MaybePath&lt;String&gt; maybeName = namePath.toMaybePath(alice);     // → Just("Alice")
EitherPath&lt;E, String&gt; eitherName = namePath.toEitherPath(alice); // → Right("Alice")
TryPath&lt;String&gt; tryName = namePath.toTryPath(alice);           // → Success("Alice")
IdPath&lt;String&gt; idName = namePath.toIdPath(alice);              // → Id("Alice")
</code></pre>
<h3 id="affinepath-bridge-methods"><a class="header" href="#affinepath-bridge-methods">AffinePath Bridge Methods</a></h3>
<p><code>AffinePath</code> may not have a value, so these methods require error handling:</p>
<pre><code class="language-java">AffinePath&lt;User, String&gt; emailPath = UserFocus.email(); // Optional&lt;String&gt; → String

User withEmail = new User("Alice", Optional.of("alice@example.com"));
User withoutEmail = new User("Bob", Optional.empty());

// MaybePath: absence becomes Nothing
emailPath.toMaybePath(withEmail);    // → Just("alice@example.com")
emailPath.toMaybePath(withoutEmail); // → Nothing

// EitherPath: provide error for absence
emailPath.toEitherPath(withEmail, "No email");    // → Right("alice@example.com")
emailPath.toEitherPath(withoutEmail, "No email"); // → Left("No email")

// TryPath: provide exception supplier for absence
emailPath.toTryPath(withEmail, () -&gt; new MissingEmailException());    // → Success
emailPath.toTryPath(withoutEmail, () -&gt; new MissingEmailException()); // → Failure
</code></pre>
<h3 id="traversalpath-bridge-methods"><a class="header" href="#traversalpath-bridge-methods">TraversalPath Bridge Methods</a></h3>
<p><code>TraversalPath</code> focuses on multiple values:</p>
<pre><code class="language-java">TraversalPath&lt;Company, User&gt; employeesPath = CompanyFocus.employees();
Company company = new Company("TechCorp", List.of(alice, bob, charlie));

// ListPath: all values as a list
ListPath&lt;User&gt; allEmployees = employeesPath.toListPath(company);

// StreamPath: lazy stream
StreamPath&lt;User&gt; employeeStream = employeesPath.toStreamPath(company);

// MaybePath: first value (or Nothing)
MaybePath&lt;User&gt; firstEmployee = employeesPath.toMaybePath(company);
</code></pre>
<h3 id="bridge-method-summary"><a class="header" href="#bridge-method-summary">Bridge Method Summary</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Path Type</th><th>Method</th><th>Result</th></tr></thead><tbody>
<tr><td><code>FocusPath&lt;S, A&gt;</code></td><td><code>toMaybePath(S)</code></td><td>Always <code>Just(a)</code></td></tr>
<tr><td><code>FocusPath&lt;S, A&gt;</code></td><td><code>toEitherPath(S)</code></td><td>Always <code>Right(a)</code></td></tr>
<tr><td><code>FocusPath&lt;S, A&gt;</code></td><td><code>toTryPath(S)</code></td><td>Always <code>Success(a)</code></td></tr>
<tr><td><code>FocusPath&lt;S, A&gt;</code></td><td><code>toIdPath(S)</code></td><td>Always <code>Id(a)</code></td></tr>
<tr><td><code>AffinePath&lt;S, A&gt;</code></td><td><code>toMaybePath(S)</code></td><td><code>Just(a)</code> or <code>Nothing</code></td></tr>
<tr><td><code>AffinePath&lt;S, A&gt;</code></td><td><code>toEitherPath(S, E)</code></td><td><code>Right(a)</code> or <code>Left(e)</code></td></tr>
<tr><td><code>AffinePath&lt;S, A&gt;</code></td><td><code>toTryPath(S, Supplier)</code></td><td><code>Success(a)</code> or <code>Failure</code></td></tr>
<tr><td><code>AffinePath&lt;S, A&gt;</code></td><td><code>toOptionalPath(S)</code></td><td><code>Optional.of(a)</code> or <code>Optional.empty()</code></td></tr>
<tr><td><code>TraversalPath&lt;S, A&gt;</code></td><td><code>toListPath(S)</code></td><td>All values as list</td></tr>
<tr><td><code>TraversalPath&lt;S, A&gt;</code></td><td><code>toStreamPath(S)</code></td><td>Lazy stream of values</td></tr>
<tr><td><code>TraversalPath&lt;S, A&gt;</code></td><td><code>toMaybePath(S)</code></td><td>First value or <code>Nothing</code></td></tr>
</tbody></table>
</div>
<hr />
<h2 id="direction-2-effects--optics"><a class="header" href="#direction-2-effects--optics">Direction 2: Effects → Optics</a></h2>
<p>When you're already in an effect context and need to navigate into the contained value, use
the <code>focus()</code> method.</p>
<h3 id="basic-focus-usage"><a class="header" href="#basic-focus-usage">Basic focus() Usage</a></h3>
<pre><code class="language-java">// Start with an effect containing structured data
EitherPath&lt;Error, User&gt; userResult = fetchUser(userId);

// Navigate into the structure
FocusPath&lt;User, String&gt; namePath = UserFocus.name();
EitherPath&lt;Error, String&gt; nameResult = userResult.focus(namePath);

// The effect semantics are preserved
// If userResult was Left(error), nameResult is also Left(error)
// If userResult was Right(user), nameResult is Right(user.name())
</code></pre>
<h3 id="focus-with-affinepath"><a class="header" href="#focus-with-affinepath">focus() with AffinePath</a></h3>
<p>When the navigation might fail (AffinePath), you must provide an error for the absent case:</p>
<pre><code class="language-java">AffinePath&lt;User, String&gt; emailPath = UserFocus.email();

// EitherPath requires an error value
EitherPath&lt;Error, String&gt; emailResult =
    userResult.focus(emailPath, new Error("Email not configured"));

// TryPath requires an exception supplier
TryPath&lt;String&gt; emailTry =
    userTryPath.focus(emailPath, () -&gt; new MissingEmailException());

// MaybePath just becomes Nothing (no error needed)
MaybePath&lt;String&gt; emailMaybe = userMaybePath.focus(emailPath);
</code></pre>
<h3 id="effect-specific-focus-behaviour"><a class="header" href="#effect-specific-focus-behaviour">Effect-Specific focus() Behaviour</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Effect Type</th><th>FocusPath Result</th><th>AffinePath (absent) Result</th></tr></thead><tbody>
<tr><td><code>MaybePath&lt;A&gt;</code></td><td><code>MaybePath&lt;B&gt;</code> (Just)</td><td><code>MaybePath&lt;B&gt;</code> (Nothing)</td></tr>
<tr><td><code>EitherPath&lt;E, A&gt;</code></td><td><code>EitherPath&lt;E, B&gt;</code> (Right)</td><td><code>EitherPath&lt;E, B&gt;</code> (Left with provided error)</td></tr>
<tr><td><code>TryPath&lt;A&gt;</code></td><td><code>TryPath&lt;B&gt;</code> (Success)</td><td><code>TryPath&lt;B&gt;</code> (Failure with provided exception)</td></tr>
<tr><td><code>IOPath&lt;A&gt;</code></td><td><code>IOPath&lt;B&gt;</code></td><td><code>IOPath&lt;B&gt;</code> (throws on run)</td></tr>
<tr><td><code>ValidationPath&lt;E, A&gt;</code></td><td><code>ValidationPath&lt;E, B&gt;</code> (Valid)</td><td><code>ValidationPath&lt;E, B&gt;</code> (Invalid with error)</td></tr>
<tr><td><code>IdPath&lt;A&gt;</code></td><td><code>IdPath&lt;B&gt;</code></td><td><code>MaybePath&lt;B&gt;</code> (path type changes)</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="practical-patterns"><a class="header" href="#practical-patterns">Practical Patterns</a></h2>
<h3 id="pattern-1-extract-and-validate"><a class="header" href="#pattern-1-extract-and-validate">Pattern 1: Extract and Validate</a></h3>
<p><strong>The problem:</strong> You have nested data and need to extract and validate specific fields.</p>
<p><strong>The solution:</strong></p>
<pre><code class="language-java">EitherPath&lt;List&lt;String&gt;, User&gt; validateUser(User user) {
    FocusPath&lt;User, String&gt; namePath = UserFocus.name();
    AffinePath&lt;User, String&gt; emailPath = UserFocus.email();

    return Path.&lt;List&lt;String&gt;, User&gt;right(user)
        .via(u -&gt; {
            // Validate name length
            String name = namePath.get(u);
            if (name.length() &lt; 2) {
                return Path.left(List.of("Name too short"));
            }
            return Path.right(u);
        })
        .via(u -&gt; {
            // Validate email if present
            return emailPath.toEitherPath(u, List.of("Email required"))
                .via(email -&gt; email.contains("@")
                    ? Path.right(u)
                    : Path.left(List.of("Invalid email format")));
        });
}
</code></pre>
<h3 id="pattern-2-nested-service-results"><a class="header" href="#pattern-2-nested-service-results">Pattern 2: Nested Service Results</a></h3>
<p><strong>The problem:</strong> Service calls return effects, and you need to extract nested data.</p>
<p><strong>The solution:</strong></p>
<pre><code class="language-java">EitherPath&lt;Error, String&gt; getOrderCustomerCity(OrderId orderId) {
    return orderService.findById(orderId)           // → EitherPath&lt;Error, Order&gt;
        .focus(OrderFocus.customer())               // → EitherPath&lt;Error, Customer&gt;
        .focus(CustomerFocus.address())             // → EitherPath&lt;Error, Address&gt;
        .focus(AddressFocus.city());                // → EitherPath&lt;Error, String&gt;
}
</code></pre>
<h3 id="pattern-3-safe-deep-access"><a class="header" href="#pattern-3-safe-deep-access">Pattern 3: Safe Deep Access</a></h3>
<p><strong>The problem:</strong> Accessing deeply nested optional data without null checks.</p>
<p><strong>The solution:</strong></p>
<pre><code class="language-java">// Traditional approach (pyramid of doom)
String getManagerEmail(Company company) {
    Department dept = company.getDepartment(0);
    if (dept == null) return "unknown";
    Employee manager = dept.getManager();
    if (manager == null) return "unknown";
    String email = manager.getEmail();
    return email != null ? email : "unknown";
}

// Focus-Effect approach
String getManagerEmail(Company company) {
    return CompanyFocus.department(0)
        .toMaybePath(company)                       // → MaybePath&lt;Department&gt;
        .focus(DepartmentFocus.manager())           // → MaybePath&lt;Employee&gt;
        .focus(EmployeeFocus.email())               // → MaybePath&lt;String&gt;
        .getOrElse("unknown");
}
</code></pre>
<h3 id="pattern-4-batch-processing-with-traversals"><a class="header" href="#pattern-4-batch-processing-with-traversals">Pattern 4: Batch Processing with Traversals</a></h3>
<p><strong>The problem:</strong> Apply an effectful operation to all items in a collection.</p>
<p><strong>The solution:</strong></p>
<pre><code class="language-java">// Validate all employee emails
ValidationPath&lt;List&lt;String&gt;, Company&gt; validateAllEmails(Company company) {
    return CompanyFocus.employees()
        .toListPath(company)
        .via(employees -&gt; {
            // Validate each employee's email
            var results = employees.stream()
                .map(e -&gt; EmployeeFocus.email()
                    .toEitherPath(e, List.of("Missing email for " + e.name())))
                .toList();
            // Combine results...
        });
}
</code></pre>
<hr />
<h2 id="when-to-use-which"><a class="header" href="#when-to-use-which">When to Use Which</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Scenario</th><th>Approach</th></tr></thead><tbody>
<tr><td>Have data, need effect pipeline</td><td><code>path.toXxxPath(source)</code></td></tr>
<tr><td>In effect, need to navigate</td><td><code>effectPath.focus(opticPath)</code></td></tr>
<tr><td>Simple extraction</td><td><code>focusPath.get(source)</code></td></tr>
<tr><td>Chained effect operations</td><td><code>effectPath.via(f)</code></td></tr>
<tr><td>Transform without effect change</td><td><code>effectPath.map(f)</code></td></tr>
</tbody></table>
</div>
<h3 id="decision-flow"><a class="header" href="#decision-flow">Decision Flow</a></h3>
<pre><code>Start with...
    │
    ├─► Concrete data?
    │       │
    │       └─► Use FocusPath.toXxxPath(data) to enter effect domain
    │
    └─► Effect containing data?
            │
            ├─► Need to navigate structure?
            │       │
            │       └─► Use effectPath.focus(opticPath)
            │
            ├─► Need to chain effects?
            │       │
            │       └─► Use effectPath.via(f)
            │
            └─► Need to transform value?
                    │
                    └─► Use effectPath.map(f)
</code></pre>
<hr />
<h2 id="composing-both-directions"><a class="header" href="#composing-both-directions">Composing Both Directions</a></h2>
<p>The most powerful patterns combine both directions fluently:</p>
<pre><code class="language-java">// Complete workflow: fetch → navigate → validate → transform → save
EitherPath&lt;Error, SaveResult&gt; processUserUpdate(UserId userId, UpdateRequest request) {
    return userService.findById(userId)                    // Effect: fetch user
        .focus(UserFocus.profile())                        // Optics: navigate to profile
        .via(profile -&gt; {                                  // Effect: validate
            return ProfileFocus.email()
                .toEitherPath(profile, Error.missingEmail())
                .via(email -&gt; validateEmail(email));
        })
        .via(validEmail -&gt; {                               // Effect: apply update
            return applyUpdate(request, validEmail);
        })
        .via(updated -&gt; {                                  // Effect: save
            return userService.save(updated);
        });
}
</code></pre>
<hr />
<div id="admonition-hands-on-learning" class="admonition admonish-info" role="note" aria-labelledby="admonition-hands-on-learning-title">
<div class="admonition-title">
<div id="admonition-hands-on-learning-title">
<p>Hands-On Learning</p>
</div>
<a class="admonition-anchor-link" href="effect/focus_integration.html#admonition-hands-on-learning"></a>
</div>
<div>
<p>Practice Focus-Effect bridging in <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/optics/Tutorial14_FocusEffectBridge.java">Tutorial 14: Focus-Effect Bridge</a> (13 exercises, ~15 minutes).</p>
</div>
</div>
<div id="admonition-see-also" class="admonition admonish-tip" role="note" aria-labelledby="admonition-see-also-title">
<div class="admonition-title">
<div id="admonition-see-also-title">
<p>See Also</p>
</div>
<a class="admonition-anchor-link" href="effect/focus_integration.html#admonition-see-also"></a>
</div>
<div>
<ul>
<li><a href="effect/../optics/focus_dsl.html">Focus DSL</a> - Complete guide to Focus paths</li>
<li><a href="effect/effect_path_overview.html">Effect Path Overview</a> - Railway model and effect basics</li>
<li><a href="effect/capabilities.html">Capability Interfaces</a> - Type class foundations</li>
</ul>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="effect/conversions.html">Type Conversions</a>
<strong>Next:</strong> <a href="effect/patterns.html">Patterns and Recipes</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="patterns-and-recipes"><a class="header" href="#patterns-and-recipes">Patterns and Recipes</a></h1>
<blockquote>
<p><em>"When the going gets weird, the weird turn professional."</em></p>
<p>— Hunter S. Thompson, <em>Fear and Loathing on the Campaign Trail '72</em></p>
</blockquote>
<p>Every codebase eventually gets weird. Edge cases multiply. Requirements
contradict. Legacy systems refuse to behave. The patterns in this chapter
are for those moments: tested approaches from production code where the
weird was met professionally.</p>
<p>These aren't academic exercises. They're recipes that survived contact with
reality.</p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="effect/patterns.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>Validation pipeline patterns for single fields and combined validations</li>
<li>Service layer patterns for repositories and chained service calls</li>
<li>IO effect patterns for resource management and composing effects</li>
<li>Error handling strategies: enrichment, recovery with logging, circuit breakers</li>
<li>Testing patterns for Path-returning methods</li>
<li>Integration patterns with existing code</li>
</ul>
</div>
</div>
<hr />
<h2 id="validation-pipelines"><a class="header" href="#validation-pipelines">Validation Pipelines</a></h2>
<p>User input arrives untrustworthy. Every field might be missing, malformed,
or actively hostile. Traditional validation scatters null checks and
conditionals throughout your code. Path types let you build validation as
composable pipelines where each rule is small, testable, and reusable.</p>
<h3 id="single-field-validation"><a class="header" href="#single-field-validation">Single Field Validation</a></h3>
<p>Each field gets its own validation function returning a Path:</p>
<pre><code class="language-java">private EitherPath&lt;String, String&gt; validateEmail(String email) {
    if (email == null || email.isBlank()) {
        return Path.left("Email is required");
    }
    if (!email.contains("@")) {
        return Path.left("Email must contain @");
    }
    if (!email.contains(".")) {
        return Path.left("Email must contain a domain");
    }
    return Path.right(email.toLowerCase().trim());
}
</code></pre>
<p>Or with modern pattern matching:</p>
<pre><code class="language-java">private EitherPath&lt;String, String&gt; validateEmail(String email) {
    return switch (email) {
        case null -&gt; Path.left("Email is required");
        case String e when e.isBlank() -&gt; Path.left("Email is required");
        case String e when !e.contains("@") -&gt; Path.left("Email must contain @");
        case String e when !e.contains(".") -&gt; Path.left("Email must have a domain");
        case String e -&gt; Path.right(e.toLowerCase().trim());
    };
}
</code></pre>
<p>The validated value may be transformed (lowercase, trimmed); the Path
carries the clean version forward.</p>
<h3 id="combining-validations-fail-fast"><a class="header" href="#combining-validations-fail-fast">Combining Validations (Fail-Fast)</a></h3>
<p>When all fields must be valid to proceed:</p>
<pre><code class="language-java">record User(String name, String email, int age) {}

EitherPath&lt;String, User&gt; validateUser(UserInput input) {
    return validateName(input.name())
        .zipWith3(
            validateEmail(input.email()),
            validateAge(input.age()),
            User::new
        );
}
</code></pre>
<p>First failure stops processing. For user-facing forms, this is often too
abrupt; see the next pattern.</p>
<h3 id="combining-validations-accumulating"><a class="header" href="#combining-validations-accumulating">Combining Validations (Accumulating)</a></h3>
<p>When users deserve to see all problems at once:</p>
<pre><code class="language-java">ValidationPath&lt;List&lt;String&gt;, User&gt; validateUser(UserInput input) {
    return validateNameV(input.name())
        .zipWith3Accum(
            validateEmailV(input.email()),
            validateAgeV(input.age()),
            User::new
        );
}

// Usage
validateUser(input).run().fold(
    errors -&gt; showAllErrors(errors),  // ["Name too short", "Invalid email"]
    user -&gt; proceed(user)
);
</code></pre>
<p>The difference is respect for the user's time.</p>
<h3 id="nested-validation"><a class="header" href="#nested-validation">Nested Validation</a></h3>
<p>Complex objects with nested structures:</p>
<pre><code class="language-java">record Registration(User user, Address address, List&lt;Preference&gt; prefs) {}

EitherPath&lt;String, Registration&gt; validateRegistration(RegistrationInput input) {
    EitherPath&lt;String, User&gt; user = validateUser(input.user());

    EitherPath&lt;String, Address&gt; address = validateStreet(input.street())
        .zipWith3(
            validateCity(input.city()),
            validatePostcode(input.postcode()),
            Address::new
        );

    EitherPath&lt;String, List&lt;Preference&gt;&gt; prefs =
        validatePreferences(input.preferences());

    return user.zipWith3(address, prefs, Registration::new);
}
</code></pre>
<p>Each sub-validation is independent; they combine at the end.</p>
<hr />
<h2 id="service-layer-patterns"><a class="header" href="#service-layer-patterns">Service Layer Patterns</a></h2>
<p>Services orchestrate multiple operations: fetching data, applying business
rules, calling external systems. Each step might fail differently. Path types
make the orchestration explicit.</p>
<h3 id="repository-pattern"><a class="header" href="#repository-pattern">Repository Pattern</a></h3>
<p>Repositories return <code>Maybe</code> (absence is expected). Services convert to
<code>Either</code> (absence becomes an error in context):</p>
<pre><code class="language-java">public class UserRepository {
    public Maybe&lt;User&gt; findById(String id) {
        return Maybe.fromOptional(
            jdbcTemplate.queryForOptional("SELECT...", id)
        );
    }

    public Maybe&lt;User&gt; findByEmail(String email) {
        return Maybe.fromOptional(
            jdbcTemplate.queryForOptional("SELECT...", email)
        );
    }
}

public class UserService {
    private final UserRepository repository;

    public EitherPath&lt;UserError, User&gt; getById(String id) {
        return Path.maybe(repository.findById(id))
            .toEitherPath(() -&gt; new UserError.NotFound(id));
    }

    public EitherPath&lt;UserError, User&gt; getByEmail(String email) {
        return Path.maybe(repository.findByEmail(email))
            .toEitherPath(() -&gt; new UserError.NotFound(email));
    }
}
</code></pre>
<p>The conversion happens at the layer boundary. Repository callers get <code>Maybe</code>;
service callers get <code>Either</code> with meaningful errors.</p>
<h3 id="chained-service-calls"><a class="header" href="#chained-service-calls">Chained Service Calls</a></h3>
<p>When each step depends on the previous:</p>
<pre><code class="language-java">public class OrderService {
    private final UserService users;
    private final InventoryService inventory;
    private final PaymentService payments;

    public EitherPath&lt;OrderError, Order&gt; placeOrder(
            String userId, List&lt;Item&gt; items) {
        return users.getById(userId)
            .mapError(OrderError::fromUserError)
            .via(user -&gt; inventory.reserve(items)
                .mapError(OrderError::fromInventoryError))
            .via(reservation -&gt; payments.charge(user, reservation.total())
                .mapError(OrderError::fromPaymentError))
            .via(payment -&gt; Path.right(
                createOrder(user, items, payment)));
    }
}
</code></pre>
<p>Each <code>mapError</code> translates the sub-service error into the order domain.
The final <code>Order</code> is created only if all steps succeed.</p>
<h3 id="service-with-fallbacks"><a class="header" href="#service-with-fallbacks">Service with Fallbacks</a></h3>
<p>When multiple sources can satisfy a request:</p>
<pre><code class="language-java">public class ConfigService {
    public EitherPath&lt;ConfigError, Config&gt; loadConfig() {
        return Path.either(loadFromFile())
            .recoverWith(e -&gt; {
                log.warn("File config unavailable: {}", e.getMessage());
                return Path.either(loadFromEnvironment());
            })
            .recoverWith(e -&gt; {
                log.warn("Env config unavailable: {}", e.getMessage());
                return Path.right(Config.defaults());
            });
    }
}
</code></pre>
<p>The logs record what was tried; the caller gets a working config or a clear
failure.</p>
<hr />
<h2 id="io-effect-patterns"><a class="header" href="#io-effect-patterns">IO Effect Patterns</a></h2>
<h3 id="resource-management-1"><a class="header" href="#resource-management-1">Resource Management</a></h3>
<p>Acquire, use, release, regardless of success or failure:</p>
<pre><code class="language-java">public class FileProcessor {
    public IOPath&lt;ProcessResult&gt; process(Path path) {
        return Path.io(() -&gt; new BufferedReader(new FileReader(path.toFile())))
            .via(reader -&gt; Path.io(() -&gt; processContent(reader)))
            .ensuring(() -&gt; {
                // Cleanup runs regardless of outcome
                log.debug("Processing complete: {}", path);
            });
    }
}
</code></pre>
<p>For true resource safety with acquisition and release:</p>
<pre><code class="language-java">public IOPath&lt;Result&gt; withConnection(Function&lt;Connection, Result&gt; action) {
    return Path.io(() -&gt; dataSource.getConnection())
        .via(conn -&gt; Path.io(() -&gt; action.apply(conn))
            .ensuring(() -&gt; {
                try { conn.close(); }
                catch (SQLException e) { log.warn("Close failed", e); }
            }));
}
</code></pre>
<h3 id="composing-effect-pipelines"><a class="header" href="#composing-effect-pipelines">Composing Effect Pipelines</a></h3>
<p>Build complex pipelines that execute later:</p>
<pre><code class="language-java">public class DataPipeline {
    public IOPath&lt;Report&gt; generateReport(ReportRequest request) {
        return Path.io(() -&gt; log.info("Starting report: {}", request.id()))
            .then(() -&gt; Path.io(() -&gt; fetchData(request)))
            .via(data -&gt; Path.io(() -&gt; transform(data)))
            .via(transformed -&gt; Path.io(() -&gt; aggregate(transformed)))
            .via(aggregated -&gt; Path.io(() -&gt; format(aggregated)))
            .peek(report -&gt; log.info("Report ready: {} rows", report.rowCount()));
    }
}

// Nothing happens until:
Report report = pipeline.generateReport(request).unsafeRun();
</code></pre>
<h3 id="expressing-parallel-intent"><a class="header" href="#expressing-parallel-intent">Expressing Parallel Intent</a></h3>
<p>While <code>IOPath</code> doesn't parallelise automatically, <code>zipWith</code> expresses
independence:</p>
<pre><code class="language-java">IOPath&lt;CombinedData&gt; fetchAll() {
    IOPath&lt;UserData&gt; users = Path.io(() -&gt; fetchUsers());
    IOPath&lt;ProductData&gt; products = Path.io(() -&gt; fetchProducts());
    IOPath&lt;OrderData&gt; orders = Path.io(() -&gt; fetchOrders());

    return users.zipWith3(products, orders, CombinedData::new);
}
</code></pre>
<p>A more sophisticated runtime could parallelise these. For now, they execute
in sequence, but the structure is clear.</p>
<hr />
<h2 id="error-handling-strategies-1"><a class="header" href="#error-handling-strategies-1">Error Handling Strategies</a></h2>
<h3 id="error-enrichment"><a class="header" href="#error-enrichment">Error Enrichment</a></h3>
<p>Add context as errors propagate through layers:</p>
<pre><code class="language-java">public &lt;A&gt; EitherPath&lt;DetailedError, A&gt; withContext(
        EitherPath&lt;Error, A&gt; path,
        String operation,
        Map&lt;String, Object&gt; context) {
    return path.mapError(error -&gt; new DetailedError(
        error,
        operation,
        context,
        Instant.now()
    ));
}

// Usage
return withContext(
    userService.getUser(id),
    "getUser",
    Map.of("userId", id, "requestId", requestId)
);
</code></pre>
<p>When the error surfaces, you know what was happening and with what parameters.</p>
<h3 id="recovery-with-logging"><a class="header" href="#recovery-with-logging">Recovery with Logging</a></h3>
<p>Log the failure, provide a fallback:</p>
<pre><code class="language-java">public &lt;A&gt; EitherPath&lt;Error, A&gt; withRecoveryLogging(
        EitherPath&lt;Error, A&gt; path,
        A fallback,
        String operation) {
    return path.recover(error -&gt; {
        log.warn("Operation '{}' failed: {}. Using fallback.",
            operation, error);
        return fallback;
    });
}
</code></pre>
<h3 id="circuit-breaker"><a class="header" href="#circuit-breaker">Circuit Breaker</a></h3>
<p>Stop calling a failing service:</p>
<pre><code class="language-java">public class CircuitBreaker&lt;E, A&gt; {
    private final AtomicInteger failures = new AtomicInteger(0);
    private final int threshold;
    private final Supplier&lt;EitherPath&lt;E, A&gt;&gt; fallback;

    public EitherPath&lt;E, A&gt; execute(Supplier&lt;EitherPath&lt;E, A&gt;&gt; operation) {
        if (failures.get() &gt;= threshold) {
            log.debug("Circuit open, using fallback");
            return fallback.get();
        }

        return operation.get()
            .peek(success -&gt; failures.set(0))
            .recoverWith(error -&gt; {
                int count = failures.incrementAndGet();
                log.warn("Failure {} of {}", count, threshold);
                return Path.left(error);
            });
    }
}
</code></pre>
<p>A proper implementation would include timeouts and half-open states. This
shows the pattern.</p>
<hr />
<h2 id="resilience-retry-with-backoff"><a class="header" href="#resilience-retry-with-backoff">Resilience: Retry with Backoff</a></h2>
<blockquote>
<p><em>"The protocol specified exponential backoff: wait one second, try again;
wait two seconds, try again; wait four seconds..."</em></p>
<p>— Neal Stephenson, <em>Cryptonomicon</em></p>
</blockquote>
<p>Transient failures—network blips, brief overloads—often succeed on retry.
But retrying immediately can worsen the problem. The <code>RetryPolicy</code> API
provides configurable backoff strategies.</p>
<h3 id="creating-retry-policies"><a class="header" href="#creating-retry-policies">Creating Retry Policies</a></h3>
<pre><code class="language-java">// Fixed delay: 100ms between each of 3 attempts
RetryPolicy fixed = RetryPolicy.fixed(3, Duration.ofMillis(100));

// Exponential backoff: 1s, 2s, 4s, 8s...
RetryPolicy exponential = RetryPolicy.exponentialBackoff(5, Duration.ofSeconds(1));

// With jitter to prevent thundering herd
RetryPolicy jittered = RetryPolicy.exponentialBackoffWithJitter(5, Duration.ofSeconds(1));
</code></pre>
<h3 id="applying-retry-to-paths"><a class="header" href="#applying-retry-to-paths">Applying Retry to Paths</a></h3>
<pre><code class="language-java">IOPath&lt;Response&gt; resilient = IOPath.delay(() -&gt; httpClient.get(url))
    .withRetry(RetryPolicy.exponentialBackoff(3, Duration.ofSeconds(1)));

// Convenience method for simple cases
IOPath&lt;Response&gt; simple = IOPath.delay(() -&gt; httpClient.get(url))
    .retry(3);  // Uses default exponential backoff
</code></pre>
<h3 id="configuring-retry-behaviour"><a class="header" href="#configuring-retry-behaviour">Configuring Retry Behaviour</a></h3>
<p>Policies are immutable but configurable:</p>
<pre><code class="language-java">RetryPolicy policy = RetryPolicy.exponentialBackoff(5, Duration.ofMillis(100))
    .withMaxDelay(Duration.ofSeconds(30))   // Cap maximum wait
    .retryOn(IOException.class);             // Only retry I/O errors
</code></pre>
<h3 id="selective-retry"><a class="header" href="#selective-retry">Selective Retry</a></h3>
<p>Not all errors should trigger retry:</p>
<pre><code class="language-java">RetryPolicy selective = RetryPolicy.fixed(3, Duration.ofMillis(100))
    .retryIf(ex -&gt;
        ex instanceof IOException ||
        ex instanceof TimeoutException ||
        (ex instanceof HttpException http &amp;&amp; http.statusCode() &gt;= 500));
</code></pre>
<h3 id="combining-retry-with-fallback"><a class="header" href="#combining-retry-with-fallback">Combining Retry with Fallback</a></h3>
<pre><code class="language-java">IOPath&lt;Data&gt; robust = fetchFromPrimary()
    .withRetry(RetryPolicy.exponentialBackoff(3, Duration.ofSeconds(1)))
    .handleErrorWith(e -&gt; {
        log.warn("Primary exhausted, trying backup");
        return fetchFromBackup()
            .withRetry(RetryPolicy.fixed(2, Duration.ofMillis(100)));
    })
    .recover(e -&gt; {
        log.error("All sources failed", e);
        return Data.empty();
    });
</code></pre>
<h3 id="handling-exhausted-retries"><a class="header" href="#handling-exhausted-retries">Handling Exhausted Retries</a></h3>
<p>When all attempts fail, <code>RetryExhaustedException</code> is thrown:</p>
<pre><code class="language-java">try {
    resilient.unsafeRun();
} catch (RetryExhaustedException e) {
    log.error("All retries failed: {}", e.getMessage());
    Throwable lastFailure = e.getCause();
    return fallbackValue;
}
</code></pre>
<h3 id="retry-pattern-quick-reference"><a class="header" href="#retry-pattern-quick-reference">Retry Pattern Quick Reference</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Strategy</th><th>Use Case</th></tr></thead><tbody>
<tr><td><code>fixed(n, delay)</code></td><td>Known recovery time</td></tr>
<tr><td><code>exponentialBackoff(n, initial)</code></td><td>Unknown recovery time</td></tr>
<tr><td><code>exponentialBackoffWithJitter(n, initial)</code></td><td>Multiple clients retrying</td></tr>
<tr><td><code>.retryOn(ExceptionType.class)</code></td><td>Selective retry</td></tr>
<tr><td><code>.withMaxDelay(duration)</code></td><td>Cap exponential growth</td></tr>
</tbody></table>
</div><div id="admonition-see-also" class="admonition admonish-tip" role="note" aria-labelledby="admonition-see-also-title">
<div class="admonition-title">
<div id="admonition-see-also-title">
<p>See Also</p>
</div>
<a class="admonition-anchor-link" href="effect/patterns.html#admonition-see-also"></a>
</div>
<div>
<p>See <a href="effect/advanced_topics.html">Advanced Effect Topics</a> for comprehensive coverage of
resilience patterns including resource management with <code>bracket</code> and <code>guarantee</code>.</p>
</div>
</div>
<hr />
<h2 id="testing-patterns"><a class="header" href="#testing-patterns">Testing Patterns</a></h2>
<p>Path-returning methods are straightforward to test. The explicit success/failure
encoding means you can verify both paths without exception handling gymnastics.</p>
<h3 id="testing-success-and-failure"><a class="header" href="#testing-success-and-failure">Testing Success and Failure</a></h3>
<pre><code class="language-java">@Test
void shouldReturnUserWhenFound() {
    when(repository.findById("123")).thenReturn(Maybe.just(testUser));

    EitherPath&lt;UserError, User&gt; result = service.getUser("123");

    assertThat(result.run().isRight()).isTrue();
    assertThat(result.run().getRight()).isEqualTo(testUser);
}

@Test
void shouldReturnErrorWhenNotFound() {
    when(repository.findById("123")).thenReturn(Maybe.nothing());

    EitherPath&lt;UserError, User&gt; result = service.getUser("123");

    assertThat(result.run().isLeft()).isTrue();
    assertThat(result.run().getLeft()).isInstanceOf(UserError.NotFound.class);
}
</code></pre>
<h3 id="testing-error-propagation"><a class="header" href="#testing-error-propagation">Testing Error Propagation</a></h3>
<p>Verify that errors from nested operations surface correctly:</p>
<pre><code class="language-java">@Test
void shouldPropagatePaymentError() {
    when(userService.getUser(any())).thenReturn(Path.right(testUser));
    when(inventory.check(any())).thenReturn(Path.right(availability));
    when(payments.charge(any(), any()))
        .thenReturn(Path.left(new PaymentError("Declined")));

    EitherPath&lt;OrderError, Order&gt; result = orderService.placeOrder(request);

    assertThat(result.run().isLeft()).isTrue();
    assertThat(result.run().getLeft())
        .isInstanceOf(OrderError.PaymentFailed.class);

    // Order creation should never be called
    verify(orderRepository, never()).save(any());
}
</code></pre>
<h3 id="property-based-testing"><a class="header" href="#property-based-testing">Property-Based Testing</a></h3>
<p>Use jqwik or similar to verify laws across many inputs:</p>
<pre><code class="language-java">@Property
void functorIdentityLaw(@ForAll @StringLength(min = 1, max = 100) String value) {
    MaybePath&lt;String&gt; path = Path.just(value);
    MaybePath&lt;String&gt; mapped = path.map(Function.identity());

    assertThat(mapped.run()).isEqualTo(path.run());
}

@Property
void recoverAlwaysSucceeds(
        @ForAll String errorMessage,
        @ForAll String fallback) {
    EitherPath&lt;String, String&gt; failed = Path.left(errorMessage);
    EitherPath&lt;String, String&gt; recovered = failed.recover(e -&gt; fallback);

    assertThat(recovered.run().isRight()).isTrue();
    assertThat(recovered.run().getRight()).isEqualTo(fallback);
}
</code></pre>
<h3 id="testing-deferred-effects"><a class="header" href="#testing-deferred-effects">Testing Deferred Effects</a></h3>
<p>Verify that <code>IOPath</code> defers execution:</p>
<pre><code class="language-java">@Test
void shouldDeferExecution() {
    AtomicInteger callCount = new AtomicInteger(0);
    IOPath&lt;Integer&gt; io = Path.io(() -&gt; callCount.incrementAndGet());

    assertThat(callCount.get()).isEqualTo(0);  // Not yet

    int result = io.unsafeRun();

    assertThat(callCount.get()).isEqualTo(1);  // Now
    assertThat(result).isEqualTo(1);
}

@Test
void shouldCaptureExceptionInRunSafe() {
    IOPath&lt;String&gt; failing = Path.io(() -&gt; {
        throw new RuntimeException("test error");
    });

    Try&lt;String&gt; result = failing.runSafe();

    assertThat(result.isFailure()).isTrue();
    assertThat(result.getCause().getMessage()).isEqualTo("test error");
}
</code></pre>
<hr />
<h2 id="integration-with-existing-code"><a class="header" href="#integration-with-existing-code">Integration with Existing Code</a></h2>
<p>Real projects have legacy code that throws exceptions, returns <code>Optional</code>,
or uses patterns that predate functional error handling.</p>
<h3 id="wrapping-exception-throwing-apis"><a class="header" href="#wrapping-exception-throwing-apis">Wrapping Exception-Throwing APIs</a></h3>
<pre><code class="language-java">public class LegacyWrapper {
    private final LegacyService legacy;

    public TryPath&lt;Data&gt; fetchData(String id) {
        return Path.tryOf(() -&gt; legacy.fetchData(id));
    }

    public EitherPath&lt;ServiceError, Data&gt; fetchDataSafe(String id) {
        return Path.tryOf(() -&gt; legacy.fetchData(id))
            .toEitherPath(ex -&gt; new ServiceError("Fetch failed", ex));
    }
}
</code></pre>
<h3 id="wrapping-optional-returning-apis"><a class="header" href="#wrapping-optional-returning-apis">Wrapping Optional-Returning APIs</a></h3>
<pre><code class="language-java">public class ModernWrapper {
    private final ModernService modern;

    public MaybePath&lt;User&gt; findUser(String id) {
        return Path.maybe(Maybe.fromOptional(modern.findUser(id)));
    }
}
</code></pre>
<h3 id="exposing-to-non-path-consumers"><a class="header" href="#exposing-to-non-path-consumers">Exposing to Non-Path Consumers</a></h3>
<p>When callers expect traditional patterns:</p>
<pre><code class="language-java">public class ServiceAdapter {
    private final PathBasedService service;

    // For consumers expecting Optional
    public Optional&lt;User&gt; findUser(String id) {
        return service.findUser(id).run().toOptional();
    }

    // For consumers expecting exceptions
    public User getUser(String id) throws UserNotFoundException {
        Either&lt;UserError, User&gt; result = service.getUser(id).run();
        if (result.isLeft()) {
            throw new UserNotFoundException(result.getLeft().message());
        }
        return result.getRight();
    }
}
</code></pre>
<hr />
<h2 id="common-pitfalls"><a class="header" href="#common-pitfalls">Common Pitfalls</a></h2>
<h3 id="pitfall-1-excessive-conversion"><a class="header" href="#pitfall-1-excessive-conversion">Pitfall 1: Excessive Conversion</a></h3>
<pre><code class="language-java">// Wasteful
Path.maybe(findUser(id))
    .toEitherPath(() -&gt; error)
    .toMaybePath()
    .toEitherPath(() -&gt; error);

// Clean
Path.maybe(findUser(id))
    .toEitherPath(() -&gt; error);
</code></pre>
<h3 id="pitfall-2-side-effects-in-pure-operations"><a class="header" href="#pitfall-2-side-effects-in-pure-operations">Pitfall 2: Side Effects in Pure Operations</a></h3>
<pre><code class="language-java">// Wrong
path.map(user -&gt; {
    auditLog.record(user);  // Side effect in map!
    return user;
});

// Right
path.peek(user -&gt; auditLog.record(user));
</code></pre>
<h3 id="pitfall-3-ignoring-the-result"><a class="header" href="#pitfall-3-ignoring-the-result">Pitfall 3: Ignoring the Result</a></h3>
<pre><code class="language-java">// Bug: result discarded, nothing happens
void processOrder(OrderRequest request) {
    validateAndProcess(request);  // Returns EitherPath, ignored
}

// Fixed
void processOrder(OrderRequest request) {
    validateAndProcess(request).run();  // Actually execute
}
</code></pre>
<h3 id="pitfall-4-treating-all-errors-the-same"><a class="header" href="#pitfall-4-treating-all-errors-the-same">Pitfall 4: Treating All Errors the Same</a></h3>
<pre><code class="language-java">// Loses information
.mapError(e -&gt; "An error occurred")

// Preserves structure
.mapError(e -&gt; new DomainError(e.code(), e.message(), e))
</code></pre>
<hr />
<h2 id="quick-reference-1"><a class="header" href="#quick-reference-1">Quick Reference</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Pattern</th><th>When to Use</th><th>Key Methods</th></tr></thead><tbody>
<tr><td>Single validation</td><td>Validate one field</td><td><code>Path.right/left</code></td></tr>
<tr><td>Combined validation</td><td>Multiple independent fields</td><td><code>zipWith</code>, <code>zipWithAccum</code></td></tr>
<tr><td>Repository wrapping</td><td>Maybe → Either at boundary</td><td><code>toEitherPath</code></td></tr>
<tr><td>Service chaining</td><td>Sequential dependent calls</td><td><code>via</code>, <code>mapError</code></td></tr>
<tr><td>Fallback chain</td><td>Multiple sources</td><td><code>recoverWith</code></td></tr>
<tr><td>Resource management</td><td>Acquire/use/release</td><td><code>bracket</code>, <code>withResource</code></td></tr>
<tr><td>Cleanup guarantee</td><td>Ensure finalizer runs</td><td><code>guarantee</code></td></tr>
<tr><td>Effect pipeline</td><td>Deferred composition</td><td><code>via</code>, <code>then</code>, <code>unsafeRun</code></td></tr>
<tr><td>Error enrichment</td><td>Add context</td><td><code>mapError</code></td></tr>
<tr><td>Circuit breaker</td><td>Protect failing service</td><td><code>recover</code>, <code>recoverWith</code></td></tr>
<tr><td>Retry with backoff</td><td>Transient failures</td><td><code>withRetry</code>, <code>RetryPolicy</code></td></tr>
<tr><td>Selective retry</td><td>Specific exception types</td><td><code>.retryOn()</code>, <code>.retryIf()</code></td></tr>
</tbody></table>
</div>
<hr />
<h2 id="summary-4"><a class="header" href="#summary-4">Summary</a></h2>
<p>The patterns in this chapter share a common theme: making the implicit explicit.
Error handling becomes visible in the types. Composition becomes visible in
the pipeline. Dependencies become visible in the choice of <code>via</code> vs <code>zipWith</code>.</p>
<p>When the going gets weird (and it will), these patterns are your professional
toolkit. They won't make the weirdness go away, but they'll help you handle
it with composure.</p>
<p>Continue to <a href="effect/advanced_effects.html">Advanced Effects</a> for Reader, State, and
Writer patterns.</p>
<div id="admonition-see-also-1" class="admonition admonish-tip" role="note" aria-labelledby="admonition-see-also-1-title">
<div class="admonition-title">
<div id="admonition-see-also-1-title">
<p>See Also</p>
</div>
<a class="admonition-anchor-link" href="effect/patterns.html#admonition-see-also-1"></a>
</div>
<div>
<ul>
<li><a href="effect/../monads/validated_monad.html">Validated Monad</a> - Accumulating validation errors</li>
<li><a href="effect/../functional/monad_error.html">MonadError</a> - The type class behind error recovery</li>
<li><a href="effect/../monads/io_monad.html">IO Monad</a> - Deferred effect execution</li>
</ul>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="effect/focus_integration.html">Focus-Effect Integration</a>
<strong>Next:</strong> <a href="effect/advanced_effects.html">Advanced Effects</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="advanced-effects"><a class="header" href="#advanced-effects">Advanced Effects</a></h1>
<blockquote>
<p><em>"We are surrounded by huge institutions we can never penetrate... They've
made themselves user-friendly, but they define the tastes to which we conform.
They're rather subtle, subservient tyrannies, but no less sinister for that."</em></p>
<p>— J.G. Ballard</p>
</blockquote>
<p>Ballard was describing the modern landscape of invisible systems: banks,
networks, bureaucracies that shape our choices while remaining opaque. Software
faces the same challenge. Configuration systems, database connections, logging
infrastructure. These are the "institutions" your code must navigate. They're
everywhere, they're necessary, and handling them explicitly at every call site
creates clutter that obscures your actual logic.</p>
<p>This chapter introduces three effect types that model these pervasive concerns:
<strong>Reader</strong> for environment access, <strong>State</strong> for threaded computation state, and
<strong>Writer</strong> for accumulated output. Each represents a different kind of
computational context that you'd otherwise pass explicitly through every
function signature.</p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="effect/advanced_effects.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li><code>ReaderPath</code> for dependency injection and environment access</li>
<li><code>WithStatePath</code> for computations with mutable state</li>
<li><code>WriterPath</code> for logging and accumulated output</li>
<li>How to compose these effects with other Path types</li>
<li>Patterns for real-world use: configuration, audit trails, and state machines</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code</p>
</div>
<a class="admonition-anchor-link" href="effect/advanced_effects.html#admonition-see-example-code"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/effect/AdvancedEffectsExample.java">AdvancedEffectsExample.java</a> - ReaderPath, WithStatePath, and WriterPath demonstrations</li>
</ul>
</div>
</div>
<div id="admonition-advanced-feature" class="admonition admonish-warning" role="note" aria-labelledby="admonition-advanced-feature-title">
<div class="admonition-title">
<div id="admonition-advanced-feature-title">
<p>Advanced Feature</p>
</div>
<a class="admonition-anchor-link" href="effect/advanced_effects.html#admonition-advanced-feature"></a>
</div>
<div>
<p>The Reader, State, and Writer Path types are an advanced part of the Effect
Path API. They build on the core Path types covered earlier and require
familiarity with those foundations.</p>
</div>
</div>
<hr />
<h2 id="readerpath-the-environment-you-inherit"><a class="header" href="#readerpath-the-environment-you-inherit">ReaderPath: The Environment You Inherit</a></h2>
<p><code>ReaderPath&lt;R, A&gt;</code> wraps <code>Reader&lt;R, A&gt;</code>, representing a computation that
needs access to an environment of type <code>R</code> to produce a value of type <code>A</code>.</p>
<p>Think of it as <strong>implicit parameter passing</strong>. Instead of threading a
<code>Config</code> or <code>DatabaseConnection</code> through every method signature, you
describe computations that <em>assume</em> the environment exists, then provide
it once at the edge of your system.</p>
<h3 id="why-reader"><a class="header" href="#why-reader">Why Reader?</a></h3>
<p>Consider a typical service method:</p>
<pre><code class="language-java">// Without Reader: environment threaded explicitly
public User getUser(String id, DbConnection db, Config config, Logger log) {
    log.debug("Fetching user: " + id);
    int timeout = config.getTimeout();
    return db.query("SELECT * FROM users WHERE id = ?", id);
}
</code></pre>
<p>Every function in the call chain needs these parameters. The signatures
become cluttered; the actual logic is buried.</p>
<p>With Reader:</p>
<pre><code class="language-java">// With Reader: environment is implicit
public ReaderPath&lt;AppEnv, User&gt; getUser(String id) {
    return ReaderPath.ask()
        .via(env -&gt; {
            env.logger().debug("Fetching user: " + id);
            return ReaderPath.pure(
                env.db().query("SELECT * FROM users WHERE id = ?", id)
            );
        });
}
</code></pre>
<p>The environment is accessed when needed but not passed explicitly. The
method signature shows what it <em>computes</em>, not what it <em>requires</em>.</p>
<h3 id="creation-10"><a class="header" href="#creation-10">Creation</a></h3>
<pre><code class="language-java">// Pure value (ignores environment)
ReaderPath&lt;Config, String&gt; pure = ReaderPath.pure("hello");

// Access the environment
ReaderPath&lt;Config, Config&gt; askAll = ReaderPath.ask();

// Project part of the environment
ReaderPath&lt;Config, String&gt; dbUrl = ReaderPath.asks(Config::databaseUrl);

// From a Reader function
ReaderPath&lt;Config, Integer&gt; timeout = ReaderPath.of(config -&gt; config.timeout());
</code></pre>
<h3 id="core-operations-11"><a class="header" href="#core-operations-11">Core Operations</a></h3>
<pre><code class="language-java">ReaderPath&lt;Config, String&gt; dbUrl = ReaderPath.asks(Config::databaseUrl);

// Transform
ReaderPath&lt;Config, Integer&gt; urlLength = dbUrl.map(String::length);

// Chain dependent computations
ReaderPath&lt;Config, Connection&gt; connection =
    dbUrl.via(url -&gt; ReaderPath.of(config -&gt;
        DriverManager.getConnection(url, config.username(), config.password())
    ));
</code></pre>
<h3 id="running-a-reader"><a class="header" href="#running-a-reader">Running a Reader</a></h3>
<p>Eventually you must provide the environment:</p>
<pre><code class="language-java">Config config = loadConfig();

ReaderPath&lt;Config, User&gt; userPath = getUser("123");
User user = userPath.run(config);  // Provide environment here
</code></pre>
<p>The Reader executes with the given environment. All <code>ask</code> and <code>asks</code> calls
within the computation receive this environment.</p>
<h3 id="local-environment-modification"><a class="header" href="#local-environment-modification">Local Environment Modification</a></h3>
<p>Sometimes a sub-computation needs a modified environment:</p>
<pre><code class="language-java">ReaderPath&lt;Config, Result&gt; withTestMode =
    computation.local(config -&gt; config.withTestMode(true));
</code></pre>
<p>The inner computation sees the modified environment; the outer computation
is unaffected.</p>
<h3 id="when-to-use-readerpath"><a class="header" href="#when-to-use-readerpath">When to Use ReaderPath</a></h3>
<p><code>ReaderPath</code> is right when:</p>
<ul>
<li>Multiple functions need the same "context" (config, connection, logger)</li>
<li>You want dependency injection without frameworks</li>
<li>Computations should be testable with different environments</li>
<li>You're building a DSL where environment is implicit</li>
</ul>
<p><code>ReaderPath</code> is wrong when:</p>
<ul>
<li>The environment changes during computation: use <code>StatePath</code></li>
<li>You need to accumulate results: use <code>WriterPath</code></li>
<li>The environment is only needed in one place: just pass it directly</li>
</ul>
<hr />
<h2 id="statepath-computation-with-memory"><a class="header" href="#statepath-computation-with-memory">StatePath: Computation with Memory</a></h2>
<p><code>StatePath&lt;S, A&gt;</code> wraps <code>State&lt;S, A&gt;</code>, representing a computation that
threads state through a sequence of operations. Each step can read the
current state, produce a value, and update the state for subsequent steps.</p>
<p>Unlike mutable state, <code>StatePath</code> keeps everything pure: the "mutation"
is actually a transformation that produces new state values.</p>
<h3 id="why-state"><a class="header" href="#why-state">Why State?</a></h3>
<p>Consider tracking statistics through a pipeline:</p>
<pre><code class="language-java">// Without State: manual state threading
Stats stats1 = new Stats();
ResultA a = processA(input, stats1);
Stats stats2 = stats1.incrementProcessed();
ResultB b = processB(a, stats2);
Stats stats3 = stats2.incrementProcessed();
// ... and so on
</code></pre>
<p>With State:</p>
<pre><code class="language-java">// With State: automatic threading
StatePath&lt;Stats, ResultC&gt; pipeline =
    StatePath.of(processA(input))
        .via(a -&gt; StatePath.modify(Stats::incrementProcessed)
            .then(() -&gt; StatePath.of(processB(a))))
        .via(b -&gt; StatePath.modify(Stats::incrementProcessed)
            .then(() -&gt; StatePath.of(processC(b))));

Tuple2&lt;Stats, ResultC&gt; result = pipeline.run(Stats.initial());
</code></pre>
<p>The state threads through automatically. Each step can read it, modify it,
or ignore it.</p>
<h3 id="creation-11"><a class="header" href="#creation-11">Creation</a></h3>
<pre><code class="language-java">// Pure value (state unchanged)
StatePath&lt;Counter, String&gt; pure = StatePath.pure("hello");

// Get current state
StatePath&lt;Counter, Counter&gt; current = StatePath.get();

// Set new state (discards old)
StatePath&lt;Counter, Unit&gt; reset = StatePath.set(Counter.zero());

// Modify state
StatePath&lt;Counter, Unit&gt; increment = StatePath.modify(Counter::increment);

// Get and modify in one step
StatePath&lt;Counter, Integer&gt; getAndIncrement =
    StatePath.getAndModify(counter -&gt; {
        int value = counter.value();
        return Tuple.of(counter.increment(), value);
    });
</code></pre>
<h3 id="core-operations-12"><a class="header" href="#core-operations-12">Core Operations</a></h3>
<pre><code class="language-java">StatePath&lt;Counter, Integer&gt; current = StatePath.get().map(Counter::value);

// Chain with state threading
StatePath&lt;Counter, String&gt; counted =
    StatePath.modify(Counter::increment)
        .then(() -&gt; StatePath.get())
        .map(c -&gt; "Count: " + c.value());

// Combine independent state operations
StatePath&lt;Counter, Result&gt; combined =
    operationA.zipWith(operationB, Result::new);
</code></pre>
<h3 id="running-state"><a class="header" href="#running-state">Running State</a></h3>
<pre><code class="language-java">Counter initial = Counter.zero();

StatePath&lt;Counter, String&gt; computation = ...;

// Get both final state and result
Tuple2&lt;Counter, String&gt; both = computation.run(initial);

// Get just the result
String result = computation.eval(initial);

// Get just the final state
Counter finalState = computation.exec(initial);
</code></pre>
<h3 id="when-to-use-statepath"><a class="header" href="#when-to-use-statepath">When to Use StatePath</a></h3>
<p><code>StatePath</code> is right when:</p>
<ul>
<li>You need to accumulate or track information through a computation</li>
<li>Multiple operations must coordinate through shared state</li>
<li>You're implementing state machines or interpreters</li>
<li>You want mutable-like semantics with immutable guarantees</li>
</ul>
<p><code>StatePath</code> is wrong when:</p>
<ul>
<li>State never changes: use <code>ReaderPath</code></li>
<li>You're accumulating a log rather than replacing state: use <code>WriterPath</code></li>
<li>The state is external (database, file): use <code>IOPath</code></li>
</ul>
<hr />
<h2 id="writerpath-accumulating-output"><a class="header" href="#writerpath-accumulating-output">WriterPath: Accumulating Output</a></h2>
<p><code>WriterPath&lt;W, A&gt;</code> wraps <code>Writer&lt;W, A&gt;</code>, representing a computation that
produces both a value and accumulated output. The output (type <code>W</code>) is
combined using a <code>Monoid</code>, allowing automatic aggregation of logs, metrics,
or any combinable data.</p>
<h3 id="why-writer"><a class="header" href="#why-writer">Why Writer?</a></h3>
<p>Consider building an audit trail:</p>
<pre><code class="language-java">// Without Writer: manual log passing
public Tuple2&lt;List&lt;String&gt;, User&gt; createUser(UserInput input, List&lt;String&gt; log) {
    List&lt;String&gt; log2 = append(log, "Validating input");
    Validated validated = validate(input);
    List&lt;String&gt; log3 = append(log2, "Creating user record");
    User user = repository.save(validated);
    List&lt;String&gt; log4 = append(log3, "User created: " + user.id());
    return Tuple.of(log4, user);
}
</code></pre>
<p>With Writer:</p>
<pre><code class="language-java">// With Writer: automatic log accumulation
public WriterPath&lt;List&lt;String&gt;, User&gt; createUser(UserInput input) {
    return WriterPath.tell(List.of("Validating input"))
        .then(() -&gt; WriterPath.pure(validate(input)))
        .via(validated -&gt; WriterPath.tell(List.of("Creating user record"))
            .then(() -&gt; WriterPath.pure(repository.save(validated))))
        .via(user -&gt; WriterPath.tell(List.of("User created: " + user.id()))
            .map(unit -&gt; user));
}
</code></pre>
<p>The log accumulates automatically. No explicit threading required.</p>
<h3 id="creation-12"><a class="header" href="#creation-12">Creation</a></h3>
<pre><code class="language-java">// Pure value (empty log)
WriterPath&lt;List&lt;String&gt;, Integer&gt; pure = WriterPath.pure(42, Monoids.list());

// Write to log (no value)
WriterPath&lt;List&lt;String&gt;, Unit&gt; logged =
    WriterPath.tell(List.of("Something happened"), Monoids.list());

// Create with both value and log
WriterPath&lt;List&lt;String&gt;, User&gt; withLog =
    WriterPath.of(user, List.of("Created user"), Monoids.list());
</code></pre>
<p>The <code>Monoid&lt;W&gt;</code> parameter defines how log entries combine:</p>
<ul>
<li><code>Monoids.list()</code>: concatenate lists</li>
<li><code>Monoids.string()</code>: concatenate strings</li>
<li>Custom monoids for metrics, events, etc.</li>
</ul>
<h3 id="core-operations-13"><a class="header" href="#core-operations-13">Core Operations</a></h3>
<pre><code class="language-java">WriterPath&lt;List&lt;String&gt;, Integer&gt; computation = ...;

// Transform value (log unchanged)
WriterPath&lt;List&lt;String&gt;, String&gt; formatted = computation.map(n -&gt; "Value: " + n);

// Add to log
WriterPath&lt;List&lt;String&gt;, Integer&gt; withExtra =
    computation.tell(List.of("Extra info"));

// Chain with log accumulation
WriterPath&lt;List&lt;String&gt;, Result&gt; pipeline =
    stepOne()
        .via(a -&gt; stepTwo(a))
        .via(b -&gt; stepThree(b));
// Logs from all three steps combine automatically
</code></pre>
<h3 id="running-writer"><a class="header" href="#running-writer">Running Writer</a></h3>
<pre><code class="language-java">WriterPath&lt;List&lt;String&gt;, User&gt; computation = createUser(input);

// Get both log and result
Tuple2&lt;List&lt;String&gt;, User&gt; both = computation.run();

// Get just the result
User user = computation.value();

// Get just the log
List&lt;String&gt; log = computation.written();
</code></pre>
<h3 id="when-to-use-writerpath"><a class="header" href="#when-to-use-writerpath">When to Use WriterPath</a></h3>
<p><code>WriterPath</code> is right when:</p>
<ul>
<li>You're building audit trails or structured logs</li>
<li>Accumulating metrics or statistics</li>
<li>Collecting warnings or diagnostics alongside computation</li>
<li>Any scenario where output should aggregate, not replace</li>
</ul>
<p><code>WriterPath</code> is wrong when:</p>
<ul>
<li>Output should replace previous output: use <code>StatePath</code></li>
<li>You need to read accumulated output mid-computation: use <code>StatePath</code></li>
<li>Output goes to external systems: use <code>IOPath</code></li>
</ul>
<hr />
<h2 id="combining-advanced-effects"><a class="header" href="#combining-advanced-effects">Combining Advanced Effects</a></h2>
<p>These effect types compose with each other and with the core Path types.</p>
<h3 id="reader--either-environment-with-errors"><a class="header" href="#reader--either-environment-with-errors">Reader + Either: Environment with Errors</a></h3>
<pre><code class="language-java">// A computation that needs config and might fail
ReaderPath&lt;Config, EitherPath&lt;Error, User&gt;&gt; getUser(String id) {
    return ReaderPath.asks(Config::database)
        .map(db -&gt; Path.either(db.findUser(id))
            .toEitherPath(() -&gt; new Error.NotFound(id)));
}
</code></pre>
<h3 id="state--writer-state-with-logging"><a class="header" href="#state--writer-state-with-logging">State + Writer: State with Logging</a></h3>
<pre><code class="language-java">// Track state and log what happens
public StatePath&lt;GameState, WriterPath&lt;List&lt;Event&gt;, Move&gt;&gt; makeMove(Position pos) {
    return StatePath.get()
        .via(state -&gt; {
            Move move = calculateMove(state, pos);
            GameState newState = state.apply(move);
            return StatePath.set(newState)
                .map(unit -&gt; WriterPath.of(
                    move,
                    List.of(new Event.MoveMade(pos, move)),
                    Monoids.list()
                ));
        });
}
</code></pre>
<h3 id="patterns-configuration-service"><a class="header" href="#patterns-configuration-service">Patterns: Configuration Service</a></h3>
<pre><code class="language-java">public class ConfigurableService {
    public ReaderPath&lt;ServiceConfig, EitherPath&lt;Error, Result&gt;&gt; process(Request req) {
        return ReaderPath.ask()
            .via(config -&gt; {
                if (!config.isEnabled()) {
                    return ReaderPath.pure(Path.left(new Error.ServiceDisabled()));
                }
                return ReaderPath.pure(
                    Path.tryOf(() -&gt; doProcess(req, config))
                        .toEitherPath(Error.ProcessingFailed::new)
                );
            });
    }
}

// Usage
ServiceConfig config = loadConfig();
EitherPath&lt;Error, Result&gt; result = service.process(request).run(config);
</code></pre>
<h3 id="patterns-audit-trail"><a class="header" href="#patterns-audit-trail">Patterns: Audit Trail</a></h3>
<pre><code class="language-java">public class AuditedRepository {
    public WriterPath&lt;List&lt;AuditEvent&gt;, EitherPath&lt;Error, User&gt;&gt; saveUser(User user) {
        return WriterPath.tell(List.of(new AuditEvent.AttemptSave(user.id())))
            .then(() -&gt; {
                Either&lt;Error, User&gt; result = repository.save(user);
                if (result.isRight()) {
                    return WriterPath.of(
                        Path.right(result.getRight()),
                        List.of(new AuditEvent.SaveSucceeded(user.id())),
                        Monoids.list()
                    );
                } else {
                    return WriterPath.of(
                        Path.left(result.getLeft()),
                        List.of(new AuditEvent.SaveFailed(user.id(), result.getLeft())),
                        Monoids.list()
                    );
                }
            });
    }
}
</code></pre>
<hr />
<h2 id="summary-5"><a class="header" href="#summary-5">Summary</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Effect Type</th><th>Models</th><th>Key Operations</th><th>Use Case</th></tr></thead><tbody>
<tr><td><code>ReaderPath&lt;R, A&gt;</code></td><td>Environment access</td><td><code>ask</code>, <code>asks</code>, <code>local</code></td><td>Config, DI</td></tr>
<tr><td><code>StatePath&lt;S, A&gt;</code></td><td>Threaded state</td><td><code>get</code>, <code>set</code>, <code>modify</code></td><td>Counters, state machines</td></tr>
<tr><td><code>WriterPath&lt;W, A&gt;</code></td><td>Accumulated output</td><td><code>tell</code>, <code>written</code></td><td>Logging, audit trails</td></tr>
</tbody></table>
</div>
<p>These effects handle the "invisible institutions" of software: the
configuration that's everywhere, the state that threads through, the
logs that accumulate. By making them explicit in the type system, you
gain the same composability and predictability that the core Path types
provide for error handling.</p>
<p>The systems remain subtle and pervasive, but no longer tyrannical.</p>
<div id="admonition-see-also" class="admonition admonish-tip" role="note" aria-labelledby="admonition-see-also-title">
<div class="admonition-title">
<div id="admonition-see-also-title">
<p>See Also</p>
</div>
<a class="admonition-anchor-link" href="effect/advanced_effects.html#admonition-see-also"></a>
</div>
<div>
<ul>
<li><a href="effect/../monads/reader_monad.html">Reader Monad</a> - The underlying type for ReaderPath</li>
<li><a href="effect/../monads/state_monad.html">State Monad</a> - The underlying type for StatePath</li>
<li><a href="effect/../monads/writer_monad.html">Writer Monad</a> - The underlying type for WriterPath</li>
<li><a href="effect/../transformers/transformers.html">Monad Transformers</a> - Combining multiple effects</li>
</ul>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="effect/patterns.html">Patterns and Recipes</a>
<strong>Next:</strong> <a href="effect/effect_contexts.html">Effect Contexts</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="effect-contexts-taming-transformer-power"><a class="header" href="#effect-contexts-taming-transformer-power">Effect Contexts: Taming Transformer Power</a></h1>
<blockquote>
<p><em>"Evrything has a shape and so does the nite only you cant see the shape of nite nor you cant think it."</em></p>
<p>— Russell Hoban, <em>Riddley Walker</em></p>
</blockquote>
<p>Hoban's narrator speaks of invisible shapes—structures that exist whether or not we perceive them. Monad transformers are like this. <code>EitherT&lt;IOKind.Witness, ApiError, User&gt;</code> has a definite shape: it's a computation that defers execution, might fail with a typed error, and produces a user when successful. The shape is there. But the syntax makes it hard to see, hard to think.</p>
<p>Effect Contexts give that shape a face you can recognise.</p>
<p>They're a middle layer between the simple Path types you've already learned and the raw transformers lurking beneath. When <code>EitherPath</code> isn't quite enough—when you need error handling <em>and</em> deferred execution, or optional values <em>and</em> IO effects—Effect Contexts provide a user-friendly API that hides the transformer machinery while preserving its power.</p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="effect/effect_contexts.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>Why monad transformers are powerful but syntactically demanding</li>
<li>The three-layer architecture: Paths, Effect Contexts, Raw Transformers</li>
<li>How Effect Contexts wrap transformers with intuitive APIs</li>
<li>The five Effect Context types and when to use each</li>
<li>Escape hatches for when you need the raw transformer</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code</p>
</div>
<a class="admonition-anchor-link" href="effect/effect_contexts.html#admonition-see-example-code"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/effect/EffectContextExample.java">EffectContextExample.java</a> - Demonstrates all five Effect Contexts</li>
</ul>
</div>
</div>
<hr />
<h2 id="the-problem-transformer-syntax"><a class="header" href="#the-problem-transformer-syntax">The Problem: Transformer Syntax</a></h2>
<p>Consider a typical API call. It might fail. It uses IO. You want typed errors. The raw transformer approach looks like this:</p>
<pre><code class="language-java">// Raw transformer: correct but noisy
EitherTMonad&lt;IOKind.Witness, ApiError&gt; monad = new EitherTMonad&lt;&gt;(IOMonad.INSTANCE);

Kind&lt;EitherTKind.Witness&lt;IOKind.Witness, ApiError&gt;, User&gt; userKind =
    EitherT.fromKind(IO_OP.widen(IO.delay(() -&gt; {
        try {
            return Either.right(userService.fetch(userId));
        } catch (Exception e) {
            return Either.left(new ApiError(e.getMessage()));
        }
    })));

Kind&lt;EitherTKind.Witness&lt;IOKind.Witness, ApiError&gt;, Profile&gt; profileKind =
    monad.flatMap(user -&gt;
        EitherT.fromKind(IO_OP.widen(IO.delay(() -&gt; {
            try {
                return Either.right(profileService.fetch(user.profileId()));
            } catch (Exception e) {
                return Either.left(new ApiError(e.getMessage()));
            }
        }))),
        userKind);
</code></pre>
<p>The business logic—fetch a user, then fetch their profile—is drowning in ceremony. You're manually constructing witnesses, wrapping IO, handling <code>Kind</code> types, threading monads. The <em>what</em> disappears into the <em>how</em>.</p>
<hr />
<h2 id="the-solution-effect-contexts"><a class="header" href="#the-solution-effect-contexts">The Solution: Effect Contexts</a></h2>
<p>The same logic with <code>ErrorContext</code>:</p>
<pre><code class="language-java">// Effect Context: same power, readable syntax
ErrorContext&lt;IOKind.Witness, ApiError, Profile&gt; profile = ErrorContext
    .&lt;ApiError, User&gt;io(
        () -&gt; userService.fetch(userId),
        ApiError::fromException)
    .via(user -&gt; ErrorContext.io(
        () -&gt; profileService.fetch(user.profileId()),
        ApiError::fromException));

Either&lt;ApiError, Profile&gt; result = profile.runIO().unsafeRun();
</code></pre>
<p>The transformer is still there—<code>ErrorContext</code> wraps <code>EitherT</code>—but the API speaks in terms you recognise: <code>io()</code> for effectful computation, <code>via()</code> for chaining, <code>runIO()</code> to execute. The shape of the computation emerges from the noise.</p>
<hr />
<h2 id="the-three-layer-architecture"><a class="header" href="#the-three-layer-architecture">The Three-Layer Architecture</a></h2>
<p>Higher-Kinded-J provides three ways to work with combined effects, each serving different needs:</p>
<pre><code>┌─────────────────────────────────────────────────────────────────┐
│  LAYER 1: Effect Path API                                       │
│  ─────────────────────────                                      │
│                                                                 │
│  EitherPath, MaybePath, TryPath, IOPath, ValidationPath...      │
│                                                                 │
│  ✓ Simple, fluent API                                           │
│  ✓ Single effect per path                                       │
│  ✓ Best for: Most application code                              │
│                                                                 │
│  Limitation: Can't combine effects (e.g., IO + typed errors)    │
├─────────────────────────────────────────────────────────────────┤
│  LAYER 2: Effect Contexts                       ← NEW           │
│  ────────────────────────                                       │
│                                                                 │
│  ErrorContext, OptionalContext, JavaOptionalContext,            │
│  ConfigContext, MutableContext                                  │
│                                                                 │
│  ✓ User-friendly transformer wrappers                           │
│  ✓ Hides HKT complexity (no Kind&lt;F, A&gt; in your code)            │
│  ✓ Best for: Combined effects without ceremony                  │
│                                                                 │
│  Limitation: Fixed to common patterns                           │
├─────────────────────────────────────────────────────────────────┤
│  LAYER 3: Raw Transformers                                      │
│  ─────────────────────────                                      │
│                                                                 │
│  EitherT, MaybeT, OptionalT, ReaderT, StateT                    │
│                                                                 │
│  ✓ Full transformer power                                       │
│  ✓ Arbitrary effect stacking                                    │
│  ✓ Best for: Library authors, unusual combinations              │
│                                                                 │
│  Limitation: Requires HKT fluency                               │
└─────────────────────────────────────────────────────────────────┘
</code></pre>
<p>Most code lives in Layer 1. When you need combined effects, Layer 2 handles the common cases cleanly. Layer 3 waits for the rare occasions when nothing else suffices.</p>
<hr />
<h2 id="available-effect-contexts"><a class="header" href="#available-effect-contexts">Available Effect Contexts</a></h2>
<p>Each Effect Context wraps a specific transformer, exposing its capabilities through a streamlined API:</p>
<div class="table-wrapper"><table><thead><tr><th>Context</th><th>Wraps</th><th>Primary Use Case</th></tr></thead><tbody>
<tr><td><a href="effect/effect_contexts_error.html"><code>ErrorContext&lt;F, E, A&gt;</code></a></td><td><code>EitherT&lt;F, E, A&gt;</code></td><td>IO with typed error handling</td></tr>
<tr><td><a href="effect/effect_contexts_optional.html"><code>OptionalContext&lt;F, A&gt;</code></a></td><td><code>MaybeT&lt;F, A&gt;</code></td><td>IO with optional results (using <code>Maybe</code>)</td></tr>
<tr><td><a href="effect/effect_contexts_optional.html"><code>JavaOptionalContext&lt;F, A&gt;</code></a></td><td><code>OptionalT&lt;F, A&gt;</code></td><td>IO with optional results (using <code>java.util.Optional</code>)</td></tr>
<tr><td><a href="effect/effect_contexts_config.html"><code>ConfigContext&lt;F, R, A&gt;</code></a></td><td><code>ReaderT&lt;F, R, A&gt;</code></td><td>Dependency injection in effectful computation</td></tr>
<tr><td><a href="effect/effect_contexts_mutable.html"><code>MutableContext&lt;F, S, A&gt;</code></a></td><td><code>StateT&lt;S, F, A&gt;</code></td><td>Stateful computation with IO</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="choosing-the-right-context"><a class="header" href="#choosing-the-right-context">Choosing the Right Context</a></h2>
<pre><code>                    What's your primary concern?
                              │
           ┌──────────────────┼──────────────────┐
           │                  │                  │
    Typed Errors       Optional Values     Environment/State
           │                  │                  │
           ▼                  │          ┌──────┴──────┐
     ErrorContext             │          │             │
                              │     ConfigContext  MutableContext
                    ┌─────────┴─────────┐
                    │                   │
             Using Maybe?         Using Optional?
                    │                   │
                    ▼                   ▼
            OptionalContext    JavaOptionalContext
</code></pre>
<p><strong>ErrorContext</strong> when you need:</p>
<ul>
<li>Typed errors across IO operations</li>
<li>Exception-catching with custom error types</li>
<li>Error recovery and transformation</li>
</ul>
<p><strong>OptionalContext / JavaOptionalContext</strong> when you need:</p>
<ul>
<li>Optional values from IO operations</li>
<li>Fallback chains for missing data</li>
<li>The choice between them is simply which optional type you prefer</li>
</ul>
<p><strong>ConfigContext</strong> when you need:</p>
<ul>
<li>Dependency injection without frameworks</li>
<li>Environment/configuration threading</li>
<li>Local configuration overrides</li>
</ul>
<p><strong>MutableContext</strong> when you need:</p>
<ul>
<li>State threading through IO operations</li>
<li>Accumulators, counters, or state machines</li>
<li>Both the final value and final state</li>
</ul>
<hr />
<h2 id="common-patterns"><a class="header" href="#common-patterns">Common Patterns</a></h2>
<h3 id="the-error-handling-pipeline"><a class="header" href="#the-error-handling-pipeline">The Error-Handling Pipeline</a></h3>
<pre><code class="language-java">ErrorContext&lt;IOKind.Witness, ApiError, Order&gt; orderPipeline =
    ErrorContext.&lt;ApiError, User&gt;io(
        () -&gt; userService.fetch(userId),
        ApiError::fromException)
    .via(user -&gt; ErrorContext.io(
        () -&gt; cartService.getCart(user.id()),
        ApiError::fromException))
    .via(cart -&gt; ErrorContext.io(
        () -&gt; orderService.createOrder(cart),
        ApiError::fromException))
    .recover(error -&gt; Order.failed(error.message()));
</code></pre>
<h3 id="the-optional-lookup-chain"><a class="header" href="#the-optional-lookup-chain">The Optional Lookup Chain</a></h3>
<pre><code class="language-java">OptionalContext&lt;IOKind.Witness, Config&gt; config =
    OptionalContext.&lt;Config&gt;io(() -&gt; cache.get("config"))
        .orElse(() -&gt; OptionalContext.io(() -&gt; database.loadConfig()))
        .orElse(() -&gt; OptionalContext.some(Config.defaults()));
</code></pre>
<h3 id="dependency-injection"><a class="header" href="#dependency-injection">Dependency Injection</a></h3>
<pre><code class="language-java">ConfigContext&lt;IOKind.Witness, ServiceConfig, Report&gt; report =
    ConfigContext.io(config -&gt;
        reportService.generate(config.reportFormat()));

Report result = report.runWithSync(new ServiceConfig("PDF", 30));
</code></pre>
<h3 id="stateful-computation"><a class="header" href="#stateful-computation">Stateful Computation</a></h3>
<pre><code class="language-java">MutableContext&lt;IOKind.Witness, Counter, String&gt; workflow =
    MutableContext.&lt;Counter&gt;get()
        .map(c -&gt; "Started at: " + c.value())
        .flatMap(msg -&gt; MutableContext.&lt;Counter, Unit&gt;modify(Counter::increment)
            .map(u -&gt; msg));

StateTuple&lt;Counter, String&gt; result = workflow.runWith(new Counter(0)).unsafeRun();
// result.state().value() == 1
// result.value() == "Started at: 0"
</code></pre>
<hr />
<h2 id="escape-hatches"><a class="header" href="#escape-hatches">Escape Hatches</a></h2>
<p>Every Effect Context provides access to its underlying transformer via an escape hatch method. When you need capabilities beyond what the Context API exposes, you can drop to Layer 3:</p>
<pre><code class="language-java">ErrorContext&lt;IOKind.Witness, ApiError, User&gt; ctx = ErrorContext.success(user);

// Escape to raw transformer
EitherT&lt;IOKind.Witness, ApiError, User&gt; transformer = ctx.toEitherT();

// Now you have full transformer capabilities
// ... perform advanced operations ...
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Context</th><th>Escape Hatch Method</th><th>Returns</th></tr></thead><tbody>
<tr><td><code>ErrorContext</code></td><td><code>toEitherT()</code></td><td><code>EitherT&lt;F, E, A&gt;</code></td></tr>
<tr><td><code>OptionalContext</code></td><td><code>toMaybeT()</code></td><td><code>MaybeT&lt;F, A&gt;</code></td></tr>
<tr><td><code>JavaOptionalContext</code></td><td><code>toOptionalT()</code></td><td><code>OptionalT&lt;F, A&gt;</code></td></tr>
<tr><td><code>ConfigContext</code></td><td><code>toReaderT()</code></td><td><code>ReaderT&lt;F, R, A&gt;</code></td></tr>
<tr><td><code>MutableContext</code></td><td><code>toStateT()</code></td><td><code>StateT&lt;S, F, A&gt;</code></td></tr>
</tbody></table>
</div>
<p>Use escape hatches sparingly. They're for genuine edge cases, not everyday operations.</p>
<hr />
<h2 id="summary-6"><a class="header" href="#summary-6">Summary</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Layer</th><th>Types</th><th>Best For</th></tr></thead><tbody>
<tr><td><strong>Layer 1</strong></td><td>Path types (<code>EitherPath</code>, <code>IOPath</code>, etc.)</td><td>Single-effect scenarios</td></tr>
<tr><td><strong>Layer 2</strong></td><td>Effect Contexts</td><td>Combined effects with clean syntax</td></tr>
<tr><td><strong>Layer 3</strong></td><td>Raw transformers (<code>EitherT</code>, <code>StateT</code>, etc.)</td><td>Maximum flexibility</td></tr>
</tbody></table>
</div>
<p>Effect Contexts occupy the middle ground: more power than simple Paths, more clarity than raw transformers. They make the invisible shapes visible, the unthinkable thinkable.</p>
<div id="admonition-see-also" class="admonition admonish-tip" role="note" aria-labelledby="admonition-see-also-title">
<div class="admonition-title">
<div id="admonition-see-also-title">
<p>See Also</p>
</div>
<a class="admonition-anchor-link" href="effect/effect_contexts.html#admonition-see-also"></a>
</div>
<div>
<ul>
<li><a href="effect/../transformers/eithert_transformer.html">EitherT</a> - The transformer behind ErrorContext</li>
<li><a href="effect/../transformers/maybet_transformer.html">MaybeT</a> - The transformer behind OptionalContext</li>
<li><a href="effect/../transformers/readert_transformer.html">ReaderT</a> - The transformer behind ConfigContext</li>
<li><a href="effect/../transformers/statet_transformer.html">StateT</a> - The transformer behind MutableContext</li>
</ul>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="effect/advanced_effects.html">Advanced Effects</a>
<strong>Next:</strong> <a href="effect/effect_contexts_error.html">ErrorContext</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="errorcontext-typed-errors-in-effectful-code"><a class="header" href="#errorcontext-typed-errors-in-effectful-code">ErrorContext: Typed Errors in Effectful Code</a></h1>
<blockquote>
<p><em>"You wont never get the whole thing its too big in the nite of your head ther aint room."</em></p>
<p>— Russell Hoban, <em>Riddley Walker</em></p>
</blockquote>
<p>API calls fail. Database queries timeout. Files go missing. The "whole thing" of what can go wrong in effectful code is indeed too big to hold in your head at once. But you can give those failures <em>names</em>—typed errors that the compiler understands and your code can reason about. <code>ErrorContext</code> captures both the deferred nature of IO and the typed-error semantics of <code>Either</code> in a single, composable abstraction.</p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="effect/effect_contexts_error.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>Creating ErrorContexts that catch exceptions and map them to typed errors</li>
<li>Chaining dependent computations with <code>via()</code> and <code>flatMap()</code></li>
<li>Recovering from errors with <code>recover()</code>, <code>recoverWith()</code>, and <code>orElse()</code></li>
<li>Transforming error types with <code>mapError()</code></li>
<li>Executing contexts with <code>runIO()</code>, <code>runIOOrThrow()</code>, and <code>runIOOrElse()</code></li>
</ul>
</div>
</div>
<hr />
<h2 id="the-problem"><a class="header" href="#the-problem">The Problem</a></h2>
<p>Traditional Java error handling fragments across styles:</p>
<pre><code class="language-java">// Style 1: Checked exceptions
public User fetchUser(String id) throws UserNotFoundException { ... }

// Style 2: Unchecked exceptions
public Order createOrder(Cart cart) { /* might throw RuntimeException */ }

// Style 3: Optional returns
public Optional&lt;Profile&gt; getProfile(User user) { ... }

// Style 4: Custom result types
public Result&lt;ValidationError, Order&gt; validateOrder(OrderRequest req) { ... }
</code></pre>
<p>Composing across these styles requires constant translation. Each boundary demands explicit handling, cluttering your code with conversion logic.</p>
<hr />
<h2 id="the-solution"><a class="header" href="#the-solution">The Solution</a></h2>
<p><code>ErrorContext</code> unifies error handling for IO-based operations. Exceptions become typed errors. Optionality can be converted to errors. All computations compose through the same operations:</p>
<pre><code class="language-java">ErrorContext&lt;IOKind.Witness, OrderError, Order&gt; orderPipeline =
    ErrorContext.&lt;OrderError, User&gt;io(
        () -&gt; userService.fetch(userId),           // May throw
        OrderError::fromException)
    .via(user -&gt; ErrorContext.io(
        () -&gt; orderService.validate(user, request),
        OrderError::fromException))
    .via(validated -&gt; ErrorContext.io(
        () -&gt; orderService.create(validated),
        OrderError::fromException))
    .recover(error -&gt; Order.placeholder(error.message()));
</code></pre>
<p>One unified API. One error type. The compiler tracks what can fail.</p>
<hr />
<h2 id="creating-errorcontexts"><a class="header" href="#creating-errorcontexts">Creating ErrorContexts</a></h2>
<h3 id="from-throwing-computations"><a class="header" href="#from-throwing-computations">From Throwing Computations</a></h3>
<p>The most common factory method catches exceptions and maps them to your error type:</p>
<pre><code class="language-java">ErrorContext&lt;IOKind.Witness, ApiError, User&gt; user = ErrorContext.io(
    () -&gt; httpClient.get("/users/" + id),   // May throw
    ApiError::fromException                   // Throwable → ApiError
);
</code></pre>
<p>The computation is <em>deferred</em>—nothing executes until you call <code>runIO()</code>. Exceptions thrown during execution are caught and converted to the error type.</p>
<h3 id="from-either-returning-computations"><a class="header" href="#from-either-returning-computations">From Either-Returning Computations</a></h3>
<p>When your code already returns <code>Either</code>:</p>
<pre><code class="language-java">ErrorContext&lt;IOKind.Witness, ValidationError, Order&gt; validated = ErrorContext.ioEither(
    () -&gt; validator.validate(request)   // Returns Either&lt;ValidationError, Order&gt;
);
</code></pre>
<h3 id="pure-values"><a class="header" href="#pure-values">Pure Values</a></h3>
<p>For successful or failed values you already have:</p>
<pre><code class="language-java">// Known success
ErrorContext&lt;IOKind.Witness, String, Integer&gt; success = ErrorContext.success(42);

// Known failure
ErrorContext&lt;IOKind.Witness, String, Integer&gt; failure = ErrorContext.failure("Not found");

// From an existing Either
Either&lt;ApiError, User&gt; either = lookupUser(id);
ErrorContext&lt;IOKind.Witness, ApiError, User&gt; ctx = ErrorContext.fromEither(either);
</code></pre>
<hr />
<h2 id="transforming-values"><a class="header" href="#transforming-values">Transforming Values</a></h2>
<h3 id="map-transform-the-success-value"><a class="header" href="#map-transform-the-success-value">map: Transform the Success Value</a></h3>
<p><code>map</code> transforms the value inside a successful context:</p>
<pre><code class="language-java">ErrorContext&lt;IOKind.Witness, String, String&gt; greeting = ErrorContext.success("world");

ErrorContext&lt;IOKind.Witness, String, String&gt; result = greeting.map(s -&gt; "Hello, " + s);
// Success("Hello, world")

ErrorContext&lt;IOKind.Witness, String, String&gt; failed = ErrorContext.failure("oops");
ErrorContext&lt;IOKind.Witness, String, String&gt; stillFailed = failed.map(s -&gt; "Hello, " + s);
// Failure("oops") — map doesn't run on failures
</code></pre>
<p>The function only executes if the context is successful. Failures pass through unchanged.</p>
<hr />
<h2 id="chaining-computations"><a class="header" href="#chaining-computations">Chaining Computations</a></h2>
<h3 id="via-chain-dependent-operations"><a class="header" href="#via-chain-dependent-operations">via: Chain Dependent Operations</a></h3>
<p><code>via</code> is the workhorse for sequencing operations where each step depends on the previous:</p>
<pre><code class="language-java">ErrorContext&lt;IOKind.Witness, DbError, Invoice&gt; invoice =
    ErrorContext.&lt;DbError, Customer&gt;io(
        () -&gt; customerRepo.find(customerId),
        DbError::fromException)
    .via(customer -&gt; ErrorContext.io(
        () -&gt; orderRepo.findByCustomer(customer.id()),
        DbError::fromException))
    .via(orders -&gt; ErrorContext.io(
        () -&gt; invoiceService.generate(orders),
        DbError::fromException));
</code></pre>
<p>Each step receives the previous result. If any step fails, subsequent steps are skipped—the failure propagates to the end.</p>
<h3 id="flatmap-type-preserving-chain"><a class="header" href="#flatmap-type-preserving-chain">flatMap: Type-Preserving Chain</a></h3>
<p><code>flatMap</code> is equivalent to <code>via</code> but with a more explicit type signature:</p>
<pre><code class="language-java">// Using flatMap instead of via
ErrorContext&lt;IOKind.Witness, ApiError, Profile&gt; profile =
    fetchUser(userId)
        .flatMap(user -&gt; fetchProfile(user.profileId()))
        .flatMap(prof -&gt; enrichProfile(prof));
</code></pre>
<p>Choose based on readability. Both short-circuit on failure.</p>
<h3 id="then-sequence-without-using-the-value"><a class="header" href="#then-sequence-without-using-the-value">then: Sequence Without Using the Value</a></h3>
<p>When you need to sequence but don't care about the previous value:</p>
<pre><code class="language-java">ErrorContext&lt;IOKind.Witness, String, Unit&gt; workflow =
    ErrorContext.&lt;String, Unit&gt;success(Unit.INSTANCE)
        .then(() -&gt; logAction("Starting"))
        .then(() -&gt; performAction())
        .then(() -&gt; logAction("Completed"));
</code></pre>
<hr />
<h2 id="recovering-from-errors"><a class="header" href="#recovering-from-errors">Recovering from Errors</a></h2>
<h3 id="recover-provide-a-fallback-value"><a class="header" href="#recover-provide-a-fallback-value">recover: Provide a Fallback Value</a></h3>
<p><code>recover</code> catches errors and produces a fallback value:</p>
<pre><code class="language-java">ErrorContext&lt;IOKind.Witness, String, Config&gt; config =
    ErrorContext.&lt;String, Config&gt;io(
        () -&gt; loadConfigFromServer(),
        Throwable::getMessage)
    .recover(error -&gt; {
        log.warn("Using defaults: {}", error);
        return Config.defaults();
    });
</code></pre>
<p>If the original computation fails, the recovery function runs. If it succeeds, recovery is never invoked.</p>
<h3 id="recoverwith-provide-a-fallback-computation"><a class="header" href="#recoverwith-provide-a-fallback-computation">recoverWith: Provide a Fallback Computation</a></h3>
<p>When recovery itself might fail:</p>
<pre><code class="language-java">ErrorContext&lt;IOKind.Witness, ApiError, Data&gt; data =
    ErrorContext.&lt;ApiError, Data&gt;io(
        () -&gt; primaryService.fetch(),
        ApiError::fromException)
    .recoverWith(error -&gt; ErrorContext.io(
        () -&gt; backupService.fetch(),
        ApiError::fromException));
</code></pre>
<p>The fallback is another <code>ErrorContext</code>. This enables fallback chains that can themselves fail.</p>
<h3 id="orelse-alternative-without-inspecting-error"><a class="header" href="#orelse-alternative-without-inspecting-error">orElse: Alternative Without Inspecting Error</a></h3>
<p>When you don't need the error details:</p>
<pre><code class="language-java">ErrorContext&lt;IOKind.Witness, String, User&gt; user =
    fetchFromCache(userId)
        .orElse(() -&gt; fetchFromDatabase(userId))
        .orElse(() -&gt; ErrorContext.success(User.anonymous()));
</code></pre>
<hr />
<h2 id="transforming-errors"><a class="header" href="#transforming-errors">Transforming Errors</a></h2>
<h3 id="maperror-change-the-error-type"><a class="header" href="#maperror-change-the-error-type">mapError: Change the Error Type</a></h3>
<p><code>mapError</code> transforms the error without affecting success values:</p>
<pre><code class="language-java">ErrorContext&lt;IOKind.Witness, String, User&gt; lowLevel = ErrorContext.failure("connection refused");

ErrorContext&lt;IOKind.Witness, ApiError, User&gt; highLevel =
    lowLevel.mapError(msg -&gt; new ApiError(500, msg));
</code></pre>
<p>This is essential when composing code from different modules that use different error types.</p>
<hr />
<h2 id="execution"><a class="header" href="#execution">Execution</a></h2>
<h3 id="runio-get-an-iopath"><a class="header" href="#runio-get-an-iopath">runIO: Get an IOPath</a></h3>
<p><code>runIO()</code> extracts an <code>IOPath&lt;Either&lt;E, A&gt;&gt;</code> for deferred execution:</p>
<pre><code class="language-java">ErrorContext&lt;IOKind.Witness, ApiError, User&gt; ctx = ...;

// Get the IOPath (nothing runs yet)
IOPath&lt;Either&lt;ApiError, User&gt;&gt; ioPath = ctx.runIO();

// Execute when ready
Either&lt;ApiError, User&gt; result = ioPath.unsafeRun();
</code></pre>
<h3 id="runioorthrow-success-or-exception"><a class="header" href="#runioorthrow-success-or-exception">runIOOrThrow: Success or Exception</a></h3>
<p>For cases where failure should throw:</p>
<pre><code class="language-java">try {
    User user = userContext.runIOOrThrow();
    // Use the user
} catch (RuntimeException e) {
    // Error was wrapped: e.getMessage() contains error.toString()
}
</code></pre>
<h3 id="runioorelse-success-or-default"><a class="header" href="#runioorelse-success-or-default">runIOOrElse: Success or Default</a></h3>
<p>For cases where failure should use a default:</p>
<pre><code class="language-java">User user = userContext.runIOOrElse(User.guest());
</code></pre>
<h3 id="runioorelseget-success-or-computed-default"><a class="header" href="#runioorelseget-success-or-computed-default">runIOOrElseGet: Success or Computed Default</a></h3>
<p>When the default depends on the error:</p>
<pre><code class="language-java">User user = userContext.runIOOrElseGet(error -&gt; {
    log.error("Failed with: {}", error);
    return User.guest();
});
</code></pre>
<hr />
<h2 id="real-world-patterns"><a class="header" href="#real-world-patterns">Real-World Patterns</a></h2>
<h3 id="api-client-with-error-handling"><a class="header" href="#api-client-with-error-handling">API Client with Error Handling</a></h3>
<pre><code class="language-java">public class UserClient {
    public ErrorContext&lt;IOKind.Witness, ApiError, User&gt; fetchUser(String id) {
        return ErrorContext.&lt;ApiError, User&gt;io(
            () -&gt; {
                HttpResponse response = httpClient.get("/users/" + id);
                if (response.status() == 404) {
                    throw new NotFoundException("User not found: " + id);
                }
                return parseUser(response.body());
            },
            ApiError::fromException);
    }

    public ErrorContext&lt;IOKind.Witness, ApiError, Profile&gt; fetchProfile(User user) {
        return ErrorContext.&lt;ApiError, Profile&gt;io(
            () -&gt; {
                HttpResponse response = httpClient.get("/profiles/" + user.profileId());
                return parseProfile(response.body());
            },
            ApiError::fromException);
    }
}

// Usage
ErrorContext&lt;IOKind.Witness, ApiError, Profile&gt; profile =
    client.fetchUser(userId)
        .via(client::fetchProfile)
        .recover(error -&gt; Profile.empty());
</code></pre>
<h3 id="multi-step-transaction"><a class="header" href="#multi-step-transaction">Multi-Step Transaction</a></h3>
<pre><code class="language-java">public ErrorContext&lt;IOKind.Witness, OrderError, Order&gt; processOrder(OrderRequest request) {
    return validateRequest(request)
        .via(this::checkInventory)
        .via(this::reserveItems)
        .via(this::chargePayment)
        .via(this::createOrder)
        .recoverWith(error -&gt; {
            // Compensating action
            return rollbackReservations()
                .then(() -&gt; ErrorContext.failure(error));
        });
}
</code></pre>
<h3 id="layered-error-types"><a class="header" href="#layered-error-types">Layered Error Types</a></h3>
<pre><code class="language-java">// Low-level: database errors
ErrorContext&lt;IOKind.Witness, DbError, User&gt; dbUser =
    ErrorContext.io(() -&gt; db.query("SELECT ..."), DbError::fromSql);

// Mid-level: repository errors
ErrorContext&lt;IOKind.Witness, RepoError, User&gt; repoUser =
    dbUser.mapError(RepoError::fromDbError);

// High-level: API errors
ErrorContext&lt;IOKind.Witness, ApiError, User&gt; apiUser =
    repoUser.mapError(ApiError::fromRepoError);
</code></pre>
<hr />
<h2 id="escape-hatch"><a class="header" href="#escape-hatch">Escape Hatch</a></h2>
<p>When you need the raw transformer:</p>
<pre><code class="language-java">ErrorContext&lt;IOKind.Witness, String, Integer&gt; ctx = ErrorContext.success(42);

EitherT&lt;IOKind.Witness, String, Integer&gt; transformer = ctx.toEitherT();

// Now you have full EitherT capabilities
</code></pre>
<hr />
<h2 id="summary-7"><a class="header" href="#summary-7">Summary</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Purpose</th><th>Short-circuits on error?</th></tr></thead><tbody>
<tr><td><code>io(supplier, errorMapper)</code></td><td>Create from throwing computation</td><td>N/A</td></tr>
<tr><td><code>success(value)</code></td><td>Create successful context</td><td>N/A</td></tr>
<tr><td><code>failure(error)</code></td><td>Create failed context</td><td>N/A</td></tr>
<tr><td><code>map(f)</code></td><td>Transform success value</td><td>Yes</td></tr>
<tr><td><code>via(f)</code></td><td>Chain dependent computation</td><td>Yes</td></tr>
<tr><td><code>recover(f)</code></td><td>Provide fallback value</td><td>No</td></tr>
<tr><td><code>recoverWith(f)</code></td><td>Provide fallback computation</td><td>No</td></tr>
<tr><td><code>mapError(f)</code></td><td>Transform error type</td><td>No</td></tr>
<tr><td><code>runIO()</code></td><td>Extract IOPath for execution</td><td>N/A</td></tr>
</tbody></table>
</div>
<p><code>ErrorContext</code> brings order to effectful error handling. Exceptions become data. Failures propagate predictably. Recovery is explicit. The shapes in the night become visible.</p>
<div id="admonition-see-also" class="admonition admonish-tip" role="note" aria-labelledby="admonition-see-also-title">
<div class="admonition-title">
<div id="admonition-see-also-title">
<p>See Also</p>
</div>
<a class="admonition-anchor-link" href="effect/effect_contexts_error.html#admonition-see-also"></a>
</div>
<div>
<ul>
<li><a href="effect/../transformers/eithert_transformer.html">EitherT Transformer</a> - The underlying transformer</li>
<li><a href="effect/../monads/either_monad.html">Either Monad</a> - The Either type</li>
<li><a href="effect/../functional/monad_error.html">MonadError</a> - The type class powering recovery</li>
</ul>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="effect/effect_contexts.html">Effect Contexts</a>
<strong>Next:</strong> <a href="effect/effect_contexts_optional.html">Optional Contexts</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="optional-contexts-graceful-absence-in-effects"><a class="header" href="#optional-contexts-graceful-absence-in-effects">Optional Contexts: Graceful Absence in Effects</a></h1>
<blockquote>
<p><em>"Sum tyms theres mor in the emty than the ful."</em></p>
<p>— Russell Hoban, <em>Riddley Walker</em></p>
</blockquote>
<p>Hoban's riddler knew that absence can be as meaningful as presence. A database query that returns nothing isn't always an error—sometimes the record genuinely doesn't exist, and that's valuable information. <code>OptionalContext</code> and <code>JavaOptionalContext</code> model this graceful absence within effectful computations, giving you the compositional power of transformers without forcing non-existence into an error mould.</p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="effect/effect_contexts_optional.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>The difference between <code>OptionalContext</code> (Maybe) and <code>JavaOptionalContext</code> (java.util.Optional)</li>
<li>Creating optional contexts from nullable suppliers and existing values</li>
<li>Chaining computations that may return nothing</li>
<li>Providing fallbacks with <code>orElse()</code> and <code>orElseValue()</code></li>
<li>Converting to <code>ErrorContext</code> when absence becomes an error</li>
</ul>
</div>
</div>
<hr />
<h2 id="two-flavours-of-optionality"><a class="header" href="#two-flavours-of-optionality">Two Flavours of Optionality</a></h2>
<p>Higher-Kinded-J provides two optional context types:</p>
<div class="table-wrapper"><table><thead><tr><th>Context</th><th>Wraps</th><th>Uses</th></tr></thead><tbody>
<tr><td><code>OptionalContext&lt;F, A&gt;</code></td><td><code>MaybeT&lt;F, A&gt;</code></td><td>Library's <code>Maybe&lt;A&gt;</code> type</td></tr>
<tr><td><code>JavaOptionalContext&lt;F, A&gt;</code></td><td><code>OptionalT&lt;F, A&gt;</code></td><td>Java's <code>java.util.Optional&lt;A&gt;</code></td></tr>
</tbody></table>
</div>
<p>They're functionally equivalent. Choose based on what your codebase already uses:</p>
<ul>
<li>If you're working with code that uses <code>Optional</code>, use <code>JavaOptionalContext</code></li>
<li>If you're using Higher-Kinded-J's <code>Maybe</code> throughout, use <code>OptionalContext</code></li>
<li>If starting fresh, either works—<code>Maybe</code> is slightly more idiomatic for FP patterns</li>
</ul>
<hr />
<h2 id="the-problem-1"><a class="header" href="#the-problem-1">The Problem</a></h2>
<p>Consider a lookup chain:</p>
<pre><code class="language-java">// Each might return null or Optional.empty()
User user = cache.get(userId);
if (user == null) {
    user = database.find(userId);
}
if (user == null) {
    user = legacySystem.lookup(userId);
}
if (user == null) {
    throw new UserNotFoundException(userId);
}
</code></pre>
<p>Four null checks. Three nested lookups. The actual logic—try cache, then database, then legacy—is obscured by defensive programming.</p>
<hr />
<h2 id="the-solution-1"><a class="header" href="#the-solution-1">The Solution</a></h2>
<p>With <code>OptionalContext</code>:</p>
<pre><code class="language-java">OptionalContext&lt;IOKind.Witness, User&gt; user =
    OptionalContext.&lt;User&gt;io(() -&gt; cache.get(userId))
        .orElse(() -&gt; OptionalContext.io(() -&gt; database.find(userId)))
        .orElse(() -&gt; OptionalContext.io(() -&gt; legacySystem.lookup(userId)));

// Convert to ErrorContext when absence is actually an error
ErrorContext&lt;IOKind.Witness, UserError, User&gt; required =
    user.toErrorContext(new UserError("User not found: " + userId));
</code></pre>
<p>The lookup chain reads top-to-bottom. Fallbacks are explicit. The point where absence becomes an error is clear.</p>
<hr />
<h2 id="creating-optionalcontexts"><a class="header" href="#creating-optionalcontexts">Creating OptionalContexts</a></h2>
<h3 id="from-nullable-suppliers"><a class="header" href="#from-nullable-suppliers">From Nullable Suppliers</a></h3>
<p>The <code>io()</code> factory handles null gracefully—null becomes empty:</p>
<pre><code class="language-java">// If findById returns null, the context is empty
OptionalContext&lt;IOKind.Witness, User&gt; user =
    OptionalContext.io(() -&gt; repository.findById(userId));

// Same pattern with JavaOptionalContext
JavaOptionalContext&lt;IOKind.Witness, User&gt; user =
    JavaOptionalContext.io(() -&gt; repository.findById(userId));
</code></pre>
<h3 id="from-maybeoptional-returning-computations"><a class="header" href="#from-maybeoptional-returning-computations">From Maybe/Optional-Returning Computations</a></h3>
<p>When your code already returns the optional type:</p>
<pre><code class="language-java">// Maybe-returning supplier
OptionalContext&lt;IOKind.Witness, Config&gt; config =
    OptionalContext.ioMaybe(() -&gt; configLoader.load("app.properties"));

// Optional-returning supplier
JavaOptionalContext&lt;IOKind.Witness, Config&gt; config =
    JavaOptionalContext.ioOptional(() -&gt; configLoader.load("app.properties"));
</code></pre>
<h3 id="pure-values-1"><a class="header" href="#pure-values-1">Pure Values</a></h3>
<p>For known values:</p>
<pre><code class="language-java">// Present value
OptionalContext&lt;IOKind.Witness, Integer&gt; some = OptionalContext.some(42);
JavaOptionalContext&lt;IOKind.Witness, Integer&gt; present = JavaOptionalContext.some(42);

// Empty
OptionalContext&lt;IOKind.Witness, Integer&gt; none = OptionalContext.none();
JavaOptionalContext&lt;IOKind.Witness, Integer&gt; absent = JavaOptionalContext.none();

// From existing Maybe/Optional
Maybe&lt;User&gt; maybe = Maybe.just(user);
OptionalContext&lt;IOKind.Witness, User&gt; fromMaybe = OptionalContext.fromMaybe(maybe);

Optional&lt;User&gt; optional = Optional.of(user);
JavaOptionalContext&lt;IOKind.Witness, User&gt; fromOpt = JavaOptionalContext.fromOptional(optional);
</code></pre>
<hr />
<h2 id="transforming-values-1"><a class="header" href="#transforming-values-1">Transforming Values</a></h2>
<h3 id="map-transform-present-values"><a class="header" href="#map-transform-present-values">map: Transform Present Values</a></h3>
<pre><code class="language-java">OptionalContext&lt;IOKind.Witness, String&gt; name = OptionalContext.some("Alice");

OptionalContext&lt;IOKind.Witness, String&gt; upper = name.map(String::toUpperCase);
// → some("ALICE")

OptionalContext&lt;IOKind.Witness, String&gt; empty = OptionalContext.none();
OptionalContext&lt;IOKind.Witness, String&gt; stillEmpty = empty.map(String::toUpperCase);
// → none (map doesn't run on empty)
</code></pre>
<hr />
<h2 id="chaining-computations-1"><a class="header" href="#chaining-computations-1">Chaining Computations</a></h2>
<h3 id="via-chain-dependent-lookups"><a class="header" href="#via-chain-dependent-lookups">via: Chain Dependent Lookups</a></h3>
<pre><code class="language-java">OptionalContext&lt;IOKind.Witness, Address&gt; address =
    OptionalContext.&lt;User&gt;io(() -&gt; userRepo.findById(userId))
        .via(user -&gt; OptionalContext.io(() -&gt; addressRepo.findByUserId(user.id())));
</code></pre>
<p>If the user isn't found, the address lookup never runs. If the user exists but has no address, the result is empty. Both cases produce the same <code>none()</code> outcome.</p>
<h3 id="flatmap-type-preserving-chain-1"><a class="header" href="#flatmap-type-preserving-chain-1">flatMap: Type-Preserving Chain</a></h3>
<pre><code class="language-java">OptionalContext&lt;IOKind.Witness, Profile&gt; profile =
    lookupUser(userId)
        .flatMap(user -&gt; lookupProfile(user.profileId()))
        .flatMap(profile -&gt; enrichProfile(profile));
</code></pre>
<h3 id="then-sequence-ignoring-values"><a class="header" href="#then-sequence-ignoring-values">then: Sequence Ignoring Values</a></h3>
<pre><code class="language-java">OptionalContext&lt;IOKind.Witness, String&gt; result =
    validateExists()
        .then(() -&gt; fetchData())
        .then(() -&gt; processResult());
</code></pre>
<hr />
<h2 id="providing-fallbacks"><a class="header" href="#providing-fallbacks">Providing Fallbacks</a></h2>
<h3 id="orelse-fallback-to-another-context"><a class="header" href="#orelse-fallback-to-another-context">orElse: Fallback to Another Context</a></h3>
<p>The primary pattern for lookup chains:</p>
<pre><code class="language-java">OptionalContext&lt;IOKind.Witness, Config&gt; config =
    OptionalContext.&lt;Config&gt;io(() -&gt; loadFromEnvironment())
        .orElse(() -&gt; OptionalContext.io(() -&gt; loadFromFile()))
        .orElse(() -&gt; OptionalContext.io(() -&gt; loadFromDefaults()))
        .orElse(() -&gt; OptionalContext.some(Config.hardcodedDefaults()));
</code></pre>
<p>Each fallback runs only if all previous attempts returned empty.</p>
<h3 id="orelsevalue-fallback-to-a-direct-value"><a class="header" href="#orelsevalue-fallback-to-a-direct-value">orElseValue: Fallback to a Direct Value</a></h3>
<p>When the fallback is known:</p>
<pre><code class="language-java">OptionalContext&lt;IOKind.Witness, Integer&gt; count =
    OptionalContext.&lt;Integer&gt;io(() -&gt; cache.getCount())
        .orElseValue(0);  // Default to zero if not cached
</code></pre>
<h3 id="recover-transform-absence"><a class="header" href="#recover-transform-absence">recover: Transform Absence</a></h3>
<p>When you need to compute the fallback:</p>
<pre><code class="language-java">OptionalContext&lt;IOKind.Witness, Config&gt; config =
    loadConfig()
        .recover(unit -&gt; {
            log.info("No config found, using defaults");
            return Config.defaults();
        });
</code></pre>
<p>The <code>unit</code> parameter is always <code>Unit.INSTANCE</code>—it's the "error" type for optionality, representing the absence of information about <em>why</em> the value is missing.</p>
<h3 id="recoverwith-fallback-to-another-computation"><a class="header" href="#recoverwith-fallback-to-another-computation">recoverWith: Fallback to Another Computation</a></h3>
<pre><code class="language-java">OptionalContext&lt;IOKind.Witness, Data&gt; data =
    fetchFromPrimary()
        .recoverWith(unit -&gt; fetchFromBackup());
</code></pre>
<hr />
<h2 id="converting-to-errorcontext"><a class="header" href="#converting-to-errorcontext">Converting to ErrorContext</a></h2>
<p>Often, absence at some point becomes an error. The boundary is explicit:</p>
<pre><code class="language-java">OptionalContext&lt;IOKind.Witness, User&gt; optionalUser =
    OptionalContext.&lt;User&gt;io(() -&gt; userRepo.findById(userId));

// Absence → Typed Error
ErrorContext&lt;IOKind.Witness, UserNotFound, User&gt; requiredUser =
    optionalUser.toErrorContext(new UserNotFound(userId));

// Now we can use ErrorContext operations
Either&lt;UserNotFound, User&gt; result = requiredUser.runIO().unsafeRun();
</code></pre>
<p>This runs the underlying computation and converts the result. For deferred conversion, use the escape hatch to the raw transformer.</p>
<hr />
<h2 id="converting-between-optional-types"><a class="header" href="#converting-between-optional-types">Converting Between Optional Types</a></h2>
<p><code>JavaOptionalContext</code> can convert to <code>OptionalContext</code>:</p>
<pre><code class="language-java">JavaOptionalContext&lt;IOKind.Witness, User&gt; javaOptional =
    JavaOptionalContext.io(() -&gt; repo.find(id));

OptionalContext&lt;IOKind.Witness, User&gt; maybeContext =
    javaOptional.toOptionalContext();
</code></pre>
<hr />
<h2 id="execution-1"><a class="header" href="#execution-1">Execution</a></h2>
<h3 id="runio-get-an-iopath-1"><a class="header" href="#runio-get-an-iopath-1">runIO: Get an IOPath</a></h3>
<pre><code class="language-java">// For OptionalContext
OptionalContext&lt;IOKind.Witness, User&gt; optionalCtx = OptionalContext.some(user);
IOPath&lt;Maybe&lt;User&gt;&gt; maybeIO = optionalCtx.runIO();

// For JavaOptionalContext
JavaOptionalContext&lt;IOKind.Witness, User&gt; javaCtx = JavaOptionalContext.some(user);
IOPath&lt;Optional&lt;User&gt;&gt; optionalIO = javaCtx.runIO();

// Execute
Maybe&lt;User&gt; maybeResult = maybeIO.unsafeRun();
Optional&lt;User&gt; optionalResult = optionalIO.unsafeRun();
</code></pre>
<h3 id="runioorelse-value-or-default"><a class="header" href="#runioorelse-value-or-default">runIOOrElse: Value or Default</a></h3>
<pre><code class="language-java">User user = userContext.runIOOrElse(User.guest());
</code></pre>
<h3 id="runioorthrow-value-or-exception"><a class="header" href="#runioorthrow-value-or-exception">runIOOrThrow: Value or Exception</a></h3>
<pre><code class="language-java">User user = userContext.runIOOrThrow();  // Throws NoSuchElementException if empty
</code></pre>
<hr />
<h2 id="real-world-patterns-1"><a class="header" href="#real-world-patterns-1">Real-World Patterns</a></h2>
<h3 id="cache-through-pattern"><a class="header" href="#cache-through-pattern">Cache-Through Pattern</a></h3>
<pre><code class="language-java">public OptionalContext&lt;IOKind.Witness, Product&gt; getProduct(String id) {
    return OptionalContext.&lt;Product&gt;io(() -&gt; cache.get(id))
        .orElse(() -&gt; {
            Product product = database.find(id);
            if (product != null) {
                cache.put(id, product);  // Populate cache
            }
            return product == null
                ? OptionalContext.none()
                : OptionalContext.some(product);
        });
}
</code></pre>
<h3 id="configuration-layering"><a class="header" href="#configuration-layering">Configuration Layering</a></h3>
<pre><code class="language-java">public OptionalContext&lt;IOKind.Witness, String&gt; getSetting(String key) {
    return OptionalContext.&lt;String&gt;io(() -&gt; System.getenv(key))          // Environment first
        .orElse(() -&gt; OptionalContext.io(() -&gt; System.getProperty(key))) // System property
        .orElse(() -&gt; OptionalContext.io(() -&gt; configFile.get(key)))     // Config file
        .orElse(() -&gt; OptionalContext.io(() -&gt; defaults.get(key)));      // Defaults last
}
</code></pre>
<h3 id="validation-with-optional-fields"><a class="header" href="#validation-with-optional-fields">Validation with Optional Fields</a></h3>
<pre><code class="language-java">record UserInput(String name, String email, String phone) {}

public OptionalContext&lt;IOKind.Witness, String&gt; getContactMethod(UserInput input) {
    return OptionalContext.&lt;String&gt;io(() -&gt; nullIfBlank(input.email()))
        .orElse(() -&gt; OptionalContext.io(() -&gt; nullIfBlank(input.phone())));
    // Returns the first available contact method
}

private String nullIfBlank(String s) {
    return s == null || s.isBlank() ? null : s;
}
</code></pre>
<h3 id="graceful-degradation"><a class="header" href="#graceful-degradation">Graceful Degradation</a></h3>
<pre><code class="language-java">public OptionalContext&lt;IOKind.Witness, DashboardData&gt; loadDashboard(String userId) {
    return OptionalContext.&lt;DashboardData&gt;io(() -&gt; fullDashboardService.load(userId))
        .orElse(() -&gt; OptionalContext.io(() -&gt; simplifiedDashboard(userId)))
        .orElse(() -&gt; OptionalContext.some(DashboardData.empty()));
}
</code></pre>
<hr />
<h2 id="escape-hatch-1"><a class="header" href="#escape-hatch-1">Escape Hatch</a></h2>
<p>When you need the raw transformer:</p>
<pre><code class="language-java">OptionalContext&lt;IOKind.Witness, User&gt; ctx = OptionalContext.some(user);
MaybeT&lt;IOKind.Witness, User&gt; transformer = ctx.toMaybeT();

JavaOptionalContext&lt;IOKind.Witness, User&gt; jCtx = JavaOptionalContext.some(user);
OptionalT&lt;IOKind.Witness, User&gt; transformer = jCtx.toOptionalT();
</code></pre>
<hr />
<h2 id="summary-8"><a class="header" href="#summary-8">Summary</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Purpose</th></tr></thead><tbody>
<tr><td><code>io(supplier)</code></td><td>Create from nullable supplier</td></tr>
<tr><td><code>ioMaybe(supplier)</code> / <code>ioOptional(supplier)</code></td><td>Create from Maybe/Optional supplier</td></tr>
<tr><td><code>some(value)</code></td><td>Create present context</td></tr>
<tr><td><code>none()</code></td><td>Create empty context</td></tr>
<tr><td><code>map(f)</code></td><td>Transform present value</td></tr>
<tr><td><code>via(f)</code> / <code>flatMap(f)</code></td><td>Chain dependent computation</td></tr>
<tr><td><code>orElse(supplier)</code></td><td>Provide fallback context</td></tr>
<tr><td><code>orElseValue(value)</code></td><td>Provide fallback value</td></tr>
<tr><td><code>toErrorContext(error)</code></td><td>Convert absence to typed error</td></tr>
<tr><td><code>runIO()</code></td><td>Extract IOPath for execution</td></tr>
</tbody></table>
</div>
<p>Optional contexts embrace the wisdom that emptiness can be meaningful. Not every missing value is a bug. Sometimes there's more in the empty than the full.</p>
<div id="admonition-see-also" class="admonition admonish-tip" role="note" aria-labelledby="admonition-see-also-title">
<div class="admonition-title">
<div id="admonition-see-also-title">
<p>See Also</p>
</div>
<a class="admonition-anchor-link" href="effect/effect_contexts_optional.html#admonition-see-also"></a>
</div>
<div>
<ul>
<li><a href="effect/../transformers/maybet_transformer.html">MaybeT Transformer</a> - The transformer behind OptionalContext</li>
<li><a href="effect/../transformers/optionalt_transformer.html">OptionalT Transformer</a> - The transformer behind JavaOptionalContext</li>
<li><a href="effect/../monads/maybe_monad.html">Maybe Monad</a> - The Maybe type</li>
<li><a href="effect/../monads/optional_monad.html">Optional Monad</a> - Working with java.util.Optional</li>
</ul>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="effect/effect_contexts_error.html">ErrorContext</a>
<strong>Next:</strong> <a href="effect/effect_contexts_config.html">ConfigContext</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="configcontext-dependency-injection-without-the-framework"><a class="header" href="#configcontext-dependency-injection-without-the-framework">ConfigContext: Dependency Injection Without the Framework</a></h1>
<blockquote>
<p><em>"The onlyes power is no power."</em></p>
<p>— Russell Hoban, <em>Riddley Walker</em></p>
</blockquote>
<p>Hoban's aphorism hints at a paradox: sometimes the most powerful abstractions are those that feel like nothing at all. <code>ConfigContext</code> provides dependency injection that doesn't feel like a framework—no annotations, no containers, no reflection. Dependencies flow through your code as naturally as function arguments, but without cluttering every signature.</p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="effect/effect_contexts_config.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>Threading configuration through effectful computations</li>
<li>Accessing the environment with <code>ask()</code> and projecting parts with <code>map()</code></li>
<li>Chaining dependent operations that all read the same config</li>
<li>Locally modifying configuration with <code>local()</code></li>
<li>Adapting contexts to different config types with <code>contramap()</code></li>
</ul>
</div>
</div>
<hr />
<h2 id="the-problem-2"><a class="header" href="#the-problem-2">The Problem</a></h2>
<p>Consider a service that needs configuration:</p>
<pre><code class="language-java">public class ReportService {
    public Report generate(ReportConfig config, UserId userId) {
        User user = userService.fetch(config.userServiceUrl(), config.timeout(), userId);
        List&lt;Order&gt; orders = orderService.fetch(config.orderServiceUrl(), config.timeout(), user);
        return buildReport(config.format(), user, orders);
    }
}
</code></pre>
<p>The <code>config</code> parameter appears everywhere. Every method in the call chain needs it, even if it only uses one field. Signatures become cluttered. Testing requires constructing complete config objects even when you only care about one aspect.</p>
<p>Dependency injection frameworks solve this with containers and annotations—but those come with their own complexity: lifecycle management, circular dependency detection, runtime magic.</p>
<hr />
<h2 id="the-solution-2"><a class="header" href="#the-solution-2">The Solution</a></h2>
<p><code>ConfigContext</code> threads configuration implicitly:</p>
<pre><code class="language-java">public ConfigContext&lt;IOKind.Witness, ReportConfig, Report&gt; generate(UserId userId) {
    return ConfigContext.&lt;ReportConfig&gt;ask()
        .via(config -&gt; fetchUser(userId))       // Config available inside
        .via(user -&gt; fetchOrders(user))         // Config still available
        .via(orders -&gt; buildReport(orders));    // And here
}

// Execute by providing config once at the edge
Report report = generate(userId).runWithSync(config);
</code></pre>
<p>Configuration is declared once. Every computation in the chain can access it. No parameters threaded through signatures.</p>
<hr />
<h2 id="creating-configcontexts"><a class="header" href="#creating-configcontexts">Creating ConfigContexts</a></h2>
<h3 id="ask-access-the-entire-configuration"><a class="header" href="#ask-access-the-entire-configuration">ask: Access the Entire Configuration</a></h3>
<p><code>ask()</code> yields the configuration itself:</p>
<pre><code class="language-java">ConfigContext&lt;IOKind.Witness, AppConfig, AppConfig&gt; config = ConfigContext.ask();

// Then project what you need
ConfigContext&lt;IOKind.Witness, AppConfig, String&gt; apiUrl =
    ConfigContext.&lt;AppConfig&gt;ask()
        .map(AppConfig::apiUrl);
</code></pre>
<h3 id="io-compute-using-configuration"><a class="header" href="#io-compute-using-configuration">io: Compute Using Configuration</a></h3>
<p>When your computation depends on config:</p>
<pre><code class="language-java">ConfigContext&lt;IOKind.Witness, DbConfig, Connection&gt; connection =
    ConfigContext.io(config -&gt; DriverManager.getConnection(
        config.url(),
        config.username(),
        config.password()
    ));
</code></pre>
<p>The function receives the configuration and returns a value. Execution is immediate when the context runs.</p>
<h3 id="iodeferred-defer-computation"><a class="header" href="#iodeferred-defer-computation">ioDeferred: Defer Computation</a></h3>
<p>When you want the IO aspect to be truly deferred:</p>
<pre><code class="language-java">ConfigContext&lt;IOKind.Witness, ApiConfig, Response&gt; response =
    ConfigContext.ioDeferred(config -&gt; () -&gt; {
        // This supplier is invoked later when runWith() is called
        return httpClient.get(config.endpoint());
    });
</code></pre>
<h3 id="pure-ignore-configuration"><a class="header" href="#pure-ignore-configuration">pure: Ignore Configuration</a></h3>
<p>For values that don't need the config:</p>
<pre><code class="language-java">ConfigContext&lt;IOKind.Witness, AnyConfig, Integer&gt; fortyTwo =
    ConfigContext.pure(42);
</code></pre>
<hr />
<h2 id="transforming-values-2"><a class="header" href="#transforming-values-2">Transforming Values</a></h2>
<h3 id="map-transform-the-result"><a class="header" href="#map-transform-the-result">map: Transform the Result</a></h3>
<pre><code class="language-java">ConfigContext&lt;IOKind.Witness, ServiceConfig, String&gt; endpoint =
    ConfigContext.&lt;ServiceConfig&gt;ask()
        .map(ServiceConfig::baseUrl);

ConfigContext&lt;IOKind.Witness, ServiceConfig, URI&gt; uri =
    endpoint.map(URI::create);
</code></pre>
<hr />
<h2 id="chaining-computations-2"><a class="header" href="#chaining-computations-2">Chaining Computations</a></h2>
<h3 id="via-chain-dependent-operations-1"><a class="header" href="#via-chain-dependent-operations-1">via: Chain Dependent Operations</a></h3>
<pre><code class="language-java">record AppConfig(String userServiceUrl, String orderServiceUrl, Duration timeout) {}

ConfigContext&lt;IOKind.Witness, AppConfig, Invoice&gt; invoice =
    ConfigContext.&lt;AppConfig&gt;ask()
        .via(config -&gt; fetchUser(config.userServiceUrl()))
        .via(user -&gt; fetchOrders(user.id()))
        .via(orders -&gt; createInvoice(orders));

private ConfigContext&lt;IOKind.Witness, AppConfig, User&gt; fetchUser(String url) {
    return ConfigContext.io(config -&gt; userClient.fetch(url, config.timeout()));
}

private ConfigContext&lt;IOKind.Witness, AppConfig, List&lt;Order&gt;&gt; fetchOrders(UserId id) {
    return ConfigContext.io(config -&gt; orderClient.fetch(config.orderServiceUrl(), id));
}
</code></pre>
<p>Each step has access to the same configuration. The config flows through without explicit passing.</p>
<h3 id="flatmap-type-preserving-chain-2"><a class="header" href="#flatmap-type-preserving-chain-2">flatMap: Type-Preserving Chain</a></h3>
<pre><code class="language-java">ConfigContext&lt;IOKind.Witness, AppConfig, Report&gt; report =
    getUser()
        .flatMap(user -&gt; getOrders(user))
        .flatMap(orders -&gt; generateReport(orders));
</code></pre>
<h3 id="then-sequence-ignoring-values-1"><a class="header" href="#then-sequence-ignoring-values-1">then: Sequence Ignoring Values</a></h3>
<pre><code class="language-java">ConfigContext&lt;IOKind.Witness, Config, String&gt; workflow =
    logStart()
        .then(() -&gt; doWork())
        .then(() -&gt; logComplete())
        .then(() -&gt; ConfigContext.pure("done"));
</code></pre>
<hr />
<h2 id="modifying-configuration-locally"><a class="header" href="#modifying-configuration-locally">Modifying Configuration Locally</a></h2>
<h3 id="local-temporary-config-override"><a class="header" href="#local-temporary-config-override">local: Temporary Config Override</a></h3>
<p>Sometimes a sub-computation needs modified settings:</p>
<pre><code class="language-java">ConfigContext&lt;IOKind.Witness, ApiConfig, Data&gt; withLongerTimeout =
    fetchData()
        .local(config -&gt; config.withTimeout(Duration.ofMinutes(5)));
</code></pre>
<p>The modified config applies only to this computation. Other computations in the same chain see the original.</p>
<h3 id="pattern-feature-flags"><a class="header" href="#pattern-feature-flags">Pattern: Feature Flags</a></h3>
<pre><code class="language-java">record AppConfig(boolean debugMode, int maxRetries) {}

ConfigContext&lt;IOKind.Witness, AppConfig, Result&gt; withDebugMode =
    processData()
        .local(config -&gt; new AppConfig(true, config.maxRetries()));
</code></pre>
<h3 id="pattern-environment-specific-settings"><a class="header" href="#pattern-environment-specific-settings">Pattern: Environment-Specific Settings</a></h3>
<pre><code class="language-java">ConfigContext&lt;IOKind.Witness, ServiceConfig, Response&gt; callService =
    ConfigContext.io(config -&gt; httpClient.call(config.endpoint()));

// In tests, use a test environment
ConfigContext&lt;IOKind.Witness, ServiceConfig, Response&gt; testCall =
    callService.local(config -&gt; config.withEndpoint("http://localhost:8080"));
</code></pre>
<hr />
<h2 id="adapting-to-different-config-types"><a class="header" href="#adapting-to-different-config-types">Adapting to Different Config Types</a></h2>
<h3 id="contramap-transform-the-required-config"><a class="header" href="#contramap-transform-the-required-config">contramap: Transform the Required Config</a></h3>
<p>When composing code with different config types:</p>
<pre><code class="language-java">record GlobalConfig(DatabaseConfig db, ApiConfig api) {}

// This needs DatabaseConfig
ConfigContext&lt;IOKind.Witness, DatabaseConfig, Connection&gt; dbConnection = ...;

// Adapt to work with GlobalConfig
ConfigContext&lt;IOKind.Witness, GlobalConfig, Connection&gt; adapted =
    dbConnection.contramap(GlobalConfig::db);
</code></pre>
<p><code>contramap</code> transforms the <em>input</em> (the config), allowing you to compose contexts that expect different configuration types.</p>
<h3 id="pattern-modular-configuration"><a class="header" href="#pattern-modular-configuration">Pattern: Modular Configuration</a></h3>
<pre><code class="language-java">// User module expects UserConfig
ConfigContext&lt;IOKind.Witness, UserConfig, User&gt; fetchUser = ...;

// Order module expects OrderConfig
ConfigContext&lt;IOKind.Witness, OrderConfig, Order&gt; fetchOrder = ...;

// Application config combines both
record AppConfig(UserConfig userConfig, OrderConfig orderConfig) {}

// Adapt both to AppConfig
ConfigContext&lt;IOKind.Witness, AppConfig, User&gt; appUser =
    fetchUser.contramap(AppConfig::userConfig);

ConfigContext&lt;IOKind.Witness, AppConfig, Order&gt; appOrder =
    fetchOrder.contramap(AppConfig::orderConfig);

// Now they can be chained
ConfigContext&lt;IOKind.Witness, AppConfig, Invoice&gt; invoice =
    appUser.via(user -&gt; appOrder.map(order -&gt; createInvoice(user, order)));
</code></pre>
<hr />
<h2 id="execution-2"><a class="header" href="#execution-2">Execution</a></h2>
<h3 id="runwith-get-an-iopath"><a class="header" href="#runwith-get-an-iopath">runWith: Get an IOPath</a></h3>
<pre><code class="language-java">ConfigContext&lt;IOKind.Witness, AppConfig, Report&gt; reportCtx = generateReport();

// Provide config, get IOPath
AppConfig config = loadConfig();
IOPath&lt;Report&gt; ioPath = reportCtx.runWith(config);

// Execute when ready
Report report = ioPath.unsafeRun();
</code></pre>
<h3 id="runwithsync-immediate-execution"><a class="header" href="#runwithsync-immediate-execution">runWithSync: Immediate Execution</a></h3>
<p>For synchronous code:</p>
<pre><code class="language-java">Report report = reportCtx.runWithSync(config);
</code></pre>
<p>This is equivalent to <code>runWith(config).unsafeRun()</code>.</p>
<hr />
<h2 id="real-world-patterns-2"><a class="header" href="#real-world-patterns-2">Real-World Patterns</a></h2>
<h3 id="service-layer-with-configuration"><a class="header" href="#service-layer-with-configuration">Service Layer with Configuration</a></h3>
<pre><code class="language-java">public class OrderService {
    public ConfigContext&lt;IOKind.Witness, ServiceConfig, Order&gt; createOrder(OrderRequest request) {
        return validateRequest(request)
            .via(valid -&gt; checkInventory(valid))
            .via(checked -&gt; processPayment(checked))
            .via(paid -&gt; saveOrder(paid));
    }

    private ConfigContext&lt;IOKind.Witness, ServiceConfig, ValidatedRequest&gt; validateRequest(
            OrderRequest request) {
        return ConfigContext.io(config -&gt;
            validator.validate(request, config.validationRules()));
    }

    private ConfigContext&lt;IOKind.Witness, ServiceConfig, CheckedRequest&gt; checkInventory(
            ValidatedRequest request) {
        return ConfigContext.io(config -&gt;
            inventoryClient.check(config.inventoryServiceUrl(), request.items()));
    }

    // ... similar for other methods
}

// At the application edge
ServiceConfig config = loadConfig();
Order order = orderService.createOrder(request).runWithSync(config);
</code></pre>
<h3 id="database-access"><a class="header" href="#database-access">Database Access</a></h3>
<pre><code class="language-java">record DbConfig(String url, String user, String password, int poolSize) {}

public class UserRepository {
    public ConfigContext&lt;IOKind.Witness, DbConfig, User&gt; findById(UserId id) {
        return ConfigContext.io(config -&gt; {
            try (Connection conn = getConnection(config)) {
                return queryUser(conn, id);
            }
        });
    }

    private Connection getConnection(DbConfig config) {
        return DriverManager.getConnection(config.url(), config.user(), config.password());
    }
}
</code></pre>
<h3 id="testability"><a class="header" href="#testability">Testability</a></h3>
<pre><code class="language-java">// Production config
DbConfig prodConfig = new DbConfig(
    "jdbc:postgresql://prod-db:5432/app",
    "app_user",
    prodPassword,
    20
);

// Test config
DbConfig testConfig = new DbConfig(
    "jdbc:h2:mem:test",
    "sa",
    "",
    1
);

// Same code, different config
User prodUser = repository.findById(id).runWithSync(prodConfig);
User testUser = repository.findById(id).runWithSync(testConfig);
</code></pre>
<h3 id="combining-with-errorcontext"><a class="header" href="#combining-with-errorcontext">Combining with ErrorContext</a></h3>
<pre><code class="language-java">public ConfigContext&lt;IOKind.Witness, ApiConfig, ErrorContext&lt;IOKind.Witness, ApiError, User&gt;&gt;
        fetchUser(UserId id) {
    return ConfigContext.io(config -&gt; {
        return ErrorContext.&lt;ApiError, User&gt;io(
            () -&gt; httpClient.get(config.userEndpoint() + "/" + id),
            ApiError::fromException);
    });
}
</code></pre>
<hr />
<h2 id="escape-hatch-2"><a class="header" href="#escape-hatch-2">Escape Hatch</a></h2>
<p>When you need the raw transformer:</p>
<pre><code class="language-java">ConfigContext&lt;IOKind.Witness, AppConfig, String&gt; ctx = ConfigContext.ask().map(AppConfig::name);

ReaderT&lt;IOKind.Witness, AppConfig, String&gt; transformer = ctx.toReaderT();
</code></pre>
<hr />
<h2 id="summary-9"><a class="header" href="#summary-9">Summary</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Purpose</th></tr></thead><tbody>
<tr><td><code>ask()</code></td><td>Access the entire configuration</td></tr>
<tr><td><code>io(config -&gt; value)</code></td><td>Compute using configuration</td></tr>
<tr><td><code>ioDeferred(config -&gt; supplier)</code></td><td>Deferred computation using config</td></tr>
<tr><td><code>pure(value)</code></td><td>Value ignoring configuration</td></tr>
<tr><td><code>map(f)</code></td><td>Transform the result</td></tr>
<tr><td><code>via(f)</code> / <code>flatMap(f)</code></td><td>Chain dependent computation</td></tr>
<tr><td><code>local(f)</code></td><td>Temporarily modify configuration</td></tr>
<tr><td><code>contramap(f)</code></td><td>Adapt to different config type</td></tr>
<tr><td><code>runWith(config)</code></td><td>Execute with provided configuration</td></tr>
<tr><td><code>runWithSync(config)</code></td><td>Execute synchronously</td></tr>
</tbody></table>
</div>
<p><code>ConfigContext</code> embodies the paradox of invisible power. Dependencies flow through your code without ceremony, without frameworks, without the infrastructure that usually accompanies "enterprise" patterns. The only power is no power—the power that feels like nothing at all.</p>
<div id="admonition-see-also" class="admonition admonish-tip" role="note" aria-labelledby="admonition-see-also-title">
<div class="admonition-title">
<div id="admonition-see-also-title">
<p>See Also</p>
</div>
<a class="admonition-anchor-link" href="effect/effect_contexts_config.html#admonition-see-also"></a>
</div>
<div>
<ul>
<li><a href="effect/../transformers/readert_transformer.html">ReaderT Transformer</a> - The underlying transformer</li>
<li><a href="effect/../monads/reader_monad.html">Reader Monad</a> - The Reader type</li>
<li><a href="effect/advanced_effects.html">Advanced Effects</a> - ReaderPath for simpler Reader usage</li>
</ul>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="effect/effect_contexts_optional.html">Optional Contexts</a>
<strong>Next:</strong> <a href="effect/effect_contexts_mutable.html">MutableContext</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="mutablecontext-stateful-computation-made-pure"><a class="header" href="#mutablecontext-stateful-computation-made-pure">MutableContext: Stateful Computation Made Pure</a></h1>
<blockquote>
<p><em>"Its the same thing every time. The stoan you find aint the stoan you thot youd be looking for."</em></p>
<p>— Russell Hoban, <em>Riddley Walker</em></p>
</blockquote>
<p>State transforms as you work with it. The counter you started with isn't the counter you end with. The accumulator grows. The traversal position shifts. <code>MutableContext</code> lets you write code that <em>feels</em> like mutation—get the current value, update it, continue—while remaining purely functional underneath. The state you find at the end isn't the state you started with, but the transformation is explicit and controlled.</p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="effect/effect_contexts_mutable.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>Threading state through effectful computations</li>
<li>Reading state with <code>get()</code>, writing with <code>put()</code>, updating with <code>modify()</code></li>
<li>Chaining stateful operations that accumulate changes</li>
<li>Running computations to get the value, the state, or both</li>
</ul>
</div>
</div>
<hr />
<h2 id="the-problem-3"><a class="header" href="#the-problem-3">The Problem</a></h2>
<p>Consider tracking statistics through a processing pipeline:</p>
<pre><code class="language-java">// Mutable approach: threading state manually
class Stats {
    int processed = 0;
    int errors = 0;
    long totalBytes = 0;
}

void processFiles(List&lt;Path&gt; files, Stats stats) {
    for (Path file : files) {
        try {
            byte[] content = Files.readAllBytes(file);
            stats.totalBytes += content.length;
            process(content);
            stats.processed++;
        } catch (Exception e) {
            stats.errors++;
        }
    }
}
</code></pre>
<p>The mutation is scattered. Testing requires mutable fixtures. Parallelisation becomes dangerous. And the state threading is implicit—you have to trace through the code to understand how <code>stats</code> changes.</p>
<hr />
<h2 id="the-solution-3"><a class="header" href="#the-solution-3">The Solution</a></h2>
<p><code>MutableContext</code> makes state threading explicit and composable:</p>
<pre><code class="language-java">record Stats(int processed, int errors, long totalBytes) {
    Stats incrementProcessed() { return new Stats(processed + 1, errors, totalBytes); }
    Stats incrementErrors() { return new Stats(processed, errors + 1, totalBytes); }
    Stats addBytes(long bytes) { return new Stats(processed, errors, totalBytes + bytes); }
}

MutableContext&lt;IOKind.Witness, Stats, Unit&gt; processFile(Path file) {
    return MutableContext.io(stats -&gt; {
        try {
            byte[] content = Files.readAllBytes(file);
            return StateTuple.of(
                stats.addBytes(content.length).incrementProcessed(),
                Unit.INSTANCE);
        } catch (Exception e) {
            return StateTuple.of(stats.incrementErrors(), Unit.INSTANCE);
        }
    });
}

// Process all files
MutableContext&lt;IOKind.Witness, Stats, Unit&gt; processAll =
    files.stream()
        .map(this::processFile)
        .reduce(MutableContext.pure(Unit.INSTANCE),
            (a, b) -&gt; a.then(() -&gt; b));

Stats finalStats = processAll.execWith(new Stats(0, 0, 0)).unsafeRun();
</code></pre>
<p>State changes are explicit. Each operation declares how it modifies state. The flow is clear.</p>
<hr />
<h2 id="creating-mutablecontexts"><a class="header" href="#creating-mutablecontexts">Creating MutableContexts</a></h2>
<h3 id="io-state-transformation-with-value"><a class="header" href="#io-state-transformation-with-value">io: State Transformation with Value</a></h3>
<p>The core factory creates a context from a function <code>S -&gt; StateTuple&lt;S, A&gt;</code>:</p>
<pre><code class="language-java">record Counter(int value) {
    Counter increment() { return new Counter(value + 1); }
}

MutableContext&lt;IOKind.Witness, Counter, String&gt; getAndIncrement =
    MutableContext.io(counter -&gt; StateTuple.of(
        counter.increment(),           // New state
        "Was: " + counter.value()      // Produced value
    ));
</code></pre>
<h3 id="get-read-current-state"><a class="header" href="#get-read-current-state">get: Read Current State</a></h3>
<p><code>get()</code> yields the current state as the value without modifying it:</p>
<pre><code class="language-java">MutableContext&lt;IOKind.Witness, Counter, Counter&gt; current = MutableContext.get();

// Often followed by map to extract what you need
MutableContext&lt;IOKind.Witness, Counter, Integer&gt; currentValue =
    MutableContext.&lt;Counter&gt;get()
        .map(Counter::value);
</code></pre>
<h3 id="put-replace-state-entirely"><a class="header" href="#put-replace-state-entirely">put: Replace State Entirely</a></h3>
<p><code>put()</code> sets a new state, returning <code>Unit</code>:</p>
<pre><code class="language-java">MutableContext&lt;IOKind.Witness, Counter, Unit&gt; reset =
    MutableContext.put(new Counter(0));
</code></pre>
<h3 id="modify-update-state"><a class="header" href="#modify-update-state">modify: Update State</a></h3>
<p><code>modify()</code> applies a transformation to the current state:</p>
<pre><code class="language-java">MutableContext&lt;IOKind.Witness, Counter, Unit&gt; increment =
    MutableContext.modify(Counter::increment);

MutableContext&lt;IOKind.Witness, Counter, Unit&gt; addFive =
    MutableContext.modify(c -&gt; new Counter(c.value() + 5));
</code></pre>
<h3 id="pure-value-without-state-change"><a class="header" href="#pure-value-without-state-change">pure: Value Without State Change</a></h3>
<p>For values that don't affect state:</p>
<pre><code class="language-java">MutableContext&lt;IOKind.Witness, AnyState, String&gt; constant =
    MutableContext.pure("Hello");
</code></pre>
<hr />
<h2 id="transforming-values-3"><a class="header" href="#transforming-values-3">Transforming Values</a></h2>
<h3 id="map-transform-the-result-1"><a class="header" href="#map-transform-the-result-1">map: Transform the Result</a></h3>
<pre><code class="language-java">MutableContext&lt;IOKind.Witness, Counter, Integer&gt; count =
    MutableContext.&lt;Counter&gt;get()
        .map(Counter::value);

MutableContext&lt;IOKind.Witness, Counter, String&gt; countStr =
    count.map(n -&gt; "Count: " + n);
</code></pre>
<p><code>map</code> transforms the value; the state flows through unchanged by the transformation itself.</p>
<hr />
<h2 id="chaining-stateful-operations"><a class="header" href="#chaining-stateful-operations">Chaining Stateful Operations</a></h2>
<h3 id="via--flatmap-sequence-state-changes"><a class="header" href="#via--flatmap-sequence-state-changes">via / flatMap: Sequence State Changes</a></h3>
<p>Each operation sees the state left by previous operations:</p>
<pre><code class="language-java">MutableContext&lt;IOKind.Witness, Counter, String&gt; workflow =
    MutableContext.&lt;Counter&gt;get()                              // Read initial state
        .map(c -&gt; "Started at " + c.value())
        .flatMap(msg -&gt; MutableContext.&lt;Counter, Unit&gt;modify(Counter::increment)
            .map(u -&gt; msg))                                     // State now incremented
        .flatMap(msg -&gt; MutableContext.&lt;Counter&gt;get()
            .map(c -&gt; msg + ", now at " + c.value()));          // See updated state
</code></pre>
<h3 id="then-sequence-ignoring-values-2"><a class="header" href="#then-sequence-ignoring-values-2">then: Sequence Ignoring Values</a></h3>
<p>When you only care about the state effects:</p>
<pre><code class="language-java">MutableContext&lt;IOKind.Witness, Counter, Unit&gt; incrementThrice =
    MutableContext.&lt;Counter, Unit&gt;modify(Counter::increment)
        .then(() -&gt; MutableContext.modify(Counter::increment))
        .then(() -&gt; MutableContext.modify(Counter::increment));
</code></pre>
<h3 id="pattern-accumulator"><a class="header" href="#pattern-accumulator">Pattern: Accumulator</a></h3>
<pre><code class="language-java">record Accumulator(List&lt;String&gt; items) {
    Accumulator add(String item) {
        var newItems = new ArrayList&lt;&gt;(items);
        newItems.add(item);
        return new Accumulator(List.copyOf(newItems));
    }
}

MutableContext&lt;IOKind.Witness, Accumulator, Unit&gt; collect(String item) {
    return MutableContext.modify(acc -&gt; acc.add(item));
}

MutableContext&lt;IOKind.Witness, Accumulator, List&lt;String&gt;&gt; collectAll =
    collect("first")
        .then(() -&gt; collect("second"))
        .then(() -&gt; collect("third"))
        .then(() -&gt; MutableContext.&lt;Accumulator&gt;get().map(Accumulator::items));

List&lt;String&gt; items = collectAll.evalWith(new Accumulator(List.of())).unsafeRun();
// ["first", "second", "third"]
</code></pre>
<hr />
<h2 id="execution-3"><a class="header" href="#execution-3">Execution</a></h2>
<p><code>MutableContext</code> offers three ways to run, depending on what you need:</p>
<h3 id="runwith-get-both-state-and-value"><a class="header" href="#runwith-get-both-state-and-value">runWith: Get Both State and Value</a></h3>
<p>Returns <code>IOPath&lt;StateTuple&lt;S, A&gt;&gt;</code>:</p>
<pre><code class="language-java">MutableContext&lt;IOKind.Witness, Counter, String&gt; workflow = ...;

IOPath&lt;StateTuple&lt;Counter, String&gt;&gt; ioPath = workflow.runWith(new Counter(0));
StateTuple&lt;Counter, String&gt; result = ioPath.unsafeRun();

Counter finalState = result.state();   // The final state
String value = result.value();          // The produced value
</code></pre>
<h3 id="evalwith-get-only-the-value"><a class="header" href="#evalwith-get-only-the-value">evalWith: Get Only the Value</a></h3>
<p>When you don't need the final state:</p>
<pre><code class="language-java">IOPath&lt;String&gt; valueIO = workflow.evalWith(new Counter(0));
String value = valueIO.unsafeRun();
</code></pre>
<h3 id="execwith-get-only-the-final-state"><a class="header" href="#execwith-get-only-the-final-state">execWith: Get Only the Final State</a></h3>
<p>When you only care about the accumulated state:</p>
<pre><code class="language-java">IOPath&lt;Counter&gt; stateIO = workflow.execWith(new Counter(0));
Counter finalState = stateIO.unsafeRun();
</code></pre>
<hr />
<h2 id="real-world-patterns-3"><a class="header" href="#real-world-patterns-3">Real-World Patterns</a></h2>
<h3 id="request-id-generation"><a class="header" href="#request-id-generation">Request ID Generation</a></h3>
<pre><code class="language-java">record IdState(long nextId) {
    IdState advance() { return new IdState(nextId + 1); }
}

MutableContext&lt;IOKind.Witness, IdState, Long&gt; generateId() {
    return MutableContext.io(state -&gt; StateTuple.of(
        state.advance(),
        state.nextId()
    ));
}

MutableContext&lt;IOKind.Witness, IdState, Request&gt; tagRequest(Request req) {
    return generateId().map(id -&gt; req.withId(id));
}

// Process multiple requests, each getting unique ID
MutableContext&lt;IOKind.Witness, IdState, List&lt;Request&gt;&gt; tagAll(List&lt;Request&gt; requests) {
    return requests.stream()
        .map(this::tagRequest)
        .reduce(
            MutableContext.pure(List.&lt;Request&gt;of()),
            (accCtx, reqCtx) -&gt; accCtx.flatMap(list -&gt;
                reqCtx.map(req -&gt; {
                    var newList = new java.util.ArrayList&lt;&gt;(list);
                    newList.add(req);
                    return List.copyOf(newList);
                }))
        );
}

List&lt;Request&gt; tagged = tagAll(requests).evalWith(new IdState(1000)).unsafeRun();
</code></pre>
<h3 id="processing-statistics"><a class="header" href="#processing-statistics">Processing Statistics</a></h3>
<pre><code class="language-java">record ProcessingStats(int success, int failure, Duration totalTime) {
    ProcessingStats recordSuccess(Duration d) {
        return new ProcessingStats(success + 1, failure, totalTime.plus(d));
    }
    ProcessingStats recordFailure() {
        return new ProcessingStats(success, failure + 1, totalTime);
    }
}

MutableContext&lt;IOKind.Witness, ProcessingStats, Result&gt; processWithStats(Item item) {
    return MutableContext.io(stats -&gt; {
        Instant start = Instant.now();
        try {
            Result result = processor.process(item);
            Duration elapsed = Duration.between(start, Instant.now());
            return StateTuple.of(stats.recordSuccess(elapsed), result);
        } catch (Exception e) {
            return StateTuple.of(stats.recordFailure(), Result.failed(e));
        }
    });
}
</code></pre>
<h3 id="state-machine"><a class="header" href="#state-machine">State Machine</a></h3>
<pre><code class="language-java">sealed interface GameState {
    record WaitingForPlayers(int count) implements GameState {}
    record InProgress(int round) implements GameState {}
    record Finished(String winner) implements GameState {}
}

MutableContext&lt;IOKind.Witness, GameState, Unit&gt; addPlayer() {
    return MutableContext.modify(state -&gt; switch (state) {
        case GameState.WaitingForPlayers(var count) -&gt;
            new GameState.WaitingForPlayers(count + 1);
        case GameState.InProgress _, GameState.Finished _ -&gt; state;  // No-op
    });
}

MutableContext&lt;IOKind.Witness, GameState, Unit&gt; startGame() {
    return MutableContext.modify(state -&gt; switch (state) {
        case GameState.WaitingForPlayers(var count) when count &gt;= 2 -&gt;
            new GameState.InProgress(1);
        case GameState.WaitingForPlayers _, GameState.InProgress _,
             GameState.Finished _ -&gt; state;
    });
}

MutableContext&lt;IOKind.Witness, GameState, Unit&gt; advanceRound() {
    return MutableContext.modify(state -&gt; switch (state) {
        case GameState.InProgress(var round) when round &lt; 10 -&gt;
            new GameState.InProgress(round + 1);
        case GameState.InProgress(var round) -&gt;
            new GameState.Finished("Player 1");  // End after 10 rounds
        case GameState.WaitingForPlayers _, GameState.Finished _ -&gt; state;
    });
}
</code></pre>
<h3 id="combining-with-other-contexts"><a class="header" href="#combining-with-other-contexts">Combining with Other Contexts</a></h3>
<pre><code class="language-java">// Stateful computation that might fail
MutableContext&lt;IOKind.Witness, Counter, ErrorContext&lt;IOKind.Witness, String, Data&gt;&gt;
    fetchWithCounter() {
    return MutableContext.&lt;Counter, Unit&gt;modify(Counter::increment)
        .map(u -&gt; ErrorContext.&lt;String, Data&gt;io(
            () -&gt; dataService.fetch(),
            Throwable::getMessage));
}
</code></pre>
<hr />
<h2 id="escape-hatch-3"><a class="header" href="#escape-hatch-3">Escape Hatch</a></h2>
<p>When you need the raw transformer:</p>
<pre><code class="language-java">MutableContext&lt;IOKind.Witness, Counter, Integer&gt; ctx =
    MutableContext.&lt;Counter&gt;get().map(Counter::value);

StateT&lt;Counter, IOKind.Witness, Integer&gt; transformer = ctx.toStateT();
</code></pre>
<hr />
<h2 id="summary-10"><a class="header" href="#summary-10">Summary</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Purpose</th><th>Returns</th></tr></thead><tbody>
<tr><td><code>io(s -&gt; StateTuple.of(newS, value))</code></td><td>State transformation with value</td><td><code>MutableContext&lt;F, S, A&gt;</code></td></tr>
<tr><td><code>get()</code></td><td>Read current state as value</td><td><code>MutableContext&lt;F, S, S&gt;</code></td></tr>
<tr><td><code>put(newState)</code></td><td>Replace state entirely</td><td><code>MutableContext&lt;F, S, Unit&gt;</code></td></tr>
<tr><td><code>modify(s -&gt; newS)</code></td><td>Transform current state</td><td><code>MutableContext&lt;F, S, Unit&gt;</code></td></tr>
<tr><td><code>pure(value)</code></td><td>Value without state change</td><td><code>MutableContext&lt;F, S, A&gt;</code></td></tr>
<tr><td><code>map(f)</code></td><td>Transform the value</td><td><code>MutableContext&lt;F, S, B&gt;</code></td></tr>
<tr><td><code>via(f)</code> / <code>flatMap(f)</code></td><td>Chain with state threading</td><td><code>MutableContext&lt;F, S, B&gt;</code></td></tr>
<tr><td><code>runWith(initialState)</code></td><td>Get both state and value</td><td><code>IOPath&lt;StateTuple&lt;S, A&gt;&gt;</code></td></tr>
<tr><td><code>evalWith(initialState)</code></td><td>Get only the value</td><td><code>IOPath&lt;A&gt;</code></td></tr>
<tr><td><code>execWith(initialState)</code></td><td>Get only the final state</td><td><code>IOPath&lt;S&gt;</code></td></tr>
</tbody></table>
</div>
<p><code>MutableContext</code> reconciles the intuition of stateful programming with the safety of pure functions. You write code that reads state, updates state, and produces values—but the state never mutates in place. Each step produces a new state, and the transformation is explicit. The stone you find isn't the stone you started with, but you can trace every change that got you there.</p>
<div id="admonition-see-also" class="admonition admonish-tip" role="note" aria-labelledby="admonition-see-also-title">
<div class="admonition-title">
<div id="admonition-see-also-title">
<p>See Also</p>
</div>
<a class="admonition-anchor-link" href="effect/effect_contexts_mutable.html#admonition-see-also"></a>
</div>
<div>
<ul>
<li><a href="effect/../transformers/statet_transformer.html">StateT Transformer</a> - The underlying transformer</li>
<li><a href="effect/../monads/state_monad.html">State Monad</a> - The State type</li>
<li><a href="effect/advanced_effects.html">Advanced Effects</a> - StatePath for simpler State usage</li>
</ul>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="effect/effect_contexts_config.html">ConfigContext</a>
<strong>Next:</strong> <a href="effect/advanced_topics.html">Advanced Topics</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="advanced-effect-topics"><a class="header" href="#advanced-effect-topics">Advanced Effect Topics</a></h1>
<blockquote>
<p><em>"The Cryptonomicon was like an idea that had been exploded into a thousand
fragments and scattered across the world... You had to pick up all the
pieces and fit them together just right for any of it to make sense."</em></p>
<p>— Neal Stephenson, <em>Cryptonomicon</em></p>
</blockquote>
<p>Stephenson's observation about scattered fragments applies equally to
advanced effect patterns. Stack safety, resource management, parallel
execution, resilience—these are the fragments that, assembled correctly,
transform fragile code into production-ready systems. Each piece makes
sense alone; together they unlock capabilities that would otherwise require
external frameworks or unsafe compromises.</p>
<p>This chapter explores advanced capabilities that build on the core Path types:
stack-safe recursion, DSL building, resource management, parallelism, and
resilience. These aren't academic exercises. They're the patterns that emerge
when simple composition meets real-world demands.</p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="effect/advanced_topics.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li><code>TrampolinePath</code> for stack-safe recursive computations that never overflow</li>
<li><code>FreePath</code> and <code>FreeApPath</code> for building interpretable domain-specific languages</li>
<li>Resource management with <code>bracket</code>, <code>withResource</code>, and <code>guarantee</code></li>
<li>Parallel execution with <code>parZipWith</code>, <code>parSequence</code>, and <code>race</code></li>
<li>Resilience patterns with <code>RetryPolicy</code> and configurable backoff strategies</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code</p>
</div>
<a class="admonition-anchor-link" href="effect/advanced_topics.html#admonition-see-example-code"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/effect/TrampolinePathExample.java">TrampolinePathExample.java</a> - Stack-safe recursion patterns</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/effect/FreePathExample.java">FreePathExample.java</a> - DSL building and interpretation</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/effect/ResourceManagementExample.java">ResourceManagementExample.java</a> - Safe resource handling</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/effect/ParallelExecutionExample.java">ParallelExecutionExample.java</a> - Concurrent operations</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/effect/ResilienceExample.java">ResilienceExample.java</a> - Retry and backoff patterns</li>
</ul>
</div>
</div>
<hr />
<h2 id="stack-safe-recursion-with-trampolinepath"><a class="header" href="#stack-safe-recursion-with-trampolinepath">Stack-Safe Recursion with TrampolinePath</a></h2>
<blockquote>
<p><em>"Randy had learned that the science of secrecy was really about recursion.
Even after you'd encrypted something, you had to worry about whether the
encrypted thing was encrypted safely."</em></p>
<p>— Neal Stephenson, <em>Cryptonomicon</em></p>
</blockquote>
<p>Recursion is elegant—until it overflows your stack. Java's call stack is
finite, typically 512KB to 1MB depending on configuration. A recursive
algorithm that works beautifully for small inputs becomes a <code>StackOverflowError</code>
waiting to happen once the depth exceeds a few thousand calls.</p>
<p><code>TrampolinePath</code> eliminates this limitation through <em>trampolining</em>: converting
recursive calls into a loop that consumes constant stack space regardless of
depth. The recursive structure of your algorithm remains; the stack overflow
doesn't.</p>
<h3 id="the-problem-4"><a class="header" href="#the-problem-4">The Problem</a></h3>
<p>Consider calculating factorial recursively:</p>
<pre><code class="language-java">// This will overflow around n = 10,000
long factorial(long n) {
    if (n &lt;= 1) return 1;
    return n * factorial(n - 1);  // Stack frame per call
}
</code></pre>
<p>Each recursive call adds a stack frame. For large <code>n</code>, you exhaust the stack
before reaching the base case.</p>
<h3 id="the-solution-4"><a class="header" href="#the-solution-4">The Solution</a></h3>
<p><code>TrampolinePath</code> separates describing the recursion from executing it:</p>
<pre><code class="language-java">TrampolinePath&lt;BigInteger&gt; factorial(BigInteger n, BigInteger acc) {
    if (n.compareTo(BigInteger.ONE) &lt;= 0) {
        return TrampolinePath.done(acc);    // Base case: return immediately
    }
    return TrampolinePath.defer(() -&gt;        // Recursive case: describe next step
        factorial(n.subtract(BigInteger.ONE), n.multiply(acc)));
}

// Safe for any input size
BigInteger result = factorial(BigInteger.valueOf(100000), BigInteger.ONE).run();
</code></pre>
<p><code>TrampolinePath.done(value)</code> signals completion. <code>TrampolinePath.defer(supplier)</code>
describes the next step without immediately executing it. When you call <code>run()</code>,
the trampoline bounces through the deferred steps in a loop, never growing the
call stack.</p>
<h3 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h3>
<p>The trampoline maintains a simple loop:</p>
<ol>
<li>Check if the current step is <code>done</code> → return the value</li>
<li>If it's <code>defer</code> → evaluate the supplier to get the next step</li>
<li>Repeat</li>
</ol>
<p>This converts stack depth into iteration count. Memory usage stays constant
regardless of recursion depth.</p>
<h3 id="mutual-recursion-1"><a class="header" href="#mutual-recursion-1">Mutual Recursion</a></h3>
<p>Trampolining handles mutual recursion—functions that call each other—with the
same elegance:</p>
<pre><code class="language-java">TrampolinePath&lt;Boolean&gt; isEven(int n) {
    if (n == 0) return TrampolinePath.done(true);
    return TrampolinePath.defer(() -&gt; isOdd(n - 1));
}

TrampolinePath&lt;Boolean&gt; isOdd(int n) {
    if (n == 0) return TrampolinePath.done(false);
    return TrampolinePath.defer(() -&gt; isEven(n - 1));
}

// Works for any depth
boolean result = isEven(1_000_000).run();  // true
</code></pre>
<p>Without trampolining, <code>isEven(1_000_000)</code> would overflow after about 10,000
calls. With trampolining, it completes in milliseconds.</p>
<h3 id="fibonacci-with-accumulator"><a class="header" href="#fibonacci-with-accumulator">Fibonacci with Accumulator</a></h3>
<p>The classic fibonacci benefits from trampolining when using accumulator style:</p>
<pre><code class="language-java">TrampolinePath&lt;BigInteger&gt; fibonacci(int n) {
    return fibHelper(n, BigInteger.ZERO, BigInteger.ONE);
}

TrampolinePath&lt;BigInteger&gt; fibHelper(int n, BigInteger a, BigInteger b) {
    if (n &lt;= 0) {
        return TrampolinePath.done(a);
    }
    return TrampolinePath.defer(() -&gt; fibHelper(n - 1, b, a.add(b)));
}

// fib(10000) completes without stack overflow
BigInteger result = fibonacci(10000).run();
</code></pre>
<h3 id="when-to-use-trampolinepath"><a class="header" href="#when-to-use-trampolinepath">When to Use TrampolinePath</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Use Case</th><th>TrampolinePath?</th></tr></thead><tbody>
<tr><td>Deeply recursive algorithms (factorial, fibonacci)</td><td>Yes</td></tr>
<tr><td>Tree traversal of arbitrary depth</td><td>Yes</td></tr>
<tr><td>Mutual recursion patterns</td><td>Yes</td></tr>
<tr><td>Interpreter/evaluator implementations</td><td>Yes</td></tr>
<tr><td>Shallow recursion (guaranteed &lt; 1000 depth)</td><td>Optional</td></tr>
<tr><td>Non-recursive code</td><td>No</td></tr>
</tbody></table>
</div>
<h3 id="conversion-and-integration"><a class="header" href="#conversion-and-integration">Conversion and Integration</a></h3>
<p><code>TrampolinePath</code> integrates with other Path types:</p>
<pre><code class="language-java">TrampolinePath&lt;Integer&gt; computation = /* ... */;

// Convert to IOPath for deferred execution
IOPath&lt;Integer&gt; io = computation.toIOPath();

// Convert to LazyPath for memoised evaluation
LazyPath&lt;Integer&gt; lazy = computation.toLazyPath();
</code></pre>
<hr />
<h2 id="building-dsls-with-free-structures"><a class="header" href="#building-dsls-with-free-structures">Building DSLs with Free Structures</a></h2>
<blockquote>
<p><em>"The key to the whole thing was that Turing had taken the seemingly useless
ability to write numbers down and combined it with a few simple rules. From
this, everything else followed."</em></p>
<p>— Neal Stephenson, <em>Cryptonomicon</em></p>
</blockquote>
<p>Sometimes you want to describe a computation without immediately executing it.
You might want to:</p>
<ul>
<li>Test the same program against mock and real interpreters</li>
<li>Optimise the program before running it</li>
<li>Log or serialise what the program <em>would</em> do</li>
<li>Run the same description in different contexts</li>
</ul>
<p>Free structures—<code>FreePath</code> and <code>FreeApPath</code>—let you build domain-specific
languages (DSLs) where the program is <em>data</em> that can be inspected, transformed,
and interpreted later.</p>
<h3 id="freepath-the-free-monad"><a class="header" href="#freepath-the-free-monad">FreePath: The Free Monad</a></h3>
<p><code>FreePath&lt;F, A&gt;</code> represents a computation built from a functor <code>F</code> that can be
interpreted into any monad. It supports the full <code>Chainable</code> interface: you can
use <code>via</code> to sequence operations where later steps depend on earlier results.</p>
<h4 id="defining-a-dsl-1"><a class="header" href="#defining-a-dsl-1">Defining a DSL</a></h4>
<p>First, define your DSL operations as a sealed interface:</p>
<pre><code class="language-java">// A simple Console DSL
sealed interface ConsoleOp&lt;A&gt; {
    record PrintLine&lt;A&gt;(String message, A next) implements ConsoleOp&lt;A&gt; {}
    record ReadLine&lt;A&gt;(Function&lt;String, A&gt; cont) implements ConsoleOp&lt;A&gt; {}
}
</code></pre>
<h4 id="building-programs"><a class="header" href="#building-programs">Building Programs</a></h4>
<p>Lift operations into <code>FreePath</code> and compose them:</p>
<pre><code class="language-java">FreePath&lt;ConsoleOp.Witness, Unit&gt; print(String msg) {
    return FreePath.liftF(new PrintLine&lt;&gt;(msg, Unit.INSTANCE), consoleFunctor);
}

FreePath&lt;ConsoleOp.Witness, String&gt; readLine() {
    return FreePath.liftF(new ReadLine&lt;&gt;(s -&gt; s), consoleFunctor);
}

// Build a program
FreePath&lt;ConsoleOp.Witness, String&gt; greet =
    print("What's your name?")
        .then(() -&gt; readLine())
        .via(name -&gt; print("Hello, " + name).map(_ -&gt; name));
</code></pre>
<p>The program <code>greet</code> doesn't <em>do</em> anything yet. It's a data structure describing
what should happen.</p>
<h4 id="interpretation"><a class="header" href="#interpretation">Interpretation</a></h4>
<p>Interpret the program by providing a natural transformation to a target monad:</p>
<pre><code class="language-java">// Real interpreter: performs actual I/O
NaturalTransformation&lt;ConsoleOp.Witness, IOKind.Witness&gt; realInterpreter =
    new NaturalTransformation&lt;&gt;() {
        @Override
        public &lt;A&gt; Kind&lt;IOKind.Witness, A&gt; apply(Kind&lt;ConsoleOp.Witness, A&gt; fa) {
            ConsoleOp&lt;A&gt; op = ConsoleOp.narrow(fa);
            return switch (op) {
                case PrintLine(var msg, var next) -&gt;
                    IO.delay(() -&gt; { System.out.println(msg); return next; });
                case ReadLine(var cont) -&gt;
                    IO.delay(() -&gt; cont.apply(scanner.nextLine()));
            };
        }
    };

// Execute with real I/O
GenericPath&lt;IOKind.Witness, String&gt; result = greet.foldMap(realInterpreter, ioMonad);
String name = result.run().unsafeRun();
</code></pre>
<h4 id="testing-with-mock-interpreters"><a class="header" href="#testing-with-mock-interpreters">Testing with Mock Interpreters</a></h4>
<p>The same program can be tested without real I/O:</p>
<pre><code class="language-java">// Test interpreter with canned responses
NaturalTransformation&lt;ConsoleOp.Witness, StateKind.Witness&gt; testInterpreter =
    /* returns canned values, records outputs */;

// Same program, different execution
GenericPath&lt;StateKind.Witness, String&gt; testResult =
    greet.foldMap(testInterpreter, stateMonad);
</code></pre>
<h3 id="freeappath-the-free-applicative"><a class="header" href="#freeappath-the-free-applicative">FreeApPath: The Free Applicative</a></h3>
<p><code>FreeApPath&lt;F, A&gt;</code> is more restricted: it implements <code>Combinable</code> but <strong>not</strong>
<code>Chainable</code>. You can use <code>zipWith</code> to combine independent computations, but
you cannot use <code>via</code> to make one computation depend on another's result.</p>
<p>Why would you want less power? Because the restriction enables <em>static analysis</em>.
Since no step depends on previous results, you can inspect the entire structure
before running anything.</p>
<h4 id="validation-example"><a class="header" href="#validation-example">Validation Example</a></h4>
<pre><code class="language-java">// Validation operations
sealed interface ValidationOp&lt;A&gt; {
    record ValidateField&lt;A&gt;(String field, Predicate&lt;String&gt; check, A onSuccess)
        implements ValidationOp&lt;A&gt; {}
}

// Build validation program
FreeApPath&lt;ValidationOp.Witness, User&gt; validateUser =
    FreeApPath.liftF(new ValidateField&lt;&gt;("name", s -&gt; !s.isBlank(), "name"), valFunctor)
        .zipWith3(
            FreeApPath.liftF(new ValidateField&lt;&gt;("email", s -&gt; s.contains("@"), "email"), valFunctor),
            FreeApPath.liftF(new ValidateField&lt;&gt;("age", s -&gt; Integer.parseInt(s) &gt; 0, "age"), valFunctor),
            (name, email, age) -&gt; new User(name, email, Integer.parseInt(age))
        );
</code></pre>
<p>All three validations are independent—they can run in parallel, and all errors
can be collected rather than stopping at the first failure.</p>
<h3 id="freepath-vs-freeappath"><a class="header" href="#freepath-vs-freeappath">FreePath vs FreeApPath</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>FreePath</th><th>FreeApPath</th></tr></thead><tbody>
<tr><td>Sequencing (<code>via</code>)</td><td>Yes</td><td>No</td></tr>
<tr><td>Combining (<code>zipWith</code>)</td><td>Yes</td><td>Yes</td></tr>
<tr><td>Static analysis</td><td>No (depends on runtime values)</td><td>Yes (structure fixed)</td></tr>
<tr><td>Parallel-friendly</td><td>No</td><td>Yes</td></tr>
<tr><td>Use case</td><td>Sequential DSLs</td><td>Validation, queries, parallel DSLs</td></tr>
</tbody></table>
</div>
<h3 id="when-to-use-free-structures"><a class="header" href="#when-to-use-free-structures">When to Use Free Structures</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Scenario</th><th>Recommendation</th></tr></thead><tbody>
<tr><td>Testing with mock interpreters</td><td>FreePath or FreeApPath</td></tr>
<tr><td>Multiple interpretation strategies</td><td>FreePath or FreeApPath</td></tr>
<tr><td>Sequential operations with dependencies</td><td>FreePath</td></tr>
<tr><td>Independent operations, all errors wanted</td><td>FreeApPath</td></tr>
<tr><td>Static analysis or optimisation</td><td>FreeApPath</td></tr>
<tr><td>Simple, one-off computation</td><td>Use concrete types directly</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="resource-management-2"><a class="header" href="#resource-management-2">Resource Management</a></h2>
<blockquote>
<p><em>"He had learned to think of the system as a living thing, with resources
that had to be carefully husbanded."</em></p>
<p>— Lionel Davidson, <em>Kolymsky Heights</em></p>
</blockquote>
<p>Davidson's protagonist survived the Siberian wilderness by meticulous resource
management. Software faces analogous challenges: database connections, file
handles, network sockets. Acquire them, use them, release them—and make
absolutely certain the release happens even when something goes wrong.</p>
<h3 id="the-bracket-pattern"><a class="header" href="#the-bracket-pattern">The bracket Pattern</a></h3>
<p><code>bracket</code> is the fundamental resource pattern: acquire, use, release. The release
<em>always</em> runs, regardless of whether the use succeeds or fails:</p>
<pre><code class="language-java">IOPath&lt;String&gt; readFile = IOPath.bracket(
    () -&gt; new FileInputStream("data.txt"),      // acquire
    stream -&gt; new String(stream.readAllBytes()), // use
    stream -&gt; stream.close()                     // release (always runs)
);
</code></pre>
<p>If <code>readAllBytes()</code> throws, the stream still closes. The exception propagates
after cleanup completes.</p>
<h4 id="bracketio-for-effectful-use"><a class="header" href="#bracketio-for-effectful-use">bracketIO for Effectful Use</a></h4>
<p>When the use phase itself returns an <code>IOPath</code>:</p>
<pre><code class="language-java">IOPath&lt;List&lt;String&gt;&gt; processFile = IOPath.bracketIO(
    () -&gt; Files.newBufferedReader(path),
    reader -&gt; IOPath.delay(() -&gt; reader.lines().toList()),
    reader -&gt; { try { reader.close(); } catch (Exception e) { /* log */ } }
);
</code></pre>
<h3 id="withresource-for-autocloseable"><a class="header" href="#withresource-for-autocloseable">withResource for AutoCloseable</a></h3>
<p>When your resource implements <code>AutoCloseable</code>, <code>withResource</code> provides a
cleaner syntax:</p>
<pre><code class="language-java">IOPath&lt;List&lt;String&gt;&gt; lines = IOPath.withResource(
    () -&gt; Files.newBufferedReader(path),
    reader -&gt; reader.lines().toList()
);
</code></pre>
<p>The reader is automatically closed after use, with proper exception handling.</p>
<h4 id="withresourceio-variant"><a class="header" href="#withresourceio-variant">withResourceIO Variant</a></h4>
<pre><code class="language-java">IOPath&lt;Config&gt; config = IOPath.withResourceIO(
    () -&gt; new FileInputStream("config.json"),
    stream -&gt; IOPath.delay(() -&gt; parseConfig(stream))
);
</code></pre>
<h3 id="guarantee-for-cleanup-actions"><a class="header" href="#guarantee-for-cleanup-actions">guarantee for Cleanup Actions</a></h3>
<p>Sometimes you don't need acquire/release semantics—you just need to ensure
something runs after a computation completes:</p>
<pre><code class="language-java">IOPath&lt;Result&gt; computation = fetchData()
    .guarantee(() -&gt; log.info("Fetch completed"));
</code></pre>
<p>The guarantee runs whether <code>fetchData()</code> succeeds or fails.</p>
<h4 id="guaranteeio-for-effectful-cleanup"><a class="header" href="#guaranteeio-for-effectful-cleanup">guaranteeIO for Effectful Cleanup</a></h4>
<pre><code class="language-java">IOPath&lt;Result&gt; withCleanup = process()
    .guaranteeIO(() -&gt; IOPath.delay(() -&gt; {
        cleanup();
        return Unit.INSTANCE;
    }));
</code></pre>
<h3 id="nested-resources"><a class="header" href="#nested-resources">Nested Resources</a></h3>
<p>Resources often nest. <code>bracket</code> composes cleanly:</p>
<pre><code class="language-java">IOPath&lt;Result&gt; nested = IOPath.bracketIO(
    () -&gt; acquireConnection(),
    connection -&gt; IOPath.bracketIO(
        () -&gt; connection.prepareStatement(sql),
        statement -&gt; IOPath.bracket(
            () -&gt; statement.executeQuery(),
            resultSet -&gt; processResults(resultSet),
            resultSet -&gt; resultSet.close()
        ),
        statement -&gt; statement.close()
    ),
    connection -&gt; connection.close()
);
</code></pre>
<p>Resources are released in reverse order: result set, then statement, then
connection. If any step fails, all acquired resources are still released.</p>
<h3 id="resource-pattern-summary"><a class="header" href="#resource-pattern-summary">Resource Pattern Summary</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Pattern</th><th>Use Case</th></tr></thead><tbody>
<tr><td><code>bracket</code></td><td>Acquire/use/release with custom cleanup</td></tr>
<tr><td><code>bracketIO</code></td><td>Same, but use returns IOPath</td></tr>
<tr><td><code>withResource</code></td><td>AutoCloseable resources</td></tr>
<tr><td><code>withResourceIO</code></td><td>AutoCloseable with IOPath use</td></tr>
<tr><td><code>guarantee</code></td><td>Ensure cleanup runs after computation</td></tr>
<tr><td><code>guaranteeIO</code></td><td>Effectful cleanup</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="parallel-execution-2"><a class="header" href="#parallel-execution-2">Parallel Execution</a></h2>
<blockquote>
<p><em>"In cryptography, you sometimes have to try many keys simultaneously.
The first one that works wins."</em></p>
<p>— Neal Stephenson, <em>Cryptonomicon</em></p>
</blockquote>
<p>Some computations are independent. Fetching user data and fetching preferences
don't depend on each other; why wait for one to finish before starting the other?</p>
<h3 id="parzipwith-binary-parallelism"><a class="header" href="#parzipwith-binary-parallelism">parZipWith: Binary Parallelism</a></h3>
<p><code>parZipWith</code> runs two <code>IOPath</code> computations concurrently and combines their
results:</p>
<pre><code class="language-java">IOPath&lt;String&gt; fetchUser = IOPath.delay(() -&gt; {
    Thread.sleep(100);
    return "User123";
});

IOPath&lt;String&gt; fetchPrefs = IOPath.delay(() -&gt; {
    Thread.sleep(100);
    return "DarkMode";
});

// Sequential: ~200ms (100ms + 100ms)
IOPath&lt;String&gt; sequential = fetchUser.zipWith(fetchPrefs, (u, p) -&gt; u + "/" + p);

// Parallel: ~100ms (max of both)
IOPath&lt;String&gt; parallel = fetchUser.parZipWith(fetchPrefs, (u, p) -&gt; u + "/" + p);
</code></pre>
<p>The operations are the same; the execution strategy differs.</p>
<h3 id="parzip3-and-parzip4"><a class="header" href="#parzip3-and-parzip4">parZip3 and parZip4</a></h3>
<p>For three or four independent computations, use <code>PathOps</code> utilities:</p>
<pre><code class="language-java">IOPath&lt;Dashboard&gt; dashboard = PathOps.parZip3(
    fetchMetrics(),
    fetchAlerts(),
    fetchUsers(),
    Dashboard::new
);

IOPath&lt;Report&gt; report = PathOps.parZip4(
    fetchSales(),
    fetchInventory(),
    fetchCustomers(),
    fetchTrends(),
    Report::new
);
</code></pre>
<p>All operations start immediately and run concurrently. The result is available
when all complete.</p>
<h3 id="parsequenceio-list-parallelism"><a class="header" href="#parsequenceio-list-parallelism">parSequenceIO: List Parallelism</a></h3>
<p>When you have a dynamic number of independent operations:</p>
<pre><code class="language-java">List&lt;IOPath&lt;User&gt;&gt; fetches = userIds.stream()
    .map(id -&gt; IOPath.delay(() -&gt; userService.fetch(id)))
    .toList();

// Sequential: N * fetchTime
IOPath&lt;List&lt;User&gt;&gt; sequential = PathOps.sequenceIO(fetches);

// Parallel: ~1 * fetchTime (with enough threads)
IOPath&lt;List&lt;User&gt;&gt; parallel = PathOps.parSequenceIO(fetches);
</code></pre>
<h3 id="parsequencefuture-for-completablefuturepath"><a class="header" href="#parsequencefuture-for-completablefuturepath">parSequenceFuture for CompletableFuturePath</a></h3>
<p>The same pattern works with <code>CompletableFuturePath</code>:</p>
<pre><code class="language-java">List&lt;CompletableFuturePath&lt;Data&gt;&gt; futures = /* ... */;
CompletableFuturePath&lt;List&lt;Data&gt;&gt; all = PathOps.parSequenceFuture(futures);
</code></pre>
<h3 id="race-first-to-finish"><a class="header" href="#race-first-to-finish">race: First to Finish</a></h3>
<p>Sometimes you want whichever completes first:</p>
<pre><code class="language-java">IOPath&lt;Config&gt; primary = IOPath.delay(() -&gt; fetchFromPrimary());
IOPath&lt;Config&gt; backup = IOPath.delay(() -&gt; fetchFromBackup());

// Returns whichever config arrives first
IOPath&lt;Config&gt; fastest = primary.race(backup);
</code></pre>
<div id="admonition-race-caveats" class="admonition admonish-warning" role="note" aria-labelledby="admonition-race-caveats-title">
<div class="admonition-title">
<div id="admonition-race-caveats-title">
<p>Race Caveats</p>
</div>
<a class="admonition-anchor-link" href="effect/advanced_topics.html#admonition-race-caveats"></a>
</div>
<div>
<p>The losing computation is <em>not</em> cancelled (Java limitation). It continues
running in the background. Use <code>race</code> for idempotent operations where
completing the loser is acceptable.</p>
</div>
</div>
<h3 id="raceio-for-multiple-competitors"><a class="header" href="#raceio-for-multiple-competitors">raceIO for Multiple Competitors</a></h3>
<pre><code class="language-java">List&lt;IOPath&lt;Response&gt;&gt; sources = List.of(
    fetchFromRegionA(),
    fetchFromRegionB(),
    fetchFromRegionC()
);

IOPath&lt;Response&gt; fastest = PathOps.raceIO(sources);
</code></pre>
<h3 id="sequential-vs-parallel-the-decision-1"><a class="header" href="#sequential-vs-parallel-the-decision-1">Sequential vs Parallel: The Decision</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Scenario</th><th>Use</th></tr></thead><tbody>
<tr><td>B needs A's result</td><td><code>via</code> (sequential)</td></tr>
<tr><td>A and B independent, need both</td><td><code>parZipWith</code></td></tr>
<tr><td>3-4 independent operations</td><td><code>parZip3</code>, <code>parZip4</code></td></tr>
<tr><td>List of independent operations</td><td><code>parSequenceIO</code></td></tr>
<tr><td>Want fastest of alternatives</td><td><code>race</code>, <code>raceIO</code></td></tr>
</tbody></table>
</div>
<p>The wrong choice doesn't break correctness—just performance. When in doubt,
prefer sequential; parallelise when profiling shows it matters.</p>
<hr />
<h2 id="resilience-patterns"><a class="header" href="#resilience-patterns">Resilience Patterns</a></h2>
<blockquote>
<p><em>"The protocol specified exponential backoff: wait one second, try again;
wait two seconds, try again; wait four seconds..."</em></p>
<p>— Neal Stephenson, <em>Cryptonomicon</em></p>
</blockquote>
<p>Networks fail. Services timeout. Databases hiccup. Resilient code doesn't
assume success—it plans for failure and recovers gracefully.</p>
<h3 id="retrypolicy"><a class="header" href="#retrypolicy">RetryPolicy</a></h3>
<p><code>RetryPolicy</code> encapsulates retry strategy: how many attempts, how long between
them, which failures to retry:</p>
<pre><code class="language-java">// Fixed delay: 100ms between each of 3 attempts
RetryPolicy fixed = RetryPolicy.fixed(3, Duration.ofMillis(100));

// Exponential backoff: 1s, 2s, 4s, 8s...
RetryPolicy exponential = RetryPolicy.exponentialBackoff(5, Duration.ofSeconds(1));

// With jitter to prevent thundering herd
RetryPolicy jittered = RetryPolicy.exponentialBackoffWithJitter(5, Duration.ofSeconds(1));
</code></pre>
<h3 id="understanding-backoff-strategies"><a class="header" href="#understanding-backoff-strategies">Understanding Backoff Strategies</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Strategy</th><th>Delays</th><th>Use Case</th></tr></thead><tbody>
<tr><td>Fixed</td><td>100ms, 100ms, 100ms</td><td>Known recovery time</td></tr>
<tr><td>Exponential</td><td>1s, 2s, 4s, 8s</td><td>Unknown recovery time</td></tr>
<tr><td>Exponential + Jitter</td><td>~1s, ~2s, ~4s (randomised)</td><td>Multiple clients retrying</td></tr>
</tbody></table>
</div>
<p>Jitter adds randomisation to prevent the "thundering herd" problem where many
clients retry at exactly the same moment, overwhelming a recovering service.</p>
<h3 id="configuring-retry-behaviour-1"><a class="header" href="#configuring-retry-behaviour-1">Configuring Retry Behaviour</a></h3>
<p>Policies are immutable but configurable through builder-style methods:</p>
<pre><code class="language-java">RetryPolicy policy = RetryPolicy.exponentialBackoff(5, Duration.ofMillis(100))
    .withMaxDelay(Duration.ofSeconds(30))   // Cap maximum wait
    .retryOn(IOException.class);             // Only retry I/O errors
</code></pre>
<h4 id="custom-retry-predicates"><a class="header" href="#custom-retry-predicates">Custom Retry Predicates</a></h4>
<pre><code class="language-java">RetryPolicy selective = RetryPolicy.fixed(3, Duration.ofMillis(100))
    .retryIf(ex -&gt;
        ex instanceof IOException ||
        ex instanceof TimeoutException ||
        (ex instanceof HttpException http &amp;&amp; http.statusCode() &gt;= 500));
</code></pre>
<h3 id="using-withretry"><a class="header" href="#using-withretry">Using withRetry</a></h3>
<p><code>IOPath</code> and <code>CompletableFuturePath</code> integrate directly with retry policies:</p>
<pre><code class="language-java">IOPath&lt;Response&gt; resilient = IOPath.delay(() -&gt; httpClient.get(url))
    .withRetry(RetryPolicy.exponentialBackoff(3, Duration.ofSeconds(1)));
</code></pre>
<h4 id="convenience-method"><a class="header" href="#convenience-method">Convenience Method</a></h4>
<p>For simple cases with default exponential backoff:</p>
<pre><code class="language-java">IOPath&lt;Response&gt; simple = IOPath.delay(() -&gt; httpClient.get(url))
    .retry(3);  // 3 attempts with default backoff
</code></pre>
<h3 id="handling-exhausted-retries-1"><a class="header" href="#handling-exhausted-retries-1">Handling Exhausted Retries</a></h3>
<p>When all attempts fail, <code>RetryExhaustedException</code> is thrown with the last
failure as its cause:</p>
<pre><code class="language-java">try {
    resilient.unsafeRun();
} catch (RetryExhaustedException e) {
    log.error("All {} retries failed", e.getMessage());
    Throwable lastFailure = e.getCause();
    return fallbackValue;
}
</code></pre>
<h3 id="combining-resilience-patterns"><a class="header" href="#combining-resilience-patterns">Combining Resilience Patterns</a></h3>
<p>Retry composes with other Path operations:</p>
<pre><code class="language-java">IOPath&lt;Data&gt; robust = IOPath.delay(() -&gt; primarySource.fetch())
    .withRetry(RetryPolicy.exponentialBackoff(3, Duration.ofSeconds(1)))
    .handleErrorWith(e -&gt; {
        log.warn("Primary exhausted, trying backup", e);
        return IOPath.delay(() -&gt; backupSource.fetch())
            .withRetry(RetryPolicy.fixed(2, Duration.ofMillis(100)));
    })
    .recover(e -&gt; {
        log.error("All sources failed", e);
        return Data.empty();
    });
</code></pre>
<h3 id="retry-with-resource-management"><a class="header" href="#retry-with-resource-management">Retry with Resource Management</a></h3>
<pre><code class="language-java">IOPath&lt;Result&gt; resilientWithResource = IOPath.withResourceIO(
    () -&gt; acquireConnection(),
    conn -&gt; IOPath.delay(() -&gt; conn.execute(query))
        .withRetry(RetryPolicy.fixed(3, Duration.ofMillis(50)))
);
</code></pre>
<p>The connection is acquired once; the query is retried within that connection.</p>
<h3 id="retry-pattern-quick-reference-1"><a class="header" href="#retry-pattern-quick-reference-1">Retry Pattern Quick Reference</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Pattern</th><th>Code</th></tr></thead><tbody>
<tr><td>Fixed delay</td><td><code>RetryPolicy.fixed(3, Duration.ofMillis(100))</code></td></tr>
<tr><td>Exponential backoff</td><td><code>RetryPolicy.exponentialBackoff(5, Duration.ofSeconds(1))</code></td></tr>
<tr><td>With jitter</td><td><code>RetryPolicy.exponentialBackoffWithJitter(5, Duration.ofSeconds(1))</code></td></tr>
<tr><td>Cap max delay</td><td><code>.withMaxDelay(Duration.ofSeconds(30))</code></td></tr>
<tr><td>Retry specific errors</td><td><code>.retryOn(IOException.class)</code></td></tr>
<tr><td>Custom predicate</td><td><code>.retryIf(ex -&gt; ...)</code></td></tr>
<tr><td>Apply to IOPath</td><td><code>path.withRetry(policy)</code></td></tr>
<tr><td>Simple retry</td><td><code>path.retry(3)</code></td></tr>
</tbody></table>
</div>
<hr />
<h2 id="summary-11"><a class="header" href="#summary-11">Summary</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Capability</th><th>Type/Method</th><th>Use Case</th></tr></thead><tbody>
<tr><td>Stack-safe recursion</td><td><code>TrampolinePath</code></td><td>Deep recursion, mutual recursion</td></tr>
<tr><td>Monadic DSLs</td><td><code>FreePath</code></td><td>Interpretable sequential programs</td></tr>
<tr><td>Applicative DSLs</td><td><code>FreeApPath</code></td><td>Static analysis, parallel-friendly programs</td></tr>
<tr><td>Resource safety</td><td><code>bracket</code>, <code>withResource</code></td><td>Files, connections, cleanup</td></tr>
<tr><td>Cleanup guarantee</td><td><code>guarantee</code></td><td>Ensure finalizers run</td></tr>
<tr><td>Parallel binary</td><td><code>parZipWith</code></td><td>Two independent computations</td></tr>
<tr><td>Parallel n-ary</td><td><code>parZip3</code>, <code>parZip4</code></td><td>3-4 independent computations</td></tr>
<tr><td>Parallel list</td><td><code>parSequenceIO</code></td><td>Dynamic number of computations</td></tr>
<tr><td>First-to-finish</td><td><code>race</code>, <code>raceIO</code></td><td>Redundant sources, timeouts</td></tr>
<tr><td>Retry with backoff</td><td><code>RetryPolicy</code>, <code>withRetry</code></td><td>Transient failures</td></tr>
</tbody></table>
</div>
<p>These patterns are the fragments Stephenson described: individually useful,
collectively transformative. Combined with the core Path types from earlier
chapters, they provide a comprehensive toolkit for building robust, composable
systems that handle the full spectrum of real-world complexity.</p>
<div id="admonition-see-also" class="admonition admonish-tip" role="note" aria-labelledby="admonition-see-also-title">
<div class="admonition-title">
<div id="admonition-see-also-title">
<p>See Also</p>
</div>
<a class="admonition-anchor-link" href="effect/advanced_topics.html#admonition-see-also"></a>
</div>
<div>
<ul>
<li><a href="effect/../monads/trampoline_monad.html">Trampoline Monad</a> - Underlying type for TrampolinePath</li>
<li><a href="effect/../monads/free_monad.html">Free Monad</a> - Underlying type for FreePath</li>
<li><a href="effect/../monads/free_applicative.html">Free Applicative</a> - Underlying type for FreeApPath</li>
<li><a href="effect/../monads/io_monad.html">IO Monad</a> - Resource and parallel operations</li>
</ul>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="effect/effect_contexts_mutable.html">MutableContext</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="monad-transformers-combining-effects"><a class="header" href="#monad-transformers-combining-effects">Monad Transformers: Combining Effects</a></h1>
<blockquote>
<p><em>"Shall I project a world?"</em></p>
<p>– Thomas Pynchon, <em>The Crying of Lot 49</em></p>
</blockquote>
<hr />
<p>A transformer projects one monad's world into another's. <code>EitherT</code> takes the world of typed errors and projects it into whatever outer monad you choose: <code>CompletableFuture</code>, <code>IO</code>, <code>List</code>. The result is a new monad that combines both effects: asynchronous computation <em>with</em> error handling, deferred execution <em>with</em> failure semantics.</p>
<p>The problem being solved is fundamental: monads don't compose naturally. You can have a <code>CompletableFuture&lt;A&gt;</code>. You can have an <code>Either&lt;E, A&gt;</code>. But a <code>CompletableFuture&lt;Either&lt;E, A&gt;&gt;</code>, whilst perfectly expressible in Java, becomes awkward to work with. Every operation requires nested <code>thenApply</code> and <code>map</code> calls, peeling back layers manually. The ergonomics deteriorate rapidly.</p>
<p>Transformers restore sanity. <code>EitherT&lt;CompletableFutureKind.Witness, DomainError, Result&gt;</code> presents a unified interface: a single <code>flatMap</code> sequences async operations that might fail; a single <code>map</code> transforms successful results; error handling works at the combined level. The nesting is still there (it must be), but the transformer hides it.</p>
<p>Higher-Kinded-J provides transformers for common combinations: <code>EitherT</code> for typed errors, <code>MaybeT</code> and <code>OptionalT</code> for optional values, <code>ReaderT</code> for dependency injection, and <code>StateT</code> for state threading. Each takes an outer monad and adds its specific capability.</p>
<hr />
<h2 id="the-stacking-concept"><a class="header" href="#the-stacking-concept">The Stacking Concept</a></h2>
<pre><code>    ┌─────────────────────────────────────────────────────────────┐
    │  WITHOUT TRANSFORMER                                        │
    │                                                             │
    │    CompletableFuture&lt;Either&lt;Error, Result&gt;&gt;                 │
    │                                                             │
    │    future.thenApply(either -&gt;                               │
    │        either.map(result -&gt;                                 │
    │            either2.map(r2 -&gt;                                │
    │                ...)))   // Nesting grows unboundedly        │
    └─────────────────────────────────────────────────────────────┘

    ┌─────────────────────────────────────────────────────────────┐
    │  WITH TRANSFORMER                                           │
    │                                                             │
    │    EitherT&lt;FutureWitness, Error, Result&gt;                    │
    │                                                             │
    │    eitherT                                                  │
    │        .flatMap(result -&gt; operation1(result))               │
    │        .flatMap(r1 -&gt; operation2(r1))                       │
    │        .map(r2 -&gt; finalTransform(r2))  // Flat!             │
    └─────────────────────────────────────────────────────────────┘
</code></pre>
<p>Same semantics. Vastly different ergonomics.</p>
<hr />
<h2 id="available-transformers"><a class="header" href="#available-transformers">Available Transformers</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Transformer</th><th>Inner Effect</th><th>Use Case</th></tr></thead><tbody>
<tr><td><code>EitherT&lt;F, E, A&gt;</code></td><td>Typed error (<code>Either&lt;E, A&gt;</code>)</td><td>Async operations that fail with domain errors</td></tr>
<tr><td><code>MaybeT&lt;F, A&gt;</code></td><td>Optional value (<code>Maybe&lt;A&gt;</code>)</td><td>Async operations that might return nothing</td></tr>
<tr><td><code>OptionalT&lt;F, A&gt;</code></td><td>Java Optional (<code>Optional&lt;A&gt;</code>)</td><td>Same as MaybeT, for java.util.Optional</td></tr>
<tr><td><code>ReaderT&lt;F, R, A&gt;</code></td><td>Environment (<code>Reader&lt;R, A&gt;</code>)</td><td>Dependency injection in effectful contexts</td></tr>
<tr><td><code>StateT&lt;S, F, A&gt;</code></td><td>State (<code>State&lt;S, A&gt;</code>)</td><td>Stateful computation within other effects</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="what-youll-learn"><a class="header" href="#what-youll-learn">What You'll Learn</a></h2>
<div id="admonition-in-this-chapter" class="admonition admonish-info" role="note" aria-labelledby="admonition-in-this-chapter-title">
<div class="admonition-title">
<div id="admonition-in-this-chapter-title">
<p>In This Chapter</p>
</div>
<a class="admonition-anchor-link" href="transformers/ch_intro.html#admonition-in-this-chapter"></a>
</div>
<div>
<ul>
<li><strong>The Problem</strong> – Monads don't compose naturally. A <code>CompletableFuture&lt;Either&lt;E, A&gt;&gt;</code> requires nested operations that become unwieldy. Transformers restore ergonomic composition.</li>
<li><strong>EitherT</strong> – Adds typed error handling to any monad. Wrap your async operations with <code>EitherT</code> to get a single <code>flatMap</code> that handles both async sequencing and error propagation.</li>
<li><strong>OptionalT</strong> – Lifts <code>java.util.Optional</code> into another monadic context. When your async operation might return nothing, OptionalT provides clean composition.</li>
<li><strong>MaybeT</strong> – The same capability as OptionalT but for the library's <code>Maybe</code> type. Choose based on whether you're using Optional or Maybe elsewhere.</li>
<li><strong>ReaderT</strong> – Threads environment dependencies through effectful computations. Combine dependency injection with async operations or error handling.</li>
<li><strong>StateT</strong> – Manages state within effectful computations. Track state changes across async boundaries or error-handling paths.</li>
</ul>
</div>
</div>
<hr />
<h2 id="chapter-contents-1"><a class="header" href="#chapter-contents-1">Chapter Contents</a></h2>
<ol>
<li><a href="transformers/transformers.html">Monad Transformers</a> - Why monads stack poorly and what transformers solve</li>
<li><a href="transformers/eithert_transformer.html">EitherT</a> - Typed errors in any monadic context</li>
<li><a href="transformers/optionalt_transformer.html">OptionalT</a> - Java Optional lifting</li>
<li><a href="transformers/maybet_transformer.html">MaybeT</a> - Maybe lifting</li>
<li><a href="transformers/readert_transformer.html">ReaderT</a> - Environment threading</li>
<li><a href="transformers/statet_transformer.html">StateT</a> - State management in effectful computation</li>
</ol>
<hr />
<p><strong>Next:</strong> <a href="transformers/transformers.html">Monad Transformers</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="the-transformers"><a class="header" href="#the-transformers">The Transformers:</a></h1>
<p><em>Combining Monadic Effects</em></p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="transformers/transformers.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>Why directly nesting monadic types like <code>CompletableFuture&lt;Either&lt;E, A&gt;&gt;</code> leads to complex, unwieldy code</li>
<li>How monad transformers wrap nested monads to provide a unified interface with familiar <code>map</code> and <code>flatMap</code> operations</li>
<li>The available transformers in Higher-Kinded-J: EitherT, MaybeT, OptionalT, ReaderT, and StateT</li>
<li>How to choose the right transformer for your use case based on the effect you need to add</li>
</ul>
</div>
</div>
<p><img src="transformers/../images/stand_back_monad_transformers.jpg" alt="stand_back_monad_transformers.jpg" /></p>
<h2 id="the-problem-5"><a class="header" href="#the-problem-5">The Problem</a></h2>
<p>When building applications, we often encounter scenarios where we need to combine different computational contexts or effects. For example:</p>
<ul>
<li>An operation might be <strong>asynchronous</strong> (represented by <code>CompletableFuture</code>).</li>
<li>The same operation might also <strong>fail with specific domain errors</strong> (represented by <code>Either&lt;DomainError, Result&gt;</code>).</li>
<li>An operation might need <strong>access to a configuration</strong> (using <code>Reader</code>) and also be <strong>asynchronous</strong>.</li>
<li>A computation might <strong>accumulate logs</strong> (using <code>Writer</code>) and also <strong>potentially fail</strong> (using <code>Maybe</code> or <code>Either</code>).</li>
</ul>
<h3 id="monads-stack-poorly"><a class="header" href="#monads-stack-poorly">Monads Stack Poorly</a></h3>
<p>Directly nesting these monadic types, like <code>CompletableFuture&lt;Either&lt;DomainError, Result&gt;&gt;</code> or <code>Reader&lt;Config, Optional&lt;Data&gt;&gt;</code>, leads to complex, deeply nested code ("callback hell" or nested <code>flatMap</code>/<code>map</code> calls). It becomes difficult to sequence operations and handle errors or contexts uniformly.</p>
<p>For instance, an operation might need to be both asynchronous <em>and</em> handle potential domain-specific errors. Representing this naively leads to nested types like:</p>
<pre><code class="language-java">// A future that, when completed, yields either a DomainError or a SuccessValue
Kind&lt;CompletableFutureKind.Witness, Either&lt;DomainError, SuccessValue&gt;&gt; nestedResult;
</code></pre>
<p>But now, how do we <code>map</code> or <code>flatMap</code> over this stack  without lots of boilerplate?</p>
<h2 id="monad-transformers-a-wrapper-to-simplify-nested-monads"><a class="header" href="#monad-transformers-a-wrapper-to-simplify-nested-monads">Monad Transformers: A <em>wrapper</em> to simplify nested Monads</a></h2>
<p><strong>Monad Transformers</strong> are a design pattern in functional programming used to combine the effects of two different monads into a single, new monad. They provide a standard way to "stack" monadic contexts, allowing you to work with the combined structure more easily using familiar monadic operations like <code>map</code> and <code>flatMap</code>.</p>
<p>A monad transformer <code>T</code> takes a monad <code>M</code> and produces a new monad <code>T&lt;M&gt;</code> that combines the effects of both <code>T</code> (conceptually) and <code>M</code>.</p>
<h4 id="for-example"><a class="header" href="#for-example">For example:</a></h4>
<ul>
<li><code>MaybeT m a</code> wraps a monad <code>m</code> and adds <code>Maybe</code>-like failure</li>
<li><code>StateT s m a</code> wraps a monad <code>m</code> and adds state-handling capability</li>
<li><code>ReaderT r m a</code> adds dependency injection (read-only environment)</li>
</ul>
<p>They allow you to <strong>stack</strong> monadic behaviours.</p>
<p>Key characteristics:</p>
<ol>
<li><strong>Stacking:</strong> They allow "stacking" monadic effects in a standard way.</li>
<li><strong>Unified Interface:</strong> The resulting transformed monad (e.g., <code>EitherT&lt;CompletableFutureKind, ...&gt;</code>) itself implements the <code>Monad</code> (and often <code>MonadError</code>, etc.) interface.</li>
<li><strong>Abstraction:</strong> They hide the complexity of manually managing the nested structure. You can use standard <code>map</code>, <code>flatMap</code>, <code>handleErrorWith</code> operations on the transformed monad, and it automatically handles the logic for both underlying monads correctly.</li>
</ol>
<h2 id="transformers-in-higher-kinded-j"><a class="header" href="#transformers-in-higher-kinded-j">Transformers in Higher-Kinded-J</a></h2>
<p><img src="transformers/../images/puml/supported_transformers.svg" alt="supported_transformers.svg" /></p>
<h3 id="1-eithertf-l-r-monad-transformer"><a class="header" href="#1-eithertf-l-r-monad-transformer">1. <code>EitherT&lt;F, L, R&gt;</code> (Monad Transformer)</a></h3>
<p><img src="transformers/../images/puml/transformers.svg" alt="transformers.svg" /></p>
<ul>
<li><strong>Definition:</strong> A monad transformer (<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/either_t/EitherT.java"><code>EitherT</code></a>) that combines an outer monad <code>F</code> with an inner <code>Either&lt;L, R&gt;</code>. Implemented as a record wrapping <code>Kind&lt;F, Either&lt;L, R&gt;&gt;</code>.</li>
<li><strong>Kind Interface:</strong> <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/either_t/EitherTKind.java"><code>EitherTKind&lt;F, L, R&gt;</code></a></li>
<li><strong>Witness Type <code>G</code>:</strong> <code>EitherTKind.Witness&lt;F, L&gt;</code> (where <code>F</code> and <code>L</code> are fixed for a given type class instance)</li>
<li><strong>Helper:</strong> <code>EitherTKindHelper</code> (<code>wrap</code>, <code>unwrap</code>). Instances are primarily created via <code>EitherT</code> static factories (<code>fromKind</code>, <code>right</code>, <code>left</code>, <code>fromEither</code>, <code>liftF</code>).</li>
<li><strong>Type Class Instances:</strong>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/either_t/EitherT.java"><code>EitherTMonad&lt;F, L&gt;</code></a> (<code>MonadError&lt;EitherTKind.Witness&lt;F, L&gt;, L&gt;</code>)</li>
</ul>
</li>
<li><strong>Notes:</strong> Simplifies working with nested structures like <code>F&lt;Either&lt;L, R&gt;&gt;</code>. Requires a <code>Monad&lt;F&gt;</code> instance for the outer monad <code>F</code> passed to its constructor. Implements <code>MonadError</code> for the <em>inner</em> <code>Either</code>'s <code>Left</code> type <code>L</code>. See the <a href="transformers/../hkts/order-walkthrough.html">Order Processing Example Walkthrough</a> for practical usage with <code>CompletableFuture</code> as <code>F</code>.</li>
<li><strong>Usage:</strong> <a href="transformers/eithert_transformer.html">How to use the EitherT Monad Transformer</a></li>
</ul>
<hr />
<h3 id="2-maybetf-a-monad-transformer"><a class="header" href="#2-maybetf-a-monad-transformer">2. <code>MaybeT&lt;F, A&gt;</code> (Monad Transformer)</a></h3>
<ul>
<li><strong>Definition:</strong> A monad transformer (<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/maybe_t/MaybeT.java"><code>MaybeT</code></a>) that combines an outer monad <code>F</code> with an inner <code>Maybe&lt;A&gt;</code>. Implemented as a record wrapping <code>Kind&lt;F, Maybe&lt;A&gt;&gt;</code>.</li>
<li><strong>Kind Interface:</strong> <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt//maybe_t/MaybeTKind.java"><code>MaybeTKind&lt;F, A&gt;</code></a></li>
<li><strong>Witness Type <code>G</code>:</strong> <code>MaybeTKind.Witness&lt;F&gt;</code> (where <code>F</code> is fixed for a given type class instance)</li>
<li><strong>Helper:</strong> <code>MaybeTKindHelper</code> (<code>wrap</code>, <code>unwrap</code>). Instances are primarily created via <code>MaybeT</code> static factories (<code>fromKind</code>, <code>just</code>, <code>nothing</code>, <code>fromMaybe</code>, <code>liftF</code>).</li>
<li><strong>Type Class Instances:</strong>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt//maybe_t/MaybeTMonad.java"><code>MaybeTMonad&lt;F&gt;</code></a> (<code>MonadError&lt;MaybeTKind.Witness&lt;F&gt;, Void&gt;</code>)</li>
</ul>
</li>
<li><strong>Notes:</strong> Simplifies working with nested structures like <code>F&lt;Maybe&lt;A&gt;&gt;</code>. Requires a <code>Monad&lt;F&gt;</code> instance for the outer monad <code>F</code>. Implements <code>MonadError</code> where the error type is <code>Void</code>, corresponding to the <code>Nothing</code> state from the inner <code>Maybe</code>.</li>
<li><strong>Usage:</strong> <a href="transformers/./maybet_transformer.html">How to use the MaybeT Monad Transformer</a></li>
</ul>
<hr />
<h3 id="3-optionaltf-a-monad-transformer"><a class="header" href="#3-optionaltf-a-monad-transformer">3. <code>OptionalT&lt;F, A&gt;</code> (Monad Transformer)</a></h3>
<ul>
<li><strong>Definition:</strong> A monad transformer (<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt//optional_t/OptionalT.java"><code>OptionalT</code></a>) that combines an outer monad <code>F</code> with an inner <code>java.util.Optional&lt;A&gt;</code>. Implemented as a record wrapping <code>Kind&lt;F, Optional&lt;A&gt;&gt;</code>.</li>
<li><strong>Kind Interface:</strong> <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt//optional_t/OptionalTKind.java"><code>OptionalTKind&lt;F, A&gt;</code></a></li>
<li><strong>Witness Type <code>G</code>:</strong> <code>OptionalTKind.Witness&lt;F&gt;</code> (where <code>F</code> is fixed for a given type class instance)</li>
<li><strong>Helper:</strong> <code>OptionalTKindHelper</code> (<code>wrap</code>, <code>unwrap</code>). Instances are primarily created via <code>OptionalT</code> static factories (<code>fromKind</code>, <code>some</code>, <code>none</code>, <code>fromOptional</code>, <code>liftF</code>).</li>
<li><strong>Type Class Instances:</strong>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt//optional_t/OptionalTMonad.java"><code>OptionalTMonad&lt;F&gt;</code></a> (<code>MonadError&lt;OptionalTKind.Witness&lt;F&gt;, Void&gt;</code>)</li>
</ul>
</li>
<li><strong>Notes:</strong> Simplifies working with nested structures like <code>F&lt;Optional&lt;A&gt;&gt;</code>. Requires a <code>Monad&lt;F&gt;</code> instance for the outer monad <code>F</code>. Implements <code>MonadError</code> where the error type is <code>Void</code>, corresponding to the <code>Optional.empty()</code> state from the inner <code>Optional</code>.</li>
<li><strong>Usage:</strong> <a href="transformers/./optionalt_transformer.html">How to use the OptionalT Monad Transformer</a></li>
</ul>
<hr />
<h3 id="4-readertf-r-a-monad-transformer"><a class="header" href="#4-readertf-r-a-monad-transformer">4. <code>ReaderT&lt;F, R, A&gt;</code> (Monad Transformer)</a></h3>
<ul>
<li><strong>Definition:</strong> A monad transformer (<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt//reader_t/ReaderT.java"><code>ReaderT</code></a>) that combines an outer monad <code>F</code> with an inner <code>Reader&lt;R, A&gt;</code>-like behaviour (dependency on environment <code>R</code>). Implemented as a record wrapping a function <code>R -&gt; Kind&lt;F, A&gt;</code>.</li>
<li><strong>Kind Interface:</strong> <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt//reader_t/ReaderTKind.java"><code>ReaderTKind&lt;F, R, A&gt;</code></a></li>
<li><strong>Witness Type <code>G</code>:</strong> <code>ReaderTKind.Witness&lt;F, R&gt;</code> (where <code>F</code> and <code>R</code> are fixed for a given type class instance)</li>
<li><strong>Helper:</strong> <code>ReaderTKindHelper</code> (<code>wrap</code>, <code>unwrap</code>). Instances are primarily created via <code>ReaderT</code> static factories (<code>of</code>, <code>lift</code>, <code>reader</code>, <code>ask</code>).</li>
<li><strong>Type Class Instances:</strong>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt//reader_t/ReaderTMonad.java"><code>ReaderTMonad&lt;F, R&gt;</code></a> (<code>Monad&lt;ReaderTKind&lt;F, R, ?&gt;&gt;</code>)</li>
</ul>
</li>
<li><strong>Notes:</strong> Simplifies managing computations that depend on a read-only environment <code>R</code> while also involving other monadic effects from <code>F</code>. Requires a <code>Monad&lt;F&gt;</code> instance for the outer monad. The <code>run()</code> method of <code>ReaderT</code> takes <code>R</code> and returns <code>Kind&lt;F, A&gt;</code>.</li>
<li><strong>Usage:</strong> <a href="transformers/./readert_transformer.html">How to use the ReaderT Monad Transformer</a></li>
</ul>
<h3 id="5-statets-f-a-monad-transformer"><a class="header" href="#5-statets-f-a-monad-transformer">5. <code>StateT&lt;S, F, A&gt;</code> (Monad Transformer)</a></h3>
<ul>
<li><strong>Definition:</strong> A monad transformer (<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt//state_t/StateT.java"><code>StateT</code></a>) that adds stateful computation (type <code>S</code>) to an underlying monad <code>F</code>. It represents a function <code>S -&gt; Kind&lt;F, StateTuple&lt;S, A&gt;&gt;</code>.</li>
<li><strong>Kind Interface:</strong><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt//state_t/StateTKind.java"><code>StateTKind&lt;S, F, A&gt;</code></a></li>
<li><strong>Witness Type <code>G</code>:</strong><code>StateTKind.Witness&lt;S, F&gt;</code> (where <code>S</code> for state and <code>F</code> for the underlying monad witness are fixed for a given type class instance; <code>A</code> is the value type parameter)</li>
<li><strong>Helper:</strong><code>StateTKindHelper</code> (<code>narrow</code>, <code>wrap</code>, <code>runStateT</code>, <code>evalStateT</code>, <code>execStateT</code>, <code>lift</code>). Instances are created via <code>StateT.create()</code>, <code>StateTMonad.of()</code>, or <code>StateTKind.lift()</code>.</li>
<li><strong>Type Class Instances:</strong>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt//state_t/StateTMonad.java"><code>StateTMonad&lt;S, F&gt;</code></a> (<code>Monad&lt;StateTKind.Witness&lt;S, F&gt;&gt;</code>)</li>
</ul>
</li>
<li><strong>Notes:</strong> Allows combining stateful logic with other monadic effects from <code>F</code>. Requires a <code>Monad&lt;F&gt;</code> instance for the underlying monad. The <code>runStateT(initialState)</code> method executes the computation, returning <code>Kind&lt;F, StateTuple&lt;S, A&gt;&gt;</code>.</li>
<li><strong>Usage:</strong><a href="transformers/./statet_transformer.html">How to use the StateT Monad Transformer</a></li>
</ul>
<hr />
<div id="admonition-further-reading" class="admonition admonish-tip" role="note" aria-labelledby="admonition-further-reading-title">
<div class="admonition-title">
<div id="admonition-further-reading-title">
<p>Further Reading</p>
</div>
<a class="admonition-anchor-link" href="transformers/transformers.html#admonition-further-reading"></a>
</div>
<div>
<p>Start with the <strong>Java-focused</strong> articles to understand why transformers matter in Java, then explore the <strong>General FP</strong> theory, and finally examine how other libraries implement these patterns.</p>
</div>
</div>
<h3 id="java-focused-resources"><a class="header" href="#java-focused-resources">Java-Focused Resources</a></h3>
<p><strong>Beginner Level:</strong>
-<a href="https://medium.com/@johnmcclean/monad-transformers-in-java-e6f6b7e0f76d">Monad Transformers in Java: A Practical Guide</a> - John McClean's clear explanation with Cyclops examples (15 min read)
-<a href="https://www.youtube.com/watch?v=rPSL1alFIjI">Functional Programming in Java: Beyond Streams</a> - Venkat Subramaniam discusses composition patterns (45 min watch)
-<a href="https://www.baeldung.com/java-combine-optional-completablefuture">Combining CompletableFuture with Optional: The Problem</a> - Baeldung's treatment of nested monads (10 min read)</p>
<p><strong>Intermediate Level:</strong>
-<a href="https://medium.com/att-israel/stacking-monads-in-functional-java-c3c8a9c9c6e">Stacking Monads in Functional Java</a> - ATT Israel Engineering team's practical examples (20 min read)</p>
<p><strong>Advanced:</strong>
-<a href="https://blog.rockthejvm.com/free-monad/">Free Monads and Monad Transformers</a> - Rock the JVM's Scala-based but Java-applicable deep dive (30 min read)</p>
<h3 id="general-fp-concepts"><a class="header" href="#general-fp-concepts">General FP Concepts</a></h3>
<p>-<a href="https://page.mi.fu-berlin.de/scravy/realworldhaskell/materialien/monad-transformers-step-by-step.pdf">Monad Transformers Step by Step</a> - Martin Grabmüller's classic paper, accessible even for Java developers (PDF, 40 min read)
-<a href="https://wiki.haskell.org/Monad_Transformers_Explained">Monad Transformer - HaskellWiki</a> - Formal definitions with clear examples
-<a href="https://www.fpcomplete.com/haskell/tutorial/monad-transformers/">What is a Monad Transformer?</a> - FP Complete's tutorial with interactive examples</p>
<h3 id="related-libraries--comparisons"><a class="header" href="#related-libraries--comparisons">Related Libraries &amp; Comparisons</a></h3>
<p>-<a href="https://github.com/aol/cyclops">Cyclops-React Transformers</a> - AOL's comprehensive Java FP library
-<a href="https://apidocs.arrow-kt.io/arrow-fx-coroutines/arrow.fx.coroutines/-resource/index.html">Arrow-kt Resource</a> - Kotlin's excellent documentation
-<a href="https://typelevel.org/cats-mtl/">Cats MTL</a> - Scala's monad transformer library (advanced)</p>
<h3 id="community--discussion"><a class="header" href="#community--discussion">Community &amp; Discussion</a></h3>
<p>-<a href="https://stackoverflow.com/questions/32579133/when-to-use-monad-transformers">Why are Monad Transformers useful?</a> - Stack Overflow discussion with practical examples
-<a href="https://www.reddit.com/r/java/comments/8qhxzv/monad_transformers_in_production_code/">Monad Transformers in Production</a> - Real-world experiences from Java developers</p>
<hr />
<p><strong>Previous:</strong> <a href="transformers/ch_intro.html">Introduction</a>
<strong>Next:</strong> <a href="transformers/eithert_transformer.html">EitherT</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="the-eithert-transformer"><a class="header" href="#the-eithert-transformer">The EitherT Transformer:</a></h1>
<h2 id="combining-monadic-effects"><a class="header" href="#combining-monadic-effects"><em>Combining Monadic Effects</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="transformers/eithert_transformer.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to combine async operations (CompletableFuture) with typed error handling (Either)</li>
<li>Building workflows that can fail with specific domain errors while remaining async</li>
<li>Using <code>fromKind</code>, <code>fromEither</code>, and <code>liftF</code> to construct EitherT values</li>
<li>Real-world order processing with validation, inventory checks, and payment processing</li>
<li>Why EitherT eliminates "callback hell" in complex async workflows</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code:</p>
</div>
<a class="admonition-anchor-link" href="transformers/eithert_transformer.html#admonition-see-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/either_t/EitherTExample.java">EitherTExample.java</a></p>
</div>
</div>
<h2 id="eithert-monad-transformer"><a class="header" href="#eithert-monad-transformer"><code>EitherT</code> Monad Transformer.</a></h2>
<p><img src="transformers/../images/puml/eithert_transformer.svg" alt="eithert_transformer.svg" /></p>
<h2 id="eithertf-l-r-combining-any-monad-f-with-eitherl-r"><a class="header" href="#eithertf-l-r-combining-any-monad-f-with-eitherl-r"><code>EitherT&lt;F, L, R&gt;</code>: Combining any Monad <code>F</code> with <code>Either&lt;L, R&gt;</code></a></h2>
<p>The <code>EitherT</code> monad transformer allows you to combine the error-handling capabilities of <code>Either&lt;L, R&gt;</code> with another outer monad <code>F</code>. It transforms a computation that results in <code>Kind&lt;F, Either&lt;L, R&gt;&gt;</code> into a single monadic structure that can be easily composed. This is particularly useful when dealing with operations that can fail (represented by <code>Left&lt;L&gt;</code>) within an effectful context <code>F</code> (like asynchronous operations using <code>CompletableFutureKind</code> or computations involving state with <code>StateKind</code>).</p>
<ul>
<li><strong><code>F</code></strong>: The witness type of the <strong>outer monad</strong> (e.g., <code>CompletableFutureKind.Witness</code>, <code>OptionalKind.Witness</code>). This monad handles the primary effect (e.g., asynchronicity, optionality).</li>
<li><strong><code>L</code></strong>: The <strong>Left type</strong> of the inner <code>Either</code>. This typically represents the <em>error</em> type for the computation or alternative result.</li>
<li><strong><code>R</code></strong>: The <strong>Right type</strong> of the inner <code>Either</code>. This typically represents the <em>success</em> value type.</li>
</ul>
<pre><code class="language-java">public record EitherT&lt;F, L, R&gt;(@NonNull Kind&lt;F, Either&lt;L, R&gt;&gt; value) { 
  /* ... static factories ... */ }
</code></pre>
<p>It holds a value of type <code>Kind&lt;F, Either&lt;L, R&gt;&gt;</code>. The real power comes from its associated type class instance, <code>EitherTMonad</code>.</p>
<p>Essentially, <code>EitherT&lt;F, L, R&gt;</code> wraps a value of type <code>Kind&lt;F, Either&lt;L, R&gt;&gt;</code>. It represents a computation within the context <code>F</code> that will eventually yield an <code>Either&lt;L, R&gt;</code>.</p>
<p>The primary goal of <code>EitherT</code> is to provide a unified <code>Monad</code> interface (specifically <code>MonadError</code> for the <code>L</code> type) for this nested structure, hiding the complexity of manually handling both the outer <code>F</code> context and the inner <code>Either</code> context.</p>
<h2 id="eithertkindf-l-r-the-witness-type"><a class="header" href="#eithertkindf-l-r-the-witness-type"><code>EitherTKind&lt;F, L, R&gt;</code>: The Witness Type</a></h2>
<p>Just like other types in the Higher-Kinded-J, <code>EitherT</code> needs a corresponding <code>Kind</code> interface to act as its witness type in generic functions. This is <code>EitherTKind&lt;F, L, R&gt;</code>.</p>
<ul>
<li>It extends <code>Kind&lt;G, R&gt;</code> where <code>G</code> (the witness for the combined monad) is <code>EitherTKind.Witness&lt;F, L&gt;</code>.</li>
<li><code>F</code> and <code>L</code> are fixed for a specific <code>EitherT</code> context, while <code>R</code> is the variable type parameter <code>A</code> in <code>Kind&lt;G, A&gt;</code>.</li>
</ul>
<p>You'll primarily interact with this type when providing type signatures or receiving results from <code>EitherTMonad</code> methods.</p>
<h2 id="eithertkindhelper"><a class="header" href="#eithertkindhelper"><code>EitherTKindHelper</code></a></h2>
<ul>
<li>Provides widen and narrow methods to safely convert between the concrete <code>EitherT&lt;F, L, R&gt;</code> and its Kind representation (<code>Kind&lt;EitherTKind&lt;F, L, ?&gt;, R&gt;</code>).</li>
</ul>
<h2 id="eithertmonadf-l-operating-on-eithert"><a class="header" href="#eithertmonadf-l-operating-on-eithert"><code>EitherTMonad&lt;F, L&gt;</code>: Operating on <code>EitherT</code></a></h2>
<ul>
<li>The EitherTMonad class implements <code>MonadError&lt;EitherTKind.Witness&lt;F, L&gt;, L&gt;</code>.</li>
</ul>
<ul>
<li>It requires a Monad<F> instance for the outer monad F to be provided during construction. This outer monad instance is used internally to handle the effects of <code>F</code>.</li>
<li>It uses <code>EITHER_T.widen</code> and <code>EITHER_T.narrow</code> internally to manage the conversion between the <code>Kind</code> and the concrete <code>EitherT</code>.</li>
<li>The error type E for MonadError is fixed to L, the 'Left' type of the inner Either. Error handling operations like <code>raiseError(L l)</code> will create an <code>EitherT</code> representing <code>F&lt;Left(l)&gt;</code>, and <code>handleErrorWith</code> allows recovering from such Left states.</li>
</ul>
<pre><code class="language-java">// Example: F = CompletableFutureKind.Witness, L = DomainError
// 1. Get the MonadError instance for the outer monad F
MonadError&lt;CompletableFutureKind.Witness, Throwable&gt; futureMonad = CompletableFutureMonad.INSTANCE;

// 2. Create the EitherTMonad, providing the outer monad instance
//    This EitherTMonad handles DomainError for the inner Either.
MonadError&lt;EitherTKind.Witness&lt;CompletableFutureKind.Witness, DomainError&gt;, DomainError&gt; eitherTMonad =
    new EitherTMonad&lt;&gt;(futureMonad);

// Now 'eitherTMonad' can be used to operate on Kind&lt;EitherTKind.Witness&lt;CompletableFutureKind.Witness, DomainError&gt;, A&gt; values.
</code></pre>
<div id="admonition-key-operations-with-_eithertmonad_" class="admonition admonish-info" role="note" aria-labelledby="admonition-key-operations-with-_eithertmonad_-title">
<div class="admonition-title">
<div id="admonition-key-operations-with-_eithertmonad_-title">
<p>Key Operations with <em>EitherTMonad</em>:</p>
</div>
<a class="admonition-anchor-link" href="transformers/eithert_transformer.html#admonition-key-operations-with-_eithertmonad_"></a>
</div>
<div>
<ul>
<li><strong><code>eitherTMonad.of(value)</code>:</strong> Lifts a pure value <code>A</code> into the <code>EitherT</code> context. Result: <code>F&lt;Right(A)&gt;</code>.</li>
<li><strong><code>eitherTMonad.map(f, eitherTKind)</code>:</strong> Applies function <code>A -&gt; B</code> to the <code>Right</code> value inside the nested structure, preserving both <code>F</code> and <code>Either</code> contexts (if Right). Result: <code>F&lt;Either&lt;L, B&gt;&gt;</code>.</li>
<li><strong><code>eitherTMonad.flatMap(f, eitherTKind)</code>:</strong> The core sequencing operation. Takes a function <code>A -&gt; Kind&lt;EitherTKind.Witness&lt;F, L&gt;, B&gt;</code> (i.e., <code>A -&gt; EitherT&lt;F, L, B&gt;</code>). It unwraps the input <code>EitherT</code>, handles the <code>F</code> context, checks the inner <code>Either</code>:
<ul>
<li>If <code>Left(l)</code>, it propagates <code>F&lt;Left(l)&gt;</code>.</li>
<li>If <code>Right(a)</code>, it applies <code>f(a)</code> to get the next <code>EitherT&lt;F, L, B&gt;</code>, and extracts its inner <code>Kind&lt;F, Either&lt;L, B&gt;&gt;</code>, effectively chaining the <code>F</code> contexts and the <code>Either</code> logic.</li>
</ul>
</li>
<li><strong><code>eitherTMonad.raiseError(errorL)</code>:</strong> Creates an <code>EitherT</code> representing a failure in the inner <code>Either</code>. Result: <code>F&lt;Left(L)&gt;</code>.</li>
<li><strong><code>eitherTMonad.handleErrorWith(eitherTKind, handler)</code>:</strong> Handles a failure <code>L</code> from the <em>inner</em> <code>Either</code>. Takes a handler <code>L -&gt; Kind&lt;EitherTKind.Witness&lt;F, L&gt;, A&gt;</code>. It unwraps the input <code>EitherT</code>, checks the inner <code>Either</code>:
<ul>
<li>If <code>Right(a)</code>, propagates <code>F&lt;Right(a)&gt;</code>.</li>
<li>If <code>Left(l)</code>, applies <code>handler(l)</code> to get a recovery <code>EitherT&lt;F, L, A&gt;</code>, and extracts its inner <code>Kind&lt;F, Either&lt;L, A&gt;&gt;</code>.</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="admonition-creating-_eithert_-instances" class="admonition admonish-note" role="note" aria-labelledby="admonition-creating-_eithert_-instances-title">
<div class="admonition-title">
<div id="admonition-creating-_eithert_-instances-title">
<p>Creating <em>EitherT</em> Instances</p>
</div>
<a class="admonition-anchor-link" href="transformers/eithert_transformer.html#admonition-creating-_eithert_-instances"></a>
</div>
<div>
<p>You typically create <code>EitherT</code> instances using its static factory methods, providing the necessary outer <code>Monad&lt;F&gt;</code> instance:</p>
<pre><code class="language-java">// Assume:
Monad&lt;OptionalKind.Witness&gt; optMonad = OptionalMonad.INSTANCE; // Outer Monad F=Optional
String errorL = "FAILED";
String successR = "OK";
Integer otherR = 123;

// 1. Lifting a pure 'Right' value: Optional&lt;Right(R)&gt;
EitherT&lt;OptionalKind.Witness, String, String&gt; etRight = EitherT.right(optMonad, successR);
// Resulting wrapped value: Optional.of(Either.right("OK"))

// 2. Lifting a pure 'Left' value: Optional&lt;Left(L)&gt;
EitherT&lt;OptionalKind.Witness, String, Integer&gt; etLeft = EitherT.left(optMonad, errorL);
// Resulting wrapped value: Optional.of(Either.left("FAILED"))

// 3. Lifting a plain Either: Optional&lt;Either(input)&gt;
Either&lt;String, String&gt; plainEither = Either.left(errorL);
EitherT&lt;OptionalKind.Witness, String, String&gt; etFromEither = EitherT.fromEither(optMonad, plainEither);
// Resulting wrapped value: Optional.of(Either.left("FAILED"))

// 4. Lifting an outer monad value F&lt;R&gt;: Optional&lt;Right(R)&gt;
Kind&lt;OptionalKind.Witness, Integer&gt; outerOptional = OPTIONAL.widen(Optional.of(otherR));
EitherT&lt;OptionalKind.Witness, String, Integer&gt; etLiftF = EitherT.liftF(optMonad, outerOptional);
// Resulting wrapped value: Optional.of(Either.right(123))

// 5. Wrapping an existing nested Kind: F&lt;Either&lt;L, R&gt;&gt;
Kind&lt;OptionalKind.Witness, Either&lt;String, String&gt;&gt; nestedKind =
    OPTIONAL.widen(Optional.of(Either.right(successR)));
EitherT&lt;OptionalKind.Witness, String, String&gt; etFromKind = EitherT.fromKind(nestedKind);
// Resulting wrapped value: Optional.of(Either.right("OK"))

// Accessing the wrapped value:
Kind&lt;OptionalKind.Witness, Either&lt;String, String&gt;&gt; wrappedValue = etRight.value();
Optional&lt;Either&lt;String, String&gt;&gt; unwrappedOptional = OPTIONAL.narrow(wrappedValue);
// unwrappedOptional is Optional.of(Either.right("OK"))
</code></pre>
</div>
</div>
<hr />
<div id="admonition-async-workflow-with-error-handling" class="admonition admonish-note" role="note" aria-labelledby="admonition-async-workflow-with-error-handling-title">
<div class="admonition-title">
<div id="admonition-async-workflow-with-error-handling-title">
<p>Async Workflow with Error Handling</p>
</div>
<a class="admonition-anchor-link" href="transformers/eithert_transformer.html#admonition-async-workflow-with-error-handling"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/either_t/EitherTExample.java">EitherTExample.java</a></li>
</ul>
<p>The most common use case for <code>EitherT</code> is combining asynchronous operations (<code>CompletableFuture</code>) with domain error handling (<code>Either</code>).  The <code>OrderWorkflowRunner</code> class provides a detailed example.</p>
<p>Here's a simplified conceptual structure based on that example:</p>
<pre><code class="language-java">public class EitherTExample {

  // --- Setup ---

  // Assume DomainError is a sealed interface for specific errors
  // Re-defining a local DomainError to avoid dependency on the full DomainError hierarchy for this isolated example.
  // In a real scenario, you would use the shared DomainError.
  record DomainError(String message) {}
  record ValidatedData(String data) {}
  record ProcessedData(String data) {}

  MonadError&lt;CompletableFutureKind.Witness, Throwable&gt; futureMonad = CompletableFutureMonad.INSTANCE;
  MonadError&lt;EitherTKind.Witness&lt;CompletableFutureKind.Witness, DomainError&gt;, DomainError&gt; eitherTMonad =
          new EitherTMonad&lt;&gt;(futureMonad);

  // --- Workflow Steps (returning Kinds) ---

  // Simulates a sync validation returning Either
  Kind&lt;EitherKind.Witness&lt;DomainError&gt;, ValidatedData&gt; validateSync(String input) {
    System.out.println("Validating synchronously...");
    if (input.isEmpty()) {
      return EITHER.widen(Either.left(new DomainError("Input empty")));
    }
    return EITHER.widen(Either.right(new ValidatedData("Validated:" + input)));
  }

  // Simulates an async processing step returning Future&lt;Either&gt;
  Kind&lt;CompletableFutureKind.Witness, Either&lt;DomainError, ProcessedData&gt;&gt; processAsync(ValidatedData vd) {
    System.out.println("Processing asynchronously for: " + vd.data());
    CompletableFuture&lt;Either&lt;DomainError, ProcessedData&gt;&gt; future =
            CompletableFuture.supplyAsync(() -&gt; {
              try {
                Thread.sleep(50);
              } catch (InterruptedException e) { /* ignore */ }
              if (vd.data().contains("fail")) {
                return Either.left(new DomainError("Processing failed"));
              }
              return Either.right(new ProcessedData("Processed:" + vd.data()));
            });
    return FUTURE.widen(future);
  }

  // Function to run the workflow for given input
  Kind&lt;CompletableFutureKind.Witness, Either&lt;DomainError, ProcessedData&gt;&gt; runWorkflow(String initialInput) {

    // Start with initial data lifted into EitherT
    Kind&lt;EitherTKind.Witness&lt;CompletableFutureKind.Witness, DomainError&gt;, String&gt; initialET = eitherTMonad.of(initialInput);

    // Step 1: Validate (Sync Either lifted into EitherT)
    Kind&lt;EitherTKind.Witness&lt;CompletableFutureKind.Witness, DomainError&gt;, ValidatedData&gt; validatedET =
            eitherTMonad.flatMap(
                    input -&gt; {
                      // Call sync step returning Kind&lt;EitherKind.Witness,...&gt;
                      // Correction 1: Use EitherKind.Witness here
                      Kind&lt;EitherKind.Witness&lt;DomainError&gt;, ValidatedData&gt; validationResult = validateSync(input);
                      // Lift the Either result into EitherT using fromEither
                      return EitherT.fromEither(futureMonad, EITHER.narrow(validationResult));
                    },
                    initialET
            );

    // Step 2: Check Inventory (Asynchronous - returns Future&lt;Either&lt;DomainError, Unit&gt;&gt;) 
    Kind&lt;EitherTKind.Witness&lt;CompletableFutureKind.Witness, DomainError&gt;, WorkflowContext&gt; inventoryET =
        eitherTMonad.flatMap( // Chain from validation result
            ctx -&gt; { // Executed only if validatedET was F&lt;Right(...)&gt;
                // Call async step -&gt; Kind&lt;CompletableFutureKind.Witness, Either&lt;DomainError, Unit&gt;&gt; 
                Kind&lt;CompletableFutureKind.Witness, Either&lt;DomainError, Unit&gt;&gt; inventoryCheckFutureKind =
                    steps.checkInventoryAsync(ctx.validatedOrder().productId(), ctx.validatedOrder().quantity());
    
                // Lift the F&lt;Either&gt; directly into EitherT using fromKind
                Kind&lt;EitherTKind.Witness&lt;CompletableFutureKind.Witness, DomainError&gt;, Unit&gt; inventoryCheckET = 
                    EitherT.fromKind(inventoryCheckFutureKind);
    
                // If inventory check resolves to Right (now Right(Unit.INSTANCE)), update context.
 
                return eitherTMonad.map(unitInstance -&gt; ctx.withInventoryChecked(), inventoryCheckET);
            },
            validatedET // Input is result of validation step
        );

    // Unwrap the final EitherT to get the underlying Future&lt;Either&gt;
    return ((EitherT&lt;CompletableFutureKind.Witness, DomainError, ProcessedData&gt;) processedET).value();
  }

  public void asyncWorkflowErrorHandlingExample(){
    // --- Workflow Definition using EitherT ---

    // Input data
    String inputData = "Data";
    String badInputData = "";
    String processingFailData = "Data-fail";

    // --- Execution ---
    System.out.println("--- Running Good Workflow ---");

    Kind&lt;CompletableFutureKind.Witness, Either&lt;DomainError, ProcessedData&gt;&gt; resultGoodKind = runWorkflow(inputData);
    System.out.println("Good Result: "+FUTURE.join(resultGoodKind));
    // Expected: Right(ProcessedData[data=Processed:Validated:Data])

    System.out.println("\n--- Running Bad Input Workflow ---");

    Kind&lt;CompletableFutureKind.Witness, Either&lt;DomainError, ProcessedData&gt;&gt; resultBadInputKind = runWorkflow(badInputData);
    System.out.println("Bad Input Result: "+ FUTURE.join(resultBadInputKind));
    // Expected: Left(DomainError[message=Input empty])

    System.out.println("\n--- Running Processing Failure Workflow ---");

    Kind&lt;CompletableFutureKind.Witness, Either&lt;DomainError, ProcessedData&gt;&gt; resultProcFailKind = runWorkflow(processingFailData);
    System.out.println("Processing Fail Result: "+FUTURE.join(resultProcFailKind));
    // Expected: Left(DomainError[message=Processing failed])

  }
  public static void main(String[] args){
    EitherTExample example = new EitherTExample();
    example.asyncWorkflowErrorHandlingExample();

  }

}

</code></pre>
<p>This example demonstrates:</p>
<ol>
<li>Instantiating <code>EitherTMonad</code> with the outer <code>CompletableFutureMonad</code>.</li>
<li>Lifting the initial value using <code>eitherTMonad.of</code>.</li>
<li>Using <code>eitherTMonad.flatMap</code> to sequence steps.</li>
<li>Lifting a synchronous <code>Either</code> result into <code>EitherT</code> using <code>EitherT.fromEither</code>.</li>
<li>Lifting an asynchronous <code>Kind&lt;F, Either&lt;L,R&gt;&gt;</code> result using <code>EitherT.fromKind</code>.</li>
<li>Automatic short-circuiting: If validation returns <code>Left</code>, the processing step is skipped.</li>
<li>Unwrapping the final <code>EitherT</code> using <code>.value()</code> to get the <code>Kind&lt;CompletableFutureKind.Witness, Either&lt;DomainError, ProcessedData&gt;&gt;</code> result.</li>
</ol>
</div>
</div>
<div id="admonition-using-_eithertmonad_-for-sequencing-and-error-handling" class="admonition admonish-note" role="note" aria-labelledby="admonition-using-_eithertmonad_-for-sequencing-and-error-handling-title">
<div class="admonition-title">
<div id="admonition-using-_eithertmonad_-for-sequencing-and-error-handling-title">
<p>Using <em>EitherTMonad</em> for Sequencing and Error Handling</p>
</div>
<a class="admonition-anchor-link" href="transformers/eithert_transformer.html#admonition-using-_eithertmonad_-for-sequencing-and-error-handling"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/order/workflow/OrderWorkflowRunner.java">OrderWorkflowRunner.java</a></li>
</ul>
<p>The primary use is chaining operations using <code>flatMap</code> and handling errors using <code>handleErrorWith</code> or related methods. The <code>OrderWorkflowRunner</code> is the best example. Let's break down a key part:</p>
<pre><code class="language-java">// --- From OrderWorkflowRunner.java ---
// Assume setup:
// F = CompletableFutureKind&lt;?&gt;
// L = DomainError
// futureMonad = CompletableFutureMonad.INSTANCE;
// eitherTMonad = new EitherTMonad&lt;&gt;(futureMonad);
// steps = new OrderWorkflowSteps(dependencies); // Contains workflow logic

// Initial Context (lifted)
WorkflowContext initialContext = WorkflowContext.start(orderData);
Kind&lt;EitherTKind.Witness&lt;CompletableFutureKind.Witness, DomainError&gt;, WorkflowContext&gt; initialET =
    eitherTMonad.of(initialContext); // F&lt;Right(initialContext)&gt;

// Step 1: Validate Order (Synchronous - returns Either)
Kind&lt;EitherTKind.Witness&lt;CompletableFutureKind.Witness, DomainError&gt;, WorkflowContext&gt; validatedET =
    eitherTMonad.flatMap( // Use flatMap on EitherTMonad
        ctx -&gt; { // Lambda receives WorkflowContext if initialET was Right
            // Call sync step -&gt; Either&lt;DomainError, ValidatedOrder&gt;
            Either&lt;DomainError, ValidatedOrder&gt; syncResultEither =
                EITHER.narrow(steps.validateOrder(ctx.initialData()));

            // Lift sync Either into EitherT: -&gt; F&lt;Either&lt;DomainError, ValidatedOrder&gt;&gt;
            Kind&lt;EitherTKind.Witness&lt;CompletableFutureKind.Witness, DomainError&gt;, ValidatedOrder&gt;
                validatedOrderET = EitherT.fromEither(futureMonad, syncResultEither);

            // If validation produced Left, map is skipped.
            // If validation produced Right(vo), map updates the context: F&lt;Right(ctx.withValidatedOrder(vo))&gt;
            return eitherTMonad.map(ctx::withValidatedOrder, validatedOrderET);
        },
        initialET // Input to the flatMap
    );

// Step 2: Check Inventory (Asynchronous - returns Future&lt;Either&lt;DomainError, Void&gt;&gt;)
Kind&lt;EitherTKind.Witness&lt;CompletableFutureKind.Witness, DomainError&gt;, WorkflowContext&gt; inventoryET =
    eitherTMonad.flatMap( // Chain from validation result
        ctx -&gt; { // Executed only if validatedET was F&lt;Right(...)&gt;
            // Call async step -&gt; Kind&lt;CompletableFutureKind.Witness, Either&lt;DomainError, Void&gt;&gt;
            Kind&lt;CompletableFutureKind.Witness, Either&lt;DomainError, Void&gt;&gt; inventoryCheckFutureKind =
                steps.checkInventoryAsync(ctx.validatedOrder().productId(), ctx.validatedOrder().quantity());

            // Lift the F&lt;Either&gt; directly into EitherT using fromKind
            Kind&lt;EitherTKind.Witness&lt;CompletableFutureKind.Witness, DomainError&gt;, Void&gt; inventoryCheckET =
                EitherT.fromKind(inventoryCheckFutureKind);

            // If inventory check resolves to Right, update context. If Left, map is skipped.
            return eitherTMonad.map(ignored -&gt; ctx.withInventoryChecked(), inventoryCheckET);
        },
        validatedET // Input is result of validation step
    );

// Step 4: Create Shipment (Asynchronous with Recovery)
Kind&lt;EitherTKind.Witness&lt;CompletableFutureKind.Witness, DomainError&gt;, WorkflowContext&gt; shipmentET =
    eitherTMonad.flatMap( // Chain from previous step
        ctx -&gt; {
            // Call async shipment step -&gt; F&lt;Either&lt;DomainError, ShipmentInfo&gt;&gt;
            Kind&lt;CompletableFutureKind.Witness, Either&lt;DomainError, ShipmentInfo&gt;&gt; shipmentAttemptFutureKind =
                steps.createShipmentAsync(ctx.validatedOrder().orderId(), ctx.validatedOrder().shippingAddress());

            // Lift into EitherT
            Kind&lt;EitherTKind.Witness&lt;CompletableFutureKind.Witness, DomainError&gt;, ShipmentInfo&gt; shipmentAttemptET =
                 EitherT.fromKind(shipmentAttemptFutureKind);

            // *** Error Handling using MonadError ***
            Kind&lt;EitherTKind.Witness&lt;CompletableFutureKind.Witness, DomainError&gt;, ShipmentInfo&gt; recoveredShipmentET =
                eitherTMonad.handleErrorWith( // Operates on the EitherT value
                    shipmentAttemptET,
                    error -&gt; { // Lambda receives DomainError if shipmentAttemptET resolves to Left(error)
                        if (error instanceof DomainError.ShippingError se &amp;&amp; "Temporary Glitch".equals(se.reason())) {
                           // Specific recoverable error: Return a *successful* EitherT
                           return eitherTMonad.of(new ShipmentInfo("DEFAULT_SHIPPING_USED"));
                        } else {
                           // Non-recoverable error: Re-raise it within EitherT
                           return eitherTMonad.raiseError(error); // Returns F&lt;Left(error)&gt;
                        }
                    });

            // Map the potentially recovered result to update context
            return eitherTMonad.map(ctx::withShipmentInfo, recoveredShipmentET);
        },
        paymentET // Assuming paymentET was the previous step
    );

// ... rest of workflow ...

// Final unwrap
// EitherT&lt;CompletableFutureKind.Witness, DomainError, FinalResult&gt; finalET = ...;
// Kind&lt;CompletableFutureKind.Witness, Either&lt;DomainError, FinalResult&gt;&gt; finalResultKind = finalET.value();
</code></pre>
<p>This demonstrates how <code>EitherTMonad.flatMap</code> sequences the steps, while <code>EitherT.fromEither</code>, <code>EitherT.fromKind</code>, and <code>eitherTMonad.of/raiseError/handleErrorWith</code> manage the lifting and error handling within the combined <code>Future&lt;Either&lt;...&gt;&gt;</code> context.</p>
</div>
</div>
<div id="admonition-key-points" class="admonition admonish-tip" role="note" aria-labelledby="admonition-key-points-title">
<div class="admonition-title">
<div id="admonition-key-points-title">
<p>Key Points:</p>
</div>
<a class="admonition-anchor-link" href="transformers/eithert_transformer.html#admonition-key-points"></a>
</div>
<div>
<p>The <code>Higher-Kinded-J</code> library simplifies the implementation and usage of concepts like monad transformers (e.g., <code>EitherT</code>) in Java precisely <em>because</em> it simulates Higher-Kinded Types (HKTs). Here's how:</p>
<ol>
<li>
<p><strong>The Core Problem Without HKTs:</strong> Java's type system doesn't allow you to directly parameterize a type by a <em>type constructor</em> like <code>List</code>, <code>Optional</code>, or <code>CompletableFuture</code>. You can write <code>List&lt;String&gt;</code>, but you cannot easily write a generic class <code>Transformer&lt;F, A&gt;</code> where <code>F</code> itself represents <em>any</em> container type (like <code>List&lt;_&gt;</code>) and <code>A</code> is the value type.
This limitation makes defining <em>general</em> monad transformers rather difficult. A monad transformer like <code>EitherT</code> needs to combine an <em>arbitrary</em> outer monad <code>F</code> with the inner <code>Either</code> monad. Without HKTs, you would typically have to:</p>
<ul>
<li>Create separate, specific transformers for each outer monad (e.g., <code>EitherTOptional</code>, <code>EitherTFuture</code>, <code>EitherTIO</code>). This leads to significant code duplication.</li>
<li>Resort to complex, often unsafe casting or reflection.</li>
<li>Write extremely verbose code manually handling the nested structure for every combination.</li>
</ul>
</li>
<li>
<p><strong>How this helps with simulating HKTs):</strong> <code>Higher-Kinded-J</code> introduces the <code>Kind&lt;F, A&gt;</code> interface. This interface, along with specific "witness types" (like <code>OptionalKind.Witness</code>, <code>CompletableFutureKind.Witness</code>, <code>EitherKind.Witness&lt;L&gt;</code>), simulates the concept of <code>F&lt;A&gt;</code>. It allows you to pass <code>F</code> (the type constructor, represented by its witness type) as a type parameter, even though Java doesn't support it natively.</p>
</li>
<li>
<p><strong>Simplifying Transformer Definition (<code>EitherT&lt;F, L, R&gt;</code>):</strong> Because we can now simulate <code>F&lt;A&gt;</code> using <code>Kind&lt;F, A&gt;</code>, we can define the <code>EitherT</code> data structure generically:</p>
<pre><code class="language-java">// Simplified from EitherT.java
public record EitherT&lt;F, L, R&gt;(@NonNull Kind&lt;F, Either&lt;L, R&gt;&gt; value)
    implements EitherTKind&lt;F, L, R&gt; { /* ... */ }
</code></pre>
<p>Here, <code>F</code> is a type parameter representing the <em>witness type</em> of the outer monad. <code>EitherT</code> doesn't need to know <em>which</em> specific monad <code>F</code> is at compile time; it just knows it holds a <code>Kind&lt;F, ...&gt;</code>. This makes the <code>EitherT</code> structure itself general-purpose.</p>
</li>
<li>
<p><strong>Simplifying Transformer Operations (<code>EitherTMonad&lt;F, L&gt;</code>):</strong> The real benefit comes with the type class instance <code>EitherTMonad</code>. This class implements <code>MonadError&lt;EitherTKind.Witness&lt;F, L&gt;, L&gt;</code>, providing the standard monadic operations (<code>map</code>, <code>flatMap</code>, <code>of</code>, <code>ap</code>, <code>raiseError</code>, <code>handleErrorWith</code>) for the combined <code>EitherT</code> structure.</p>
<p>Critically, <code>EitherTMonad</code> takes the <code>Monad&lt;F&gt;</code> instance for the <em>specific outer monad</em><code>F</code> as a constructor argument:</p>
<pre><code class="language-java">// From EitherTMonad.java
public class EitherTMonad&lt;F, L&gt; implements MonadError&lt;EitherTKind.Witness&lt;F, L&gt;, L&gt; {
    private final @NonNull Monad&lt;F&gt; outerMonad; // &lt;-- Holds the specific outer monad instance

    public EitherTMonad(@NonNull Monad&lt;F&gt; outerMonad) {
        this.outerMonad = Objects.requireNonNull(outerMonad, "Outer Monad instance cannot be null");
    }
    // ... implementation of map, flatMap etc. ...
}
</code></pre>
<p>Inside its <code>map</code>, <code>flatMap</code>, etc., implementations, <code>EitherTMonad</code> uses the provided <code>outerMonad</code> instance (via its <code>map</code> and <code>flatMap</code> methods) to handle the outer context <code>F</code>, while also managing the inner <code>Either</code> logic (checking for <code>Left</code>/<code>Right</code>, applying functions, propagating <code>Left</code>).
<strong>This is where the Higher-Kinded-J drastically simplifies things:</strong></p>
</li>
</ol>
<ul>
<li>You only need <strong>one</strong><code>EitherTMonad</code> implementation.</li>
<li>It works <strong>generically</strong> for any outer monad <code>F</code><em>for which you have a <code>Monad&lt;F&gt;</code> instance</em> (like <code>OptionalMonad</code>, <code>CompletableFutureMonad</code>, <code>IOMonad</code>, etc.).</li>
<li>The complex logic of combining the two monads' behaviours (e.g., how <code>flatMap</code> should work on <code>F&lt;Either&lt;L, R&gt;&gt;</code>) is encapsulated <em>within</em><code>EitherTMonad</code>, leveraging the simulated HKTs and the provided <code>outerMonad</code> instance.</li>
<li>As a user, you just instantiate <code>EitherTMonad</code> with the appropriate outer monad instance and then use its standard methods (<code>map</code>, <code>flatMap</code>, etc.) on your <code>EitherT</code> values, as seen in the <code>OrderWorkflowRunner</code> example. You don't need to manually handle the nesting.</li>
</ul>
<p>In essence, the HKT simulation provided by <code>Higher-Kinded-J</code> allows defining the structure (<code>EitherT</code>) and the operations (<code>EitherTMonad</code>) generically over the outer monad <code>F</code>, overcoming Java's native limitations and making monad transformers feasible and much less boilerplate-heavy than they would otherwise be.</p>
</div>
</div>
<hr />
<div id="admonition-further-reading" class="admonition admonish-tip" role="note" aria-labelledby="admonition-further-reading-title">
<div class="admonition-title">
<div id="admonition-further-reading-title">
<p>Further Reading</p>
</div>
<a class="admonition-anchor-link" href="transformers/eithert_transformer.html#admonition-further-reading"></a>
</div>
<div>
<p>Start with the <strong>Java-focused</strong> resources to see practical applications, then explore <strong>General FP concepts</strong> for deeper understanding, and finally check <strong>Related Libraries</strong> to see alternative approaches.</p>
</div>
</div>
<h3 id="java-focused-resources-1"><a class="header" href="#java-focused-resources-1">Java-Focused Resources</a></h3>
<p><strong>Beginner Level:</strong>
-<a href="https://www.baeldung.com/java-either">Error Handling with Either in Java</a> - Baeldung's introduction to Either (10 min read)
-<a href="https://www.nurkiewicz.com/2013/05/java-8-completablefuture-in-practice.html">CompletableFuture Error Handling Patterns</a> - Tomasz Nurkiewicz's comparison to traditional async error handling (15 min read)
-<a href="https://vimeo.com/113707214">Railway Oriented Programming in Java</a> - Scott Wlaschin's classic talk adapted to Java contexts (60 min watch)</p>
<p><strong>Intermediate Level:</strong>
-<a href="https://medium.com/@johnmcclean/reactive-error-handling-with-cyclops-e2e82a3e5f5">Combining Async and Error Handling in Java</a> - Real-world async error workflows (20 min read)</p>
<p><strong>Advanced:</strong>
-<a href="https://www.youtube.com/watch?v=3VSdGPQXoZ0">Type-Safe Error Handling at Scale</a> - Zalando's production experience (conference talk, 40 min)</p>
<h3 id="general-fp-concepts-1"><a class="header" href="#general-fp-concepts-1">General FP Concepts</a></h3>
<p>-<a href="https://fsharpforfunandprofit.com/rop/">Railway Oriented Programming</a> - F# for Fun and Profit's accessible explanation (20 min read)
-<a href="https://www.manning.com/books/functional-programming-in-scala">Handling Errors Without Exceptions</a> - Chapter 4 from "Functional Programming in Scala" (free excerpt)
-<a href="https://en.wikipedia.org/wiki/Either_type">Either Type - Wikipedia</a> - Formal definition and language comparisons</p>
<h3 id="related-libraries--comparisons-1"><a class="header" href="#related-libraries--comparisons-1">Related Libraries &amp; Comparisons</a></h3>
<p>-<a href="https://apidocs.arrow-kt.io/arrow-core/arrow.core/-either/index.html">Arrow Either</a> - Kotlin's excellent API design
-<a href="https://doc.rust-lang.org/std/result/">Result Type in Rust</a> - See how a systems language solves this problem</p>
<h3 id="community--discussion-1"><a class="header" href="#community--discussion-1">Community &amp; Discussion</a></h3>
<p>-<a href="https://stackoverflow.com/questions/39868580/either-vs-exceptions-in-java">Either vs Exceptions in Java</a> - Stack Overflow debate with practical insights
-<a href="https://news.ycombinator.com/item?id=15716149">Using Either in Production Java Code</a> - Hacker News discussion with war stories</p>
<hr />
<p><strong>Previous:</strong> <a href="transformers/transformers.html">Monad Transformers</a>
<strong>Next:</strong> <a href="transformers/optionalt_transformer.html">OptionalT</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="the-optionalt-transformer"><a class="header" href="#the-optionalt-transformer">The OptionalT Transformer:</a></h1>
<h2 id="combining-monadic-effects-with-javautiloptional"><a class="header" href="#combining-monadic-effects-with-javautiloptional"><em>Combining Monadic Effects with <code>java.util.Optional</code></em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="transformers/optionalt_transformer.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to integrate Java's Optional with other monadic contexts</li>
<li>Building async workflows where each step might return empty results</li>
<li>Using <code>some</code>, <code>none</code>, and <code>fromOptional</code> to construct OptionalT values</li>
<li>Creating multi-step data retrieval with graceful failure handling</li>
<li>Providing default values when optional chains result in empty</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code:</p>
</div>
<a class="admonition-anchor-link" href="transformers/optionalt_transformer.html#admonition-see-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/optional_t/OptionalTExample.java">OptionalTExample.java</a></p>
</div>
</div>
<h2 id="optionalt-monad-transformer"><a class="header" href="#optionalt-monad-transformer"><code>OptionalT</code> Monad Transformer</a></h2>
<p>The <code>OptionalT</code> monad transformer (short for Optional Transformer) is designed to combine the semantics of <code>java.util.Optional&lt;A&gt;</code> (representing a value that might be present or absent) with an arbitrary outer monad <code>F</code>. It effectively allows you to work with computations of type <code>Kind&lt;F, Optional&lt;A&gt;&gt;</code> as a single, unified monadic structure.</p>
<p>This is particularly useful when operations within an effectful context <code>F</code> (such as asynchronicity with <code>CompletableFutureKind</code>, non-determinism with <code>ListKind</code>, or dependency injection with <code>ReaderKind</code>) can also result in an absence of a value (represented by <code>Optional.empty()</code>).</p>
<h2 id="structure"><a class="header" href="#structure">Structure</a></h2>
<p><img src="transformers/../images/puml/optional_t_transformer.svg" alt="optional_t_transformer.svg" /></p>
<h2 id="optionaltf-a-the-core-data-type"><a class="header" href="#optionaltf-a-the-core-data-type"><code>OptionalT&lt;F, A&gt;</code>: The Core Data Type</a></h2>
<p><code>OptionalT&lt;F, A&gt;</code> is a record that wraps a computation yielding <code>Kind&lt;F, Optional&lt;A&gt;&gt;</code>.</p>
<pre><code class="language-java">public record OptionalT&lt;F, A&gt;(@NonNull Kind&lt;F, Optional&lt;A&gt;&gt; value)
    implements OptionalTKind&lt;F, A&gt; {
  // ... static factory methods ...
}
</code></pre>
<ul>
<li><strong><code>F</code></strong>: The witness type of the <strong>outer monad</strong> (e.g., <code>CompletableFutureKind.Witness</code>, <code>ListKind.Witness</code>). This monad encapsulates the primary effect of the computation.</li>
<li><strong><code>A</code></strong>: The type of the value that might be present within the **<code>Optional</code>, which itself is within the context of <code>F</code>.</li>
<li><strong><code>value</code></strong>: The core wrapped value of type **<code>Kind&lt;F, Optional&lt;A&gt;&gt;</code>. This represents an effectful computation <code>F</code> that, upon completion, yields a <code>java.util.Optional&lt;A&gt;</code>.</li>
</ul>
<h2 id="optionaltkindf-a-the-witness-type"><a class="header" href="#optionaltkindf-a-the-witness-type"><code>OptionalTKind&lt;F, A&gt;</code>: The Witness Type</a></h2>
<p><strong>For integration with Higher-Kinded-J's generic programming model,</strong> <code>OptionalTKind&lt;F, A&gt;</code> acts as the higher-kinded type witness.</p>
<ul>
<li><strong>It extends</strong> <code>Kind&lt;G, A&gt;</code>, where <code>G</code> (the witness for the combined <code>OptionalT</code> monad) is <code>OptionalTKind.Witness&lt;F&gt;</code>.</li>
<li><strong>The outer monad</strong> <code>F</code> is fixed for a particular <code>OptionalT</code> context, while <code>A</code> is the variable type parameter representing the value inside the <code>Optional</code>.</li>
</ul>
<pre><code class="language-java">public interface OptionalTKind&lt;F, A&gt; extends Kind&lt;OptionalTKind.Witness&lt;F&gt;, A&gt; {
  // Witness type G = OptionalTKind.Witness&lt;F&gt;
  // Value type A = A (from Optional&lt;A&gt;)
}
</code></pre>
<h2 id="optionaltkindhelper-utility-for-wrapping-and-unwrapping"><a class="header" href="#optionaltkindhelper-utility-for-wrapping-and-unwrapping"><code>OptionalTKindHelper</code>: Utility for Wrapping and Unwrapping</a></h2>
<p><code>OptionalTKindHelper</code> is a final utility class providing static methods to seamlessly convert between the concrete <code>OptionalT&lt;F, A&gt;</code> type and its <code>Kind</code> representation (<code>Kind&lt;OptionalTKind.Witness&lt;F&gt;, A&gt;</code>).</p>
<pre><code class="language-java">
public enum OptionalTKindHelper {
   
  OPTIONAL_T;
  
    // Unwraps Kind&lt;OptionalTKind.Witness&lt;F&gt;, A&gt; to OptionalT&lt;F, A&gt;
    public  &lt;F, A&gt; @NonNull OptionalT&lt;F, A&gt; narrow(
        @Nullable Kind&lt;OptionalTKind.Witness&lt;F&gt;, A&gt; kind);

    // Wraps OptionalT&lt;F, A&gt; into OptionalTKind&lt;F, A&gt;
    public  &lt;F, A&gt; @NonNull OptionalTKind&lt;F, A&gt; widen(
        @NonNull OptionalT&lt;F, A&gt; optionalT);
}
</code></pre>
<p><strong>Internally, it uses a private record</strong> <code>OptionalTHolder</code> to implement <code>OptionalTKind</code>, but this is an implementation detail.</p>
<h2 id="optionaltmonadf-operating-on-optionalt"><a class="header" href="#optionaltmonadf-operating-on-optionalt"><code>OptionalTMonad&lt;F&gt;</code>: Operating on <code>OptionalT</code></a></h2>
<p><strong>The</strong> <code>OptionalTMonad&lt;F&gt;</code> class implements <code>MonadError&lt;OptionalTKind.Witness&lt;F&gt;, Unit&gt;</code>. This provides the standard monadic operations (<code>of</code>, <code>map</code>, <code>flatMap</code>, <code>ap</code>) and error handling capabilities for the <code>OptionalT</code> structure. The error type <code>E</code> for <code>MonadError</code> is fixed to <code>Unit</code> signifying that an "error" in this context is the <code>Optional.empty()</code> state within <code>F&lt;Optional&lt;A&gt;&gt;</code>.</p>
<ul>
<li><strong>It requires a</strong> <code>Monad&lt;F&gt;</code> instance for the outer monad <code>F</code>, which must be supplied during construction. This <code>outerMonad</code> is used to manage and sequence the effects of <code>F</code>.</li>
</ul>
<pre><code class="language-java">// Example: F = CompletableFutureKind.Witness
// 1. Get the Monad instance for the outer monad F
Monad&lt;CompletableFutureKind.Witness&gt; futureMonad = CompletableFutureMonad.INSTANCE;

// 2. Create the OptionalTMonad
OptionalTMonad&lt;CompletableFutureKind.Witness&gt; optionalTFutureMonad =
    new OptionalTMonad&lt;&gt;(futureMonad);

// Now 'optionalTFutureMonad' can be used to operate on
// Kind&lt;OptionalTKind.Witness&lt;CompletableFutureKind.Witness&gt;, A&gt; values.

</code></pre>
<div id="admonition-key-operations-with-_optionaltmonad_" class="admonition admonish-info" role="note" aria-labelledby="admonition-key-operations-with-_optionaltmonad_-title">
<div class="admonition-title">
<div id="admonition-key-operations-with-_optionaltmonad_-title">
<p>Key Operations with <em>OptionalTMonad</em>:</p>
</div>
<a class="admonition-anchor-link" href="transformers/optionalt_transformer.html#admonition-key-operations-with-_optionaltmonad_"></a>
</div>
<div>
<ul>
<li><strong><code>optionalTMonad.of(value)</code></strong>: Lifts a (nullable) value <code>A</code> into the <code>OptionalT</code> context. The underlying operation is <code>r -&gt; outerMonad.of(Optional.ofNullable(value))</code>. Result: <code>OptionalT(F&lt;Optional&lt;A&gt;&gt;)</code>.</li>
<li><strong><code>optionalTMonad.map(func, optionalTKind)</code></strong>: Applies a function <code>A -&gt; B</code> to the value <code>A</code> if it's present within the <code>Optional</code> and the <code>F</code> context is successful. The transformation occurs within <code>outerMonad.map</code>. If <code>func</code> returns <code>null</code>, the result becomes <code>F&lt;Optional.empty()&gt;</code>. Result: <code>OptionalT(F&lt;Optional&lt;B&gt;&gt;)</code>.</li>
<li><strong><code>optionalTMonad.flatMap(func, optionalTKind)</code></strong>: The primary sequencing operation. It takes a function <code>A -&gt; Kind&lt;OptionalTKind.Witness&lt;F&gt;, B&gt;</code> (which effectively means <code>A -&gt; OptionalT&lt;F, B&gt;</code>). It runs the initial <code>OptionalT</code> to get <code>Kind&lt;F, Optional&lt;A&gt;&gt;</code>. Using <code>outerMonad.flatMap</code>, if this yields an <code>Optional.of(a)</code>, <code>func</code> is applied to <code>a</code> to get the next <code>OptionalT&lt;F, B&gt;</code>. The <code>value</code> of this new <code>OptionalT</code> (<code>Kind&lt;F, Optional&lt;B&gt;&gt;</code>) becomes the result. If at any point an <code>Optional.empty()</code> is encountered within <code>F</code>, it short-circuits and propagates <code>F&lt;Optional.empty()&gt;</code>. Result: <code>OptionalT(F&lt;Optional&lt;B&gt;&gt;)</code>.</li>
<li><strong><code>optionalTMonad.raiseError(error)</code></strong> (where error is <code>Unit</code>): Creates an <code>OptionalT</code> representing absence. Result: <code>OptionalT(F&lt;Optional.empty()&gt;)</code>.</li>
<li><strong><code>optionalTMonad.handleErrorWith(optionalTKind, handler)</code></strong>: Handles an empty state from the <em>inner</em> <code>Optional</code>. Takes a handler <code>Function&lt;Unit, Kind&lt;OptionalTKind.Witness&lt;F&gt;, A&gt;&gt;</code>.</li>
</ul>
</div>
</div>
<hr />
<div id="admonition-creating-_optionalt_-instances" class="admonition admonish-note" role="note" aria-labelledby="admonition-creating-_optionalt_-instances-title">
<div class="admonition-title">
<div id="admonition-creating-_optionalt_-instances-title">
<p>Creating <em>OptionalT</em> Instances</p>
</div>
<a class="admonition-anchor-link" href="transformers/optionalt_transformer.html#admonition-creating-_optionalt_-instances"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/optional_t/OptionalTExample.java">OptionalTExample.java</a></li>
</ul>
<p><code>OptionalT</code> instances are typically created using its static factory methods. These often require a <code>Monad&lt;F&gt;</code> instance for the outer monad.</p>
<pre><code class="language-java">public void createExample() {
    // --- Setup ---
    // Outer Monad F = CompletableFutureKind.Witness
    Monad&lt;CompletableFutureKind.Witness&gt; futureMonad = CompletableFutureMonad.INSTANCE;
    String presentValue = "Data";
    Integer numericValue = 123;

    // 1. `OptionalT.fromKind(Kind&lt;F, Optional&lt;A&gt;&gt; value)`
    //    Wraps an existing F&lt;Optional&lt;A&gt;&gt;.
    Kind&lt;CompletableFutureKind.Witness, Optional&lt;String&gt;&gt; fOptional =
        FUTURE.widen(CompletableFuture.completedFuture(Optional.of(presentValue)));
    OptionalT&lt;CompletableFutureKind.Witness, String&gt; ot1 = OptionalT.fromKind(fOptional);
    // Value: CompletableFuture&lt;Optional.of("Data")&gt;

    // 2. `OptionalT.some(Monad&lt;F&gt; monad, A a)`
    //    Creates an OptionalT with a present value, F&lt;Optional.of(a)&gt;.
    OptionalT&lt;CompletableFutureKind.Witness, String&gt; ot2 = OptionalT.some(futureMonad, presentValue);
    // Value: CompletableFuture&lt;Optional.of("Data")&gt;

    // 3. `OptionalT.none(Monad&lt;F&gt; monad)`
    //    Creates an OptionalT representing an absent value, F&lt;Optional.empty()&gt;.
    OptionalT&lt;CompletableFutureKind.Witness, String&gt; ot3 = OptionalT.none(futureMonad);
    // Value: CompletableFuture&lt;Optional.empty()&gt;

    // 4. `OptionalT.fromOptional(Monad&lt;F&gt; monad, Optional&lt;A&gt; optional)`
    //    Lifts a plain java.util.Optional into OptionalT, F&lt;Optional&lt;A&gt;&gt;.
    Optional&lt;Integer&gt; optInt = Optional.of(numericValue);
    OptionalT&lt;CompletableFutureKind.Witness, Integer&gt; ot4 = OptionalT.fromOptional(futureMonad, optInt);
    // Value: CompletableFuture&lt;Optional.of(123)&gt;


    Optional&lt;Integer&gt; optEmpty = Optional.empty();
    OptionalT&lt;CompletableFutureKind.Witness, Integer&gt; ot4Empty = OptionalT.fromOptional(futureMonad, optEmpty);
    // Value: CompletableFuture&lt;Optional.empty()&gt;


    // 5. `OptionalT.liftF(Monad&lt;F&gt; monad, Kind&lt;F, A&gt; fa)`
    //    Lifts an F&lt;A&gt; into OptionalT. If A is null, it becomes F&lt;Optional.empty()&gt;, otherwise F&lt;Optional.of(A)&gt;.
    Kind&lt;CompletableFutureKind.Witness, String&gt; fValue =
        FUTURE.widen(CompletableFuture.completedFuture(presentValue));
    OptionalT&lt;CompletableFutureKind.Witness, String&gt; ot5 = OptionalT.liftF(futureMonad, fValue);
    // Value: CompletableFuture&lt;Optional.of("Data   ")&gt;

    Kind&lt;CompletableFutureKind.Witness, String&gt; fNullValue =
        FUTURE.widen(CompletableFuture.completedFuture(null)); // F&lt;null&gt;
    OptionalT&lt;CompletableFutureKind.Witness, String&gt; ot5Null = OptionalT.liftF(futureMonad, fNullValue);
    // Value: CompletableFuture&lt;Optional.empty()&gt; (because the value inside F was null)


    // Accessing the wrapped value:
    Kind&lt;CompletableFutureKind.Witness, Optional&lt;String&gt;&gt; wrappedFVO = ot1.value();
    CompletableFuture&lt;Optional&lt;String&gt;&gt; futureOptional = FUTURE.narrow(wrappedFVO);
    futureOptional.thenAccept(optStr -&gt; System.out.println("ot1 result: " + optStr));
  }
</code></pre>
</div>
</div>
<div id="admonition-asynchronous-multi-step-data-retrieval" class="admonition admonish-note" role="note" aria-labelledby="admonition-asynchronous-multi-step-data-retrieval-title">
<div class="admonition-title">
<div id="admonition-asynchronous-multi-step-data-retrieval-title">
<p>Asynchronous Multi-Step Data Retrieval</p>
</div>
<a class="admonition-anchor-link" href="transformers/optionalt_transformer.html#admonition-asynchronous-multi-step-data-retrieval"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/optional_t/OptionalTExample.java">OptionalTExample.java</a></li>
</ul>
<p>Consider a scenario where you need to fetch a userLogin, then their profile, and finally their preferences. Each step is asynchronous (<code>CompletableFuture</code>) and might return an empty <code>Optional</code> if the data is not found. <code>OptionalT</code> helps manage this composition cleanly.</p>
<pre><code class="language-java">public static class OptionalTAsyncExample {

    // --- Monad Setup ---
    static final Monad&lt;CompletableFutureKind.Witness&gt; futureMonad = CompletableFutureMonad.INSTANCE;
    static final OptionalTMonad&lt;CompletableFutureKind.Witness&gt; optionalTFutureMonad =
        new OptionalTMonad&lt;&gt;(futureMonad);
    static final ExecutorService executor = Executors.newFixedThreadPool(2);

    public static Kind&lt;CompletableFutureKind.Witness, Optional&lt;User&gt;&gt; fetchUserAsync(String userId) {
      return FUTURE.widen(CompletableFuture.supplyAsync(() -&gt; {
        System.out.println("Fetching userLogin " + userId + " on " + Thread.currentThread().getName());
        try {
          TimeUnit.MILLISECONDS.sleep(50);
        } catch (InterruptedException e) { /* ignore */ }
        return "user1".equals(userId) ? Optional.of(new User(userId, "Alice")) : Optional.empty();
      }, executor));
    }

    public static Kind&lt;CompletableFutureKind.Witness, Optional&lt;UserProfile&gt;&gt; fetchProfileAsync(String userId) {
      return FUTURE.widen(CompletableFuture.supplyAsync(() -&gt; {
        System.out.println("Fetching profile for " + userId + " on " + Thread.currentThread().getName());
        try {
          TimeUnit.MILLISECONDS.sleep(50);
        } catch (InterruptedException e) { /* ignore */ }
        return "user1".equals(userId) ? Optional.of(new UserProfile(userId, "Loves HKJ")) : Optional.empty();
      }, executor));
    }

    public static Kind&lt;CompletableFutureKind.Witness, Optional&lt;UserPreferences&gt;&gt; fetchPrefsAsync(String userId) {
      return FUTURE.widen(CompletableFuture.supplyAsync(() -&gt; {
        System.out.println("Fetching preferences for " + userId + " on " + Thread.currentThread().getName());
        try {
          TimeUnit.MILLISECONDS.sleep(50);
        } catch (InterruptedException e) { /* ignore */ }
        // Simulate preferences sometimes missing even for a valid userLogin
        return "user1".equals(userId) &amp;&amp; Math.random() &gt; 0.3 ? Optional.of(new UserPreferences(userId, "dark")) : Optional.empty();
      }, executor));
    }

    // --- Service Stubs (simulating async calls returning Future&lt;Optional&lt;T&gt;&gt;) ---

    // --- Workflow using OptionalT ---
    public static OptionalT&lt;CompletableFutureKind.Witness, UserPreferences&gt; getFullUserPreferences(String userId) {
      // Start by fetching the userLogin, lifting into OptionalT
      OptionalT&lt;CompletableFutureKind.Witness, User&gt; userOT =
          OptionalT.fromKind(fetchUserAsync(userId));

      // If userLogin exists, fetch profile
      OptionalT&lt;CompletableFutureKind.Witness, UserProfile&gt; profileOT =
          OPTIONAL_T.narrow(
              optionalTFutureMonad.flatMap(
                  userLogin -&gt; OPTIONAL_T.widen(OptionalT.fromKind(fetchProfileAsync(userLogin.id()))),
                  OPTIONAL_T.widen(userOT)
              )
          );

      // If profile exists, fetch preferences
      OptionalT&lt;CompletableFutureKind.Witness, UserPreferences&gt; preferencesOT =
          OPTIONAL_T.narrow(
              optionalTFutureMonad.flatMap(
                  profile -&gt; OPTIONAL_T.widen(OptionalT.fromKind(fetchPrefsAsync(profile.userId()))),
                  OPTIONAL_T.widen(profileOT)
              )
          );
      return preferencesOT;
    }

    // Workflow with recovery / default
    public static OptionalT&lt;CompletableFutureKind.Witness, UserPreferences&gt; getPrefsWithDefault(String userId) {
      OptionalT&lt;CompletableFutureKind.Witness, UserPreferences&gt; prefsAttemptOT = getFullUserPreferences(userId);

      Kind&lt;OptionalTKind.Witness&lt;CompletableFutureKind.Witness&gt;, UserPreferences&gt; recoveredPrefsOTKind =
          optionalTFutureMonad.handleErrorWith(
              OPTIONAL_T.widen(prefsAttemptOT),
              (Unit v) -&gt; { // This lambda is called if prefsAttemptOT results in F&lt;Optional.empty()&gt;
                System.out.println("Preferences not found for " + userId + ", providing default.");
                // Lift a default preference into OptionalT
                UserPreferences defaultPrefs = new UserPreferences(userId, "default-light");
                return OPTIONAL_T.widen(OptionalT.some(futureMonad, defaultPrefs));
              }
          );
      return OPTIONAL_T.narrow(recoveredPrefsOTKind);
    }

    public static void main(String[] args) {
      System.out.println("--- Attempting to get preferences for existing userLogin (user1) ---");
      OptionalT&lt;CompletableFutureKind.Witness, UserPreferences&gt; resultUser1OT = getFullUserPreferences("user1");
      CompletableFuture&lt;Optional&lt;UserPreferences&gt;&gt; future1 =
          FUTURE.narrow(resultUser1OT.value());

      future1.whenComplete((optPrefs, ex) -&gt; {
        if (ex != null) {
          System.err.println("Error for user1: " + ex.getMessage());
        } else {
          System.out.println("User1 Preferences: " + optPrefs.map(UserPreferences::toString).orElse("NOT FOUND"));
        }
      });


      System.out.println("\n--- Attempting to get preferences for non-existing userLogin (user2) ---");
      OptionalT&lt;CompletableFutureKind.Witness, UserPreferences&gt; resultUser2OT = getFullUserPreferences("user2");
      CompletableFuture&lt;Optional&lt;UserPreferences&gt;&gt; future2 =
          FUTURE.narrow(resultUser2OT.value());

      future2.whenComplete((optPrefs, ex) -&gt; {
        if (ex != null) {
          System.err.println("Error for user2: " + ex.getMessage());
        } else {
          System.out.println("User2 Preferences: " + optPrefs.map(UserPreferences::toString).orElse("NOT FOUND (as expected)"));
        }
      });

      System.out.println("\n--- Attempting to get preferences for user1 WITH DEFAULT ---");
      OptionalT&lt;CompletableFutureKind.Witness, UserPreferences&gt; resultUser1WithDefaultOT = getPrefsWithDefault("user1");
      CompletableFuture&lt;Optional&lt;UserPreferences&gt;&gt; future3 =
          FUTURE.narrow(resultUser1WithDefaultOT.value());

      future3.whenComplete((optPrefs, ex) -&gt; {
        if (ex != null) {
          System.err.println("Error for user1 (with default): " + ex.getMessage());
        } else {
          // This will either be the fetched prefs or the default.
          System.out.println("User1 Preferences (with default): " + optPrefs.map(UserPreferences::toString).orElse("THIS SHOULD NOT HAPPEN if default works"));
        }
        // Wait for async operations to complete for demonstration
        try {
          TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
          Thread.currentThread().interrupt();
        }
        executor.shutdown();
      });
    }

    // --- Domain Model ---
    record User(String id, String name) {
    }

    record UserProfile(String userId, String bio) {
    }

    record UserPreferences(String userId, String theme) {
    }
  }
</code></pre>
<p><strong>This example demonstrates:</strong></p>
<ol>
<li><strong>Setting up</strong> <code>OptionalTMonad</code> with <code>CompletableFutureMonad</code>.</li>
<li><strong>Using</strong> <code>OptionalT.fromKind</code> to lift an existing <code>Kind&lt;F, Optional&lt;A&gt;&gt;</code> (the result of async service calls) into the <code>OptionalT</code> context.</li>
<li><strong>Sequencing operations with</strong> <code>optionalTFutureMonad.flatMap</code>. If any step in the chain (e.g., <code>fetchUserAsync</code>) results in <code>F&lt;Optional.empty()&gt;</code>, subsequent <code>flatMap</code> lambdas are short-circuited, and the overall result becomes <code>F&lt;Optional.empty()&gt;</code>.</li>
<li><strong>Using</strong> <code>handleErrorWith</code> to provide a default <code>UserPreferences</code> if the chain of operations results in an empty <code>Optional</code>.</li>
<li><strong>Finally,</strong> <code>.value()</code> is used to extract the underlying <code>Kind&lt;CompletableFutureKind.Witness, Optional&lt;UserPreferences&gt;&gt;</code> to interact with the <code>CompletableFuture</code> directly.</li>
</ol>
<p><code>OptionalT</code> simplifies managing sequences of operations where each step might not yield a value.</p>
</div>
</div>
<hr />
<div id="admonition-further-reading" class="admonition admonish-tip" role="note" aria-labelledby="admonition-further-reading-title">
<div class="admonition-title">
<div id="admonition-further-reading-title">
<p>Further Reading</p>
</div>
<a class="admonition-anchor-link" href="transformers/optionalt_transformer.html#admonition-further-reading"></a>
</div>
<div>
<p>Start with the <strong>Java-focused</strong> resources to understand Optional patterns, then explore <strong>General FP concepts</strong> for deeper understanding, and finally check <strong>Related Libraries</strong> to see alternative approaches.</p>
</div>
</div>
<h3 id="java-focused-resources-2"><a class="header" href="#java-focused-resources-2">Java-Focused Resources</a></h3>
<p><strong>Beginner Level:</strong>
-<a href="https://www.baeldung.com/java-optional">Java Optional Best Practices</a> - Comprehensive Baeldung guide (20 min read)
-<a href="https://www.nurkiewicz.com/2013/08/optional-in-java-8-cheat-sheet.html">The Mother of All Bikesheds: Optional.orElse vs orElseGet</a> - Tomasz Nurkiewicz's practical guide (10 min read)
-<a href="https://www.youtube.com/watch?v=vKVzRbsMnTQ">Java Optional - A Practical Guide</a> - Stuart Marks (Oracle) on proper Optional usage (60 min watch)</p>
<p><strong>Intermediate Level:</strong>
-<a href="https://www.baeldung.com/java-optional-chaining">Chaining Optional in Java</a> - flatMap patterns and composition (15 min read)
-<a href="https://blog.softwaremill.com/12-recipes-for-using-the-optional-class-as-its-meant-to-be-used-2da0d7f0b6a8">Optional Anti-Patterns</a> - What NOT to do (12 min read)</p>
<h3 id="general-fp-concepts-2"><a class="header" href="#general-fp-concepts-2">General FP Concepts</a></h3>
<p>-<a href="https://wiki.haskell.org/Maybe">Maybe Monad Explained</a> - Haskell's Maybe (Java's Optional equivalent)
-<a href="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/">Null References: The Billion Dollar Mistake</a> - Tony Hoare's historic talk on why Optional matters (10 min read)</p>
<h3 id="related-libraries--comparisons-2"><a class="header" href="#related-libraries--comparisons-2">Related Libraries &amp; Comparisons</a></h3>
<p>-<a href="https://github.com/google/guava/wiki/UsingAndAvoidingNullExplained">Guava's Optional</a> - Pre-Java 8 approach, still relevant
-<a href="https://kotlinlang.org/docs/null-safety.html">Kotlin Null Safety</a> - Language-level solution to the same problem</p>
<h3 id="community--discussion-2"><a class="header" href="#community--discussion-2">Community &amp; Discussion</a></h3>
<p>-<a href="https://stackoverflow.com/questions/39754106/when-to-return-optional-instead-of-throwing-an-exception">When to Return Optional vs Throw Exception</a> - Stack Overflow debate
-<a href="https://shipilev.net/jvm/anatomy-quarks/11-optional-sequential-guards/">Optional Performance Considerations</a> - Aleksey Shipilëv's JVM deep dive</p>
<hr />
<p><strong>Previous:</strong> <a href="transformers/eithert_transformer.html">EitherT</a>
<strong>Next:</strong> <a href="transformers/maybet_transformer.html">MaybeT</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="the-maybet-transformer"><a class="header" href="#the-maybet-transformer">The MaybeT Transformer:</a></h1>
<h2 id="combining-monadic-effects-with-optionality"><a class="header" href="#combining-monadic-effects-with-optionality"><em>Combining Monadic Effects with Optionality</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="transformers/maybet_transformer.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to combine Maybe's optionality with other monadic effects</li>
<li>Building workflows where operations might produce Nothing within async contexts</li>
<li>Understanding the difference between MaybeT and OptionalT</li>
<li>Using <code>just</code>, <code>nothing</code>, and <code>fromMaybe</code> to construct MaybeT values</li>
<li>Handling Nothing states with Unit as the error type in MonadError</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code:</p>
</div>
<a class="admonition-anchor-link" href="transformers/maybet_transformer.html#admonition-see-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/maybe_t/MaybeTExample.java">MaybeTExample.java</a></p>
</div>
</div>
## `MaybeT` Monad Transformer.
<p><img src="transformers/../images/puml/maybet_transformer.svg" alt="maybet_transformer.svg" /></p>
<h2 id="maybetf-a-combining-any-monad-f-with-maybea"><a class="header" href="#maybetf-a-combining-any-monad-f-with-maybea"><code>MaybeT&lt;F, A&gt;</code>: Combining Any Monad <code>F</code> with <code>Maybe&lt;A&gt;</code></a></h2>
<p>The <code>MaybeT</code> monad transformer allows you to combine the optionality of <code>Maybe&lt;A&gt;</code> (representing a value that might be
<code>Just&lt;A&gt;</code> or <code>Nothing</code>) with another outer monad <code>F</code>. It transforms a computation that results in <code>Kind&lt;F, Maybe&lt;A&gt;&gt;</code>
into a single monadic structure. This is useful for operations within an effectful context <code>F</code> (like
<code>CompletableFutureKind</code> for async operations or <code>ListKind</code> for non-deterministic computations) that can also result in
an absence of a value.</p>
<ul>
<li><strong><code>F</code></strong>: The witness type of the <strong>outer monad</strong> (e.g., <code>CompletableFutureKind.Witness</code>, <code>ListKind.Witness</code>). This
monad handles the primary effect (e.g., asynchronicity, non-determinism).</li>
<li><strong><code>A</code></strong>: The type of the value potentially held by the inner <code>Maybe</code>.</li>
</ul>
<pre><code>// From: org.higherkindedj.hkt.maybe_t.MaybeT
public record MaybeT&lt;F, A&gt;(@NonNull Kind&lt;F, Maybe&lt;A&gt;&gt; value) { 
/* ... static factories ... */ }
</code></pre>
<p><code>MaybeT&lt;F, A&gt;</code> wraps a value of type <code>Kind&lt;F, Maybe&lt;A&gt;&gt;</code>. It signifies a computation in the context of <code>F</code> that will
eventually produce a <code>Maybe&lt;A&gt;</code>. The main benefit comes from its associated type class instance, <code>MaybeTMonad</code>, which
provides monadic operations for this combined structure.</p>
<h2 id="maybetkindf-a-the-witness-type"><a class="header" href="#maybetkindf-a-the-witness-type"><code>MaybeTKind&lt;F, A&gt;</code>: The Witness Type</a></h2>
<p>Similar to other HKTs in Higher-Kinded-J, <code>MaybeT</code> uses <code>MaybeTKind&lt;F, A&gt;</code> as its witness type for use in generic
functions.</p>
<ul>
<li>It extends <code>Kind&lt;G, A&gt;</code> where <code>G</code> (the witness for the combined monad) is <code>MaybeTKind.Witness&lt;F&gt;</code>.</li>
<li><code>F</code> is fixed for a specific <code>MaybeT</code> context, while <code>A</code> is the variable type parameter.</li>
</ul>
<pre><code class="language-java">public interface MaybeTKind&lt;F, A&gt; extends Kind&lt;MaybeTKind.Witness&lt;F&gt;, A&gt; {
  // Witness type G = MaybeTKind.Witness&lt;F&gt;
  // Value type A = A (from Maybe&lt;A&gt;)
}
</code></pre>
<h2 id="maybetkindhelper"><a class="header" href="#maybetkindhelper"><code>MaybeTKindHelper</code></a></h2>
<ul>
<li>This utility class provides static <code>wrap</code> and <code>unwrap</code> methods for safe conversion between the concrete <code>MaybeT&lt;F, A&gt;</code>
and its <code>Kind</code> representation (<code>Kind&lt;MaybeTKind.Witness&lt;F&gt;, A&gt;</code>).</li>
</ul>
<pre><code class="language-java">// To wrap:
// MaybeT&lt;F, A&gt; maybeT = ...;
Kind&lt;MaybeTKind.Witness&lt;F&gt;, A&gt; kind = MAYBE_T.widen(maybeT);
// To unwrap:
MaybeT&lt;F, A&gt; unwrappedMaybeT = MAYBE_T.narrow(kind);
</code></pre>
<h2 id="maybetmonadf-operating-on-maybet"><a class="header" href="#maybetmonadf-operating-on-maybet"><code>MaybeTMonad&lt;F&gt;</code>: Operating on <code>MaybeT</code></a></h2>
<p>The <code>MaybeTMonad&lt;F&gt;</code> class implements <code>MonadError&lt;MaybeTKind.Witness&lt;F&gt;, Unit&gt;</code>. The error type <code>E</code> for <code>MonadError</code> is fixed to <code>Unit</code>, signifying that an "error" in this context is the <code>Maybe.nothing()</code> state within the <code>F&lt;Maybe&lt;A&gt;&gt;</code> structure.
<code>MaybeT</code> represents failure (or absence) as <code>Nothing</code>, which doesn't carry an error value itself.</p>
<ul>
<li>It requires a <code>Monad&lt;F&gt;</code> instance for the outer monad <code>F</code>, provided during construction. This instance is used to
manage the effects of <code>F</code>.</li>
<li>It uses <code>MaybeTKindHelper.wrap</code> and <code>MaybeTKindHelper.unwrap</code> for conversions.</li>
<li>Operations like <code>raiseError(Unit.INSTANCE)</code> will create a <code>MaybeT</code> representing <code>F&lt;Nothing&gt;</code>.
The <code>Unit.INSTANCE</code> signifies the <code>Nothing</code> state without carrying a separate error value.</li>
<li><code>handleErrorWith</code> allows "recovering" from a <code>Nothing</code> state by providing an alternative <code>MaybeT</code>. The handler function passed to <code>handleErrorWith</code> will receive <code>Unit.INSTANCE</code> if a <code>Nothing</code> state is encountered.</li>
</ul>
<pre><code class="language-java">// Example: F = CompletableFutureKind.Witness, Error type for MonadError is Unit
// 1. Get the Monad instance for the outer monad F
Monad&lt;CompletableFutureKind.Witness&gt; futureMonad = CompletableFutureMonad.INSTANCE; 

// 2. Create the MaybeTMonad, providing the outer monad instance
MonadError&lt;MaybeTKind.Witness&lt;CompletableFutureKind.Witness&gt;, Unit&gt; maybeTMonad =
    new MaybeTMonad&lt;&gt;(futureMonad);

// Now 'maybeTMonad' can be used to operate on Kind&lt;MaybeTKind.Witness&lt;CompletableFutureKind.Witness&gt;, A&gt; values.
</code></pre>
<div id="admonition-key-operations-with-_maybetmonad_" class="admonition admonish-info" role="note" aria-labelledby="admonition-key-operations-with-_maybetmonad_-title">
<div class="admonition-title">
<div id="admonition-key-operations-with-_maybetmonad_-title">
<p>Key Operations with <em>MaybeTMonad</em>:</p>
</div>
<a class="admonition-anchor-link" href="transformers/maybet_transformer.html#admonition-key-operations-with-_maybetmonad_"></a>
</div>
<div>
<ul>
<li><strong><code>maybeTMonad.of(value)</code>:</strong> Lifts a nullable value <code>A</code> into the <code>MaybeT</code> context. Result:
<code>F&lt;Maybe.fromNullable(value)&gt;</code>.</li>
<li><strong><code>maybeTMonad.map(f, maybeTKind)</code>:</strong> Applies function <code>A -&gt; B</code> to the <code>Just</code> value inside the nested structure. If
it's <code>Nothing</code>, or <code>f</code> returns <code>null</code>, it propagates <code>F&lt;Nothing&gt;</code>.</li>
<li><strong><code>maybeTMonad.flatMap(f, maybeTKind)</code>:</strong> Sequences operations. Takes <code>A -&gt; Kind&lt;MaybeTKind.Witness&lt;F&gt;, B&gt;</code>. If the
input is <code>F&lt;Just(a)&gt;</code>, it applies <code>f(a)</code> to get the next <code>MaybeT&lt;F, B&gt;</code> and extracts its <code>Kind&lt;F, Maybe&lt;B&gt;&gt;</code>. If
<code>F&lt;Nothing&gt;</code>, it propagates <code>F&lt;Nothing&gt;</code>.</li>
<li><strong><code>maybeTMonad.raiseError(Unit.INSTANCE)</code>:</strong> Creates <code>MaybeT</code> representing <code>F&lt;Nothing&gt;</code>.</li>
<li><strong><code>maybeTMonad.handleErrorWith(maybeTKind, handler)</code>:</strong> Handles a <code>Nothing</code> state. The handler
<code>Unit -&gt; Kind&lt;MaybeTKind.Witness&lt;F&gt;, A&gt;</code> is invoked with <code>null</code>.</li>
</ul>
</div>
</div>
<hr />
<div id="admonition-creating-_maybet_-instances" class="admonition admonish-note" role="note" aria-labelledby="admonition-creating-_maybet_-instances-title">
<div class="admonition-title">
<div id="admonition-creating-_maybet_-instances-title">
<p>Creating <em>MaybeT</em> Instances</p>
</div>
<a class="admonition-anchor-link" href="transformers/maybet_transformer.html#admonition-creating-_maybet_-instances"></a>
</div>
<div>
<p><code>MaybeT</code> instances are typically created using its static factory methods, often requiring the outer <code>Monad&lt;F&gt;</code>
instance:</p>
<pre><code class="language-java">public void createExample() {
    Monad&lt;OptionalKind.Witness&gt; optMonad = OptionalMonad.INSTANCE; // Outer Monad F=Optional
    String presentValue = "Hello";

    // 1. Lifting a non-null value: Optional&lt;Just(value)&gt;
    MaybeT&lt;OptionalKind.Witness, String&gt; mtJust = MaybeT.just(optMonad, presentValue);
    // Resulting wrapped value: Optional.of(Maybe.just("Hello"))

    // 2. Creating a 'Nothing' state: Optional&lt;Nothing&gt;
    MaybeT&lt;OptionalKind.Witness, String&gt; mtNothing = MaybeT.nothing(optMonad);
    // Resulting wrapped value: Optional.of(Maybe.nothing())

    // 3. Lifting a plain Maybe: Optional&lt;Maybe(input)&gt;
    Maybe&lt;Integer&gt; plainMaybe = Maybe.just(123);
    MaybeT&lt;OptionalKind.Witness, Integer&gt; mtFromMaybe = MaybeT.fromMaybe(optMonad, plainMaybe);
    // Resulting wrapped value: Optional.of(Maybe.just(123))

    Maybe&lt;Integer&gt; plainNothing = Maybe.nothing();
    MaybeT&lt;OptionalKind.Witness, Integer&gt; mtFromMaybeNothing = MaybeT.fromMaybe(optMonad, plainNothing);
    // Resulting wrapped value: Optional.of(Maybe.nothing())


    // 4. Lifting an outer monad value F&lt;A&gt;: Optional&lt;Maybe&lt;A&gt;&gt; (using fromNullable)
    Kind&lt;OptionalKind.Witness, String&gt; outerOptional = OPTIONAL.widen(Optional.of("World"));
    MaybeT&lt;OptionalKind.Witness, String&gt; mtLiftF = MaybeT.liftF(optMonad, outerOptional);
    // Resulting wrapped value: Optional.of(Maybe.just("World"))

    Kind&lt;OptionalKind.Witness, String&gt; outerEmptyOptional = OPTIONAL.widen(Optional.empty());
    MaybeT&lt;OptionalKind.Witness, String&gt; mtLiftFEmpty = MaybeT.liftF(optMonad, outerEmptyOptional);
    // Resulting wrapped value: Optional.of(Maybe.nothing())


    // 5. Wrapping an existing nested Kind: F&lt;Maybe&lt;A&gt;&gt;
    Kind&lt;OptionalKind.Witness, Maybe&lt;String&gt;&gt; nestedKind =
        OPTIONAL.widen(Optional.of(Maybe.just("Present")));
    MaybeT&lt;OptionalKind.Witness, String&gt; mtFromKind = MaybeT.fromKind(nestedKind);
    // Resulting wrapped value: Optional.of(Maybe.just("Present"))

    // Accessing the wrapped value:
    Kind&lt;OptionalKind.Witness, Maybe&lt;String&gt;&gt; wrappedValue = mtJust.value();
    Optional&lt;Maybe&lt;String&gt;&gt; unwrappedOptional = OPTIONAL.narrow(wrappedValue);
    // unwrappedOptional is Optional.of(Maybe.just("Hello"))
  }
</code></pre>
</div>
</div>
<div id="admonition-asynchronous-optional-resource-fetching" class="admonition admonish-note" role="note" aria-labelledby="admonition-asynchronous-optional-resource-fetching-title">
<div class="admonition-title">
<div id="admonition-asynchronous-optional-resource-fetching-title">
<p>Asynchronous Optional Resource Fetching</p>
</div>
<a class="admonition-anchor-link" href="transformers/maybet_transformer.html#admonition-asynchronous-optional-resource-fetching"></a>
</div>
<div>
<p>Let's consider fetching a userLogin and then their preferences, where each step is asynchronous and might not return a value.</p>
<pre><code class="language-java">public static class MaybeTAsyncExample {
  // --- Setup ---
  Monad&lt;CompletableFutureKind.Witness&gt; futureMonad = CompletableFutureMonad.INSTANCE;
  MonadError&lt;MaybeTKind.Witness&lt;CompletableFutureKind.Witness&gt;, Unit&gt; maybeTMonad =
      new MaybeTMonad&lt;&gt;(futureMonad);

  // Simulates fetching a userLogin asynchronously
  Kind&lt;CompletableFutureKind.Witness, Maybe&lt;User&gt;&gt; fetchUserAsync(String userId) {
    System.out.println("Fetching userLogin: " + userId);
    CompletableFuture&lt;Maybe&lt;User&gt;&gt; future = CompletableFuture.supplyAsync(() -&gt; {
      try {
        TimeUnit.MILLISECONDS.sleep(50);
      } catch (InterruptedException e) { /* ignore */ }
      if ("user123".equals(userId)) {
        return Maybe.just(new User(userId, "Alice"));
      }
      return Maybe.nothing();
    });
    return FUTURE.widen(future);
  }

  // Simulates fetching userLogin preferences asynchronously
  Kind&lt;CompletableFutureKind.Witness, Maybe&lt;UserPreferences&gt;&gt; fetchPreferencesAsync(String userId) {
    System.out.println("Fetching preferences for userLogin: " + userId);
    CompletableFuture&lt;Maybe&lt;UserPreferences&gt;&gt; future = CompletableFuture.supplyAsync(() -&gt; {
      try {
        TimeUnit.MILLISECONDS.sleep(30);
      } catch (InterruptedException e) { /* ignore */ }
      if ("user123".equals(userId)) {
        return Maybe.just(new UserPreferences(userId, "dark-mode"));
      }
      return Maybe.nothing(); // No preferences for other users or if userLogin fetch failed
    });
    return FUTURE.widen(future);
  }

  // --- Service Stubs (returning Future&lt;Maybe&lt;T&gt;&gt;) ---

  // Function to run the workflow for a given userId
  Kind&lt;CompletableFutureKind.Witness, Maybe&lt;UserPreferences&gt;&gt; getUserPreferencesWorkflow(String userIdToFetch) {

    // Step 1: Fetch User
    // Directly use MaybeT.fromKind as fetchUserAsync already returns F&lt;Maybe&lt;User&gt;&gt;
    Kind&lt;MaybeTKind.Witness&lt;CompletableFutureKind.Witness&gt;, User&gt; userMT =
        MAYBE_T.widen(MaybeT.fromKind(fetchUserAsync(userIdToFetch)));

    // Step 2: Fetch Preferences if User was found
    Kind&lt;MaybeTKind.Witness&lt;CompletableFutureKind.Witness&gt;, UserPreferences&gt; preferencesMT =
        maybeTMonad.flatMap(
            userLogin -&gt; { // This lambda is only called if userMT contains F&lt;Just(userLogin)&gt;
              System.out.println("User found: " + userLogin.name() + ". Now fetching preferences.");
              // fetchPreferencesAsync returns Kind&lt;CompletableFutureKind.Witness, Maybe&lt;UserPreferences&gt;&gt;
              // which is F&lt;Maybe&lt;A&gt;&gt;, so we can wrap it directly.
              return MAYBE_T.widen(MaybeT.fromKind(fetchPreferencesAsync(userLogin.id())));
            },
            userMT // Input to flatMap
        );

    // Try to recover if preferences are Nothing, but userLogin was found (conceptual)
    Kind&lt;MaybeTKind.Witness&lt;CompletableFutureKind.Witness&gt;, UserPreferences&gt; preferencesWithDefaultMT =
        maybeTMonad.handleErrorWith(preferencesMT, (Unit v) -&gt; { // Handler for Nothing
          System.out.println("Preferences not found, attempting to use default.");
          // We need userId here. For simplicity, let's assume we could get it or just return nothing.
          // This example shows returning nothing again if we can't provide a default.
          // A real scenario might try to fetch default preferences or construct one.
          return maybeTMonad.raiseError(Unit.INSTANCE); // Still Nothing, or could be MaybeT.just(defaultPrefs)
        });


    // Unwrap the final MaybeT to get the underlying Future&lt;Maybe&lt;UserPreferences&gt;&gt;
    MaybeT&lt;CompletableFutureKind.Witness, UserPreferences&gt; finalMaybeT =
        MAYBE_T.narrow(preferencesWithDefaultMT); // or preferencesMT if no recovery
    return finalMaybeT.value();
  }

  public void asyncExample() {
    System.out.println("--- Fetching preferences for known userLogin (user123) ---");
    Kind&lt;CompletableFutureKind.Witness, Maybe&lt;UserPreferences&gt;&gt; resultKnownUserKind =
        getUserPreferencesWorkflow("user123");
    Maybe&lt;UserPreferences&gt; resultKnownUser = FUTURE.join(resultKnownUserKind);
    System.out.println("Known User Result: " + resultKnownUser);
    // Expected: Just(UserPreferences[userId=user123, theme=dark-mode])

    System.out.println("\n--- Fetching preferences for unknown userLogin (user999) ---");
    Kind&lt;CompletableFutureKind.Witness, Maybe&lt;UserPreferences&gt;&gt; resultUnknownUserKind =
        getUserPreferencesWorkflow("user999");
    Maybe&lt;UserPreferences&gt; resultUnknownUser = FUTURE.join(resultUnknownUserKind);
    System.out.println("Unknown User Result: " + resultUnknownUser);
    // Expected: Nothing
  }

  // --- Workflow Definition using MaybeT ---

  // --- Domain Model ---
  record User(String id, String name) {
  }

  record UserPreferences(String userId, String theme) {
  }
}
</code></pre>
<p>This example illustrates:</p>
<ol>
<li>Setting up <code>MaybeTMonad</code> with <code>CompletableFutureMonad</code>and <code>Unit</code> as the error type.</li>
<li>Using <code>MaybeT.fromKind</code> to lift an existing <code>Kind&lt;F, Maybe&lt;A&gt;&gt;</code> into the <code>MaybeT</code> context.</li>
<li>Sequencing operations with <code>maybeTMonad.flatMap</code>. If <code>WorkspaceUserAsync</code> results in <code>F&lt;Nothing&gt;</code>, the lambda for
fetching preferences is skipped.</li>
<li>The <code>handleErrorWith</code> shows a way to potentially recover from a <code>Nothing</code> state using <code>Unit</code> in the handler and <code>raiseError(Unit.INSTANCE)</code>.</li>
<li>Finally, <code>.value()</code> is used to extract the underlying <code>Kind&lt;CompletableFutureKind.Witness, Maybe&lt;UserPreferences&gt;&gt;</code>.</li>
</ol>
</div>
</div>
<div id="admonition-key-points" class="admonition admonish-tip" role="note" aria-labelledby="admonition-key-points-title">
<div class="admonition-title">
<div id="admonition-key-points-title">
<p>Key Points:</p>
</div>
<a class="admonition-anchor-link" href="transformers/maybet_transformer.html#admonition-key-points"></a>
</div>
<div>
<ul>
<li>The <code>MaybeT</code> transformer simplifies working with nested optional values within other monadic contexts by providing a
unified monadic interface, abstracting away the manual checks and propagation of <code>Nothing</code> states.</li>
<li>When <code>MaybeTMonad</code> is used as a <code>MonadError</code>, the error type is <code>Unit</code>, indicating that the "error" (a <code>Nothing</code> state) doesn't carry a specific value beyond its occurrence.</li>
</ul>
</div>
</div>
<hr />
<h2 id="maybet-vs-optionalt-when-to-use-which"><a class="header" href="#maybet-vs-optionalt-when-to-use-which">MaybeT vs OptionalT: When to Use Which?</a></h2>
<p>Both <code>MaybeT</code> and <code>OptionalT</code> serve similar purposes: combining optionality with other monadic effects. Here's when to choose each:</p>
<h3 id="use-maybet-when"><a class="header" href="#use-maybet-when">Use <strong>MaybeT</strong> when:</a></h3>
<ul>
<li>You're working within the higher-kinded-j ecosystem and want consistency with the <code>Maybe</code> type</li>
<li>You need a type that's explicitly designed for functional composition (more FP-native)</li>
<li>You want to avoid Java's <code>Optional</code> and its quirks (e.g., serialisation warnings, identity-sensitive operations)</li>
<li>You're building a system where <code>Maybe</code> is used throughout</li>
</ul>
<h3 id="use-optionalt-when"><a class="header" href="#use-optionalt-when">Use <strong>OptionalT</strong> when:</a></h3>
<ul>
<li>You're integrating with existing Java code that uses <code>java.util.Optional</code></li>
<li>You want to leverage familiar Java 8+ Optional APIs</li>
<li>Your team is more comfortable with standard Java types</li>
<li>You're wrapping external libraries that return <code>Optional</code></li>
</ul>
<p><strong>In practice:</strong> The choice often comes down to consistency with your existing codebase. Both offer equivalent functionality through their <code>MonadError</code> instances.</p>
<hr />
<div id="admonition-further-reading" class="admonition admonish-tip" role="note" aria-labelledby="admonition-further-reading-title">
<div class="admonition-title">
<div id="admonition-further-reading-title">
<p>Further Reading</p>
</div>
<a class="admonition-anchor-link" href="transformers/maybet_transformer.html#admonition-further-reading"></a>
</div>
<div>
<p>Start with the <strong>Java-focused</strong> resources to understand Maybe/Option patterns, then explore <strong>General FP concepts</strong> for deeper understanding, and finally check <strong>Related Libraries</strong> to see alternative approaches.</p>
</div>
</div>
<h3 id="java-focused-resources-3"><a class="header" href="#java-focused-resources-3">Java-Focused Resources</a></h3>
<p><strong>Beginner Level:</strong>
-<a href="https://medium.com/@johnmcclean/maybe-monad-in-java-8-2e0b7d8e3e5a">Maybe vs Optional: Understanding the Difference</a> - When to use custom Maybe over Java's Optional (10 min read)
-<a href="https://www.baeldung.com/java-avoid-null-check">Null Handling Patterns in Modern Java</a> - Comprehensive guide to null safety (15 min read)</p>
<p><strong>Intermediate Level:</strong>
-<a href="https://bartoszmilewski.com/2013/09/10/monoids-monads-and-monad-zero/">MonadZero and Failure</a> - Understanding failure representation (20 min read)
-<a href="https://dzone.com/articles/functional-java-handling-optionals-in-completable">Handling Nothing in Asynchronous Code</a> - DZone's practical patterns (12 min read)</p>
<h3 id="general-fp-concepts-3"><a class="header" href="#general-fp-concepts-3">General FP Concepts</a></h3>
<p>-<a href="https://en.wikipedia.org/wiki/Option_type">Maybe/Option Type</a> - Wikipedia's cross-language overview
-<a href="https://learnyouahaskell.com/a-fistful-of-monads">A Fistful of Monads (Haskell)</a> - Accessible introduction to Maybe (30 min read)</p>
<h3 id="related-libraries--comparisons-3"><a class="header" href="#related-libraries--comparisons-3">Related Libraries &amp; Comparisons</a></h3>
<p>-<a href="https://www.scala-lang.org/api/2.13.3/scala/Option.html">Scala Option</a> - Scala's battle-tested implementation
-<a href="https://apidocs.arrow-kt.io/arrow-core/arrow.core/-option/index.html">Arrow Option (Kotlin)</a> - Kotlin FP approach</p>
<h3 id="community--discussion-3"><a class="header" href="#community--discussion-3">Community &amp; Discussion</a></h3>
<p>-<a href="https://stackoverflow.com/questions/48280735/maybe-vs-either-for-error-handling">Maybe vs Either for Error Handling</a> - Stack Overflow comparison
-<a href="https://www.reddit.com/r/java/comments/7t3q6k/why_implement_maybe_when_java_has_optional/">Why Use Maybe When We Have Optional?</a> - Reddit discussion on use cases</p>
<hr />
<p><strong>Previous:</strong> <a href="transformers/optionalt_transformer.html">OptionalT</a>
<strong>Next:</strong> <a href="transformers/readert_transformer.html">ReaderT</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="the-readert-transformer"><a class="header" href="#the-readert-transformer">The ReaderT Transformer:</a></h1>
<h2 id="combining-monadic-effects-with-a-read-only-environment"><a class="header" href="#combining-monadic-effects-with-a-read-only-environment"><em>Combining Monadic Effects with a Read-Only Environment</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="transformers/readert_transformer.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to combine dependency injection (Reader) with other effects like async operations</li>
<li>Building configuration-dependent workflows that are also async or failable</li>
<li>Using <code>ask</code>, <code>reader</code>, and <code>lift</code> to work with environment-dependent computations</li>
<li>Creating testable microservice clients with injected configuration</li>
<li>Managing database connections, API keys, and other contextual dependencies</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code:</p>
</div>
<a class="admonition-anchor-link" href="transformers/readert_transformer.html#admonition-see-example-code"></a>
</div>
<div>
<ul>
<li>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/reader_t/ReaderTExample.java">ReaderTExample.java</a></p>
</li>
<li>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/reader_t/ReaderTAsyncExample.java">ReaderTAsyncExample.java</a></p>
</li>
<li>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/reader_t/ReaderTAsyncUnitExample.java">ReaderTAsyncUnitExample.java</a></p>
</li>
</ul>
</div>
</div>
<h2 id="readert-monad-transformer"><a class="header" href="#readert-monad-transformer"><code>ReaderT</code> Monad Transformer</a></h2>
<p>The <code>ReaderT</code> monad transformer (short for Reader Transformer) allows you to combine the capabilities of the <code>Reader</code> monad (providing a read-only environment <code>R</code>) with another outer monad <code>F</code>. It encapsulates a computation that, given an environment <code>R</code>, produces a result within the monadic context <code>F</code> (i.e., <code>Kind&lt;F, A&gt;</code>).</p>
<p>This is particularly useful when you have operations that require some configuration or context (<code>R</code>) and also involve other effects managed by <code>F</code>, such as asynchronicity (<code>CompletableFutureKind</code>), optionality (<code>OptionalKind</code>, <code>MaybeKind</code>), or error handling (<code>EitherKind</code>).</p>
<p>The <code>ReaderT&lt;F, R, A&gt;</code> structure essentially wraps a function <code>R -&gt; Kind&lt;F, A&gt;</code>.</p>
<h2 id="structure-1"><a class="header" href="#structure-1">Structure</a></h2>
<p><img src="transformers/../images/puml/readert_transformer.svg" alt="readert_transformer.svg" /></p>
<h2 id="readertf-r-a-the-core-data-type"><a class="header" href="#readertf-r-a-the-core-data-type"><code>ReaderT&lt;F, R, A&gt;</code>: The Core Data Type</a></h2>
<p><code>ReaderT&lt;F, R, A&gt;</code> is a record that encapsulates the core computation.</p>
<pre><code class="language-java">public record ReaderT&lt;F, R, A&gt;(@NonNull Function&lt;R, Kind&lt;F, A&gt;&gt; run)
    implements ReaderTKind&lt;F, R, A&gt; {
  // ... static factory methods ...
}
</code></pre>
<ul>
<li><strong><code>F</code></strong>: The witness type of the <strong>outer monad</strong> (e.g., <code>OptionalKind.Witness</code>, <code>CompletableFutureKind.Witness</code>). This monad handles an effect such as optionality or asynchronicity.</li>
<li><strong><code>R</code></strong>: The type of the <strong>read-only environment</strong> (context or configuration) that the computation depends on.</li>
<li><strong><code>A</code></strong>: The type of the value produced by the computation, wrapped within the outer monad <code>F</code>.</li>
<li><strong><code>run</code></strong>: The essential function <code>R -&gt; Kind&lt;F, A&gt;</code>. When this function is applied to an environment of type <code>R</code>, it yields a monadic value <code>Kind&lt;F, A&gt;</code>.</li>
</ul>
<h2 id="readertkindf-r-a-the-witness-type"><a class="header" href="#readertkindf-r-a-the-witness-type"><code>ReaderTKind&lt;F, R, A&gt;</code>: The Witness Type</a></h2>
<p>To integrate with Higher-Kinded-J's generic programming capabilities, <code>ReaderTKind&lt;F, R, A&gt;</code> serves as the witness type.</p>
<ul>
<li>It extends <code>Kind&lt;G, A&gt;</code>, where <code>G</code> (the witness for the combined <code>ReaderT</code> monad) is <code>ReaderTKind.Witness&lt;F, R&gt;</code>.</li>
<li>The types <code>F</code> (outer monad) and <code>R</code> (environment) are fixed for a specific <code>ReaderT</code> context, while <code>A</code> is the variable value type.</li>
</ul>
<pre><code class="language-java">public interface ReaderTKind&lt;F, R, A&gt; extends Kind&lt;ReaderTKind.Witness&lt;F, R&gt;, A&gt; {
  // Witness type G = ReaderTKind.Witness&lt;F, R&gt;
  // Value type A = A
}
</code></pre>
<h2 id="readertkindhelper-utility-for-wrapping-and-unwrapping"><a class="header" href="#readertkindhelper-utility-for-wrapping-and-unwrapping"><code>ReaderTKindHelper</code>: Utility for Wrapping and Unwrapping</a></h2>
<p><code>ReaderTKindHelper</code> provides READER_T enum essential utility methods to convert between the concrete <code>ReaderT&lt;F, R, A&gt;</code> type and its <code>Kind</code> representation (<code>Kind&lt;ReaderTKind.Witness&lt;F, R&gt;, A&gt;</code>).</p>
<pre><code class="language-java">public enum ReaderTKindHelper {
   READER_T;
  
    // Unwraps Kind&lt;ReaderTKind.Witness&lt;F, R&gt;, A&gt; to ReaderT&lt;F, R, A&gt;
    public &lt;F, R, A&gt; @NonNull ReaderT&lt;F, R, A&gt; narrow(
        @Nullable Kind&lt;ReaderTKind.Witness&lt;F, R&gt;, A&gt; kind);

    // Wraps ReaderT&lt;F, R, A&gt; into ReaderTKind&lt;F, R, A&gt;
    public &lt;F, R, A&gt; @NonNull ReaderTKind&lt;F, R, A&gt; widen(
        @NonNull ReaderT&lt;F, R, A&gt; readerT);
}
</code></pre>
<h2 id="readertmonadf-r-operating-on-readert"><a class="header" href="#readertmonadf-r-operating-on-readert"><code>ReaderTMonad&lt;F, R&gt;</code>: Operating on <code>ReaderT</code></a></h2>
<p>The <code>ReaderTMonad&lt;F, R&gt;</code> class implements the <code>Monad&lt;ReaderTKind.Witness&lt;F, R&gt;&gt;</code> interface, providing the standard monadic operations (<code>of</code>, <code>map</code>, <code>flatMap</code>, <code>ap</code>) for the <code>ReaderT</code> structure.</p>
<ul>
<li>It requires a <code>Monad&lt;F&gt;</code> instance for the outer monad <code>F</code> to be provided during its construction. This <code>outerMonad</code> is used internally to sequence operations within the <code>F</code> context.</li>
<li><code>R</code> is the fixed environment type for this monad instance.</li>
</ul>
<pre><code class="language-java">// Example: F = OptionalKind.Witness, R = AppConfig
// 1. Get the Monad instance for the outer monad F
OptionalMonad optionalMonad = OptionalMonad.INSTANCE;

// 2. Define your environment type
record AppConfig(String apiKey) {}

// 3. Create the ReaderTMonad
ReaderTMonad&lt;OptionalKind.Witness, AppConfig&gt; readerTOptionalMonad =
    new ReaderTMonad&lt;&gt;(optionalMonad);

// Now 'readerTOptionalMonad' can be used to operate on 
// Kind&lt;ReaderTKind.Witness&lt;OptionalKind.Witness, AppConfig&gt;, A&gt; values.
</code></pre>
<div id="admonition-key-operations-with-_readertmonad_" class="admonition admonish-info" role="note" aria-labelledby="admonition-key-operations-with-_readertmonad_-title">
<div class="admonition-title">
<div id="admonition-key-operations-with-_readertmonad_-title">
<p>Key Operations with <em>ReaderTMonad</em></p>
</div>
<a class="admonition-anchor-link" href="transformers/readert_transformer.html#admonition-key-operations-with-_readertmonad_"></a>
</div>
<div>
<ul>
<li><strong><code>readerTMonad.of(value)</code></strong>: Lifts a pure value <code>A</code> into the <code>ReaderT</code> context. The underlying function becomes <code>r -&gt; outerMonad.of(value)</code>. Result: <code>ReaderT(r -&gt; F&lt;A&gt;)</code>.</li>
<li><strong><code>readerTMonad.map(func, readerTKind)</code></strong>: Applies a function <code>A -&gt; B</code> to the value <code>A</code> inside the <code>ReaderT</code> structure, if present and successful within the <code>F</code> context. The transformation <code>A -&gt; B</code> happens within the <code>outerMonad.map</code> call. Result: <code>ReaderT(r -&gt; F&lt;B&gt;)</code>.</li>
<li><strong><code>readerTMonad.flatMap(func, readerTKind)</code></strong>: The core sequencing operation. Takes a function <code>A -&gt; Kind&lt;ReaderTKind.Witness&lt;F, R&gt;, B&gt;</code> (which is effectively <code>A -&gt; ReaderT&lt;F, R, B&gt;</code>). It runs the initial <code>ReaderT</code> with the environment <code>R</code> to get <code>Kind&lt;F, A&gt;</code>. Then, it uses <code>outerMonad.flatMap</code> to process this. If <code>Kind&lt;F, A&gt;</code> yields an <code>A</code>, <code>func</code> is applied to <code>a</code> to get a new <code>ReaderT&lt;F, R, B&gt;</code>. This new <code>ReaderT</code> is then also run with the <em>same original environment</em><code>R</code> to yield <code>Kind&lt;F, B&gt;</code>. This allows composing computations that all depend on the same environment <code>R</code> while also managing the effects of <code>F</code>. Result: <code>ReaderT(r -&gt; F&lt;B&gt;)</code>.</li>
</ul>
</div>
</div>
<div id="admonition-creating-_readert_-instances" class="admonition admonish-note" role="note" aria-labelledby="admonition-creating-_readert_-instances-title">
<div class="admonition-title">
<div id="admonition-creating-_readert_-instances-title">
<p>Creating <em>ReaderT</em> Instances</p>
</div>
<a class="admonition-anchor-link" href="transformers/readert_transformer.html#admonition-creating-_readert_-instances"></a>
</div>
<div>
<p>You typically create <code>ReaderT</code> instances using its static factory methods. These methods often require an instance of <code>Monad&lt;F&gt;</code> for the outer monad.</p>
<pre><code class="language-java"> public void createExample(){
  // --- Setup ---
  // Outer Monad F = OptionalKind.Witness
  OptionalMonad optMonad = OptionalMonad.INSTANCE;

  // Environment Type R
  record Config(String setting) {
  }
  Config testConfig = new Config("TestValue");

  // --- Factory Methods ---

  // 1. `ReaderT.of(Function&lt;R, Kind&lt;F, A&gt;&gt; runFunction)`
  //    Constructs directly from the R -&gt; F&lt;A&gt; function.
  Function&lt;Config, Kind&lt;OptionalKind.Witness, String&gt;&gt; runFn1 =
      cfg -&gt; OPTIONAL.widen(Optional.of("Data based on " + cfg.setting()));
  ReaderT&lt;OptionalKind.Witness, Config, String&gt; rt1 = ReaderT.of(runFn1);
  // To run: OPTIONAL.narrow(rt1.run().apply(testConfig)) is Optional.of("Data based on TestValue")
  System.out.println(OPTIONAL.narrow(rt1.run().apply(testConfig)));

  // 2. `ReaderT.lift(Monad&lt;F&gt; outerMonad, Kind&lt;F, A&gt; fa)`
  //    Lifts an existing monadic value `Kind&lt;F, A&gt;` into ReaderT.
  //    The resulting ReaderT ignores the environment R and always returns `fa`.
  Kind&lt;OptionalKind.Witness, Integer&gt; optionalValue = OPTIONAL.widen(Optional.of(123));
  ReaderT&lt;OptionalKind.Witness, Config, Integer&gt; rt2 = ReaderT.lift(optMonad, optionalValue);
  // To run: OPTIONAL.narrow(rt2.run().apply(testConfig)) is Optional.of(123)
  System.out.println(OPTIONAL.narrow(rt2.run().apply(testConfig)));

  Kind&lt;OptionalKind.Witness, Integer&gt; emptyOptional = OPTIONAL.widen(Optional.empty());
  ReaderT&lt;OptionalKind.Witness, Config, Integer&gt; rt2Empty = ReaderT.lift(optMonad, emptyOptional);
  // To run: OPTIONAL.narrow(rt2Empty.run().apply(testConfig)) is Optional.empty()


  // 3. `ReaderT.reader(Monad&lt;F&gt; outerMonad, Function&lt;R, A&gt; f)`
  //    Creates a ReaderT from a function R -&gt; A. The result A is then lifted into F using outerMonad.of(A).
  Function&lt;Config, String&gt; simpleReaderFn = cfg -&gt; "Hello from " + cfg.setting();
  ReaderT&lt;OptionalKind.Witness, Config, String&gt; rt3 = ReaderT.reader(optMonad, simpleReaderFn);
  // To run: OPTIONAL.narrow(rt3.run().apply(testConfig)) is Optional.of("Hello from TestValue")
  System.out.println(OPTIONAL.narrow(rt3.run().apply(testConfig)));

  // 4. `ReaderT.ask(Monad&lt;F&gt; outerMonad)`
  //    Creates a ReaderT that, when run, provides the environment R itself as the result, lifted into F.
  //    The function is r -&gt; outerMonad.of(r).
  ReaderT&lt;OptionalKind.Witness, Config, Config&gt; rt4 = ReaderT.ask(optMonad);
  // To run: OPTIONAL.narrow(rt4.run().apply(testConfig)) is Optional.of(new Config("TestValue"))
  System.out.println(OPTIONAL.narrow(rt4.run().apply(testConfig)));

  // --- Using ReaderTKindHelper.READER_T to widen/narrow for Monad operations ---
  //    Avoid a cast with var ReaderTKind&lt;OptionalKind.Witness, Config, String&gt; kindRt1 =
  //        (ReaderTKind&lt;OptionalKind.Witness, Config, String&gt;) READER_T.widen(rt1);
  var kindRt1 = READER_T.widen(rt1);
  ReaderT&lt;OptionalKind.Witness, Config, String&gt; unwrappedRt1 = READER_T.narrow(kindRt1);
}
</code></pre>
</div>
</div>
<div id="admonition-example-readert-for-actions-returning-unit" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-readert-for-actions-returning-unit-title">
<div class="admonition-title">
<div id="admonition-example-readert-for-actions-returning-unit-title">
<p>Example: <code>ReaderT</code> for Actions Returning <code>Unit</code></p>
</div>
<a class="admonition-anchor-link" href="transformers/readert_transformer.html#admonition-example-readert-for-actions-returning-unit"></a>
</div>
<div>
<p>Sometimes, a computation dependent on an environment <code>R</code> and involving an outer monad <code>F</code> might perform an action (e.g., logging, initializing a resource, sending a fire-and-forget message) without producing a specific data value. In such cases, the result type <code>A</code> of <code>ReaderT&lt;F, R, A&gt;</code> can be <code>org.higherkindedj.hkt.Unit</code>.</p>
<p>Let's extend the asynchronous example to include an action that logs a message using the <code>AppConfig</code> and completes asynchronously, returning <code>Unit</code>.</p>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/reader_t/ReaderTAsyncUnitExample.java">ReaderTAsyncUnitExample.java</a></li>
</ul>
<pre><code class="language-java">    // Action: Log a message using AppConfig, complete asynchronously returning F&lt;Unit&gt;
    public static Kind&lt;CompletableFutureKind.Witness, Unit&gt; logInitialisationAsync(AppConfig config) {
        CompletableFuture&lt;Unit&gt; future = CompletableFuture.runAsync(() -&gt; {
            System.out.println("Thread: " + Thread.currentThread().getName() +
                " - Initialising component with API Key: " + config.apiKey() +
                " for Service URL: " + config.serviceUrl());
            // Simulate some work
            try {
                TimeUnit.MILLISECONDS.sleep(50);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                throw new RuntimeException(e);
            }
            System.out.println("Thread: " + Thread.currentThread().getName() +
                " - Initialisation complete for: " + config.serviceUrl());
        }, config.executor()).thenApply(v -&gt; Unit.INSTANCE); // Ensure CompletableFuture&lt;Unit&gt;
        return FUTURE.widen(future);
    }

    // Wrap the action in ReaderT: R -&gt; F&lt;Unit&gt;
    public static ReaderT&lt;CompletableFutureKind.Witness, AppConfig, Unit&gt; initialiseComponentRT() {
        return ReaderT.of(ReaderTAsyncUnitExample::logInitialisationAsync);
    }

    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(2);
        AppConfig prodConfig = new AppConfig("prod_secret_for_init", "[https://init.prod.service](https://init.prod.service)", executor);

        // Get the ReaderT for the initialisation action
        ReaderT&lt;CompletableFutureKind.Witness, AppConfig, Unit&gt; initAction = initialiseComponentRT();

        System.out.println("--- Running Initialisation Action with Prod Config ---");
        // Run the action by providing the prodConfig environment
        // This returns Kind&lt;CompletableFutureKind.Witness, Unit&gt;
        Kind&lt;CompletableFutureKind.Witness, Unit&gt; futureUnit = initAction.run().apply(prodConfig);

        // Wait for completion and get the Unit result (which is just Unit.INSTANCE)
        Unit result = FUTURE.join(futureUnit);
        System.out.println("Initialisation Result: " + result); // Expected: Initialisation Result: ()

        executor.shutdown();
        try {
            if (!executor.awaitTermination(5, TimeUnit.SECONDS)) {
                executor.shutdownNow();
            }
        } catch (InterruptedException e) {
            executor.shutdownNow();
            Thread.currentThread().interrupt();
        }
    }
</code></pre>
<p>This example illustrates:</p>
<ul>
<li>An asynchronous action (<code>logInitialisationAsync</code>) that depends on <code>AppConfig</code> but logically returns no specific data, so its result is <code>CompletableFuture&lt;Unit&gt;</code>.</li>
<li>This action is wrapped into a <code>ReaderT&lt;CompletableFutureKind.Witness, AppConfig, Unit&gt;</code>.</li>
<li>When this <code>ReaderT</code> is run with an <code>AppConfig</code>, it yields a <code>Kind&lt;CompletableFutureKind.Witness, Unit&gt;</code>.</li>
<li>The final result of joining such a future is <code>Unit.INSTANCE</code>, signifying successful completion of the effectful, environment-dependent action.</li>
</ul>
</div>
</div>
<div id="admonition-example-configuration-dependent-asynchronous-service-calls" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-configuration-dependent-asynchronous-service-calls-title">
<div class="admonition-title">
<div id="admonition-example-configuration-dependent-asynchronous-service-calls-title">
<p>Example: Configuration-Dependent Asynchronous Service Calls</p>
</div>
<a class="admonition-anchor-link" href="transformers/readert_transformer.html#admonition-example-configuration-dependent-asynchronous-service-calls"></a>
</div>
<div>
<p>Let's illustrate <code>ReaderT</code> by combining an environment dependency (<code>AppConfig</code>) with an asynchronous operation (<code>CompletableFuture</code>).</p>
<pre><code class="language-java">
public class ReaderTAsyncExample {
  // --- Monad Setup ---
  // Outer Monad F = CompletableFutureKind.Witness
  static final Monad&lt;CompletableFutureKind.Witness&gt; futureMonad = CompletableFutureMonad.INSTANCE;
  // ReaderTMonad for AppConfig and CompletableFutureKind
  static final ReaderTMonad&lt;CompletableFutureKind.Witness, AppConfig&gt; cfReaderTMonad =
      new ReaderTMonad&lt;&gt;(futureMonad);

  // Simulates an async call to an external service
  public static Kind&lt;CompletableFutureKind.Witness, ServiceData&gt; fetchExternalData(AppConfig config, String itemId) {
    System.out.println("Thread: " + Thread.currentThread().getName() + " - Fetching external data for " + itemId + " using API key: " + config.apiKey() + " from " + config.serviceUrl());
    CompletableFuture&lt;ServiceData&gt; future = CompletableFuture.supplyAsync(() -&gt; {
      try {
        TimeUnit.MILLISECONDS.sleep(100); // Simulate network latency
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        throw new RuntimeException(e);
      }
      return new ServiceData("Raw data for " + itemId + " from " + config.serviceUrl());
    }, config.executor());
    return FUTURE.widen(future);
  }

  // Operation 1: Fetch data, wrapped in ReaderT
  // This is R -&gt; F&lt;A&gt; which is the core of ReaderT
  public static ReaderT&lt;CompletableFutureKind.Witness, AppConfig, ServiceData&gt; fetchServiceDataRT(String itemId) {
    return ReaderT.of(appConfig -&gt; fetchExternalData(appConfig, itemId));
  }

  // Operation 2: Process data (sync part, depends on AppConfig, then lifts to ReaderT)
  // This uses ReaderT.reader: R -&gt; A, then A is lifted to F&lt;A&gt;
  public static ReaderT&lt;CompletableFutureKind.Witness, AppConfig, ProcessedData&gt; processDataRT(ServiceData sData) {
    return ReaderT.reader(futureMonad, // Outer monad to lift the result
        appConfig -&gt; { // Function R -&gt; A (Config -&gt; ProcessedData)
          System.out.println("Thread: " + Thread.currentThread().getName() + " - Processing data with config: " + appConfig.apiKey());
          return new ProcessedData("Processed: " + sData.rawData().toUpperCase() + " (API Key Suffix: " + appConfig.apiKey().substring(Math.max(0, appConfig.apiKey().length() - 3)) + ")");
        });
  }


  // --- Service Logic (depends on AppConfig, returns Future&lt;ServiceData&gt;) ---

  public static void main(String[] args) throws Exception {
    ExecutorService executor = Executors.newFixedThreadPool(2);
    AppConfig prodConfig = new AppConfig("prod_secret_key_xyz", "https://api.prod.example.com", executor);
    AppConfig stagingConfig = new AppConfig("stag_test_key_123", "https://api.staging.example.com", executor);

    // --- Composing with ReaderTMonad.flatMap ---
    // Define a workflow: fetch data, then process it.
    // The AppConfig is threaded through automatically by ReaderT.
    Kind&lt;ReaderTKind.Witness&lt;CompletableFutureKind.Witness, AppConfig&gt;, ProcessedData&gt; workflowRTKind =
        cfReaderTMonad.flatMap(
            serviceData -&gt; READER_T.widen(processDataRT(serviceData)), // ServiceData -&gt; ReaderTKind&lt;..., ProcessedData&gt;
            READER_T.widen(fetchServiceDataRT("item123")) // Initial ReaderTKind&lt;..., ServiceData&gt;
        );

    // Unwrap to the concrete ReaderT to run it
    ReaderT&lt;CompletableFutureKind.Witness, AppConfig, ProcessedData&gt; composedWorkflow =
        READER_T.narrow(workflowRTKind);

    // --- Running the workflow with different configurations ---

    System.out.println("--- Running with Production Config ---");
    // Run the workflow by providing the 'prodConfig' environment
    // This returns Kind&lt;CompletableFutureKind.Witness, ProcessedData&gt;
    Kind&lt;CompletableFutureKind.Witness, ProcessedData&gt; futureResultProd = composedWorkflow.run().apply(prodConfig);
    ProcessedData resultProd = FUTURE.join(futureResultProd); // Blocks for result
    System.out.println("Prod Result: " + resultProd);
    // Expected output will show "prod_secret_key_xyz", "[https://api.prod.example.com](https://api.prod.example.com)" in logs
    // and "Processed: RAW DATA FOR ITEM123 FROM [https://api.prod.example.com](https://api.prod.example.com) (API Key Suffix: xyz)"


    System.out.println("\n--- Running with Staging Config ---");
    // Run the same workflow with 'stagingConfig'
    Kind&lt;CompletableFutureKind.Witness, ProcessedData&gt; futureResultStaging = composedWorkflow.run().apply(stagingConfig);
    ProcessedData resultStaging = FUTURE.join(futureResultStaging); // Blocks for result
    System.out.println("Staging Result: " + resultStaging);
    // Expected output will show "stag_test_key_123", "[https://api.staging.example.com](https://api.staging.example.com)" in logs
    // and "Processed: RAW DATA FOR ITEM123 FROM [https://api.staging.example.com](https://api.staging.example.com) (API Key Suffix: 123)"


    // --- Another example: Using ReaderT.ask ---
    ReaderT&lt;CompletableFutureKind.Witness, AppConfig, AppConfig&gt; getConfigSettingRT =
        ReaderT.ask(futureMonad); // Provides the whole AppConfig

    Kind&lt;ReaderTKind.Witness&lt;CompletableFutureKind.Witness, AppConfig&gt;, String&gt; getServiceUrlRT =
        cfReaderTMonad.map(
            (AppConfig cfg) -&gt; "Service URL from ask: " + cfg.serviceUrl(),
            READER_T.widen(getConfigSettingRT)
        );

    String stagingServiceUrl = FUTURE.join(
        READER_T.narrow(getServiceUrlRT).run().apply(stagingConfig)
    );
    System.out.println("\nStaging Service URL via ask: " + stagingServiceUrl);


    executor.shutdown();
    try {
      if (!executor.awaitTermination(5, TimeUnit.SECONDS)) {
        executor.shutdownNow();
      }
    } catch (InterruptedException e) {
      executor.shutdownNow();
      Thread.currentThread().interrupt();
    }
  }

  // --- ReaderT-based Service Operations ---

  // --- Environment ---
  record AppConfig(String apiKey, String serviceUrl, ExecutorService executor) {
  }

  // --- Service Response ---
  record ServiceData(String rawData) {
  }

  record ProcessedData(String info) {
  }
}
</code></pre>
<p><strong>This</strong> example demonstrates:</p>
<ol>
<li>Defining an <code>AppConfig</code> environment.</li>
<li>Creating service operations (<code>WorkspaceServiceDataRT</code>, <code>processDataRT</code>) that return <code>ReaderT&lt;CompletableFutureKind, AppConfig, A&gt;</code>. These operations implicitly depend on <code>AppConfig</code>.</li>
<li>Using <code>cfReaderTMonad.flatMap</code> to chain these operations. The <code>AppConfig</code> is passed implicitly through the chain.</li>
<li>Executing the composed workflow (<code>composedWorkflow.run().apply(config)</code>) by providing a specific <code>AppConfig</code>. This "injects" the dependency at the very end.</li>
<li>The asynchronicity from <code>CompletableFuture</code> is handled by the <code>futureMonad</code> within <code>ReaderTMonad</code> and <code>ReaderT</code>'s factories.</li>
<li>Using <code>ReaderT.ask</code> to directly access the configuration within a <code>ReaderT</code> computation.</li>
</ol>
</div>
</div>
<div id="admonition-key-points" class="admonition admonish-tip" role="note" aria-labelledby="admonition-key-points-title">
<div class="admonition-title">
<div id="admonition-key-points-title">
<p>Key Points:</p>
</div>
<a class="admonition-anchor-link" href="transformers/readert_transformer.html#admonition-key-points"></a>
</div>
<div>
<p><code>ReaderT</code> simplifies managing computations that require a shared, read-only environment while also dealing with other monadic effects, leading to cleaner, more composable, and testable code by deferring environment injection.</p>
</div>
</div>
<hr />
<div id="admonition-further-reading" class="admonition admonish-tip" role="note" aria-labelledby="admonition-further-reading-title">
<div class="admonition-title">
<div id="admonition-further-reading-title">
<p>Further Reading</p>
</div>
<a class="admonition-anchor-link" href="transformers/readert_transformer.html#admonition-further-reading"></a>
</div>
<div>
<p>Start with the <strong>Java-focused</strong> resources to understand dependency injection patterns, then explore <strong>General FP concepts</strong> for deeper understanding, and finally check <strong>Related Libraries</strong> to see alternative approaches.</p>
</div>
</div>
<h3 id="java-focused-resources-4"><a class="header" href="#java-focused-resources-4">Java-Focused Resources</a></h3>
<p><strong>Beginner Level:</strong>
-<a href="https://www.baeldung.com/java-dependency-injection-functional">Dependency Injection the Functional Way</a> - Baeldung's introduction to Reader (15 min read)
-<a href="https://medium.com/@johnmcclean/reader-monad-for-dependency-injection-in-java-9056d9501c75">Reader Monad for Dependency Injection</a> - Practical examples without frameworks (12 min read)
-<a href="https://www.youtube.com/watch?v=ZasXwtTRkio">Functional Dependency Injection</a> - Conference talk on Reader pattern (40 min watch)</p>
<p><strong>Intermediate Level:</strong>
-<a href="https://blog.rockthejvm.com/reader-monad/">Configuration as Code with Reader</a> - Rock the JVM's practical guide (20 min read)
-<a href="https://medium.com/@olxc/reader-monad-for-dependency-injection-4c5700c4c148">Reader vs Dependency Injection Frameworks</a> - When to use what (15 min read)</p>
<p><strong>Advanced:</strong>
-<a href="https://www.fpcomplete.com/blog/readert-design-pattern/">ReaderT Design Pattern</a> - FP Complete's production patterns (30 min read)</p>
<h3 id="general-fp-concepts-4"><a class="header" href="#general-fp-concepts-4">General FP Concepts</a></h3>
<p>-<a href="https://wiki.haskell.org/Reader_monad">Reader Monad Explained</a> - HaskellWiki's clear explanation
-<a href="https://en.wikipedia.org/wiki/Environment_passing_style">Environment Passing Style</a> - Wikipedia on the underlying concept
-<a href="https://bartoszmilewski.com/2014/01/14/functors-are-containers/">Functions as Context</a> - Bartosz Milewski's blog on function contexts</p>
<h3 id="related-libraries--comparisons-4"><a class="header" href="#related-libraries--comparisons-4">Related Libraries &amp; Comparisons</a></h3>
<p>-<a href="https://typelevel.org/cats/datatypes/kleisli.html">Cats Reader</a> - Scala's implementation (called Kleisli)
-<a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader.html">Haskell's ReaderT</a> - Original inspiration</p>
<h3 id="community--discussion-4"><a class="header" href="#community--discussion-4">Community &amp; Discussion</a></h3>
<p>-<a href="https://stackoverflow.com/questions/14301361/why-is-the-reader-monad-useful">Reader Monad vs Constructor Injection</a> - Stack Overflow debate
-<a href="https://www.reddit.com/r/functionalprogramming/comments/5qvzwq/reader_monad_in_production/">Using Reader in Production</a> - Real-world experiences
-<a href="https://news.ycombinator.com/item?id=16743608">ReaderT Pattern at Scale</a> - HN discussion from production teams</p>
<hr />
<p><strong>Previous:</strong> <a href="transformers/maybet_transformer.html">MaybeT</a>
<strong>Next:</strong> <a href="transformers/statet_transformer.html">StateT</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="the-statet-transformer"><a class="header" href="#the-statet-transformer">The StateT Transformer:</a></h1>
<h2 id="monad-transformer"><a class="header" href="#monad-transformer"><em>Monad Transformer</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="transformers/statet_transformer.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to add stateful computation to any existing monad</li>
<li>Building stack operations that can fail (StateT with Optional)</li>
<li>Understanding the relationship between State and StateT&lt;S, Identity, A&gt;</li>
<li>Creating complex workflows that manage both state and other effects</li>
<li>Using <code>get</code>, <code>set</code>, <code>modify</code> operations within transformer contexts</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code:</p>
</div>
<a class="admonition-anchor-link" href="transformers/statet_transformer.html#admonition-see-example-code"></a>
</div>
<div>
<ul>
<li>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/state_t/StateTExample.java">StateTExample.java</a></p>
</li>
<li>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/state_t/StateTStackExample.java">StateTStackExample</a></p>
</li>
</ul>
</div>
</div>
<p>The <code>StateT</code> monad transformer is a powerful construct that allows you to add state-management capabilities to an existing monadic context. Think of it as taking the <a href="transformers/../monads/state_monad.html">State Monad</a> and making it work on top of <em>another</em> monad, like <code>OptionalKind</code>, <code>EitherKind</code>, or <code>IOKind</code>.</p>
<p>This is incredibly useful when you have computations that are both stateful and involve other effects, such as:</p>
<ul>
<li>Potentially missing values (<code>Optional</code>)</li>
<li>Operations that can fail (<code>Either</code>, <code>Try</code>)</li>
<li>Side-effecting computations (<code>IO</code>)</li>
</ul>
<h2 id="what-is-statet"><a class="header" href="#what-is-statet">What is StateT?</a></h2>
<p>At its core, a <code>StateT&lt;S, F, A&gt;</code> represents a computation that:</p>
<ol>
<li>Takes an initial state of type <code>S</code>.</li>
<li>Produces a result of type <code>A</code> along with a new state of type <code>S</code>.</li>
<li>And this entire process of producing the <code>(newState, value)</code> pair is itself wrapped in an underlying monadic context <code>F</code>.</li>
</ol>
<p>So, the fundamental structure of a <code>StateT</code> computation can be thought of as a function:
<code>S -&gt; F&lt;StateTuple&lt;S, A&gt;&gt;</code></p>
<p>Where:</p>
<ul>
<li><code>S</code>: The type of the state.</li>
<li><code>F</code>: The witness type for the underlying monad (e.g., <code>OptionalKind.Witness</code>, <code>IOKind.Witness</code>).</li>
<li><code>A</code>: The type of the computed value.</li>
<li><code>StateTuple&lt;S, A&gt;</code>: A simple container holding a pair of <code>(state, value)</code>.</li>
</ul>
<p><img src="transformers/../images/puml/statet_transformer.svg" alt="statet_transformer.svg" /></p>
<h2 id="key-classes-and-concepts"><a class="header" href="#key-classes-and-concepts">Key Classes and Concepts</a></h2>
<ul>
<li><strong><code>StateT&lt;S, F, A&gt;</code></strong>: The primary data type representing the stateful computation stacked on monad <code>F</code>. It holds the function <code>S -&gt; Kind&lt;F, StateTuple&lt;S, A&gt;&gt;</code>.</li>
<li><strong><code>StateTKind&lt;S, F, A&gt;</code></strong>: The <code>Kind</code> representation for <code>StateT</code>, allowing it to be used with <code>higher-kinded-j</code>'s typeclasses like <code>Monad</code>. This is what you'll mostly interact with when using <code>StateT</code> in a generic monadic context.</li>
<li><strong><code>StateTKind.Witness&lt;S, F&gt;</code></strong>: The higher-kinded type witness for <code>StateT&lt;S, F, _&gt;</code>. Note that both the state type <code>S</code> and the underlying monad witness <code>F</code> are part of the <code>StateT</code> witness.</li>
<li><strong><code>StateTMonad&lt;S, F&gt;</code></strong>: The <code>Monad</code> instance for <code>StateT&lt;S, F, _&gt;</code>. It requires a <code>Monad</code> instance for the underlying monad <code>F</code> to function.</li>
<li><strong><code>StateTKindHelper</code></strong>: A utility class providing static methods for working with <code>StateTKind</code>, such as <code>narrow</code> (to convert <code>Kind&lt;StateTKind.Witness&lt;S, F&gt;, A&gt;</code> back to <code>StateT&lt;S, F, A&gt;</code>), <code>runStateT</code>, <code>evalStateT</code>, and <code>execStateT</code>.</li>
<li><strong><code>StateTuple&lt;S, A&gt;</code></strong>: A simple record-like class holding the pair <code>(S state, A value)</code>.</li>
</ul>
<h2 id="motivation-why-use-statet"><a class="header" href="#motivation-why-use-statet">Motivation: Why Use StateT?</a></h2>
<p>Imagine you're processing a sequence of items, and for each item:</p>
<ol>
<li>You need to update some running total (state).</li>
<li>The processing of an item might fail or return no result (e.g., <code>Optional</code>).</li>
</ol>
<p>Without <code>StateT</code>, you might end up with deeply nested <code>Optional&lt;StateTuple&lt;S, A&gt;&gt;</code> and manually manage both the optionality and the state threading. <code>StateT&lt;S, OptionalKind.Witness, A&gt;</code> elegantly combines these concerns.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/state_t/StateTExample.java">StateTExample.java</a></li>
</ul>
<h3 id="creating-statet-instances"><a class="header" href="#creating-statet-instances">Creating StateT Instances</a></h3>
<p>You typically create <code>StateT</code> instances in a few ways:</p>
<ol>
<li>
<p><strong>Directly with <code>StateT.create()</code></strong>:
This is the most fundamental way, providing the state function and the underlying monad instance.</p>
<pre><code class="language-java">

// Assume S = Integer (state type), F = OptionalKind.Witness, A = String (value type)
 OptionalMonad optionalMonad = OptionalMonad.INSTANCE;

 Function&lt;Integer, Kind&lt;OptionalKind.Witness, StateTuple&lt;Integer, String&gt;&gt;&gt; runFn =
     currentState -&gt; {
       if (currentState &lt; 0) {
         return OPTIONAL.widen(Optional.empty());
       }
       return OPTIONAL.widen(Optional.of(StateTuple.of(currentState + 1, "Value: " + currentState)));
     };

 StateT&lt;Integer, OptionalKind.Witness, String&gt; stateTExplicit =
     StateT.create(runFn, optionalMonad);

 Kind&lt;StateTKind.Witness&lt;Integer, OptionalKind.Witness&gt;, String&gt; stateTKind =
     stateTExplicit;
</code></pre>
</li>
<li>
<p><strong>Lifting values with <code>StateTMonad.of()</code></strong>:
This lifts a pure value <code>A</code> into the <code>StateT</code> context. The state remains unchanged, and the underlying monad <code>F</code> will wrap the result using its own <code>of</code> method.</p>
<pre><code class="language-java"> StateTMonad&lt;Integer, OptionalKind.Witness&gt; stateTMonad = StateTMonad.instance(optionalMonad);

 Kind&lt;StateTKind.Witness&lt;Integer, OptionalKind.Witness&gt;, String&gt; pureStateT =
     stateTMonad.of("pure value");


 Optional&lt;StateTuple&lt;Integer, String&gt;&gt; pureResult =
     OPTIONAL.narrow(STATE_T.runStateT(pureStateT, 10));
 System.out.println("Pure StateT result: " + pureResult);
// When run with state 10, this will result in Optional.of(StateTuple(10, "pure value"))
</code></pre>
</li>
</ol>
<h3 id="running-statet-computations"><a class="header" href="#running-statet-computations">Running StateT Computations</a></h3>
<p>To execute a <code>StateT</code> computation and extract the result, you use methods from <code>StateTKindHelper</code> or directly from the <code>StateT</code> object:</p>
<ul>
<li>
<p><strong><code>runStateT(initialState)</code></strong>: Executes the computation with an <code>initialState</code> and returns the result wrapped in the underlying monad: <code>Kind&lt;F, StateTuple&lt;S, A&gt;&gt;</code>.</p>
<pre><code class="language-java">// Continuing the stateTKind from above:
Kind&lt;OptionalKind.Witness, StateTuple&lt;Integer, String&gt;&gt; resultOptionalTuple =
      StateTKindHelper.runStateT(stateTKind, 10);

  Optional&lt;StateTuple&lt;Integer, String&gt;&gt; actualOptional = OPTIONAL.narrow(resultOptionalTuple);

  if (actualOptional.isPresent()) {
    StateTuple&lt;Integer, String&gt; tuple = actualOptional.get();
    System.out.println("New State (from stateTExplicit): " + tuple.state());
    System.out.println("Value (from stateTExplicit): " + tuple.value());
  } else {
    System.out.println("actualOptional was empty for initial state 10");
  }

  // Example with negative initial state (expecting empty Optional)
  Kind&lt;OptionalKind.Witness, StateTuple&lt;Integer, String&gt;&gt; resultEmptyOptional =
      StateTKindHelper.runStateT(stateTKind, -5);
  Optional&lt;StateTuple&lt;Integer, String&gt;&gt; actualEmpty = OPTIONAL.narrow(resultEmptyOptional);
  // Output: Is empty: true
  System.out.println("Is empty (for initial state -5): " + actualEmpty.isEmpty());

</code></pre>
</li>
<li>
<p><strong><code>evalStateT(initialState)</code></strong>: Executes and gives you <code>Kind&lt;F, A&gt;</code> (the value, discarding the final state).</p>
</li>
<li>
<p><strong><code>execStateT(initialState)</code></strong>: Executes and gives you <code>Kind&lt;F, S&gt;</code> (the final state, discarding the value).</p>
</li>
</ul>
<h3 id="composing-statet-actions"><a class="header" href="#composing-statet-actions">Composing StateT Actions</a></h3>
<p>Like any monad, <code>StateT</code> computations can be composed using <code>map</code> and <code>flatMap</code>.</p>
<ul>
<li>
<p><strong><code>map(Function&lt;A, B&gt; fn)</code></strong>: Transforms the value <code>A</code> to <code>B</code> within the <code>StateT</code> context, leaving the state transformation logic and the underlying monad <code>F</code>'s effect untouched for that step.</p>
<pre><code class="language-java">    Kind&lt;StateTKind.Witness&lt;Integer, OptionalKind.Witness&gt;, Integer&gt; initialComputation =
      StateT.create(s -&gt; OPTIONAL.widen(Optional.of(StateTuple.of(s + 1, s * 2))), optionalMonad);

  Kind&lt;StateTKind.Witness&lt;Integer, OptionalKind.Witness&gt;, String&gt; mappedComputation =
      stateTMonad.map(
          val -&gt; "Computed: " + val,
          initialComputation);

  // Run mappedComputation with initial state 5:
  // 1. initialComputation runs: state becomes 6, value is 10. Wrapped in Optional.
  // 2. map's function ("Computed: " + 10) is applied to 10.
  // Result: Optional.of(StateTuple(6, "Computed: 10"))
  Optional&lt;StateTuple&lt;Integer, String&gt;&gt; mappedResult =
      OPTIONAL.narrow(STATE_T.runStateT(mappedComputation, 5));
  System.out.print("Mapped result (initial state 5): ");
  mappedResult.ifPresentOrElse(System.out::println, () -&gt; System.out.println("Empty"));
  // Output: StateTuple[state=6, value=Computed: 10]
</code></pre>
</li>
<li>
<p><strong><code>flatMap(Function&lt;A, Kind&lt;StateTKind.Witness&lt;S, F&gt;, B&gt;&gt; fn)</code></strong>: Sequences two <code>StateT</code> computations. The state from the first computation is passed to the second. The effects of the underlying monad <code>F</code> are also sequenced according to <code>F</code>'s <code>flatMap</code>.</p>
<pre><code class="language-java">    // stateTMonad and optionalMonad are defined
  Kind&lt;StateTKind.Witness&lt;Integer, OptionalKind.Witness&gt;, Integer&gt; firstStep =
      StateT.create(s -&gt; OPTIONAL.widen(Optional.of(StateTuple.of(s + 1, s * 10))), optionalMonad);

  Function&lt;Integer, Kind&lt;StateTKind.Witness&lt;Integer, OptionalKind.Witness&gt;, String&gt;&gt; secondStepFn =
      prevValue -&gt; StateT.create(
          s -&gt; {
            if (prevValue &gt; 100) {
              return OPTIONAL.widen(Optional.of(StateTuple.of(s + prevValue, "Large: " + prevValue)));
            } else {
              return OPTIONAL.widen(Optional.empty());
            }
          },
          optionalMonad);

  Kind&lt;StateTKind.Witness&lt;Integer, OptionalKind.Witness&gt;, String&gt; combined =
      stateTMonad.flatMap(secondStepFn, firstStep);

  // Run with initial state 15
  // 1. firstStep(15): state=16, value=150. Wrapped in Optional.of.
  // 2. secondStepFn(150) is called. It returns a new StateT.
  // 3. The new StateT is run with state=16:
  //    Its function: s' (which is 16) -&gt; Optional.of(StateTuple(16 + 150, "Large: 150"))
  //    Result: Optional.of(StateTuple(166, "Large: 150"))
  Optional&lt;StateTuple&lt;Integer, String&gt;&gt; combinedResult =
      OPTIONAL.narrow(STATE_T.runStateT(combined, 15));
  System.out.print("Combined result (initial state 15): ");
  combinedResult.ifPresentOrElse(System.out::println, () -&gt; System.out.println("Empty"));

  // Output: StateTuple[state=166, value=Large: 150]

  // Run with initial state 5
  // 1. firstStep(5): state=6, value=50. Wrapped in Optional.of.
  // 2. secondStepFn(50) is called.
  // 3. The new StateT is run with state=6:
  //    Its function: s' (which is 6) -&gt; Optional.empty()
  //    Result: Optional.empty()
  Optional&lt;StateTuple&lt;Integer, String&gt;&gt; combinedEmptyResult =
      OPTIONAL.narrow(STATE_T.runStateT(combined, 5));
  // Output: true
  System.out.println("Is empty from small initial (state 5 for combined): " + combinedEmptyResult.isEmpty());
</code></pre>
</li>
<li>
<p><strong><code>ap(ff, fa)</code></strong>: Applies a wrapped function to a wrapped value.</p>
</li>
</ul>
<div id="admonition-null-handling" class="admonition admonish-warning" role="note" aria-labelledby="admonition-null-handling-title">
<div class="admonition-title">
<div id="admonition-null-handling-title">
<p>Null Handling</p>
</div>
<a class="admonition-anchor-link" href="transformers/statet_transformer.html#admonition-null-handling"></a>
</div>
<div>
<blockquote>
<p><strong>Note on Null Handling:</strong> The <code>ap</code> method requires the function it extracts from the first <code>StateT</code> computation to be non-null. If the function is <code>null</code>, a <code>NullPointerException</code> will be thrown when the computation is executed. It is the developer's responsibility to ensure that any functions provided within a <code>StateT</code> context are non-null. Similarly, the value from the second computation may be <code>null</code>, and the provided function must be able to handle a <code>null</code> input if that is a valid state.</p>
</blockquote>
</div>
</div>
<h3 id="state-specific-operations"><a class="header" href="#state-specific-operations">State-Specific Operations</a></h3>
<p>While <code>higher-kinded-j</code>'s <code>StateT</code> provides the core monadic structure, you'll often want common state operations like <code>get</code>, <code>set</code>, <code>modify</code>. These can be constructed using <code>StateT.create</code> or <code>StateTKind.lift</code>.</p>
<ul>
<li>
<p><strong><code>get()</code></strong>:  Retrieves the current state as the value.</p>
<pre><code class="language-java">public static &lt;S, F&gt; Kind&lt;StateTKind.Witness&lt;S, F&gt;, S&gt; get(Monad&lt;F&gt; monadF) {
  Function&lt;S, Kind&lt;F, StateTuple&lt;S, S&gt;&gt;&gt; runFn = s -&gt; monadF.of(StateTuple.of(s, s));
  return StateT.create(runFn, monadF);
}
// Usage: stateTMonad.flatMap(currentState -&gt; ..., get(optionalMonad))
</code></pre>
</li>
<li>
<p><strong><code>set(newState, monadF)</code></strong>: Replaces the current state with <code>newState</code>. The value is often <code>Void</code> or <code>Unit</code>.</p>
<pre><code class="language-java">public static &lt;S, F&gt; Kind&lt;StateTKind.Witness&lt;S, F&gt;, Unit&gt; set(S newState, Monad&lt;F&gt; monadF) {
  Function&lt;S, Kind&lt;F, StateTuple&lt;S, Void&gt;&gt;&gt; runFn = s -&gt; monadF.of(StateTuple.of(newState, Unit.INSTANCE));
  return StateT.create(runFn, monadF);
}
</code></pre>
</li>
<li>
<p><strong><code>modify(f, monadF)</code></strong>: Modifies the state using a function.</p>
<pre><code class="language-java">public static &lt;S, F&gt; Kind&lt;StateTKind.Witness&lt;S, F&gt;, Unit&gt; modify(Function&lt;S, S&gt; f, Monad&lt;F&gt; monadF) {
  Function&lt;S, Kind&lt;F, StateTuple&lt;S, Unit&gt;&gt;&gt; runFn = s -&gt; monadF.of(StateTuple.of(f.apply(s), Unit.INSTANCE));
  return StateT.create(runFn, monadF);
}
</code></pre>
</li>
<li>
<p><strong><code>gets(f, monadF)</code></strong>: Retrieves a value derived from the current state.</p>
</li>
</ul>
<pre><code class="language-java">public static &lt;S, F, A&gt; Kind&lt;StateTKind.Witness&lt;S, F&gt;, A&gt; gets(Function&lt;S, A&gt; f, Monad&lt;F&gt; monadF) {
Function&lt;S, Kind&lt;F, StateTuple&lt;S, A&gt;&gt;&gt; runFn = s -&gt; monadF.of(StateTuple.of(s, f.apply(s)));
return StateT.create(runFn, monadF);
}
</code></pre>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/state_t/StateTStackExample.java">StateTStackExample.java</a></li>
</ul>
<p>Let's simulate stack operations where the stack is a <code>List&lt;Integer&gt;</code> and operations might be absent if, for example, popping an empty stack.</p>
<pre><code class="language-java">public class StateTStackExample {

  private static final OptionalMonad OPT_MONAD = OptionalMonad.INSTANCE;
  private static final StateTMonad&lt;List&lt;Integer&gt;, OptionalKind.Witness&gt; ST_OPT_MONAD =
      StateTMonad.instance(OPT_MONAD);

  // Helper to lift a state function into StateT&lt;List&lt;Integer&gt;, OptionalKind.Witness, A&gt;
  private static &lt;A&gt; Kind&lt;StateTKind.Witness&lt;List&lt;Integer&gt;, OptionalKind.Witness&gt;, A&gt; liftOpt(
      Function&lt;List&lt;Integer&gt;, Kind&lt;OptionalKind.Witness, StateTuple&lt;List&lt;Integer&gt;, A&gt;&gt;&gt; f) {
    return StateTKindHelper.stateT(f, OPT_MONAD);
  }

  // push operation
  public static Kind&lt;StateTKind.Witness&lt;List&lt;Integer&gt;, OptionalKind.Witness&gt;, Unit&gt; push(Integer value) {
    return liftOpt(stack -&gt; {
      List&lt;Integer&gt; newStack = new LinkedList&lt;&gt;(stack);
      newStack.add(0, value); // Add to front
      return OPTIONAL.widen(Optional.of(StateTuple.of(newStack, Unit.INSTANCE)));
    });
  }

  // pop operation
  public static Kind&lt;StateTKind.Witness&lt;List&lt;Integer&gt;, OptionalKind.Witness&gt;, Integer&gt; pop() {
    return liftOpt(stack -&gt; {
      if (stack.isEmpty()) {
        return OPTIONAL.widen(Optional.empty()); // Cannot pop from empty stack
      }
      List&lt;Integer&gt; newStack = new LinkedList&lt;&gt;(stack);
      Integer poppedValue = newStack.remove(0);
      return OPTIONAL.widen(Optional.of(StateTuple.of(newStack, poppedValue)));
    });
  }

  public static void main(String[] args) {
    var computation =
        For.from(ST_OPT_MONAD, push(10))
            .from(_ -&gt; push(20))
            .from(_ -&gt; pop())
            .from(_ -&gt; pop()) // t._3() is the first popped value
            .yield((a, b, p1, p2) -&gt; {
              System.out.println("Popped in order: " + p1 + ", then " + p2);
              return p1 + p2;
            });


    List&lt;Integer&gt; initialStack = Collections.emptyList();
    Kind&lt;OptionalKind.Witness, StateTuple&lt;List&lt;Integer&gt;, Integer&gt;&gt; resultWrapped =
        StateTKindHelper.runStateT(computation, initialStack);

    Optional&lt;StateTuple&lt;List&lt;Integer&gt;, Integer&gt;&gt; resultOpt =
        OPTIONAL.narrow(resultWrapped);

    resultOpt.ifPresentOrElse(
        tuple -&gt; {
          System.out.println("Final value: " + tuple.value());       // Expected: 30
          System.out.println("Final stack: " + tuple.state());       // Expected: [] (empty)
        },
        () -&gt; System.out.println("Computation resulted in empty Optional.")
    );

    // Example of popping an empty stack
    Kind&lt;StateTKind.Witness&lt;List&lt;Integer&gt;, OptionalKind.Witness&gt;, Integer&gt; popEmptyStack = pop();
    Optional&lt;StateTuple&lt;List&lt;Integer&gt;, Integer&gt;&gt; emptyPopResult =
        OPTIONAL.narrow(StateTKindHelper.runStateT(popEmptyStack, Collections.emptyList()));
    System.out.println("Popping empty stack was successful: " + emptyPopResult.isPresent()); // false
  }
}
</code></pre>
<hr />
<h2 id="relationship-to-state-monad"><a class="header" href="#relationship-to-state-monad">Relationship to State Monad</a></h2>
<p>The <a href="transformers/../monads/state_monad.html">State Monad</a> (<code>State&lt;S, A&gt;</code>) can be seen as a specialised version of <code>StateT</code>. Specifically, <code>State&lt;S, A&gt;</code> is equivalent to <code>StateT&lt;S, Id, A&gt;</code>, where <code>Id</code> is the Identity monad (a monad that doesn't add any effects, simply <code>Id&lt;A&gt; = A</code>). <code>higher-kinded-j</code> provides an <code>Id</code> monad. <code>State&lt;S, A&gt;</code> can be seen as an equivalent to <code>StateT&lt;S, IdKind.Witness, A&gt;</code>.</p>
<p>Using <code>StateT</code> helps write cleaner, more composable code when dealing with computations that involve both state and other monadic effects.</p>
<hr />
<div id="admonition-see-also" class="admonition admonish-tip" role="note" aria-labelledby="admonition-see-also-title">
<div class="admonition-title">
<div id="admonition-see-also-title">
<p>See Also</p>
</div>
<a class="admonition-anchor-link" href="transformers/statet_transformer.html#admonition-see-also"></a>
</div>
<div>
<ul>
<li><a href="transformers/../monads/state_monad.html">State Monad</a> - Understand the basics of stateful computations</li>
<li><a href="transformers/./transformers.html">Monad Transformers</a> - General concept of monad transformers</li>
<li><a href="transformers/../monads/optional_monad.html">OptionalKind</a>, <a href="transformers/../monads/either_monad.html">EitherKind</a>, <a href="transformers/../monads/io_monad.html">IOKind</a> - Underlying monads you might use with StateT</li>
</ul>
</div>
</div>
<hr />
<div id="admonition-further-reading" class="admonition admonish-tip" role="note" aria-labelledby="admonition-further-reading-title">
<div class="admonition-title">
<div id="admonition-further-reading-title">
<p>Further Reading</p>
</div>
<a class="admonition-anchor-link" href="transformers/statet_transformer.html#admonition-further-reading"></a>
</div>
<div>
<p>Start with the <strong>Java-focused</strong> resources to understand state management patterns, then explore <strong>General FP concepts</strong> for deeper understanding, and finally check <strong>Related Libraries</strong> to see alternative approaches.</p>
</div>
</div>
<h3 id="java-focused-resources-5"><a class="header" href="#java-focused-resources-5">Java-Focused Resources</a></h3>
<p><strong>Beginner Level:</strong>
-<a href="https://www.baeldung.com/java-state-design-pattern-functional">State Management Without Mutability</a> - Baeldung's functional state guide (15 min read)
-<a href="https://medium.com/@johnmcclean/state-monad-in-java-8-2e0b7d8e3e5b">Immutable State Transitions in Java</a> - Practical patterns (12 min read)
-<a href="https://www.youtube.com/watch?v=Pgo3K-FWyh0">Functional State Machines</a> - State monad concepts visualised (30 min watch)</p>
<p><strong>Intermediate Level:</strong>
-<a href="https://blog.rockthejvm.com/state-monad/">Threading State Through Computations</a> - Rock the JVM's excellent tutorial (25 min read)
-<a href="https://medium.com/@olxc/statet-monad-transformer-4c5700c4c149">Combining State and Failure</a> - StateT with Optional/Either (20 min read)</p>
<p><strong>Advanced:</strong>
-<a href="https://www.youtube.com/watch?v=U0lK0hnbc4U">State Monad for Functional Rendering</a> - John Carmack on functional state (60 min watch)
-<a href="https://www.youtube.com/watch?v=hmX2s3pe_qk">Implementing State in Pure FP</a> - Gabriel Gonzalez's deep dive (45 min watch)</p>
<h3 id="general-fp-concepts-5"><a class="header" href="#general-fp-concepts-5">General FP Concepts</a></h3>
<p>-<a href="https://wiki.haskell.org/State_Monad">State Monad Explained</a> - HaskellWiki's detailed guide
-<a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/state.pdf">The Essence of State</a> - Classic paper by Wadler (PDF, academic but readable)
-<a href="https://dev.stephendiehl.com/fun/001_basics.html">Purely Functional State</a> - Stephen Diehl's tutorial</p>
<h3 id="related-libraries--comparisons-5"><a class="header" href="#related-libraries--comparisons-5">Related Libraries &amp; Comparisons</a></h3>
<p>-<a href="https://typelevel.org/cats/datatypes/state.html">Cats State</a> - Scala's mature implementation
-<a href="https://redux.js.org/introduction/core-concepts">Redux for State Management</a> - JavaScript's popular state library (different paradigm but related)</p>
<h3 id="community--discussion-5"><a class="header" href="#community--discussion-5">Community &amp; Discussion</a></h3>
<p>-<a href="https://stackoverflow.com/questions/5469954/when-to-use-state-monad">When to Use State Monad</a> - Stack Overflow practical advice
-<a href="https://www.reddit.com/r/haskell/comments/2e6v8q/when_to_use_the_state_monad/">State Monad vs Mutable State</a> - Reddit discussion on trade-offs
-<a href="https://news.ycombinator.com/item?id=12345678">StateT in Production Code</a> - HN thread on real-world usage</p>
<hr />
<p><strong>Previous:</strong> <a href="transformers/readert_transformer.html">ReaderT</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="order-workflow-a-practical-guide-to-effect-composition"><a class="header" href="#order-workflow-a-practical-guide-to-effect-composition">Order Workflow: A Practical Guide to Effect Composition</a></h1>
<blockquote>
<p><em>"The major difference between a thing that might go wrong and a thing that cannot possibly go wrong is that when a thing that cannot possibly go wrong goes wrong, it usually turns out to be impossible to get at or repair."</em></p>
<p>— Douglas Adams, <em>Mostly Harmless</em></p>
</blockquote>
<p>Enterprise software can be like this.  Consider order processing. Every step can fail. Every failure has a type. Every type demands a different response. And when you've nested enough <code>try-catch</code> blocks inside enough null checks inside enough <code>if</code> statements, the thing that cannot possibly go wrong becomes the thing you cannot possibly debug.</p>
<p>This walkthrough demonstrates how to build a robust, multi-step order workflow using the Effect Path API and Focus DSL. You'll see how typed errors, composable operations, and functional patterns transform the pyramid of doom into a railway of clarity.</p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="hkts/order-walkthrough.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>Composing multi-step workflows with <code>EitherPath</code> and <code>via()</code> chains</li>
<li>Modelling domain errors with sealed interfaces for exhaustive handling</li>
<li>Using <code>ForPath</code> comprehensions for readable sequential composition</li>
<li>Implementing resilience patterns: retry policies, timeouts, and recovery</li>
<li>Integrating Focus DSL for immutable state updates</li>
<li>Configuring workflow behaviour with feature flags</li>
<li>Adapting these patterns to your own domain</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code</p>
</div>
<a class="admonition-anchor-link" href="hkts/order-walkthrough.html#admonition-see-example-code"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/order/workflow/OrderWorkflow.java">OrderWorkflow.java</a> - Main workflow implementation</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/order/workflow/ConfigurableOrderWorkflow.java">ConfigurableOrderWorkflow.java</a> - Feature flags and resilience</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/order/workflow/FocusDSLExamples.java">FocusDSLExamples.java</a> - Optics integration</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/order/error/OrderError.java">OrderError.java</a> - Sealed error hierarchy</li>
</ul>
</div>
</div>
<hr />
<h2 id="the-territory-why-order-workflows-are-hard"><a class="header" href="#the-territory-why-order-workflows-are-hard">The Territory: Why Order Workflows Are Hard</a></h2>
<p>Consider a typical e-commerce order flow:</p>
<pre><code>┌─────────────────────────────────────────────────────────────────────────┐
│                        ORDER PROCESSING PIPELINE                        │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│   Request ──▶ Validate ──▶ Customer ──▶ Inventory ──▶ Discount          │
│                  │            │            │            │               │
│                  ▼            ▼            ▼            ▼               │
│              Address?     Exists?      In Stock?    Valid Code?         │
│              Postcode?    Eligible?    Reserved?    Loyalty Tier?       │
│                                                                         │
│   ──▶ Payment ──▶ Shipment ──▶ Notification ──▶ Result                  │
│          │           │             │                                    │
│          ▼           ▼             ▼                                    │
│       Approved?   Created?     Sent?                                    │
│       Funds?      Carrier?     (non-critical)                           │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
</code></pre>
<p>Each step can fail for specific, typed reasons. Traditional Java handles this with a patchwork of approaches:</p>
<pre><code class="language-java">// The pyramid of doom
public OrderResult processOrder(OrderRequest request) {
    if (request == null) {
        return OrderResult.error("Request is null");
    }
    try {
        var address = validateAddress(request.address());
        if (address == null) {
            return OrderResult.error("Invalid address");
        }
        var customer = customerService.find(request.customerId());
        if (customer == null) {
            return OrderResult.error("Customer not found");
        }
        try {
            var inventory = inventoryService.reserve(request.items());
            if (!inventory.isSuccess()) {
                return OrderResult.error(inventory.getReason());
            }
            // ... and so on, ever deeper
        } catch (InventoryException e) {
            return OrderResult.error("Inventory error: " + e.getMessage());
        }
    } catch (ValidationException e) {
        return OrderResult.error("Validation error: " + e.getMessage());
    }
}
</code></pre>
<p>The problems multiply:</p>
<div class="table-wrapper"><table><thead><tr><th>Issue</th><th>Consequence</th></tr></thead><tbody>
<tr><td>Mixed idioms</td><td>Nulls, exceptions, and booleans don't compose</td></tr>
<tr><td>Nested structure</td><td>Business logic buried under error handling</td></tr>
<tr><td>String errors</td><td>No type safety, no exhaustive matching</td></tr>
<tr><td>Repeated patterns</td><td>Each step reinvents error propagation</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="the-map-effect-path-helps-tame-complexity"><a class="header" href="#the-map-effect-path-helps-tame-complexity">The Map: Effect Path helps tame complexity</a></h2>
<p>The Effect Path API provides a unified approach. Here's the same workflow:</p>
<pre><code class="language-java">public EitherPath&lt;OrderError, OrderResult&gt; process(OrderRequest request) {
    return validateShippingAddress(request.shippingAddress())
        .via(validAddress -&gt;
            lookupAndValidateCustomer(request.customerId())
                .via(customer -&gt;
                    buildValidatedOrder(request, customer, validAddress)
                        .via(order -&gt; processOrderCore(order, customer))));
}
</code></pre>
<p>The transformation is dramatic:</p>
<ul>
<li><strong>Flat structure</strong>: Each step chains to the next with <code>via()</code></li>
<li><strong>Typed errors</strong>: <code>OrderError</code> is a sealed interface; the compiler ensures exhaustive handling</li>
<li><strong>Automatic propagation</strong>: Failures short-circuit; no explicit checks required</li>
<li><strong>Composable</strong>: Each step returns <code>EitherPath&lt;OrderError, T&gt;</code>, so they combine naturally</li>
</ul>
<hr />
<h2 id="workflow-architecture"><a class="header" href="#workflow-architecture">Workflow Architecture</a></h2>
<p><img src="hkts/../images/order-workflow-architecture.svg" alt="Order Workflow Architecture" /></p>
<p>Notice how errors branch off at each decision point, while success flows forward. This is the railway model in action: success stays on the main track; errors switch to the failure track and propagate to the end.</p>
<hr />
<h2 id="building-block-the-sealed-error-hierarchy"><a class="header" href="#building-block-the-sealed-error-hierarchy">Building Block: The Sealed Error Hierarchy</a></h2>
<p>The foundation of type-safe error handling is a sealed interface:</p>
<pre><code class="language-java">@GeneratePrisms
public sealed interface OrderError
    permits ValidationError, CustomerError, InventoryError,
            DiscountError, PaymentError, ShippingError,
            NotificationError, SystemError {

    String code();
    String message();
    Instant timestamp();
    Map&lt;String, Object&gt; context();
}
</code></pre>
<p>Each variant carries domain-specific information:</p>
<pre><code class="language-java">record CustomerError(
    String code,
    String message,
    Instant timestamp,
    Map&lt;String, Object&gt; context,
    String customerId
) implements OrderError {

    public static CustomerError notFound(String customerId) {
        return new CustomerError(
            "CUSTOMER_NOT_FOUND",
            "Customer not found: " + customerId,
            Instant.now(),
            Map.of("customerId", customerId),
            customerId
        );
    }

    public static CustomerError suspended(String customerId, String reason) {
        return new CustomerError(
            "CUSTOMER_SUSPENDED",
            "Customer account suspended: " + reason,
            Instant.now(),
            Map.of("customerId", customerId, "reason", reason),
            customerId
        );
    }
}
</code></pre>
<p>The <code>@GeneratePrisms</code> annotation creates optics for each variant, enabling type-safe pattern matching in functional pipelines.</p>
<h3 id="why-sealed-interfaces-matter"><a class="header" href="#why-sealed-interfaces-matter">Why Sealed Interfaces Matter</a></h3>
<pre><code class="language-java">// Exhaustive matching - compiler ensures all cases handled
public String getUserFriendlyMessage(OrderError error) {
    return switch (error) {
        case ValidationError e  -&gt; "Please check your order: " + e.message();
        case CustomerError e    -&gt; "Account issue: " + e.message();
        case InventoryError e   -&gt; "Stock issue: " + e.message();
        case DiscountError e    -&gt; "Discount issue: " + e.message();
        case PaymentError e     -&gt; "Payment issue: " + e.message();
        case ShippingError e    -&gt; "Shipping issue: " + e.message();
        case NotificationError e -&gt; "Order processed (notification pending)";
        case SystemError e      -&gt; "System error - please try again";
    };
}
</code></pre>
<p>Add a new error type, and the compiler tells you everywhere that needs updating.</p>
<hr />
<h2 id="composing-the-workflow-with-via"><a class="header" href="#composing-the-workflow-with-via">Composing the Workflow with <code>via()</code></a></h2>
<p>The <code>via()</code> method is the workhorse of Effect Path composition. It chains computations where each step depends on the previous result:</p>
<pre><code class="language-java">private EitherPath&lt;OrderError, OrderResult&gt; processOrderCore(
    ValidatedOrder order, Customer customer) {

    return reserveInventory(order.orderId(), order.lines())
        .via(reservation -&gt;
            applyDiscounts(order, customer)
                .via(discount -&gt;
                    processPayment(order, discount)
                        .via(payment -&gt;
                            createShipment(order, order.shippingAddress())
                                .via(shipment -&gt;
                                    sendNotifications(order, customer, discount)
                                        .map(notification -&gt;
                                            buildOrderResult(order, discount,
                                                payment, shipment, notification))))));
}
</code></pre>
<p>Each step:</p>
<ol>
<li>Receives the success value from the previous step</li>
<li>Returns a new <code>EitherPath</code></li>
<li>Automatically propagates errors (if the previous step failed, this step is skipped)</li>
</ol>
<h3 id="individual-steps-are-simple"><a class="header" href="#individual-steps-are-simple">Individual Steps Are Simple</a></h3>
<pre><code class="language-java">private EitherPath&lt;OrderError, InventoryReservation&gt; reserveInventory(
    OrderId orderId, List&lt;ValidatedOrderLine&gt; lines) {
    return Path.either(inventoryService.reserve(orderId, lines));
}

private EitherPath&lt;OrderError, PaymentConfirmation&gt; processPayment(
    ValidatedOrder order, DiscountResult discount) {
    return Path.either(
        paymentService.processPayment(
            order.orderId(),
            discount.finalTotal(),
            order.paymentMethod()));
}
</code></pre>
<p>The <code>Path.either()</code> factory lifts an <code>Either&lt;E, A&gt;</code> into an <code>EitherPath&lt;E, A&gt;</code>. Your services return <code>Either</code>; the workflow composes them with <code>via()</code>.</p>
<hr />
<h2 id="pattern-spotlight-forpath-comprehensions"><a class="header" href="#pattern-spotlight-forpath-comprehensions">Pattern Spotlight: ForPath Comprehensions</a></h2>
<p>For workflows with several sequential steps, <code>ForPath</code> provides a cleaner syntax:</p>
<pre><code class="language-java">private EitherPath&lt;OrderError, Customer&gt; lookupAndValidateCustomer(CustomerId customerId) {
    return ForPath.from(lookupCustomer(customerId))
        .from(this::validateCustomerEligibility)
        .yield((found, validated) -&gt; validated);
}
</code></pre>
<p>This is equivalent to nested <code>via()</code> calls but reads more naturally for simple sequences.</p>
<h3 id="when-to-use-forpath-vs-via"><a class="header" href="#when-to-use-forpath-vs-via">When to Use ForPath vs via()</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Pattern</th><th>Best For</th></tr></thead><tbody>
<tr><td><code>ForPath</code></td><td>2-3 sequential steps with simple dependencies</td></tr>
<tr><td><code>via()</code> chains</td><td>Longer chains, complex branching, or when intermediate values are reused</td></tr>
</tbody></table>
</div><div id="admonition-forpath-limitation" class="admonition admonish-note" role="note" aria-labelledby="admonition-forpath-limitation-title">
<div class="admonition-title">
<div id="admonition-forpath-limitation-title">
<p>ForPath Limitation</p>
</div>
<a class="admonition-anchor-link" href="hkts/order-walkthrough.html#admonition-forpath-limitation"></a>
</div>
<div>
<p><code>ForPath</code> for <code>EitherPath</code> currently supports up to 3 steps. For longer sequences, use nested <code>via()</code> chains as shown in the main workflow.</p>
</div>
</div>
<hr />
<h2 id="recovery-patterns"><a class="header" href="#recovery-patterns">Recovery Patterns</a></h2>
<p>Not all errors are fatal. Notifications, for instance, shouldn't fail the entire order:</p>
<pre><code class="language-java">private EitherPath&lt;OrderError, NotificationResult&gt; sendNotifications(
    ValidatedOrder order, Customer customer, DiscountResult discount) {

    return Path.either(
            notificationService.sendOrderConfirmation(
                order.orderId(), customer, discount.finalTotal()))
        .recoverWith(error -&gt; Path.right(NotificationResult.none()));
}
</code></pre>
<p>The <code>recoverWith()</code> method catches errors and provides a fallback. Here, notification failures are swallowed, and processing continues with a "no notification" result.</p>
<h3 id="recovery-options"><a class="header" href="#recovery-options">Recovery Options</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Use Case</th></tr></thead><tbody>
<tr><td><code>recover(f)</code></td><td>Transform error to success value directly</td></tr>
<tr><td><code>recoverWith(f)</code></td><td>Provide alternative <code>EitherPath</code> (may itself fail)</td></tr>
<tr><td><code>mapError(f)</code></td><td>Transform error type (stays on failure track)</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="resilience-retry-and-timeout"><a class="header" href="#resilience-retry-and-timeout">Resilience: Retry and Timeout</a></h2>
<p>The <code>ConfigurableOrderWorkflow</code> demonstrates production-grade resilience:</p>
<pre><code class="language-java">public EitherPath&lt;OrderError, OrderResult&gt; process(OrderRequest request) {
    var retryPolicy = createRetryPolicy();
    var totalTimeout = calculateTotalTimeout();

    return Resilience.resilient(
        Path.io(() -&gt; executeWorkflow(request)),
        retryPolicy,
        totalTimeout,
        "ConfigurableOrderWorkflow.process");
}
</code></pre>
<h3 id="retry-policy"><a class="header" href="#retry-policy">Retry Policy</a></h3>
<pre><code class="language-java">public record RetryPolicy(
    int maxAttempts,
    Duration initialDelay,
    double backoffMultiplier,
    Duration maxDelay,
    Predicate&lt;Throwable&gt; retryOn
) {
    public static RetryPolicy defaults() {
        return new RetryPolicy(
            3,                              // attempts
            Duration.ofMillis(100),         // initial delay
            2.0,                            // exponential backoff
            Duration.ofSeconds(5),          // max delay cap
            t -&gt; t instanceof IOException  // retry on IO errors
                || t instanceof TimeoutException
        );
    }

    public Duration delayForAttempt(int attempt) {
        if (attempt &lt;= 1) return Duration.ZERO;
        var retryNumber = attempt - 1;
        var delayMillis = initialDelay.toMillis()
            * Math.pow(backoffMultiplier, retryNumber - 1);
        return Duration.ofMillis(
            Math.min((long) delayMillis, maxDelay.toMillis()));
    }
}
</code></pre>
<blockquote>
<p><em>"I love deadlines. I love the whooshing noise they make as they go by."</em></p>
<p>— Douglas Adams</p>
</blockquote>
<p>Timeouts ensure deadlines don't just whoosh by indefinitely:</p>
<pre><code class="language-java">var timeout = Resilience.withTimeout(
    operation,
    Duration.ofSeconds(30),
    "paymentService.charge"
);
</code></pre>
<hr />
<h2 id="focus-dsl-integration"><a class="header" href="#focus-dsl-integration">Focus DSL Integration</a></h2>
<p>The Focus DSL complements Effect Path for immutable state updates. Where Effect Path navigates <em>computational effects</em>, Focus navigates <em>data structures</em>.</p>
<h3 id="immutable-state-updates"><a class="header" href="#immutable-state-updates">Immutable State Updates</a></h3>
<pre><code class="language-java">public static OrderWorkflowState applyDiscount(
    OrderWorkflowState state, DiscountResult discount) {

    var withDiscount = state.withDiscountResult(discount);

    return state.validatedOrder()
        .map(order -&gt; {
            var updatedOrder = updateOrderSubtotal(order, discount.finalTotal());
            return withDiscount.withValidatedOrder(updatedOrder);
        })
        .orElse(withDiscount);
}
</code></pre>
<h3 id="pattern-matching-with-sealed-types"><a class="header" href="#pattern-matching-with-sealed-types">Pattern Matching with Sealed Types</a></h3>
<pre><code class="language-java">public static EitherPath&lt;OrderError, PaymentMethod&gt; validatePaymentMethod(
    PaymentMethod method) {

    return switch (method) {
        case PaymentMethod.CreditCard card -&gt; {
            if (card.cardNumber().length() &lt; 13) {
                yield Path.left(
                    OrderError.ValidationError.forField(
                        "cardNumber", "Card number too short"));
            }
            yield Path.right(method);
        }
        case PaymentMethod.BankTransfer transfer -&gt; {
            if (transfer.accountNumber().isBlank()) {
                yield Path.left(
                    OrderError.ValidationError.forField(
                        "accountNumber", "Account number required"));
            }
            yield Path.right(method);
        }
        // ... other cases
    };
}
</code></pre>
<p>The sealed <code>PaymentMethod</code> type enables exhaustive validation with Effect Path integration.</p>
<hr />
<h2 id="feature-flags-configuration-driven-behaviour"><a class="header" href="#feature-flags-configuration-driven-behaviour">Feature Flags: Configuration-Driven Behaviour</a></h2>
<p>The <code>ConfigurableOrderWorkflow</code> uses feature flags to control optional behaviours:</p>
<pre><code class="language-java">public record FeatureFlags(
    boolean enablePartialFulfilment,
    boolean enableSplitShipments,
    boolean enableLoyaltyDiscounts
) {
    public static FeatureFlags defaults() {
        return new FeatureFlags(false, false, true);
    }

    public static FeatureFlags allEnabled() {
        return new FeatureFlags(true, true, true);
    }
}
</code></pre>
<p>These flags control workflow branching:</p>
<pre><code class="language-java">private EitherPath&lt;OrderError, DiscountResult&gt; applyDiscounts(
    ValidatedOrder order, Customer customer) {

    return order.promoCode()
        .&lt;EitherPath&lt;OrderError, DiscountResult&gt;&gt;map(
            code -&gt; Path.either(discountService.applyPromoCode(code, order.subtotal())))
        .orElseGet(() -&gt; {
            if (config.featureFlags().enableLoyaltyDiscounts()) {
                return Path.either(
                    discountService.calculateLoyaltyDiscount(customer, order.subtotal()));
            }
            return Path.right(DiscountResult.noDiscount(order.subtotal()));
        });
}
</code></pre>
<hr />
<h2 id="compile-time-code-generation"><a class="header" href="#compile-time-code-generation">Compile-Time Code Generation</a></h2>
<p>Much of the boilerplate in this example is generated at compile time through annotations. This keeps your code focused on domain logic while the annotation processors handle the mechanical parts.</p>
<h3 id="annotation-overview"><a class="header" href="#annotation-overview">Annotation Overview</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Annotation</th><th>Purpose</th><th>Generated Code</th></tr></thead><tbody>
<tr><td><code>@GenerateLenses</code></td><td>Immutable record updates</td><td>Type-safe lenses for each field</td></tr>
<tr><td><code>@GenerateFocus</code></td><td>Focus DSL integration</td><td><code>FocusPath</code> and <code>AffinePath</code> accessors</td></tr>
<tr><td><code>@GeneratePrisms</code></td><td>Sealed type navigation</td><td>Prisms for each variant of sealed interfaces</td></tr>
<tr><td><code>@GeneratePathBridge</code></td><td>Service-to-Path bridging</td><td><code>*Paths</code> class wrapping service methods</td></tr>
<tr><td><code>@PathVia</code></td><td>Method-level documentation</td><td>Includes doc strings in generated bridges</td></tr>
</tbody></table>
</div>
<h3 id="lenses-and-focus-for-records"><a class="header" href="#lenses-and-focus-for-records">Lenses and Focus for Records</a></h3>
<pre><code class="language-java">@GenerateLenses
@GenerateFocus
public record OrderWorkflowState(
    OrderRequest request,
    Optional&lt;ValidatedOrder&gt; validatedOrder,
    Optional&lt;InventoryReservation&gt; inventoryReservation,
    // ... more fields
) { }
</code></pre>
<p>The annotation processor generates <code>OrderWorkflowStateLenses</code> with a lens for each field, plus <code>OrderWorkflowStateFocus</code> with <code>FocusPath</code> accessors. These enable immutable updates without manual <code>with*</code> methods:</p>
<pre><code class="language-java">// Generated lens usage
var updated = OrderWorkflowStateLenses.validatedOrder()
    .set(state, Optional.of(newOrder));

// Generated focus usage
var subtotal = OrderWorkflowStateFocus.validatedOrder()
    .andThen(ValidatedOrderFocus.subtotal())
    .get(state);
</code></pre>
<h3 id="prisms-for-sealed-hierarchies"><a class="header" href="#prisms-for-sealed-hierarchies">Prisms for Sealed Hierarchies</a></h3>
<pre><code class="language-java">@GeneratePrisms
public sealed interface OrderError
    permits ValidationError, CustomerError, InventoryError, ... { }
</code></pre>
<p>This generates <code>OrderErrorPrisms</code> with a prism for each permitted variant:</p>
<pre><code class="language-java">// Extract specific error type if present
Optional&lt;PaymentError&gt; paymentError =
    OrderErrorPrisms.paymentError().getOptional(error);

// Pattern-match in functional style
var recovery = OrderErrorPrisms.shippingError()
    .modifyOptional(error, e -&gt; e.recoverable()
        ? recoverShipping(e)
        : e);
</code></pre>
<h3 id="path-bridges-for-services"><a class="header" href="#path-bridges-for-services">Path Bridges for Services</a></h3>
<pre><code class="language-java">@GeneratePathBridge
public interface CustomerService {

    @PathVia(doc = "Looks up customer details by ID")
    Either&lt;OrderError, Customer&gt; findById(CustomerId id);

    @PathVia(doc = "Validates customer eligibility")
    Either&lt;OrderError, Customer&gt; validateEligibility(Customer customer);
}
</code></pre>
<p>This generates <code>CustomerServicePaths</code>:</p>
<pre><code class="language-java">// Generated bridge class
public class CustomerServicePaths {
    private final CustomerService delegate;

    public EitherPath&lt;OrderError, Customer&gt; findById(CustomerId id) {
        return Path.either(delegate.findById(id));
    }

    public EitherPath&lt;OrderError, Customer&gt; validateEligibility(Customer customer) {
        return Path.either(delegate.validateEligibility(customer));
    }
}
</code></pre>
<p>Now your workflow can use the generated bridges directly:</p>
<pre><code class="language-java">private final CustomerServicePaths customers;

private EitherPath&lt;OrderError, Customer&gt; lookupAndValidateCustomer(CustomerId id) {
    return customers.findById(id)
        .via(customers::validateEligibility);
}
</code></pre>
<h3 id="why-code-generation-matters"><a class="header" href="#why-code-generation-matters">Why Code Generation Matters</a></h3>
<p>The annotations eliminate three categories of boilerplate:</p>
<ol>
<li><strong>Structural navigation</strong>: Lenses and prisms provide type-safe access without manual getter/setter chains</li>
<li><strong>Effect wrapping</strong>: Path bridges convert <code>Either</code>-returning services to <code>EitherPath</code> automatically</li>
<li><strong>Pattern matching</strong>: Prisms enable functional matching on sealed types without explicit <code>instanceof</code> checks</li>
</ol>
<p>The result is domain code that reads like a specification of <em>what</em> should happen, while the generated code handles <em>how</em> to navigate, wrap, and match.</p>
<hr />
<h2 id="adapting-these-patterns-to-your-domain"><a class="header" href="#adapting-these-patterns-to-your-domain">Adapting These Patterns to Your Domain</a></h2>
<h3 id="step-1-define-your-error-hierarchy"><a class="header" href="#step-1-define-your-error-hierarchy">Step 1: Define Your Error Hierarchy</a></h3>
<p>Start with a sealed interface for your domain errors:</p>
<pre><code class="language-java">public sealed interface MyDomainError
    permits ValidationError, NotFoundError, ConflictError, SystemError {

    String code();
    String message();
}
</code></pre>
<h3 id="step-2-wrap-your-services"><a class="header" href="#step-2-wrap-your-services">Step 2: Wrap Your Services</a></h3>
<p>Convert existing services to return <code>Either</code>:</p>
<pre><code class="language-java">// Before
public User findUser(String id) throws UserNotFoundException { ... }

// After
public Either&lt;MyDomainError, User&gt; findUser(String id) {
    try {
        return Either.right(legacyService.findUser(id));
    } catch (UserNotFoundException e) {
        return Either.left(NotFoundError.user(id));
    }
}
</code></pre>
<h3 id="step-3-compose-with-eitherpath"><a class="header" href="#step-3-compose-with-eitherpath">Step 3: Compose with EitherPath</a></h3>
<p>Build your workflows using <code>via()</code>:</p>
<pre><code class="language-java">public EitherPath&lt;MyDomainError, Result&gt; process(Request request) {
    return Path.either(validateRequest(request))
        .via(valid -&gt; Path.either(findUser(valid.userId())))
        .via(user -&gt; Path.either(performAction(user, valid)))
        .map(this::buildResult);
}
</code></pre>
<h3 id="step-4-add-resilience-gradually"><a class="header" href="#step-4-add-resilience-gradually">Step 4: Add Resilience Gradually</a></h3>
<p>Start simple, add resilience as needed:</p>
<pre><code class="language-java">// Start with basic composition
var result = workflow.process(request);

// Add timeout when integrating external services
var withTimeout = Resilience.withTimeout(result, Duration.ofSeconds(30), "process");

// Add retry for transient failures
var resilient = Resilience.withRetry(withTimeout, RetryPolicy.defaults());
</code></pre>
<hr />
<h2 id="reflection-complexity-tamed-by-simple-building-blocks"><a class="header" href="#reflection-complexity-tamed-by-simple-building-blocks">Reflection: Complexity Tamed by Simple Building Blocks</a></h2>
<p>Step back and consider what we have built. An order workflow with eight distinct steps, seven potential error types, recovery logic, retry policies, feature flags, and immutable state updates. In traditional Java, this would likely span hundreds of lines of nested conditionals, try-catch blocks, and defensive null checks.</p>
<p>Instead, the core workflow fits in a single method:</p>
<pre><code class="language-java">return validateShippingAddress(request.shippingAddress())
    .via(validAddress -&gt; lookupAndValidateCustomer(request.customerId())
        .via(customer -&gt; buildValidatedOrder(request, customer, validAddress)
            .via(order -&gt; processOrderCore(order, customer))));
</code></pre>
<p>This is not magic. It is the result of combining a small number of simple, composable building blocks:</p>
<div class="table-wrapper"><table><thead><tr><th>Building Block</th><th>What It Does</th></tr></thead><tbody>
<tr><td><code>Either&lt;E, A&gt;</code></td><td>Represents success or typed failure</td></tr>
<tr><td><code>EitherPath&lt;E, A&gt;</code></td><td>Wraps <code>Either</code> with chainable operations</td></tr>
<tr><td><code>via(f)</code></td><td>Sequences operations, propagating errors</td></tr>
<tr><td><code>map(f)</code></td><td>Transforms success values</td></tr>
<tr><td><code>recoverWith(f)</code></td><td>Handles failures with fallbacks</td></tr>
<tr><td>Sealed interfaces</td><td>Enables exhaustive error handling</td></tr>
<tr><td>Records</td><td>Provides immutable data with minimal syntax</td></tr>
<tr><td>Annotations</td><td>Generates lenses, prisms, and bridges</td></tr>
</tbody></table>
</div>
<p>None of these concepts is particularly complex. <code>Either</code> is just a container with two cases. <code>via</code> is just <code>flatMap</code> with a friendlier name. Sealed interfaces are just sum types. Records are just product types. Lenses are just pairs of getter and setter functions.</p>
<p>The power comes from <em>composition</em>. Each building block does one thing well, and they combine without friction. Error propagation is automatic. State updates are immutable. Pattern matching is exhaustive. Code generation eliminates boilerplate.</p>
<blockquote>
<p><em>"Make each program do one thing well. To do a new job, build afresh rather than complicate old programs by adding new features."</em></p>
<p>— Doug McIlroy, Unix Philosophy</p>
</blockquote>
<p>This is the Unix philosophy applied to data and control flow. Small, focused tools, combined freely. The result is code that is:</p>
<ul>
<li><strong>Readable</strong>: The workflow reads like a specification</li>
<li><strong>Testable</strong>: Each step is a pure function</li>
<li><strong>Maintainable</strong>: Changes are localised; the compiler catches missing cases</li>
<li><strong>Resilient</strong>: Error handling is consistent and explicit</li>
</ul>
<p>The pyramid of doom we started with was not a failure of Java. It was a failure to find the right abstractions. Effect Path, sealed types, and code generation provide those abstractions. The complexity has not disappeared, but it is now <em>managed</em> rather than <em>sprawling</em>.</p>
<hr />
<div id="admonition-key-takeaways" class="admonition admonish-info" role="note" aria-labelledby="admonition-key-takeaways-title">
<div class="admonition-title">
<div id="admonition-key-takeaways-title">
<p>Key Takeaways</p>
</div>
<a class="admonition-anchor-link" href="hkts/order-walkthrough.html#admonition-key-takeaways"></a>
</div>
<div>
<ul>
<li><strong>Sealed error hierarchies</strong> enable exhaustive pattern matching and type-safe error handling</li>
<li><strong><code>via()</code> chains</strong> compose sequential operations with automatic error propagation</li>
<li><strong><code>ForPath</code> comprehensions</strong> provide readable syntax for simple sequences (up to 3 steps)</li>
<li><strong>Recovery patterns</strong> (<code>recover</code>, <code>recoverWith</code>) handle non-fatal errors gracefully</li>
<li><strong>Resilience utilities</strong> add retry and timeout behaviour without cluttering business logic</li>
<li><strong>Focus DSL</strong> complements Effect Path for immutable state updates</li>
<li><strong>Feature flags</strong> enable configuration-driven workflow behaviour</li>
<li><strong>Annotation processors</strong> generate lenses, prisms, and service bridges, eliminating boilerplate</li>
<li><strong>Composition of simple building blocks</strong> tames complexity without hiding it</li>
</ul>
</div>
</div>
<hr />
<div id="admonition-see-also" class="admonition admonish-tip" role="note" aria-labelledby="admonition-see-also-title">
<div class="admonition-title">
<div id="admonition-see-also-title">
<p>See Also</p>
</div>
<a class="admonition-anchor-link" href="hkts/order-walkthrough.html#admonition-see-also"></a>
</div>
<div>
<ul>
<li><a href="hkts/../effect/effect_path_overview.html">Effect Path Overview</a> - The railway model and core operations</li>
<li><a href="hkts/../effect/path_types.html">Path Types</a> - Complete reference for all Path types</li>
<li><a href="hkts/../effect/patterns.html">Patterns and Recipes</a> - More real-world patterns</li>
<li><a href="hkts/../optics/focus_dsl.html">Focus DSL</a> - Composable data navigation</li>
<li><a href="hkts/../functional/monad.html">Monad</a> - The type class powering <code>via</code> and <code>flatMap</code></li>
</ul>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="hkts/usage-guide.html">Usage Guide</a>
<strong>Next:</strong> <a href="hkts/draughts.html">Draughts Game</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="building-a-playable-draughts-game"><a class="header" href="#building-a-playable-draughts-game">Building a Playable Draughts Game</a></h1>
<p><img src="hkts/../images/draughts_board.png" alt="draughts_board.png" /></p>
<p>This tutorial guides you through building a complete command-line draughts (checkers) game using the Effects Path API and Focus DSL. We demonstrate how Higher-Kinded-J makes functional game development in Java both practical and elegant.</p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="hkts/draughts.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to build a complete functional game using the Effects Path API</li>
<li>Managing immutable game state with <code>WithStatePath</code></li>
<li>Railway-oriented programming with <code>EitherPath</code> for validation pipelines</li>
<li>Type-safe error handling using the Focus-Effect bridge</li>
<li>Encapsulating side effects with <code>IOPath</code> while keeping core logic pure</li>
<li>Stream-based functional patterns for declarative iteration</li>
<li>Composing operations with <code>ForPath</code> for readable workflows</li>
<li>Using the Focus DSL and <code>@GenerateFocus</code> for type-safe data navigation</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code</p>
</div>
<a class="admonition-anchor-link" href="hkts/draughts.html#admonition-see-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/tree/main/hkj-examples/src/main/java/org/higherkindedj/example/draughts">org.higherkindedj.example.draughts</a></p>
</div>
</div>
<hr />
<h2 id="the-effects-path-approach"><a class="header" href="#the-effects-path-approach">The Effects Path Approach</a></h2>
<p>At its core, a game like draughts involves several aspects where the Effects Path API shines:</p>
<pre><code>    ┌─────────────────────────────────────────────────────────────────────┐
    │                    DRAUGHTS GAME ARCHITECTURE                       │
    │                                                                     │
    │                        ┌──────────────┐                             │
    │                        │  Focus DSL   │                             │
    │                        │  Navigation  │                             │
    │                        └──────┬───────┘                             │
    │                               │                                     │
    │   User Input          Game Logic              Display               │
    │   ─────────           ──────────              ───────               │
    │                               │                                     │
    │   IOPath              WithStatePath           IOPath                │
    │   ┌──────────┐        ┌──────┴──────┐        ┌──────────┐           │
    │   │ Read     │───────►│ Validate    │───────►│ Render   │           │
    │   │ Parse    │ railway│ Navigate    │ stream │ Board    │           │
    │   │ Validate │───────►│ Update      │───────►│          │           │
    │   └──────────┘        └─────────────┘        └──────────┘           │
    │        │                    │                     │                 │
    │        ▼                    ▼                     ▼                 │
    │   EitherPath          WithStatePath           IOPath                │
    │   &lt;Error,             &lt;GameState,             &lt;Unit&gt;                │
    │   MoveCommand&gt;        MoveResult&gt;                                   │
    │                                                                     │
    │                    Composed via ForPath                             │
    └─────────────────────────────────────────────────────────────────────┘
</code></pre>
<p>The Effects Path API provides the tools for each concern:</p>
<div class="table-wrapper"><table><thead><tr><th>Concern</th><th>Path Type</th><th>Purpose</th></tr></thead><tbody>
<tr><td><strong>State Management</strong></td><td><code>WithStatePath&lt;S, A&gt;</code></td><td>Pure state transformations without mutable variables</td></tr>
<tr><td><strong>User Input</strong></td><td><code>IOPath&lt;A&gt;</code> + <code>EitherPath&lt;E, A&gt;</code></td><td>Side effects with railway-oriented validation</td></tr>
<tr><td><strong>Game Logic</strong></td><td><code>WithStatePath&lt;GameState, MoveResult&gt;</code></td><td>Railway-oriented validation and rule enforcement</td></tr>
<tr><td><strong>Side Effects</strong></td><td><code>IOPath&lt;A&gt;</code></td><td>Deferred console I/O</td></tr>
<tr><td><strong>Composition</strong></td><td><code>ForPath</code></td><td>Sequential workflow composition</td></tr>
<tr><td><strong>Data Navigation</strong></td><td>Focus DSL</td><td>Type-safe access to nested structures</td></tr>
<tr><td><strong>Iteration</strong></td><td><code>Stream</code> + <code>IntStream</code></td><td>Declarative, functional iteration patterns</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="step-1-defining-the-game-state-with-focus-dsl"><a class="header" href="#step-1-defining-the-game-state-with-focus-dsl">Step 1: Defining the Game State with Focus DSL</a></h2>
<p>Our game state uses immutable records annotated with <code>@GenerateFocus</code> to enable type-safe navigation via the Focus DSL.</p>
<pre><code class="language-java">import org.higherkindedj.optics.annotations.GenerateFocus;

// Enum for the two players
enum Player { RED, BLACK }

// Enum for the type of piece
enum PieceType { MAN, KING }

// A piece on the board, owned by a player with a certain type
@GenerateFocus
record Piece(Player owner, PieceType type) {}

// A square on the 8x8 board, identified by row and column
@GenerateFocus
record Square(int row, int col) {
  @Override
  public String toString() {
    return "" + (char)('a' + col) + (row + 1);
  }
}

// Represents an error during move parsing or validation
// The isQuit flag distinguishes quit commands from validation errors
@GenerateFocus
record GameError(String description, boolean isQuit) {
  public GameError(String description) { this(description, false); }
}

// The command to make a move from one square to another
@GenerateFocus
record MoveCommand(Square from, Square to) {}

// The outcome of a move attempt
enum MoveOutcome { SUCCESS, INVALID_MOVE, CAPTURE_MADE, GAME_WON }

@GenerateFocus
record MoveResult(MoveOutcome outcome, String message) {}
</code></pre>
<p>The main <code>GameState</code> record captures the complete game state. The initialisation uses a stream-based approach for a declarative, functional style:</p>
<pre><code class="language-java">@GenerateFocus
public record GameState(
    Map&lt;Square, Piece&gt; board,
    Player currentPlayer,
    String message,
    boolean isGameOver) {

  private static final int BLACK_START_ROW = 0;
  private static final int BLACK_END_ROW = 3;
  private static final int RED_START_ROW = 5;
  private static final int RED_END_ROW = 8;

  /**
   * Creates the initial game state using stream-based board initialisation.
   */
  public static GameState initial() {
    Map&lt;Square, Piece&gt; board =
        Stream.concat(
                placePieces(Player.BLACK, BLACK_START_ROW, BLACK_END_ROW),
                placePieces(Player.RED, RED_START_ROW, RED_END_ROW))
            .collect(Collectors.toUnmodifiableMap(Map.Entry::getKey, Map.Entry::getValue));

    return new GameState(board, Player.RED, "Game started. RED's turn.", false);
  }

  /**
   * Generates piece placements using flatMap to combine all squares across rows.
   */
  private static Stream&lt;Map.Entry&lt;Square, Piece&gt;&gt; placePieces(
      Player owner, int startRow, int endRow) {
    Piece piece = new Piece(owner, PieceType.MAN);

    return IntStream.range(startRow, endRow)
        .boxed()
        .flatMap(row -&gt;
            darkSquaresInRow(row).mapToObj(col -&gt; Map.entry(new Square(row, col), piece)));
  }

  /**
   * Returns column indices of dark (playable) squares using IntStream.iterate.
   */
  private static IntStream darkSquaresInRow(int row) {
    int startCol = (row % 2 != 0) ? 0 : 1;
    return IntStream.iterate(startCol, col -&gt; col &lt; 8, col -&gt; col + 2);
  }

  // Pure transformation methods
  GameState withMessage(String newMessage) { ... }
  GameState togglePlayer() { ... }
}
</code></pre>
<div id="admonition-functional-initialisation" class="admonition admonish-note" role="note" aria-labelledby="admonition-functional-initialisation-title">
<div class="admonition-title">
<div id="admonition-functional-initialisation-title">
<p>Functional Initialisation</p>
</div>
<a class="admonition-anchor-link" href="hkts/draughts.html#admonition-functional-initialisation"></a>
</div>
<div>
<p>The stream-based approach replaces imperative nested loops with declarative operations:</p>
<ul>
<li><code>Stream.concat()</code> combines piece placements from both players</li>
<li><code>IntStream.range().flatMap()</code> generates squares across multiple rows</li>
<li><code>IntStream.iterate()</code> calculates playable squares on each row</li>
<li><code>Collectors.toUnmodifiableMap()</code> creates an immutable result</li>
</ul>
</div>
</div>
<p>The <code>@GenerateFocus</code> annotation generates Focus path classes that enable type-safe navigation:</p>
<pre><code class="language-java">// Generated: GameStateFocus, PieceFocus, SquareFocus, etc.
// Usage:
Player owner = PieceFocus.owner().get(piece);
GameState updated = GameStateFocus.message().set("New message", state);
</code></pre>
<hr />
<h2 id="step-2-handling-user-input-with-railway-oriented-programming"><a class="header" href="#step-2-handling-user-input-with-railway-oriented-programming">Step 2: Handling User Input with Railway-Oriented Programming</a></h2>
<p>The <code>InputHandler</code> class demonstrates railway-oriented programming for input parsing. The parsing pipeline uses <code>EitherPath</code> to chain validation steps, where errors automatically short-circuit to the error track:</p>
<pre><code>readLine → checkQuit → splitInput → parseSquares → MoveCommand
   ↓          ↓           ↓            ↓
 IOPath   EitherPath  EitherPath   EitherPath
</code></pre>
<p>Each step either continues on the success track or switches to the error track. The final result captures both the side effect of reading from console (<code>IOPath</code>) and the possibility of parse errors (<code>Either</code>).</p>
<pre><code class="language-java">import org.higherkindedj.hkt.effect.IOPath;
import org.higherkindedj.hkt.effect.EitherPath;
import org.higherkindedj.hkt.effect.Path;

class InputHandler {
  private static final Scanner scanner = new Scanner(System.in);

  /**
   * Reads a move command from the console.
   * Wraps the side-effecting input operation in IOPath and delegates parsing
   * to a pure function.
   */
  static IOPath&lt;Either&lt;GameError, MoveCommand&gt;&gt; readMoveCommand() {
    return Path.io(() -&gt; {
      System.out.print("Enter move (e.g., 'a3 b4') or 'quit': ");
      return parseLine(scanner.nextLine().trim());
    });
  }

  /**
   * Parses an input line using railway-oriented programming.
   * The pipeline chains validation steps with .via(), where any error
   * short-circuits the entire pipeline.
   */
  private static Either&lt;GameError, MoveCommand&gt; parseLine(String line) {
    return checkNotQuit(line)
        .via(InputHandler::splitIntoTwoParts)
        .via(InputHandler::parseSquarePair)
        .run();
  }

  // ===== Pipeline Steps =====

  /** First step: checks if input is the quit command. */
  private static EitherPath&lt;GameError, String&gt; checkNotQuit(String line) {
    return "quit".equalsIgnoreCase(line)
        ? Path.left(new GameError("Player quit the game.", true))
        : Path.right(line);
  }

  /** Second step: splits input into exactly two parts. */
  private static EitherPath&lt;GameError, String[]&gt; splitIntoTwoParts(String line) {
    String[] parts = line.split("\\s+");
    return parts.length == 2
        ? Path.right(parts)
        : Path.left(new GameError("Invalid input. Use 'from to' format (e.g., 'c3 d4')."));
  }

  /** Third step: parses both squares and combines into MoveCommand. */
  private static EitherPath&lt;GameError, MoveCommand&gt; parseSquarePair(String[] parts) {
    return parseSquare(parts[0]).zipWith(parseSquare(parts[1]), MoveCommand::new);
  }

  // ===== Square Parsing =====

  /**
   * Parses a square notation string (e.g., "a3") using railway-oriented programming.
   */
  private static EitherPath&lt;GameError, Square&gt; parseSquare(String input) {
    return validateFormat(input).via(InputHandler::validateBoundsAndCreate);
  }

  private static EitherPath&lt;GameError, String&gt; validateFormat(String input) {
    return (input != null &amp;&amp; input.length() == 2)
        ? Path.right(input)
        : Path.left(new GameError("Invalid square format: " + input));
  }

  private static EitherPath&lt;GameError, Square&gt; validateBoundsAndCreate(String input) {
    char colChar = input.charAt(0);
    char rowChar = input.charAt(1);

    boolean validCol = colChar &gt;= 'a' &amp;&amp; colChar &lt;= 'h';
    boolean validRow = rowChar &gt;= '1' &amp;&amp; rowChar &lt;= '8';

    if (!validCol || !validRow) {
      return Path.left(new GameError("Square out of bounds (a1-h8): " + input));
    }

    return Path.right(new Square(rowChar - '1', colChar - 'a'));
  }
}
</code></pre>
<div id="admonition-the-railway-model" class="admonition admonish-note" role="note" aria-labelledby="admonition-the-railway-model-title">
<div class="admonition-title">
<div id="admonition-the-railway-model-title">
<p>The Railway Model</p>
</div>
<a class="admonition-anchor-link" href="hkts/draughts.html#admonition-the-railway-model"></a>
</div>
<div>
<p>The <code>EitherPath</code> follows the railway model: values flow on the success track (Right), while errors automatically switch to the failure track (Left). The <code>.via()</code> method chains dependent validations, and <code>zipWith</code> combines two validations, short-circuiting on the first error.</p>
</div>
</div>
<hr />
<h2 id="step-3-game-logic-with-railway-oriented-programming"><a class="header" href="#step-3-game-logic-with-railway-oriented-programming">Step 3: Game Logic with Railway-Oriented Programming</a></h2>
<p>The game logic uses railway-oriented programming where validations chain on the success track and errors automatically short-circuit to the error track. This replaces imperative if-else chains with a fluent, declarative pipeline.</p>
<pre><code class="language-java">import org.higherkindedj.hkt.effect.WithStatePath;
import org.higherkindedj.hkt.effect.EitherPath;
import org.higherkindedj.hkt.effect.Path;
import org.higherkindedj.hkt.state.State;
import org.higherkindedj.optics.focus.AffinePath;
import org.higherkindedj.optics.focus.FocusPaths;

public class GameLogic {

  /**
   * Applies a move command using railway-oriented programming.
   * Each step either continues on the success track or short-circuits to the error track.
   */
  public static WithStatePath&lt;GameState, MoveResult&gt; applyMove(MoveCommand command) {
    Square from = MoveCommandFocus.from().get(command);
    Square to = MoveCommandFocus.to().get(command);

    return Path.state(
        State.of(
            (GameState state) -&gt;
                // Railway: get piece → validate ownership → validate destination → apply move
                getPieceAt(from, state)
                    .via(piece -&gt; validateOwnership(piece, state))
                    .via(piece -&gt; validateDestinationEmpty(to, state).map(unit -&gt; piece))
                    .via(piece -&gt; validateAndApply(state, command, piece, from, to))
                    .fold(error -&gt; invalidMove(error, state), result -&gt; result)));
  }
</code></pre>
<p>Each validation step is a separate function that returns an <code>EitherPath</code>:</p>
<pre><code class="language-java">  // ===== Validation Pipeline Steps =====

  /** Gets the piece at a square using the Focus-Effect bridge. */
  private static EitherPath&lt;String, Piece&gt; getPieceAt(Square square, GameState state) {
    return AffinePath.of(FocusPaths.&lt;Square, Piece&gt;mapAt(square))
        .toEitherPath(state.board(), "No piece at " + square);
  }

  /** Validates that the piece belongs to the current player. */
  private static EitherPath&lt;String, Piece&gt; validateOwnership(Piece piece, GameState state) {
    Player currentPlayer = GameStateFocus.currentPlayer().get(state);
    Player pieceOwner = PieceFocus.owner().get(piece);

    return pieceOwner == currentPlayer
        ? Path.right(piece)
        : Path.left("Not your piece.");
  }

  /** Validates that the destination square is empty. */
  private static EitherPath&lt;String, Unit&gt; validateDestinationEmpty(Square to, GameState state) {
    boolean isEmpty =
        AffinePath.of(FocusPaths.&lt;Square, Piece&gt;mapAt(to)).getOptional(state.board()).isEmpty();

    return isEmpty
        ? Path.right(Unit.INSTANCE)
        : Path.left("Destination square " + to + " is occupied.");
  }

  /** Validates the move type and applies it if valid. */
  private static EitherPath&lt;String, StateTuple&lt;GameState, MoveResult&gt;&gt; validateAndApply(
      GameState state, MoveCommand command, Piece piece, Square from, Square to) {

    int rowDiff = SquareFocus.row().get(to) - SquareFocus.row().get(from);
    int colDiff = SquareFocus.col().get(to) - SquareFocus.col().get(from);

    if (Math.abs(rowDiff) == 1 &amp;&amp; Math.abs(colDiff) == 1) {
      return validateSimpleMove(piece, rowDiff).map(p -&gt; performMove(state, command, p));
    } else if (Math.abs(rowDiff) == 2 &amp;&amp; Math.abs(colDiff) == 2) {
      return validateJumpMove(state, command, piece, from, rowDiff, colDiff);
    } else {
      return Path.left("Move must be diagonal by 1 or 2 squares.");
    }
  }
</code></pre>
<p>State updates use the Focus DSL for cleaner transformations:</p>
<pre><code class="language-java">  /** Creates an invalid move result. */
  private static StateTuple&lt;GameState, MoveResult&gt; invalidMove(String message, GameState state) {
    return new StateTuple&lt;&gt;(
        new MoveResult(MoveOutcome.INVALID_MOVE, message),
        GameStateFocus.message().set(message, state));
  }

  /** Performs a simple move. */
  private static StateTuple&lt;GameState, MoveResult&gt; performMove(
      GameState state, MoveCommand command, Piece piece) {

    Map&lt;Square, Piece&gt; newBoard = new HashMap&lt;&gt;(state.board());
    newBoard.remove(command.from());
    newBoard.put(command.to(), piece);

    GameState movedState = GameStateFocus.board().set(newBoard, state);
    GameState finalState = checkAndKingPiece(movedState, command.to());

    return new StateTuple&lt;&gt;(
        new MoveResult(MoveOutcome.SUCCESS, "Move successful."),
        finalState.togglePlayer());
  }
</code></pre>
<div id="admonition-focus-effect-bridge" class="admonition admonish-tip" role="note" aria-labelledby="admonition-focus-effect-bridge-title">
<div class="admonition-title">
<div id="admonition-focus-effect-bridge-title">
<p>Focus-Effect Bridge</p>
</div>
<a class="admonition-anchor-link" href="hkts/draughts.html#admonition-focus-effect-bridge"></a>
</div>
<div>
<p>The bridge between Focus DSL and Effects Path API enables powerful patterns:</p>
<ul>
<li><code>AffinePath.of(FocusPaths.mapAt(key)).toEitherPath(map, error)</code> - Navigate into a Map with error handling</li>
<li><code>AffinePath.of(FocusPaths.mapAt(key)).toMaybePath(map)</code> - Navigate with optional result</li>
<li><code>GameStateFocus.message().set(msg, state)</code> - Type-safe state updates</li>
</ul>
</div>
</div>
<hr />
<h2 id="step-4-composing-with-forpath-and-extracted-handlers"><a class="header" href="#step-4-composing-with-forpath-and-extracted-handlers">Step 4: Composing with ForPath and Extracted Handlers</a></h2>
<p>The main game class uses <code>ForPath</code> to compose the turn workflow, with error handling extracted into pure predicates and separate handler functions for improved readability:</p>
<pre><code class="language-java">import org.higherkindedj.hkt.effect.IOPath;
import org.higherkindedj.hkt.effect.Path;
import org.higherkindedj.hkt.expression.ForPath;

public class Draughts {

  /**
   * Processes a single turn using ForPath for composition.
   */
  private static IOPath&lt;GameState&gt; processTurn(GameState currentState) {
    return ForPath.from(BoardDisplay.displayBoard(currentState))
        .from(ignored -&gt; InputHandler.readMoveCommand())
        .yield((ignored, result) -&gt; result)
        .via(result -&gt; handleTurnResult(result, currentState));
  }

  /**
   * Handles the result using Either.fold() with extracted handler functions.
   */
  private static IOPath&lt;GameState&gt; handleTurnResult(
      Either&lt;GameError, MoveCommand&gt; result, GameState state) {
    return result.fold(
        error -&gt; handleError(error, state),
        command -&gt; applyMove(command, state));
  }

  // ===== Error Handling =====

  /**
   * Handles an error using a pure predicate to distinguish quit from other errors.
   */
  private static IOPath&lt;GameState&gt; handleError(GameError error, GameState state) {
    return isQuitCommand(error)
        ? handleQuit(state)
        : displayErrorAndContinue(error, state);
  }

  /** Pure predicate: checks if the error represents a quit command using Focus DSL. */
  private static boolean isQuitCommand(GameError error) {
    return GameErrorFocus.isQuit().get(error);
  }

  /** Handles the quit command by setting game over and displaying farewell. */
  private static IOPath&lt;GameState&gt; handleQuit(GameState state) {
    return Path.io(() -&gt; {
      System.out.println("Goodbye!");
      return GameStateFocus.isGameOver().set(true, state);
    });
  }

  /** Displays an error message and returns the unchanged state. */
  private static IOPath&lt;GameState&gt; displayErrorAndContinue(GameError error, GameState state) {
    return Path.io(() -&gt; {
      System.out.println("Error: " + GameErrorFocus.description().get(error));
      return state;
    });
  }

  // ===== Move Application =====

  /** Applies a valid move command to the game state. */
  private static IOPath&lt;GameState&gt; applyMove(MoveCommand command, GameState state) {
    return Path.ioPure(GameLogic.applyMove(command).run(state).state());
  }
}
</code></pre>
<div id="admonition-functional-error-handling" class="admonition admonish-note" role="note" aria-labelledby="admonition-functional-error-handling-title">
<div class="admonition-title">
<div id="admonition-functional-error-handling-title">
<p>Functional Error Handling</p>
</div>
<a class="admonition-anchor-link" href="hkts/draughts.html#admonition-functional-error-handling"></a>
</div>
<div>
<p>The error handling demonstrates several functional patterns:</p>
<ul>
<li><strong>Pure predicates</strong>: <code>isQuitCommand()</code> uses <code>GameErrorFocus.isQuit()</code> for type-safe access</li>
<li><strong>Type-safe flags</strong>: The <code>isQuit</code> field in <code>GameError</code> avoids string matching</li>
<li><strong>Extracted handlers</strong>: Each error case has its own handler function</li>
<li><strong>Separation of concerns</strong>: Logic is cleanly separated from side effects</li>
</ul>
</div>
</div>
<p>The <code>ForPath</code> comprehension makes the workflow declarative:</p>
<ol>
<li>Display the board (side effect)</li>
<li>Read user input (side effect returning <code>Either</code>)</li>
<li>Yield the result for further processing</li>
<li>Handle errors or apply moves via extracted functions</li>
</ol>
<hr />
<h2 id="step-5-the-game-loop"><a class="header" href="#step-5-the-game-loop">Step 5: The Game Loop</a></h2>
<p>The game loop is a recursive <code>IOPath</code> computation that uses a ternary expression for clarity:</p>
<pre><code class="language-java">  /**
   * The main game loop as a recursive IOPath computation.
   * Creates an IOPath representing the entire game.
   */
  private static IOPath&lt;Unit&gt; gameLoop(GameState gameState) {
    return gameState.isGameOver()
        ? BoardDisplay.displayBoard(gameState)
        : processTurn(gameState).via(Draughts::gameLoop);
  }

  public static void main(String[] args) {
    // Build and execute the complete game
    IOPath&lt;Unit&gt; game =
        Path.ioPure(GameState.initial())
            .via(Draughts::gameLoop)
            .then(() -&gt; Path.ioRunnable(() -&gt; System.out.println("Thank you for playing!")));

    game.unsafeRun();
  }
</code></pre>
<div id="admonition-deferred-execution" class="admonition admonish-note" role="note" aria-labelledby="admonition-deferred-execution-title">
<div class="admonition-title">
<div id="admonition-deferred-execution-title">
<p>Deferred Execution</p>
</div>
<a class="admonition-anchor-link" href="hkts/draughts.html#admonition-deferred-execution"></a>
</div>
<div>
<p>The entire game is constructed as a pure <code>IOPath</code> value. No side effects occur until <code>unsafeRun()</code> is called at the application boundary. This separation makes the code easier to test and reason about.</p>
</div>
</div>
<hr />
<h2 id="step-6-displaying-the-board-with-streams-and-maybepath"><a class="header" href="#step-6-displaying-the-board-with-streams-and-maybepath">Step 6: Displaying the Board with Streams and MaybePath</a></h2>
<p>The display uses <code>IOPath</code> to encapsulate console output, with streams for declarative rendering and <code>MaybePath</code> for optional piece handling:</p>
<pre><code class="language-java">public class BoardDisplay {

  private static final String BOARD_HEADER = "  a b c d e f g h";
  private static final String BOARD_BORDER = " +-----------------+";

  /**
   * Creates an IOPath that, when executed, displays the current game state.
   */
  public static IOPath&lt;Unit&gt; displayBoard(GameState gameState) {
    return Path.ioRunnable(() -&gt; System.out.println(renderGameState(gameState)));
  }

  /**
   * Renders the complete game state as a string using stream composition.
   */
  private static String renderGameState(GameState state) {
    return String.join("\n",
        "",
        BOARD_HEADER,
        BOARD_BORDER,
        renderBoard(state),
        BOARD_BORDER,
        BOARD_HEADER,
        "",
        state.message(),
        renderCurrentPlayer(state));
  }

  /**
   * Renders all board rows using streams.
   */
  private static String renderBoard(GameState state) {
    return IntStream.iterate(7, row -&gt; row &gt;= 0, row -&gt; row - 1)
        .mapToObj(row -&gt; renderRow(state, row))
        .collect(Collectors.joining("\n"));
  }

  /**
   * Renders a single row of the board.
   */
  private static String renderRow(GameState state, int row) {
    String squares = IntStream.range(0, 8)
        .mapToObj(col -&gt; renderSquare(state, row, col))
        .collect(Collectors.joining(" "));

    int displayRow = row + 1;
    return displayRow + "| " + squares + " |" + displayRow;
  }

  /**
   * Renders a single square using MaybePath for optional piece handling.
   */
  private static String renderSquare(GameState state, int row, int col) {
    return AffinePath.of(FocusPaths.&lt;Square, Piece&gt;mapAt(new Square(row, col)))
        .toMaybePath(state.board())
        .map(BoardDisplay::pieceToChar)
        .getOrElse(".");
  }

  /**
   * Pure function converting a piece to its display character.
   */
  private static String pieceToChar(Piece piece) {
    char base = PieceFocus.owner().get(piece) == Player.RED ? 'r' : 'b';
    char display = PieceFocus.type().get(piece) == PieceType.KING
        ? Character.toUpperCase(base)
        : base;
    return String.valueOf(display);
  }

  private static String renderCurrentPlayer(GameState state) {
    return state.isGameOver()
        ? ""
        : "Current Player: " + GameStateFocus.currentPlayer().get(state);
  }
}
</code></pre>
<div id="admonition-functional-rendering-patterns" class="admonition admonish-note" role="note" aria-labelledby="admonition-functional-rendering-patterns-title">
<div class="admonition-title">
<div id="admonition-functional-rendering-patterns-title">
<p>Functional Rendering Patterns</p>
</div>
<a class="admonition-anchor-link" href="hkts/draughts.html#admonition-functional-rendering-patterns"></a>
</div>
<div>
<p>The display uses several functional patterns:</p>
<ul>
<li><strong>Streams</strong>: <code>IntStream.iterate()</code> and <code>mapToObj()</code> for declarative row/column iteration</li>
<li><strong>MaybePath</strong>: <code>toMaybePath().map().getOrElse()</code> safely handles absent pieces</li>
<li><strong>Pure functions</strong>: <code>pieceToChar()</code> has no side effects and uses Focus DSL</li>
<li><strong>String composition</strong>: <code>String.join()</code> and <code>Collectors.joining()</code> for clean concatenation</li>
</ul>
</div>
</div>
<h3 id="playing-the-game"><a class="header" href="#playing-the-game">Playing the Game</a></h3>
<p><img src="hkts/../images/draughts_game.png" alt="draughts_game.png" /></p>
<p>In the game we can see BLACK has "kinged" a piece by reaching <code>e8</code>.</p>
<hr />
<h2 id="step-7-adding-multi-jump-rules-with-stream-based-jump-detection"><a class="header" href="#step-7-adding-multi-jump-rules-with-stream-based-jump-detection">Step 7: Adding Multi-Jump Rules with Stream-Based Jump Detection</a></h2>
<p>A key rule in draughts is that captures must be completed: if a capture leads to another possible capture with the same piece, that jump must also be taken.</p>
<p>The beauty of the functional approach is that we only need to modify the core rules in <code>GameLogic.java</code>. The game loop, IO handlers, and data models remain unchanged.</p>
<p>The jump detection uses a stream-based approach instead of nested loops for cleaner functional style:</p>
<pre><code class="language-java">  /** Jump direction offsets for checking available jumps. */
  private static final int[] JUMP_OFFSETS = {-2, 2};

  /** Record representing a jump direction (row and column offsets). */
  private record JumpDirection(int rowOffset, int colOffset) {}

  /**
   * Checks if a piece can make any valid jump using MaybePath.
   */
  private static boolean canPieceJump(GameState state, Square from) {
    return AffinePath.of(FocusPaths.&lt;Square, Piece&gt;mapAt(from))
        .toMaybePath(state.board())
        .map(piece -&gt; hasAnyValidJump(state, from, piece))
        .getOrElse(false);
  }

  /**
   * Checks all directions for valid jumps using streams.
   */
  private static boolean hasAnyValidJump(GameState state, Square from, Piece piece) {
    Player owner = PieceFocus.owner().get(piece);
    PieceType type = PieceFocus.type().get(piece);

    return generateJumpDirections()
        .filter(dir -&gt; isValidJumpDirection(type, owner, dir.rowOffset()))
        .anyMatch(dir -&gt; isValidJump(state, from, dir, owner));
  }

  /**
   * Generates all possible jump direction pairs using flatMap.
   */
  private static Stream&lt;JumpDirection&gt; generateJumpDirections() {
    return IntStream.of(JUMP_OFFSETS)
        .boxed()
        .flatMap(row -&gt; IntStream.of(JUMP_OFFSETS).mapToObj(col -&gt; new JumpDirection(row, col)));
  }

  /** Checks if a jump direction is valid for the piece type. */
  private static boolean isValidJumpDirection(PieceType type, Player owner, int rowOffset) {
    if (type == PieceType.KING) return true;
    // Men can only jump forward
    return !((owner == Player.RED &amp;&amp; rowOffset &gt; 0) || (owner == Player.BLACK &amp;&amp; rowOffset &lt; 0));
  }

  /** Checks if a specific jump is valid using MaybePath. */
  private static boolean isValidJump(GameState state, Square from, JumpDirection dir, Player owner) {
    int toRow = from.row() + dir.rowOffset();
    int toCol = from.col() + dir.colOffset();

    if (toRow &lt; 0 || toRow &gt; 7 || toCol &lt; 0 || toCol &gt; 7) return false;

    Square to = new Square(toRow, toCol);
    Square jumpedSquare = new Square(from.row() + dir.rowOffset() / 2, from.col() + dir.colOffset() / 2);

    // Destination must be empty
    boolean destEmpty =
        AffinePath.of(FocusPaths.&lt;Square, Piece&gt;mapAt(to)).getOptional(state.board()).isEmpty();

    // Must have opponent piece to jump
    boolean hasOpponentPiece =
        AffinePath.of(FocusPaths.&lt;Square, Piece&gt;mapAt(jumpedSquare))
            .toMaybePath(state.board())
            .filter(p -&gt; PieceFocus.owner().get(p) != owner)
            .run()
            .isJust();

    return destEmpty &amp;&amp; hasOpponentPiece;
  }
</code></pre>
<div id="admonition-stream-based-iteration" class="admonition admonish-note" role="note" aria-labelledby="admonition-stream-based-iteration-title">
<div class="admonition-title">
<div id="admonition-stream-based-iteration-title">
<p>Stream-Based Iteration</p>
</div>
<a class="admonition-anchor-link" href="hkts/draughts.html#admonition-stream-based-iteration"></a>
</div>
<div>
<p>The jump detection replaces nested imperative loops with:</p>
<ul>
<li><code>IntStream.of().flatMap()</code> - Generates all direction combinations</li>
<li><code>Stream.filter()</code> - Removes invalid directions for piece type</li>
<li><code>Stream.anyMatch()</code> - Short-circuits on first valid jump found</li>
<li><code>MaybePath.filter().run().isJust()</code> - Safely checks for opponent piece</li>
</ul>
</div>
</div>
<p>After a capture, we check for further jumps using <code>MaybePath</code>:</p>
<pre><code class="language-java">  private static StateTuple&lt;GameState, MoveResult&gt; performJump(...) {
    // ... perform the jump and update board ...

    // Check for win condition using MaybePath
    return checkWinCondition(stateAfterKinging)
        .map(winner -&gt; createWinResult(winner, stateAfterKinging))
        .getOrElseGet(() -&gt; checkMultiJumpOrEndTurn(stateAfterKinging, command.to()));
  }

  /** Checks for multi-jump or ends the turn. */
  private static StateTuple&lt;GameState, MoveResult&gt; checkMultiJumpOrEndTurn(
      GameState state, Square position) {
    return canPieceJump(state, position)
        ? new StateTuple&lt;&gt;(
            new MoveResult(MoveOutcome.CAPTURE_MADE,
                "Capture successful. You must jump again with the same piece."),
            GameStateFocus.message().set(
                "Capture successful. You must jump again with the same piece.", state))
        : new StateTuple&lt;&gt;(
            new MoveResult(MoveOutcome.CAPTURE_MADE, "Capture successful."),
            state.togglePlayer());
  }
</code></pre>
<hr />
<h2 id="under-the-hood-the-monads"><a class="header" href="#under-the-hood-the-monads">Under the Hood: The Monads</a></h2>
<p>The Effects Path API provides a user-friendly layer over powerful functional abstractions. Understanding these foundations helps when you need more advanced patterns.</p>
<h3 id="the-state-monad"><a class="header" href="#the-state-monad">The State Monad</a></h3>
<p><code>WithStatePath&lt;S, A&gt;</code> wraps the State monad, which represents computations that thread state through a sequence of operations:</p>
<pre><code class="language-java">// State&lt;S, A&gt; represents: S -&gt; (A, S)
// A function from initial state to (result, new state)

// WithStatePath provides a fluent API over State
WithStatePath&lt;Integer, String&gt; computation = WithStatePath.&lt;Integer&gt;get()
    .via(n -&gt; WithStatePath.modify((Integer x) -&gt; x + 1)
        .map(ignored -&gt; "Count: " + (n + 1)));

StateTuple&lt;Integer, String&gt; result = computation.run(0);
// result.value() = "Count: 1", result.state() = 1
</code></pre>
<h3 id="the-either-monad"><a class="header" href="#the-either-monad">The Either Monad</a></h3>
<p><code>EitherPath&lt;E, A&gt;</code> wraps Either, providing typed error handling that short-circuits on failure:</p>
<pre><code class="language-java">// Either&lt;E, A&gt; is either Left(error) or Right(value)
// Operations on Right continue; operations on Left propagate the error

EitherPath&lt;String, Integer&gt; result = Path.&lt;String, Integer&gt;right(10)
    .via(n -&gt; n &gt; 5 ? Path.right(n * 2) : Path.left("Too small"))
    .map(n -&gt; n + 1);
// result.run() = Right(21)
</code></pre>
<h3 id="the-io-monad"><a class="header" href="#the-io-monad">The IO Monad</a></h3>
<p><code>IOPath&lt;A&gt;</code> wraps IO, representing deferred side effects:</p>
<pre><code class="language-java">// IO&lt;A&gt; describes a computation that, when run, produces A
// Nothing happens until unsafeRun() is called

IOPath&lt;String&gt; readName = Path.io(() -&gt; {
    System.out.print("Name: ");
    return scanner.nextLine();
});

// readName is a value describing the action - no I/O yet
String name = readName.unsafeRun();  // Now the I/O happens
</code></pre>
<h3 id="higher-kinded-types-1"><a class="header" href="#higher-kinded-types-1">Higher-Kinded Types</a></h3>
<p>Java lacks native support for higher-kinded types. Higher-Kinded-J provides a simulation using <code>Kind&lt;F, A&gt;</code> as a bridge type:</p>
<pre><code class="language-java">// We cannot write: &lt;F&gt; F&lt;A&gt; map(F&lt;A&gt; fa, Function&lt;A, B&gt; f)
// But we can write: &lt;F&gt; Kind&lt;F, B&gt; map(Kind&lt;F, A&gt; fa, Function&lt;A, B&gt; f)

// The Path types unwrap the complexity for everyday use
</code></pre>
<p>The Effects Path API abstracts over these foundations, providing a consistent, fluent interface that works the same way regardless of which effect type you use.</p>
<hr />
<h2 id="why-this-functional-approach-is-better"><a class="header" href="#why-this-functional-approach-is-better">Why This Functional Approach is Better</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th>Traditional</th><th>Effects Path API</th></tr></thead><tbody>
<tr><td><strong>Testability</strong></td><td>Mock frameworks, complex setup</td><td>Pure functions, direct assertions</td></tr>
<tr><td><strong>Error Handling</strong></td><td>Exceptions, null checks</td><td>Railway-oriented (<code>EitherPath.via()</code>)</td></tr>
<tr><td><strong>Validation</strong></td><td>Nested if-else chains</td><td>Fluent pipelines that short-circuit</td></tr>
<tr><td><strong>State Management</strong></td><td>Mutable fields</td><td>Immutable transforms (<code>WithStatePath</code>)</td></tr>
<tr><td><strong>Side Effects</strong></td><td>Scattered throughout code</td><td>Isolated at boundaries (<code>IOPath</code>)</td></tr>
<tr><td><strong>Composability</strong></td><td>Nested callbacks</td><td>Fluent chaining (<code>via</code>, <code>map</code>)</td></tr>
<tr><td><strong>Iteration</strong></td><td>Imperative loops</td><td>Streams with <code>flatMap</code>, <code>filter</code>, <code>anyMatch</code></td></tr>
<tr><td><strong>Optional Data</strong></td><td>Manual null checks</td><td><code>MaybePath.map().getOrElse()</code></td></tr>
<tr><td><strong>Data Access</strong></td><td>Manual null checks</td><td>Type-safe paths (Focus DSL)</td></tr>
</tbody></table>
</div>
<p>The <code>GameLogic</code> class is completely pure; you can test the entire rules engine by providing a <code>GameState</code> and a <code>MoveCommand</code>, then asserting on the result. No mocking of console I/O required.</p>
<hr />
<div id="admonition-see-also" class="admonition admonish-tip" role="note" aria-labelledby="admonition-see-also-title">
<div class="admonition-title">
<div id="admonition-see-also-title">
<p>See Also</p>
</div>
<a class="admonition-anchor-link" href="hkts/draughts.html#admonition-see-also"></a>
</div>
<div>
<ul>
<li><a href="hkts/../effect/effect_path_overview.html">Effect Path Overview</a> - The railway model for effect composition</li>
<li><a href="hkts/../optics/focus_dsl.html">Focus DSL</a> - Type-safe data navigation</li>
<li><a href="hkts/../effect/focus_integration.html">Focus-Effect Integration</a> - Bridging optics and effects</li>
<li><a href="hkts/../functional/for_comprehension.html">ForPath Comprehensions</a> - For-comprehension syntax</li>
<li><a href="hkts/../effect/path_types.html">WithStatePath</a> - State management patterns</li>
</ul>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="hkts/order-walkthrough.html">An Order Workflow</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="hands-on-learning"><a class="header" href="#hands-on-learning">Hands-On Learning</a></h1>
<blockquote>
<p><em>"You look at where you're going and where you are and it never makes sense, but then you look back at where you've been and a pattern seems to emerge."</em></p>
<p>– Robert M. Pirsig, <em>Zen and the Art of Motorcycle Maintenance</em></p>
</blockquote>
<hr />
<p>Reading about functional programming is one thing. Writing it is another entirely.</p>
<p>These tutorials exist because understanding emerges from doing. You will encounter exercises where you replace <code>answerRequired()</code> with working code. Tests will fail, red and insistent, until your solution is correct. The failure is not punishment; it is feedback. Each red test is a question; each green test is comprehension made concrete.</p>
<p>The pattern Pirsig describes applies precisely here. Midway through an exercise on Applicative composition, the relationship between <code>map</code> and <code>ap</code> may feel arbitrary. Three tutorials later, building a validation pipeline, the pattern clicks. You look back at where you've been, and suddenly the earlier struggles make sense. This is not a flaw in the learning process. It <em>is</em> the learning process.</p>
<p><strong>Eight journeys</strong> are available, each designed to be completed in 22-40 minutes. Do one per sitting. Let concepts consolidate before moving on.</p>
<p>Expect to struggle. Expect moments of confusion. These are not signs that something is wrong. They are signs that learning is happening.</p>
<hr />
<h2 id="the-learning-loop"><a class="header" href="#the-learning-loop">The Learning Loop</a></h2>
<pre><code>    ┌─────────────────────────────────────────────────────────────┐
    │                                                             │
    │    READ  ──────►  WRITE  ──────►  RUN  ──────►  OBSERVE     │
    │      │              │              │               │        │
    │      │              │              │               │        │
    │      ▼              ▼              ▼               ▼        │
    │   Exercise      Replace        Execute          Red or      │
    │   description   answerRequired()  test          Green?      │
    │                                                             │
    │                         │                                   │
    │                         ▼                                   │
    │              ┌──────────┴──────────┐                        │
    │              │                     │                        │
    │           GREEN                   RED                       │
    │         (Next exercise)     (Read error, iterate)           │
    │                                                             │
    └─────────────────────────────────────────────────────────────┘
</code></pre>
<p>The loop is simple. The understanding it produces is not.</p>
<hr />
<h2 id="eight-journeys"><a class="header" href="#eight-journeys">Eight Journeys</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Journey</th><th>Focus</th><th>Duration</th><th>Exercises</th></tr></thead><tbody>
<tr><td><strong>Core: Foundations</strong></td><td>HKT simulation, Functor, Applicative, Monad</td><td>~38 min</td><td>24</td></tr>
<tr><td><strong>Core: Error Handling</strong></td><td>MonadError, concrete types, real-world patterns</td><td>~30 min</td><td>20</td></tr>
<tr><td><strong>Core: Advanced</strong></td><td>Natural Transformations, Coyoneda, Free Applicative</td><td>~26 min</td><td>16</td></tr>
<tr><td><strong>Effect API</strong></td><td>Effect paths, ForPath, Effect Contexts</td><td>~65 min</td><td>15</td></tr>
<tr><td><strong>Optics: Lens &amp; Prism</strong></td><td>Lens basics, Prism, Affine</td><td>~40 min</td><td>30</td></tr>
<tr><td><strong>Optics: Traversals</strong></td><td>Traversals, composition, practical applications</td><td>~40 min</td><td>27</td></tr>
<tr><td><strong>Optics: Fluent &amp; Free</strong></td><td>Fluent API, Free Monad DSL</td><td>~37 min</td><td>22</td></tr>
<tr><td><strong>Optics: Focus DSL</strong></td><td>Type-safe path navigation</td><td>~22 min</td><td>18</td></tr>
</tbody></table>
</div>
<p>Start with whichever interests you most. The <a href="tutorials/learning_paths.html">Learning Paths</a> guide suggests sequences for different goals.</p>
<hr />
<h2 id="what-youll-learn-1"><a class="header" href="#what-youll-learn-1">What You'll Learn</a></h2>
<div id="admonition-in-this-chapter" class="admonition admonish-info" role="note" aria-labelledby="admonition-in-this-chapter-title">
<div class="admonition-title">
<div id="admonition-in-this-chapter-title">
<p>In This Chapter</p>
</div>
<a class="admonition-anchor-link" href="tutorials/ch_intro.html#admonition-in-this-chapter"></a>
</div>
<div>
<ul>
<li><strong>Core Types Journeys</strong> – Three journeys building from basic <code>Kind&lt;F, A&gt;</code> wrapping through error handling to advanced patterns like Coyoneda and Free Applicative.</li>
<li><strong>Effect API Journey</strong> – Learn the recommended user-facing API for working with functional effects.</li>
<li><strong>Optics Journeys</strong> – Four journeys progressing from simple Lens operations through Traversals, the Free Monad DSL, and the Focus DSL.</li>
<li><strong>Learning Paths</strong> – Curated sequences of journeys for different goals and time budgets.</li>
<li><strong>Solutions Guide</strong> – When you're genuinely stuck, reference implementations are available. Try to struggle first; the learning happens in the struggle.</li>
<li><strong>Troubleshooting</strong> – Common errors and their solutions.</li>
</ul>
</div>
</div>
<hr />
<h2 id="chapter-contents-2"><a class="header" href="#chapter-contents-2">Chapter Contents</a></h2>
<ol>
<li><a href="tutorials/tutorials_intro.html">Interactive Tutorials</a> - Getting started with the tutorial system</li>
<li><strong>Core Types</strong>
<ul>
<li><a href="tutorials/coretypes/foundations_journey.html">Foundations Journey</a> - Kind basics to Monad</li>
<li><a href="tutorials/coretypes/error_handling_journey.html">Error Handling Journey</a> - MonadError and concrete types</li>
<li><a href="tutorials/coretypes/advanced_journey.html">Advanced Patterns Journey</a> - Natural transformations to Free Applicative</li>
</ul>
</li>
<li><strong>Effect API</strong>
<ul>
<li><a href="tutorials/effect/effect_journey.html">Effect API Journey</a> - The recommended user-facing API</li>
</ul>
</li>
<li><strong>Optics</strong>
<ul>
<li><a href="tutorials/optics/lens_prism_journey.html">Lens &amp; Prism Journey</a> - Fundamental optics</li>
<li><a href="tutorials/optics/traversals_journey.html">Traversals &amp; Practice Journey</a> - Collections and real-world use</li>
<li><a href="tutorials/optics/fluent_free_journey.html">Fluent &amp; Free DSL Journey</a> - Advanced APIs</li>
<li><a href="tutorials/optics/focus_dsl_journey.html">Focus DSL Journey</a> - Type-safe path navigation</li>
</ul>
</li>
<li><a href="tutorials/learning_paths.html">Learning Paths</a> - Recommended journey sequences</li>
<li><a href="tutorials/solutions_guide.html">Solutions Guide</a> - Reference implementations</li>
<li><a href="tutorials/troubleshooting.html">Troubleshooting</a> - Common issues and solutions</li>
</ol>
<hr />
<p><strong>Next:</strong> <a href="tutorials/tutorials_intro.html">Interactive Tutorials</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="interactive-tutorials-learn-higher-kinded-j-by-building"><a class="header" href="#interactive-tutorials-learn-higher-kinded-j-by-building">Interactive Tutorials: Learn Higher-Kinded-J by Building</a></h1>
<p>The best way to understand Higher-Kinded Types and Optics isn't just reading about them: it's writing code, running tests, and seeing the patterns come alive in your IDE.</p>
<h2 id="what-makes-these-tutorials-different"><a class="header" href="#what-makes-these-tutorials-different">What Makes These Tutorials Different?</a></h2>
<p>Rather than passive reading, you'll:</p>
<ul>
<li><strong>Write Real Code</strong>: Replace <code>answerRequired()</code> placeholders with working implementations</li>
<li><strong>Get Immediate Feedback</strong>: Each test fails until your solution is correct</li>
<li><strong>Build Progressively</strong>: Earlier concepts become tools for later challenges</li>
<li><strong>See Practical Applications</strong>: Every exercise solves a real problem Java developers face</li>
</ul>
<p>Think of these as a guided laboratory for functional programming patterns in Java.</p>
<h2 id="eight-focused-journeys"><a class="header" href="#eight-focused-journeys">Eight Focused Journeys</a></h2>
<p>Each journey is designed for a single sitting (22-40 minutes). Short enough to stay focused. Long enough to build real understanding.</p>
<h3 id="effect-api-journey-recommended"><a class="header" href="#effect-api-journey-recommended">Effect API Journey (Recommended)</a></h3>
<div id="admonition-start-here-for-practical-use" class="admonition admonish-tip" role="note" aria-labelledby="admonition-start-here-for-practical-use-title">
<div class="admonition-title">
<div id="admonition-start-here-for-practical-use-title">
<p>Start Here for Practical Use</p>
</div>
<a class="admonition-anchor-link" href="tutorials/tutorials_intro.html#admonition-start-here-for-practical-use"></a>
</div>
<div>
<p>After completing Core: Foundations, the <strong>Effect API journey</strong> is the recommended next step. It teaches the primary user-facing API of Higher-Kinded-J.</p>
</div>
</div>
<div class="table-wrapper"><table><thead><tr><th>Journey</th><th>Duration</th><th>Exercises</th><th>Focus</th></tr></thead><tbody>
<tr><td><a href="tutorials/effect/effect_journey.html">Effect API</a></td><td>~65 min</td><td>15</td><td>Effect paths, ForPath, Contexts</td></tr>
</tbody></table>
</div>
<h3 id="core-types-journeys-foundation"><a class="header" href="#core-types-journeys-foundation">Core Types Journeys (Foundation)</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Journey</th><th>Duration</th><th>Exercises</th><th>Focus</th></tr></thead><tbody>
<tr><td><a href="tutorials/coretypes/foundations_journey.html">Foundations</a></td><td>~38 min</td><td>24</td><td>Kind, Functor, Applicative, Monad</td></tr>
<tr><td><a href="tutorials/coretypes/error_handling_journey.html">Error Handling</a></td><td>~30 min</td><td>20</td><td>MonadError, Either, Maybe, Validated</td></tr>
<tr><td><a href="tutorials/coretypes/advanced_journey.html">Advanced Patterns</a></td><td>~26 min</td><td>16</td><td>Natural Transformations, Coyoneda, Free Ap</td></tr>
</tbody></table>
</div>
<h3 id="optics-journeys"><a class="header" href="#optics-journeys">Optics Journeys</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Journey</th><th>Duration</th><th>Exercises</th><th>Focus</th></tr></thead><tbody>
<tr><td><a href="tutorials/optics/lens_prism_journey.html">Lens &amp; Prism</a></td><td>~40 min</td><td>30</td><td>Lens, Prism, Affine fundamentals</td></tr>
<tr><td><a href="tutorials/optics/traversals_journey.html">Traversals &amp; Practice</a></td><td>~40 min</td><td>27</td><td>Traversals, composition, real-world use</td></tr>
<tr><td><a href="tutorials/optics/fluent_free_journey.html">Fluent &amp; Free DSL</a></td><td>~37 min</td><td>22</td><td>Fluent API, Free Monad DSL</td></tr>
<tr><td><a href="tutorials/optics/focus_dsl_journey.html">Focus DSL</a></td><td>~22 min</td><td>18</td><td>Type-safe path navigation</td></tr>
</tbody></table>
</div>
<h2 id="how-the-tutorials-work"><a class="header" href="#how-the-tutorials-work">How the Tutorials Work</a></h2>
<h3 id="the-exercise-pattern"><a class="header" href="#the-exercise-pattern">The Exercise Pattern</a></h3>
<p>Each tutorial contains multiple exercises following this pattern:</p>
<pre><code class="language-java">@Test
void exercise1_yourFirstChallenge() {
    // 1. Context: What you're working with
    Either&lt;String, Integer&gt; value = Either.right(42);

    // 2. Task: What you need to implement
    // TODO: Transform the value by doubling it
    Either&lt;String, Integer&gt; result = answerRequired();

    // 3. Verification: The test checks your solution
    assertThat(result.getRight()).isEqualTo(84);
}
</code></pre>
<p>Your job is to replace <code>answerRequired()</code> with working code. The test will fail with a clear error message until you get it right.</p>
<h3 id="the-learning-loop-1"><a class="header" href="#the-learning-loop-1">The Learning Loop</a></h3>
<ol>
<li><strong>Read</strong> the exercise description and hints</li>
<li><strong>Write</strong> your solution in place of <code>answerRequired()</code></li>
<li><strong>Run</strong> the test (Ctrl+Shift+F10 in IntelliJ, Cmd+Shift+T in Eclipse)</li>
<li><strong>Observe</strong> the result:
<ul>
<li>✅ <strong>Green</strong>: Correct! Move to the next exercise</li>
<li>❌ <strong>Red</strong>: Read the error message carefully; it contains clues</li>
</ul>
</li>
<li><strong>Iterate</strong> until you understand the pattern</li>
</ol>
<h3 id="getting-unstuck"><a class="header" href="#getting-unstuck">Getting Unstuck</a></h3>
<p>If you're struggling with an exercise:</p>
<ol>
<li><strong>Read the Javadoc carefully</strong>: The comments contain hints and links to relevant documentation</li>
<li><strong>Check the type signatures</strong>: What types does the method expect? What does it return?</li>
<li><strong>Look at earlier exercises</strong>: You might have already used a similar pattern</li>
<li><strong>Consult the documentation</strong>: Links are provided throughout the tutorials</li>
<li><strong>Peek at the solution</strong>: Solutions are in <code>solutions/coretypes/</code> and <code>solutions/optics/</code> directories</li>
</ol>
<blockquote>
<p><strong>Resist the temptation to copy-paste solutions!</strong> You'll learn far more from struggling for 5 minutes than from reading the answer immediately. The struggle is where the learning happens.</p>
</blockquote>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<h3 id="required-knowledge"><a class="header" href="#required-knowledge">Required Knowledge</a></h3>
<ul>
<li><strong>Java Fundamentals</strong>: Records, generics, lambda expressions, method references</li>
<li><strong>IDE Proficiency</strong>: Running tests, navigating code, using auto-completion</li>
<li><strong>Basic Functional Concepts</strong>: Helpful but not required; we'll introduce them as needed</li>
</ul>
<h3 id="technical-setup"><a class="header" href="#technical-setup">Technical Setup</a></h3>
<ul>
<li><strong>Java 25 or later</strong>: The library uses modern Java features</li>
<li><strong>Build Tool</strong>: Gradle or Maven with the Higher-Kinded-J dependencies configured</li>
<li><strong>IDE</strong>: IntelliJ IDEA, Eclipse, or VS Code with Java extensions</li>
</ul>
<h3 id="verify-your-setup"><a class="header" href="#verify-your-setup">Verify Your Setup</a></h3>
<p>Run this simple test to ensure everything is configured correctly:</p>
<pre><code class="language-bash">./gradlew :hkj-examples:test --tests "*Tutorial01_KindBasics.exercise1*"
</code></pre>
<p>If you see a test failure with "Answer required", you're ready to go!</p>
<h2 id="recommended-learning-paths"><a class="header" href="#recommended-learning-paths">Recommended Learning Paths</a></h2>
<p>See the full <a href="tutorials/learning_paths.html">Learning Paths</a> guide for detailed sequences. Here's a quick overview:</p>
<h3 id="quick-start-2-sessions"><a class="header" href="#quick-start-2-sessions">Quick Start (2 sessions)</a></h3>
<p><a href="tutorials/coretypes/foundations_journey.html">Core: Foundations</a> → <a href="tutorials/effect/effect_journey.html">Effect API</a></p>
<h3 id="practical-fp-4-sessions"><a class="header" href="#practical-fp-4-sessions">Practical FP (4 sessions)</a></h3>
<p><a href="tutorials/coretypes/foundations_journey.html">Core: Foundations</a> → <a href="tutorials/coretypes/error_handling_journey.html">Error Handling</a> → <a href="tutorials/effect/effect_journey.html">Effect API</a> → <a href="tutorials/optics/lens_prism_journey.html">Optics: Lens &amp; Prism</a></p>
<h3 id="optics-specialist-4-sessions"><a class="header" href="#optics-specialist-4-sessions">Optics Specialist (4 sessions)</a></h3>
<p><a href="tutorials/optics/lens_prism_journey.html">Lens &amp; Prism</a> → <a href="tutorials/optics/traversals_journey.html">Traversals</a> → <a href="tutorials/optics/fluent_free_journey.html">Fluent &amp; Free</a> → <a href="tutorials/optics/focus_dsl_journey.html">Focus DSL</a></p>
<h3 id="full-curriculum-8-sessions"><a class="header" href="#full-curriculum-8-sessions">Full Curriculum (8 sessions)</a></h3>
<p>All journeys in recommended order. See <a href="tutorials/learning_paths.html">Learning Paths</a>.</p>
<h2 id="what-youll-build"><a class="header" href="#what-youll-build">What You'll Build</a></h2>
<p>By the end of these tutorials, you'll have hands-on experience building:</p>
<h3 id="from-core-types-journeys"><a class="header" href="#from-core-types-journeys">From Core Types Journeys:</a></h3>
<ul>
<li>A <strong>form validation system</strong> using Applicative to combine independent checks</li>
<li>A <strong>data processing pipeline</strong> using Monad to chain dependent operations</li>
<li>An <strong>error handling workflow</strong> using <code>Either</code> and <code>Validated</code> for robust failure management</li>
<li>A <strong>configuration system</strong> using <code>Reader</code> monad for dependency injection</li>
</ul>
<h3 id="from-optics-journeys"><a class="header" href="#from-optics-journeys">From Optics Journeys:</a></h3>
<ul>
<li>A <strong>user profile editor</strong> with deep nested updates using Lens composition</li>
<li>An <strong>e-commerce order processor</strong> using Traversals for bulk operations</li>
<li>A <strong>data validation pipeline</strong> combining Lens, Prism, and Traversal</li>
<li>A <strong>multi-step workflow builder</strong> using the Free Monad DSL with logging and validation</li>
</ul>
<h2 id="tips-for-success"><a class="header" href="#tips-for-success">Tips for Success</a></h2>
<ol>
<li>
<p><strong>One journey per sitting</strong>: Each journey builds internal momentum. Splitting them reduces learning.</p>
</li>
<li>
<p><strong>Read the Hints</strong>: They're there to guide you, not to slow you down. The Javadoc comments often contain the answer.</p>
</li>
<li>
<p><strong>Run Tests Frequently</strong>: Don't write all exercises at once. Get one green, then move to the next.</p>
</li>
<li>
<p><strong>Experiment Fearlessly</strong>: Try different approaches. Tests provide a safety net; you can't break anything.</p>
</li>
<li>
<p><strong>Don't Rush</strong>: Understanding matters more than speed. Take breaks between journeys.</p>
</li>
<li>
<p><strong>Ask Questions</strong>: Use <a href="https://github.com/higher-kinded-j/higher-kinded-j/discussions">GitHub Discussions</a> if you're confused about a concept.</p>
</li>
</ol>
<h2 id="beyond-the-tutorials"><a class="header" href="#beyond-the-tutorials">Beyond the Tutorials</a></h2>
<p>After completing the tutorials, continue your learning journey with:</p>
<ul>
<li><strong><a href="https://github.com/higher-kinded-j/higher-kinded-j/tree/main/hkj-examples/src/main/java/org/higherkindedj/example">Example Code</a></strong>: Production-quality examples in <code>hkj-examples</code></li>
<li><strong><a href="https://higher-kinded-j.github.io/home.html">API Documentation</a></strong>: Deep dives into every optic and typeclass</li>
<li><strong><a href="tutorials/../hkts/order-walkthrough.html">Complete Walkthroughs</a></strong>: See how the patterns combine in real applications</li>
<li><strong>Your Own Projects</strong>: Apply these patterns to your actual codebase</li>
</ul>
<h2 id="ready-to-begin"><a class="header" href="#ready-to-begin">Ready to Begin?</a></h2>
<p>Choose your starting point:</p>
<p><strong>Recommended Path:</strong></p>
<ol>
<li><a href="tutorials/coretypes/foundations_journey.html">Foundations Journey</a> - Start here for core concepts</li>
<li><a href="tutorials/effect/effect_journey.html">Effect API Journey</a> - The primary user-facing API (recommended next)</li>
</ol>
<p><strong>Core Types Track (Foundation):</strong></p>
<ul>
<li><a href="tutorials/coretypes/foundations_journey.html">Foundations Journey</a> - Start here for HKT basics</li>
<li><a href="tutorials/coretypes/error_handling_journey.html">Error Handling Journey</a> - Continue with error handling</li>
<li><a href="tutorials/coretypes/advanced_journey.html">Advanced Journey</a> - Master advanced patterns</li>
</ul>
<p><strong>Optics Track:</strong></p>
<ul>
<li><a href="tutorials/optics/lens_prism_journey.html">Lens &amp; Prism Journey</a> - Start here for optics</li>
<li><a href="tutorials/optics/traversals_journey.html">Traversals Journey</a> - Collections and composition</li>
<li><a href="tutorials/optics/fluent_free_journey.html">Fluent &amp; Free Journey</a> - Advanced APIs</li>
<li><a href="tutorials/optics/focus_dsl_journey.html">Focus DSL Journey</a> - Type-safe paths</li>
</ul>
<p>Or see <a href="tutorials/learning_paths.html">Learning Paths</a> for detailed sequences.</p>
<p>Remember: The goal isn't to memorise every detail. It's to develop an intuition for when and how to apply these patterns. That only comes through practice.</p>
<hr />
<p><strong>Previous:</strong> <a href="tutorials/ch_intro.html">Introduction</a>
<strong>Next:</strong> <a href="tutorials/coretypes/foundations_journey.html">Core Types: Foundations Journey</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="core-types-foundations-journey"><a class="header" href="#core-types-foundations-journey">Core Types: Foundations Journey</a></h1>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="tutorials/coretypes/foundations_journey.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How Higher-Kinded Types work in Java through the <code>Kind&lt;F, A&gt;</code> wrapper</li>
<li>The progression from Functor (map) to Applicative (combine) to Monad (chain)</li>
<li>Building the mental model for functional programming in Java</li>
</ul>
</div>
</div>
<p><strong>Duration</strong>: ~38 minutes | <strong>Tutorials</strong>: 4 | <strong>Exercises</strong>: 24</p>
<h2 id="journey-overview"><a class="header" href="#journey-overview">Journey Overview</a></h2>
<p>This journey builds the foundation for everything else in Higher-Kinded-J. You'll learn how Java can simulate Higher-Kinded Types and master the three core abstractions: Functor, Applicative, and Monad.</p>
<pre><code>Kind (container) → Functor (map) → Applicative (combine) → Monad (chain)
</code></pre>
<p>By the end, you'll understand why these abstractions exist and how they help you write cleaner, more composable code.</p>
<hr />
<h2 id="tutorial-01-kind-basics-8-minutes"><a class="header" href="#tutorial-01-kind-basics-8-minutes">Tutorial 01: Kind Basics (~8 minutes)</a></h2>
<p><strong>File</strong>: <code>Tutorial01_KindBasics.java</code> | <strong>Exercises</strong>: 4</p>
<p>Demystify the <code>Kind&lt;F, A&gt;</code> wrapper that makes Higher-Kinded Types possible in Java.</p>
<p><strong>What you'll learn</strong>:</p>
<ul>
<li>Why <code>Kind&lt;F, A&gt;</code> exists and what it represents</li>
<li>How to widen concrete types like <code>Either&lt;L, R&gt;</code> into <code>Kind&lt;F, A&gt;</code></li>
<li>How to narrow <code>Kind&lt;F, A&gt;</code> back to concrete types</li>
<li>What "witness types" are and how they work</li>
</ul>
<p><strong>Key insight</strong>: <code>Kind&lt;F, A&gt;</code> is just a type-level trick. The actual data never changes; we're just changing how the type system sees it.</p>
<p><strong>Links to documentation</strong>: <a href="tutorials/coretypes/../../hkts/hkt_introduction.html">HKT Introduction</a> | <a href="tutorials/coretypes/../../hkts/core-concepts.html">Core Concepts</a></p>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/coretypes/Tutorial01_KindBasics.java">Hands On Practice</a></p>
<hr />
<h2 id="tutorial-02-functor-mapping-8-minutes"><a class="header" href="#tutorial-02-functor-mapping-8-minutes">Tutorial 02: Functor Mapping (~8 minutes)</a></h2>
<p><strong>File</strong>: <code>Tutorial02_FunctorMapping.java</code> | <strong>Exercises</strong>: 6</p>
<p>Learn to transform values inside containers uniformly, regardless of the container type.</p>
<p><strong>What you'll learn</strong>:</p>
<ul>
<li>The <code>map</code> operation and how it preserves structure</li>
<li>Using Functor to write code that works for <code>List</code>, <code>Optional</code>, <code>Either</code>, etc.</li>
<li>Method references with Functor</li>
<li>Functor composition (chaining multiple maps)</li>
</ul>
<p><strong>Key insight</strong>: Functor lets you focus on the transformation logic without worrying about the container's details.</p>
<p><strong>Real-world application</strong>: Transform API responses, map over asynchronous results, convert validation errors.</p>
<p><strong>Links to documentation</strong>: <a href="tutorials/coretypes/../../functional/functor.html">Functor Guide</a></p>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/coretypes/Tutorial02_FunctorMapping.java">Hands On Practice</a></p>
<hr />
<h2 id="tutorial-03-applicative-combining-10-minutes"><a class="header" href="#tutorial-03-applicative-combining-10-minutes">Tutorial 03: Applicative Combining (~10 minutes)</a></h2>
<p><strong>File</strong>: <code>Tutorial03_ApplicativeCombining.java</code> | <strong>Exercises</strong>: 7</p>
<p>Learn to combine multiple independent computations, perfect for validating forms where each field is checked separately.</p>
<p><strong>What you'll learn</strong>:</p>
<ul>
<li>Lifting plain values into context with <code>of</code> (pure)</li>
<li>Combining 2, 3, 4, or 5 independent values with <code>map2</code>, <code>map3</code>, <code>map4</code>, <code>map5</code></li>
<li>The difference between <code>Either</code> (fail-fast) and <code>Validated</code> (accumulate errors)</li>
<li>When to use Applicative vs Monad</li>
</ul>
<p><strong>Key insight</strong>: Use Applicative when your computations don't depend on each other's results. It's more powerful than Functor but less powerful (and more efficient) than Monad.</p>
<p><strong>Real-world application</strong>: Form validation, combining multiple API calls in parallel, aggregating independent data sources.</p>
<p><strong>Links to documentation</strong>: <a href="tutorials/coretypes/../../functional/applicative.html">Applicative Guide</a></p>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/coretypes/Tutorial03_ApplicativeCombining.java">Hands On Practice</a></p>
<hr />
<h2 id="tutorial-04-monad-chaining-12-minutes"><a class="header" href="#tutorial-04-monad-chaining-12-minutes">Tutorial 04: Monad Chaining (~12 minutes)</a></h2>
<p><strong>File</strong>: <code>Tutorial04_MonadChaining.java</code> | <strong>Exercises</strong>: 7</p>
<p>Learn to chain computations where each step depends on the result of the previous one.</p>
<p><strong>What you'll learn</strong>:</p>
<ul>
<li>The <code>flatMap</code> operation for dependent computations</li>
<li>How Monad automatically handles context (no manual unwrapping!)</li>
<li>Chaining database lookups, API calls, and business logic</li>
<li>Short-circuiting on errors automatically</li>
</ul>
<p><strong>Key insight</strong>: Monad is like a programmable semicolon. It handles the "what happens next" logic so you can focus on your business logic.</p>
<p><strong>Real-world application</strong>: Multi-step workflows, database query chains, API request pipelines, business rule processing.</p>
<p><strong>Links to documentation</strong>: <a href="tutorials/coretypes/../../functional/monad.html">Monad Guide</a> | <a href="tutorials/coretypes/../../hkts/order-walkthrough.html">Order Workflow Example</a></p>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/coretypes/Tutorial04_MonadChaining.java">Hands On Practice</a></p>
<hr />
<h2 id="running-the-tutorials"><a class="header" href="#running-the-tutorials">Running the Tutorials</a></h2>
<h3 id="option-1-run-this-journeys-tests"><a class="header" href="#option-1-run-this-journeys-tests">Option 1: Run This Journey's Tests</a></h3>
<pre><code class="language-bash">./gradlew :hkj-examples:test --tests "*Tutorial01_KindBasics*"
./gradlew :hkj-examples:test --tests "*Tutorial02_FunctorMapping*"
./gradlew :hkj-examples:test --tests "*Tutorial03_ApplicativeCombining*"
./gradlew :hkj-examples:test --tests "*Tutorial04_MonadChaining*"
</code></pre>
<h3 id="option-2-use-your-ide"><a class="header" href="#option-2-use-your-ide">Option 2: Use Your IDE</a></h3>
<p>Right-click on any tutorial file and select "Run".</p>
<hr />
<h2 id="common-pitfalls-1"><a class="header" href="#common-pitfalls-1">Common Pitfalls</a></h2>
<h3 id="1-skipping-the-widennarrow-steps"><a class="header" href="#1-skipping-the-widennarrow-steps">1. Skipping the Widen/Narrow Steps</a></h3>
<p><strong>Problem</strong>: Trying to pass <code>Either&lt;L, R&gt;</code> directly to a method expecting <code>Kind&lt;F, A&gt;</code>.</p>
<p><strong>Solution</strong>: Always widen before passing to generic code:</p>
<pre><code class="language-java">Either&lt;String, Integer&gt; either = Either.right(42);
Kind&lt;EitherKind.Witness&lt;String&gt;, Integer&gt; kind = EITHER.widen(either);
</code></pre>
<h3 id="2-confusing-map2-with-flatmap"><a class="header" href="#2-confusing-map2-with-flatmap">2. Confusing map2 with flatMap</a></h3>
<p><strong>Problem</strong>: Using <code>flatMap</code> when <code>map2</code> would suffice (or vice versa).</p>
<p><strong>Solution</strong>: Ask: "Does this step depend on the previous result?"</p>
<ul>
<li><strong>No</strong> → Use Applicative (<code>map2</code>, <code>map3</code>, etc.)</li>
<li><strong>Yes</strong> → Use Monad (<code>flatMap</code>)</li>
</ul>
<hr />
<h2 id="whats-next"><a class="header" href="#whats-next">What's Next?</a></h2>
<p>After completing this journey:</p>
<ol>
<li><strong>Continue to Error Handling</strong>: Learn MonadError and when to use which concrete type</li>
<li><strong>Jump to Effect API</strong>: Start using the user-friendly Effect Path API (recommended)</li>
<li><strong>Explore Optics</strong>: See how these concepts power the optics library</li>
</ol>
<hr />
<p><strong>Next Journey</strong>: <a href="tutorials/coretypes/error_handling_journey.html">Core Types: Error Handling</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="core-types-error-handling-journey"><a class="header" href="#core-types-error-handling-journey">Core Types: Error Handling Journey</a></h1>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="tutorials/coretypes/error_handling_journey.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>Making failures explicit and recoverable using MonadError</li>
<li>When to use <code>Either</code>, <code>Maybe</code>, <code>Validated</code>, and <code>Try</code></li>
<li>Building real-world workflows that combine multiple patterns</li>
</ul>
</div>
</div>
<p><strong>Duration</strong>: ~30 minutes | <strong>Tutorials</strong>: 3 | <strong>Exercises</strong>: 20</p>
<p><strong>Prerequisites</strong>: <a href="tutorials/coretypes/foundations_journey.html">Core Types: Foundations Journey</a></p>
<h2 id="journey-overview-1"><a class="header" href="#journey-overview-1">Journey Overview</a></h2>
<p>Now that you understand Functor, Applicative, and Monad, it's time to handle the real world: errors happen. This journey teaches you to make errors explicit in your types and choose the right type for each situation.</p>
<pre><code>MonadError (explicit failures) → Concrete Types (right tool for the job) → Real World (combine everything)
</code></pre>
<hr />
<h2 id="tutorial-05-monaderror-handling-8-minutes"><a class="header" href="#tutorial-05-monaderror-handling-8-minutes">Tutorial 05: MonadError Handling (~8 minutes)</a></h2>
<p><strong>File</strong>: <code>Tutorial05_MonadErrorHandling.java</code> | <strong>Exercises</strong>: 7</p>
<p>Learn to make failures explicit and recoverable using MonadError.</p>
<p><strong>What you'll learn</strong>:</p>
<ul>
<li>Creating errors explicitly with <code>raiseError</code></li>
<li>Recovering from errors with <code>handleErrorWith</code> and <code>recover</code></li>
<li>Using <code>Try</code> to wrap exception-throwing code safely</li>
<li>When to use <code>Either</code>, <code>Try</code>, or <code>Validated</code></li>
</ul>
<p><strong>Key insight</strong>: MonadError makes error handling a first-class part of your type signatures. No more surprise exceptions!</p>
<p><strong>Real-world application</strong>: API error handling, database failure recovery, validation with custom error types.</p>
<p><strong>Links to documentation</strong>: <a href="tutorials/coretypes/../../functional/monad_error.html">MonadError Guide</a> | <a href="tutorials/coretypes/../../monads/either_monad.html">Either Monad</a></p>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/coretypes/Tutorial05_MonadErrorHandling.java">Hands On Practice</a></p>
<hr />
<h2 id="tutorial-06-concrete-types-10-minutes"><a class="header" href="#tutorial-06-concrete-types-10-minutes">Tutorial 06: Concrete Types (~10 minutes)</a></h2>
<p><strong>File</strong>: <code>Tutorial06_ConcreteTypes.java</code> | <strong>Exercises</strong>: 7</p>
<p>Learn when to use each concrete type that implements the typeclasses you've learned.</p>
<p><strong>What you'll learn</strong>:</p>
<ul>
<li><code>Either&lt;L, R&gt;</code> for explicit, fail-fast error handling</li>
<li><code>Maybe&lt;A&gt;</code> for optional values without error details</li>
<li><code>List&lt;A&gt;</code> for working with multiple values</li>
<li><code>Validated&lt;E, A&gt;</code> for accumulating all errors</li>
<li>How to convert between these types</li>
</ul>
<p><strong>Key insight</strong>: Each type makes different trade-offs. <code>Either</code> fails fast, <code>Validated</code> accumulates errors, <code>Maybe</code> discards error details.</p>
<p><strong>Decision tree</strong>:</p>
<pre><code>Need error message?
├── Yes → Need ALL errors?
│         ├── Yes → Validated
│         └── No  → Either
└── No  → Just optional?
          ├── Yes → Maybe
          └── Multiple values? → List
</code></pre>
<p><strong>Links to documentation</strong>: <a href="tutorials/coretypes/../../monads/either_monad.html">Either</a> | <a href="tutorials/coretypes/../../monads/maybe_monad.html">Maybe</a> | <a href="tutorials/coretypes/../../monads/validated_monad.html">Validated</a></p>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/coretypes/Tutorial06_ConcreteTypes.java">Hands On Practice</a></p>
<hr />
<h2 id="tutorial-07-real-world-12-minutes"><a class="header" href="#tutorial-07-real-world-12-minutes">Tutorial 07: Real World (~12 minutes)</a></h2>
<p><strong>File</strong>: <code>Tutorial07_RealWorld.java</code> | <strong>Exercises</strong>: 6</p>
<p>Bring everything together by building realistic workflows that combine multiple patterns.</p>
<p><strong>What you'll learn</strong>:</p>
<ul>
<li>Building validation pipelines with Applicative</li>
<li>Processing data streams with Functor and Monad</li>
<li>Using <code>Reader</code> monad for dependency injection</li>
<li>Combining effects: validation + transformation + error handling</li>
</ul>
<p><strong>Key insight</strong>: Real applications rarely use just one pattern. They compose Functor, Applicative, and Monad to build robust systems.</p>
<p><strong>Real-world scenarios</strong>:</p>
<ul>
<li>User registration with validation, database checks, and email sending</li>
<li>Data import pipeline with parsing, validation, and transformation</li>
<li>Configuration-driven workflow using Reader monad</li>
</ul>
<p><strong>Links to documentation</strong>: <a href="tutorials/coretypes/../../monads/reader_monad.html">Reader Monad</a> | <a href="tutorials/coretypes/../../functional/for_comprehension.html">For Comprehensions</a></p>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/coretypes/Tutorial07_RealWorld.java">Hands On Practice</a></p>
<hr />
<h2 id="running-the-tutorials-1"><a class="header" href="#running-the-tutorials-1">Running the Tutorials</a></h2>
<pre><code class="language-bash">./gradlew :hkj-examples:test --tests "*Tutorial05_MonadErrorHandling*"
./gradlew :hkj-examples:test --tests "*Tutorial06_ConcreteTypes*"
./gradlew :hkj-examples:test --tests "*Tutorial07_RealWorld*"
</code></pre>
<hr />
<h2 id="common-pitfalls-2"><a class="header" href="#common-pitfalls-2">Common Pitfalls</a></h2>
<h3 id="1-forgetting-to-handle-errors"><a class="header" href="#1-forgetting-to-handle-errors">1. Forgetting to Handle Errors</a></h3>
<p><strong>Problem</strong>: Assuming <code>Either.right()</code> everywhere without planning for <code>Either.left()</code>.</p>
<p><strong>Solution</strong>: Always think about both paths. Tests check both success and failure cases!</p>
<h3 id="2-using-either-when-you-want-all-errors"><a class="header" href="#2-using-either-when-you-want-all-errors">2. Using Either When You Want All Errors</a></h3>
<p><strong>Problem</strong>: Validation stops at the first error when you want to show all errors.</p>
<p><strong>Solution</strong>: Use <code>Validated</code> with Applicative (<code>map2</code>, etc.) to accumulate errors:</p>
<pre><code class="language-java">Validated&lt;List&lt;String&gt;, User&gt; result = ValidatedApplicative.instance().map3(
    validateName(name),
    validateEmail(email),
    validateAge(age),
    User::new
);
</code></pre>
<h3 id="3-throwing-exceptions-instead-of-returning-errors"><a class="header" href="#3-throwing-exceptions-instead-of-returning-errors">3. Throwing Exceptions Instead of Returning Errors</a></h3>
<p><strong>Problem</strong>: Old habits die hard. You throw instead of returning <code>Either.left()</code>.</p>
<p><strong>Solution</strong>: Wrap exception-throwing code with <code>Try</code>:</p>
<pre><code class="language-java">Try&lt;Integer&gt; result = Try.of(() -&gt; Integer.parseInt(input));
</code></pre>
<hr />
<h2 id="whats-next-1"><a class="header" href="#whats-next-1">What's Next?</a></h2>
<p>After completing this journey:</p>
<ol>
<li><strong>Continue to Advanced Patterns</strong>: Natural Transformations, Coyoneda, Free Applicative</li>
<li><strong>Jump to Effect API</strong>: Start using the user-friendly Effect Path API (recommended for practical use)</li>
<li><strong>Explore Optics</strong>: Apply your knowledge to immutable data manipulation</li>
</ol>
<hr />
<p><strong>Previous</strong>: <a href="tutorials/coretypes/foundations_journey.html">Core Types: Foundations</a>
<strong>Next Journey</strong>: <a href="tutorials/coretypes/advanced_journey.html">Core Types: Advanced Patterns</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="core-types-advanced-patterns-journey"><a class="header" href="#core-types-advanced-patterns-journey">Core Types: Advanced Patterns Journey</a></h1>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="tutorials/coretypes/advanced_journey.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>Natural Transformations for polymorphic type conversion</li>
<li>Coyoneda for free functors and map fusion optimisation</li>
<li>Free Applicative for modelling independent, parallelisable computations</li>
</ul>
</div>
</div>
<p><strong>Duration</strong>: ~26 minutes | <strong>Tutorials</strong>: 3 | <strong>Exercises</strong>: 16</p>
<p><strong>Prerequisites</strong>: <a href="tutorials/coretypes/error_handling_journey.html">Core Types: Error Handling Journey</a></p>
<h2 id="journey-overview-2"><a class="header" href="#journey-overview-2">Journey Overview</a></h2>
<p>This journey covers advanced functional programming patterns. These aren't everyday tools, but when you need them, they're invaluable. You'll learn how to transform between type constructors, optimise mapping operations, and model parallel computations.</p>
<pre><code>Natural Transformations → Coyoneda (map fusion) → Free Applicative (parallel)
</code></pre>
<hr />
<h2 id="tutorial-08-natural-transformations-8-minutes"><a class="header" href="#tutorial-08-natural-transformations-8-minutes">Tutorial 08: Natural Transformations (~8 minutes)</a></h2>
<p><strong>File</strong>: <code>Tutorial08_NaturalTransformation.java</code> | <strong>Exercises</strong>: 5</p>
<p>Learn to transform between type constructors while preserving structure.</p>
<p><strong>What you'll learn</strong>:</p>
<ul>
<li>What natural transformations are and why they matter</li>
<li>The <code>Natural&lt;F, G&gt;</code> interface for polymorphic transformations</li>
<li>Composing transformations with <code>andThen</code> and <code>compose</code></li>
<li>Using transformations to interpret Free structures</li>
<li>The identity transformation and its uses</li>
</ul>
<p><strong>Key insight</strong>: Natural transformations let you change the "container" without touching the contents. They're the morphisms between functors.</p>
<p><strong>Real-world application</strong>: Interpreting DSLs, converting between effect types, abstracting over different backends.</p>
<p><strong>Links to documentation</strong>: <a href="tutorials/coretypes/../../functional/natural_transformation.html">Natural Transformation Guide</a></p>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/coretypes/Tutorial08_NaturalTransformation.java">Hands On Practice</a></p>
<hr />
<h2 id="tutorial-09-coyoneda-8-minutes"><a class="header" href="#tutorial-09-coyoneda-8-minutes">Tutorial 09: Coyoneda (~8 minutes)</a></h2>
<p><strong>File</strong>: <code>Tutorial09_Coyoneda.java</code> | <strong>Exercises</strong>: 5</p>
<p>Learn how Coyoneda gives you a free Functor and enables map fusion.</p>
<p><strong>What you'll learn</strong>:</p>
<ul>
<li>Lifting values into Coyoneda with <code>lift</code></li>
<li>Mapping without a Functor instance (deferred execution)</li>
<li>Map fusion: chaining maps accumulates into one traversal</li>
<li>Lowering back to execute accumulated transformations</li>
<li>When and why to use Coyoneda</li>
</ul>
<p><strong>Key insight</strong>: Coyoneda stores the value and accumulated function separately, executing only when you lower. Multiple maps become a single traversal.</p>
<p><strong>Example</strong>:</p>
<pre><code class="language-java">// Without Coyoneda: 3 separate traversals
list.map(f).map(g).map(h);

// With Coyoneda: functions compose, single traversal on lower
Coyoneda.lift(list)
    .map(f)
    .map(g)
    .map(h)
    .lower(listFunctor);  // One traversal with f.andThen(g).andThen(h)
</code></pre>
<p><strong>Real-world application</strong>: Optimising repeated transformations, working with types that lack Functor instances, building efficient pipelines.</p>
<p><strong>Links to documentation</strong>: <a href="tutorials/coretypes/../../monads/coyoneda.html">Coyoneda Guide</a></p>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/coretypes/Tutorial09_Coyoneda.java">Hands On Practice</a></p>
<hr />
<h2 id="tutorial-10-free-applicative-10-minutes"><a class="header" href="#tutorial-10-free-applicative-10-minutes">Tutorial 10: Free Applicative (~10 minutes)</a></h2>
<p><strong>File</strong>: <code>Tutorial10_FreeApplicative.java</code> | <strong>Exercises</strong>: 6</p>
<p>Learn to model independent computations that can potentially run in parallel.</p>
<p><strong>What you'll learn</strong>:</p>
<ul>
<li>Creating pure values with <code>FreeAp.pure</code></li>
<li>Lifting instructions with <code>FreeAp.lift</code></li>
<li>Combining independent computations with <code>map2</code></li>
<li>Interpreting programs with <code>foldMap</code></li>
<li>The key difference from Free Monad: independence vs dependence</li>
</ul>
<p><strong>Key insight</strong>: With Free Applicative, neither computation in <code>map2</code> depends on the other's result. This structural independence enables parallel execution.</p>
<p><strong>Comparison</strong>:</p>
<pre><code class="language-java">// Free Monad (sequential - B depends on A)
freeA.flatMap(a -&gt; computeB(a))

// Free Applicative (parallel - independent)
FreeAp.map2(freeA, freeB, (a, b) -&gt; combine(a, b))
</code></pre>
<p><strong>Real-world application</strong>: Parallel data fetching, form validation, batch API calls, request deduplication.</p>
<p><strong>Links to documentation</strong>: <a href="tutorials/coretypes/../../monads/free_applicative.html">Free Applicative Guide</a></p>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/coretypes/Tutorial10_FreeApplicative.java">Hands On Practice</a></p>
<hr />
<h2 id="running-the-tutorials-2"><a class="header" href="#running-the-tutorials-2">Running the Tutorials</a></h2>
<pre><code class="language-bash">./gradlew :hkj-examples:test --tests "*Tutorial08_NaturalTransformation*"
./gradlew :hkj-examples:test --tests "*Tutorial09_Coyoneda*"
./gradlew :hkj-examples:test --tests "*Tutorial10_FreeApplicative*"
</code></pre>
<hr />
<h2 id="key-concepts-summary"><a class="header" href="#key-concepts-summary">Key Concepts Summary</a></h2>
<h3 id="natural-transformation"><a class="header" href="#natural-transformation">Natural Transformation</a></h3>
<p>A polymorphic function between type constructors: <code>Natural&lt;F, G&gt;</code> transforms <code>Kind&lt;F, A&gt;</code> to <code>Kind&lt;G, A&gt;</code> for any type <code>A</code>. Used to interpret Free structures.</p>
<h3 id="coyoneda"><a class="header" href="#coyoneda">Coyoneda</a></h3>
<p>The "free functor" that gives any type a Functor instance. Stores a value and an accumulated function, enabling map fusion where multiple maps become a single traversal.</p>
<h3 id="free-applicative"><a class="header" href="#free-applicative">Free Applicative</a></h3>
<p>Captures independent computations that can potentially run in parallel. Unlike Free Monad's <code>flatMap</code>, <code>map2</code> combines values without creating dependencies.</p>
<hr />
<h2 id="common-pitfalls-3"><a class="header" href="#common-pitfalls-3">Common Pitfalls</a></h2>
<h3 id="1-using-free-monad-when-free-applicative-suffices"><a class="header" href="#1-using-free-monad-when-free-applicative-suffices">1. Using Free Monad When Free Applicative Suffices</a></h3>
<p><strong>Problem</strong>: Using <code>flatMap</code> everywhere, missing parallelisation opportunities.</p>
<p><strong>Solution</strong>: Ask: "Does this step need the previous result?" If no, use <code>map2</code>.</p>
<h3 id="2-forgetting-to-lower-coyoneda"><a class="header" href="#2-forgetting-to-lower-coyoneda">2. Forgetting to Lower Coyoneda</a></h3>
<p><strong>Problem</strong>: Building up Coyoneda but never executing with <code>lower()</code>.</p>
<p><strong>Solution</strong>: Coyoneda is lazy. Call <code>lower(functor)</code> to execute.</p>
<h3 id="3-type-parameter-confusion-with-natural"><a class="header" href="#3-type-parameter-confusion-with-natural">3. Type Parameter Confusion with Natural</a></h3>
<p><strong>Problem</strong>: Getting lost in <code>Natural&lt;F, G&gt;</code> type parameters.</p>
<p><strong>Solution</strong>: Think of it as: "I can turn any <code>F&lt;A&gt;</code> into a <code>G&lt;A&gt;</code>".</p>
<hr />
<h2 id="whats-next-2"><a class="header" href="#whats-next-2">What's Next?</a></h2>
<p>Congratulations! You've completed the Core Types track. You now understand:</p>
<ul>
<li>The HKT simulation in Java</li>
<li>Functor, Applicative, and Monad</li>
<li>Error handling with MonadError</li>
<li>Advanced patterns for optimisation and parallelism</li>
</ul>
<p><strong>Recommended next steps</strong>:</p>
<ol>
<li><strong>Effect API Journey</strong>: Learn the user-friendly path-based API (recommended)</li>
<li><strong>Optics: Lens &amp; Prism</strong>: Apply functional patterns to data manipulation</li>
<li><strong>Monad Transformers</strong>: Stack effects with <code>EitherT</code>, <code>ReaderT</code>, etc.</li>
<li><strong>Study Real Examples</strong>: See <a href="tutorials/coretypes/../../hkts/order-walkthrough.html">Order Workflow</a></li>
</ol>
<hr />
<p><strong>Previous</strong>: <a href="tutorials/coretypes/error_handling_journey.html">Core Types: Error Handling</a>
<strong>Next</strong>: <a href="tutorials/coretypes/../effect/effect_journey.html">Effect API Journey</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="effect-api-journey"><a class="header" href="#effect-api-journey">Effect API Journey</a></h1>
<p><strong>Estimated Duration</strong>: ~65 minutes (two sub-journeys) | <strong>Exercises</strong>: 15</p>
<div id="admonition-the-primary-api" class="admonition admonish-info" role="note" aria-labelledby="admonition-the-primary-api-title">
<div class="admonition-title">
<div id="admonition-the-primary-api-title">
<p>The Primary API</p>
</div>
<a class="admonition-anchor-link" href="tutorials/effect/effect_journey.html#admonition-the-primary-api"></a>
</div>
<div>
<p>The Effect Path API is the <strong>recommended user-facing API</strong> for Higher-Kinded-J. This journey teaches you to be productive with functional effects without needing deep HKT knowledge.</p>
</div>
</div>
<h2 id="what-youll-learn-2"><a class="header" href="#what-youll-learn-2">What You'll Learn</a></h2>
<p>The Effect API Journey covers the complete Effect Path system:</p>
<h3 id="part-1-fundamentals-35-min-8-exercises"><a class="header" href="#part-1-fundamentals-35-min-8-exercises">Part 1: Fundamentals (~35 min, 8 exercises)</a></h3>
<ul>
<li><strong>Creating Paths</strong>: <code>Path.just()</code>, <code>Path.nothing()</code>, <code>Path.right()</code>, <code>Path.left()</code>, <code>Path.tryOf()</code>, <code>Path.io()</code></li>
<li><strong>Transforming Values</strong>: Using <code>map</code> to transform success values</li>
<li><strong>Chaining Operations</strong>: Using <code>via</code> (flatMap) to chain dependent computations</li>
<li><strong>Error Recovery</strong>: <code>recover</code>, <code>recoverWith</code>, <code>orElse</code>, <code>mapError</code></li>
<li><strong>Combining Paths</strong>: Using <code>zipWith</code> to combine independent computations</li>
<li><strong>Real-World Workflows</strong>: Building complete effect-based workflows</li>
</ul>
<h3 id="part-2-advanced-30-min-7-exercises"><a class="header" href="#part-2-advanced-30-min-7-exercises">Part 2: Advanced (~30 min, 7 exercises)</a></h3>
<ul>
<li><strong>ForPath Comprehensions</strong>: Readable multi-step workflows with for-comprehension syntax</li>
<li><strong>Effect Contexts</strong>: ErrorContext, ConfigContext, MutableContext</li>
<li><strong>@GeneratePathBridge</strong>: Annotations for service integration</li>
<li><strong>Focus-Effect Integration</strong>: Combining optics with effect paths</li>
</ul>
<h2 id="why-effect-api-first"><a class="header" href="#why-effect-api-first">Why Effect API First?</a></h2>
<p>The Effect Path API is designed to be the primary interface for most users:</p>
<ol>
<li><strong>Ergonomic</strong>: Fluent, chainable API that feels natural in Java</li>
<li><strong>Type-Safe</strong>: Compile-time guarantees about effect handling</li>
<li><strong>Practical</strong>: Designed for real-world use cases</li>
<li><strong>Composable</strong>: Paths compose naturally with each other and with optics</li>
</ol>
<h2 id="getting-started-1"><a class="header" href="#getting-started-1">Getting Started</a></h2>
<p>The tutorials are located in <code>hkj-examples/src/test/java/org/higherkindedj/tutorial/effect/</code>:</p>
<h3 id="tutorial-01-effect-path-basics"><a class="header" href="#tutorial-01-effect-path-basics">Tutorial 01: Effect Path Basics</a></h3>
<p><strong>File</strong>: <code>Tutorial01_EffectPathBasics.java</code></p>
<pre><code class="language-java">// Exercise 1: Creating MaybePath
MaybePath&lt;String&gt; present = Path.just("hello");
assertThat(present.getOrElse("default")).isEqualTo("hello");

MaybePath&lt;String&gt; absent = Path.nothing();
assertThat(absent.getOrElse("default")).isEqualTo("default");

// Exercise 5: Chaining with via
EitherPath&lt;String, Double&gt; result = Path.&lt;String, String&gt;right("25")
    .via(parseNumber)
    .via(validatePositive)
    .via(divideHundredBy);
assertThat(result.run().getRight()).isEqualTo(4.0);
</code></pre>
<h3 id="tutorial-02-effect-path-advanced"><a class="header" href="#tutorial-02-effect-path-advanced">Tutorial 02: Effect Path Advanced</a></h3>
<p><strong>File</strong>: <code>Tutorial02_EffectPathAdvanced.java</code></p>
<pre><code class="language-java">// Exercise 1: ForPath comprehensions
MaybePath&lt;Integer&gt; result = ForPath.from(Path.just(10))
    .from(n -&gt; Path.just(n * 2))
    .yield((a, b) -&gt; a + b);
assertThat(result.getOrElse(0)).isEqualTo(30);

// Exercise 4: ConfigContext for dependency injection
ConfigContext&lt;?, AppConfig, String&gt; workflow = ConfigContext.&lt;AppConfig&gt;ask()
    .via(cfg -&gt; ConfigContext.pure(cfg.apiUrl() + "/users"))
    .via(endpoint -&gt; ConfigContext.io(cfg -&gt; endpoint + "?timeout=" + cfg.timeout()));

String url = workflow.runWithSync(config);
</code></pre>
<h2 id="path-types-quick-reference"><a class="header" href="#path-types-quick-reference">Path Types Quick Reference</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Factory Method</th><th>Returns</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Path.just(a)</code></td><td><code>MaybePath&lt;A&gt;</code></td><td>Present value</td></tr>
<tr><td><code>Path.nothing()</code></td><td><code>MaybePath&lt;A&gt;</code></td><td>Absent value</td></tr>
<tr><td><code>Path.maybe(nullable)</code></td><td><code>MaybePath&lt;A&gt;</code></td><td>From nullable</td></tr>
<tr><td><code>Path.right(a)</code></td><td><code>EitherPath&lt;E, A&gt;</code></td><td>Success</td></tr>
<tr><td><code>Path.left(e)</code></td><td><code>EitherPath&lt;E, A&gt;</code></td><td>Failure</td></tr>
<tr><td><code>Path.tryOf(supplier)</code></td><td><code>TryPath&lt;A&gt;</code></td><td>From throwing code</td></tr>
<tr><td><code>Path.io(supplier)</code></td><td><code>IOPath&lt;A&gt;</code></td><td>Deferred effect</td></tr>
<tr><td><code>Path.optional(opt)</code></td><td><code>OptionalPath&lt;A&gt;</code></td><td>From Optional</td></tr>
</tbody></table>
</div>
<h2 id="key-operations"><a class="header" href="#key-operations">Key Operations</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Description</th></tr></thead><tbody>
<tr><td><code>map(f)</code></td><td>Transform success value</td></tr>
<tr><td><code>via(f)</code> / <code>flatMap(f)</code></td><td>Chain dependent computation</td></tr>
<tr><td><code>zipWith(other, f)</code></td><td>Combine independent paths</td></tr>
<tr><td><code>recover(f)</code></td><td>Replace error with value</td></tr>
<tr><td><code>recoverWith(f)</code></td><td>Replace error with path</td></tr>
<tr><td><code>orElse(supplier)</code></td><td>Alternative on failure</td></tr>
<tr><td><code>mapError(f)</code></td><td>Transform error</td></tr>
<tr><td><code>focus(focusPath)</code></td><td>Navigate with optics</td></tr>
</tbody></table>
</div>
<h2 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h2>
<p>Before starting this journey, you should:</p>
<ol>
<li>Be comfortable with Java lambdas and method references</li>
<li>Understand basic generics (type parameters)</li>
</ol>
<p><strong>Optional but helpful</strong>: Complete <a href="tutorials/effect/../coretypes/foundations_journey.html">Core Types: Foundations Journey</a> for deeper HKT understanding.</p>
<h2 id="running-the-tutorials-3"><a class="header" href="#running-the-tutorials-3">Running the Tutorials</a></h2>
<pre><code class="language-bash"># Run all Effect Path tutorials
./gradlew :hkj-examples:test --tests "*tutorial.effect.*"

# Run specific tutorial
./gradlew :hkj-examples:test --tests "*Tutorial01_EffectPathBasics*"

# Check solutions
./gradlew :hkj-examples:test --tests "*solutions.effect.*"
</code></pre>
<h2 id="further-resources"><a class="header" href="#further-resources">Further Resources</a></h2>
<p>After completing this journey, explore:</p>
<ul>
<li><a href="tutorials/effect/../../effect/effect_path_overview.html">Effect Path Overview</a> - Detailed documentation</li>
<li><a href="tutorials/effect/../../effect/path_types.html">Path Types</a> - All available path types</li>
<li><a href="tutorials/effect/../../effect/forpath_comprehension.html">ForPath Comprehension</a> - Advanced ForPath usage</li>
<li><a href="tutorials/effect/../../effect/effect_contexts.html">Effect Contexts</a> - Context API documentation</li>
<li><a href="tutorials/effect/../optics/focus_dsl_journey.html">Optics: Focus-Effect Bridge (Tutorial 14)</a> - Deep integration guide</li>
</ul>
<h2 id="whats-next-3"><a class="header" href="#whats-next-3">What's Next?</a></h2>
<p>After completing the Effect API journey:</p>
<ul>
<li><strong>Explore Core Types</strong>: Understand the HKT foundations in <a href="tutorials/effect/../coretypes/foundations_journey.html">Core Types: Foundations</a></li>
<li><strong>Master Optics</strong>: Learn data manipulation in <a href="tutorials/effect/../optics/lens_prism_journey.html">Optics: Lens &amp; Prism</a></li>
<li><strong>See Production Patterns</strong>: Check the examples in <code>hkj-examples/src/main/java/org/higherkindedj/example/</code></li>
</ul>
<hr />
<p><strong>Previous</strong>: <a href="tutorials/effect/../learning_paths.html">Learning Paths</a>
<strong>Next</strong>: <a href="tutorials/effect/../coretypes/foundations_journey.html">Core Types: Foundations</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="optics-lens--prism-journey"><a class="header" href="#optics-lens--prism-journey">Optics: Lens &amp; Prism Journey</a></h1>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="tutorials/optics/lens_prism_journey.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>Accessing and updating fields in immutable records with Lenses</li>
<li>Composing lenses for deep nested access</li>
<li>Working with sum types (sealed interfaces) using Prisms</li>
<li>Handling optional fields precisely with Affines</li>
</ul>
</div>
</div>
<p><strong>Duration</strong>: ~40 minutes | <strong>Tutorials</strong>: 4 | <strong>Exercises</strong>: 30</p>
<h2 id="journey-overview-3"><a class="header" href="#journey-overview-3">Journey Overview</a></h2>
<p>This journey teaches the fundamental optics: Lens, Prism, and Affine. By the end, you'll never write verbose immutable update code again.</p>
<pre><code>Lens (product types) → Lens Composition → Prism (sum types) → Affine (optional)
</code></pre>
<hr />
<h2 id="the-optics-hierarchy-preview"><a class="header" href="#the-optics-hierarchy-preview">The Optics Hierarchy (Preview)</a></h2>
<pre><code>         Lens (single required field)
              ↓
         Prism (one variant of sum type)
              ↓
         Affine (zero or one element)
              ↓
         Traversal (zero or more elements)
</code></pre>
<p>When you compose a Lens with a Prism, you get an Affine. This journey builds that intuition.</p>
<hr />
<h2 id="tutorial-01-lens-basics-8-minutes"><a class="header" href="#tutorial-01-lens-basics-8-minutes">Tutorial 01: Lens Basics (~8 minutes)</a></h2>
<p><strong>File</strong>: <code>Tutorial01_LensBasics.java</code> | <strong>Exercises</strong>: 7</p>
<p>Learn immutable field access and modification with Lenses, the foundation of the optics library.</p>
<p><strong>What you'll learn</strong>:</p>
<ul>
<li>The three core operations: <code>get</code>, <code>set</code>, <code>modify</code></li>
<li>Using <code>@GenerateLenses</code> to auto-generate lenses for records</li>
<li>Manual lens creation with <code>Lens.of()</code></li>
<li>Lens composition with <code>andThen</code></li>
</ul>
<p><strong>Key insight</strong>: A Lens is a first-class getter/setter. You can pass it around, compose it, and reuse it across your codebase.</p>
<p><strong>Before and After</strong>:</p>
<pre><code class="language-java">// Without lenses (verbose, error-prone)
var updated = new User(user.name(), newEmail, user.address());

// With lenses (clear, composable)
var updated = UserLenses.email().set(newEmail, user);
</code></pre>
<p><strong>Real-world application</strong>: User profile updates, configuration management, any nested record manipulation.</p>
<p><strong>Links to documentation</strong>: <a href="tutorials/optics/../../optics/lenses.html">Lenses Guide</a></p>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/optics/Tutorial01_LensBasics.java">Hands On Practice</a></p>
<hr />
<h2 id="tutorial-02-lens-composition-10-minutes"><a class="header" href="#tutorial-02-lens-composition-10-minutes">Tutorial 02: Lens Composition (~10 minutes)</a></h2>
<p><strong>File</strong>: <code>Tutorial02_LensComposition.java</code> | <strong>Exercises</strong>: 7</p>
<p>Learn to access deeply nested structures by composing simple lenses into powerful paths.</p>
<p><strong>What you'll learn</strong>:</p>
<ul>
<li>Composing lenses with <code>andThen</code> to create deep paths</li>
<li>Updating nested fields in a single expression</li>
<li>Creating reusable composed lenses</li>
<li>The associative property: <code>(a.andThen(b)).andThen(c) == a.andThen(b.andThen(c))</code></li>
</ul>
<p><strong>Key insight</strong>: Composition is the superpower of optics. Combine small, reusable pieces into complex transformations.</p>
<p><strong>Before and After</strong>:</p>
<pre><code class="language-java">// Without lenses (nightmare)
var newUser = new User(
    user.name(),
    user.email(),
    new Address(
        new Street("New St", user.address().street().number()),
        user.address().city()
    )
);

// With lenses (one line)
var newUser = userToStreetName.set("New St", user);
</code></pre>
<p><strong>Real-world application</strong>: Updating deeply nested JSON, modifying complex domain models, configuration tree manipulation.</p>
<p><strong>Links to documentation</strong>: <a href="tutorials/optics/../../optics/composing_optics.html">Composing Optics</a></p>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/optics/Tutorial02_LensComposition.java">Hands On Practice</a></p>
<hr />
<h2 id="tutorial-03-prism-basics-10-minutes"><a class="header" href="#tutorial-03-prism-basics-10-minutes">Tutorial 03: Prism Basics (~10 minutes)</a></h2>
<p><strong>File</strong>: <code>Tutorial03_PrismBasics.java</code> | <strong>Exercises</strong>: 9</p>
<p>Learn to work with sum types (sealed interfaces) safely using Prisms.</p>
<p><strong>What you'll learn</strong>:</p>
<ul>
<li>The three core operations: <code>getOptional</code>, <code>build</code>, <code>modify</code></li>
<li>Pattern matching on sealed interfaces</li>
<li>Using <code>@GeneratePrisms</code> for automatic generation</li>
<li>Using <code>matches()</code> for type checking and <code>doesNotMatch()</code> for exclusion filtering</li>
<li>The <code>nearly</code> prism for predicate-based matching</li>
<li>Prism composition</li>
</ul>
<p><strong>Key insight</strong>: Prisms are like type-safe <code>instanceof</code> checks with built-in modification capability.</p>
<p><strong>Example scenario</strong>: An <code>OrderStatus</code> can be <code>Pending</code>, <code>Processing</code>, or <code>Shipped</code>. A Prism lets you safely operate on just the <code>Shipped</code> variant.</p>
<pre><code class="language-java">// Safely extract tracking number only if Shipped
Optional&lt;String&gt; tracking = shippedPrism
    .andThen(trackingLens)
    .getOptional(orderStatus);
</code></pre>
<p><strong>Real-world application</strong>: State machine handling, discriminated unions, API response variants, event processing.</p>
<p><strong>Links to documentation</strong>: <a href="tutorials/optics/../../optics/prisms.html">Prisms Guide</a> | <a href="tutorials/optics/../../optics/advanced_prism_patterns.html">Advanced Prism Patterns</a></p>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/optics/Tutorial03_PrismBasics.java">Hands On Practice</a></p>
<hr />
<h2 id="tutorial-04-affine-basics-12-minutes"><a class="header" href="#tutorial-04-affine-basics-12-minutes">Tutorial 04: Affine Basics (~12 minutes)</a></h2>
<p><strong>File</strong>: <code>Tutorial04_AffineBasics.java</code> | <strong>Exercises</strong>: 7</p>
<p>Learn to work with optional fields and nullable properties using Affines.</p>
<p><strong>What you'll learn</strong>:</p>
<ul>
<li>The core operations: <code>getOptional</code>, <code>set</code>, <code>modify</code></li>
<li>Using <code>Affines.some()</code> for <code>Optional&lt;T&gt;</code> fields</li>
<li>Why <code>Lens.andThen(Prism)</code> produces an Affine, not a Traversal</li>
<li>Using <code>matches()</code> and <code>getOrElse()</code> convenience methods</li>
<li>Composing Affines for deep optional access</li>
<li>When to use Affine vs Lens vs Prism vs Traversal</li>
</ul>
<p><strong>Key insight</strong>: An Affine is more precise than a Traversal when you know there's at most one element. It's what you get when you compose a guaranteed path (Lens) with an uncertain one (Prism).</p>
<p><strong>Decision guide</strong>:</p>
<div class="table-wrapper"><table><thead><tr><th>Optic</th><th>Focus Count</th><th>Use Case</th></tr></thead><tbody>
<tr><td>Lens</td><td>Exactly 1</td><td>Required field</td></tr>
<tr><td>Prism</td><td>0 or 1 (variant)</td><td>Sum type case</td></tr>
<tr><td>Affine</td><td>0 or 1 (optional)</td><td>Optional field</td></tr>
<tr><td>Traversal</td><td>0 to many</td><td>Collection</td></tr>
</tbody></table>
</div>
<p><strong>Real-world application</strong>: User profiles with optional contact info, configuration with optional sections, nullable legacy fields.</p>
<p><strong>Links to documentation</strong>: <a href="tutorials/optics/../../optics/affine.html">Affines Guide</a></p>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/optics/Tutorial04_AffineBasics.java">Hands On Practice</a></p>
<hr />
<h2 id="running-the-tutorials-4"><a class="header" href="#running-the-tutorials-4">Running the Tutorials</a></h2>
<pre><code class="language-bash">./gradlew :hkj-examples:test --tests "*Tutorial01_LensBasics*"
./gradlew :hkj-examples:test --tests "*Tutorial02_LensComposition*"
./gradlew :hkj-examples:test --tests "*Tutorial03_PrismBasics*"
./gradlew :hkj-examples:test --tests "*Tutorial04_AffineBasics*"
</code></pre>
<hr />
<h2 id="common-pitfalls-4"><a class="header" href="#common-pitfalls-4">Common Pitfalls</a></h2>
<h3 id="1-forgetting-andthen-for-composition"><a class="header" href="#1-forgetting-andthen-for-composition">1. Forgetting andThen for Composition</a></h3>
<p><strong>Problem</strong>: Trying to access nested fields without composing lenses.</p>
<p><strong>Solution</strong>: Chain lenses with <code>andThen</code>:</p>
<pre><code class="language-java">var userToStreetName = UserLenses.address()
    .andThen(AddressLenses.street())
    .andThen(StreetLenses.name());
</code></pre>
<h3 id="2-using-prismget-instead-of-getoptional"><a class="header" href="#2-using-prismget-instead-of-getoptional">2. Using Prism.get Instead of getOptional</a></h3>
<p><strong>Problem</strong>: Expecting <code>get()</code> on a Prism when the variant doesn't match.</p>
<p><strong>Solution</strong>: Prisms return <code>Optional</code>. Always use <code>getOptional()</code>:</p>
<pre><code class="language-java">Optional&lt;Shipped&gt; shipped = shippedPrism.getOptional(orderStatus);
</code></pre>
<h3 id="3-expecting-traversal-when-you-get-affine"><a class="header" href="#3-expecting-traversal-when-you-get-affine">3. Expecting Traversal When You Get Affine</a></h3>
<p><strong>Problem</strong>: Thinking Lens + Prism = Traversal.</p>
<p><strong>Solution</strong>: Lens + Prism = Affine (zero-or-one, not zero-or-many). Use <code>asTraversal()</code> if needed.</p>
<hr />
<h2 id="whats-next-4"><a class="header" href="#whats-next-4">What's Next?</a></h2>
<p>After completing this journey:</p>
<ol>
<li><strong>Continue to Traversals &amp; Practice</strong>: Learn bulk operations on collections</li>
<li><strong>Jump to Focus DSL</strong>: Use the ergonomic path-based API</li>
<li><strong>Explore Real Examples</strong>: See <a href="tutorials/optics/../../optics/auditing_complex_data_example.html">Auditing Complex Data</a></li>
</ol>
<hr />
<p><strong>Next Journey</strong>: <a href="tutorials/optics/traversals_journey.html">Optics: Traversals &amp; Practice</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="optics-traversals--practice-journey"><a class="header" href="#optics-traversals--practice-journey">Optics: Traversals &amp; Practice Journey</a></h1>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="tutorials/optics/traversals_journey.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>Working with multiple targets simultaneously using Traversals</li>
<li>The rules for composing different optic types</li>
<li>Using annotation-driven code generation</li>
<li>Applying optics to realistic production scenarios</li>
</ul>
</div>
</div>
<p><strong>Duration</strong>: ~40 minutes | <strong>Tutorials</strong>: 4 | <strong>Exercises</strong>: 27</p>
<p><strong>Prerequisites</strong>: <a href="tutorials/optics/lens_prism_journey.html">Optics: Lens &amp; Prism Journey</a></p>
<h2 id="journey-overview-4"><a class="header" href="#journey-overview-4">Journey Overview</a></h2>
<p>This journey takes you from single-element optics to collections and real-world applications. You'll learn to modify multiple elements at once and understand how different optics compose.</p>
<pre><code>Traversal (bulk ops) → Composition Rules → Generated Optics → Real World
</code></pre>
<hr />
<h2 id="tutorial-05-traversal-basics-10-minutes"><a class="header" href="#tutorial-05-traversal-basics-10-minutes">Tutorial 05: Traversal Basics (~10 minutes)</a></h2>
<p><strong>File</strong>: <code>Tutorial05_TraversalBasics.java</code> | <strong>Exercises</strong>: 7</p>
<p>Learn to work with multiple targets simultaneously using Traversals.</p>
<p><strong>What you'll learn</strong>:</p>
<ul>
<li>Operating on all elements in a collection with <code>modify</code>, <code>set</code>, <code>getAll</code></li>
<li>Using <code>@GenerateTraversals</code> for automatic List traversals</li>
<li>Manual traversal creation for custom containers</li>
<li>Filtering traversals with predicates</li>
<li>Composing traversals to reach nested collections</li>
</ul>
<p><strong>Key insight</strong>: A Traversal is like a Lens that can focus on zero, one, or many targets at once.</p>
<p><strong>Example</strong>:</p>
<pre><code class="language-java">// Update all player scores in a league
Traversal&lt;League, Integer&gt; allScores = leagueToTeams
    .andThen(teamToPlayers)
    .andThen(playerToScore);

League updated = Traversals.modify(allScores, score -&gt; score + 10, league);
</code></pre>
<p><strong>Real-world application</strong>: Bulk price updates, applying discounts to cart items, sanitising user input across forms, batch data transformation.</p>
<p><strong>Links to documentation</strong>: <a href="tutorials/optics/../../optics/traversals.html">Traversals Guide</a></p>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/optics/Tutorial05_TraversalBasics.java">Hands On Practice</a></p>
<hr />
<h2 id="tutorial-06-optics-composition-10-minutes"><a class="header" href="#tutorial-06-optics-composition-10-minutes">Tutorial 06: Optics Composition (~10 minutes)</a></h2>
<p><strong>File</strong>: <code>Tutorial06_OpticsComposition.java</code> | <strong>Exercises</strong>: 7</p>
<p>Learn the rules and patterns for composing different optic types.</p>
<p><strong>What you'll learn</strong>:</p>
<ul>
<li>Lens + Lens → Lens (both always succeed)</li>
<li>Lens + Prism → Affine (might fail, so result is more precise than Traversal)</li>
<li>Prism + Lens → Affine (might fail, so result is more precise than Traversal)</li>
<li>Affine + Affine → Affine (chained optional access)</li>
<li>Lens + Traversal → Traversal</li>
<li>Prism + Prism → Prism</li>
<li>When the result type "generalises" based on composition</li>
</ul>
<p><strong>Key insight</strong>: Composition follows intuitive rules. If any step might fail, the result reflects that uncertainty. If at most one element can be focused, you get an Affine; if potentially many, a Traversal.</p>
<p><strong>Composition Rules</strong>:</p>
<div class="table-wrapper"><table><thead><tr><th>First</th><th>Second</th><th>Result</th></tr></thead><tbody>
<tr><td>Lens</td><td>Lens</td><td>Lens</td></tr>
<tr><td>Lens</td><td>Prism</td><td>Affine</td></tr>
<tr><td>Prism</td><td>Lens</td><td>Affine</td></tr>
<tr><td>Affine</td><td>Affine</td><td>Affine</td></tr>
<tr><td>Lens</td><td>Traversal</td><td>Traversal</td></tr>
<tr><td>Prism</td><td>Prism</td><td>Prism</td></tr>
<tr><td>Traversal</td><td>Lens</td><td>Traversal</td></tr>
</tbody></table>
</div>
<p><strong>Real-world application</strong>: Complex domain model navigation, API response processing, configuration validation.</p>
<p><strong>Links to documentation</strong>: <a href="tutorials/optics/../../optics/composition_rules.html">Composition Rules</a></p>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/optics/Tutorial06_OpticsComposition.java">Hands On Practice</a></p>
<hr />
<h2 id="tutorial-07-generated-optics-8-minutes"><a class="header" href="#tutorial-07-generated-optics-8-minutes">Tutorial 07: Generated Optics (~8 minutes)</a></h2>
<p><strong>File</strong>: <code>Tutorial07_GeneratedOptics.java</code> | <strong>Exercises</strong>: 7</p>
<p>Learn to leverage annotation-driven code generation for zero-boilerplate optics.</p>
<p><strong>What you'll learn</strong>:</p>
<ul>
<li>Using <code>@GenerateLenses</code> to create lens classes automatically</li>
<li>Using <code>@GeneratePrisms</code> for sealed interface prisms</li>
<li>Using <code>@GenerateTraversals</code> for collection traversals</li>
<li>Understanding scope limitations of generated code (local vs class-level)</li>
<li>Combining multiple annotations on one class</li>
</ul>
<p><strong>Key insight</strong>: The annotation processor eliminates 90% of the boilerplate. You write the data model, the processor writes the optics.</p>
<p><strong>Example</strong>:</p>
<pre><code class="language-java">@GenerateLenses
public record User(String name, String email, Address address) {}

// Generated: UserLenses.name(), UserLenses.email(), UserLenses.address()
</code></pre>
<p><strong>Generated code location</strong>: Same package, with <code>Lenses</code>/<code>Prisms</code>/<code>Traversals</code> suffix.</p>
<p><strong>Links to documentation</strong>: <a href="tutorials/optics/../../optics/lenses.html">Lenses</a> | <a href="tutorials/optics/../../optics/prisms.html">Prisms</a> | <a href="tutorials/optics/../../optics/traversals.html">Traversals</a></p>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/optics/Tutorial07_GeneratedOptics.java">Hands On Practice</a></p>
<hr />
<h2 id="tutorial-08-real-world-optics-12-minutes"><a class="header" href="#tutorial-08-real-world-optics-12-minutes">Tutorial 08: Real World Optics (~12 minutes)</a></h2>
<p><strong>File</strong>: <code>Tutorial08_RealWorldOptics.java</code> | <strong>Exercises</strong>: 6</p>
<p>Apply optics to realistic scenarios that mirror production code.</p>
<p><strong>What you'll learn</strong>:</p>
<ul>
<li>User profile management with deep nesting</li>
<li>API response processing with sum types</li>
<li>E-commerce order processing with collections</li>
<li>Data validation pipelines</li>
<li>Form state management</li>
<li>Configuration updates</li>
</ul>
<p><strong>Key insight</strong>: Real applications combine Lens, Prism, Affine, and Traversal in sophisticated ways. The patterns you've learned compose beautifully.</p>
<p><strong>Scenarios include</strong>:</p>
<ol>
<li><strong>User Management</strong>: Update user profiles with nested address and contact info</li>
<li><strong>API Integration</strong>: Process API responses with multiple variant types</li>
<li><strong>E-commerce</strong>: Apply discounts, update inventory, modify order status</li>
<li><strong>Validation</strong>: Build reusable validators that navigate data structures</li>
</ol>
<p><strong>Links to documentation</strong>: <a href="tutorials/optics/../../optics/auditing_complex_data_example.html">Auditing Complex Data</a></p>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/optics/Tutorial08_RealWorldOptics.java">Hands On Practice</a></p>
<hr />
<h2 id="running-the-tutorials-5"><a class="header" href="#running-the-tutorials-5">Running the Tutorials</a></h2>
<pre><code class="language-bash">./gradlew :hkj-examples:test --tests "*Tutorial05_TraversalBasics*"
./gradlew :hkj-examples:test --tests "*Tutorial06_OpticsComposition*"
./gradlew :hkj-examples:test --tests "*Tutorial07_GeneratedOptics*"
./gradlew :hkj-examples:test --tests "*Tutorial08_RealWorldOptics*"
</code></pre>
<hr />
<h2 id="common-pitfalls-5"><a class="header" href="#common-pitfalls-5">Common Pitfalls</a></h2>
<h3 id="1-generated-code-not-available"><a class="header" href="#1-generated-code-not-available">1. Generated Code Not Available</a></h3>
<p><strong>Problem</strong>: Can't find <code>UserLenses</code> even though you annotated the class.</p>
<p><strong>Solution</strong>:</p>
<ul>
<li>Rebuild the project to trigger annotation processing</li>
<li>Check that the annotation is on a top-level or static class, not a local class</li>
<li>Verify annotation processor is configured in build.gradle</li>
</ul>
<h3 id="2-confusing-getall-with-get"><a class="header" href="#2-confusing-getall-with-get">2. Confusing getAll with get</a></h3>
<p><strong>Problem</strong>: Using <code>get()</code> on a Traversal expecting a single value.</p>
<p><strong>Solution</strong>: Traversals can have multiple targets. Use <code>getAll()</code> for a List:</p>
<pre><code class="language-java">List&lt;Integer&gt; allScores = Traversals.getAll(scoresTraversal, team);
</code></pre>
<h3 id="3-forgetting-filter-order-matters"><a class="header" href="#3-forgetting-filter-order-matters">3. Forgetting Filter Order Matters</a></h3>
<p><strong>Problem</strong>: Filtering after traversal gives unexpected results.</p>
<p><strong>Solution</strong>: Apply filters at the right point in composition:</p>
<pre><code class="language-java">// Filter THEN traverse
var activeUserEmails = usersTraversal
    .filter(User::isActive)
    .andThen(emailLens);
</code></pre>
<hr />
<h2 id="whats-next-5"><a class="header" href="#whats-next-5">What's Next?</a></h2>
<p>After completing this journey:</p>
<ol>
<li><strong>Continue to Fluent &amp; Free DSL</strong>: Learn ergonomic APIs and the Free Monad DSL</li>
<li><strong>Jump to Focus DSL</strong>: Use the type-safe path navigation API</li>
<li><strong>Explore Real Examples</strong>: See production patterns in the examples</li>
</ol>
<hr />
<p><strong>Previous</strong>: <a href="tutorials/optics/lens_prism_journey.html">Optics: Lens &amp; Prism</a>
<strong>Next Journey</strong>: <a href="tutorials/optics/fluent_free_journey.html">Optics: Fluent &amp; Free DSL</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="optics-fluent--free-dsl-journey"><a class="header" href="#optics-fluent--free-dsl-journey">Optics: Fluent &amp; Free DSL Journey</a></h1>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="tutorials/optics/fluent_free_journey.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>The ergonomic fluent API for Java-friendly optic operations</li>
<li>Advanced prism patterns including predicate-based matching</li>
<li>Building composable optic programs with the Free Monad DSL</li>
<li>Interpreting programs for logging, validation, and direct execution</li>
</ul>
</div>
</div>
<p><strong>Duration</strong>: ~37 minutes | <strong>Tutorials</strong>: 3 | <strong>Exercises</strong>: 22</p>
<p><strong>Prerequisites</strong>: <a href="tutorials/optics/traversals_journey.html">Optics: Traversals &amp; Practice Journey</a></p>
<h2 id="journey-overview-5"><a class="header" href="#journey-overview-5">Journey Overview</a></h2>
<p>This journey covers advanced optics patterns: the fluent API for ergonomic usage, advanced prism techniques, and the powerful Free Monad DSL for building interpretable optic programs.</p>
<pre><code>Fluent API (ergonomics) → Advanced Prisms → Free Monad DSL (programs as data)
</code></pre>
<hr />
<h2 id="tutorial-09-fluent-optics-api-12-minutes"><a class="header" href="#tutorial-09-fluent-optics-api-12-minutes">Tutorial 09: Fluent Optics API (~12 minutes)</a></h2>
<p><strong>File</strong>: <code>Tutorial09_FluentOpticsAPI.java</code> | <strong>Exercises</strong>: 7</p>
<p>Learn the ergonomic fluent API for Java-friendly optic operations.</p>
<p><strong>What you'll learn</strong>:</p>
<ul>
<li>Source-first static methods: <code>Lenses.get(lens, source)</code></li>
<li>Collection operations: <code>Traversals.getAll</code>, <code>Traversals.modifyAll</code>, <code>Traversals.setAll</code></li>
<li>Query operations: <code>Traversals.exists</code>, <code>Traversals.count</code>, <code>Traversals.find</code></li>
<li>Integration with <code>Either</code>, <code>Maybe</code>, <code>Validated</code> for effectful operations</li>
<li>Real-world form validation with optics + Either</li>
</ul>
<p><strong>Key insight</strong>: The fluent API provides discoverable, readable syntax without sacrificing the power of optics.</p>
<p><strong>Before and After</strong>:</p>
<pre><code class="language-java">// Traditional style
String name = lens.get(user);

// Fluent style (more discoverable in IDE)
String name = Lenses.get(lens, user);

// Query a collection
boolean hasAdmin = Traversals.exists(rolesTraversal, role -&gt; role.isAdmin(), user);
</code></pre>
<p><strong>Real-world application</strong>: Form validation, data querying, conditional updates, batch processing.</p>
<p><strong>Links to documentation</strong>: <a href="tutorials/optics/../../optics/fluent_api.html">Fluent API Guide</a></p>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/optics/Tutorial09_FluentOpticsAPI.java">Hands On Practice</a></p>
<hr />
<h2 id="tutorial-10-advanced-prism-patterns-10-minutes"><a class="header" href="#tutorial-10-advanced-prism-patterns-10-minutes">Tutorial 10: Advanced Prism Patterns (~10 minutes)</a></h2>
<p><strong>File</strong>: <code>Tutorial10_AdvancedPrismPatterns.java</code> | <strong>Exercises</strong>: 8</p>
<p>Master advanced prism techniques including predicate-based matching and cross-optic composition.</p>
<p><strong>What you'll learn</strong>:</p>
<ul>
<li>The <code>nearly</code> prism for predicate-based matching (complement to <code>only</code>)</li>
<li>Using <code>doesNotMatch</code> for exclusion filtering</li>
<li>Lens + Prism = Affine composition pattern</li>
<li>Prism + Lens = Affine composition pattern</li>
<li>Chaining compositions with <code>lens.asTraversal()</code></li>
</ul>
<p><strong>Key insight</strong>: Cross-optic composition lets you navigate complex data structures that mix product types, sum types, and optional values.</p>
<p><strong>Composition patterns</strong>:</p>
<pre><code class="language-java">// Navigate through optional field
Lens&lt;Config, Optional&lt;Database&gt;&gt; dbLens = ...;
Prism&lt;Optional&lt;Database&gt;, Database&gt; somePrism = Prisms.some();
Affine&lt;Config, Database&gt; dbAffine = dbLens.andThen(somePrism);

// Access field within sum type variant
Prism&lt;Response, Success&gt; successPrism = ...;
Lens&lt;Success, Data&gt; dataLens = ...;
Affine&lt;Response, Data&gt; dataAffine = successPrism.andThen(dataLens);
</code></pre>
<p><strong>The <code>nearly</code> prism</strong>:</p>
<pre><code class="language-java">// Match values that satisfy a predicate
Prism&lt;Integer, Integer&gt; positive = Prisms.nearly(0, n -&gt; n &gt; 0);
positive.getOptional(5);   // Optional.of(5)
positive.getOptional(-3);  // Optional.empty()
</code></pre>
<p><strong>Real-world application</strong>: API response processing, configuration with optional sections, validation pipelines.</p>
<p><strong>Links to documentation</strong>: <a href="tutorials/optics/../../optics/advanced_prism_patterns.html">Advanced Prism Patterns</a> | <a href="tutorials/optics/../../optics/composition_rules.html">Composition Rules</a></p>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/optics/Tutorial10_AdvancedPrismPatterns.java">Hands On Practice</a></p>
<hr />
<h2 id="tutorial-11-free-monad-dsl-15-minutes"><a class="header" href="#tutorial-11-free-monad-dsl-15-minutes">Tutorial 11: Free Monad DSL (~15 minutes)</a></h2>
<p><strong>File</strong>: <code>Tutorial11_AdvancedOpticsDSL.java</code> | <strong>Exercises</strong>: 7</p>
<p>Master the Free Monad DSL for building composable optic programs as data structures.</p>
<p><strong>What you'll learn</strong>:</p>
<ul>
<li>Building programs as values with <code>OpticPrograms</code></li>
<li>Composing programs with <code>flatMap</code></li>
<li>Conditional workflows with <code>flatMap</code> branching</li>
<li>Multi-step transformations</li>
<li>Logging interpreter for audit trails</li>
<li>Validation interpreter for dry-runs</li>
<li>Real-world order processing pipeline</li>
</ul>
<p><strong>Key insight</strong>: The Free Monad DSL separates "what to do" (the program) from "how to do it" (the interpreter). Build the program once, run it many ways.</p>
<p><strong>Example</strong>:</p>
<pre><code class="language-java">// Build a program
Free&lt;OpticOpKind.Witness, Config&gt; program = OpticPrograms
    .get(config, envLens)
    .flatMap(env -&gt;
        env.equals("prod")
            ? OpticPrograms.set(config, debugLens, false)
            : OpticPrograms.pure(config)
    );

// Run with different interpreters
Config result = OpticInterpreters.direct().run(program);
LoggingOpticInterpreter.Log log = OpticInterpreters.logging().run(program);
ValidationResult validation = OpticInterpreters.validating().validate(program);
</code></pre>
<p><strong>Interpreters available</strong>:</p>
<ul>
<li><strong>Direct</strong>: Execute the program immediately</li>
<li><strong>Logging</strong>: Record every operation for audit trails</li>
<li><strong>Validation</strong>: Dry-run to check for potential issues</li>
</ul>
<p><strong>Real-world application</strong>: Auditable workflows, testable business logic, multi-stage data transformations, replayable operations.</p>
<p><strong>Links to documentation</strong>: <a href="tutorials/optics/../../optics/free_monad_dsl.html">Free Monad DSL</a> | <a href="tutorials/optics/../../optics/interpreters.html">Optic Interpreters</a></p>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/optics/Tutorial11_AdvancedOpticsDSL.java">Hands On Practice</a></p>
<hr />
<h2 id="running-the-tutorials-6"><a class="header" href="#running-the-tutorials-6">Running the Tutorials</a></h2>
<pre><code class="language-bash">./gradlew :hkj-examples:test --tests "*Tutorial09_FluentOpticsAPI*"
./gradlew :hkj-examples:test --tests "*Tutorial10_AdvancedPrismPatterns*"
./gradlew :hkj-examples:test --tests "*Tutorial11_AdvancedOpticsDSL*"
</code></pre>
<hr />
<h2 id="common-pitfalls-6"><a class="header" href="#common-pitfalls-6">Common Pitfalls</a></h2>
<h3 id="1-null-checks-in-validation-interpreter"><a class="header" href="#1-null-checks-in-validation-interpreter">1. Null Checks in Validation Interpreter</a></h3>
<p><strong>Problem</strong>: NPE when using Free Monad DSL with validation interpreter.</p>
<p><strong>Solution</strong>: Validation returns null for <code>get</code> operations. Always null-check:</p>
<pre><code class="language-java">.flatMap(value -&gt; {
    if (value != null &amp;&amp; value.equals("expected")) {
        // ...
    }
})
</code></pre>
<h3 id="2-overusing-the-free-monad-dsl"><a class="header" href="#2-overusing-the-free-monad-dsl">2. Overusing the Free Monad DSL</a></h3>
<p><strong>Problem</strong>: Using Free for simple operations where direct optics suffice.</p>
<p><strong>Solution</strong>: Use Free Monad DSL when you need:</p>
<ul>
<li>Audit trails</li>
<li>Dry-run validation</li>
<li>Multiple interpretations of the same program</li>
<li>Testable, mockable optic workflows</li>
</ul>
<h3 id="3-forgetting-to-run-the-interpreter"><a class="header" href="#3-forgetting-to-run-the-interpreter">3. Forgetting to Run the Interpreter</a></h3>
<p><strong>Problem</strong>: Building a Free program but never interpreting it.</p>
<p><strong>Solution</strong>: Free programs are lazy data. Call <code>interpreter.run(program)</code> to execute.</p>
<hr />
<h2 id="whats-next-6"><a class="header" href="#whats-next-6">What's Next?</a></h2>
<p>After completing this journey:</p>
<ol>
<li><strong>Continue to Focus DSL</strong>: Learn the type-safe path navigation API</li>
<li><strong>Combine with Effect API</strong>: Use optics with Effect paths for powerful workflows</li>
<li><strong>Study Production Examples</strong>: See <a href="tutorials/optics/../../hkts/draughts.html">Draughts Game</a> for complex optics usage</li>
</ol>
<hr />
<p><strong>Previous</strong>: <a href="tutorials/optics/traversals_journey.html">Optics: Traversals &amp; Practice</a>
<strong>Next Journey</strong>: <a href="tutorials/optics/focus_dsl_journey.html">Optics: Focus DSL</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="optics-focus-dsl-journey"><a class="header" href="#optics-focus-dsl-journey">Optics: Focus DSL Journey</a></h1>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="tutorials/optics/focus_dsl_journey.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>Type-safe path navigation with automatic type transitions</li>
<li>The FocusPath, AffinePath, and TraversalPath types</li>
<li>Effectful modifications with Applicative and Monad</li>
<li>Aggregating values with Monoid and foldMap</li>
<li>Kind field support and type class integration</li>
</ul>
</div>
</div>
<p><strong>Duration</strong>: ~22 minutes | <strong>Tutorials</strong>: 2 | <strong>Exercises</strong>: 18</p>
<p><strong>Prerequisites</strong>: <a href="tutorials/optics/lens_prism_journey.html">Optics: Lens &amp; Prism Journey</a></p>
<h2 id="journey-overview-6"><a class="header" href="#journey-overview-6">Journey Overview</a></h2>
<p>The Focus DSL provides an ergonomic, type-safe way to navigate nested data structures. Path types automatically widen as you navigate through optional values and collections.</p>
<pre><code>FocusPath → via(Prism) → AffinePath → via(Traversal) → TraversalPath
</code></pre>
<p>This is often the most practical way to work with optics in day-to-day code.</p>
<hr />
<h2 id="tutorial-12-focus-dsl-basics-12-minutes"><a class="header" href="#tutorial-12-focus-dsl-basics-12-minutes">Tutorial 12: Focus DSL Basics (~12 minutes)</a></h2>
<p><strong>File</strong>: <code>Tutorial12_FocusDSL.java</code> | <strong>Exercises</strong>: 10</p>
<p>Learn the Focus DSL for ergonomic, type-safe path navigation through nested data structures.</p>
<p><strong>What you'll learn</strong>:</p>
<ul>
<li>Creating <code>FocusPath</code> from a Lens with <code>FocusPath.of()</code></li>
<li>Composing paths with <code>via()</code> for deep navigation</li>
<li><code>AffinePath</code> for optional values using <code>some()</code></li>
<li><code>TraversalPath</code> for collections using <code>each()</code></li>
<li>Accessing specific elements with <code>at(index)</code> and <code>atKey(key)</code></li>
<li>Filtering traversals with <code>filter()</code></li>
<li>Converting paths with <code>toLens()</code>, <code>asAffine()</code>, <code>asTraversal()</code></li>
</ul>
<p><strong>Key insight</strong>: Path types automatically widen as you navigate. <code>FocusPath</code> becomes <code>AffinePath</code> through optional values, and becomes <code>TraversalPath</code> through collections.</p>
<p><strong>Path type transitions</strong>:</p>
<pre><code>FocusPath (Lens-like: exactly 1)
    │
    ├── via(Lens)     → FocusPath
    ├── via(Prism)    → AffinePath
    ├── via(Affine)   → AffinePath
    └── each()        → TraversalPath

AffinePath (0 or 1)
    │
    ├── via(Lens)     → AffinePath
    ├── via(Prism)    → AffinePath
    └── each()        → TraversalPath

TraversalPath (0 to many)
    │
    └── via(anything) → TraversalPath
</code></pre>
<p><strong>Example</strong>:</p>
<pre><code class="language-java">// Build a path through nested structure
var path = FocusPath.of(companyLens)       // FocusPath&lt;Root, Company&gt;
    .via(departmentsLens)                   // FocusPath&lt;Root, List&lt;Dept&gt;&gt;
    .each()                                 // TraversalPath&lt;Root, Dept&gt;
    .via(managerLens)                       // TraversalPath&lt;Root, Manager&gt;
    .via(emailLens);                        // TraversalPath&lt;Root, String&gt;

// Get all manager emails
List&lt;String&gt; emails = path.getAll(root);

// Update all manager emails
Root updated = path.modify(String::toLowerCase, root);
</code></pre>
<p><strong>Links to documentation</strong>: <a href="tutorials/optics/../../optics/focus_dsl.html">Focus DSL</a></p>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/optics/Tutorial12_FocusDSL.java">Hands On Practice</a></p>
<hr />
<h2 id="tutorial-13-advanced-focus-dsl-10-minutes"><a class="header" href="#tutorial-13-advanced-focus-dsl-10-minutes">Tutorial 13: Advanced Focus DSL (~10 minutes)</a></h2>
<p><strong>File</strong>: <code>Tutorial13_AdvancedFocusDSL.java</code> | <strong>Exercises</strong>: 8</p>
<p>Master advanced Focus DSL features including type class integration, monoid aggregation, and Kind field navigation.</p>
<p><strong>What you'll learn</strong>:</p>
<ul>
<li><code>modifyF()</code> for effectful modifications with Applicative/Monad</li>
<li><code>foldMap()</code> for aggregating values using Monoid</li>
<li><code>traverseOver()</code> for generic collection traversal via Traverse type class</li>
<li><code>modifyWhen()</code> for conditional modifications</li>
<li><code>instanceOf()</code> for sum type navigation</li>
<li><code>traced()</code> for debugging path navigation</li>
</ul>
<p><strong>Key insight</strong>: <code>traverseOver()</code> bridges the HKT Traverse type class with optics, letting you navigate into <code>Kind&lt;F, A&gt;</code> wrapped collections. This is the foundation for automatic Kind field support in <code>@GenerateFocus</code>.</p>
<p><strong>Effectful modifications</strong>:</p>
<pre><code class="language-java">// Validate while modifying
Either&lt;Error, User&gt; result = path.modifyF(
    EitherMonad.instance(),
    value -&gt; validateAndTransform(value),
    user
);

// Async modification
CompletableFuture&lt;User&gt; futureUser = path.modifyF(
    CFMonad.INSTANCE,
    value -&gt; fetchAndUpdate(value),
    user
);
</code></pre>
<p><strong>Aggregation with Monoid</strong>:</p>
<pre><code class="language-java">// Sum all salaries
Integer total = salaryPath.foldMap(
    IntSumMonoid.INSTANCE,
    salary -&gt; salary,
    company
);

// Collect all names
String allNames = namePath.foldMap(
    StringMonoid.INSTANCE,
    name -&gt; name + ", ",
    team
);
</code></pre>
<p><strong>Kind field support</strong>:</p>
<pre><code class="language-java">// Manual traverseOver for Kind&lt;ListKind.Witness, Role&gt; field
FocusPath&lt;User, Kind&lt;ListKind.Witness, Role&gt;&gt; rolesKindPath = FocusPath.of(userRolesLens);
TraversalPath&lt;User, Role&gt; allRolesPath = rolesKindPath
    .&lt;ListKind.Witness, Role&gt;traverseOver(ListTraverse.INSTANCE);

// With @GenerateFocus, this is generated automatically:
// TraversalPath&lt;User, Role&gt; roles = UserFocus.roles();
</code></pre>
<p><strong>Links to documentation</strong>: <a href="tutorials/optics/../../optics/kind_field_support.html">Kind Field Support</a> | <a href="tutorials/optics/../../functional/foldable_and_traverse.html">Foldable and Traverse</a></p>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/optics/Tutorial13_AdvancedFocusDSL.java">Hands On Practice</a></p>
<hr />
<h2 id="running-the-tutorials-7"><a class="header" href="#running-the-tutorials-7">Running the Tutorials</a></h2>
<pre><code class="language-bash">./gradlew :hkj-examples:test --tests "*Tutorial12_FocusDSL*"
./gradlew :hkj-examples:test --tests "*Tutorial13_AdvancedFocusDSL*"
</code></pre>
<hr />
<h2 id="focus-dsl-cheat-sheet"><a class="header" href="#focus-dsl-cheat-sheet">Focus DSL Cheat Sheet</a></h2>
<h3 id="path-types-1"><a class="header" href="#path-types-1">Path Types</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Focus Count</th><th>Created By</th></tr></thead><tbody>
<tr><td><code>FocusPath&lt;S,A&gt;</code></td><td>Exactly 1</td><td><code>FocusPath.of(lens)</code></td></tr>
<tr><td><code>AffinePath&lt;S,A&gt;</code></td><td>0 or 1</td><td><code>.via(prism)</code>, <code>.some()</code></td></tr>
<tr><td><code>TraversalPath&lt;S,A&gt;</code></td><td>0 to many</td><td><code>.each()</code>, <code>.via(traversal)</code></td></tr>
</tbody></table>
</div>
<h3 id="common-operations"><a class="header" href="#common-operations">Common Operations</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Available On</th><th>Description</th></tr></thead><tbody>
<tr><td><code>get(s)</code></td><td>FocusPath</td><td>Get the single value</td></tr>
<tr><td><code>getOptional(s)</code></td><td>AffinePath</td><td>Get optional value</td></tr>
<tr><td><code>getAll(s)</code></td><td>TraversalPath</td><td>Get all values as List</td></tr>
<tr><td><code>set(a, s)</code></td><td>All</td><td>Set value(s)</td></tr>
<tr><td><code>modify(f, s)</code></td><td>All</td><td>Transform value(s)</td></tr>
<tr><td><code>modifyF(m, f, s)</code></td><td>All</td><td>Effectful modification</td></tr>
<tr><td><code>foldMap(m, f, s)</code></td><td>TraversalPath</td><td>Aggregate with Monoid</td></tr>
</tbody></table>
</div>
<h3 id="navigation"><a class="header" href="#navigation">Navigation</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Effect</th></tr></thead><tbody>
<tr><td><code>via(lens)</code></td><td>Navigate through required field</td></tr>
<tr><td><code>via(prism)</code></td><td>Navigate to sum type variant (widens to Affine)</td></tr>
<tr><td><code>some()</code></td><td>Navigate into Optional (widens to Affine)</td></tr>
<tr><td><code>each()</code></td><td>Navigate into collection (widens to Traversal)</td></tr>
<tr><td><code>at(index)</code></td><td>Navigate to specific index (widens to Affine)</td></tr>
<tr><td><code>atKey(key)</code></td><td>Navigate to map key (widens to Affine)</td></tr>
<tr><td><code>filter(pred)</code></td><td>Filter traversal targets</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="common-pitfalls-7"><a class="header" href="#common-pitfalls-7">Common Pitfalls</a></h2>
<h3 id="1-expecting-get-on-affinepath"><a class="header" href="#1-expecting-get-on-affinepath">1. Expecting get() on AffinePath</a></h3>
<p><strong>Problem</strong>: Calling <code>get()</code> on an AffinePath when you need <code>getOptional()</code>.</p>
<p><strong>Solution</strong>: AffinePath might have zero elements. Use <code>getOptional()</code>:</p>
<pre><code class="language-java">Optional&lt;String&gt; value = affinePath.getOptional(source);
</code></pre>
<h3 id="2-type-inference-issues-with-modifyf"><a class="header" href="#2-type-inference-issues-with-modifyf">2. Type Inference Issues with modifyF</a></h3>
<p><strong>Problem</strong>: Java can't infer type parameters for <code>modifyF</code>.</p>
<p><strong>Solution</strong>: Explicitly specify the monad instance:</p>
<pre><code class="language-java">path.&lt;EitherKind.Witness&lt;Error&gt;&gt;modifyF(EitherMonad.instance(), ...)
</code></pre>
<h3 id="3-forgetting-traverseover-for-kind-fields"><a class="header" href="#3-forgetting-traverseover-for-kind-fields">3. Forgetting traverseOver for Kind Fields</a></h3>
<p><strong>Problem</strong>: Can't navigate into <code>Kind&lt;ListKind.Witness, A&gt;</code> field.</p>
<p><strong>Solution</strong>: Use <code>traverseOver</code> with the appropriate Traverse instance:</p>
<pre><code class="language-java">path.traverseOver(ListTraverse.INSTANCE)
</code></pre>
<hr />
<h2 id="whats-next-7"><a class="header" href="#whats-next-7">What's Next?</a></h2>
<p>Congratulations! You've completed the Optics track. You now understand:</p>
<ul>
<li>Lens, Prism, Affine, and Traversal</li>
<li>Optic composition rules</li>
<li>Generated optics with annotations</li>
<li>The Fluent API and Free Monad DSL</li>
<li>The Focus DSL for type-safe navigation</li>
</ul>
<p><strong>Recommended next steps</strong>:</p>
<ol>
<li><strong>Effect API Journey</strong>: Combine optics with Effect paths</li>
<li><strong>Use @GenerateFocus</strong>: Annotate your records for automatic path generation</li>
<li><strong>Study Production Examples</strong>: See <a href="tutorials/optics/../../hkts/draughts.html">Draughts Game</a></li>
<li><strong>Explore Core Types</strong>: Understand the HKT foundation powering <code>modifyF</code></li>
</ol>
<hr />
<p><strong>Previous</strong>: <a href="tutorials/optics/fluent_free_journey.html">Optics: Fluent &amp; Free DSL</a>
<strong>Next</strong>: <a href="tutorials/optics/../effect/effect_journey.html">Effect API Journey</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="learning-paths"><a class="header" href="#learning-paths">Learning Paths</a></h1>
<div id="admonition-choose-your-path" class="admonition admonish-info" role="note" aria-labelledby="admonition-choose-your-path-title">
<div class="admonition-title">
<div id="admonition-choose-your-path-title">
<p>Choose Your Path</p>
</div>
<a class="admonition-anchor-link" href="tutorials/learning_paths.html#admonition-choose-your-path"></a>
</div>
<div>
<p>Each journey is designed to be completed in a single sitting (22-40 minutes). Paths are recommended sequences of journeys for different goals.</p>
</div>
</div>
<h2 id="all-journeys-at-a-glance"><a class="header" href="#all-journeys-at-a-glance">All Journeys at a Glance</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Journey</th><th>Duration</th><th>Exercises</th><th>Level</th></tr></thead><tbody>
<tr><td><a href="tutorials/coretypes/foundations_journey.html">Core: Foundations</a></td><td>~38 min</td><td>24</td><td>Beginner</td></tr>
<tr><td><a href="tutorials/coretypes/error_handling_journey.html">Core: Error Handling</a></td><td>~30 min</td><td>20</td><td>Intermediate</td></tr>
<tr><td><a href="tutorials/coretypes/advanced_journey.html">Core: Advanced Patterns</a></td><td>~26 min</td><td>16</td><td>Advanced</td></tr>
<tr><td><a href="tutorials/effect/effect_journey.html">Effect API</a></td><td>~65 min</td><td>15</td><td>All Levels</td></tr>
<tr><td><a href="tutorials/optics/lens_prism_journey.html">Optics: Lens &amp; Prism</a></td><td>~40 min</td><td>30</td><td>Beginner</td></tr>
<tr><td><a href="tutorials/optics/traversals_journey.html">Optics: Traversals &amp; Practice</a></td><td>~40 min</td><td>27</td><td>Intermediate</td></tr>
<tr><td><a href="tutorials/optics/fluent_free_journey.html">Optics: Fluent &amp; Free DSL</a></td><td>~37 min</td><td>22</td><td>Advanced</td></tr>
<tr><td><a href="tutorials/optics/focus_dsl_journey.html">Optics: Focus DSL</a></td><td>~22 min</td><td>18</td><td>Intermediate</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="recommended-paths"><a class="header" href="#recommended-paths">Recommended Paths</a></h2>
<div id="admonition-start-here" class="admonition admonish-tip" role="note" aria-labelledby="admonition-start-here-title">
<div class="admonition-title">
<div id="admonition-start-here-title">
<p>Start Here</p>
</div>
<a class="admonition-anchor-link" href="tutorials/learning_paths.html#admonition-start-here"></a>
</div>
<div>
<p><strong>Path A: Effect-First</strong> is the recommended path for most users. It teaches the primary user-facing API of Higher-Kinded-J and gets you productive quickly.</p>
</div>
</div>
<h3 id="path-a-effect-first-recommended"><a class="header" href="#path-a-effect-first-recommended">Path A: Effect-First (Recommended)</a></h3>
<p><em>The modern approach: start with the user-friendly Effect API.</em></p>
<div class="table-wrapper"><table><thead><tr><th>Session</th><th>Journey</th><th>Duration</th></tr></thead><tbody>
<tr><td>1</td><td><a href="tutorials/coretypes/foundations_journey.html">Core: Foundations</a></td><td>~38 min</td></tr>
<tr><td>2</td><td><a href="tutorials/effect/effect_journey.html">Effect API: Fundamentals</a></td><td>~35 min</td></tr>
<tr><td>3</td><td><a href="tutorials/effect/effect_journey.html">Effect API: Advanced</a></td><td>~30 min</td></tr>
<tr><td>4</td><td><a href="tutorials/optics/lens_prism_journey.html">Optics: Lens &amp; Prism</a></td><td>~40 min</td></tr>
</tbody></table>
</div>
<p><strong>Total</strong>: 4 sessions, ~143 min across sessions</p>
<p><strong>Best for</strong>: New users who want the recommended learning experience.</p>
<hr />
<h3 id="path-b-quick-start"><a class="header" href="#path-b-quick-start">Path B: Quick Start</a></h3>
<p><em>Get productive with Higher-Kinded-J quickly.</em></p>
<div class="table-wrapper"><table><thead><tr><th>Session</th><th>Journey</th><th>Duration</th></tr></thead><tbody>
<tr><td>1</td><td><a href="tutorials/coretypes/foundations_journey.html">Core: Foundations</a></td><td>~38 min</td></tr>
<tr><td>2</td><td><a href="tutorials/effect/effect_journey.html">Effect API: Fundamentals</a></td><td>~35 min</td></tr>
</tbody></table>
</div>
<p><strong>Total</strong>: 2 sessions, ~73 min across sessions</p>
<p><strong>Best for</strong>: Developers who want to use the library immediately without deep theory.</p>
<hr />
<h3 id="path-c-practical-fp"><a class="header" href="#path-c-practical-fp">Path C: Practical FP</a></h3>
<p><em>Core functional patterns for everyday use.</em></p>
<div class="table-wrapper"><table><thead><tr><th>Session</th><th>Journey</th><th>Duration</th></tr></thead><tbody>
<tr><td>1</td><td><a href="tutorials/coretypes/foundations_journey.html">Core: Foundations</a></td><td>~38 min</td></tr>
<tr><td>2</td><td><a href="tutorials/coretypes/error_handling_journey.html">Core: Error Handling</a></td><td>~30 min</td></tr>
<tr><td>3</td><td><a href="tutorials/effect/effect_journey.html">Effect API: Fundamentals</a></td><td>~35 min</td></tr>
<tr><td>4</td><td><a href="tutorials/optics/lens_prism_journey.html">Optics: Lens &amp; Prism</a></td><td>~40 min</td></tr>
</tbody></table>
</div>
<p><strong>Total</strong>: 4 sessions, ~143 min across sessions</p>
<p><strong>Best for</strong>: Developers building production applications who want solid foundations.</p>
<hr />
<h3 id="path-d-core-types-deep-dive"><a class="header" href="#path-d-core-types-deep-dive">Path D: Core Types Deep Dive</a></h3>
<p><em>Master the theoretical foundation.</em></p>
<div class="table-wrapper"><table><thead><tr><th>Session</th><th>Journey</th><th>Duration</th></tr></thead><tbody>
<tr><td>1</td><td><a href="tutorials/coretypes/foundations_journey.html">Core: Foundations</a></td><td>~38 min</td></tr>
<tr><td>2</td><td><a href="tutorials/coretypes/error_handling_journey.html">Core: Error Handling</a></td><td>~30 min</td></tr>
<tr><td>3</td><td><a href="tutorials/coretypes/advanced_journey.html">Core: Advanced Patterns</a></td><td>~26 min</td></tr>
</tbody></table>
</div>
<p><strong>Total</strong>: 3 sessions, ~94 min across sessions</p>
<p><strong>Best for</strong>: Developers who want to understand the FP theory deeply before applying it.</p>
<hr />
<h3 id="path-e-optics-specialist"><a class="header" href="#path-e-optics-specialist">Path E: Optics Specialist</a></h3>
<p><em>Master immutable data manipulation.</em></p>
<div class="table-wrapper"><table><thead><tr><th>Session</th><th>Journey</th><th>Duration</th></tr></thead><tbody>
<tr><td>1</td><td><a href="tutorials/optics/lens_prism_journey.html">Optics: Lens &amp; Prism</a></td><td>~40 min</td></tr>
<tr><td>2</td><td><a href="tutorials/optics/traversals_journey.html">Optics: Traversals &amp; Practice</a></td><td>~40 min</td></tr>
<tr><td>3</td><td><a href="tutorials/optics/fluent_free_journey.html">Optics: Fluent &amp; Free DSL</a></td><td>~37 min</td></tr>
<tr><td>4</td><td><a href="tutorials/optics/focus_dsl_journey.html">Optics: Focus DSL</a></td><td>~22 min</td></tr>
</tbody></table>
</div>
<p><strong>Total</strong>: 4 sessions, ~139 min across sessions</p>
<p><strong>Best for</strong>: Developers working with complex immutable data structures who want to master optics.</p>
<hr />
<h3 id="path-f-full-curriculum"><a class="header" href="#path-f-full-curriculum">Path F: Full Curriculum</a></h3>
<p><em>Everything, done properly over multiple sessions.</em></p>
<div class="table-wrapper"><table><thead><tr><th>Session</th><th>Journey</th><th>Duration</th></tr></thead><tbody>
<tr><td>1</td><td><a href="tutorials/coretypes/foundations_journey.html">Core: Foundations</a></td><td>~38 min</td></tr>
<tr><td>2</td><td><a href="tutorials/coretypes/error_handling_journey.html">Core: Error Handling</a></td><td>~30 min</td></tr>
<tr><td>3</td><td><a href="tutorials/coretypes/advanced_journey.html">Core: Advanced Patterns</a></td><td>~26 min</td></tr>
<tr><td>4</td><td><a href="tutorials/effect/effect_journey.html">Effect API: Fundamentals</a></td><td>~35 min</td></tr>
<tr><td>5</td><td><a href="tutorials/effect/effect_journey.html">Effect API: Advanced</a></td><td>~30 min</td></tr>
<tr><td>6</td><td><a href="tutorials/optics/lens_prism_journey.html">Optics: Lens &amp; Prism</a></td><td>~40 min</td></tr>
<tr><td>7</td><td><a href="tutorials/optics/traversals_journey.html">Optics: Traversals &amp; Practice</a></td><td>~40 min</td></tr>
<tr><td>8</td><td><a href="tutorials/optics/fluent_free_journey.html">Optics: Fluent &amp; Free DSL</a></td><td>~37 min</td></tr>
<tr><td>9</td><td><a href="tutorials/optics/focus_dsl_journey.html">Optics: Focus DSL</a></td><td>~22 min</td></tr>
</tbody></table>
</div>
<p><strong>Total</strong>: 9 sessions, ~298 min across sessions</p>
<p><strong>Best for</strong>: Those who want comprehensive mastery of Higher-Kinded-J.</p>
<hr />
<h2 id="combined-journeys"><a class="header" href="#combined-journeys">Combined Journeys</a></h2>
<p>For longer learning sessions, these combinations work well together and stay under 60 minutes:</p>
<h3 id="error-mastery-56-min"><a class="header" href="#error-mastery-56-min">Error Mastery (~56 min)</a></h3>
<p>Combine <a href="tutorials/coretypes/error_handling_journey.html">Core: Error Handling</a> + <a href="tutorials/coretypes/advanced_journey.html">Core: Advanced Patterns</a></p>
<p>Focus: Complete the error handling and advanced FP patterns in one sitting.</p>
<h3 id="dsl-power-59-min"><a class="header" href="#dsl-power-59-min">DSL Power (~59 min)</a></h3>
<p>Combine <a href="tutorials/optics/fluent_free_journey.html">Optics: Fluent &amp; Free DSL</a> + <a href="tutorials/optics/focus_dsl_journey.html">Optics: Focus DSL</a></p>
<p>Focus: Master both the Free Monad DSL and the Focus DSL together.</p>
<h3 id="effect-api-complete-65-min"><a class="header" href="#effect-api-complete-65-min">Effect API Complete (~65 min)</a></h3>
<p>Combine <a href="tutorials/effect/effect_journey.html">Effect API: Fundamentals</a> + <a href="tutorials/effect/effect_journey.html">Effect API: Advanced</a></p>
<p>Focus: Master the complete Effect Path API from basics to advanced contexts and annotations.</p>
<hr />
<h2 id="tips-for-success-1"><a class="header" href="#tips-for-success-1">Tips for Success</a></h2>
<ol>
<li>
<p><strong>One journey per sitting</strong>: Each journey is designed to be completed without interruption. Taking breaks between journeys helps consolidation.</p>
</li>
<li>
<p><strong>Don't skip the struggle</strong>: When an exercise is hard, that's where learning happens. Consult solutions only after genuine effort.</p>
</li>
<li>
<p><strong>Run the tests</strong>: The red-to-green feedback loop is essential. Don't just read the exercises.</p>
</li>
<li>
<p><strong>Revisit earlier journeys</strong>: After completing later journeys, earlier concepts often make more sense. Circle back.</p>
</li>
<li>
<p><strong>Apply immediately</strong>: After each journey, try using what you learned in your own code.</p>
</li>
</ol>
<hr />
<p><strong>Previous</strong>: <a href="tutorials/tutorials_intro.html">Interactive Tutorials</a>
<strong>Next</strong>: <a href="tutorials/solutions_guide.html">Solutions Guide</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="tutorial-solutions-guide"><a class="header" href="#tutorial-solutions-guide">Tutorial Solutions Guide</a></h1>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="tutorials/solutions_guide.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>When to consult solutions versus working through problems independently</li>
<li>How to learn effectively from solutions without just copy-pasting code</li>
<li>Common patterns used throughout solution files (widen-operate-narrow, typeclass instances, optic composition)</li>
<li>Debugging techniques for compilation and runtime errors</li>
<li>How to experiment with variations and connect solutions to documentation</li>
</ul>
</div>
</div>
<h2 id="philosophy-when-to-use-solutions"><a class="header" href="#philosophy-when-to-use-solutions">Philosophy: When to Use Solutions</a></h2>
<p>The solution files exist to help you learn, not to short-circuit the learning process. Here's how to use them effectively.</p>
<h3 id="-good-reasons-to-check-solutions"><a class="header" href="#-good-reasons-to-check-solutions">✅ Good Reasons to Check Solutions</a></h3>
<ol>
<li><strong>After Multiple Genuine Attempts</strong>: You've tried for 10+ minutes and exhausted your ideas</li>
<li><strong>To Verify Your Approach</strong>: You have a working solution but want to compare approaches</li>
<li><strong>To Learn Idioms</strong>: You want to see the "idiomatic" way to use the library</li>
<li><strong>When Completely Stuck</strong>: You're blocked on a fundamental concept and can't progress</li>
</ol>
<h3 id="-poor-reasons-to-check-solutions"><a class="header" href="#-poor-reasons-to-check-solutions">❌ Poor Reasons to Check Solutions</a></h3>
<ol>
<li><strong>Immediately When Confused</strong>: Give yourself time to think through the problem</li>
<li><strong>To Save Time</strong>: The struggle is where learning happens; shortcuts lead to shallow understanding</li>
<li><strong>Copy-Pasting for Green Tests</strong>: You'll pass the tutorial but won't retain the knowledge</li>
<li><strong>Because It's Available</strong>: Resist the temptation!</li>
</ol>
<blockquote>
<p><strong>Rule of Thumb</strong>: If you haven't spent at least 5 minutes thinking about the problem, you're not ready for the solution.</p>
</blockquote>
<h2 id="how-to-learn-from-solutions"><a class="header" href="#how-to-learn-from-solutions">How to Learn from Solutions</a></h2>
<p>When you do consult a solution, approach it systematically:</p>
<h3 id="1-dont-just-copy-paste"><a class="header" href="#1-dont-just-copy-paste">1. Don't Just Copy-Paste</a></h3>
<p><strong>Instead</strong>:</p>
<ul>
<li>Read the solution carefully</li>
<li>Understand <em>why</em> it works</li>
<li>Close the solution file</li>
<li>Re-implement it yourself from memory</li>
<li>Run the test to verify understanding</li>
</ul>
<h3 id="2-compare-approaches"><a class="header" href="#2-compare-approaches">2. Compare Approaches</a></h3>
<p>If you have a working solution that differs from the provided one:</p>
<ul>
<li>Are they functionally equivalent?</li>
<li>Is one more idiomatic?</li>
<li>Is one more efficient?</li>
<li>What trade-offs exist between them?</li>
</ul>
<p><strong>Example</strong>:</p>
<pre><code class="language-java">// Your solution (verbose but clear)
Either&lt;String, Integer&gt; result = value1.flatMap(a -&gt;
    value2.map(b -&gt; a + b)
);

// Provided solution (using map2 - more idiomatic for Applicative)
EitherMonad&lt;String&gt; applicative = EitherMonad.instance();
Either&lt;String, Integer&gt; result = EITHER.narrow(
    applicative.map2(EITHER.widen(value1), EITHER.widen(value2), (a, b) -&gt; a + b)
);
</code></pre>
<p>Both are correct, but the second uses the Applicative abstraction more idiomatically.</p>
<h3 id="3-identify-patterns"><a class="header" href="#3-identify-patterns">3. Identify Patterns</a></h3>
<p>Solutions often reveal reusable patterns:</p>
<p><strong>Pattern: Typeclass Access</strong></p>
<pre><code class="language-java">// Pattern you'll see repeatedly
SomeMonad&lt;ErrorType&gt; monad = SomeMonad.instance();
ConcreteType&lt;ErrorType, ValueType&gt; result = HELPER.narrow(
    monad.operationName(HELPER.widen(input), ...)
);
</code></pre>
<p><strong>Pattern: Optic Composition</strong></p>
<pre><code class="language-java">// Pattern: Build paths from small pieces
var outerToInner = OuterLenses.middle()
    .andThen(MiddleLenses.inner())
    .andThen(InnerLenses.field());
</code></pre>
<h3 id="4-annotate-solutions"><a class="header" href="#4-annotate-solutions">4. Annotate Solutions</a></h3>
<p>When studying a solution, add your own comments explaining what each part does:</p>
<pre><code class="language-java">// Create the Applicative instance for Either with String errors
EitherMonad&lt;String&gt; applicative = EitherMonad.instance();

// Widen both Either values to Kind for generic processing
// Combine them using map2 (because they're independent)
// Narrow the result back to concrete Either type
Either&lt;String, Integer&gt; result = EITHER.narrow(
    applicative.map2(
        EITHER.widen(value1),  // First independent value
        EITHER.widen(value2),  // Second independent value
        (a, b) -&gt; a + b        // Combining function
    )
);
</code></pre>
<h2 id="understanding-common-solution-patterns"><a class="header" href="#understanding-common-solution-patterns">Understanding Common Solution Patterns</a></h2>
<h3 id="pattern-1-widen--operate--narrow"><a class="header" href="#pattern-1-widen--operate--narrow">Pattern 1: Widen → Operate → Narrow</a></h3>
<p><strong>Why</strong>: Generic operations work on <code>Kind&lt;F, A&gt;</code>, not concrete types.</p>
<pre><code class="language-java">// 1. Start with concrete type
Either&lt;String, Integer&gt; either = Either.right(42);

// 2. Widen to Kind for generic operation
Kind&lt;EitherKind.Witness&lt;String&gt;, Integer&gt; kind = EITHER.widen(either);

// 3. Perform generic operation (e.g., Functor.map)
Kind&lt;EitherKind.Witness&lt;String&gt;, String&gt; mapped = functor.map(Object::toString, kind);

// 4. Narrow back to concrete type
Either&lt;String, String&gt; result = EITHER.narrow(mapped);
</code></pre>
<p><strong>When you see this</strong>: Core Types tutorials use this pattern extensively.</p>
<h3 id="pattern-2-typeclass-instance-retrieval"><a class="header" href="#pattern-2-typeclass-instance-retrieval">Pattern 2: Typeclass Instance Retrieval</a></h3>
<p><strong>Why</strong>: Typeclasses provide the implementation for generic operations.</p>
<pre><code class="language-java">// Get the Monad instance for Either with String errors
EitherMonad&lt;String&gt; monad = EitherMonad.instance();

// Use it to perform monadic operations
monad.flatMap(...);
</code></pre>
<p><strong>When you see this</strong>: Tutorials 02-05 in Core Types track.</p>
<h3 id="pattern-3-optic-composition-chains"><a class="header" href="#pattern-3-optic-composition-chains">Pattern 3: Optic Composition Chains</a></h3>
<p><strong>Why</strong>: Small, focused optics compose into powerful transformations.</p>
<pre><code class="language-java">// Build a path through nested structures
var leagueToPlayerScores = LeagueTraversals.teams()      // League → Teams
    .andThen(TeamTraversals.players())                    // Team → Players
    .andThen(PlayerLenses.score().asTraversal());        // Player → Score
</code></pre>
<p><strong>When you see this</strong>: Optics tutorials 02, 04, 05, 07.</p>
<h3 id="pattern-4-manual-lens-creation"><a class="header" href="#pattern-4-manual-lens-creation">Pattern 4: Manual Lens Creation</a></h3>
<p><strong>Why</strong>: Annotation processor can't generate lenses for local classes.</p>
<pre><code class="language-java">class ProductLenses {
    public static Lens&lt;Product, String&gt; name() {
        return Lens.of(
            Product::name,                                           // Getter
            (product, newName) -&gt; new Product(                       // Setter
                product.id(),
                newName,
                product.price()
            )
        );
    }
}
</code></pre>
<p><strong>When you see this</strong>: Optics tutorials with local record definitions.</p>
<h3 id="pattern-5-traversal-creation"><a class="header" href="#pattern-5-traversal-creation">Pattern 5: Traversal Creation</a></h3>
<p><strong>Why</strong>: Custom containers need custom traversals.</p>
<pre><code class="language-java">public static Traversal&lt;Order, LineItem&gt; items() {
    return new Traversal&lt;&gt;() {
        @Override
        public &lt;F&gt; Kind&lt;F, Order&gt; modifyF(
            Function&lt;LineItem, Kind&lt;F, LineItem&gt;&gt; f,
            Order order,
            Applicative&lt;F&gt; applicative
        ) {
            // Traverse items list, applying f to each element
            Kind&lt;F, List&lt;LineItem&gt;&gt; updatedItems =
                ListTraverse.instance().traverse(applicative, f, order.items());

            // Map the result back to Order
            return applicative.map(
                newItems -&gt; new Order(order.id(), newItems, order.status()),
                updatedItems
            );
        }
    };
}
</code></pre>
<p><strong>When you see this</strong>: Optics Tutorial 07.</p>
<h2 id="debugging-your-solutions"><a class="header" href="#debugging-your-solutions">Debugging Your Solutions</a></h2>
<h3 id="common-compilation-errors"><a class="header" href="#common-compilation-errors">Common Compilation Errors</a></h3>
<h4 id="error-cannot-find-symbol-method-answerrequired"><a class="header" href="#error-cannot-find-symbol-method-answerrequired">Error: "cannot find symbol: method answerRequired()"</a></h4>
<p><strong>Cause</strong>: You haven't imported or defined the helper method.</p>
<p><strong>Fix</strong>: Ensure this exists at the top of the file:</p>
<pre><code class="language-java">private static &lt;T&gt; T answerRequired() {
    throw new RuntimeException("Answer required");
}
</code></pre>
<h4 id="error-incompatible-types--cannot-be-converted-to-kind"><a class="header" href="#error-incompatible-types--cannot-be-converted-to-kind">Error: "incompatible types: ... cannot be converted to Kind&lt;...&gt;"</a></h4>
<p><strong>Cause</strong>: Forgot to widen before passing to generic code.</p>
<p><strong>Fix</strong>: Wrap with the appropriate helper:</p>
<pre><code class="language-java">EITHER.widen(eitherValue)
MAYBE.widen(maybeValue)
LIST.widen(listValue)
</code></pre>
<h4 id="error-cannot-find-symbol-variable-somelenses"><a class="header" href="#error-cannot-find-symbol-variable-somelenses">Error: "cannot find symbol: variable SomeLenses"</a></h4>
<p><strong>Cause</strong>: Annotation processor hasn't run or class isn't eligible for generation.</p>
<p><strong>Fix</strong>:</p>
<ol>
<li>Rebuild project: <code>./gradlew clean build</code></li>
<li>Check annotation is on top-level or static class (not local class)</li>
<li>Verify <code>@GenerateLenses</code> import is correct</li>
</ol>
<h4 id="error-method-mapn-in-interface-applicative-cannot-be-applied"><a class="header" href="#error-method-mapn-in-interface-applicative-cannot-be-applied">Error: "method mapN in interface Applicative<F> cannot be applied"</a></h4>
<p><strong>Cause</strong>: Wrong number of arguments or incorrect type parameters.</p>
<p><strong>Fix</strong>: Check you're using the right <code>map2</code>/<code>map3</code>/<code>map4</code>/<code>map5</code> for the number of values you're combining.</p>
<h3 id="common-runtime-errors"><a class="header" href="#common-runtime-errors">Common Runtime Errors</a></h3>
<h4 id="error-answer-required-exception"><a class="header" href="#error-answer-required-exception">Error: "Answer required" exception</a></h4>
<p><strong>Cause</strong>: You haven't replaced the placeholder with a solution.</p>
<p><strong>Fix</strong>: This is expected! Replace <code>answerRequired()</code> with working code.</p>
<h4 id="error-kindunwrapexception"><a class="header" href="#error-kindunwrapexception">Error: "KindUnwrapException"</a></h4>
<p><strong>Cause</strong>: Trying to narrow a <code>Kind&lt;F, A&gt;</code> that wasn't created from the expected type.</p>
<p><strong>Fix</strong>: Ensure the witness type matches. <code>EITHER.narrow()</code> only works on <code>Kind&lt;EitherKind.Witness&lt;L&gt;, R&gt;</code>.</p>
<h4 id="error-nullpointerexception-in-free-monad-validation"><a class="header" href="#error-nullpointerexception-in-free-monad-validation">Error: NullPointerException in Free Monad validation</a></h4>
<p><strong>Cause</strong>: Validation interpreter returns <code>null</code> for <code>get</code> operations.</p>
<p><strong>Fix</strong>: Add null checks:</p>
<pre><code class="language-java">.flatMap(value -&gt; {
    if (value != null &amp;&amp; value.equals("expected")) {
        // ...
    } else {
        // ...
    }
})
</code></pre>
<h2 id="solution-file-organisation"><a class="header" href="#solution-file-organisation">Solution File Organisation</a></h2>
<p>Solutions are organised to mirror the tutorial structure:</p>
<pre><code>hkj-examples/src/test/java/org/higherkindedj/tutorial/solutions/
├── coretypes/
│   ├── Tutorial01_KindBasics_Solution.java
│   ├── Tutorial02_FunctorMapping_Solution.java
│   ├── Tutorial03_ApplicativeCombining_Solution.java
│   ├── Tutorial04_MonadChaining_Solution.java
│   ├── Tutorial05_MonadErrorHandling_Solution.java
│   ├── Tutorial06_ConcreteTypes_Solution.java
│   └── Tutorial07_RealWorld_Solution.java
└── optics/
    ├── Tutorial01_LensBasics_Solution.java
    ├── Tutorial02_LensComposition_Solution.java
    ├── Tutorial03_PrismBasics_Solution.java
    ├── Tutorial04_TraversalBasics_Solution.java
    ├── Tutorial05_OpticsComposition_Solution.java
    ├── Tutorial06_GeneratedOptics_Solution.java
    ├── Tutorial07_RealWorldOptics_Solution.java
    ├── Tutorial08_FluentOpticsAPI_Solution.java
    └── Tutorial09_AdvancedOpticsDSL_Solution.java
</code></pre>
<p>Each solution file:</p>
<ul>
<li>Contains complete, working implementations for all exercises</li>
<li>Includes explanatory comments</li>
<li>Demonstrates idiomatic usage patterns</li>
<li>Compiles and passes all tests</li>
</ul>
<h2 id="learning-beyond-solutions"><a class="header" href="#learning-beyond-solutions">Learning Beyond Solutions</a></h2>
<h3 id="experiment-with-variations"><a class="header" href="#experiment-with-variations">Experiment with Variations</a></h3>
<p>Once you understand a solution, try variations:</p>
<p><strong>Original solution</strong>:</p>
<pre><code class="language-java">Either&lt;String, Integer&gt; result = EITHER.narrow(
    applicative.map2(EITHER.widen(value1), EITHER.widen(value2), (a, b) -&gt; a + b)
);
</code></pre>
<p><strong>Variations to try</strong>:</p>
<ol>
<li>What if one value is <code>Left</code>? (Test the error path)</li>
<li>Can you use <code>flatMap</code> instead? (Understand the difference)</li>
<li>How would this work with <code>Validated</code> instead of <code>Either</code>? (See error accumulation)</li>
</ol>
<h3 id="connect-to-documentation"><a class="header" href="#connect-to-documentation">Connect to Documentation</a></h3>
<p>Each solution references specific documentation sections. Follow these links to deepen understanding:</p>
<ul>
<li>If a solution uses <code>Functor.map</code> → Read the <a href="tutorials/../functional/functor.html">Functor Guide</a></li>
<li>If a solution composes optics → Read <a href="tutorials/../optics/composing_optics.html">Composing Optics</a></li>
<li>If a solution uses a specific monad → Read its dedicated guide</li>
</ul>
<h3 id="build-your-own-exercises"><a class="header" href="#build-your-own-exercises">Build Your Own Exercises</a></h3>
<p>After mastering the tutorials, create your own scenarios:</p>
<ol>
<li>Define a domain model from your work</li>
<li>Write tests that require optics or monads</li>
<li>Solve them using the patterns you've learned</li>
<li>Compare your solutions to the tutorial patterns</li>
</ol>
<h2 id="when-solutions-dont-help"><a class="header" href="#when-solutions-dont-help">When Solutions Don't Help</a></h2>
<p>If you've read the solution but still don't understand:</p>
<ol>
<li><strong>Go back to fundamentals</strong>: Re-read the introduction to that tutorial</li>
<li><strong>Check prerequisites</strong>: Maybe you need to understand an earlier concept first</li>
<li><strong>Read the documentation</strong>: Solutions show <em>how</em>, documentation explains <em>why</em></li>
<li><strong>Ask for help</strong>: Use <a href="https://github.com/higher-kinded-j/higher-kinded-j/discussions">GitHub Discussions</a></li>
</ol>
<h2 id="remember"><a class="header" href="#remember">Remember</a></h2>
<blockquote>
<p>The solution is not the destination; understanding is.</p>
</blockquote>
<p>A copied solution gets you a green test today but leaves you unprepared for tomorrow's challenges. The effort you put into solving exercises yourself directly translates to your ability to apply these patterns in production code.</p>
<p>Take your time. Struggle productively. Learn deeply.</p>
<hr />
<p><strong>Previous:</strong> <a href="tutorials/optics_track.html">Optics Track</a>
<strong>Next:</strong> <a href="tutorials/troubleshooting.html">Troubleshooting</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="tutorial-troubleshooting-guide"><a class="header" href="#tutorial-troubleshooting-guide">Tutorial Troubleshooting Guide</a></h1>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="tutorials/troubleshooting.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to fix compilation errors including missing generated lenses, type mismatches, and method not found errors</li>
<li>Solutions for runtime issues like KindUnwrapException, NullPointerException, and unexpected test failures</li>
<li>How to configure annotation processing in IntelliJ IDEA, Eclipse, and VS Code</li>
<li>Troubleshooting build failures in Gradle and Maven</li>
<li>When to use Functor, Applicative, or Monad and understanding the Kind abstraction</li>
</ul>
</div>
</div>
<p>This guide addresses common issues you might encounter whilst working through the Higher-Kinded-J tutorials.</p>
<h2 id="compilation-issues"><a class="header" href="#compilation-issues">Compilation Issues</a></h2>
<h3 id="generated-lensesprisms-not-found"><a class="header" href="#generated-lensesprisms-not-found">Generated Lenses/Prisms Not Found</a></h3>
<p><strong>Symptom</strong>: <code>cannot find symbol: variable UserLenses</code></p>
<p><strong>Causes and Solutions</strong>:</p>
<h4 id="1-annotation-processor-not-configured"><a class="header" href="#1-annotation-processor-not-configured">1. Annotation Processor Not Configured</a></h4>
<p><strong>Check</strong>: <code>build.gradle</code> or <code>pom.xml</code> includes annotation processors:</p>
<pre><code class="language-gradle">dependencies {
    annotationProcessor("io.github.higher-kinded-j:hkj-processor:VERSION")
    annotationProcessor("io.github.higher-kinded-j:hkj-processor-plugins:VERSION")
}
</code></pre>
<h4 id="2-project-needs-rebuilding"><a class="header" href="#2-project-needs-rebuilding">2. Project Needs Rebuilding</a></h4>
<p><strong>Fix</strong>: Clean and rebuild to trigger annotation processing:</p>
<pre><code class="language-bash">./gradlew clean build
</code></pre>
<p><strong>In IDE</strong>: Build → Rebuild Project</p>
<h4 id="3-local-class-limitation"><a class="header" href="#3-local-class-limitation">3. Local Class Limitation</a></h4>
<p><strong>Problem</strong>: Annotation processor cannot generate code for local classes (defined inside methods).</p>
<p><strong>Example of what doesn't work</strong>:</p>
<pre><code class="language-java">@Test
void someTest() {
    @GenerateLenses  // ❌ Won't work - local class
    record User(String name) {}

    // UserLenses doesn't exist!
}
</code></pre>
<p><strong>Solution</strong>: Manually create the lens within the method:</p>
<pre><code class="language-java">@Test
void someTest() {
    record User(String name) {}

    // Manual lens creation
    class UserLenses {
        public static Lens&lt;User, String&gt; name() {
            return Lens.of(
                User::name,
                (user, newName) -&gt; new User(newName)
            );
        }
    }

    // Now you can use UserLenses.name()
}
</code></pre>
<h4 id="4-ide-not-detecting-generated-code"><a class="header" href="#4-ide-not-detecting-generated-code">4. IDE Not Detecting Generated Code</a></h4>
<p><strong>Fix</strong>: Enable annotation processing in your IDE:</p>
<p><strong>IntelliJ IDEA</strong>:</p>
<ol>
<li>Preferences → Build → Compiler → Annotation Processors</li>
<li>Enable "Enable annotation processing"</li>
<li>File → Invalidate Caches → Invalidate and Restart</li>
</ol>
<p><strong>Eclipse</strong>:</p>
<ol>
<li>Project → Properties → Java Compiler → Annotation Processing</li>
<li>Enable "Enable project specific settings"</li>
<li>Enable "Enable annotation processing"</li>
</ol>
<hr />
<h3 id="type-mismatch-errors-with-kind"><a class="header" href="#type-mismatch-errors-with-kind">Type Mismatch Errors with Kind</a></h3>
<p><strong>Symptom</strong>: <code>incompatible types: Either&lt;String,Integer&gt; cannot be converted to Kind&lt;...&gt;</code></p>
<p><strong>Cause</strong>: Forgot to widen concrete type before passing to generic code.</p>
<p><strong>Fix</strong>: Use the appropriate <code>KindHelper</code>:</p>
<pre><code class="language-java">// ❌ Wrong - passing concrete type to generic method
Kind&lt;F, Integer&gt; result = functor.map(i -&gt; i + 1, Either.right(42));

// ✅ Correct - widen first
Either&lt;String, Integer&gt; either = Either.right(42);
Kind&lt;EitherKind.Witness&lt;String&gt;, Integer&gt; kind = EITHER.widen(either);
Kind&lt;EitherKind.Witness&lt;String&gt;, Integer&gt; result = functor.map(i -&gt; i + 1, kind);

// Then narrow back if needed
Either&lt;String, Integer&gt; resultEither = EITHER.narrow(result);
</code></pre>
<hr />
<h3 id="cannot-find-map2map3map4map5"><a class="header" href="#cannot-find-map2map3map4map5">"Cannot Find map2/map3/map4/map5"</a></h3>
<p><strong>Symptom</strong>: <code>cannot find symbol: method map2(...)</code></p>
<p><strong>Cause</strong>: These are typeclass methods, not instance methods on <code>Either</code>/<code>Validated</code>.</p>
<p><strong>Fix</strong>: Access through the typeclass instance:</p>
<pre><code class="language-java">// ❌ Wrong - map2 is not an instance method
Either&lt;String, Integer&gt; result = value1.map2(value2, (a, b) -&gt; a + b);

// ✅ Correct - use the typeclass
EitherMonad&lt;String&gt; applicative = EitherMonad.instance();
Either&lt;String, Integer&gt; result = EITHER.narrow(
    applicative.map2(
        EITHER.widen(value1),
        EITHER.widen(value2),
        (a, b) -&gt; a + b
    )
);
</code></pre>
<hr />
<h3 id="maybegetorelse-method-not-found"><a class="header" href="#maybegetorelse-method-not-found">"Maybe.getOrElse() Method Not Found"</a></h3>
<p><strong>Symptom</strong>: <code>cannot find symbol: method getOrElse(T)</code></p>
<p><strong>Cause</strong>: The method is called <code>orElse()</code>, not <code>getOrElse()</code>.</p>
<p><strong>Fix</strong>:</p>
<pre><code class="language-java">// ❌ Wrong
String result = maybe.getOrElse("default");

// ✅ Correct
String result = maybe.orElse("default");
</code></pre>
<hr />
<h3 id="optic-composition-type-errors"><a class="header" href="#optic-composition-type-errors">Optic Composition Type Errors</a></h3>
<p><strong>Symptom</strong>: <code>incompatible types: Optic&lt;...&gt; cannot be converted to Prism&lt;...&gt;</code></p>
<p><strong>Cause</strong>: Cross-type optic composition returns the more general <code>Optic</code> type.</p>
<p><strong>Composition Rules</strong>:</p>
<ul>
<li>Lens + Lens = Lens</li>
<li>Lens + Prism = <strong>Optic</strong> (not Prism!)</li>
<li>Lens + Traversal = Traversal</li>
<li>Prism + Prism = Prism</li>
<li>Traversal + Lens = Traversal</li>
</ul>
<p><strong>Fix</strong>: Use the correct return type:</p>
<pre><code class="language-java">// ❌ Wrong - expecting Prism
Prism&lt;Order, CreditCard&gt; orderToCreditCard =
    orderToPayment.andThen(creditCardPrism);

// ✅ Correct - Lens + Prism = Optic
Optic&lt;Order, Order, CreditCard, CreditCard&gt; orderToCreditCard =
    orderToPayment.andThen(creditCardPrism);
</code></pre>
<hr />
<h2 id="runtime-issues"><a class="header" href="#runtime-issues">Runtime Issues</a></h2>
<h3 id="answer-required-exception"><a class="header" href="#answer-required-exception">"Answer Required" Exception</a></h3>
<p><strong>Symptom</strong>: Test fails with <code>RuntimeException: Answer required</code></p>
<p><strong>Cause</strong>: This is expected! You haven't replaced the placeholder yet.</p>
<p><strong>Fix</strong>: Replace <code>answerRequired()</code> with your solution:</p>
<pre><code class="language-java">// ❌ Placeholder - will throw exception
Either&lt;String, Integer&gt; result = answerRequired();

// ✅ Your solution
Either&lt;String, Integer&gt; result = Either.right(42);
</code></pre>
<hr />
<h3 id="nullpointerexception-in-free-monad-validation"><a class="header" href="#nullpointerexception-in-free-monad-validation">NullPointerException in Free Monad Validation</a></h3>
<p><strong>Symptom</strong>: NPE when calling <code>.equals()</code> or other methods in Free Monad DSL</p>
<p><strong>Example</strong>:</p>
<pre><code class="language-java">OpticPrograms.get(config, envLens)
    .flatMap(env -&gt; {
        if (env.equals("production")) {  // ❌ NPE here!
            // ...
        }
    });
</code></pre>
<p><strong>Cause</strong>: Validation interpreter returns <code>null</code> for <code>get</code> operations (it's a dry-run, not an execution).</p>
<p><strong>Fix</strong>: Add null check:</p>
<pre><code class="language-java">OpticPrograms.get(config, envLens)
    .flatMap(env -&gt; {
        if (env != null &amp;&amp; env.equals("production")) {  // ✅ Safe
            return OpticPrograms.set(config, debugLens, false);
        } else {
            return OpticPrograms.pure(config);
        }
    });
</code></pre>
<hr />
<h3 id="kindunwrapexception"><a class="header" href="#kindunwrapexception">KindUnwrapException</a></h3>
<p><strong>Symptom</strong>: <code>KindUnwrapException: Cannot narrow null Kind</code> or type mismatch</p>
<p><strong>Cause</strong>: Trying to narrow a <code>Kind&lt;F, A&gt;</code> with the wrong helper or passing <code>null</code>.</p>
<p><strong>Fix</strong>: Ensure witness types match:</p>
<pre><code class="language-java">// ❌ Wrong - mismatched witnesses
Either&lt;String, Integer&gt; either = MAYBE.narrow(someKind);

// ✅ Correct - matching witnesses
Either&lt;String, Integer&gt; either = EITHER.narrow(someKind);
Maybe&lt;Integer&gt; maybe = MAYBE.narrow(someOtherKind);
</code></pre>
<hr />
<h3 id="unexpected-test-failures-with-null-values"><a class="header" href="#unexpected-test-failures-with-null-values">Unexpected Test Failures with Null Values</a></h3>
<p><strong>Symptom</strong>: Test expects a value but gets <code>null</code></p>
<p><strong>Cause</strong>: Forgot to replace a <code>null</code> placeholder in a lambda or return statement.</p>
<p><strong>Common locations</strong>:</p>
<pre><code class="language-java">// In lambdas
Function&lt;Integer, String&gt; fn = i -&gt; null;  // ❌ Replace with actual logic

// In return statements
return null;  // ❌ Replace with answerRequired() or actual value

// In function arguments
someMethod.apply(null);  // ❌ Replace with answerRequired() or actual value
</code></pre>
<p><strong>Fix</strong>: Search for all <code>null</code> in your solutions and replace appropriately.</p>
<hr />
<h2 id="ide-specific-issues"><a class="header" href="#ide-specific-issues">IDE-Specific Issues</a></h2>
<h3 id="intellij-idea-cannot-resolve-symbol"><a class="header" href="#intellij-idea-cannot-resolve-symbol">IntelliJ IDEA: "Cannot Resolve Symbol"</a></h3>
<p>Even though code compiles, IDE shows red underlines.</p>
<p><strong>Fixes</strong>:</p>
<ol>
<li><strong>Invalidate Caches</strong>: File → Invalidate Caches → Invalidate and Restart</li>
<li><strong>Reimport Project</strong>: Right-click <code>build.gradle</code> → Reload Gradle Project</li>
<li><strong>Rebuild</strong>: Build → Rebuild Project</li>
<li><strong>Check Annotation Processing</strong>: Preferences → Build → Compiler → Annotation Processors → Enable</li>
</ol>
<hr />
<h3 id="eclipse-generated-code-not-visible"><a class="header" href="#eclipse-generated-code-not-visible">Eclipse: Generated Code Not Visible</a></h3>
<p><strong>Fixes</strong>:</p>
<ol>
<li><strong>Refresh Project</strong>: Right-click project → Refresh</li>
<li><strong>Clean Build</strong>: Project → Clean → Clean all projects</li>
<li><strong>Enable Annotation Processing</strong>:
<ul>
<li>Project → Properties → Java Compiler → Annotation Processing</li>
<li>Enable "Enable project specific settings"</li>
<li>Enable "Enable annotation processing"</li>
</ul>
</li>
</ol>
<hr />
<h3 id="vs-code-cannot-find-generated-classes"><a class="header" href="#vs-code-cannot-find-generated-classes">VS Code: Cannot Find Generated Classes</a></h3>
<p><strong>Fixes</strong>:</p>
<ol>
<li><strong>Reload Window</strong>: Cmd/Ctrl+Shift+P → "Reload Window"</li>
<li><strong>Clean Java Workspace</strong>: Cmd/Ctrl+Shift+P → "Java: Clean Java Language Server Workspace"</li>
<li><strong>Rebuild</strong>: Run <code>./gradlew clean build</code> in terminal</li>
</ol>
<hr />
<h2 id="test-execution-issues"><a class="header" href="#test-execution-issues">Test Execution Issues</a></h2>
<h3 id="tests-dont-run"><a class="header" href="#tests-dont-run">Tests Don't Run</a></h3>
<p><strong>Symptom</strong>: Clicking "Run" does nothing or test runner can't find tests</p>
<p><strong>Fixes</strong>:</p>
<h4 id="gradle"><a class="header" href="#gradle">Gradle:</a></h4>
<pre><code class="language-bash"># Run specific tutorial
./gradlew :hkj-examples:test --tests "*Tutorial01_KindBasics*"

# Run all core types tutorials
./gradlew :hkj-examples:test --tests "*coretypes*"

# Run all optics tutorials
./gradlew :hkj-examples:test --tests "*optics*"
</code></pre>
<h4 id="ide"><a class="header" href="#ide">IDE:</a></h4>
<ul>
<li>Ensure JUnit 5 is configured (not JUnit 4)</li>
<li>Check test runner is set to use JUnit Platform</li>
<li>Verify <code>@Test</code> import is <code>org.junit.jupiter.api.Test</code></li>
</ul>
<hr />
<h3 id="tests-pass-locally-but-fail-in-ci"><a class="header" href="#tests-pass-locally-but-fail-in-ci">Tests Pass Locally But Fail in CI</a></h3>
<p><strong>Common causes</strong>:</p>
<ol>
<li><strong>Java Version Mismatch</strong>: Ensure CI uses Java 25+</li>
<li><strong>Annotation Processor Not Running</strong>: CI build must run <code>clean build</code>, not just <code>test</code></li>
<li><strong>Encoding Issues</strong>: Ensure UTF-8 encoding in build configuration</li>
</ol>
<hr />
<h2 id="performance-issues"><a class="header" href="#performance-issues">Performance Issues</a></h2>
<h3 id="slow-test-execution"><a class="header" href="#slow-test-execution">Slow Test Execution</a></h3>
<p><strong>Symptom</strong>: Tests take a long time to run</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li>
<p><strong>Run Specific Tests</strong>: Don't run all tests when debugging one exercise</p>
<pre><code class="language-bash">./gradlew :hkj-examples:test --tests "*Tutorial01*"
</code></pre>
</li>
<li>
<p><strong>Use IDE Test Runner</strong>: Faster than Gradle for individual tests</p>
</li>
<li>
<p><strong>Parallel Execution</strong>: Enable in <code>gradle.properties</code>:</p>
<pre><code class="language-properties">org.gradle.parallel=true
org.gradle.caching=true
</code></pre>
</li>
</ol>
<hr />
<h3 id="slow-ide-auto-completion"><a class="header" href="#slow-ide-auto-completion">Slow IDE Auto-Completion</a></h3>
<p><strong>Cause</strong>: Annotation processing running on every keystroke.</p>
<p><strong>Fix in IntelliJ</strong>:</p>
<ol>
<li>Preferences → Build → Compiler → Annotation Processors</li>
<li>Set "Obtain processors from project classpath"</li>
<li>Uncheck "Run annotation processors on sources in test folders" (for quicker editing)</li>
<li>Re-enable when running tests</li>
</ol>
<hr />
<h2 id="build-issues"><a class="header" href="#build-issues">Build Issues</a></h2>
<h3 id="gradle-build-fails"><a class="header" href="#gradle-build-fails">Gradle Build Fails</a></h3>
<p><strong>Common errors</strong>:</p>
<h4 id="could-not-resolve-dependencies"><a class="header" href="#could-not-resolve-dependencies">"Could not resolve dependencies"</a></h4>
<p><strong>Fix</strong>: Check your Maven Central connection and version numbers:</p>
<pre><code class="language-gradle">repositories {
    mavenCentral()
}

dependencies {
    implementation("io.github.higher-kinded-j:hkj-core:LATEST_VERSION")
}
</code></pre>
<h4 id="execution-failed-for-task-compilejava"><a class="header" href="#execution-failed-for-task-compilejava">"Execution failed for task ':compileJava'"</a></h4>
<p><strong>Fix</strong>: Verify Java 25+ is configured:</p>
<pre><code class="language-bash">java -version  # Should be 25 or later
</code></pre>
<p>Update <code>build.gradle</code>:</p>
<pre><code class="language-gradle">    java {
        toolchain {
            languageVersion.set(JavaLanguageVersion.of(25))
        }
    }
</code></pre>
<hr />
<h3 id="maven-build-fails"><a class="header" href="#maven-build-fails">Maven Build Fails</a></h3>
<p><strong>Fix</strong>: Ensure annotation processors are configured in <code>pom.xml</code>:</p>
<pre><code class="language-xml">&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
            &lt;version&gt;3.14.1&lt;/version&gt;
            &lt;configuration&gt;
                &lt;source&gt;25&lt;/source&gt;
                &lt;target&gt;25&lt;/target&gt;
                &lt;annotationProcessorPaths&gt;
                    &lt;path&gt;
                        &lt;groupId&gt;io.github.higher-kinded-j&lt;/groupId&gt;
                        &lt;artifactId&gt;hkj-processor&lt;/artifactId&gt;
                        &lt;version&gt;${hkj.version}&lt;/version&gt;
                    &lt;/path&gt;
                    &lt;path&gt;
                        &lt;groupId&gt;io.github.higher-kinded-j&lt;/groupId&gt;
                        &lt;artifactId&gt;hkj-processor-plugins&lt;/artifactId&gt;
                        &lt;version&gt;${hkj.version}&lt;/version&gt;
                    &lt;/path&gt;
                &lt;/annotationProcessorPaths&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>
<hr />
<h2 id="conceptual-confusion"><a class="header" href="#conceptual-confusion">Conceptual Confusion</a></h2>
<h3 id="i-dont-understand-kindf-a"><a class="header" href="#i-dont-understand-kindf-a">"I Don't Understand Kind&lt;F, A&gt;"</a></h3>
<p><strong>Start here</strong>: <a href="tutorials/../hkts/hkt_introduction.html">HKT Introduction</a></p>
<p><strong>Key insight</strong>: <code>Kind&lt;F, A&gt;</code> is just a wrapper. The actual data is unchanged:</p>
<pre><code class="language-java">Either&lt;String, Integer&gt; either = Either.right(42);

// Widening just changes the type signature - data is the same
Kind&lt;EitherKind.Witness&lt;String&gt;, Integer&gt; kind = EITHER.widen(either);

// Narrowing restores the original type - data is still the same
Either&lt;String, Integer&gt; back = EITHER.narrow(kind);

// either == back (same object!)
</code></pre>
<hr />
<h3 id="when-do-i-use-functor-vs-applicative-vs-monad"><a class="header" href="#when-do-i-use-functor-vs-applicative-vs-monad">"When Do I Use Functor vs Applicative vs Monad?"</a></h3>
<p><strong>Decision tree</strong>:</p>
<ol>
<li><strong>Just transforming values?</strong> → Functor (<code>map</code>)</li>
<li><strong>Combining independent operations?</strong> → Applicative (<code>map2</code>, <code>map3</code>, etc.)</li>
<li><strong>Chaining dependent operations?</strong> → Monad (<code>flatMap</code>)</li>
</ol>
<p><strong>Example scenario</strong>: Form validation</p>
<ul>
<li>Each field validation is <strong>independent</strong> → Use Applicative to combine them</li>
<li>After validation, processing depends on success → Use Monad to chain</li>
</ul>
<hr />
<h3 id="why-cant-i-just-use-eitherrightmap"><a class="header" href="#why-cant-i-just-use-eitherrightmap">"Why Can't I Just Use Either.right().map()?"</a></h3>
<p><strong>You can!</strong> The tutorials teach the typeclass abstraction, but concrete types have convenience methods:</p>
<pre><code class="language-java">// Concrete API (easier for simple cases)
Either&lt;String, Integer&gt; result = Either.right(42)
    .map(i -&gt; i * 2)
    .flatMap(i -&gt; Either.right(i + 10));

// Typeclass API (more powerful for generic code)
EitherMonad&lt;String&gt; monad = EitherMonad.instance();
Either&lt;String, Integer&gt; result = EITHER.narrow(
    monad.flatMap(
        EITHER.widen(Either.right(42)),
        i -&gt; EITHER.widen(Either.right(i * 2 + 10))
    )
);
</code></pre>
<p>The typeclass version lets you write code that works for <strong>any</strong> monad, not just <code>Either</code>.</p>
<hr />
<h2 id="getting-help"><a class="header" href="#getting-help">Getting Help</a></h2>
<p>If this guide doesn't solve your problem:</p>
<ol>
<li>
<p><strong>Search GitHub Issues</strong>: Someone may have encountered this before</p>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/issues">Open Issues</a></li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/issues?q=is%3Aissue+is%3Aclosed">Closed Issues</a></li>
</ul>
</li>
<li>
<p><strong>Ask in Discussions</strong>: Describe your problem with code samples</p>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/discussions">GitHub Discussions</a></li>
</ul>
</li>
<li>
<p><strong>File an Issue</strong>: If you've found a bug</p>
<ul>
<li>Include: Java version, IDE, build tool, minimal reproduction</li>
</ul>
</li>
<li>
<p><strong>Check Documentation</strong>: The main docs cover advanced topics</p>
<ul>
<li><a href="tutorials/../home.html">Documentation Home</a></li>
</ul>
</li>
</ol>
<hr />
<p><strong>Remember</strong>: Most "bugs" are actually learning opportunities. Take time to understand <em>why</em> something isn't working before asking for help. The debugging process itself builds understanding!</p>
<hr />
<p><strong>Previous:</strong> <a href="tutorials/solutions_guide.html">Solutions Guide</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="optics-i-fundamentals"><a class="header" href="#optics-i-fundamentals">Optics I: Fundamentals</a></h1>
<blockquote>
<p><em>"The best way to predict the future is to invent it... The second best way is to fund it. The third best way is to map it."</em></p>
<p>– Neal Stephenson, <em>Cryptonomicon</em></p>
</blockquote>
<hr />
<p>Every Java developer has, at some point, stared at a screen wondering why updating a single field in an immutable record requires reconstructing half the object graph. The standard approach (manually copying and rebuilding each layer) works, technically speaking, in the same way that crossing the Atlantic in a rowing boat works. Possible, certainly. Pleasant, no.</p>
<p>Optics offer a rather more civilised alternative.</p>
<p>At their heart, optics are simply composable, reusable paths through data structures. A Lens focuses on a single field. A Prism handles cases that might not exist. An Iso converts between equivalent representations. None of this is particularly revolutionary in concept (functional programmers have been using these tools for decades), but the practical benefit is considerable: once you've defined a path, you can use it to get, set, or modify values without writing the same tedious reconstruction code repeatedly.</p>
<p>This chapter introduces the fundamental optics: Lens for product types (records with fields), Prism for sum types (sealed interfaces with variants), and Iso for reversible conversions. By the end, you'll understand not only how each works, but when to reach for one over another.</p>
<p>The composition rules table at the chapter's end is worth bookmarking. You'll refer to it more often than you might expect.</p>
<hr />
<h2 id="the-optics-hierarchy"><a class="header" href="#the-optics-hierarchy">The Optics Hierarchy</a></h2>
<p>Before diving into individual optics, it helps to see how they relate to one another:</p>
<pre><code>                    ┌─────────┐
                    │  Fold   │  (read-only, zero-or-more)
                    └────┬────┘
                         │
              ┌──────────┴──────────┐
              │                     │
         ┌────┴────┐          ┌─────┴─────┐
         │ Getter  │          │ Traversal │  (read-write, zero-or-more)
         └────┬────┘          └─────┬─────┘
              │                     │
              │               ┌─────┴─────┐
              │               │           │
         ┌────┴────┐    ┌─────┴─────┐ ┌───┴───┐
         │  Lens   │    │  Affine   │ │Setter │
         └────┬────┘    └─────┬─────┘ └───────┘
              │         (zero-or-one)
              │               │
              │         ┌─────┴─────┐
              │         │   Prism   │
              │         └─────┬─────┘
              │               │
              └───────┬───────┘
                 ┌────┴────┐
                 │   Iso   │  (exactly-one, reversible)
                 └─────────┘
</code></pre>
<p>Arrows indicate "can be used as" relationships. A Lens can be used anywhere a Getter or Fold is expected. An Iso (the most specific optic) can be used as any of the others. Affine sits between Traversal and Prism, representing precisely zero-or-one focus, making it ideal for optional fields.</p>
<hr />
<h2 id="what-youll-learn-3"><a class="header" href="#what-youll-learn-3">What You'll Learn</a></h2>
<div id="admonition-in-this-chapter" class="admonition admonish-info" role="note" aria-labelledby="admonition-in-this-chapter-title">
<div class="admonition-title">
<div id="admonition-in-this-chapter-title">
<p>In This Chapter</p>
</div>
<a class="admonition-anchor-link" href="optics/ch1_intro.html#admonition-in-this-chapter"></a>
</div>
<div>
<ul>
<li><strong>Lenses</strong> – Focus on exactly one field within a record. A Lens guarantees the field exists and provides both get and set operations.</li>
<li><strong>Prisms</strong> – Handle sum types (sealed interfaces) where a value might be one of several variants. A Prism can attempt to match a variant and construct new instances.</li>
<li><strong>Affines</strong> – For optional fields that may or may not be present. An Affine targets zero-or-one values, making it perfect for nullable fields or conditional access.</li>
<li><strong>Isomorphisms</strong> – Bidirectional, lossless conversions between equivalent types. An Iso can convert in both directions without losing information.</li>
<li><strong>Composition</strong> – Chain optics together to navigate arbitrarily deep structures. The composition of a Lens with a Prism produces an Affine, following predictable rules.</li>
<li><strong>The Composition Rules</strong> – A reference table showing what optic type results from composing any two optics. Keep this bookmarked; you'll need it.</li>
</ul>
</div>
</div>
<hr />
<h2 id="chapter-contents-3"><a class="header" href="#chapter-contents-3">Chapter Contents</a></h2>
<ol>
<li><a href="optics/optics_intro.html">What Are Optics?</a> - Introduction to composable, reusable paths through data</li>
<li><a href="optics/lenses.html">Lenses</a> - Focusing on required fields within records</li>
<li><a href="optics/prisms.html">Prisms</a> - Safely handling sum types and optional variants</li>
<li><a href="optics/affine.html">Affines</a> - Working with optional fields (zero-or-one focus)</li>
<li><a href="optics/iso.html">Isomorphisms</a> - Lossless conversions between equivalent types</li>
<li><a href="optics/composition_rules.html">Composition Rules</a> - A reference for what type results from combining optics</li>
</ol>
<hr />
<p><strong>Next:</strong> <a href="optics/optics_intro.html">What Are Optics?</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="an-introduction-to-optics"><a class="header" href="#an-introduction-to-optics">An Introduction to Optics</a></h1>
<p><img src="optics/../images/optics.jpg" alt="Diagram showing optics as composable lenses focusing on nested data structures" /></p>
<div id="admonition-learn-optics-hands-on" class="admonition admonish-tip" role="note" aria-labelledby="admonition-learn-optics-hands-on-title">
<div class="admonition-title">
<div id="admonition-learn-optics-hands-on-title">
<p>Learn Optics Hands-On</p>
</div>
<a class="admonition-anchor-link" href="optics/optics_intro.html#admonition-learn-optics-hands-on"></a>
</div>
<div>
<p>Ready to master optics through practice? Our <strong><a href="optics/../tutorials/optics_track.html">Optics Tutorial Track</a></strong> offers 9 interactive tutorials covering Lenses, Prisms, Traversals, and the Free Monad DSL in ~90 minutes.</p>
</div>
</div>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="optics/optics_intro.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>What optics are and how they solve the nested immutable data update problem in Java</li>
<li>The five core optic types: Lens, Iso, Prism, Traversal, and Fold, and when to use each</li>
<li>How to compose optics to navigate and modify deeply nested structures</li>
<li>Using annotation-driven code generation to create type-safe optics automatically</li>
<li>Performing effectful modifications with Higher-Kinded Types using <code>modifyF</code> and Applicatives</li>
</ul>
</div>
</div>
<p>As Java developers, we appreciate the safety and predictability of immutable objects, especially with the introduction of records. However, this safety comes at a cost: updating nested immutable data can be a verbose and error-prone nightmare.</p>
<p>Consider a simple nested record structure:</p>
<pre><code class="language-java">record Street(String name, int number) {}
record Address(Street street, String city) {}
record User(String name, Address address) {}
</code></pre>
<p>How do you update the user's street name? In standard Java, you're forced into a "copy-and-update" cascade:</p>
<pre><code class="language-java">// What most Java developers actually write
public User updateStreetName(User user, String newStreetName) {
    var address = user.address();
    var street = address.street();
    var newStreet = new Street(newStreetName, street.number());
    var newAddress = new Address(newStreet, address.city());
    return new User(user.name(), newAddress);
}
</code></pre>
<p>This is tedious, hard to read, and gets exponentially worse with deeper nesting. What if there was a way to "zoom in" on the data you want to change, update it, and get a new copy of the top-level object back, all in one clean operation?</p>
<p>This is the problem that <strong>Optics</strong> solve.</p>
<h2 id="what-are-optics"><a class="header" href="#what-are-optics">What Are Optics?</a></h2>
<p>At their core, optics are simply <strong>composable, functional getters and setters</strong> for immutable data structures.</p>
<p>Think of an optic as a <em>zoom lens</em> for your data. It's a first-class object that represents a path from a whole structure (like <code>User</code>) to a specific part (like the street <code>name</code>). Because it's an object, you can pass it around, compose it with other optics, and use it to perform functional updates.</p>
<h2 id="think-of-optics-like"><a class="header" href="#think-of-optics-like">Think of Optics Like...</a></h2>
<ul>
<li><strong>Lens</strong>: A magnifying glass that focuses on one specific part</li>
<li><strong>Prism</strong>: A tool that splits light, but only works with certain types of light</li>
<li><strong>Iso</strong>: A universal translator between equivalent languages</li>
<li><strong>Traversal</strong>: A spotlight that can illuminate many targets at once</li>
<li><strong>Fold</strong>: A read-only query tool that extracts and aggregates data</li>
</ul>
<p>Every optic provides two basic capabilities:</p>
<ol>
<li><strong><code>get</code></strong>: Focus on a structure <code>S</code> and retrieve a part <code>A</code>.</li>
<li><strong><code>set</code></strong>: Focus on a structure <code>S</code>, provide a new part <code>A</code>, and receive a new <code>S</code> with the part updated. This is always an immutable operation: a new copy of <code>S</code> is returned.</li>
</ol>
<p>The real power comes from their <strong>composability</strong>. You can chain optics together to peer deeply into nested structures and perform targeted updates with ease.</p>
<h2 id="the-optics-family-in-higher-kinded-j"><a class="header" href="#the-optics-family-in-higher-kinded-j">The Optics Family in Higher-Kinded-J</a></h2>
<p>The <code>higher-kinded-j</code> library provides the foundation for a rich optics library, primarily focused on three main types. Each is designed to solve a specific kind of data access problem.</p>
<h3 id="1-lens-for-has-a-relationships"><a class="header" href="#1-lens-for-has-a-relationships">1. Lens: For "Has-A" Relationships</a></h3>
<p>A <strong>Lens</strong> is the most common optic. It focuses on a single, required piece of data within a larger "product type" (a <code>record</code> or class with fields). It's for data that is guaranteed to exist.</p>
<ul>
<li>
<p><strong>Problem it solves</strong>: Getting and setting a field within an object, especially a deeply nested one.</p>
</li>
<li>
<p><strong>Generated Code</strong>: Annotating a record with <code>@GenerateLenses</code> produces a companion class (e.g., <code>UserLenses</code>) that contains:</p>
<ol>
<li>A <strong>lens</strong> for each field (e.g., <code>UserLenses.address()</code>).</li>
<li>Convenient <strong><code>with*</code> helper methods</strong> for easy updates (e.g., <code>UserLenses.withAddress(...)</code>).</li>
</ol>
</li>
<li>
<p><strong>Example (Deep Update with Lenses)</strong>:</p>
<ul>
<li>To solve our initial problem of updating the user's street name, we compose lenses:</li>
</ul>
</li>
</ul>
<pre><code class="language-java">    // Compose lenses to create a direct path to the nested data
    var userToStreetName = UserLenses.address()
        .andThen(AddressLenses.street())
        .andThen(StreetLenses.name());
  
    // Perform the deep update in a single, readable line
    User updatedUser = userToStreetName.set("New Street", userLogin);
</code></pre>
<ul>
<li>
<p><strong>Example (Shallow Update with <code>with*</code> Helpers)</strong>:</p>
<ul>
<li>For simple, top-level updates, the <code>with*</code> methods are more direct and discoverable.</li>
</ul>
</li>
</ul>
<pre><code class="language-java">// Before: Using the lens directly
User userWithNewName = UserLenses.name().set("Bob", userLogin);

// After: Using the generated helper method
User userWithNewName = UserLenses.withName(userLogin, "Bob");
</code></pre>
<h3 id="2-iso-for-is-equivalent-to-relationships"><a class="header" href="#2-iso-for-is-equivalent-to-relationships">2. Iso: For "Is-Equivalent-To" Relationships</a></h3>
<p>An <strong>Iso</strong> (Isomorphism) is a special, reversible optic. It represents a lossless, two-way conversion between two types that hold the exact same information. Think of it as a type-safe, composable adapter.</p>
<ul>
<li>
<p><strong>Problem it solves</strong>: Swapping between different representations of the same data, such as a wrapper class and its raw value, or between two structurally different but informationally equivalent records.</p>
</li>
<li>
<p><strong>Example</strong>: Suppose you have a <code>Point</code> record and a <code>Tuple2&lt;Integer, Integer&gt;</code>, which are structurally different but hold the same data.</p>
<pre><code class="language-java">public record Point(int x, int y) {}
</code></pre>
<p>You can define an <code>Iso</code> to convert between them:</p>
<pre><code class="language-java">@GenerateIsos
public static Iso&lt;Point, Tuple2&lt;Integer, Integer&gt;&gt; pointToTuple() {
  return Iso.of(
      point -&gt; Tuple.of(point.x(), point.y()), // get
      tuple -&gt; new Point(tuple._1(), tuple._2())  // reverseGet
  );
}
</code></pre>
<p>This <code>Iso</code> can now be composed with other optics to, for example, create a <code>Lens</code> that goes from a <code>Point</code> directly to its first element inside a <code>Tuple</code> representation.</p>
</li>
</ul>
<h3 id="3-prism-for-is-a-relationships"><a class="header" href="#3-prism-for-is-a-relationships">3. Prism: For "Is-A" Relationships</a></h3>
<p>A <strong>Prism</strong> is like a Lens, but for "sum types" (<code>sealed interface</code> or <code>enum</code>). It focuses on a single, <em>possible case</em> of a type. A Prism's <code>get</code> operation can fail (it returns an <code>Optional</code>), because the data might not be the case you're looking for. Think of it as a type-safe, functional <code>instanceof</code> and cast.</p>
<ul>
<li><strong>Problem it solves</strong>: Safely operating on one variant of a sealed interface.</li>
<li><strong>Example</strong>: Instead of using an <code>if-instanceof</code> chain to handle a specific <code>DomainError</code>:</li>
</ul>
<pre><code class="language-java">// Using a generated Prism for a sealed interface
DomainErrorPrisms.shippingError()
   .getOptional(error) // Safely gets a ShippingError if it matches
   .filter(ShippingError::isRecoverable)
   .ifPresent(this::handleRecovery); // Perform action only if it's the right type
</code></pre>
<h3 id="4-traversal-for-has-many-relationships"><a class="header" href="#4-traversal-for-has-many-relationships">4. Traversal: For "Has-Many" Relationships</a></h3>
<p>A <strong>Traversal</strong> is an optic that can focus on multiple targets at once, typically all the items within a collection inside a larger structure.</p>
<ul>
<li>
<p><strong>Problem it solves</strong>: Applying an operation to every element in a <code>List</code>, <code>Set</code>, or other collection that is a field within an object.</p>
</li>
<li>
<p><strong>Example</strong>: To validate a list of promo codes in an order with <code>Validated</code>:</p>
<pre><code class="language-java">@GenerateTraversals
public record OrderData(..., List&lt;String&gt; promoCodes) {}
var codesTraversal = OrderDataTraversals.promoCodes();
// returns Validated&lt;Error, Code&gt;
var validationFunction = (String code) -&gt; validate(code); 

// Use the traversal to apply the function to every code.
// The Applicative for Validated handles the error accumulation automatically.
Validated&lt;Error, OrderData&gt; result = codesTraversal.modifyF(
    validationFunction, orderData, validatedApplicative
);
</code></pre>
</li>
</ul>
<h3 id="5-fold-for-has-many-queries"><a class="header" href="#5-fold-for-has-many-queries">5. Fold: For "Has-Many" Queries</a></h3>
<p>A <strong>Fold</strong> is a read-only optic designed specifically for querying and extracting data without modification. Think of it as a <code>Traversal</code> that has given up the ability to modify in exchange for a clearer expression of intent and additional query-focused operations.</p>
<ul>
<li>
<p><strong>Problem it solves</strong>: Extracting information from complex data structures: finding items, checking conditions, aggregating values, or collecting data without modifying the original structure.</p>
</li>
<li>
<p><strong>Generated Code</strong>: Annotating a record with <code>@GenerateFolds</code> produces a companion class (e.g., <code>OrderFolds</code>) with a <code>Fold</code> for each field.</p>
</li>
<li>
<p><strong>Example (Querying Product Catalogue)</strong>:</p>
<ul>
<li>To find all products in an order that cost more than £50:</li>
</ul>
</li>
</ul>
<pre><code class="language-java">    // Get the generated fold
    Fold&lt;Order, Product&gt; orderToProducts = OrderFolds.items();

    // Find all matching products
    List&lt;Product&gt; expensiveItems = orderToProducts.getAll(order).stream()
        .filter(product -&gt; product.price() &gt; 50.00)
        .collect(toList());

    // Or check if any exist
    boolean hasExpensiveItems = orderToProducts.exists(
        product -&gt; product.price() &gt; 50.00,
        order
    );
</code></pre>
<ul>
<li><strong>Key Operations</strong>:
<ul>
<li><code>getAll(source)</code>: Extract all focused values into a <code>List</code></li>
<li><code>preview(source)</code>: Get the first value as an <code>Optional</code></li>
<li><code>find(predicate, source)</code>: Find first matching value</li>
<li><code>exists(predicate, source)</code>: Check if any value matches</li>
<li><code>all(predicate, source)</code>: Check if all values match</li>
<li><code>isEmpty(source)</code>: Check if there are zero focused values</li>
<li><code>length(source)</code>: Count the number of focused values</li>
</ul>
</li>
</ul>
<p><strong>Why Fold is Important</strong>: While <code>Traversal</code> can do everything <code>Fold</code> can do, using <code>Fold</code> makes your code's intent crystal clear: "I'm only reading this data, not modifying it." This is valuable for code reviewers, for preventing accidental mutations, and for expressing domain logic where queries should be separated from commands (<a href="https://martinfowler.com/bliki/CQRS.html">CQRS pattern</a>).</p>
<h2 id="advanced-capabilities-profunctor-adaptations"><a class="header" href="#advanced-capabilities-profunctor-adaptations">Advanced Capabilities: Profunctor Adaptations</a></h2>
<p>One of the most powerful features of <code>higher-kinded-j</code> optics is their <strong>profunctor</strong> nature. Every optic can be adapted to work with different source and target types using three key operations:</p>
<ul>
<li><strong><code>contramap</code></strong>: Adapt an optic to work with a different source type</li>
<li><strong><code>map</code></strong>: Transform the result type of an optic</li>
<li><strong><code>dimap</code></strong>: Adapt both source and target types simultaneously</li>
</ul>
<p>This makes optics incredibly flexible for real-world scenarios like API integration, legacy system support, and working with different data representations. For a detailed exploration of these capabilities, see the <a href="optics/profunctor_optics.html">Profunctor Optics Guide</a>.</p>
<h2 id="how-higher-kinded-j-provides-optics"><a class="header" href="#how-higher-kinded-j-provides-optics">How <code>higher-kinded-j</code> Provides Optics</a></h2>
<p>This brings us to the unique advantages <code>higher-kinded-j</code> offers for optics in Java.</p>
<ol>
<li><strong>An Annotation-Driven Workflow</strong>: Manually writing optics is boilerplate. The <code>higher-kinded-j</code> approach automates this. By simply adding an annotation (<code>@GenerateLenses</code>, <code>@GeneratePrisms</code>, etc.) to your data classes, you get fully-functional, type-safe optics for free. This is a massive productivity boost and eliminates a major barrier to using optics in Java.</li>
<li><strong>Higher-Kinded Types for Effectful Updates</strong>: This is the most powerful feature. Because <code>higher-kinded-j</code> provides an HKT abstraction (<code>Kind&lt;F, A&gt;</code>) and type classes like <code>Functor</code> and <code>Applicative</code>, the optics can perform <em>effectful</em> modifications. The <code>modifyF</code> method is generic over an <code>Applicative</code> effect <code>F</code>. This means you can perform an update within the context of any data type that has an <code>Applicative</code> instance:
<ul>
<li>Want to perform an update that might fail? Use <code>Optional</code> or <code>Either</code> as your <code>F</code>.</li>
<li>Want to perform an asynchronous update? Use <code>CompletableFuture</code> as your <code>F</code>.</li>
<li>Want to accumulate validation errors? Use <code>Validated</code> as your <code>F</code>.</li>
</ul>
</li>
<li><strong>Profunctor Adaptability</strong>: Every optic is fundamentally a profunctor, meaning it can be adapted to work with different data types and structures. This provides incredible flexibility for integrating with external systems, handling legacy data formats, and working with strongly-typed wrappers.</li>
</ol>
<h2 id="common-patterns-1"><a class="header" href="#common-patterns-1">Common Patterns</a></h2>
<h3 id="when-to-use-with-helpers-vs-manual-lenses"><a class="header" href="#when-to-use-with-helpers-vs-manual-lenses">When to Use <code>with*</code> Helpers vs Manual Lenses</a></h3>
<ul>
<li><strong>Use <code>with*</code> helpers</strong> for simple, top-level field updates</li>
<li><strong>Use composed lenses</strong> for deep updates or when you need to reuse the path</li>
<li><strong>Use manual lens creation</strong> for computed properties or complex transformations</li>
</ul>
<h3 id="decision-guide"><a class="header" href="#decision-guide">Decision Guide</a></h3>
<ul>
<li><strong>Need to focus on a required field?</strong> → <strong>Lens</strong></li>
<li><strong>Need to work with optional variants?</strong> → <strong>Prism</strong></li>
<li><strong>Need to convert between equivalent types?</strong> → <strong>Iso</strong></li>
<li><strong>Need to modify collections?</strong> → <strong>Traversal</strong></li>
<li><strong>Need to query or extract data without modification?</strong> → <strong>Fold</strong></li>
<li><strong>Need to adapt existing optics?</strong> → <strong>Profunctor operations</strong></li>
</ul>
<h2 id="common-pitfalls-8"><a class="header" href="#common-pitfalls-8">Common Pitfalls</a></h2>
<p><strong>Don't do this:</strong></p>
<p>java</p>
<pre><code class="language-java">// Calling get() multiple times is inefficient
var street = employeeToStreet.get(employee);
var newEmployee = employeeToStreet.set(street.toUpperCase(), employee);
</code></pre>
<p><strong>Do this instead:</strong></p>
<p>java</p>
<pre><code class="language-java">// Use modify() for transformations
var newEmployee = employeeToStreet.modify(String::toUpperCase, employee);
</code></pre>
<p>This level of abstraction enables you to write highly reusable and testable business logic that is completely decoupled from the details of state management, asynchrony, or error handling.</p>
<h2 id="making-optics-feel-natural-in-java"><a class="header" href="#making-optics-feel-natural-in-java">Making Optics Feel Natural in Java</a></h2>
<p>While optics are powerful, their functional programming origins can make them feel foreign to Java developers. To bridge this gap, <code>higher-kinded-j</code> provides two complementary approaches for working with optics:</p>
<h3 id="fluent-api-for-optics"><a class="header" href="#fluent-api-for-optics">Fluent API for Optics</a></h3>
<p>The <strong><a href="optics/fluent_api.html">Fluent API</a></strong> provides Java-friendly syntax for optic operations, offering both concise static methods and discoverable fluent builders:</p>
<pre><code class="language-java">// Static method style - concise
int age = OpticOps.get(person, PersonLenses.age());

// Fluent builder style - explicit and discoverable
int age = OpticOps.getting(person).through(PersonLenses.age());
</code></pre>
<p>This makes optics feel natural in Java whilst preserving all their functional power. Learn more in the <a href="optics/fluent_api.html">Fluent API Guide</a>.</p>
<h3 id="free-monad-dsl-for-optics"><a class="header" href="#free-monad-dsl-for-optics">Free Monad DSL for Optics</a></h3>
<p>The <strong><a href="optics/free_monad_dsl.html">Free Monad DSL</a></strong> separates program description from execution, enabling you to:</p>
<ul>
<li>Build optic programs as composable values</li>
<li>Execute programs with different strategies (direct, logging, validation)</li>
<li>Create audit trails for compliance</li>
<li>Validate operations before applying them</li>
</ul>
<pre><code class="language-java">// Build a program
Free&lt;OpticOpKind.Witness, Person&gt; program =
    OpticPrograms.get(person, PersonLenses.age())
        .flatMap(age -&gt;
            OpticPrograms.set(person, PersonLenses.age(), age + 1));

// Execute with different interpreters
Person result = OpticInterpreters.direct().run(program);                     // Production
LoggingOpticInterpreter logger = OpticInterpreters.logging();
logger.run(program);                                                          // Audit trail
ValidationOpticInterpreter.ValidationResult validation = OpticInterpreters.validating().validate(program);  // Dry-run
</code></pre>
<p>This powerful pattern is explored in detail in the <a href="optics/free_monad_dsl.html">Free Monad DSL Guide</a> and <a href="optics/interpreters.html">Optic Interpreters Guide</a>.</p>
<hr />
<p><strong>Next:</strong> <a href="optics/lenses.html">Lenses: Working with Product Types</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="nested-updates-with-lenses-a-practical-guide"><a class="header" href="#nested-updates-with-lenses-a-practical-guide">Nested Updates with Lenses: A Practical Guide</a></h1>
<h2 id="working-with-product-types"><a class="header" href="#working-with-product-types"><em>Working with Product Types</em></a></h2>
<p><img src="optics/../images/lens2.jpg" alt="Visual representation of a lens focusing on a single field within nested immutable data structures" /></p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="optics/lenses.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to safely access and update fields in immutable data structures</li>
<li>Using <code>@GenerateLenses</code> to automatically create type-safe field accessors</li>
<li>Composing lenses to navigate deeply nested records</li>
<li>The difference between <code>get</code>, <code>set</code>, and <code>modify</code> operations</li>
<li>Building reusable, composable data access patterns</li>
<li>When to use lenses vs direct field access</li>
</ul>
</div>
</div>
<div id="admonition-hands-on-practice" class="admonition admonish-note" role="note" aria-labelledby="admonition-hands-on-practice-title">
<div class="admonition-title">
<div id="admonition-hands-on-practice-title">
<p>Hands On Practice</p>
</div>
<a class="admonition-anchor-link" href="optics/lenses.html#admonition-hands-on-practice"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/optics/Tutorial01_LensBasics.java">Tutorial01_LensBasics.java</a> | <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/optics/Tutorial07_GeneratedOptics.java">Tutorial07_GeneratedOptics.java</a></p>
</div>
</div>
<div id="admonition-example-code" class="admonition admonish-note" role="note" aria-labelledby="admonition-example-code-title">
<div class="admonition-title">
<div id="admonition-example-code-title">
<p>Example Code</p>
</div>
<a class="admonition-anchor-link" href="optics/lenses.html#admonition-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/LensUsageExample.java">LensesExample</a></p>
</div>
</div>
<p>In the introduction to optics, we saw how updating nested immutable data can be verbose and why optics provide a clean, functional solution. We identified the <code>Lens</code> as the primary tool for working with "has-a" relationships, like a field within a record.</p>
<p>This guide provides a complete, step-by-step walkthrough of how to solve the nested update problem using a composable Lens and its generated helper methods.</p>
<hr />
<h2 id="the-scenario-updating-an-employees-address"><a class="header" href="#the-scenario-updating-an-employees-address">The Scenario: Updating an Employee's Address</a></h2>
<p>Let's use a common business scenario involving a deeply nested data structure. Our goal is to update the <code>street</code> of an <code>Employee</code>'s <code>Company``Address</code>.</p>
<p><strong>The Data Model:</strong></p>
<pre><code class="language-java">public record Address(String street, String city) {}
public record Company(String name, Address address) {}
public record Employee(String name, Company company) {}
</code></pre>
<p>Without optics, changing the street requires manually rebuilding the entire <code>Employee</code> object graph. With optics, we can define a direct path to the <code>street</code> and perform the update in a single, declarative line.</p>
<hr />
<h2 id="a-step-by-step-walkthrough"><a class="header" href="#a-step-by-step-walkthrough">A Step-by-Step Walkthrough</a></h2>
<h3 id="step-1-generating-the-lenses"><a class="header" href="#step-1-generating-the-lenses">Step 1: Generating the Lenses</a></h3>
<p>Manually writing <code>Lens</code> implementations is tedious boilerplate. The <code>hkj-optics</code> library automates this with an annotation processor. To begin, we simply annotate our records with <strong><code>@GenerateLenses</code></strong>.</p>
<p>This process creates a companion class for each record (e.g., <code>EmployeeLenses</code>, <code>CompanyLenses</code>) that contains two key features:</p>
<ol>
<li><strong>Lens Factories</strong>: Static methods that create a <code>Lens</code> for each field (e.g., <code>EmployeeLenses.company()</code>).</li>
<li><strong><code>with*</code> Helpers</strong>: Static convenience methods for easy, shallow updates (e.g., <code>EmployeeLenses.withCompany(...)</code>).</li>
</ol>
<pre><code class="language-java">import org.higherkindedj.optics.annotations.GenerateLenses;

@GenerateLenses
public record Address(String street, String city) {}

@GenerateLenses
public record Company(String name, Address address) {}

@GenerateLenses
public record Employee(String name, Company company) {}
</code></pre>
<h4 id="customising-the-generated-package"><a class="header" href="#customising-the-generated-package">Customising the Generated Package</a></h4>
<p>By default, generated classes are placed in the same package as the annotated record. You can specify a different package using the <code>targetPackage</code> attribute to avoid name collisions or to organise generated code separately:</p>
<pre><code class="language-java">// Generated class will be placed in org.example.generated.optics
@GenerateLenses(targetPackage = "org.example.generated.optics")
public record Address(String street, String city) {}
</code></pre>
<p>This is particularly useful when:</p>
<ul>
<li>Multiple records in different packages share the same name</li>
<li>You want to keep generated code separate from source code</li>
<li>You need to control the visibility of generated classes</li>
</ul>
<h3 id="step-2-composing-a-deep-lens"><a class="header" href="#step-2-composing-a-deep-lens">Step 2: Composing a Deep Lens</a></h3>
<p>With the lenses generated, we can now compose them using the <strong><code>andThen</code></strong> method. We'll chain the individual lenses together to create a single, new <code>Lens</code> that represents the complete path from the top-level object (<code>Employee</code>) to the deeply nested field (<code>street</code>).</p>
<p>The result is a new, powerful, and reusable <code>Lens&lt;Employee, String&gt;</code>.</p>
<pre><code class="language-java">// Get the generated lenses
Lens&lt;Employee, Company&gt; employeeToCompany = EmployeeLenses.company();
Lens&lt;Company, Address&gt; companyToAddress = CompanyLenses.address();
Lens&lt;Address, String&gt; addressToStreet = AddressLenses.street();

// Compose them to create a single, deep lens
Lens&lt;Employee, String&gt; employeeToStreet =
    employeeToCompany
        .andThen(companyToAddress)
        .andThen(addressToStreet);
</code></pre>
<h3 id="step-3-performing-updates-with-the-composed-lens"><a class="header" href="#step-3-performing-updates-with-the-composed-lens">Step 3: Performing Updates with the Composed Lens</a></h3>
<p>With our optics generated, we have two primary ways to perform updates.</p>
<h4 id="a-simple-shallow-updates-with-with-helpers"><a class="header" href="#a-simple-shallow-updates-with-with-helpers">A) Simple, Shallow Updates with <code>with*</code> Helpers</a></h4>
<p>For simple updates to a top-level field, the generated <code>with*</code> methods are the most convenient and readable option.</p>
<pre><code class="language-java">// Create an employee instance
var employee = new Employee("Alice", ...);

// Use the generated helper to create an updated copy
var updatedEmployee = EmployeeLenses.withName(employee, "Bob");
</code></pre>
<p>This is a cleaner, more discoverable alternative to using the lens directly (<code>EmployeeLenses.name().set("Bob", employee)</code>).</p>
<h4 id="b-deep-updates-with-a-composed-lens"><a class="header" href="#b-deep-updates-with-a-composed-lens">B) Deep Updates with a Composed Lens</a></h4>
<p>For deep updates into nested structures, the composed lens is the perfect tool. The <code>Lens</code> interface provides two primary methods for this:</p>
<ul>
<li><code>set(newValue, object)</code>: Replaces the focused value with a new one.</li>
<li><code>modify(function, object)</code>: Applies a function to the focused value to compute the new value.</li>
</ul>
<p>Both methods handle the "copy-and-update" cascade for you, returning a completely new top-level object.</p>
<pre><code class="language-java">// Use the composed lens from Step 2
Employee updatedEmployee = employeeToStreet.set("456 Main St", initialEmployee);
</code></pre>
<hr />
<h2 id="when-to-use-with-helpers-vs-manual-lenses-1"><a class="header" href="#when-to-use-with-helpers-vs-manual-lenses-1">When to Use <code>with*</code> Helpers vs Manual Lenses</a></h2>
<p>Understanding when to use each approach will help you write cleaner, more maintainable code:</p>
<h3 id="use-with-helpers-when"><a class="header" href="#use-with-helpers-when">Use <code>with*</code> Helpers When:</a></h3>
<ul>
<li><strong>Simple, top-level field updates</strong> - Direct field replacement on the immediate object</li>
<li><strong>One-off updates</strong> - You don't need to reuse the update logic</li>
<li><strong>API clarity</strong> - You want the most discoverable, IDE-friendly approach</li>
</ul>
<pre><code class="language-java">// Perfect for simple updates
var promotedEmployee = EmployeeLenses.withName(employee, "Senior " + employee.name());
</code></pre>
<h3 id="use-composed-lenses-when"><a class="header" href="#use-composed-lenses-when">Use Composed Lenses When:</a></h3>
<ul>
<li><strong>Deep updates</strong> - Navigating multiple levels of nesting</li>
<li><strong>Reusable paths</strong> - The same update pattern will be used multiple times</li>
<li><strong>Complex transformations</strong> - Using <code>modify()</code> with functions</li>
<li><strong>Conditional updates</strong> - Part of larger optic compositions</li>
</ul>
<pre><code class="language-java">// Ideal for reusable deep updates
Lens&lt;Employee, String&gt; streetLens = employeeToCompany
    .andThen(companyToAddress)
    .andThen(addressToStreet);

// Can be reused across your application
Employee moved = streetLens.set("New Office Street", employee);
Employee uppercased = streetLens.modify(String::toUpperCase, employee);
</code></pre>
<div id="admonition-cross-optic-composition" class="admonition admonish-tip" role="note" aria-labelledby="admonition-cross-optic-composition-title">
<div class="admonition-title">
<div id="admonition-cross-optic-composition-title">
<p>Cross-Optic Composition</p>
</div>
<a class="admonition-anchor-link" href="optics/lenses.html#admonition-cross-optic-composition"></a>
</div>
<div>
<p>Lenses can also compose with other optic types. When you compose a <code>Lens</code> with a <code>Prism</code>, you get a <code>Traversal</code>:</p>
<pre><code class="language-java">// Lens &gt;&gt;&gt; Prism = Traversal
record User(Optional&lt;Settings&gt; settings) {}
Lens&lt;User, Optional&lt;Settings&gt;&gt; settingsLens = UserLenses.settings();
Prism&lt;Optional&lt;Settings&gt;, Settings&gt; somePrism = Prisms.some();

Traversal&lt;User, Settings&gt; userSettings = settingsLens.andThen(somePrism);
</code></pre>
<p>See <a href="optics/composition_rules.html">Composition Rules</a> for the complete reference on how different optics compose.</p>
</div>
</div>
<h3 id="use-manual-lens-creation-when"><a class="header" href="#use-manual-lens-creation-when">Use Manual Lens Creation When:</a></h3>
<ul>
<li><strong>Computed properties</strong> - The lens represents derived data</li>
<li><strong>Complex transformations</strong> - Custom getter/setter logic</li>
<li><strong>Legacy integration</strong> - Working with existing APIs</li>
</ul>
<pre><code class="language-java">// For computed or derived properties
Lens&lt;Employee, String&gt; fullAddressLens = Lens.of(
    emp -&gt; emp.company().address().street() + ", " + emp.company().address().city(),
    (emp, fullAddr) -&gt; {
        String[] parts = fullAddr.split(", ");
        return employeeToCompany.andThen(companyToAddress).set(
            new Address(parts[0], parts[1]), emp);
    }
);
</code></pre>
<hr />
<h2 id="common-pitfalls-9"><a class="header" href="#common-pitfalls-9">Common Pitfalls</a></h2>
<h3 id="dont-do-this"><a class="header" href="#dont-do-this">Don't Do This:</a></h3>
<pre><code class="language-java">// Inefficient: Calling get() multiple times
var currentStreet = employeeToStreet.get(employee);
var newEmployee = employeeToStreet.set(currentStreet.toUpperCase(), employee);

// Verbose: Rebuilding lenses repeatedly
var street1 = EmployeeLenses.company().andThen(CompanyLenses.address()).andThen(AddressLenses.street()).get(emp1);
var street2 = EmployeeLenses.company().andThen(CompanyLenses.address()).andThen(AddressLenses.street()).get(emp2);

// Mixing approaches unnecessarily
var tempCompany = EmployeeLenses.company().get(employee);
var updatedCompany = CompanyLenses.withName(tempCompany, "New Company");
var finalEmployee = EmployeeLenses.withCompany(employee, updatedCompany);
</code></pre>
<h3 id="do-this-instead"><a class="header" href="#do-this-instead">Do This Instead:</a></h3>
<pre><code class="language-java">// Efficient: Use modify() for transformations
var newEmployee = employeeToStreet.modify(String::toUpperCase, employee);

// Reusable: Create the lens once, use many times
var streetLens = EmployeeLenses.company().andThen(CompanyLenses.address()).andThen(AddressLenses.street());
var street1 = streetLens.get(emp1);
var street2 = streetLens.get(emp2);

// Consistent: Use one approach for the entire update
var finalEmployee = EmployeeLenses.company()
    .andThen(CompanyLenses.name())
    .set("New Company", employee);
</code></pre>
<hr />
<h2 id="performance-notes"><a class="header" href="#performance-notes">Performance Notes</a></h2>
<p>Lenses are optimised for immutable updates:</p>
<ul>
<li><strong>Memory efficient</strong>: Only creates new objects along the path that changes</li>
<li><strong>Reusable</strong>: Composed lenses can be stored and reused across your application</li>
<li><strong>Type-safe</strong>: All operations are checked at compile time</li>
<li><strong>Lazy</strong>: Operations are only performed when needed</li>
</ul>
<p><strong>Best Practice</strong>: For frequently used paths, create the composed lens once and store it as a static field:</p>
<pre><code class="language-java">public class EmployeeOptics {
    public static final Lens&lt;Employee, String&gt; STREET = 
        EmployeeLenses.company()
            .andThen(CompanyLenses.address())
            .andThen(AddressLenses.street());
        
    public static final Lens&lt;Employee, String&gt; COMPANY_NAME = 
        EmployeeLenses.company()
            .andThen(CompanyLenses.name());
}
</code></pre>
<hr />
<h2 id="complete-runnable-example"><a class="header" href="#complete-runnable-example">Complete, Runnable Example</a></h2>
<p>The following standalone example puts all these steps together. You can run it to see the output and the immutability in action.</p>
<pre><code class="language-java">package org.higherkindedj.example.lens;

// Imports for the generated classes would be automatically resolved by your IDE
import org.higherkindedj.example.lens.LensUsageExampleLenses.AddressLenses;
import org.higherkindedj.example.lens.LensUsageExampleLenses.CompanyLenses;
import org.higherkindedj.example.lens.LensUsageExampleLenses.EmployeeLenses;
import org.higherkindedj.optics.Lens;
import org.higherkindedj.optics.annotations.GenerateLenses;

public class LensUsageExample {

    // 1. Define a nested, immutable data model.
    @GenerateLenses
    public record Address(String street, String city) {}

    @GenerateLenses
    public record Company(String name, Address address) {}

    @GenerateLenses
    public record Employee(String name, Company company) {}


    public static void main(String[] args) {
        // 2. Create an initial, nested immutable object.
        var initialAddress = new Address("123 Fake St", "Anytown");
        var initialCompany = new Company("Initech Inc.", initialAddress);
        var initialEmployee = new Employee("Alice", initialCompany);

        System.out.println("Original Employee: " + initialEmployee);
        System.out.println("------------------------------------------");


        // --- SCENARIO 1: Simple update with a `with*` helper ---
        System.out.println("--- Scenario 1: Using `with*` Helper ---");
        var employeeWithNewName = EmployeeLenses.withName(initialEmployee, "Bob");
        System.out.println("After `withName`:    " + employeeWithNewName);
        System.out.println("------------------------------------------");

        // --- SCENARIO 2: Deep update with a composed Lens ---
        System.out.println("--- Scenario 2: Using Composed Lens ---");
        Lens&lt;Employee, String&gt; employeeToStreet =
            EmployeeLenses.company()
                .andThen(CompanyLenses.address())
                .andThen(AddressLenses.street());

        // Use `set` to replace a value
        Employee updatedEmployeeSet = employeeToStreet.set("456 Main St", initialEmployee);
        System.out.println("After deep `set`:       " + updatedEmployeeSet);

        // Use `modify` to apply a function
        Employee updatedEmployeeModify = employeeToStreet.modify(String::toUpperCase, initialEmployee);
        System.out.println("After deep `modify`:    " + updatedEmployeeModify);
        System.out.println("Original is unchanged:  " + initialEmployee);
      
        // --- SCENARIO 3: Demonstrating reusability ---
        System.out.println("--- Scenario 3: Reusing Composed Lens ---");
        var employee2 = new Employee("Charlie", new Company("Tech Corp", new Address("789 Oak Ave", "Tech City")));
      
        // Same lens works on different employee instances
        var bothUpdated = List.of(initialEmployee, employee2)
            .stream()
            .map(emp -&gt; employeeToStreet.modify(street -&gt; "Remote: " + street, emp))
            .toList();
          
        System.out.println("Batch updated: " + bothUpdated);
    }
}
</code></pre>
<p><strong>Expected Output:</strong></p>
<pre><code>Original Employee: Employee[name=Alice, company=Company[name=Initech Inc., address=Address[street=123 Fake St, city=Anytown]]]
------------------------------------------
--- Scenario 1: Using `with*` Helper ---
After `withName`:    Employee[name=Bob, company=Company[name=Initech Inc., address=Address[street=123 Fake St, city=Anytown]]]
------------------------------------------
--- Scenario 2: Using Composed Lens ---
After deep `set`:       Employee[name=Alice, company=Company[name=Initech Inc., address=Address[street=456 Main St, city=Anytown]]]
After deep `modify`:    Employee[name=Alice, company=Company[name=Initech Inc., address=Address[street=123 FAKE ST, city=Anytown]]]
Original is unchanged:  Employee[name=Alice, company=Company[name=Initech Inc., address=Address[street=123 Fake St, city=Anytown]]]
------------------------------------------
--- Scenario 3: Reusing Composed Lens ---
Batch updated: [Employee[name=Alice, company=Company[name=Initech Inc., address=Address[street=Remote: 123 Fake St, city=Anytown]]], Employee[name=Charlie, company=Company[name=Tech Corp, address=Address[street=Remote: 789 Oak Ave, city=Tech City]]]]
</code></pre>
<p>As you can see, the generated optics provide a clean, declarative, and type-safe API for working with immutable data, whether your updates are simple and shallow or complex and deep.</p>
<hr />
<h2 id="beyond-the-basics-effectful-updates-with-modifyf"><a class="header" href="#beyond-the-basics-effectful-updates-with-modifyf">Beyond the Basics: Effectful Updates with <code>modifyF</code></a></h2>
<p>While <code>set</code> and <code>modify</code> are for simple, pure updates, the <code>Lens</code> interface also supports effectful operations through <code>modifyF</code>. This method allows you to perform updates within a context like an <code>Optional</code>, <code>Validated</code>, or <code>CompletableFuture</code>.</p>
<p>This means you can use the same <code>employeeToStreet</code> lens to perform a street name update that involves failable validation or an asynchronous API call, making your business logic incredibly reusable and robust.</p>
<pre><code class="language-java">// Example: Street validation that might fail
Function&lt;String, Kind&lt;ValidatedKind.Witness&lt;String&gt;, String&gt;&gt; validateStreet = 
    street -&gt; street.length() &gt; 0 &amp;&amp; street.length() &lt; 100 
        ? VALIDATED.widen(Validated.valid(street))
        : VALIDATED.widen(Validated.invalid("Street name must be between 1 and 100 characters"));

// Use the same lens with effectful validation
Kind&lt;ValidatedKind.Witness&lt;String&gt;, Employee&gt; result =
    employeeToStreet.modifyF(validateStreet, employee, validatedApplicative);
</code></pre>
<div id="admonition-for-comprehension-integration" class="admonition admonish-tip" role="note" aria-labelledby="admonition-for-comprehension-integration-title">
<div class="admonition-title">
<div id="admonition-for-comprehension-integration-title">
<p>For Comprehension Integration</p>
</div>
<a class="admonition-anchor-link" href="optics/lenses.html#admonition-for-comprehension-integration"></a>
</div>
<div>
<p>Lenses integrate with For comprehensions in two ways:</p>
<ul>
<li>Use <code>focus()</code> within a For comprehension to extract values via lens-like accessors. See <a href="optics/../functional/for_comprehension.html#extracting-values-with-focus">For Comprehensions: Extracting Values with focus()</a>.</li>
<li>Use <code>ForState</code> for stateful lens operations that thread updates through a workflow. See <a href="optics/../functional/for_comprehension.html#stateful-updates-with-forstate">For Comprehensions: Stateful Updates with ForState</a>.</li>
</ul>
</div>
</div>
<div id="admonition-hands-on-learning" class="admonition admonish-info" role="note" aria-labelledby="admonition-hands-on-learning-title">
<div class="admonition-title">
<div id="admonition-hands-on-learning-title">
<p>Hands-On Learning</p>
</div>
<a class="admonition-anchor-link" href="optics/lenses.html#admonition-hands-on-learning"></a>
</div>
<div>
<p>Practice lens basics in <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/optics/Tutorial01_LensBasics.java">Tutorial 01: Lens Basics</a> (7 exercises, ~10 minutes) and generated optics in <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/optics/Tutorial07_GeneratedOptics.java">Tutorial 07: Generated Optics</a> (7 exercises, ~10 minutes).</p>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="optics/optics_intro.html">An Introduction to Optics</a>
<strong>Next:</strong> <a href="optics/prisms.html">Prisms: Working with Sum Types</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="prisms-a-practical-guide"><a class="header" href="#prisms-a-practical-guide">Prisms: A Practical Guide</a></h1>
<h2 id="working-with-sum-types"><a class="header" href="#working-with-sum-types"><em>Working with Sum Types</em></a></h2>
<p><img src="optics/../images/prism.jpeg" alt="Visual representation of a prism safely extracting one variant from a sum type" /></p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="optics/prisms.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to safely work with sum types and sealed interfaces</li>
<li>Using <code>@GeneratePrisms</code> to create type-safe variant accessors</li>
<li>The difference between <code>getOptional</code> and <code>build</code> operations</li>
<li>Composing prisms with other optics for deep conditional access</li>
<li>Handling optional data extraction without <code>instanceof</code> chains</li>
<li>When to use prisms vs pattern matching vs traditional type checking</li>
</ul>
</div>
</div>
<div id="admonition-hands-on-practice" class="admonition admonish-note" role="note" aria-labelledby="admonition-hands-on-practice-title">
<div class="admonition-title">
<div id="admonition-hands-on-practice-title">
<p>Hands On Practice</p>
</div>
<a class="admonition-anchor-link" href="optics/prisms.html#admonition-hands-on-practice"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/optics/Tutorial03_PrismBasics.java">Tutorial03_PrismBasics.java</a></p>
</div>
</div>
<div id="admonition-example-code" class="admonition admonish-note" role="note" aria-labelledby="admonition-example-code-title">
<div class="admonition-title">
<div id="admonition-example-code-title">
<p>Example Code</p>
</div>
<a class="admonition-anchor-link" href="optics/prisms.html#admonition-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/PrismUsageExample.java">PrismUsageExample</a>
<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/PrismConvenienceMethodsExample.java">PrismConvenienceMethodsExample</a>
<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/PrismsUtilityExample.java">PrismsUtilityExample</a></p>
</div>
</div>
<p>The previous guide demonstrated how a <strong><code>Lens</code></strong> gives us a powerful, composable way to work with "has-a" relationships: a field that is guaranteed to exist within a record.</p>
<p>But what happens when the data doesn't have a guaranteed structure? What if a value can be one of <em>several different types</em>? This is the domain of "is-a" relationships, or <strong>sum types</strong>, commonly modeled in Java using <code>sealed interface</code> or <code>enum</code>.</p>
<p>For this, we need a different kind of optic: the <strong>Prism</strong>.</p>
<hr />
<h2 id="the-scenario-working-with-json-like-data"><a class="header" href="#the-scenario-working-with-json-like-data">The Scenario: Working with JSON-like Data</a></h2>
<p>A <code>Lens</code> is like a sniper rifle, targeting a single, known field. A <strong><code>Prism</code></strong> is like a safe-cracker's tool; it attempts to open a specific "lock" (a particular type) and only succeeds if it has the right key.</p>
<p>Consider a common scenario: modelling a JSON structure. A value can be a string, a number, a boolean, or a nested object.</p>
<p><strong>The Data Model:</strong> We can represent this with a <code>sealed interface</code>.</p>
<pre><code class="language-java">import org.higherkindedj.optics.annotations.GeneratePrisms;
import org.higherkindedj.optics.annotations.GenerateLenses;
import java.util.Map;

@GeneratePrisms // Generates Prisms for each case of the sealed interface
public sealed interface JsonValue {}

public record JsonString(String value) implements JsonValue {}
public record JsonNumber(double value) implements JsonValue {}

@GenerateLenses // We can still use Lenses on the product types within the sum type
public record JsonObject(Map&lt;String, JsonValue&gt; fields) implements JsonValue {}
</code></pre>
<p><strong>Our Goal:</strong> We need to safely access and update the <code>value</code> of a <code>JsonString</code> that is deeply nested within another <code>JsonObject</code>. An <code>instanceof</code> and casting approach would be unsafe and verbose. A <code>Lens</code> won't work because a <code>JsonValue</code> might be a <code>JsonNumber</code>, not the <code>JsonObject</code> we expect.</p>
<hr />
<h2 id="think-of-prisms-like"><a class="header" href="#think-of-prisms-like">Think of Prisms Like...</a></h2>
<ul>
<li><strong>A type-safe filter</strong>: Only "lets through" values that match a specific shape</li>
<li><strong>A safe cast</strong>: Like <code>instanceof</code> + cast, but functional and composable</li>
<li><strong>A conditional lens</strong>: Works like a lens, but might return empty if the type doesn't match</li>
<li><strong>A pattern matcher</strong>: Focuses on one specific case of a sum type</li>
</ul>
<hr />
<h2 id="a-step-by-step-walkthrough-1"><a class="header" href="#a-step-by-step-walkthrough-1">A Step-by-Step Walkthrough</a></h2>
<h3 id="step-1-generating-the-prisms"><a class="header" href="#step-1-generating-the-prisms">Step 1: Generating the Prisms</a></h3>
<p>Just as with lenses, we annotate our <code>sealed interface</code> with <strong><code>@GeneratePrisms</code></strong>. This automatically creates a companion class (e.g., <code>JsonValuePrisms</code>) with a <code>Prism</code> for each permitted subtype.</p>
<pre><code class="language-java">// Generated automatically:
// JsonValuePrisms.jsonString() -&gt; Prism&lt;JsonValue, JsonString&gt;
// JsonValuePrisms.jsonNumber() -&gt; Prism&lt;JsonValue, JsonNumber&gt;
// JsonValuePrisms.jsonBoolean() -&gt; Prism&lt;JsonValue, JsonBoolean&gt;
// JsonValuePrisms.jsonObject() -&gt; Prism&lt;JsonValue, JsonObject&gt;
</code></pre>
<h4 id="customising-the-generated-package-1"><a class="header" href="#customising-the-generated-package-1">Customising the Generated Package</a></h4>
<p>By default, generated classes are placed in the same package as the annotated type. You can specify a different package using the <code>targetPackage</code> attribute:</p>
<pre><code class="language-java">// Generated class will be placed in org.example.generated.optics
@GeneratePrisms(targetPackage = "org.example.generated.optics")
public sealed interface JsonValue {}
</code></pre>
<p>This is useful when you need to avoid name collisions or organise generated code separately.</p>
<h3 id="step-2-the-core-prism-operations"><a class="header" href="#step-2-the-core-prism-operations">Step 2: The Core Prism Operations</a></h3>
<p>A <code>Prism</code> is defined by two unique, failable operations:</p>
<ul>
<li><strong><code>getOptional(source)</code></strong>: Attempts to focus on the target. It returns an <code>Optional</code> which is non-empty only if the <code>source</code> matches the Prism's specific case. This is the safe alternative to an <code>instanceof</code> check and cast.</li>
<li><strong><code>build(value)</code></strong>: Constructs the top-level type from a part. This is the reverse operation, used to wrap a value back into its specific case (e.g., taking a <code>String</code> and building a <code>JsonString</code>).</li>
</ul>
<pre><code class="language-java">Prism&lt;JsonValue, JsonString&gt; jsonStringPrism = JsonValuePrisms.jsonString();

// --- Using getOptional (the safe "cast") ---
Optional&lt;JsonString&gt; result1 = jsonStringPrism.getOptional(new JsonString("hello")); 
// -&gt; Optional.of(JsonString("hello"))

Optional&lt;JsonString&gt; result2 = jsonStringPrism.getOptional(new JsonNumber(123));   
// -&gt; Optional.empty()

// --- Using build (construct the sum type from a part) ---
JsonValue result3 = jsonStringPrism.build(new JsonString("world")); 
// -&gt; JsonString("world") (as JsonValue)
</code></pre>
<h3 id="step-3-composing-prisms-for-deep-access"><a class="header" href="#step-3-composing-prisms-for-deep-access">Step 3: Composing Prisms for Deep Access</a></h3>
<p>The true power is composing <code>Prism</code>s with other optics. When a composition might fail (any time a <code>Prism</code> is involved), the result is an <code>Affine</code> (or <code>Traversal</code> when combining with traversals).</p>
<div id="admonition-direct-composition-methods" class="admonition admonish-tip" role="note" aria-labelledby="admonition-direct-composition-methods-title">
<div class="admonition-title">
<div id="admonition-direct-composition-methods-title">
<p>Direct Composition Methods</p>
</div>
<a class="admonition-anchor-link" href="optics/prisms.html#admonition-direct-composition-methods"></a>
</div>
<div>
<p>higher-kinded-j provides direct composition methods that automatically return the correct type:</p>
<ul>
<li><code>Lens.andThen(Prism)</code> returns <code>Affine</code></li>
<li><code>Prism.andThen(Lens)</code> returns <code>Affine</code></li>
<li><code>Prism.andThen(Prism)</code> returns <code>Prism</code></li>
<li><code>Affine.andThen(Affine)</code> returns <code>Affine</code></li>
</ul>
<p>See <a href="optics/composition_rules.html">Composition Rules</a> for the complete reference.</p>
</div>
</div>
<pre><code class="language-java">// Create all the optics we need
Prism&lt;JsonValue, JsonObject&gt; jsonObjectPrism = JsonValuePrisms.jsonObject();
Prism&lt;JsonValue, JsonString&gt; jsonStringPrism = JsonValuePrisms.jsonString();
Lens&lt;JsonObject, Map&lt;String, JsonValue&gt;&gt; fieldsLens = JsonObjectLenses.fields();
Lens&lt;JsonString, String&gt; valueLens = JsonStringLenses.value();

// Direct composition: Prism &gt;&gt;&gt; Lens = Traversal
Traversal&lt;JsonValue, String&gt; jsonStringValue =
    jsonStringPrism.andThen(valueLens);

// The composed optic: safely navigate from JsonObject -&gt; userLogin field -&gt; name field -&gt; string value
Traversal&lt;JsonObject, String&gt; userNameTraversal =
    fieldsLens.asTraversal()                      // JsonObject -&gt; Map&lt;String, JsonValue&gt;
        .andThen(Traversals.forMap("userLogin"))  // -&gt; JsonValue (if "userLogin" key exists)
        .andThen(jsonObjectPrism.asTraversal())   // -&gt; JsonObject (if it's an object)
        .andThen(fieldsLens.asTraversal())        // -&gt; Map&lt;String, JsonValue&gt;
        .andThen(Traversals.forMap("name"))       // -&gt; JsonValue (if "name" key exists)
        .andThen(jsonStringValue);                // -&gt; String (if it's a string)
</code></pre>
<p>This composed <code>Traversal</code> now represents a safe, deep path that will only succeed if every step in the chain matches.</p>
<hr />
<h2 id="when-to-use-prisms-vs-other-approaches"><a class="header" href="#when-to-use-prisms-vs-other-approaches">When to Use Prisms vs Other Approaches</a></h2>
<h3 id="use-prisms-when"><a class="header" href="#use-prisms-when">Use Prisms When:</a></h3>
<ul>
<li><strong>Type-safe variant handling</strong> - Working with <code>sealed interface</code> or <code>enum</code> cases</li>
<li><strong>Optional data extraction</strong> - You need to safely "try" to get a specific type</li>
<li><strong>Composable type checking</strong> - Building reusable type-safe paths</li>
<li><strong>Functional pattern matching</strong> - Avoiding <code>instanceof</code> chains</li>
</ul>
<pre><code class="language-java">// Perfect for safe type extraction
Optional&lt;String&gt; errorMessage = DomainErrorPrisms.validationError()
    .andThen(ValidationErrorLenses.message())
    .getOptional(someError);
</code></pre>
<h3 id="use-traditional-instanceof-when"><a class="header" href="#use-traditional-instanceof-when">Use Traditional instanceof When:</a></h3>
<ul>
<li><strong>One-off type checks</strong> - Not building reusable logic</li>
<li><strong>Imperative control flow</strong> - You need if/else branching</li>
<li><strong>Performance critical paths</strong> - Minimal abstraction overhead needed</li>
</ul>
<pre><code class="language-java">// Sometimes instanceof is clearer for simple cases
if (jsonValue instanceof JsonString jsonStr) {
    return jsonStr.value().toUpperCase();
}
</code></pre>
<h3 id="use-pattern-matching-when"><a class="header" href="#use-pattern-matching-when">Use Pattern Matching When:</a></h3>
<ul>
<li><strong>Exhaustive case handling</strong> - You need to handle all variants</li>
<li><strong>Complex extraction logic</strong> - Multiple levels of pattern matching</li>
<li><strong>Modern codebases</strong> - Using recent Java features</li>
</ul>
<pre><code class="language-java">// Pattern matching for comprehensive handling
return switch (jsonValue) {
    case JsonString(var str) -&gt; str.toUpperCase();
    case JsonNumber(var num) -&gt; String.valueOf(num);
    case JsonBoolean(var bool) -&gt; String.valueOf(bool);
    case JsonObject(var fields) -&gt; "Object with " + fields.size() + " fields";
};
</code></pre>
<hr />
<h2 id="common-pitfalls-10"><a class="header" href="#common-pitfalls-10">Common Pitfalls</a></h2>
<h3 id="dont-do-this-1"><a class="header" href="#dont-do-this-1">Don't Do This:</a></h3>
<pre><code class="language-java">// Unsafe: Assuming the cast will succeed
JsonString jsonStr = (JsonString) jsonValue; // Can throw ClassCastException!

// Verbose: Repeated instanceof checks
if (jsonValue instanceof JsonObject obj1) {
    var userValue = obj1.fields().get("userLogin");
    if (userValue instanceof JsonObject obj2) {
        var nameValue = obj2.fields().get("name");
        if (nameValue instanceof JsonString str) {
            return str.value().toUpperCase();
        }
    }
}

// Inefficient: Creating prisms repeatedly
var name1 = JsonValuePrisms.jsonString().getOptional(value1);
var name2 = JsonValuePrisms.jsonString().getOptional(value2);
var name3 = JsonValuePrisms.jsonString().getOptional(value3);
</code></pre>
<h3 id="do-this-instead-1"><a class="header" href="#do-this-instead-1">Do This Instead:</a></h3>
<pre><code class="language-java">// Safe: Use prism's getOptional
Optional&lt;JsonString&gt; maybeJsonStr = JsonValuePrisms.jsonString().getOptional(jsonValue);

// Composable: Build reusable safe paths
var userNamePath = JsonValuePrisms.jsonObject()
    .andThen(JsonObjectLenses.fields())
    .andThen(mapValue("userLogin"))
    .andThen(JsonValuePrisms.jsonObject())
    // ... continue composition

// Efficient: Reuse prisms and composed paths
var stringPrism = JsonValuePrisms.jsonString();
var name1 = stringPrism.getOptional(value1);
var name2 = stringPrism.getOptional(value2);
var name3 = stringPrism.getOptional(value3);
</code></pre>
<hr />
<h2 id="performance-notes-1"><a class="header" href="#performance-notes-1">Performance Notes</a></h2>
<p>Prisms are optimised for type safety and composability:</p>
<ul>
<li><strong>Fast type checking</strong>: Prisms use <code>instanceof</code> under the hood, which is optimised by the JVM</li>
<li><strong>Lazy evaluation</strong>: Composed prisms only perform checks when needed</li>
<li><strong>Memory efficient</strong>: No boxing or wrapper allocation for failed matches</li>
<li><strong>Composable</strong>: Complex type-safe paths can be built once and reused</li>
</ul>
<p><strong>Best Practice</strong>: For frequently used prism combinations, create them once and store as constants:</p>
<pre><code class="language-java">public class JsonOptics {
    public static final Prism&lt;JsonValue, JsonString&gt; STRING = 
        JsonValuePrisms.jsonString();
  
    public static final Traversal&lt;JsonValue, String&gt; STRING_VALUE = 
        STRING.andThen(JsonStringLenses.value());
  
    public static final Traversal&lt;JsonObject, String&gt; USER_NAME = 
        fieldsLens.asTraversal()
            .andThen(Traversals.forMap("userLogin"))
            .andThen(JsonValuePrisms.jsonObject().asTraversal())
            .andThen(fieldsLens.asTraversal())
            .andThen(Traversals.forMap("name"))
            .andThen(STRING.asTraversal())
            .andThen(JsonStringLenses.value().asTraversal());
}
</code></pre>
<h2 id="real-world-example-api-response-handling"><a class="header" href="#real-world-example-api-response-handling">Real-World Example: API Response Handling</a></h2>
<p>Here's a practical example of using prisms to handle different API response types safely:</p>
<pre><code class="language-java">@GeneratePrisms
public sealed interface ApiResponse {}
public record SuccessResponse(String data, int statusCode) implements ApiResponse {}
public record ErrorResponse(String message, String errorCode) implements ApiResponse {}
public record TimeoutResponse(long timeoutMs) implements ApiResponse {}

public class ApiHandler {
    // Reusable prisms for different response types
    private static final Prism&lt;ApiResponse, SuccessResponse&gt; SUCCESS = 
        ApiResponsePrisms.successResponse();
    private static final Prism&lt;ApiResponse, ErrorResponse&gt; ERROR = 
        ApiResponsePrisms.errorResponse();
    private static final Prism&lt;ApiResponse, TimeoutResponse&gt; TIMEOUT = 
        ApiResponsePrisms.timeoutResponse();
  
    public String handleResponse(ApiResponse response) {
        // Type-safe extraction and handling
        return SUCCESS.getOptional(response)
            .map(success -&gt; "Success: " + success.data())
            .or(() -&gt; ERROR.getOptional(response)
                .map(error -&gt; "Error " + error.errorCode() + ": " + error.message()))
            .or(() -&gt; TIMEOUT.getOptional(response)
                .map(timeout -&gt; "Request timed out after " + timeout.timeoutMs() + "ms"))
            .orElse("Unknown response type");
    }
  
    // Use prisms for conditional processing
    public boolean isRetryable(ApiResponse response) {
        return ERROR.getOptional(response)
            .map(error -&gt; "RATE_LIMIT".equals(error.errorCode()) || "TEMPORARY".equals(error.errorCode()))
            .or(() -&gt; TIMEOUT.getOptional(response).map(t -&gt; true))
            .orElse(false);
    }
}
</code></pre>
<h2 id="complete-runnable-example-1"><a class="header" href="#complete-runnable-example-1">Complete, Runnable Example</a></h2>
<p>This example puts it all together, showing how to use the composed <code>Traversal</code> to perform a safe update.</p>
<pre><code class="language-java">package org.higherkindedj.example.prism;

import org.higherkindedj.optics.Lens;
import org.higherkindedj.optics.Prism;
import org.higherkindedj.optics.Traversal;
import org.higherkindedj.optics.annotations.GenerateLenses;
import org.higherkindedj.optics.annotations.GeneratePrisms;
import org.higherkindedj.optics.util.Traversals;
import java.util.*;

public class PrismUsageExample {

    // 1. Define the nested data model with sum types.
    @GeneratePrisms
    public sealed interface JsonValue {}
    public record JsonString(String value) implements JsonValue {}
    public record JsonNumber(double value) implements JsonValue {}
  
    @GenerateLenses
    public record JsonObject(Map&lt;String, JsonValue&gt; fields) implements JsonValue {}


    public static void main(String[] args) {
        // 2. Create the initial nested structure.
        var userData = Map.of(
            "userLogin", new JsonObject(Map.of(
                "name", new JsonString("Alice"),
                "age", new JsonNumber(30),
                "active", new JsonBoolean(true)
            )),
            "metadata", new JsonObject(Map.of(
                "version", new JsonString("1.0")
            ))
        );
        var data = new JsonObject(userData);
    
        System.out.println("Original Data: " + data);
        System.out.println("------------------------------------------");


        // 3. Get the generated and manually created optics.
        Prism&lt;JsonValue, JsonObject&gt; jsonObjectPrism = JsonValuePrisms.jsonObject();
        Prism&lt;JsonValue, JsonString&gt; jsonStringPrism = JsonValuePrisms.jsonString();
        Lens&lt;JsonObject, Map&lt;String, JsonValue&gt;&gt; fieldsLens = JsonObjectLenses.fields();
        Lens&lt;JsonString, String&gt; jsonStringValueLens = Lens.of(JsonString::value, (js, s) -&gt; new JsonString(s));
    
        // 4. Demonstrate individual prism operations
        System.out.println("--- Individual Prism Operations ---");
    
        // Safe type extraction
        JsonValue userValue = data.fields().get("userLogin");
        Optional&lt;JsonObject&gt; userObject = jsonObjectPrism.getOptional(userValue);
        System.out.println("User object: " + userObject);
    
        // Attempting to extract wrong type
        JsonValue nameValue = ((JsonObject) userValue).fields().get("name");
        Optional&lt;JsonNumber&gt; nameAsNumber = JsonValuePrisms.jsonNumber().getOptional(nameValue);
        System.out.println("Name as number (should be empty): " + nameAsNumber);
    
        // Building new values
        JsonValue newString = jsonStringPrism.build(new JsonString("Bob"));
        System.out.println("Built new string: " + newString);
        System.out.println("------------------------------------------");
    
        // 5. Compose the full traversal.
        Traversal&lt;JsonObject, String&gt; userToJsonName =
            fieldsLens.asTraversal()
                .andThen(Traversals.forMap("userLogin")) 
                .andThen(jsonObjectPrism.asTraversal())
                .andThen(fieldsLens.asTraversal())
                .andThen(Traversals.forMap("name"))
                .andThen(jsonStringPrism.asTraversal())
                .andThen(jsonStringValueLens.asTraversal());

          // 6. Use the composed traversal to perform safe updates
        JsonObject updatedData = Traversals.modify(userNameTraversal, String::toUpperCase, data);
        System.out.println("After safe `modify`:  " + updatedData);
    
        // 7. Demonstrate that the traversal safely handles missing paths
        var dataWithoutUser = new JsonObject(Map.of("metadata", new JsonString("test")));
        JsonObject safeUpdate = Traversals.modify(userNameTraversal, String::toUpperCase, dataWithoutUser);
        System.out.println("Safe update on missing path: " + safeUpdate);
    
        System.out.println("Original is unchanged: " + data);
        System.out.println("------------------------------------------");
    
        // 8. Demonstrate error-resistant operations
        System.out.println("--- Error-Resistant Operations ---");
    
        // Get all string values safely
        List&lt;String&gt; allStrings = List.of(
            new JsonString("hello"),
            new JsonNumber(42),
            new JsonString("world"),
            new JsonBoolean(true)
        ).stream()
        .map(jsonStringPrism::getOptional)
        .filter(Optional::isPresent)
        .map(Optional::get)
        .map(JsonString::value)
        .toList();
    
        System.out.println("Extracted strings only: " + allStrings);
    }
}
</code></pre>
<p><strong>Expected Output:</strong></p>
<pre><code>Original Data: JsonObject[fields={userLogin=JsonObject[fields={name=JsonString[value=Alice], age=JsonNumber[value=30.0], active=JsonBoolean[value=true]}], metadata=JsonObject[fields={version=JsonString[value=1.0]}]}]
------------------------------------------
--- Individual Prism Operations ---
User object: Optional[JsonObject[fields={name=JsonString[value=Alice], age=JsonNumber[value=30.0], active=JsonBoolean[value=true]}]]
Name as number (should be empty): Optional.empty
Built new string: JsonString[value=Bob]
------------------------------------------
--- Composed Traversal Operations ---
After safe `modify`:  JsonObject[fields={userLogin=JsonObject[fields={name=JsonString[value=ALICE], age=JsonNumber[value=30.0], active=JsonBoolean[value=true]}], metadata=JsonObject[fields={version=JsonString[value=1.0]}]}]
Safe update on missing path: JsonObject[fields={metadata=JsonString[value=test]}]
Original is unchanged: JsonObject[fields={userLogin=JsonObject[fields={name=JsonString[value=Alice], age=JsonNumber[value=30.0], active=JsonBoolean[value=true]}], metadata=JsonObject[fields={version=JsonString[value=1.0]}]}]
------------------------------------------
--- Error-Resistant Operations ---
Extracted strings only: [hello, world]
</code></pre>
<hr />
<h2 id="prism-convenience-methods"><a class="header" href="#prism-convenience-methods">Prism Convenience Methods</a></h2>
<h3 id="streamlined-operations-for-common-patterns"><a class="header" href="#streamlined-operations-for-common-patterns"><em>Streamlined Operations for Common Patterns</em></a></h3>
<p>Whilst <code>getOptional()</code> and <code>build()</code> are the core operations, the <code>Prism</code> interface provides several convenience methods that make everyday tasks more ergonomic and expressive.</p>
<p><strong>Quick Reference:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Purpose</th><th>Returns</th></tr></thead><tbody>
<tr><td><code>matches(S source)</code></td><td>Check if prism matches without extraction</td><td><code>boolean</code></td></tr>
<tr><td><code>getOrElse(A default, S source)</code></td><td>Extract value or return default</td><td><code>A</code></td></tr>
<tr><td><code>mapOptional(Function&lt;A, B&gt; f, S source)</code></td><td>Transform matched value</td><td><code>Optional&lt;B&gt;</code></td></tr>
<tr><td><code>modify(Function&lt;A, A&gt; f, S source)</code></td><td>Modify if matches, else return original</td><td><code>S</code></td></tr>
<tr><td><code>modifyWhen(Predicate&lt;A&gt; p, Function&lt;A, A&gt; f, S source)</code></td><td>Modify only when predicate satisfied</td><td><code>S</code></td></tr>
<tr><td><code>setWhen(Predicate&lt;A&gt; p, A value, S source)</code></td><td>Set only when predicate satisfied</td><td><code>S</code></td></tr>
<tr><td><code>orElse(Prism&lt;S, A&gt; other)</code></td><td>Try this prism, then fallback</td><td><code>Prism&lt;S, A&gt;</code></td></tr>
</tbody></table>
</div>
<h3 id="type-checking-with-matches"><a class="header" href="#type-checking-with-matches">Type Checking with <code>matches()</code></a></h3>
<p>The <code>matches()</code> method provides a clean alternative to <code>getOptional(source).isPresent()</code>:</p>
<pre><code class="language-java">Prism&lt;JsonValue, JsonString&gt; stringPrism = JsonValuePrisms.jsonString();

// Clear, declarative type checking
if (stringPrism.matches(value)) {
    // Process as string
}

// Useful in streams and filters
List&lt;JsonValue&gt; onlyStrings = values.stream()
    .filter(stringPrism::matches)
    .collect(Collectors.toList());
</code></pre>
<p><strong>Real-World Example</strong>: Filtering polymorphic domain events:</p>
<pre><code class="language-java">@GeneratePrisms
sealed interface DomainEvent permits UserEvent, OrderEvent, PaymentEvent {}

// Business logic: process only payment events
public void processPayments(List&lt;DomainEvent&gt; events) {
    Prism&lt;DomainEvent, PaymentEvent&gt; paymentPrism =
        DomainEventPrisms.paymentEvent();

    long paymentCount = events.stream()
        .filter(paymentPrism::matches)
        .count();

    logger.info("Processing {} payment events", paymentCount);

    events.stream()
        .filter(paymentPrism::matches)
        .map(paymentPrism::getOptional)
        .flatMap(Optional::stream)
        .forEach(this::processPayment);
}
</code></pre>
<h3 id="default-values-with-getorelse"><a class="header" href="#default-values-with-getorelse">Default Values with <code>getOrElse()</code></a></h3>
<p>When you need fallback values, <code>getOrElse()</code> is more concise than <code>getOptional().orElse()</code>:</p>
<pre><code class="language-java">Prism&lt;ApiResponse, SuccessResponse&gt; successPrism =
    ApiResponsePrisms.successResponse();

// Extract success data or use default
String data = successPrism.getOrElse(
    new SuccessResponse("fallback", 200),
    response
).data();

// Particularly useful for configuration
Config config = Prisms.some()
    .getOrElse(Config.DEFAULT, optionalConfig);
</code></pre>
<p><strong>Real-World Example</strong>: Parsing user input with graceful degradation:</p>
<pre><code class="language-java">@GeneratePrisms
sealed interface ParsedValue permits IntValue, StringValue, InvalidValue {}

public int parseUserQuantity(String input, int defaultQty) {
    ParsedValue parsed = parseInput(input);

    Prism&lt;ParsedValue, IntValue&gt; intPrism = ParsedValuePrisms.intValue();

    // Extract integer or use sensible default
    return intPrism.getOrElse(
        new IntValue(defaultQty),
        parsed
    ).value();
}

// Application settings with fallback
public DatabaseConfig getDatabaseConfig(ApplicationConfig config) {
    Prism&lt;ConfigSource, DatabaseConfig&gt; dbConfigPrism =
        ConfigSourcePrisms.databaseConfig();

    return dbConfigPrism.getOrElse(
        DatabaseConfig.DEFAULT_POSTGRES,
        config.source()
    );
}
</code></pre>
<h3 id="transforming-matches-with-mapoptional"><a class="header" href="#transforming-matches-with-mapoptional">Transforming Matches with <code>mapOptional()</code></a></h3>
<p>The <code>mapOptional()</code> method transforms matched values without building them back into the source type:</p>
<pre><code class="language-java">Prism&lt;JsonValue, JsonNumber&gt; numberPrism = JsonValuePrisms.jsonNumber();

// Extract and transform in one operation
Optional&lt;String&gt; formatted = numberPrism.mapOptional(
    num -&gt; String.format("%.2f", num.value()),
    jsonValue
);

// Compose transformations
Optional&lt;Boolean&gt; isLarge = numberPrism.mapOptional(
    num -&gt; num.value() &gt; 1000,
    jsonValue
);
</code></pre>
<p><strong>Real-World Example</strong>: ETL data transformation pipeline:</p>
<pre><code class="language-java">@GeneratePrisms
sealed interface SourceData permits CsvRow, JsonObject, XmlNode {}

public List&lt;CustomerRecord&gt; extractCustomers(List&lt;SourceData&gt; sources) {
    Prism&lt;SourceData, CsvRow&gt; csvPrism = SourceDataPrisms.csvRow();

    return sources.stream()
        .map(source -&gt; csvPrism.mapOptional(
            csv -&gt; new CustomerRecord(
                csv.column("customer_id"),
                csv.column("name"),
                csv.column("email")
            ),
            source
        ))
        .flatMap(Optional::stream)
        .collect(Collectors.toList());
}

// Extract business metrics from polymorphic events
public Optional&lt;BigDecimal&gt; extractRevenue(DomainEvent event) {
    Prism&lt;DomainEvent, OrderCompleted&gt; orderPrism =
        DomainEventPrisms.orderCompleted();

    return orderPrism.mapOptional(
        order -&gt; order.lineItems().stream()
            .map(LineItem::totalPrice)
            .reduce(BigDecimal.ZERO, BigDecimal::add),
        event
    );
}
</code></pre>
<h3 id="simple-modifications-with-modify"><a class="header" href="#simple-modifications-with-modify">Simple Modifications with <code>modify()</code></a></h3>
<p>Instead of manually calling <code>getOptional().map(f).map(build)</code>, use <code>modify()</code>:</p>
<pre><code class="language-java">Prism&lt;JsonValue, JsonString&gt; stringPrism = JsonValuePrisms.jsonString();

// Clean modification
JsonValue uppercased = stringPrism.modify(
    str -&gt; new JsonString(str.value().toUpperCase()),
    jsonValue
);

// Verbose alternative
JsonValue verboseResult = stringPrism.getOptional(jsonValue)
    .map(str -&gt; new JsonString(str.value().toUpperCase()))
    .map(stringPrism::build)
    .orElse(jsonValue);
</code></pre>
<p>If the prism doesn't match, <code>modify()</code> safely returns the original structure unchanged.</p>
<h3 id="conditional-operations-with-modifywhen-and-setwhen"><a class="header" href="#conditional-operations-with-modifywhen-and-setwhen">Conditional Operations with <code>modifyWhen()</code> and <code>setWhen()</code></a></h3>
<p>These methods combine matching with predicate-based filtering:</p>
<pre><code class="language-java">Prism&lt;ConfigValue, StringConfig&gt; stringConfig =
    ConfigValuePrisms.stringConfig();

// Only modify non-empty strings
ConfigValue sanitised = stringConfig.modifyWhen(
    str -&gt; !str.value().isEmpty(),
    str -&gt; new StringConfig(str.value().trim()),
    configValue
);

// Only update if validation passes
ConfigValue validated = stringConfig.setWhen(
    str -&gt; str.value().length() &lt;= 255,
    new StringConfig("validated"),
    configValue
);
</code></pre>
<p><strong>Real-World Example</strong>: Business rule enforcement in order processing:</p>
<pre><code class="language-java">@GeneratePrisms
sealed interface OrderStatus permits Draft, Submitted, Approved, Rejected {}

public class OrderProcessor {
    private static final Prism&lt;OrderStatus, Submitted&gt; SUBMITTED =
        OrderStatusPrisms.submitted();

    // Only approve orders above minimum value
    public OrderStatus approveIfEligible(
        OrderStatus status,
        BigDecimal orderValue,
        BigDecimal minValue
    ) {
        return SUBMITTED.setWhen(
            submitted -&gt; orderValue.compareTo(minValue) &gt;= 0,
            new Approved(Instant.now(), "AUTO_APPROVED"),
            status
        );
    }

    // Apply discount only to high-value draft orders
    public OrderStatus applyVipDiscount(OrderStatus status, Order order) {
        Prism&lt;OrderStatus, Draft&gt; draftPrism = OrderStatusPrisms.draft();

        return draftPrism.modifyWhen(
            draft -&gt; order.totalValue().compareTo(VIP_THRESHOLD) &gt; 0,
            draft -&gt; draft.withDiscount(VIP_DISCOUNT_RATE),
            status
        );
    }
}
</code></pre>
<p><strong>Use Cases:</strong></p>
<ul>
<li><strong>Conditional validation</strong>: Update only if current value meets criteria</li>
<li><strong>Guarded transformations</strong>: Apply changes only to valid states</li>
<li><strong>Business rules</strong>: Enforce constraints during updates</li>
<li><strong>Workflow automation</strong>: Apply state transitions based on business logic</li>
</ul>
<h3 id="fallback-matching-with-orelse"><a class="header" href="#fallback-matching-with-orelse">Fallback Matching with <code>orElse()</code></a></h3>
<p>The <code>orElse()</code> method chains prisms to try multiple matches:</p>
<pre><code class="language-java">Prism&lt;JsonValue, JsonNumber&gt; intPrism = JsonValuePrisms.jsonInt();
Prism&lt;JsonValue, JsonNumber&gt; doublePrism = JsonValuePrisms.jsonDouble();

// Try int first, fall back to double
Prism&lt;JsonValue, JsonNumber&gt; anyNumber = intPrism.orElse(doublePrism);

Optional&lt;JsonNumber&gt; result = anyNumber.getOptional(jsonValue);
// Matches either integer or double JSON values

// Building always uses the first prism's constructor
JsonValue built = anyNumber.build(new JsonNumber(42)); // Uses intPrism.build
</code></pre>
<p><strong>Real-World Example</strong>: Handling multiple error types in API responses:</p>
<pre><code class="language-java">Prism&lt;ApiResponse, String&gt; errorMessage =
    ApiResponsePrisms.validationError()
        .andThen(ValidationErrorLenses.message())
        .orElse(
            ApiResponsePrisms.serverError()
                .andThen(ServerErrorLenses.message())
        );

// Extracts error message from either error type
Optional&lt;String&gt; message = errorMessage.getOptional(response);
</code></pre>
<div id="admonition-when-to-use-convenience-methods" class="admonition admonish-tip" role="note" aria-labelledby="admonition-when-to-use-convenience-methods-title">
<div class="admonition-title">
<div id="admonition-when-to-use-convenience-methods-title">
<p>When to Use Convenience Methods</p>
</div>
<a class="admonition-anchor-link" href="optics/prisms.html#admonition-when-to-use-convenience-methods"></a>
</div>
<div>
<ul>
<li><strong>matches()</strong>: Type guards, stream filters, conditional logic</li>
<li><strong>getOrElse()</strong>: Configuration, default values, fallback data</li>
<li><strong>mapOptional()</strong>: Projections, transformations without reconstruction</li>
<li><strong>modify()</strong>: Simple transformations of matching cases</li>
<li><strong>modifyWhen()</strong>: Conditional updates based on current state</li>
<li><strong>setWhen()</strong>: Guarded updates with validation</li>
<li><strong>orElse()</strong>: Handling multiple variants, fallback strategies</li>
</ul>
</div>
</div>
<hr />
<h2 id="common-prism-patterns-with-the-prisms-utility"><a class="header" href="#common-prism-patterns-with-the-prisms-utility">Common Prism Patterns with the Prisms Utility</a></h2>
<h3 id="ready-made-prisms-for-standard-types"><a class="header" href="#ready-made-prisms-for-standard-types"><em>Ready-Made Prisms for Standard Types</em></a></h3>
<p>The <code>Prisms</code> utility class (in <code>org.higherkindedj.optics.util</code>) provides factory methods for common prism patterns, saving you from writing boilerplate for standard Java types.</p>
<p><strong>Quick Reference:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Factory Method</th><th>Type Signature</th><th>Use Case</th></tr></thead><tbody>
<tr><td><code>some()</code></td><td><code>Prism&lt;Optional&lt;A&gt;, A&gt;</code></td><td>Extract present Optional values</td></tr>
<tr><td><code>left()</code></td><td><code>Prism&lt;Either&lt;L, R&gt;, L&gt;</code></td><td>Focus on Left case</td></tr>
<tr><td><code>right()</code></td><td><code>Prism&lt;Either&lt;L, R&gt;, R&gt;</code></td><td>Focus on Right case</td></tr>
<tr><td><code>only(A value)</code></td><td><code>Prism&lt;A, Unit&gt;</code></td><td>Match specific value</td></tr>
<tr><td><code>notNull()</code></td><td><code>Prism&lt;@Nullable A, A&gt;</code></td><td>Filter null values</td></tr>
<tr><td><code>instanceOf(Class&lt;A&gt;)</code></td><td><code>Prism&lt;S, A&gt;</code></td><td>Safe type-based casting</td></tr>
<tr><td><code>listHead()</code></td><td><code>Prism&lt;List&lt;A&gt;, A&gt;</code></td><td>First element (if exists)</td></tr>
<tr><td><code>listLast()</code></td><td><code>Prism&lt;List&lt;A&gt;, A&gt;</code></td><td>Last element (if exists)</td></tr>
<tr><td><code>listAt(int)</code></td><td><code>Prism&lt;List&lt;A&gt;, A&gt;</code></td><td>Element at index (read-only)</td></tr>
</tbody></table>
</div>
<h3 id="working-with-optional-prismssome"><a class="header" href="#working-with-optional-prismssome">Working with Optional: <code>Prisms.some()</code></a></h3>
<pre><code class="language-java">import org.higherkindedj.optics.util.Prisms;

Prism&lt;Optional&lt;String&gt;, String&gt; somePrism = Prisms.some();

Optional&lt;String&gt; present = Optional.of("hello");
Optional&lt;String&gt; value = somePrism.getOptional(present); // Optional.of("hello")

Optional&lt;String&gt; empty = Optional.empty();
Optional&lt;String&gt; noMatch = somePrism.getOptional(empty); // Optional.empty()

// Useful for nested Optionals
Optional&lt;Optional&lt;Config&gt;&gt; nestedConfig = loadConfig();
Optional&lt;Config&gt; flattened = somePrism.getOptional(nestedConfig)
    .flatMap(Function.identity());
</code></pre>
<h3 id="either-case-handling-prismsleft-and-prismsright"><a class="header" href="#either-case-handling-prismsleft-and-prismsright">Either Case Handling: <code>Prisms.left()</code> and <code>Prisms.right()</code></a></h3>
<pre><code class="language-java">Prism&lt;Either&lt;String, Integer&gt;, String&gt; leftPrism = Prisms.left();
Prism&lt;Either&lt;String, Integer&gt;, Integer&gt; rightPrism = Prisms.right();

Either&lt;String, Integer&gt; error = Either.left("Failed");
Optional&lt;String&gt; errorMsg = leftPrism.getOptional(error); // Optional.of("Failed")
Optional&lt;Integer&gt; noValue = rightPrism.getOptional(error); // Optional.empty()

// Compose with lenses for deep access
record ValidationError(String code, String message) {}
Lens&lt;ValidationError, String&gt; messageLens = ValidationErrorLenses.message();

Prism&lt;Either&lt;ValidationError, Data&gt;, String&gt; errorMessage =
    Prisms.&lt;ValidationError, Data&gt;left()
        .andThen(messageLens);

Either&lt;ValidationError, Data&gt; result = validate(data);
Optional&lt;String&gt; msg = errorMessage.getOptional(result);
</code></pre>
<h3 id="sentinel-values-prismsonly"><a class="header" href="#sentinel-values-prismsonly">Sentinel Values: <code>Prisms.only()</code></a></h3>
<p>Perfect for matching specific constant values:</p>
<pre><code class="language-java">Prism&lt;String, Unit&gt; httpOkPrism = Prisms.only("200 OK");

// Check for specific status
if (httpOkPrism.matches(statusCode)) {
    // Handle success case
}

// Filter for specific values
List&lt;String&gt; onlyErrors = statusCodes.stream()
    .filter(Prisms.only("500 ERROR")::matches)
    .collect(Collectors.toList());

// Null sentinel handling
Prism&lt;String, Unit&gt; nullPrism = Prisms.only(null);
boolean isNull = nullPrism.matches(value);
</code></pre>
<h3 id="null-safety-prismsnotnull"><a class="header" href="#null-safety-prismsnotnull">Null Safety: <code>Prisms.notNull()</code></a></h3>
<pre><code class="language-java">Prism&lt;String, String&gt; notNullPrism = Prisms.notNull();

// Safe extraction
@Nullable String nullable = getDatabaseValue();
Optional&lt;String&gt; safe = notNullPrism.getOptional(nullable);

// Compose to filter null values in pipelines
Traversal&lt;List&lt;String&gt;, String&gt; nonNullStrings =
    Traversals.&lt;String&gt;forList()
        .andThen(Prisms.&lt;String&gt;notNull().asTraversal());

List&lt;@Nullable String&gt; mixedList = List.of("hello", null, "world", null);
List&lt;String&gt; filtered = Traversals.getAll(nonNullStrings, mixedList);
// Result: ["hello", "world"]
</code></pre>
<h3 id="type-safe-casting-prismsinstanceof"><a class="header" href="#type-safe-casting-prismsinstanceof">Type-Safe Casting: <code>Prisms.instanceOf()</code></a></h3>
<p>Elegant alternative to <code>instanceof</code> checks in type hierarchies:</p>
<pre><code class="language-java">sealed interface Animal permits Dog, Cat, Bird {}
record Dog(String name, String breed) implements Animal {}
record Cat(String name, int lives) implements Animal {}
record Bird(String name, boolean canFly) implements Animal {}

Prism&lt;Animal, Dog&gt; dogPrism = Prisms.instanceOf(Dog.class);

Animal animal = new Dog("Buddy", "Labrador");
Optional&lt;Dog&gt; maybeDog = dogPrism.getOptional(animal); // Optional.of(Dog(...))

// Compose with lenses for deep access
Lens&lt;Dog, String&gt; breedLens = DogLenses.breed();
Traversal&lt;Animal, String&gt; dogBreed =
    dogPrism.asTraversal().andThen(breedLens.asTraversal());

List&lt;Animal&gt; animals = List.of(
    new Dog("Rex", "German Shepherd"),
    new Cat("Whiskers", 9),
    new Dog("Max", "Beagle")
);

List&lt;String&gt; breeds = Traversals.getAll(
    Traversals.&lt;Animal&gt;forList().andThen(dogBreed),
    animals
);
// Result: ["German Shepherd", "Beagle"]
</code></pre>
<h3 id="collection-element-access"><a class="header" href="#collection-element-access">Collection Element Access</a></h3>
<pre><code class="language-java">// First element (if list is non-empty)
Prism&lt;List&lt;String&gt;, String&gt; headPrism = Prisms.listHead();
List&lt;String&gt; names = List.of("Alice", "Bob", "Charlie");
Optional&lt;String&gt; first = headPrism.getOptional(names); // Optional.of("Alice")

// Last element
Prism&lt;List&lt;String&gt;, String&gt; lastPrism = Prisms.listLast();
Optional&lt;String&gt; last = lastPrism.getOptional(names); // Optional.of("Charlie")

// Element at specific index (read-only for queries)
Prism&lt;List&lt;String&gt;, String&gt; secondPrism = Prisms.listAt(1);
Optional&lt;String&gt; second = secondPrism.getOptional(names); // Optional.of("Bob")

// Safe access patterns
String firstOrDefault = headPrism.getOrElse("Unknown", names);
boolean hasList = headPrism.matches(names);
</code></pre>
<div id="admonition-list-prism-limitations" class="admonition admonish-warning" role="note" aria-labelledby="admonition-list-prism-limitations-title">
<div class="admonition-title">
<div id="admonition-list-prism-limitations-title">
<p>List Prism Limitations</p>
</div>
<a class="admonition-anchor-link" href="optics/prisms.html#admonition-list-prism-limitations"></a>
</div>
<div>
<p>The <code>listHead()</code> and <code>listLast()</code> prisms have limited <code>build()</code> operations: they create singleton lists. The <code>listAt(int)</code> prism throws <code>UnsupportedOperationException</code> on <code>build()</code> since there's no meaningful way to construct a complete list from a single indexed element.</p>
<p><strong>Use these prisms for:</strong></p>
<ul>
<li>Safe element extraction</li>
<li>Conditional checks (with <code>matches()</code>)</li>
<li>Query operations (with <code>getOptional()</code>)</li>
</ul>
<p><strong>For list modification</strong>, use <code>Traversal</code> or <code>Lens</code> instead:</p>
<pre><code class="language-java">// ✅ For modifications, use proper traversals
Lens&lt;List&lt;String&gt;, String&gt; firstLens = listFirstElementLens();
List&lt;String&gt; updated = firstLens.modify(String::toUpperCase, names);
</code></pre>
</div>
</div>
<h3 id="composing-utility-prisms"><a class="header" href="#composing-utility-prisms">Composing Utility Prisms</a></h3>
<p>The real power emerges when composing these utility prisms with your domain optics:</p>
<pre><code class="language-java">record Config(Optional&lt;Either&lt;String, DatabaseSettings&gt;&gt; database) {}
record DatabaseSettings(String host, int port) {}

// Build a path through Optional -&gt; Either -&gt; Settings -&gt; host
Prism&lt;Config, String&gt; databaseHost =
    ConfigLenses.database()                    // Lens&lt;Config, Optional&lt;Either&lt;...&gt;&gt;&gt;
        .asTraversal()
        .andThen(Prisms.some().asTraversal())  // -&gt; Either&lt;String, DatabaseSettings&gt;
        .andThen(Prisms.right().asTraversal()) // -&gt; DatabaseSettings
        .andThen(DatabaseSettingsLenses.host().asTraversal()); // -&gt; String

Config config = loadConfig();
Optional&lt;String&gt; host = Traversals.getAll(databaseHost, config)
    .stream().findFirst();
</code></pre>
<div id="admonition-performance-considerations" class="admonition admonish-tip" role="note" aria-labelledby="admonition-performance-considerations-title">
<div class="admonition-title">
<div id="admonition-performance-considerations-title">
<p>Performance Considerations</p>
</div>
<a class="admonition-anchor-link" href="optics/prisms.html#admonition-performance-considerations"></a>
</div>
<div>
<p>Utility prisms are lightweight and stateless; they're safe to create on-demand or cache as constants:</p>
<pre><code class="language-java">public class AppPrisms {
    public static final Prism&lt;Optional&lt;User&gt;, User&gt; SOME_USER = Prisms.some();
    public static final Prism&lt;Response, SuccessResponse&gt; SUCCESS =
        Prisms.instanceOf(SuccessResponse.class);
}
</code></pre>
</div>
</div>
<hr />
<h2 id="why-prisms-are-essential"><a class="header" href="#why-prisms-are-essential">Why Prisms are Essential</a></h2>
<p><code>Lens</code> handles the "what" and <code>Prism</code> handles the "what if." Together, they allow you to model and operate on virtually any immutable data structure you can design. Prisms are essential for:</p>
<ul>
<li><strong>Safety</strong>: Eliminating <code>instanceof</code> checks and unsafe casts.</li>
<li><strong>Clarity</strong>: Expressing failable focus in a clean, functional way.</li>
<li><strong>Composability</strong>: Combining checks for different data shapes into a single, reusable optic.</li>
<li><strong>Maintainability</strong>: Creating type-safe paths that won't break when data structures evolve.</li>
</ul>
<p>By adding Prisms to your toolkit, you can write even more robust, declarative, and maintainable code that gracefully handles the complexity of real-world data structures.</p>
<div id="admonition-ready-for-more" class="admonition admonish-tip" role="note" aria-labelledby="admonition-ready-for-more-title">
<div class="admonition-title">
<div id="admonition-ready-for-more-title">
<p>Ready for More?</p>
</div>
<a class="admonition-anchor-link" href="optics/prisms.html#admonition-ready-for-more"></a>
</div>
<div>
<p>Once you're comfortable with these prism fundamentals, explore <a href="optics/advanced_prism_patterns.html">Advanced Prism Patterns</a> for production-ready patterns including:</p>
<ul>
<li>Configuration management with layered prism composition</li>
<li>API response handling with type-safe error recovery</li>
<li>Data validation pipelines and event processing systems</li>
<li>State machine implementations and plugin architectures</li>
<li>Performance optimisation and testing strategies</li>
</ul>
</div>
</div>
<div id="admonition-for-comprehension-integration" class="admonition admonish-tip" role="note" aria-labelledby="admonition-for-comprehension-integration-title">
<div class="admonition-title">
<div id="admonition-for-comprehension-integration-title">
<p>For Comprehension Integration</p>
</div>
<a class="admonition-anchor-link" href="optics/prisms.html#admonition-for-comprehension-integration"></a>
</div>
<div>
<p>Prisms integrate with For comprehensions via the <code>match()</code> operation, which provides prism-based pattern matching with short-circuit semantics. When the prism match fails, the computation short-circuits using the monad's zero value (empty list, Nothing, etc.). See <a href="optics/../functional/for_comprehension.html#pattern-matching-with-match">For Comprehensions: Pattern Matching with match()</a>.</p>
</div>
</div>
<div id="admonition-hands-on-learning" class="admonition admonish-info" role="note" aria-labelledby="admonition-hands-on-learning-title">
<div class="admonition-title">
<div id="admonition-hands-on-learning-title">
<p>Hands-On Learning</p>
</div>
<a class="admonition-anchor-link" href="optics/prisms.html#admonition-hands-on-learning"></a>
</div>
<div>
<p>Practice prism basics in <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/optics/Tutorial03_PrismBasics.java">Tutorial 03: Prism Basics</a> (9 exercises, ~12 minutes).</p>
</div>
</div>
<hr />
<div id="admonition-further-reading" class="admonition admonish-tip" role="note" aria-labelledby="admonition-further-reading-title">
<div class="admonition-title">
<div id="admonition-further-reading-title">
<p>Further Reading</p>
</div>
<a class="admonition-anchor-link" href="optics/prisms.html#admonition-further-reading"></a>
</div>
<div>
<ul>
<li><strong>Monocle</strong>: <a href="https://www.optics.dev/Monocle/">Scala Optics Library</a> - Production-ready Scala optics with extensive examples</li>
<li><strong>Haskell Lens</strong>: <a href="https://hackage.haskell.org/package/lens">Canonical Reference</a> - The original comprehensive optics library</li>
<li><strong>Lens Tutorial</strong>: <a href="https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial">A Little Lens Starter Tutorial</a> - Beginner-friendly introduction</li>
</ul>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="optics/lenses.html">Lenses: Working with Product Types</a>
<strong>Next:</strong> <a href="optics/affine.html">Affines: Working with Optional Fields</a> | <a href="optics/advanced_prism_patterns.html">Advanced Prism Patterns</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="affines-a-practical-guide"><a class="header" href="#affines-a-practical-guide">Affines: A Practical Guide</a></h1>
<h2 id="working-with-optional-fields"><a class="header" href="#working-with-optional-fields"><em>Working with Optional Fields</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="optics/affine.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to safely work with optional fields and nullable properties</li>
<li>The difference between Affine, Lens, and Prism</li>
<li>Why <code>Lens.andThen(Prism)</code> produces an Affine, not a Traversal</li>
<li>Composing affines with other optics for deep optional access</li>
<li>Handling zero-or-one element focus without boilerplate</li>
<li>When to use Affines vs Prisms vs Lenses</li>
</ul>
</div>
</div>
<div id="admonition-hands-on-practice" class="admonition admonish-note" role="note" aria-labelledby="admonition-hands-on-practice-title">
<div class="admonition-title">
<div id="admonition-hands-on-practice-title">
<p>Hands On Practice</p>
</div>
<a class="admonition-anchor-link" href="optics/affine.html#admonition-hands-on-practice"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/optics/Tutorial04_AffineBasics.java">Tutorial04_AffineBasics.java</a></p>
</div>
</div>
<div id="admonition-example-code" class="admonition admonish-note" role="note" aria-labelledby="admonition-example-code-title">
<div class="admonition-title">
<div id="admonition-example-code-title">
<p>Example Code</p>
</div>
<a class="admonition-anchor-link" href="optics/affine.html#admonition-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/AffineUsageExample.java">AffineUsageExample</a></p>
</div>
</div>
<p>We've seen how a <strong>Lens</strong> focuses on exactly one value that is guaranteed to exist, and how a <strong>Prism</strong> focuses on a value that may or may not exist depending on the variant.</p>
<p>But what about fields that are <em>sometimes</em> there? Optional fields in records, nullable properties in legacy APIs, or the result of composing a Lens with a Prism? This is the domain of the <strong>Affine</strong>.</p>
<hr />
<h2 id="the-scenario-optional-fields-in-records"><a class="header" href="#the-scenario-optional-fields-in-records">The Scenario: Optional Fields in Records</a></h2>
<p>Modern Java applications frequently use <code>Optional&lt;T&gt;</code> to represent values that may be absent. Consider a user profile with optional contact information:</p>
<pre><code class="language-java">record UserProfile(String username, Optional&lt;ContactInfo&gt; contact) {}
record ContactInfo(String email, Optional&lt;String&gt; phone) {}
</code></pre>
<p><strong>Our Goal:</strong> We need to safely access and update the phone number, which is doubly optional: the contact info might not exist, and even if it does, the phone number might be absent.</p>
<hr />
<h2 id="think-of-affines-like"><a class="header" href="#think-of-affines-like">Think of Affines Like...</a></h2>
<ul>
<li><strong>A Lens with uncertainty</strong>: Gets exactly one value <em>if</em> it exists</li>
<li><strong>A Prism without construction</strong>: Can update but not build from scratch</li>
<li><strong>An optional field accessor</strong>: Perfect for <code>Optional&lt;T&gt;</code> fields</li>
<li><strong>A Lens + Prism composition</strong>: The natural result of combining them</li>
</ul>
<hr />
<h2 id="understanding-the-optic-hierarchy"><a class="header" href="#understanding-the-optic-hierarchy">Understanding the Optic Hierarchy</a></h2>
<p>An Affine sits between Lens and Traversal in the optic hierarchy:</p>
<pre><code>         Iso
        /   \
     Lens   Prism
        \   /
        Affine
          |
       Traversal
</code></pre>
<p><strong>Key insight:</strong> When you compose a Lens (exactly one element) with a Prism (zero or one element), the result focuses on zero or one element, which is an Affine.</p>
<div class="table-wrapper"><table><thead><tr><th>Optic</th><th>Focus</th><th>Get</th><th>Set</th></tr></thead><tbody>
<tr><td><strong>Lens</strong></td><td>Exactly one</td><td>Always succeeds</td><td>Always succeeds</td></tr>
<tr><td><strong>Prism</strong></td><td>Zero or one</td><td>May fail</td><td>Can build from scratch</td></tr>
<tr><td><strong>Affine</strong></td><td>Zero or one</td><td>May fail</td><td>Requires existing structure</td></tr>
<tr><td><strong>Traversal</strong></td><td>Zero or more</td><td>Multiple values</td><td>Multiple values</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="a-step-by-step-walkthrough-2"><a class="header" href="#a-step-by-step-walkthrough-2">A Step-by-Step Walkthrough</a></h2>
<h3 id="step-1-creating-an-affine-manually"><a class="header" href="#step-1-creating-an-affine-manually">Step 1: Creating an Affine Manually</a></h3>
<p>An Affine is defined by two operations:</p>
<ul>
<li><strong><code>getOptional(source)</code></strong>: Returns <code>Optional&lt;A&gt;</code> containing the focus if present</li>
<li><strong><code>set(value, source)</code></strong>: Returns a new source with the focus updated</li>
</ul>
<pre><code class="language-java">import org.higherkindedj.optics.Affine;
import java.util.Optional;

// Affine for accessing the value inside an Optional field
Affine&lt;Optional&lt;String&gt;, String&gt; someAffine = Affine.of(
    Function.identity(),                    // getOptional: Optional&lt;String&gt; -&gt; Optional&lt;String&gt;
    (opt, value) -&gt; Optional.of(value)      // set: always wrap in Optional.of
);

// Usage
Optional&lt;String&gt; present = Optional.of("hello");
Optional&lt;String&gt; result = someAffine.getOptional(present);  // Optional.of("hello")

Optional&lt;String&gt; empty = Optional.empty();
Optional&lt;String&gt; noMatch = someAffine.getOptional(empty);   // Optional.empty()

// Setting always wraps the value
Optional&lt;String&gt; updated = someAffine.set("world", empty);  // Optional.of("world")
</code></pre>
<h3 id="step-2-using-the-affines-utility-class"><a class="header" href="#step-2-using-the-affines-utility-class">Step 2: Using the Affines Utility Class</a></h3>
<p>The <code>Affines</code> utility class provides ready-made affines for common patterns:</p>
<pre><code class="language-java">import org.higherkindedj.optics.util.Affines;

// For Optional&lt;T&gt; fields
Affine&lt;Optional&lt;String&gt;, String&gt; someAffine = Affines.some();

// For Maybe&lt;T&gt; (higher-kinded-j's Maybe type)
Affine&lt;Maybe&lt;String&gt;, String&gt; justAffine = Affines.just();

// For nullable fields (legacy code)
Affine&lt;@Nullable String, String&gt; nullableAffine = Affines.nullable();

// For list element access
Affine&lt;List&lt;String&gt;, String&gt; headAffine = Affines.listHead();
Affine&lt;List&lt;String&gt;, String&gt; lastAffine = Affines.listLast();
Affine&lt;List&lt;String&gt;, String&gt; thirdAffine = Affines.listAt(2);
</code></pre>
<h3 id="step-3-affine-from-lens--prism-composition"><a class="header" href="#step-3-affine-from-lens--prism-composition">Step 3: Affine from Lens + Prism Composition</a></h3>
<p>The most common way to obtain an Affine is through composition:</p>
<pre><code class="language-java">import org.higherkindedj.optics.Lens;
import org.higherkindedj.optics.Prism;
import org.higherkindedj.optics.util.Prisms;

// Domain model
record Config(Optional&lt;DatabaseSettings&gt; database) {}
record DatabaseSettings(String host, int port) {}

// Lens to the Optional field
Lens&lt;Config, Optional&lt;DatabaseSettings&gt;&gt; databaseLens =
    Lens.of(Config::database, (c, db) -&gt; new Config(db));

// Prism to extract from Optional
Prism&lt;Optional&lt;DatabaseSettings&gt;, DatabaseSettings&gt; somePrism = Prisms.some();

// Composition: Lens &gt;&gt;&gt; Prism = Affine
Affine&lt;Config, DatabaseSettings&gt; databaseAffine =
    databaseLens.andThen(somePrism);

// Usage
Config config1 = new Config(Optional.of(new DatabaseSettings("localhost", 5432)));
Optional&lt;DatabaseSettings&gt; result1 = databaseAffine.getOptional(config1);
// result1 = Optional[DatabaseSettings[host=localhost, port=5432]]

Config config2 = new Config(Optional.empty());
Optional&lt;DatabaseSettings&gt; result2 = databaseAffine.getOptional(config2);
// result2 = Optional.empty()

// Setting through the affine
Config updated = databaseAffine.set(new DatabaseSettings("newhost", 3306), config2);
// updated = Config[database=Optional[DatabaseSettings[host=newhost, port=3306]]]
</code></pre>
<div id="admonition-why-affine-not-traversal" class="admonition admonish-tip" role="note" aria-labelledby="admonition-why-affine-not-traversal-title">
<div class="admonition-title">
<div id="admonition-why-affine-not-traversal-title">
<p>Why Affine, not Traversal?</p>
</div>
<a class="admonition-anchor-link" href="optics/affine.html#admonition-why-affine-not-traversal"></a>
</div>
<div>
<p>You might wonder why <code>Lens.andThen(Prism)</code> returns an Affine rather than a Traversal. The answer is precision:</p>
<ul>
<li><strong>Traversal</strong> focuses on <em>zero or more</em> elements</li>
<li><strong>Affine</strong> focuses on <em>exactly zero or one</em> element</li>
</ul>
<p>Since a Lens always provides one element and a Prism may match zero or one, the composition can never produce <em>more</em> than one element. Affine captures this constraint precisely, giving you stronger type guarantees.</p>
</div>
</div>
<hr />
<h2 id="affine-vs-prism-the-key-difference"><a class="header" href="#affine-vs-prism-the-key-difference">Affine vs Prism: The Key Difference</a></h2>
<p>Both Affine and Prism focus on zero-or-one elements, but they differ in one crucial way:</p>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Prism</th><th>Affine</th></tr></thead><tbody>
<tr><td><strong>getOptional</strong></td><td>✅ Yes</td><td>✅ Yes</td></tr>
<tr><td><strong>set</strong></td><td>✅ Yes</td><td>✅ Yes</td></tr>
<tr><td><strong>build</strong></td><td>✅ Yes (construct from part)</td><td>❌ No</td></tr>
</tbody></table>
</div>
<p>A <strong>Prism</strong> can <em>construct</em> a complete structure from just the focused part (via <code>build</code>). An <strong>Affine</strong> cannot; it can only <em>modify</em> an existing structure.</p>
<pre><code class="language-java">// Prism: can build from scratch
Prism&lt;Shape, Circle&gt; circlePrism = ...;
Shape newCircle = circlePrism.build(new Circle(5.0, "red"));  // Works!

// Affine: cannot build, only update
Affine&lt;Config, DatabaseSettings&gt; dbAffine = ...;
// No build() method available; must have an existing Config to work with
Config updated = dbAffine.set(newSettings, existingConfig);
</code></pre>
<p><strong>When to use which:</strong></p>
<ul>
<li>Use <strong>Prism</strong> for sum types where you can construct variants</li>
<li>Use <strong>Affine</strong> for optional fields in product types</li>
</ul>
<hr />
<h2 id="convenience-methods"><a class="header" href="#convenience-methods">Convenience Methods</a></h2>
<p>The <code>Affine</code> interface provides several convenience methods for common operations:</p>
<p><strong>Quick Reference:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Purpose</th><th>Returns</th></tr></thead><tbody>
<tr><td><code>matches(S source)</code></td><td>Check if affine focuses on a value</td><td><code>boolean</code></td></tr>
<tr><td><code>doesNotMatch(S source)</code></td><td>Check if affine has no focus</td><td><code>boolean</code></td></tr>
<tr><td><code>getOrElse(A default, S source)</code></td><td>Extract value or return default</td><td><code>A</code></td></tr>
<tr><td><code>mapOptional(Function&lt;A, B&gt; f, S source)</code></td><td>Transform focused value</td><td><code>Optional&lt;B&gt;</code></td></tr>
<tr><td><code>modify(Function&lt;A, A&gt; f, S source)</code></td><td>Modify if present, else return original</td><td><code>S</code></td></tr>
<tr><td><code>modifyWhen(Predicate&lt;A&gt; p, Function&lt;A, A&gt; f, S source)</code></td><td>Modify only when predicate satisfied</td><td><code>S</code></td></tr>
<tr><td><code>setWhen(Predicate&lt;A&gt; p, A value, S source)</code></td><td>Set only when predicate satisfied</td><td><code>S</code></td></tr>
<tr><td><code>remove(S source)</code></td><td>Remove the focused element (if supported)</td><td><code>S</code></td></tr>
</tbody></table>
</div>
<h3 id="checking-for-presence"><a class="header" href="#checking-for-presence">Checking for Presence</a></h3>
<pre><code class="language-java">Affine&lt;Optional&lt;String&gt;, String&gt; someAffine = Affines.some();

Optional&lt;String&gt; present = Optional.of("hello");
Optional&lt;String&gt; empty = Optional.empty();

// Using matches()
if (someAffine.matches(present)) {
    System.out.println("Value present");
}

// Using doesNotMatch()
if (someAffine.doesNotMatch(empty)) {
    System.out.println("No value");
}

// Useful in streams
List&lt;Optional&lt;String&gt;&gt; values = List.of(
    Optional.of("a"),
    Optional.empty(),
    Optional.of("b")
);

long presentCount = values.stream()
    .filter(someAffine::matches)
    .count();  // 2
</code></pre>
<h3 id="default-values"><a class="header" href="#default-values">Default Values</a></h3>
<pre><code class="language-java">Affine&lt;Optional&lt;Config&gt;, Config&gt; configAffine = Affines.some();

Optional&lt;Config&gt; maybeConfig = loadConfig();

// Get value or use default
Config config = configAffine.getOrElse(Config.DEFAULT, maybeConfig);
</code></pre>
<h3 id="conditional-modification"><a class="header" href="#conditional-modification">Conditional Modification</a></h3>
<pre><code class="language-java">Affine&lt;Optional&lt;String&gt;, String&gt; someAffine = Affines.some();

Optional&lt;String&gt; value = Optional.of("hello world");

// Only modify if predicate is satisfied
Optional&lt;String&gt; result = someAffine.modifyWhen(
    s -&gt; s.length() &gt; 5,
    String::toUpperCase,
    value
);
// result = Optional.of("HELLO WORLD")

// Set only when condition is met
Optional&lt;String&gt; guarded = someAffine.setWhen(
    s -&gt; s.startsWith("hello"),
    "goodbye",
    value
);
// guarded = Optional.of("goodbye")
</code></pre>
<h3 id="removal-support"><a class="header" href="#removal-support">Removal Support</a></h3>
<p>Some affines support the <code>remove</code> operation to clear the focused element:</p>
<pre><code class="language-java">// Create an affine that supports removal
Affine&lt;Optional&lt;String&gt;, String&gt; removableAffine = Affines.someWithRemove();

Optional&lt;String&gt; present = Optional.of("hello");
Optional&lt;String&gt; cleared = removableAffine.remove(present);
// cleared = Optional.empty()
</code></pre>
<div id="admonition-remove-support" class="admonition admonish-warning" role="note" aria-labelledby="admonition-remove-support-title">
<div class="admonition-title">
<div id="admonition-remove-support-title">
<p>Remove Support</p>
</div>
<a class="admonition-anchor-link" href="optics/affine.html#admonition-remove-support"></a>
</div>
<div>
<p>Not all affines support the <code>remove</code> operation. Calling <code>remove</code> on an affine that doesn't support it will return the source unchanged. Use <code>Affines.someWithRemove()</code> instead of <code>Affines.some()</code> when you need removal support.</p>
</div>
</div>
<hr />
<h2 id="composing-affines"><a class="header" href="#composing-affines">Composing Affines</a></h2>
<p>Affines compose with other optics following precise rules:</p>
<pre><code class="language-java">// Affine &gt;&gt;&gt; Affine = Affine
Affine&lt;A, C&gt; result = affineAB.andThen(affineBC);

// Affine &gt;&gt;&gt; Lens = Affine
Affine&lt;A, C&gt; result = affineAB.andThen(lensBC);

// Affine &gt;&gt;&gt; Prism = Affine
Affine&lt;A, C&gt; result = affineAB.andThen(prismBC);

// Affine &gt;&gt;&gt; Iso = Affine
Affine&lt;A, C&gt; result = affineAB.andThen(isoBC);

// Affine &gt;&gt;&gt; Traversal = Traversal
Traversal&lt;A, C&gt; result = affineAB.asTraversal().andThen(traversalBC);
</code></pre>
<h3 id="deep-optional-access-example"><a class="header" href="#deep-optional-access-example">Deep Optional Access Example</a></h3>
<pre><code class="language-java">record User(String name, Optional&lt;Address&gt; address) {}
record Address(String street, Optional&lt;String&gt; postcode) {}

// Build affines for each optional field
Lens&lt;User, Optional&lt;Address&gt;&gt; addressLens =
    Lens.of(User::address, (u, a) -&gt; new User(u.name(), a));

Lens&lt;Address, Optional&lt;String&gt;&gt; postcodeLens =
    Lens.of(Address::postcode, (a, p) -&gt; new Address(a.street(), p));

Prism&lt;Optional&lt;Address&gt;, Address&gt; addressPrism = Prisms.some();
Prism&lt;Optional&lt;String&gt;, String&gt; postcodePrism = Prisms.some();

// Compose to access nested optional
Affine&lt;User, String&gt; userPostcode =
    addressLens
        .andThen(addressPrism)           // Lens &gt;&gt;&gt; Prism = Affine
        .andThen(postcodeLens)           // Affine &gt;&gt;&gt; Lens = Affine
        .andThen(postcodePrism);         // Affine &gt;&gt;&gt; Prism = Affine

// Usage
User user1 = new User("Alice", Optional.of(
    new Address("123 Main St", Optional.of("SW1A 1AA"))
));
User user2 = new User("Bob", Optional.empty());

Optional&lt;String&gt; postcode1 = userPostcode.getOptional(user1);
// Optional.of("SW1A 1AA")

Optional&lt;String&gt; postcode2 = userPostcode.getOptional(user2);
// Optional.empty()

// Update deeply nested optional
User updated = userPostcode.set("EC1A 1BB", user1);
// User[name=Alice, address=Optional[Address[street=123 Main St, postcode=Optional[EC1A 1BB]]]]
</code></pre>
<hr />
<h2 id="factory-methods"><a class="header" href="#factory-methods">Factory Methods</a></h2>
<p>The <code>Affine</code> interface provides factory methods for common construction patterns:</p>
<h3 id="from-getter-and-setter"><a class="header" href="#from-getter-and-setter">From Getter and Setter</a></h3>
<pre><code class="language-java">// Basic construction
Affine&lt;S, A&gt; affine = Affine.of(
    s -&gt; getOptional(s),           // S -&gt; Optional&lt;A&gt;
    (s, a) -&gt; setInSource(s, a)    // (S, A) -&gt; S
);

// With removal support
Affine&lt;S, A&gt; removable = Affine.of(
    s -&gt; getOptional(s),           // S -&gt; Optional&lt;A&gt;
    (s, a) -&gt; setInSource(s, a),   // (S, A) -&gt; S
    s -&gt; removeFromSource(s)       // S -&gt; S
);
</code></pre>
<h3 id="from-lens-and-prism"><a class="header" href="#from-lens-and-prism">From Lens and Prism</a></h3>
<pre><code class="language-java">// Compose a Lens and Prism into an Affine
Affine&lt;S, B&gt; affine = Affine.fromLensAndPrism(
    lensAB,   // Lens&lt;S, A&gt;
    prismBC   // Prism&lt;A, B&gt;
);

// Compose a Prism and Lens into an Affine
Affine&lt;S, B&gt; affine = Affine.fromPrismAndLens(
    prismAB,  // Prism&lt;S, A&gt;
    lensBC    // Lens&lt;A, B&gt;
);
</code></pre>
<hr />
<h2 id="when-to-use-affines-vs-other-optics"><a class="header" href="#when-to-use-affines-vs-other-optics">When to Use Affines vs Other Optics</a></h2>
<h3 id="use-affine-when"><a class="header" href="#use-affine-when">Use Affine When:</a></h3>
<ul>
<li><strong>Optional fields</strong> in records or classes (<code>Optional&lt;T&gt;</code>)</li>
<li><strong>Nullable properties</strong> in legacy or interop code</li>
<li><strong>Conditional field access</strong> that may or may not exist</li>
<li><strong>Lens + Prism compositions</strong> where you need the precise type</li>
</ul>
<pre><code class="language-java">// Perfect for optional record fields
record Config(Optional&lt;String&gt; apiKey) {}

Affine&lt;Config, String&gt; apiKeyAffine =
    ConfigLenses.apiKey().andThen(Prisms.some());

Optional&lt;String&gt; key = apiKeyAffine.getOptional(config);
</code></pre>
<h3 id="use-lens-when"><a class="header" href="#use-lens-when">Use Lens When:</a></h3>
<ul>
<li>The field is <strong>always present</strong> (guaranteed to exist)</li>
<li>You're working with <strong>product types</strong> (records, classes)</li>
</ul>
<pre><code class="language-java">// Field always exists
record Point(int x, int y) {}
Lens&lt;Point, Integer&gt; xLens = Lens.of(Point::x, (p, x) -&gt; new Point(x, p.y()));
</code></pre>
<h3 id="use-prism-when"><a class="header" href="#use-prism-when">Use Prism When:</a></h3>
<ul>
<li>Working with <strong>sum types</strong> (sealed interfaces, enums)</li>
<li>You need to <strong>construct</strong> the whole from a part</li>
<li>Type-safe <strong>variant matching</strong></li>
</ul>
<pre><code class="language-java">// Sum type handling
sealed interface Shape permits Circle, Rectangle {}
Prism&lt;Shape, Circle&gt; circlePrism = ...;
Shape circle = circlePrism.build(new Circle(5.0));  // Can construct!
</code></pre>
<h3 id="use-traversal-when"><a class="header" href="#use-traversal-when">Use Traversal When:</a></h3>
<ul>
<li>Focusing on <strong>multiple elements</strong> (lists, sets)</li>
<li>You need to work with <strong>collections</strong></li>
</ul>
<pre><code class="language-java">// Multiple elements
Traversal&lt;List&lt;String&gt;, String&gt; listTraversal = Traversals.forList();
List&lt;String&gt; upper = Traversals.modify(listTraversal, String::toUpperCase, names);
</code></pre>
<hr />
<h2 id="common-pitfalls-11"><a class="header" href="#common-pitfalls-11">Common Pitfalls</a></h2>
<h3 id="dont-do-this-2"><a class="header" href="#dont-do-this-2">Don't Do This:</a></h3>
<pre><code class="language-java">// Overly complex: manual Optional handling
Optional&lt;String&gt; getNestedValue(Config config) {
    return config.database()
        .flatMap(db -&gt; db.connection())
        .flatMap(conn -&gt; conn.timeout())
        .map(Object::toString);
}

// Unsafe: assuming presence without checking
String value = config.database().get().host();  // NoSuchElementException!

// Verbose: repeated null checks
if (user.address() != null &amp;&amp; user.address().postcode() != null) {
    return user.address().postcode();
}
</code></pre>
<h3 id="do-this-instead-2"><a class="header" href="#do-this-instead-2">Do This Instead:</a></h3>
<pre><code class="language-java">// Clean: compose affines for deep access
Affine&lt;Config, String&gt; timeoutAffine =
    databaseAffine
        .andThen(connectionAffine)
        .andThen(timeoutLens)
        .andThen(Affines.some());

Optional&lt;String&gt; timeout = timeoutAffine.mapOptional(Object::toString, config);

// Safe: affine handles absence gracefully
String value = databaseAffine.getOrElse(defaultSettings, config).host();

// Composable: build reusable optics
Affine&lt;User, String&gt; postcodeAffine = UserOptics.postcode();
Optional&lt;String&gt; postcode = postcodeAffine.getOptional(user);
</code></pre>
<hr />
<h2 id="the-affine-laws"><a class="header" href="#the-affine-laws">The Affine Laws</a></h2>
<p>Well-behaved affines satisfy these laws:</p>
<h3 id="get-set-law"><a class="header" href="#get-set-law">Get-Set Law</a></h3>
<p>If a value is present, getting and then setting returns the original:</p>
<pre><code class="language-java">affine.getOptional(s).map(a -&gt; affine.set(a, s)).orElse(s) == s
</code></pre>
<h3 id="set-set-law"><a class="header" href="#set-set-law">Set-Set Law</a></h3>
<p>Setting twice is equivalent to setting once with the final value:</p>
<pre><code class="language-java">affine.set(b, affine.set(a, s)) == affine.set(b, s)
</code></pre>
<h3 id="getoptional-set-law"><a class="header" href="#getoptional-set-law">GetOptional-Set Law</a></h3>
<p>Setting a value and then getting returns that value (if the structure allows):</p>
<pre><code class="language-java">// When getOptional returns a value after set:
affine.getOptional(affine.set(a, s)) == Optional.of(a)
// (or Optional.empty() if the structure doesn't support the focus)
</code></pre>
<hr />
<h2 id="real-world-example-configuration-management"><a class="header" href="#real-world-example-configuration-management">Real-World Example: Configuration Management</a></h2>
<pre><code class="language-java">import org.higherkindedj.optics.Affine;
import org.higherkindedj.optics.Lens;
import org.higherkindedj.optics.util.Affines;
import org.higherkindedj.optics.util.Prisms;

import java.util.Optional;

// Domain model with nested optionals
record AppConfig(
    String appName,
    Optional&lt;DatabaseConfig&gt; database,
    Optional&lt;CacheConfig&gt; cache
) {}

record DatabaseConfig(
    String host,
    int port,
    Optional&lt;PoolConfig&gt; pool
) {}

record PoolConfig(int minSize, int maxSize) {}

record CacheConfig(String provider, int ttlSeconds) {}

public class ConfigOptics {
    // Lenses for required fields
    public static final Lens&lt;AppConfig, String&gt; appName =
        Lens.of(AppConfig::appName, (c, n) -&gt; new AppConfig(n, c.database(), c.cache()));

    public static final Lens&lt;AppConfig, Optional&lt;DatabaseConfig&gt;&gt; database =
        Lens.of(AppConfig::database, (c, db) -&gt; new AppConfig(c.appName(), db, c.cache()));

    public static final Lens&lt;DatabaseConfig, String&gt; host =
        Lens.of(DatabaseConfig::host, (db, h) -&gt; new DatabaseConfig(h, db.port(), db.pool()));

    public static final Lens&lt;DatabaseConfig, Optional&lt;PoolConfig&gt;&gt; pool =
        Lens.of(DatabaseConfig::pool, (db, p) -&gt; new DatabaseConfig(db.host(), db.port(), p));

    public static final Lens&lt;PoolConfig, Integer&gt; maxSize =
        Lens.of(PoolConfig::maxSize, (p, m) -&gt; new PoolConfig(p.minSize(), m));

    // Affines for optional access
    public static final Affine&lt;AppConfig, DatabaseConfig&gt; databaseAffine =
        database.andThen(Prisms.some());

    public static final Affine&lt;AppConfig, String&gt; databaseHost =
        databaseAffine.andThen(host);

    public static final Affine&lt;AppConfig, PoolConfig&gt; poolConfig =
        databaseAffine
            .andThen(pool)
            .andThen(Prisms.some());

    public static final Affine&lt;AppConfig, Integer&gt; poolMaxSize =
        poolConfig.andThen(maxSize);

    public static void main(String[] args) {
        // Create a config with nested optionals
        AppConfig config = new AppConfig(
            "MyApp",
            Optional.of(new DatabaseConfig(
                "localhost",
                5432,
                Optional.of(new PoolConfig(5, 20))
            )),
            Optional.empty()
        );

        // Read nested values safely
        System.out.println("Host: " + databaseHost.getOptional(config));
        // Host: Optional[localhost]

        System.out.println("Pool max: " + poolMaxSize.getOptional(config));
        // Pool max: Optional[20]

        // Update deeply nested value
        AppConfig updated = poolMaxSize.set(50, config);
        System.out.println("Updated pool max: " + poolMaxSize.getOptional(updated));
        // Updated pool max: Optional[50]

        // Conditional modification
        AppConfig doubled = poolMaxSize.modify(n -&gt; n * 2, config);
        System.out.println("Doubled pool max: " + poolMaxSize.getOptional(doubled));
        // Doubled pool max: Optional[40]

        // Safe operation on missing config
        AppConfig emptyConfig = new AppConfig("EmptyApp", Optional.empty(), Optional.empty());
        System.out.println("Missing host: " + databaseHost.getOptional(emptyConfig));
        // Missing host: Optional.empty

        // Modification on missing does nothing
        AppConfig unchanged = poolMaxSize.modify(n -&gt; n * 2, emptyConfig);
        System.out.println("Empty config unchanged: " + (unchanged == emptyConfig));
        // Empty config unchanged: true
    }
}
</code></pre>
<hr />
<h2 id="performance-notes-2"><a class="header" href="#performance-notes-2">Performance Notes</a></h2>
<p>Affines are designed for both safety and efficiency:</p>
<ul>
<li><strong>Zero allocation for absent values</strong>: <code>getOptional</code> returns <code>Optional.empty()</code> without allocating</li>
<li><strong>Short-circuit evaluation</strong>: Composed affines stop at the first absent value</li>
<li><strong>Immutable by design</strong>: All operations return new values, enabling safe concurrent use</li>
<li><strong>Inlinable</strong>: Simple affines are candidates for JVM inlining</li>
</ul>
<p><strong>Best Practice</strong>: Create composed affines once and reuse them:</p>
<pre><code class="language-java">public class UserOptics {
    // Create once, use everywhere
    public static final Affine&lt;User, String&gt; EMAIL =
        addressLens.andThen(addressPrism).andThen(emailLens);

    public static final Affine&lt;User, String&gt; POSTCODE =
        addressLens.andThen(addressPrism).andThen(postcodeLens).andThen(postcodePrism);
}
</code></pre>
<hr />
<h2 id="why-affines-are-essential"><a class="header" href="#why-affines-are-essential">Why Affines are Essential</a></h2>
<p>Affines fill an important gap in the optic hierarchy:</p>
<ul>
<li><strong>Precision</strong>: More precise than Traversal for zero-or-one access</li>
<li><strong>Composability</strong>: Natural result of Lens + Prism composition</li>
<li><strong>Safety</strong>: Eliminate null checks and <code>Optional.flatMap</code> chains</li>
<li><strong>Expressiveness</strong>: Clearly communicate "optional field" intent</li>
</ul>
<p>By adding Affines to your toolkit, you can write cleaner, safer code that handles optional data with the same elegance as required fields.</p>
<hr />
<div id="admonition-further-reading" class="admonition admonish-tip" role="note" aria-labelledby="admonition-further-reading-title">
<div class="admonition-title">
<div id="admonition-further-reading-title">
<p>Further Reading</p>
</div>
<a class="admonition-anchor-link" href="optics/affine.html#admonition-further-reading"></a>
</div>
<div>
<ul>
<li><strong>Monocle Optional</strong>: <a href="https://www.optics.dev/Monocle/docs/optics/optional">Scala's Affine</a> - Monocle uses "Optional" for the same concept</li>
<li><strong>Baeldung</strong>: <a href="https://www.baeldung.com/java-optional">Handling Optionality in Java</a> - Guide to Java Optional, the underlying type Affine often works with</li>
</ul>
</div>
</div>
<div id="admonition-terminology-note" class="admonition admonish-tip" role="note" aria-labelledby="admonition-terminology-note-title">
<div class="admonition-title">
<div id="admonition-terminology-note-title">
<p>Terminology Note</p>
</div>
<a class="admonition-anchor-link" href="optics/affine.html#admonition-terminology-note"></a>
</div>
<div>
<p>In some functional programming libraries (notably Scala's Monocle), the Affine optic is called an <strong>Optional</strong>. This can cause confusion with Java's <code>java.util.Optional</code>. In higher-kinded-j, we use the term "Affine" to avoid this ambiguity whilst maintaining mathematical precision.</p>
</div>
</div>
<div id="admonition-hands-on-learning" class="admonition admonish-info" role="note" aria-labelledby="admonition-hands-on-learning-title">
<div class="admonition-title">
<div id="admonition-hands-on-learning-title">
<p>Hands-On Learning</p>
</div>
<a class="admonition-anchor-link" href="optics/affine.html#admonition-hands-on-learning"></a>
</div>
<div>
<p>Practice affine basics in <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/optics/Tutorial04_AffineBasics.java">Tutorial 04: Affine Basics</a> (7 exercises, ~10 minutes).</p>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="optics/prisms.html">Prisms: Working with Sum Types</a>
<strong>Next:</strong> <a href="optics/iso.html">Isomorphisms: Data Equivalence</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="isomorphisms-a-practical-guide"><a class="header" href="#isomorphisms-a-practical-guide">Isomorphisms: A Practical Guide</a></h1>
<h2 id="data-equivalence-with-isos"><a class="header" href="#data-equivalence-with-isos"><em>Data Equivalence with Isos</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="optics/iso.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to define lossless, reversible conversions between equivalent types</li>
<li>Creating isomorphisms with <code>Iso.of(get, reverseGet)</code></li>
<li>Using <code>reverse()</code> to flip conversion directions</li>
<li>Step-by-step transformation workflows for data format conversion</li>
<li>Testing round-trip properties to ensure conversion correctness</li>
<li>When to use isos vs direct conversion methods vs manual adapters</li>
</ul>
</div>
</div>
<div id="admonition-example-code" class="admonition admonish-note" role="note" aria-labelledby="admonition-example-code-title">
<div class="admonition-title">
<div id="admonition-example-code-title">
<p>Example Code</p>
</div>
<a class="admonition-anchor-link" href="optics/iso.html#admonition-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/IsoUsageExample.java">IsoUsageExample</a></p>
</div>
</div>
<p>In the previous guides, we explored two essential optics: the <strong><code>Lens</code></strong>, for targeting data that <em>must</em> exist (a "has-a" relationship), and the <strong><code>Prism</code></strong>, for safely targeting data that <em>might</em> exist in a specific shape (an "is-a" relationship).</p>
<p>This leaves one final, fundamental question: what if you have two data types that are different in structure but hold the exact same information? How do you switch between them losslessly? For this, we need our final core optic: the <strong><code>Iso</code></strong>.</p>
<hr />
<h2 id="the-scenario-translating-between-equivalent-types"><a class="header" href="#the-scenario-translating-between-equivalent-types">The Scenario: Translating Between Equivalent Types</a></h2>
<p>An <strong><code>Iso</code></strong> (Isomorphism) is a "two-way street." It's an optic that represents a perfectly reversible, lossless conversion between two equivalent types. Think of it as a <strong>universal translator</strong> or a type-safe adapter that you can compose with other optics.</p>
<p>An <code>Iso</code> is the right tool when you need to:</p>
<ul>
<li>Convert a wrapper type to its raw value (e.g., <code>UserId(long id)</code> &lt;-&gt; <code>long</code>).</li>
<li>Handle data encoding and decoding (e.g., <code>byte[]</code> &lt;-&gt; <code>Base64 String</code>).</li>
<li>Bridge two data structures that are informationally identical (e.g., a custom record and a generic tuple).</li>
</ul>
<p>Let's explore that last case. Imagine we have a <code>Point</code> record and want to convert it to a generic <code>Tuple2</code> to use with a library that operates on tuples.</p>
<p><strong>The Data Model:</strong></p>
<pre><code class="language-java">public record Point(int x, int y) {}

public record Tuple2&lt;A, B&gt;(A _1, B _2) {}
</code></pre>
<p>These two records can hold the same information. An <code>Iso</code> is the perfect way to formalize this relationship.</p>
<hr />
<h2 id="think-of-isos-like"><a class="header" href="#think-of-isos-like">Think of Isos Like...</a></h2>
<ul>
<li><strong>A universal translator</strong>: Perfect two-way conversion between equivalent representations</li>
<li><strong>A reversible adapter</strong>: Converts between formats without losing information</li>
<li><strong>A bridge</strong>: Connects two different structures that represent the same data</li>
<li><strong>A currency exchange</strong>: Converts between equivalent values at a 1:1 rate</li>
</ul>
<hr />
<h2 id="a-step-by-step-walkthrough-3"><a class="header" href="#a-step-by-step-walkthrough-3">A Step-by-Step Walkthrough</a></h2>
<h3 id="step-1-defining-an-iso"><a class="header" href="#step-1-defining-an-iso">Step 1: Defining an Iso</a></h3>
<p>Unlike Lenses and Prisms, which are often generated from annotations, Isos are almost always defined manually. This is because the logic for converting between two types is unique to your specific domain.</p>
<p>You create an <code>Iso</code> using the static <code>Iso.of(get, reverseGet)</code> constructor.</p>
<pre><code class="language-java">import org.higherkindedj.optics.Iso;
import org.higherkindedj.hkt.tuple.Tuple;
import org.higherkindedj.hkt.tuple.Tuple2;

public class Converters {
    public static Iso&lt;Point, Tuple2&lt;Integer, Integer&gt;&gt; pointToTuple() {
      return Iso.of(
          // Function to get the Tuple from the Point
          point -&gt; Tuple.of(point.x(), point.y()),
          // Function to get the Point from the Tuple
          tuple -&gt; new Point(tuple._1(), tuple._2())
      );
    }
}
</code></pre>
<h4 id="using-generateisos-for-method-based-isos"><a class="header" href="#using-generateisos-for-method-based-isos">Using <code>@GenerateIsos</code> for Method-Based Isos</a></h4>
<p>Whilst most Isos are defined manually, the <code>@GenerateIsos</code> annotation can be applied to methods that return Iso instances to generate a companion class with static fields. You can also customise the generated package:</p>
<pre><code class="language-java">public class Converters {
    // Generated class will be placed in org.example.generated.optics
    @GenerateIsos(targetPackage = "org.example.generated.optics")
    public static Iso&lt;Point, Tuple2&lt;Integer, Integer&gt;&gt; pointToTuple() {
        return Iso.of(
            point -&gt; Tuple.of(point.x(), point.y()),
            tuple -&gt; new Point(tuple._1(), tuple._2())
        );
    }
}
</code></pre>
<p>This is useful when you need to avoid name collisions or organise generated code separately.</p>
<h3 id="step-2-the-core-iso-operations"><a class="header" href="#step-2-the-core-iso-operations">Step 2: The Core Iso Operations</a></h3>
<p>An <code>Iso</code> provides two fundamental, lossless operations:</p>
<ul>
<li><strong><code>get(source)</code></strong>: The "forward" conversion (e.g., from <code>Point</code> to <code>Tuple2</code>).</li>
<li><strong><code>reverseGet(target)</code></strong>: The "backward" conversion (e.g., from <code>Tuple2</code> back to <code>Point</code>).</li>
</ul>
<p>Furthermore, every <code>Iso</code> is trivially reversible using the <strong><code>.reverse()</code></strong> method, which returns a new <code>Iso</code> with the "get" and "reverseGet" functions swapped.</p>
<pre><code class="language-java">var pointToTupleIso = Converters.pointToTuple();
var myPoint = new Point(10, 20);

// Forward conversion
Tuple2&lt;Integer, Integer&gt; myTuple = pointToTupleIso.get(myPoint); // -&gt; Tuple2[10, 20]

// Backward conversion using the reversed Iso
Point convertedBack = pointToTupleIso.reverse().get(myTuple); // -&gt; Point[10, 20]

// Demonstrate perfect round-trip
assert myPoint.equals(convertedBack); // Always true for lawful Isos
</code></pre>
<h3 id="step-3-composing-isos-as-a-bridge"><a class="header" href="#step-3-composing-isos-as-a-bridge">Step 3: Composing Isos as a Bridge</a></h3>
<p>The most powerful feature of an <code>Iso</code> is its ability to act as an adapter or "glue" between other optics. Because the conversion is lossless, an <code>Iso</code> preserves the "shape" of the optic it's composed with.</p>
<ul>
<li><code>Iso + Iso = Iso</code></li>
<li><strong><code>Iso + Lens = Lens</code></strong></li>
<li><strong><code>Iso + Prism = Prism</code></strong></li>
<li><strong><code>Iso + Traversal = Traversal</code></strong></li>
</ul>
<p>This second rule is incredibly useful. We can compose our <code>Iso&lt;Point, Tuple2&gt;</code> with a <code>Lens</code> that operates on a <code>Tuple2</code> to create a brand new <code>Lens</code> that operates directly on our <code>Point</code>!</p>
<pre><code class="language-java">// A standard Lens that gets the first element of any Tuple2
Lens&lt;Tuple2&lt;Integer, Integer&gt;, Integer&gt; tupleFirstElementLens = ...;

// The composition: Iso&lt;Point, Tuple2&gt; + Lens&lt;Tuple2, Integer&gt; = Lens&lt;Point, Integer&gt;
Lens&lt;Point, Integer&gt; pointToX = pointToTupleIso.andThen(tupleFirstElementLens);

// We can now use this new Lens to modify the 'x' coordinate of our Point
Point movedPoint = pointToX.modify(x -&gt; x + 5, myPoint); // -&gt; Point[15, 20]
</code></pre>
<p>The <code>Iso</code> acted as a bridge, allowing a generic <code>Lens</code> for tuples to work on our specific <code>Point</code> record.</p>
<hr />
<h2 id="when-to-use-isos-vs-other-approaches"><a class="header" href="#when-to-use-isos-vs-other-approaches">When to Use Isos vs Other Approaches</a></h2>
<h3 id="use-isos-when"><a class="header" href="#use-isos-when">Use Isos When:</a></h3>
<ul>
<li><strong>Data format conversion</strong> - Converting between equivalent representations</li>
<li><strong>Legacy system integration</strong> - Bridging old and new data formats</li>
<li><strong>Library interoperability</strong> - Adapting your types to work with external libraries</li>
<li><strong>Composable adapters</strong> - Building reusable conversion components</li>
</ul>
<pre><code class="language-java">// Perfect for format conversion
Iso&lt;LocalDate, String&gt; dateStringIso = Iso.of(
    date -&gt; date.format(DateTimeFormatter.ISO_LOCAL_DATE),
    dateStr -&gt; LocalDate.parse(dateStr, DateTimeFormatter.ISO_LOCAL_DATE)
);

// Use with any date-focused lens
Lens&lt;Person, String&gt; birthDateStringLens = 
    PersonLenses.birthDate().andThen(dateStringIso);
</code></pre>
<h3 id="use-direct-conversion-methods-when"><a class="header" href="#use-direct-conversion-methods-when">Use Direct Conversion Methods When:</a></h3>
<ul>
<li><strong>One-way conversion</strong> - You don't need the reverse operation</li>
<li><strong>Non-lossless conversion</strong> - Information is lost in the conversion</li>
<li><strong>Performance critical paths</strong> - Minimal abstraction overhead needed</li>
</ul>
<pre><code class="language-java">// Simple one-way conversion
String pointDescription = point.x() + "," + point.y();
</code></pre>
<h3 id="use-manual-adapters-when"><a class="header" href="#use-manual-adapters-when">Use Manual Adapters When:</a></h3>
<ul>
<li><strong>Complex conversion logic</strong> - Multi-step or conditional conversions</li>
<li><strong>Validation required</strong> - Conversion might fail</li>
<li><strong>Side effects needed</strong> - Logging, caching, etc.</li>
</ul>
<pre><code class="language-java">// Complex conversion that might fail
public Optional&lt;Point&gt; parsePoint(String input) {
    try {
        String[] parts = input.split(",");
        return Optional.of(new Point(
            Integer.parseInt(parts[0].trim()),
            Integer.parseInt(parts[1].trim())
        ));
    } catch (Exception e) {
        return Optional.empty();
    }
}
</code></pre>
<hr />
<h2 id="common-pitfalls-12"><a class="header" href="#common-pitfalls-12">Common Pitfalls</a></h2>
<h3 id="dont-do-this-3"><a class="header" href="#dont-do-this-3">Don't Do This:</a></h3>
<pre><code class="language-java">// Lossy conversion - not a true isomorphism
Iso&lt;Double, Integer&gt; lossyIso = Iso.of(
    d -&gt; d.intValue(),    // Loses decimal precision!
    i -&gt; i.doubleValue()  // Can't recover original value
);

// One-way thinking - forgetting about reverseGet
Iso&lt;Point, String&gt; badPointIso = Iso.of(
    point -&gt; point.x() + "," + point.y(),
    str -&gt; new Point(0, 0)  // Ignores the input!
);

// Creating Isos repeatedly instead of reusing
var iso1 = Iso.of(Point::x, x -&gt; new Point(x, 0));
var iso2 = Iso.of(Point::x, x -&gt; new Point(x, 0));
var iso3 = Iso.of(Point::x, x -&gt; new Point(x, 0));
</code></pre>
<h3 id="do-this-instead-3"><a class="header" href="#do-this-instead-3">Do This Instead:</a></h3>
<pre><code class="language-java">// True isomorphism - perfect round-trip
Iso&lt;Point, String&gt; goodPointIso = Iso.of(
    point -&gt; point.x() + "," + point.y(),
    str -&gt; {
        String[] parts = str.split(",");
        return new Point(Integer.parseInt(parts[0]), Integer.parseInt(parts[1]));
    }
);

// Test your isomorphisms
public static &lt;A, B&gt; void testIsomorphism(Iso&lt;A, B&gt; iso, A original) {
    B converted = iso.get(original);
    A roundTrip = iso.reverse().get(converted);
    assert original.equals(roundTrip) : "Iso failed round-trip test";
}

// Reuse Isos as constants
public static final Iso&lt;Point, Tuple2&lt;Integer, Integer&gt;&gt; POINT_TO_TUPLE = 
    Iso.of(
        point -&gt; Tuple.of(point.x(), point.y()),
        tuple -&gt; new Point(tuple._1(), tuple._2())
    );
</code></pre>
<hr />
<h2 id="performance-notes-3"><a class="header" href="#performance-notes-3">Performance Notes</a></h2>
<p>Isos are designed for efficient, lossless conversion:</p>
<ul>
<li><strong>Zero overhead composition</strong>: Multiple Iso compositions are fused into single operations</li>
<li><strong>Lazy evaluation</strong>: Conversions only happen when needed</li>
<li><strong>Type safety</strong>: All conversions are checked at compile time</li>
<li><strong>Reusable</strong>: Isos can be stored and reused across your application</li>
</ul>
<p><strong>Best Practice</strong>: For frequently used conversions, create Isos as constants and test them:</p>
<pre><code class="language-java">public class DataIsos {
    public static final Iso&lt;UserId, Long&gt; USER_ID_LONG = 
        Iso.of(UserId::value, UserId::new);
    
    public static final Iso&lt;Money, BigDecimal&gt; MONEY_DECIMAL = 
        Iso.of(Money::amount, Money::new);
    
    // Test your isos
    static {
        testIsomorphism(USER_ID_LONG, new UserId(12345L));
        testIsomorphism(MONEY_DECIMAL, new Money(new BigDecimal("99.99")));
    }
  
    private static &lt;A, B&gt; void testIsomorphism(Iso&lt;A, B&gt; iso, A original) {
        B converted = iso.get(original);
        A roundTrip = iso.reverse().get(converted);
        if (!original.equals(roundTrip)) {
            throw new AssertionError("Iso failed round-trip test: " + original + " -&gt; " + converted + " -&gt; " + roundTrip);
        }
    }
}
</code></pre>
<hr />
<h2 id="real-world-examples"><a class="header" href="#real-world-examples">Real-World Examples</a></h2>
<h3 id="1-api-data-transformation"><a class="header" href="#1-api-data-transformation">1. API Data Transformation</a></h3>
<pre><code class="language-java">// Internal model
public record Customer(String name, String email, LocalDate birthDate) {}

// External API model
public record CustomerDto(String fullName, String emailAddress, String birthDateString) {}

public class CustomerIsos {
    public static final Iso&lt;Customer, CustomerDto&gt; CUSTOMER_DTO = Iso.of(
        // Convert to DTO
        customer -&gt; new CustomerDto(
            customer.name(),
            customer.email(),
            customer.birthDate().format(DateTimeFormatter.ISO_LOCAL_DATE)
        ),
        // Convert from DTO
        dto -&gt; new Customer(
            dto.fullName(),
            dto.emailAddress(),
            LocalDate.parse(dto.birthDateString(), DateTimeFormatter.ISO_LOCAL_DATE)
        )
    );
  
    // Now any Customer lens can work with DTOs
    public static final Lens&lt;CustomerDto, String&gt; DTO_NAME = 
        CUSTOMER_DTO.reverse().andThen(CustomerLenses.name()).andThen(CUSTOMER_DTO);
}
</code></pre>
<h3 id="2-configuration-format-conversion"><a class="header" href="#2-configuration-format-conversion">2. Configuration Format Conversion</a></h3>
<pre><code class="language-java">// Different configuration representations
public record DatabaseConfig(String host, int port, String database) {}
public record ConnectionString(String value) {}

public class ConfigIsos {
    public static final Iso&lt;DatabaseConfig, ConnectionString&gt; DB_CONNECTION = Iso.of(
        // To connection string
        config -&gt; new ConnectionString(
            "jdbc:postgresql://" + config.host() + ":" + config.port() + "/" + config.database()
        ),
        // From connection string
        conn -&gt; {
            // Simple parser for this example
            String url = conn.value();
            String[] parts = url.replace("jdbc:postgresql://", "").split("[:/]");
            return new DatabaseConfig(parts[0], Integer.parseInt(parts[1]), parts[2]);
        }
    );
  
    // Use with existing configuration lenses
    public static final Lens&lt;DatabaseConfig, String&gt; CONNECTION_STRING_HOST = 
        DB_CONNECTION.andThen(
            Lens.of(
                cs -&gt; cs.value().split("//")[1].split(":")[0],
                (cs, host) -&gt; new ConnectionString(cs.value().replaceFirst("//[^:]+:", "//" + host + ":"))
            )
        ).andThen(DB_CONNECTION.reverse());
}
</code></pre>
<h3 id="3-wrapper-type-integration"><a class="header" href="#3-wrapper-type-integration">3. Wrapper Type Integration</a></h3>
<pre><code class="language-java">// Strongly-typed wrappers
public record ProductId(UUID value) {}
public record CategoryId(UUID value) {}

public class WrapperIsos {
    public static final Iso&lt;ProductId, UUID&gt; PRODUCT_ID_UUID = 
        Iso.of(ProductId::value, ProductId::new);
  
    public static final Iso&lt;CategoryId, UUID&gt; CATEGORY_ID_UUID = 
        Iso.of(CategoryId::value, CategoryId::new);
  
    // Use with any UUID-based operations
    public static String formatProductId(ProductId id) {
        return PRODUCT_ID_UUID
            .andThen(Iso.of(UUID::toString, UUID::fromString))
            .get(id);
    }
}
</code></pre>
<h2 id="complete-runnable-example-2"><a class="header" href="#complete-runnable-example-2">Complete, Runnable Example</a></h2>
<p>This example puts all the steps together to show both direct conversion and composition.</p>
<pre><code class="language-java">public class IsoUsageExample {

    @GenerateLenses
    public record Point(int x, int y) {}

    @GenerateLenses
    public record Circle(Point centre, int radius) {}

    public static class Converters {
        @GenerateIsos
        public static Iso&lt;Point, Tuple2&lt;Integer, Integer&gt;&gt; pointToTuple() {
            return Iso.of(
                    point -&gt; Tuple.of(point.x(), point.y()),
                    tuple -&gt; new Point(tuple._1(), tuple._2()));
        }

        // Additional useful Isos
        public static final Iso&lt;Point, String&gt; POINT_STRING = Iso.of(
                point -&gt; point.x() + "," + point.y(),
                str -&gt; {
                    String[] parts = str.split(",");
                    return new Point(Integer.parseInt(parts[0]), Integer.parseInt(parts[1]));
                }
        );
    }

    // Test helper
    private static &lt;A, B&gt; void testRoundTrip(Iso&lt;A, B&gt; iso, A original, String description) {
        B converted = iso.get(original);
        A roundTrip = iso.reverse().get(converted);
        System.out.println(description + ":");
        System.out.println("  Original:  " + original);
        System.out.println("  Converted: " + converted);
        System.out.println("  Round-trip: " + roundTrip);
        System.out.println("  Success: " + original.equals(roundTrip));
        System.out.println();
    }

    public static void main(String[] args) {
        // 1. Define a point and circle.
        var myPoint = new Point(10, 20);
        var myCircle = new Circle(myPoint, 5);

        System.out.println("=== ISO USAGE EXAMPLE ===");
        System.out.println("Original Point: " + myPoint);
        System.out.println("Original Circle: " + myCircle);
        System.out.println("------------------------------------------");

        // 2. Get the generated Iso.
        var pointToTupleIso = ConvertersIsos.pointToTuple;

        // --- SCENARIO 1: Direct conversions and round-trip testing ---
        System.out.println("--- Scenario 1: Direct Conversions ---");
        testRoundTrip(pointToTupleIso, myPoint, "Point to Tuple conversion");
        testRoundTrip(Converters.POINT_STRING, myPoint, "Point to String conversion");

        // --- SCENARIO 2: Using reverse() ---
        System.out.println("--- Scenario 2: Reverse Operations ---");
        var tupleToPointIso = pointToTupleIso.reverse();
        var myTuple = Tuple.of(30, 40);
        Point pointFromTuple = tupleToPointIso.get(myTuple);
        System.out.println("Tuple: " + myTuple + " -&gt; Point: " + pointFromTuple);
        System.out.println();

        // --- SCENARIO 3: Composition with lenses ---
        System.out.println("--- Scenario 3: Composition with Lenses ---");

        // Create a lens manually that works with Point directly
        Lens&lt;Point, Integer&gt; pointToXLens = Lens.of(
                Point::x,
                (point, newX) -&gt; new Point(newX, point.y())
        );

        // Use the lens
        Point movedPoint = pointToXLens.modify(x -&gt; x + 5, myPoint);
        System.out.println("Original point: " + myPoint);
        System.out.println("After moving X by 5: " + movedPoint);
        System.out.println();

        // --- SCENARIO 4: Demonstrating Iso composition ---
        System.out.println("--- Scenario 4: Iso Composition ---");

        // Show how the Iso can be used to convert and work with tuples
        Tuple2&lt;Integer, Integer&gt; tupleRepresentation = pointToTupleIso.get(myPoint);
        System.out.println("Point as tuple: " + tupleRepresentation);

        // Modify the tuple using tuple operations
        Lens&lt;Tuple2&lt;Integer, Integer&gt;, Integer&gt; tupleFirstLens = Tuple2Lenses._1();
        Tuple2&lt;Integer, Integer&gt; modifiedTuple = tupleFirstLens.modify(x -&gt; x * 2, tupleRepresentation);

        // Convert back to Point
        Point modifiedPoint = pointToTupleIso.reverse().get(modifiedTuple);
        System.out.println("Modified tuple: " + modifiedTuple);
        System.out.println("Back to point: " + modifiedPoint);
        System.out.println();

        // --- SCENARIO 5: String format conversions ---
        System.out.println("--- Scenario 5: String Format Conversions ---");

        String pointAsString = Converters.POINT_STRING.get(myPoint);
        System.out.println("Point as string: " + pointAsString);

        Point recoveredFromString = Converters.POINT_STRING.reverse().get(pointAsString);
        System.out.println("Recovered from string: " + recoveredFromString);
        System.out.println("Perfect round-trip: " + myPoint.equals(recoveredFromString));

        // --- SCENARIO 6: Working with Circle centre through Iso ---
        System.out.println("--- Scenario 6: Circle Centre Manipulation ---");

        // Get the centre as a tuple, modify it, and put it back
        Point originalCentre = myCircle.centre();
        Tuple2&lt;Integer, Integer&gt; centreAsTuple = pointToTupleIso.get(originalCentre);
        Tuple2&lt;Integer, Integer&gt; shiftedCentre = Tuple.of(centreAsTuple._1() + 10, centreAsTuple._2() + 10);
        Point newCentre = pointToTupleIso.reverse().get(shiftedCentre);
        Circle newCircle = CircleLenses.centre().set(newCentre, myCircle);

        System.out.println("Original circle: " + myCircle);
        System.out.println("Centre as tuple: " + centreAsTuple);
        System.out.println("Shifted centre tuple: " + shiftedCentre);
        System.out.println("New circle: " + newCircle);
    }
</code></pre>
<p><strong>Expected Output:</strong></p>
<pre><code>=== ISO USAGE EXAMPLE ===
Original Point: Point[x=10, y=20]
Original Circle: Circle[centre=Point[x=10, y=20], radius=5]
------------------------------------------
--- Scenario 1: Direct Conversions ---
Point to Tuple conversion:
  Original:  Point[x=10, y=20]
  Converted: Tuple2[_1=10, _2=20]
  Round-trip: Point[x=10, y=20]
  Success: true

Point to String conversion:
  Original:  Point[x=10, y=20]
  Converted: 10,20
  Round-trip: Point[x=10, y=20]
  Success: true

--- Scenario 2: Reverse Operations ---
Tuple: Tuple2[_1=30, _2=40] -&gt; Point: Point[x=30, y=40]

--- Scenario 3: Working with Different Representations ---
Original point: Point[x=10, y=20]
After moving X by 5: Point[x=15, y=20]

--- Scenario 4: Conversion Workflows ---
Point as tuple: Tuple2[_1=10, _2=20]
Modified tuple: Tuple2[_1=20, _2=20]
Back to point: Point[x=20, y=20]

--- Scenario 5: String Format Conversions ---
Point as string: 10,20
Recovered from string: Point[x=10, y=20]
Perfect round-trip: true

--- Scenario 6: Circle Centre Manipulation ---
Original circle: Circle[centre=Point[x=10, y=20], radius=5]
Centre as tuple: Tuple2[_1=10, _2=20]
Shifted centre tuple: Tuple2[_1=20, _2=30]
New circle: Circle[centre=Point[x=20, y=30], radius=5]
</code></pre>
<hr />
<h2 id="why-isos-are-a-powerful-bridge"><a class="header" href="#why-isos-are-a-powerful-bridge">Why Isos are a Powerful Bridge</a></h2>
<p><code>Lens</code>, <code>Prism</code>, and <code>Iso</code> form a powerful trio for modelling any data operation. An <code>Iso</code> is the essential bridge that enables you to:</p>
<ul>
<li><strong>Work with the Best Representation</strong>: Convert data to the most suitable format for each operation, then convert back when needed.</li>
<li><strong>Enable Library Integration</strong>: Adapt your internal data types to work seamlessly with external libraries without changing your core domain model.</li>
<li><strong>Maintain Type Safety</strong>: All conversions are checked at compile time, eliminating runtime conversion errors.</li>
<li><strong>Build Reusable Converters</strong>: Create tested, reusable conversion components that can be used throughout your application.</li>
</ul>
<p>The step-by-step conversion approach shown in the examples is the most practical way to use Isos in real applications, providing clear, maintainable code that leverages the strengths of different data representations.</p>
<hr />
<p><strong>Previous:</strong> <a href="optics/affine.html">Affines: Working with Optional Fields</a>
<strong>Next:</strong> <a href="optics/composition_rules.html">Composition Rules</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="optic-composition-rules"><a class="header" href="#optic-composition-rules">Optic Composition Rules</a></h1>
<h2 id="understanding-how-different-optics-compose"><a class="header" href="#understanding-how-different-optics-compose"><em>Understanding How Different Optics Compose</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="optics/composition_rules.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>The mathematical rules governing optic composition</li>
<li>When composition returns the same optic type vs a more general one</li>
<li>Practical implications for your code</li>
<li>Quick reference table for all composition patterns</li>
</ul>
</div>
</div>
<div id="admonition-hands-on-practice" class="admonition admonish-note" role="note" aria-labelledby="admonition-hands-on-practice-title">
<div class="admonition-title">
<div id="admonition-hands-on-practice-title">
<p>Hands On Practice</p>
</div>
<a class="admonition-anchor-link" href="optics/composition_rules.html#admonition-hands-on-practice"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/optics/Tutorial02_LensComposition.java">Tutorial02_LensComposition.java</a></p>
</div>
</div>
<p>When composing optics, the resulting optic type follows precise mathematical rules. Understanding these rules helps you predict what type of optic you'll get and why.</p>
<hr />
<h2 id="the-optic-hierarchy"><a class="header" href="#the-optic-hierarchy">The Optic Hierarchy</a></h2>
<p>Optics form a hierarchy from most specific (most operations available) to most general (fewest operations available):</p>
<pre><code>Iso ──────────────────────────────────────────┐
 │                                            │
 ├──&gt; Lens ──&gt; Getter                         │
 │       │                                    │
 │       └──────────────────────┐             │
 │                              │             │
 └──&gt; Prism ──&gt; Affine ─────&gt; Fold            │
          │         │                         │
          │         └──────────────┐          │
          │                        v          │
          └──────────────────&gt; Traversal ─────┘
                                    │
                                    └──&gt; Setter
</code></pre>
<p><strong>What is Affine?</strong> An Affine optic focuses on <strong>zero or one</strong> element within a structure. It combines the partial access of a Prism with the update capability of a Lens. Common use cases include:</p>
<ul>
<li>Accessing <code>Optional&lt;T&gt;</code> fields in records</li>
<li>Working with nullable properties</li>
<li>Navigating through optional intermediate structures</li>
</ul>
<p><strong>Key insight</strong>: When composing two different optic types, the result is always the <strong>least general common ancestor</strong> that can represent both operations.</p>
<hr />
<h2 id="composition-rules-table"><a class="header" href="#composition-rules-table">Composition Rules Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>First Optic</th><th>&gt;&gt;&gt;</th><th>Second Optic</th><th>=</th><th>Result Optic</th><th>Reason</th></tr></thead><tbody>
<tr><td><strong>Iso</strong></td><td>&gt;&gt;&gt;</td><td>Iso</td><td>=</td><td><strong>Iso</strong></td><td>Both directions preserved</td></tr>
<tr><td><strong>Iso</strong></td><td>&gt;&gt;&gt;</td><td>Lens</td><td>=</td><td><strong>Lens</strong></td><td>Lens is more restrictive</td></tr>
<tr><td><strong>Iso</strong></td><td>&gt;&gt;&gt;</td><td>Prism</td><td>=</td><td><strong>Prism</strong></td><td>Prism is more restrictive</td></tr>
<tr><td><strong>Iso</strong></td><td>&gt;&gt;&gt;</td><td>Affine</td><td>=</td><td><strong>Affine</strong></td><td>Affine is more restrictive</td></tr>
<tr><td><strong>Iso</strong></td><td>&gt;&gt;&gt;</td><td>Traversal</td><td>=</td><td><strong>Traversal</strong></td><td>Traversal is most general</td></tr>
<tr><td><strong>Lens</strong></td><td>&gt;&gt;&gt;</td><td>Lens</td><td>=</td><td><strong>Lens</strong></td><td>Same type</td></tr>
<tr><td><strong>Lens</strong></td><td>&gt;&gt;&gt;</td><td>Prism</td><td>=</td><td><strong>Affine</strong></td><td>May not match (0-1 targets)</td></tr>
<tr><td><strong>Lens</strong></td><td>&gt;&gt;&gt;</td><td>Affine</td><td>=</td><td><strong>Affine</strong></td><td>Affine preserves partiality</td></tr>
<tr><td><strong>Lens</strong></td><td>&gt;&gt;&gt;</td><td>Traversal</td><td>=</td><td><strong>Traversal</strong></td><td>Traversal is more general</td></tr>
<tr><td><strong>Lens</strong></td><td>&gt;&gt;&gt;</td><td>Iso</td><td>=</td><td><strong>Lens</strong></td><td>Iso subsumes Lens</td></tr>
<tr><td><strong>Prism</strong></td><td>&gt;&gt;&gt;</td><td>Prism</td><td>=</td><td><strong>Prism</strong></td><td>Same type</td></tr>
<tr><td><strong>Prism</strong></td><td>&gt;&gt;&gt;</td><td>Lens</td><td>=</td><td><strong>Affine</strong></td><td>May not match + field access</td></tr>
<tr><td><strong>Prism</strong></td><td>&gt;&gt;&gt;</td><td>Affine</td><td>=</td><td><strong>Affine</strong></td><td>Affine preserves partiality</td></tr>
<tr><td><strong>Prism</strong></td><td>&gt;&gt;&gt;</td><td>Traversal</td><td>=</td><td><strong>Traversal</strong></td><td>Traversal is more general</td></tr>
<tr><td><strong>Prism</strong></td><td>&gt;&gt;&gt;</td><td>Iso</td><td>=</td><td><strong>Prism</strong></td><td>Iso subsumes Prism</td></tr>
<tr><td><strong>Affine</strong></td><td>&gt;&gt;&gt;</td><td>Affine</td><td>=</td><td><strong>Affine</strong></td><td>Same type</td></tr>
<tr><td><strong>Affine</strong></td><td>&gt;&gt;&gt;</td><td>Lens</td><td>=</td><td><strong>Affine</strong></td><td>Affine preserves partiality</td></tr>
<tr><td><strong>Affine</strong></td><td>&gt;&gt;&gt;</td><td>Prism</td><td>=</td><td><strong>Affine</strong></td><td>Both may not match</td></tr>
<tr><td><strong>Affine</strong></td><td>&gt;&gt;&gt;</td><td>Traversal</td><td>=</td><td><strong>Traversal</strong></td><td>Traversal is more general</td></tr>
<tr><td><strong>Affine</strong></td><td>&gt;&gt;&gt;</td><td>Iso</td><td>=</td><td><strong>Affine</strong></td><td>Iso subsumes Affine</td></tr>
<tr><td><strong>Traversal</strong></td><td>&gt;&gt;&gt;</td><td>any</td><td>=</td><td><strong>Traversal</strong></td><td>Traversal is already general</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="why-lens--prism--affine"><a class="header" href="#why-lens--prism--affine">Why Lens &gt;&gt;&gt; Prism = Affine</a></h2>
<p>This is perhaps the most important composition rule to understand.</p>
<h3 id="the-intuition"><a class="header" href="#the-intuition">The Intuition</a></h3>
<p>A <strong>Lens</strong> guarantees exactly one focus. A <strong>Prism</strong> provides zero-or-one focuses (it may not match).</p>
<p>When you compose them:</p>
<ul>
<li>The Lens always gets you to <code>A</code></li>
<li>The Prism may or may not get you from <code>A</code> to <code>B</code></li>
</ul>
<p>Result: <strong>zero-or-one</strong> focuses, which is an <strong>Affine</strong> optic.</p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<pre><code class="language-java">// Domain model
record Config(Optional&lt;DatabaseSettings&gt; database) {}
record DatabaseSettings(String host, int port) {}

// The Lens always gets the Optional&lt;DatabaseSettings&gt;
Lens&lt;Config, Optional&lt;DatabaseSettings&gt;&gt; databaseLens =
    Lens.of(Config::database, (c, db) -&gt; new Config(db));

// The Prism may or may not extract the DatabaseSettings
Prism&lt;Optional&lt;DatabaseSettings&gt;, DatabaseSettings&gt; somePrism = Prisms.some();

// Composition: Lens &gt;&gt;&gt; Prism = Affine
Affine&lt;Config, DatabaseSettings&gt; databaseAffine =
    databaseLens.andThen(somePrism);

// Usage
Config config1 = new Config(Optional.of(new DatabaseSettings("localhost", 5432)));
Optional&lt;DatabaseSettings&gt; result1 = databaseAffine.getOptional(config1);
// result1 = Optional[DatabaseSettings[host=localhost, port=5432]]

Config config2 = new Config(Optional.empty());
Optional&lt;DatabaseSettings&gt; result2 = databaseAffine.getOptional(config2);
// result2 = Optional.empty() (the prism didn't match)

// Setting always succeeds
Config updated = databaseAffine.set(new DatabaseSettings("newhost", 3306), config2);
// updated = Config[database=Optional[DatabaseSettings[host=newhost, port=3306]]]
</code></pre>
<hr />
<h2 id="why-prism--lens--affine"><a class="header" href="#why-prism--lens--affine">Why Prism &gt;&gt;&gt; Lens = Affine</a></h2>
<p>Similarly, composing a Prism first and then a Lens also yields an Affine.</p>
<h3 id="the-intuition-1"><a class="header" href="#the-intuition-1">The Intuition</a></h3>
<p>A <strong>Prism</strong> may or may not match. If it matches, the <strong>Lens</strong> always gets you to the field.</p>
<p>Result: <strong>zero-or-one</strong> focuses, depending on whether the Prism matched.</p>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<pre><code class="language-java">// Domain model with sealed interface
sealed interface Shape permits Circle, Rectangle {}
record Circle(double radius, String colour) implements Shape {}
record Rectangle(double width, double height, String colour) implements Shape {}

// The Prism may or may not match Circle
Prism&lt;Shape, Circle&gt; circlePrism = Prism.of(
    shape -&gt; shape instanceof Circle c ? Optional.of(c) : Optional.empty(),
    c -&gt; c
);

// The Lens always gets the radius from a Circle
Lens&lt;Circle, Double&gt; radiusLens =
    Lens.of(Circle::radius, (c, r) -&gt; new Circle(r, c.colour()));

// Composition: Prism &gt;&gt;&gt; Lens = Affine
Affine&lt;Shape, Double&gt; circleRadiusAffine = circlePrism.andThen(radiusLens);

// Usage
Shape circle = new Circle(5.0, "red");
Optional&lt;Double&gt; radius = circleRadiusAffine.getOptional(circle);
// radius = Optional[5.0]

Shape rectangle = new Rectangle(10.0, 20.0, "blue");
Optional&lt;Double&gt; empty = circleRadiusAffine.getOptional(rectangle);
// empty = Optional.empty() (prism didn't match)

// Modification only affects circles
Shape modified = circleRadiusAffine.modify(r -&gt; r * 2, circle);
// modified = Circle[radius=10.0, colour=red]

Shape unchanged = circleRadiusAffine.modify(r -&gt; r * 2, rectangle);
// unchanged = Rectangle[width=10.0, height=20.0, colour=blue] (unchanged)
</code></pre>
<hr />
<h2 id="available-composition-methods"><a class="header" href="#available-composition-methods">Available Composition Methods</a></h2>
<h3 id="direct-composition-recommended"><a class="header" href="#direct-composition-recommended">Direct Composition (Recommended)</a></h3>
<p>higher-kinded-j provides direct <code>andThen</code> methods that automatically return the correct type:</p>
<pre><code class="language-java">// Lens &gt;&gt;&gt; Lens = Lens
Lens&lt;A, C&gt; result = lensAB.andThen(lensBC);

// Lens &gt;&gt;&gt; Prism = Affine
Affine&lt;A, C&gt; result = lensAB.andThen(prismBC);

// Prism &gt;&gt;&gt; Prism = Prism
Prism&lt;A, C&gt; result = prismAB.andThen(prismBC);

// Prism &gt;&gt;&gt; Lens = Affine
Affine&lt;A, C&gt; result = prismAB.andThen(lensBC);

// Affine &gt;&gt;&gt; Affine = Affine
Affine&lt;A, C&gt; result = affineAB.andThen(affineBC);

// Affine &gt;&gt;&gt; Lens = Affine
Affine&lt;A, C&gt; result = affineAB.andThen(lensBC);

// Traversal &gt;&gt;&gt; Traversal = Traversal
Traversal&lt;A, C&gt; result = traversalAB.andThen(traversalBC);
</code></pre>
<h3 id="via-astraversal-universal-fallback"><a class="header" href="#via-astraversal-universal-fallback">Via asTraversal (Universal Fallback)</a></h3>
<p>When you need to compose optics in a generic way, convert everything to Traversal:</p>
<pre><code class="language-java">// Any optic composition via Traversal
Traversal&lt;A, D&gt; result =
    optic1.asTraversal()
        .andThen(optic2.asTraversal())
        .andThen(optic3.asTraversal());
</code></pre>
<p>This approach always works but loses type information (you get a Traversal even when a more specific type would be possible).</p>
<hr />
<h2 id="practical-guidelines"><a class="header" href="#practical-guidelines">Practical Guidelines</a></h2>
<h3 id="1-use-direct-composition-when-possible"><a class="header" href="#1-use-direct-composition-when-possible">1. Use Direct Composition When Possible</a></h3>
<pre><code class="language-java">// Preferred: uses direct andThen for correct return type
Traversal&lt;Config, String&gt; hostTraversal =
    databaseLens.andThen(somePrism).andThen(hostLens.asTraversal());
</code></pre>
<h3 id="2-chain-multiple-compositions"><a class="header" href="#2-chain-multiple-compositions">2. Chain Multiple Compositions</a></h3>
<pre><code class="language-java">// Multiple compositions
Traversal&lt;Order, String&gt; customerEmail =
    orderCustomerLens           // Lens&lt;Order, Customer&gt;
        .andThen(customerContactPrism)   // Prism&lt;Customer, ContactInfo&gt;
        .andThen(contactEmailLens.asTraversal());  // Lens&lt;ContactInfo, String&gt;
</code></pre>
<h3 id="3-store-complex-compositions-as-constants"><a class="header" href="#3-store-complex-compositions-as-constants">3. Store Complex Compositions as Constants</a></h3>
<pre><code class="language-java">public final class OrderOptics {
    // Reusable compositions
    public static final Traversal&lt;Order, String&gt; CUSTOMER_EMAIL =
        OrderLenses.customer()
            .andThen(CustomerPrisms.activeCustomer())
            .andThen(CustomerLenses.email().asTraversal());

    public static final Traversal&lt;Order, Money&gt; LINE_ITEM_PRICES =
        OrderTraversals.lineItems()
            .andThen(LineItemLenses.price().asTraversal());
}
</code></pre>
<hr />
<h2 id="common-patterns-2"><a class="header" href="#common-patterns-2">Common Patterns</a></h2>
<h3 id="pattern-1-optional-field-access"><a class="header" href="#pattern-1-optional-field-access">Pattern 1: Optional Field Access</a></h3>
<p>Navigate to an optional field that may not exist:</p>
<pre><code class="language-java">record User(String name, Optional&lt;Address&gt; address) {}
record Address(String street, String city) {}

// Lens to Optional, Prism to extract, Lens to field
Traversal&lt;User, String&gt; userCity =
    UserLenses.address()           // Lens&lt;User, Optional&lt;Address&gt;&gt;
        .andThen(Prisms.some())    // Prism&lt;Optional&lt;Address&gt;, Address&gt;
        .andThen(AddressLenses.city().asTraversal()); // Lens&lt;Address, String&gt;
</code></pre>
<h3 id="pattern-2-sum-type-field-access"><a class="header" href="#pattern-2-sum-type-field-access">Pattern 2: Sum Type Field Access</a></h3>
<p>Navigate into a specific case of a sealed interface:</p>
<pre><code class="language-java">sealed interface Payment permits CreditCard, BankTransfer {}
record CreditCard(String number, String expiry) implements Payment {}
record BankTransfer(String iban, String bic) implements Payment {}

// Prism to case, Lens to field
Traversal&lt;Payment, String&gt; creditCardNumber =
    PaymentPrisms.creditCard()     // Prism&lt;Payment, CreditCard&gt;
        .andThen(CreditCardLenses.number()); // Lens&lt;CreditCard, String&gt;
</code></pre>
<h3 id="pattern-3-conditional-collection-access"><a class="header" href="#pattern-3-conditional-collection-access">Pattern 3: Conditional Collection Access</a></h3>
<p>Navigate into items that match a condition:</p>
<pre><code class="language-java">// Traversal over list, filter by predicate
Traversal&lt;List&lt;Order&gt;, Order&gt; activeOrders =
    Traversals.&lt;Order&gt;forList()
        .andThen(Traversals.filtered(Order::isActive));
</code></pre>
<hr />
<h2 id="summary-12"><a class="header" href="#summary-12">Summary</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Composition</th><th>Result</th><th>Use Case</th></tr></thead><tbody>
<tr><td>Lens &gt;&gt;&gt; Lens</td><td>Lens</td><td>Nested product types (records)</td></tr>
<tr><td>Lens &gt;&gt;&gt; Prism</td><td>Affine</td><td>Product containing sum type</td></tr>
<tr><td>Prism &gt;&gt;&gt; Lens</td><td>Affine</td><td>Sum type containing product</td></tr>
<tr><td>Prism &gt;&gt;&gt; Prism</td><td>Prism</td><td>Nested sum types</td></tr>
<tr><td>Affine &gt;&gt;&gt; Affine</td><td>Affine</td><td>Chained optional access</td></tr>
<tr><td>Affine &gt;&gt;&gt; Lens</td><td>Affine</td><td>Optional then field access</td></tr>
<tr><td>Affine &gt;&gt;&gt; Prism</td><td>Affine</td><td>Optional then variant match</td></tr>
<tr><td>Any &gt;&gt;&gt; Traversal</td><td>Traversal</td><td>Collection access</td></tr>
<tr><td>Iso &gt;&gt;&gt; Any</td><td>Same as second</td><td>Type conversion first</td></tr>
</tbody></table>
</div>
<p>Understanding these rules helps you:</p>
<ul>
<li>Predict the type of composed optics</li>
<li>Choose the right composition approach</li>
<li>Design your domain model with optics in mind</li>
</ul>
<div id="admonition-hands-on-learning" class="admonition admonish-info" role="note" aria-labelledby="admonition-hands-on-learning-title">
<div class="admonition-title">
<div id="admonition-hands-on-learning-title">
<p>Hands-On Learning</p>
</div>
<a class="admonition-anchor-link" href="optics/composition_rules.html#admonition-hands-on-learning"></a>
</div>
<div>
<p>Practice lens composition in <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/optics/Tutorial02_LensComposition.java">Tutorial 02: Lens Composition</a> (7 exercises, ~10 minutes).</p>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="optics/traversals.html">Traversals</a>
<strong>Next:</strong> <a href="optics/cookbook.html">Optics Cookbook</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="optics-ii-collections"><a class="header" href="#optics-ii-collections">Optics II: Collections</a></h1>
<blockquote>
<p><em>"The world is full of abandoned meanings."</em></p>
<p>– Don DeLillo, <em>White Noise</em></p>
</blockquote>
<hr />
<p>Single values are straightforward enough. The challenge, as with so many things in programming, arrives when you need to handle <em>many</em> of them.</p>
<p>Consider an order containing a list of items, each with a price. Applying a discount to every price using standard Java means a stream, a map, a collector, and the nagging suspicion that there must be a better way. There is.</p>
<p>Traversals operate on zero-or-more values, typically the elements of a collection embedded within a larger structure. Where a Lens says "there is exactly one thing here," a Traversal says "there may be several things here, and I'd like to work with all of them, please." The politeness is implicit.</p>
<p>Folds are Traversal's read-only cousin. If you need to query, search, aggregate, or summarise without modification, a Fold makes your intent explicit. This matters more than it might seem: code that cannot accidentally modify data is code that behaves predictably at three in the morning when something has gone wrong.</p>
<p>This chapter covers both, along with Getters and Setters (the asymmetric specialists) and practical patterns for working with common Java collections. The monoid-based aggregation in Folds may initially seem academic, but it has a way of becoming indispensable once you've used it a few times.</p>
<hr />
<h2 id="traversal-vs-fold"><a class="header" href="#traversal-vs-fold">Traversal vs Fold</a></h2>
<p>The distinction is worth understanding clearly:</p>
<pre><code>┌─────────────────────────────────────────────────────────────┐
│                      TRAVERSAL                              │
│  ┌─────┐   ┌─────┐   ┌─────┐   ┌─────┐                     │
│  │  A  │   │  B  │   │  C  │   │  D  │  ← Focuses on all   │
│  └──┬──┘   └──┬──┘   └──┬──┘   └──┬──┘                     │
│     │        │        │        │                           │
│     ▼        ▼        ▼        ▼                           │
│   getAll ──────────────────────────→ [A, B, C, D]          │
│   modify(f) ───────────────────────→ [f(A), f(B), ...]     │
│   set(X) ──────────────────────────→ [X, X, X, X]          │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│                        FOLD                                 │
│  ┌─────┐   ┌─────┐   ┌─────┐   ┌─────┐                     │
│  │  A  │   │  B  │   │  C  │   │  D  │  ← Read-only        │
│  └──┬──┘   └──┬──┘   └──┬──┘   └──┬──┘                     │
│     │        │        │        │                           │
│     ▼        ▼        ▼        ▼                           │
│   getAll ──────────────────────────→ [A, B, C, D]          │
│   foldMap(monoid, f) ──────────────→ combined result       │
│   exists(predicate) ───────────────→ true/false            │
│   ✗ NO set or modify                                       │
└─────────────────────────────────────────────────────────────┘
</code></pre>
<p>Both can read. Only Traversal can write. Choose based on intent.</p>
<hr />
<h2 id="what-youll-learn-4"><a class="header" href="#what-youll-learn-4">What You'll Learn</a></h2>
<div id="admonition-in-this-chapter" class="admonition admonish-info" role="note" aria-labelledby="admonition-in-this-chapter-title">
<div class="admonition-title">
<div id="admonition-in-this-chapter-title">
<p>In This Chapter</p>
</div>
<a class="admonition-anchor-link" href="optics/ch2_intro.html#admonition-in-this-chapter"></a>
</div>
<div>
<ul>
<li><strong>Traversals</strong> – Focus on zero-or-more elements within a structure. Apply the same modification to every item in a list, or extract all values matching a path.</li>
<li><strong>Folds</strong> – Read-only traversal that aggregates results using a Monoid. Sum all prices, count matching elements, or check if any element satisfies a predicate.</li>
<li><strong>Getters</strong> – A read-only Lens. When you need to extract a value but never modify it, a Getter documents that intent in the type.</li>
<li><strong>Setters</strong> – A write-only optic. Modify values without reading them first, useful when the modification doesn't depend on the current value.</li>
<li><strong>Common Data Structures</strong> – Ready-made traversals for Java's standard collections. Iterate over List elements, Map entries, Set members, and more.</li>
<li><strong>Limiting Traversals</strong> – Take the first N elements, skip elements, or focus only on specific indices. Control exactly which elements a Traversal affects.</li>
</ul>
</div>
</div>
<hr />
<h2 id="chapter-contents-4"><a class="header" href="#chapter-contents-4">Chapter Contents</a></h2>
<ol>
<li><a href="optics/traversals.html">Traversals</a> - Bulk operations on collection elements</li>
<li><a href="optics/folds.html">Folds</a> - Read-only queries with monoid-based aggregation</li>
<li><a href="optics/getters.html">Getters</a> - Read-only focus on single values</li>
<li><a href="optics/setters.html">Setters</a> - Write-only modification without reading</li>
<li><a href="optics/common_data_structure_traversals.html">Common Data Structures</a> - Patterns for List, Map, Set, and more</li>
<li><a href="optics/limiting_traversals.html">Limiting Traversals</a> - First-N, take, and drop operations</li>
</ol>
<hr />
<p><strong>Next:</strong> <a href="optics/traversals.html">Traversals</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="traversals-practical-guide"><a class="header" href="#traversals-practical-guide">Traversals: Practical Guide</a></h1>
<h2 id="handling-bulk-updates"><a class="header" href="#handling-bulk-updates"><em>Handling Bulk Updates</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="optics/traversals.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to perform bulk operations on collections within immutable structures</li>
<li>Using <code>@GenerateTraversals</code> for automatic collection optics</li>
<li>Composing traversals with lenses and prisms for deep bulk updates</li>
<li>The <code>Traversals.modify()</code> and <code>Traversals.getAll()</code> utility methods</li>
<li>Understanding zero-or-more target semantics</li>
<li>When to use traversals vs streams vs manual loops for collection processing</li>
</ul>
</div>
</div>
<div id="admonition-hands-on-practice" class="admonition admonish-note" role="note" aria-labelledby="admonition-hands-on-practice-title">
<div class="admonition-title">
<div id="admonition-hands-on-practice-title">
<p>Hands On Practice</p>
</div>
<a class="admonition-anchor-link" href="optics/traversals.html#admonition-hands-on-practice"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/optics/Tutorial05_TraversalBasics.java">Tutorial05_TraversalBasics.java</a></p>
</div>
</div>
<div id="admonition-example-code" class="admonition admonish-note" role="note" aria-labelledby="admonition-example-code-title">
<div class="admonition-title">
<div id="admonition-example-code-title">
<p>Example Code</p>
</div>
<a class="admonition-anchor-link" href="optics/traversals.html#admonition-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/TraversalUsageExample.java">TraversalUsageExample</a></p>
</div>
</div>
<p>So far, our journey through optics has shown us how to handle singular focus:</p>
<ul>
<li>A <strong><code>Lens</code></strong> targets a part that <em>must</em> exist.</li>
<li>A <strong><code>Prism</code></strong> targets a part that <em>might</em> exist in one specific shape.</li>
<li>An <strong><code>Iso</code></strong> provides a two-way bridge between <em>equivalent</em> types.</li>
</ul>
<p>But what about operating on <em>many</em> items at once? How do we apply a single change to every element in a nested list? For this, we need the most general and powerful optic in our toolkit: the <strong>Traversal</strong>.</p>
<h2 id="the-scenario-updating-an-entire-league"><a class="header" href="#the-scenario-updating-an-entire-league">The Scenario: Updating an Entire League</a></h2>
<p>A <code>Traversal</code> is a functional "search-and-replace." It gives you a single tool to focus on zero or more items within a larger structure, allowing you to <code>get</code>, <code>set</code>, or <code>modify</code> all of them in one go.</p>
<p>This makes it the perfect optic for working with collections. Consider this data model of a sports league:</p>
<p><strong>The Data Model:</strong></p>
<pre><code class="language-java">public record Player(String name, int score) {}
public record Team(String name, List&lt;Player&gt; players) {}
public record League(String name, List&lt;Team&gt; teams) {}
</code></pre>
<p><strong>Our Goal:</strong> We need to give every single player in the entire league 5 bonus points. The traditional approach involves nested loops or streams, forcing us to manually reconstruct each immutable object along the way.</p>
<pre><code class="language-java">// Manual, verbose bulk update
List&lt;Team&gt; newTeams = league.teams().stream()
    .map(team -&gt; {
        List&lt;Player&gt; newPlayers = team.players().stream()
            .map(player -&gt; new Player(player.name(), player.score() + 5))
            .collect(Collectors.toList());
        return new Team(team.name(), newPlayers);
    })
    .collect(Collectors.toList());
League updatedLeague = new League(league.name(), newTeams);
</code></pre>
<p>This code is deeply nested and mixes the <em>what</em> (add 5 to a score) with the <em>how</em> (looping, collecting, and reconstructing). A <code>Traversal</code> lets us abstract away the "how" completely.</p>
<h2 id="think-of-traversals-like"><a class="header" href="#think-of-traversals-like">Think of Traversals Like...</a></h2>
<ul>
<li><strong>A spotlight</strong>: Illuminates many targets at once within a structure</li>
<li><strong>A search-and-replace tool</strong>: Finds all matching items and transforms them</li>
<li><strong>A bulk editor</strong>: Applies the same operation to multiple items efficiently</li>
<li><strong>A magnifying glass array</strong>: Like a lens, but for zero-to-many targets instead of exactly one</li>
</ul>
<h2 id="a-step-by-step-walkthrough-4"><a class="header" href="#a-step-by-step-walkthrough-4">A Step-by-Step Walkthrough</a></h2>
<h3 id="step-1-generating-traversals"><a class="header" href="#step-1-generating-traversals">Step 1: Generating Traversals</a></h3>
<p>The library provides a rich set of tools for creating <code>Traversal</code> instances, found in the <strong><code>Traversals</code></strong> utility class and through annotations.</p>
<ul>
<li><strong><code>@GenerateTraversals</code></strong>: Annotating a record will automatically generate a <code>Traversal</code> for any <code>Iterable</code> field (like <code>List</code> or <code>Set</code>).</li>
<li><strong><code>Traversals.forList()</code></strong>: A static helper that creates a traversal for the elements of a <code>List</code>.</li>
<li><strong><code>Traversals.forMap(key)</code></strong>: A static helper that creates a traversal focusing on the value for a specific key in a <code>Map</code>.</li>
</ul>
<pre><code class="language-java">import org.higherkindedj.optics.annotations.GenerateTraversals;
import java.util.List;

// We also add @GenerateLenses to get access to player fields
@GenerateLenses
public record Player(String name, int score) {}

@GenerateLenses
@GenerateTraversals // Traversal for List&lt;Player&gt;
public record Team(String name, List&lt;Player&gt; players) {}

@GenerateLenses
@GenerateTraversals // Traversal for List&lt;Team&gt;
public record League(String name, List&lt;Team&gt; teams) {}
</code></pre>
<h4 id="customising-the-generated-package-2"><a class="header" href="#customising-the-generated-package-2">Customising the Generated Package</a></h4>
<p>By default, generated classes are placed in the same package as the annotated record. You can specify a different package using the <code>targetPackage</code> attribute:</p>
<pre><code class="language-java">// Generated class will be placed in org.example.generated.optics
@GenerateTraversals(targetPackage = "org.example.generated.optics")
public record Team(String name, List&lt;Player&gt; players) {}
</code></pre>
<p>This is useful when you need to avoid name collisions or organise generated code separately.</p>
<h3 id="step-2-composing-a-deep-traversal"><a class="header" href="#step-2-composing-a-deep-traversal">Step 2: Composing a Deep Traversal</a></h3>
<p>Just like other optics, <code>Traversal</code>s can be composed with <code>andThen</code>. We can chain them together to create a single, deep traversal from the <code>League</code> all the way down to each player's <code>score</code>.</p>
<pre><code class="language-java">// Get generated optics
Traversal&lt;League, Team&gt; leagueToTeams = LeagueTraversals.teams();
Traversal&lt;Team, Player&gt; teamToPlayers = TeamTraversals.players();
Lens&lt;Player, Integer&gt; playerToScore = PlayerLenses.score();

// Compose them to create a single, deep traversal.
Traversal&lt;League, Integer&gt; leagueToAllPlayerScores =
    leagueToTeams
        .andThen(teamToPlayers)
        .andThen(playerToScore.asTraversal()); // Convert the final Lens
</code></pre>
<p>The result is a single <code>Traversal&lt;League, Integer&gt;</code> that declaratively represents the path to all player scores.</p>
<h3 id="step-3-using-the-traversal-with-helper-methods"><a class="header" href="#step-3-using-the-traversal-with-helper-methods">Step 3: Using the Traversal with Helper Methods</a></h3>
<p>The <code>Traversals</code> utility class provides convenient helper methods to perform the most common operations.</p>
<ul>
<li><strong><code>Traversals.modify(traversal, function, source)</code></strong>: Applies a pure function to all targets of a traversal.</li>
</ul>
<pre><code class="language-java">  // Use the composed traversal to add 5 bonus points to every score.
  League updatedLeague = Traversals.modify(leagueToAllPlayerScores, score -&gt; score + 5, league);
</code></pre>
<ul>
<li><strong><code>Traversals.getAll(traversal, source)</code></strong>: Extracts all targets of a traversal into a <code>List</code>.</li>
</ul>
<pre><code class="language-java">  // Get a flat list of all player scores in the league.
  List&lt;Integer&gt; allScores = Traversals.getAll(leagueToAllPlayerScores, league);
  // Result: [100, 90, 110, 120]
</code></pre>
<h2 id="when-to-use-traversals-vs-other-approaches"><a class="header" href="#when-to-use-traversals-vs-other-approaches">When to Use Traversals vs Other Approaches</a></h2>
<h3 id="use-traversals-when"><a class="header" href="#use-traversals-when">Use Traversals When:</a></h3>
<ul>
<li><strong>Bulk operations on nested collections</strong> - Applying the same operation to many items</li>
<li><strong>Type-safe collection manipulation</strong> - Working with collections inside immutable structures</li>
<li><strong>Reusable bulk logic</strong> - Creating operations that can be applied across different instances</li>
<li><strong>Effectful operations</strong> - Using <code>modifyF</code> for operations that might fail or have side effects</li>
</ul>
<pre><code class="language-java">// Perfect for bulk updates with type safety
Traversal&lt;Company, String&gt; allEmails = CompanyTraversals.employees()
    .andThen(EmployeeTraversals.contacts())
    .andThen(ContactLenses.email().asTraversal());

Company withNormalisedEmails = Traversals.modify(allEmails, String::toLowerCase, company);
</code></pre>
<h3 id="use-streams-when"><a class="header" href="#use-streams-when">Use Streams When:</a></h3>
<ul>
<li><strong>Complex transformations</strong> - Multiple operations that don't map cleanly to traversals</li>
<li><strong>Filtering and collecting</strong> - You need to change the collection structure</li>
<li><strong>Performance critical paths</strong> - Minimal abstraction overhead needed</li>
</ul>
<pre><code class="language-java">// Better with streams for complex logic
List&lt;String&gt; activePlayerNames = league.teams().stream()
    .flatMap(team -&gt; team.players().stream())
    .filter(player -&gt; player.score() &gt; 50)
    .map(Player::name)
    .sorted()
    .collect(toList());
</code></pre>
<h3 id="use-manual-loops-when"><a class="header" href="#use-manual-loops-when">Use Manual Loops When:</a></h3>
<ul>
<li><strong>Early termination needed</strong> - You might want to stop processing early</li>
<li><strong>Complex control flow</strong> - Multiple conditions and branches</li>
<li><strong>Imperative mindset</strong> - The operation is inherently procedural</li>
</ul>
<pre><code class="language-java">// Sometimes a loop is clearest
for (Team team : league.teams()) {
    for (Player player : team.players()) {
        if (player.score() &lt; 0) {
            throw new IllegalStateException("Negative score found: " + player);
        }
    }
}
</code></pre>
<hr />
<h2 id="common-pitfalls-13"><a class="header" href="#common-pitfalls-13">Common Pitfalls</a></h2>
<h3 id="dont-do-this-4"><a class="header" href="#dont-do-this-4">Don't Do This:</a></h3>
<pre><code class="language-java">// Inefficient: Creating traversals repeatedly
teams.forEach(team -&gt; {
    var traversal = TeamTraversals.players().andThen(PlayerLenses.score().asTraversal());
    Traversals.modify(traversal, score -&gt; score + 1, team);
});

// Over-engineering: Using traversals for simple cases
Traversal&lt;Player, String&gt; playerName = PlayerLenses.name().asTraversal();
String name = Traversals.getAll(playerName, player).get(0); // Just use player.name()!

// Type confusion: Forgetting that traversals work on zero-or-more targets
League emptyLeague = new League("Empty", List.of());
List&lt;Integer&gt; scores = Traversals.getAll(leagueToAllPlayerScores, emptyLeague); // Returns empty list
</code></pre>
<h3 id="do-this-instead-4"><a class="header" href="#do-this-instead-4">Do This Instead:</a></h3>
<pre><code class="language-java">// Efficient: Create traversals once, use many times
var scoreTraversal = LeagueTraversals.teams()
    .andThen(TeamTraversals.players())
    .andThen(PlayerLenses.score().asTraversal());

League bonusLeague = Traversals.modify(scoreTraversal, score -&gt; score + 5, league);
League doubledLeague = Traversals.modify(scoreTraversal, score -&gt; score * 2, league);

// Right tool for the job: Use direct access for single items
String playerName = player.name(); // Simple and clear

// Defensive: Handle empty collections gracefully  
List&lt;Integer&gt; allScores = Traversals.getAll(scoreTraversal, league);
OptionalDouble average = allScores.stream().mapToInt(Integer::intValue).average();
</code></pre>
<hr />
<h2 id="performance-notes-4"><a class="header" href="#performance-notes-4">Performance Notes</a></h2>
<p>Traversals are optimised for immutable updates:</p>
<ul>
<li><strong>Memory efficient</strong>: Only creates new objects along the path that changes</li>
<li><strong>Lazy evaluation</strong>: Stops early if no changes are needed</li>
<li><strong>Batch operations</strong>: <code>modifyF</code> processes all targets in a single pass</li>
<li><strong>Structural sharing</strong>: Unchanged parts of the data structure are reused</li>
</ul>
<p><strong>Best Practice</strong>: For frequently used traversal combinations, create them once and store as constants:</p>
<pre><code class="language-java">public class LeagueOptics {
    public static final Traversal&lt;League, Integer&gt; ALL_PLAYER_SCORES = 
        LeagueTraversals.teams()
            .andThen(TeamTraversals.players())
            .andThen(PlayerLenses.score().asTraversal());
      
    public static final Traversal&lt;League, String&gt; ALL_PLAYER_NAMES = 
        LeagueTraversals.teams()
            .andThen(TeamTraversals.players())
            .andThen(PlayerLenses.name().asTraversal());
}
</code></pre>
<hr />
<h2 id="common-patterns-3"><a class="header" href="#common-patterns-3">Common Patterns</a></h2>
<h3 id="validation-with-error-accumulation"><a class="header" href="#validation-with-error-accumulation">Validation with Error Accumulation</a></h3>
<pre><code class="language-java">// Validate all email addresses in a userLogin list
Traversal&lt;Company, String&gt; allEmails = CompanyTraversals.employees()
    .andThen(EmployeeTraversals.contactInfo())
    .andThen(ContactInfoLenses.email().asTraversal());

Function&lt;String, Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, String&gt;&gt; validateEmail = 
    email -&gt; email.contains("@") 
        ? VALIDATED.widen(Validated.valid(email))
        : VALIDATED.widen(Validated.invalid(List.of("Invalid email: " + email)));

Validated&lt;List&lt;String&gt;, Company&gt; result = VALIDATED.narrow(
    allEmails.modifyF(validateEmail, company, validatedApplicative)
);
</code></pre>
<h3 id="conditional-updates"><a class="header" href="#conditional-updates">Conditional Updates</a></h3>
<pre><code class="language-java">// Give bonus points only to high-performing players
Function&lt;Integer, Integer&gt; conditionalBonus = score -&gt; 
    score &gt;= 80 ? score + 10 : score;

League bonusLeague = Traversals.modify(
    LeagueOptics.ALL_PLAYER_SCORES, 
    conditionalBonus, 
    league
);
</code></pre>
<h3 id="data-transformation"><a class="header" href="#data-transformation">Data Transformation</a></h3>
<pre><code class="language-java">// Normalise all player names to title case
Function&lt;String, String&gt; titleCase = name -&gt; 
    Arrays.stream(name.toLowerCase().split(" "))
        .map(word -&gt; word.substring(0, 1).toUpperCase() + word.substring(1))
        .collect(joining(" "));

League normalisedLeague = Traversals.modify(
    LeagueOptics.ALL_PLAYER_NAMES,
    titleCase,
    league
);
</code></pre>
<h3 id="asynchronous-operations"><a class="header" href="#asynchronous-operations">Asynchronous Operations</a></h3>
<pre><code class="language-java">// Fetch additional player statistics asynchronously
Function&lt;Integer, CompletableFuture&lt;Integer&gt;&gt; fetchBonusPoints = 
    playerId -&gt; statsService.getBonusPoints(playerId);

CompletableFuture&lt;League&gt; enrichedLeague = CF.narrow(
    LeagueOptics.ALL_PLAYER_SCORES.modifyF(
        score -&gt; CF.widen(fetchBonusPoints.apply(score)),
        league,
        CompletableFutureMonad.INSTANCE
    )
);
</code></pre>
<hr />
<h2 id="list-manipulation-with-partsof"><a class="header" href="#list-manipulation-with-partsof">List Manipulation with <code>partsOf</code></a></h2>
<h3 id="treating-traversal-focuses-as-collections"><a class="header" href="#treating-traversal-focuses-as-collections"><em>Treating Traversal Focuses as Collections</em></a></h3>
<div id="admonition-what-youll-learn-1" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-1-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-1-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="optics/traversals.html#admonition-what-youll-learn-1"></a>
</div>
<div>
<ul>
<li>Converting a Traversal into a Lens on a List of elements</li>
<li>Using <code>partsOf</code> for sorting, reversing, and deduplicating focused elements</li>
<li>Convenience methods: <code>sorted</code>, <code>reversed</code>, <code>distinct</code></li>
<li>Understanding size mismatch behaviour and graceful degradation</li>
<li>When list-level operations on traversal targets are appropriate</li>
</ul>
</div>
</div>
<div id="admonition-example-code-1" class="admonition admonish-note" role="note" aria-labelledby="admonition-example-code-1-title">
<div class="admonition-title">
<div id="admonition-example-code-1-title">
<p>Example Code</p>
</div>
<a class="admonition-anchor-link" href="optics/traversals.html#admonition-example-code-1"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/PartsOfTraversalExample.java">PartsOfTraversalExample</a></p>
</div>
</div>
<p>So far, we've seen how traversals excel at applying the <em>same</em> operation to every focused element individually. But what if you need to perform operations that consider <em>all</em> focuses as a group? Sorting, reversing, or removing duplicates are inherently list-level operations: they require knowledge of the entire collection, not just individual elements.</p>
<p>This is where <code>partsOf</code> becomes invaluable. It bridges the gap between element-wise traversal operations and collection-level algorithms.</p>
<h3 id="think-of-partsof-like"><a class="header" href="#think-of-partsof-like">Think of partsOf Like...</a></h3>
<ul>
<li><strong>A "collect and redistribute" operation</strong>: Gather all targets, transform them as a group, then put them back</li>
<li><strong>A camera taking a snapshot</strong>: Capture all focused elements, edit the photo, then overlay the changes</li>
<li><strong>A postal sorting centre</strong>: Collect all parcels, sort them efficiently, then redistribute to addresses</li>
<li><strong>The bridge between trees and lists</strong>: Temporarily flatten a structure for list operations, then restore the shape</li>
</ul>
<h3 id="the-problem-element-wise-limitations"><a class="header" href="#the-problem-element-wise-limitations">The Problem: Element-Wise Limitations</a></h3>
<p>Consider this scenario: you have a catalogue of products across multiple categories, and you want to sort all prices from lowest to highest. With standard traversal operations, you're stuck:</p>
<pre><code class="language-java">// This doesn't work - modify operates on each element independently
Traversal&lt;Catalogue, Double&gt; allPrices = CatalogueTraversals.categories()
    .andThen(CategoryTraversals.products())
    .andThen(ProductLenses.price().asTraversal());

// This sorts nothing - each price is transformed in isolation
Catalogue result = Traversals.modify(allPrices, price -&gt; price, catalogue);
// Prices remain in original order!
</code></pre>
<p>The traversal has no way to "see" all prices simultaneously. Each element is processed independently, making sorting impossible.</p>
<h3 id="the-solution-partsof"><a class="header" href="#the-solution-partsof">The Solution: <code>partsOf</code></a></h3>
<p>The <code>partsOf</code> combinator transforms a <code>Traversal&lt;S, A&gt;</code> into a <code>Lens&lt;S, List&lt;A&gt;&gt;</code>, allowing you to:</p>
<ol>
<li><strong>Get</strong>: Extract all focused elements as a single list</li>
<li><strong>Manipulate</strong>: Apply any list operation (sort, reverse, filter, etc.)</li>
<li><strong>Set</strong>: Distribute the modified elements back to their original positions</li>
</ol>
<pre><code class="language-java">// Convert traversal to a lens on the list of all prices
Lens&lt;Catalogue, List&lt;Double&gt;&gt; pricesLens = Traversals.partsOf(allPrices);

// Get all prices as a list
List&lt;Double&gt; allPricesList = pricesLens.get(catalogue);
// Result: [999.99, 499.99, 799.99, 29.99, 49.99, 19.99]

// Sort the list
List&lt;Double&gt; sortedPrices = new ArrayList&lt;&gt;(allPricesList);
Collections.sort(sortedPrices);
// Result: [19.99, 29.99, 49.99, 499.99, 799.99, 999.99]

// Set the sorted prices back
Catalogue sortedCatalogue = pricesLens.set(sortedPrices, catalogue);
</code></pre>
<p><strong>The Magic</strong>: The sorted prices are distributed back to the <em>original positions</em> in the structure. The first product gets the lowest price, the second product gets the second-lowest, and so on, regardless of which category they belong to.</p>
<h3 id="convenience-methods-1"><a class="header" href="#convenience-methods-1">Convenience Methods</a></h3>
<p>The <code>Traversals</code> utility class provides convenience methods that combine <code>partsOf</code> with common list operations:</p>
<h4 id="sorted---natural-ordering"><a class="header" href="#sorted---natural-ordering"><code>sorted</code> - Natural Ordering</a></h4>
<pre><code class="language-java">Traversal&lt;List&lt;Product&gt;, Double&gt; priceTraversal =
    Traversals.&lt;Product&gt;forList().andThen(ProductLenses.price().asTraversal());

// Sort prices in ascending order
List&lt;Product&gt; sortedProducts = Traversals.sorted(priceTraversal, products);
</code></pre>
<h4 id="sorted---custom-comparator"><a class="header" href="#sorted---custom-comparator"><code>sorted</code> - Custom Comparator</a></h4>
<pre><code class="language-java">Traversal&lt;List&lt;Product&gt;, String&gt; nameTraversal =
    Traversals.&lt;Product&gt;forList().andThen(ProductLenses.name().asTraversal());

// Sort names case-insensitively
List&lt;Product&gt; sortedByName = Traversals.sorted(
    nameTraversal,
    String.CASE_INSENSITIVE_ORDER,
    products
);

// Sort by name length
List&lt;Product&gt; sortedByLength = Traversals.sorted(
    nameTraversal,
    Comparator.comparingInt(String::length),
    products
);
</code></pre>
<h4 id="reversed---invert-order"><a class="header" href="#reversed---invert-order"><code>reversed</code> - Invert Order</a></h4>
<pre><code class="language-java">Traversal&lt;Project, Integer&gt; priorityTraversal =
    ProjectTraversals.tasks().andThen(TaskLenses.priority().asTraversal());

// Reverse all priorities
Project reversedProject = Traversals.reversed(priorityTraversal, project);

// Useful for: inverting priority schemes, LIFO ordering, undo stacks
</code></pre>
<h4 id="distinct---remove-duplicates"><a class="header" href="#distinct---remove-duplicates"><code>distinct</code> - Remove Duplicates</a></h4>
<pre><code class="language-java">Traversal&lt;List&lt;Product&gt;, String&gt; tagTraversal =
    Traversals.&lt;Product&gt;forList().andThen(ProductLenses.tag().asTraversal());

// Remove duplicate tags (preserves first occurrence)
List&lt;Product&gt; deduplicatedProducts = Traversals.distinct(tagTraversal, products);
</code></pre>
<h3 id="understanding-size-mismatch-behaviour"><a class="header" href="#understanding-size-mismatch-behaviour">Understanding Size Mismatch Behaviour</a></h3>
<p>A crucial aspect of <code>partsOf</code> is how it handles size mismatches between the new list and the number of target positions:</p>
<p><strong>Fewer elements than positions</strong>: Original values are preserved in remaining positions.</p>
<pre><code class="language-java">// Original: 5 products with prices [100, 200, 300, 400, 500]
List&lt;Double&gt; partialPrices = List.of(10.0, 20.0, 30.0); // Only 3 values

List&lt;Product&gt; result = pricesLens.set(partialPrices, products);
// Result prices: [10.0, 20.0, 30.0, 400, 500]
// First 3 updated, last 2 unchanged
</code></pre>
<p><strong>More elements than positions</strong>: Extra elements are ignored.</p>
<pre><code class="language-java">// Original: 3 products
List&lt;Double&gt; extraPrices = List.of(10.0, 20.0, 30.0, 40.0, 50.0); // 5 values

List&lt;Product&gt; result = pricesLens.set(extraPrices, products);
// Result: Only first 3 prices used, 40.0 and 50.0 ignored
</code></pre>
<p>This graceful degradation makes <code>partsOf</code> safe to use even when you're not certain about the exact number of targets.</p>
<h3 id="lens-laws-compliance"><a class="header" href="#lens-laws-compliance">Lens Laws Compliance</a></h3>
<p>The <code>partsOf</code> combinator produces a lawful <code>Lens</code> when the list sizes match:</p>
<ul>
<li><strong>Get-Set Law</strong>: <code>set(get(s), s) = s</code></li>
<li><strong>Set-Get Law</strong>: <code>get(set(a, s)) = a</code> (when <code>a.size() = targets</code>)</li>
<li><strong>Set-Set Law</strong>: <code>set(b, set(a, s)) = set(b, s)</code></li>
</ul>
<p>When sizes don't match, the laws still hold for the elements that <em>are</em> provided.</p>
<h3 id="advanced-use-cases"><a class="header" href="#advanced-use-cases">Advanced Use Cases</a></h3>
<h4 id="combining-with-filtered-traversals"><a class="header" href="#combining-with-filtered-traversals">Combining with Filtered Traversals</a></h4>
<pre><code class="language-java">// Sort only in-stock product prices
Traversal&lt;List&lt;Product&gt;, Double&gt; inStockPrices =
    Traversals.&lt;Product&gt;forList()
        .filtered(p -&gt; p.stockLevel() &gt; 0)
        .andThen(ProductLenses.price().asTraversal());

List&lt;Product&gt; result = Traversals.sorted(inStockPrices, products);
// Out-of-stock products unchanged, in-stock prices sorted
</code></pre>
<h4 id="custom-list-algorithms"><a class="header" href="#custom-list-algorithms">Custom List Algorithms</a></h4>
<pre><code class="language-java">Lens&lt;Catalogue, List&lt;Double&gt;&gt; pricesLens = Traversals.partsOf(allPrices);
List&lt;Double&gt; prices = new ArrayList&lt;&gt;(pricesLens.get(catalogue));

// Apply any list algorithm:
Collections.shuffle(prices);              // Randomise
Collections.rotate(prices, 3);            // Circular rotation
prices.sort(Comparator.reverseOrder());   // Descending sort
prices.removeIf(p -&gt; p &lt; 10.0);          // Filter (with caveats)
</code></pre>
<h3 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h3>
<p><code>partsOf</code> operations traverse the structure twice:</p>
<ol>
<li><strong>Once for <code>get</code></strong>: Collect all focused elements</li>
<li><strong>Once for <code>set</code></strong>: Distribute modified elements back</li>
</ol>
<p>For very large structures with thousands of focuses, consider:</p>
<ul>
<li>Caching the lens if used repeatedly</li>
<li>Using direct stream operations if structure preservation isn't required</li>
<li>Profiling to ensure the abstraction overhead is acceptable</li>
</ul>
<p><strong>Best Practice</strong>: Create the <code>partsOf</code> lens once and reuse it:</p>
<pre><code class="language-java">public class CatalogueOptics {
    private static final Traversal&lt;Catalogue, Double&gt; ALL_PRICES =
        CatalogueTraversals.categories()
            .andThen(CategoryTraversals.products())
            .andThen(ProductLenses.price().asTraversal());

    public static final Lens&lt;Catalogue, List&lt;Double&gt;&gt; PRICES_AS_LIST =
        Traversals.partsOf(ALL_PRICES);
}
</code></pre>
<h3 id="common-pitfalls-with-partsof"><a class="header" href="#common-pitfalls-with-partsof">Common Pitfalls with partsOf</a></h3>
<h4 id="dont-do-this-5"><a class="header" href="#dont-do-this-5">Don't Do This:</a></h4>
<pre><code class="language-java">// Expecting distinct to reduce structure size
List&lt;Product&gt; products = List.of(
    new Product("Widget", 25.99),
    new Product("Gadget", 49.99),
    new Product("Widget", 30.00)  // Duplicate name
);

// This doesn't remove the third product!
List&lt;Product&gt; result = Traversals.distinct(nameTraversal, products);
// The new list of distinct names is shorter, so the third product keeps its original name.

// Wrong: Using partsOf when you need element-wise operations
Lens&lt;List&lt;Product&gt;, List&lt;Double&gt;&gt; lens = Traversals.partsOf(priceTraversal);
List&lt;Double&gt; prices = lens.get(products);
prices.forEach(p -&gt; System.out.println(p)); // Just use Traversals.getAll()!
</code></pre>
<h4 id="do-this-instead-5"><a class="header" href="#do-this-instead-5">Do This Instead:</a></h4>
<pre><code class="language-java">// Understand that structure is preserved, only values redistribute
List&lt;Product&gt; result = Traversals.distinct(nameTraversal, products);
// Third product keeps original price, gets redistributed unique name

// Use partsOf when you need list-level operations
Lens&lt;List&lt;Product&gt;, List&lt;Double&gt;&gt; lens = Traversals.partsOf(priceTraversal);
List&lt;Double&gt; prices = new ArrayList&lt;&gt;(lens.get(products));
Collections.sort(prices); // True list operation
lens.set(prices, products);

// For simple iteration, use getAll
Traversals.getAll(priceTraversal, products).forEach(System.out::println);
</code></pre>
<h3 id="when-to-use-partsof"><a class="header" href="#when-to-use-partsof">When to Use partsOf</a></h3>
<p><strong>Use partsOf when:</strong></p>
<ul>
<li>Sorting focused elements by their values</li>
<li>Reversing the order of focused elements</li>
<li>Removing duplicates whilst preserving structure</li>
<li>Applying list algorithms that require seeing all elements at once</li>
<li>Redistributing values across positions (e.g., load balancing)</li>
</ul>
<p><strong>Avoid partsOf when:</strong></p>
<ul>
<li>Simple iteration suffices (use <code>getAll</code>)</li>
<li>Element-wise transformation is needed (use <code>modify</code>)</li>
<li>You need to change the structure itself (use streams/filtering)</li>
<li>Performance is critical and structure is very large</li>
</ul>
<hr />
<h2 id="real-world-example-configuration-validation"><a class="header" href="#real-world-example-configuration-validation">Real-World Example: Configuration Validation</a></h2>
<pre><code class="language-java">// Configuration model
@GenerateLenses
@GenerateTraversals
public record ServerConfig(String name, List&lt;DatabaseConfig&gt; databases) {}

@GenerateLenses  
public record DatabaseConfig(String host, int port, String name) {}

// Validation traversal
public class ConfigValidation {
    private static final Traversal&lt;ServerConfig, Integer&gt; ALL_DB_PORTS = 
        ServerConfigTraversals.databases()
            .andThen(DatabaseConfigLenses.port().asTraversal());
  
    public static Validated&lt;List&lt;String&gt;, ServerConfig&gt; validateConfig(ServerConfig config) {
        Function&lt;Integer, Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Integer&gt;&gt; validatePort = 
            port -&gt; {
                if (port &gt;= 1024 &amp;&amp; port &lt;= 65535) {
                    return VALIDATED.widen(Validated.valid(port));
                } else {
                    return VALIDATED.widen(Validated.invalid(
                        List.of("Port " + port + " is out of valid range (1024-65535)")
                    ));
                }
            };
  
        return VALIDATED.narrow(
            ALL_DB_PORTS.modifyF(
                validatePort, 
                config, 
                ValidatedMonad.instance(Semigroups.list())
            )
        );
    }
}
</code></pre>
<h2 id="complete-runnable-example-3"><a class="header" href="#complete-runnable-example-3">Complete, Runnable Example</a></h2>
<p>This example demonstrates how to use the <code>with*</code> helpers for a targeted update and how to use a composed <code>Traversal</code> with the new utility methods for bulk operations.</p>
<pre><code class="language-java">package org.higherkindedj.example.optics;

import java.util.ArrayList;
import java.util.List;
import org.higherkindedj.optics.Lens;
import org.higherkindedj.optics.Traversal;
import org.higherkindedj.optics.annotations.GenerateLenses;
import org.higherkindedj.optics.annotations.GenerateTraversals;
import org.higherkindedj.optics.util.Traversals;

public class TraversalUsageExample {

    @GenerateLenses
    public record Player(String name, int score) {}
  
    @GenerateLenses
    @GenerateTraversals
    public record Team(String name, List&lt;Player&gt; players) {}
  
    @GenerateLenses
    @GenerateTraversals
    public record League(String name, List&lt;Team&gt; teams) {}
  
    public static void main(String[] args) {
        var team1 = new Team("Team Alpha", List.of(
            new Player("Alice", 100), 
            new Player("Bob", 90)
        ));
        var team2 = new Team("Team Bravo", List.of(
            new Player("Charlie", 110), 
            new Player("Diana", 120)
        ));
        var league = new League("Pro League", List.of(team1, team2));
  
        System.out.println("=== TRAVERSAL USAGE EXAMPLE ===");
        System.out.println("Original League: " + league);
        System.out.println("------------------------------------------");
  
        // --- SCENARIO 1: Using `with*` helpers for a targeted, shallow update ---
        System.out.println("--- Scenario 1: Shallow Update with `with*` Helpers ---");
        var teamToUpdate = league.teams().get(0);
        var updatedTeam = TeamLenses.withName(teamToUpdate, "Team Omega");
        var newTeamsList = new ArrayList&lt;&gt;(league.teams());
        newTeamsList.set(0, updatedTeam);
        var leagueWithUpdatedTeam = LeagueLenses.withTeams(league, newTeamsList);
  
        System.out.println("After updating one team's name:");
        System.out.println(leagueWithUpdatedTeam);
        System.out.println("------------------------------------------");
  
        // --- SCENARIO 2: Using composed Traversals for deep, bulk updates ---
        System.out.println("--- Scenario 2: Bulk Updates with Composed Traversals ---");
    
        // Create the composed traversal
        Traversal&lt;League, Integer&gt; leagueToAllPlayerScores =
            LeagueTraversals.teams()
                .andThen(TeamTraversals.players())
                .andThen(PlayerLenses.score().asTraversal());
  
        // Use the `modify` helper to add 5 bonus points to every score.
        League updatedLeague = Traversals.modify(leagueToAllPlayerScores, score -&gt; score + 5, league);
        System.out.println("After adding 5 bonus points to all players:");
        System.out.println(updatedLeague);
        System.out.println();
    
        // --- SCENARIO 3: Extracting data with `getAll` ---
        System.out.println("--- Scenario 3: Data Extraction ---");
    
        List&lt;Integer&gt; allScores = Traversals.getAll(leagueToAllPlayerScores, league);
        System.out.println("All player scores: " + allScores);
        System.out.println("Total players: " + allScores.size());
        System.out.println("Average score: " + allScores.stream().mapToInt(Integer::intValue).average().orElse(0.0));
        System.out.println();
    
        // --- SCENARIO 4: Conditional updates ---
        System.out.println("--- Scenario 4: Conditional Updates ---");
    
        // Give bonus points only to players with scores &gt;= 100
        League bonusLeague = Traversals.modify(
            leagueToAllPlayerScores, 
            score -&gt; score &gt;= 100 ? score + 20 : score, 
            league
        );
        System.out.println("After conditional bonus (20 points for scores &gt;= 100):");
        System.out.println(bonusLeague);
        System.out.println();
    
        // --- SCENARIO 5: Multiple traversals ---
        System.out.println("--- Scenario 5: Multiple Traversals ---");
    
        // Create a traversal for player names
        Traversal&lt;League, String&gt; leagueToAllPlayerNames =
            LeagueTraversals.teams()
                .andThen(TeamTraversals.players())
                .andThen(PlayerLenses.name().asTraversal());
    
        // Normalise all names to uppercase
        League upperCaseLeague = Traversals.modify(leagueToAllPlayerNames, String::toUpperCase, league);
        System.out.println("After converting all names to uppercase:");
        System.out.println(upperCaseLeague);
        System.out.println();
    
        // --- SCENARIO 6: Working with empty collections ---
        System.out.println("--- Scenario 6: Empty Collections ---");
    
        League emptyLeague = new League("Empty League", List.of());
        List&lt;Integer&gt; emptyScores = Traversals.getAll(leagueToAllPlayerScores, emptyLeague);
        League emptyAfterUpdate = Traversals.modify(leagueToAllPlayerScores, score -&gt; score + 100, emptyLeague);
    
        System.out.println("Empty league: " + emptyLeague);
        System.out.println("Scores from empty league: " + emptyScores);
        System.out.println("Empty league after update: " + emptyAfterUpdate);
    
        System.out.println("------------------------------------------");
        System.out.println("Original league unchanged: " + league);
    }
}
</code></pre>
<p><strong>Expected Output:</strong></p>
<pre><code>=== TRAVERSAL USAGE EXAMPLE ===
Original League: League[name=Pro League, teams=[Team[name=Team Alpha, players=[Player[name=Alice, score=100], Player[name=Bob, score=90]]], Team[name=Team Bravo, players=[Player[name=Charlie, score=110], Player[name=Diana, score=120]]]]]
------------------------------------------
--- Scenario 1: Shallow Update with `with*` Helpers ---
After updating one team's name:
League[name=Pro League, teams=[Team[name=Team Omega, players=[Player[name=Alice, score=100], Player[name=Bob, score=90]]], Team[name=Team Bravo, players=[Player[name=Charlie, score=110], Player[name=Diana, score=120]]]]]
------------------------------------------
--- Scenario 2: Bulk Updates with Composed Traversals ---
After adding 5 bonus points to all players:
League[name=Pro League, teams=[Team[name=Team Alpha, players=[Player[name=Alice, score=105], Player[name=Bob, score=95]]], Team[name=Team Bravo, players=[Player[name=Charlie, score=115], Player[name=Diana, score=125]]]]]

--- Scenario 3: Data Extraction ---
All player scores: [100, 90, 110, 120]
Total players: 4
Average score: 105.0

--- Scenario 4: Conditional Updates ---
After conditional bonus (20 points for scores &gt;= 100):
League[name=Pro League, teams=[Team[name=Team Alpha, players=[Player[name=Alice, score=120], Player[name=Bob, score=90]]], Team[name=Team Bravo, players=[Player[name=Charlie, score=130], Player[name=Diana, score=140]]]]]

--- Scenario 5: Multiple Traversals ---
After converting all names to uppercase:
League[name=Pro League, teams=[Team[name=Team Alpha, players=[Player[name=ALICE, score=100], Player[name=BOB, score=90]]], Team[name=Team Bravo, players=[Player[name=CHARLIE, score=110], Player[name=DIANA, score=120]]]]]

--- Scenario 6: Working with Empty Collections ---
Empty league: League[name=Empty League, teams=[]]
Scores from empty league: []
Empty league after update: League[name=Empty League, teams=[]]
------------------------------------------
Original league unchanged: League[name=Pro League, teams=[Team[name=Team Alpha, players=[Player[name=Alice, score=100], Player[name=Bob, score=90]]], Team[name=Team Bravo, players=[Player[name=Charlie, score=110], Player[name=Diana, score=120]]]]]
</code></pre>
<hr />
<div id="admonition-for-comprehension-integration" class="admonition admonish-tip" role="note" aria-labelledby="admonition-for-comprehension-integration-title">
<div class="admonition-title">
<div id="admonition-for-comprehension-integration-title">
<p>For Comprehension Integration</p>
</div>
<a class="admonition-anchor-link" href="optics/traversals.html#admonition-for-comprehension-integration"></a>
</div>
<div>
<p>For a fluent, comprehension-style API for traversal operations, see <a href="optics/../functional/for_comprehension.html#bulk-operations-with-fortraversal">For Comprehensions: Bulk Operations with ForTraversal</a>. This provides an alternative syntax for filtering, modifying, and collecting traversal targets within an applicative context.</p>
</div>
</div>
<hr />
<h2 id="unifying-the-concepts"><a class="header" href="#unifying-the-concepts">Unifying the Concepts</a></h2>
<p>A <code>Traversal</code> is the most general of the core optics. In fact, all other optics can be seen as specialised <code>Traversal</code>s:</p>
<ul>
<li>A <code>Lens</code> is just a <code>Traversal</code> that always focuses on <strong>exactly one</strong> item.</li>
<li>A <code>Prism</code> is just a <code>Traversal</code> that focuses on <strong>zero or one</strong> item.</li>
<li>An <code>Iso</code> is just a <code>Traversal</code> that focuses on <strong>exactly one</strong> item and is reversible.</li>
</ul>
<p>This is the reason they can all be composed together so seamlessly. By mastering <code>Traversal</code>, you complete your understanding of the core optics family, enabling you to build powerful, declarative, and safe data transformations that work efficiently across any number of targets.</p>
<div id="admonition-hands-on-learning" class="admonition admonish-info" role="note" aria-labelledby="admonition-hands-on-learning-title">
<div class="admonition-title">
<div id="admonition-hands-on-learning-title">
<p>Hands-On Learning</p>
</div>
<a class="admonition-anchor-link" href="optics/traversals.html#admonition-hands-on-learning"></a>
</div>
<div>
<p>Practice traversal basics in <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/optics/Tutorial05_TraversalBasics.java">Tutorial 05: Traversal Basics</a> (7 exercises, ~10 minutes).</p>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="optics/iso.html">Isomorphisms: Data Equivalence</a>
<strong>Next:</strong> <a href="optics/folds.html">Folds: Querying Immutable Data</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="folds-a-practical-guide"><a class="header" href="#folds-a-practical-guide">Folds: A Practical Guide</a></h1>
<h2 id="querying-immutable-data"><a class="header" href="#querying-immutable-data"><em>Querying Immutable Data</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="optics/folds.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to query and extract data from complex structures without modification</li>
<li>Using <code>@GenerateFolds</code> to create type-safe query optics automatically</li>
<li>Understanding the relationship between Fold and the Foldable type class</li>
<li>Aggregating data with monoids for sums, products, and custom combiners</li>
<li>Composing folds with other optics for deep, conditional queries</li>
<li>The difference between <code>getAll</code>, <code>preview</code>, <code>find</code>, <code>exists</code>, <code>all</code>, and <code>length</code></li>
<li>Maybe-based extensions for functional optional handling (<code>previewMaybe</code>, <code>findMaybe</code>, <code>getAllMaybe</code>)</li>
<li>When to use Fold vs Traversal vs direct field access vs Stream API</li>
<li>Building read-only data processing pipelines with clear intent</li>
</ul>
</div>
</div>
<div id="admonition-example-code" class="admonition admonish-note" role="note" aria-labelledby="admonition-example-code-title">
<div class="admonition-title">
<div id="admonition-example-code-title">
<p>Example Code</p>
</div>
<a class="admonition-anchor-link" href="optics/folds.html#admonition-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/FoldUsageExample.java">FoldUsageExample</a></p>
</div>
</div>
<p>In previous guides, we explored optics that allow both reading and writing: <strong><code>Lens</code></strong> for required fields, <strong><code>Prism</code></strong> for conditional variants, <strong><code>Iso</code></strong> for lossless conversions, and <strong><code>Traversal</code></strong> for bulk operations on collections.</p>
<p>But what if you need to perform read-only operations? What if you want to query, search, filter, or aggregate data without any possibility of modification? This is where <strong><code>Fold</code></strong> shines.</p>
<hr />
<h2 id="the-scenario-analysing-e-commerce-orders"><a class="header" href="#the-scenario-analysing-e-commerce-orders">The Scenario: Analysing E-Commerce Orders</a></h2>
<p>A <strong><code>Fold</code></strong> is a read-only optic designed specifically for querying and data extraction. Think of it as a <strong>database query tool</strong> or a <strong>telescope</strong> that lets you peer into your data structures, extract information, and aggregate results: all without the ability to modify anything.</p>
<p>Consider an e-commerce system where you need to analyse orders:</p>
<p><strong>The Data Model:</strong></p>
<pre><code class="language-java">@GenerateLenses
public record Product(String name, double price, String category, boolean inStock) {}

@GenerateLenses
@GenerateFolds  // Generate Folds for querying
public record Order(String orderId, List&lt;Product&gt; items, String customerName) {}

@GenerateLenses
@GenerateFolds
public record OrderHistory(List&lt;Order&gt; orders) {}
</code></pre>
<p><strong>Common Query Needs:</strong></p>
<ul>
<li>"Find all products in this order"</li>
<li>"Get the first product or empty if none"</li>
<li>"Check if any product is out of stock"</li>
<li>"Count how many items are in the order"</li>
<li>"Calculate the total price of all items"</li>
<li>"Check if all items are under £100"</li>
</ul>
<p>A <code>Fold</code> makes these queries type-safe, composable, and expressive.</p>
<hr />
<h2 id="think-of-folds-like"><a class="header" href="#think-of-folds-like">Think of Folds Like...</a></h2>
<ul>
<li><strong>A database query</strong>: Extracting specific data from complex structures</li>
<li><strong>A read-only telescope</strong>: Magnifying and examining data without touching it</li>
<li><strong>A search engine</strong>: Finding and collecting information efficiently</li>
<li><strong>An aggregation pipeline</strong>: Combining values according to rules (via monoids)</li>
<li><strong>A reporter</strong>: Summarising data into useful metrics</li>
</ul>
<hr />
<h2 id="fold-vs-traversal-understanding-the-difference"><a class="header" href="#fold-vs-traversal-understanding-the-difference">Fold vs Traversal: Understanding the Difference</a></h2>
<p>Before we dive deeper, it's crucial to understand how <code>Fold</code> relates to <code>Traversal</code>:</p>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th>Traversal</th><th>Fold</th></tr></thead><tbody>
<tr><td><strong>Purpose</strong></td><td>Read and modify collections</td><td>Read-only queries</td></tr>
<tr><td><strong>Can modify?</strong></td><td>Yes (<code>set</code>, <code>modify</code>)</td><td>No</td></tr>
<tr><td><strong>Query operations</strong></td><td>Yes (via <code>getAll</code>, but not primary purpose)</td><td>Yes (designed for this)</td></tr>
<tr><td><strong>Intent clarity</strong></td><td>"I might modify this"</td><td>"I'm only reading this"</td></tr>
<tr><td><strong>Conversion</strong></td><td>Can be converted to Fold via <code>asFold()</code></td><td>Cannot be converted to Traversal</td></tr>
<tr><td><strong>Use cases</strong></td><td>Bulk updates, validation with modifications</td><td>Queries, searches, aggregations</td></tr>
</tbody></table>
</div>
<p><strong>Key Insight</strong>: Every <code>Traversal</code> can be viewed as a <code>Fold</code> (read-only subset), but not every <code>Fold</code> can be a <code>Traversal</code>. By choosing <code>Fold</code> when you only need reading, you make your code's intent clear and prevent accidental modifications.</p>
<hr />
<h2 id="a-step-by-step-walkthrough-5"><a class="header" href="#a-step-by-step-walkthrough-5">A Step-by-Step Walkthrough</a></h2>
<h3 id="step-1-generating-folds"><a class="header" href="#step-1-generating-folds">Step 1: Generating Folds</a></h3>
<p>Just like with other optics, we use annotations to trigger automatic code generation. Annotating a record with <strong><code>@GenerateFolds</code></strong> creates a companion class (e.g., <code>OrderFolds</code>) containing a <code>Fold</code> for each field.</p>
<pre><code class="language-java">import org.higherkindedj.optics.annotations.GenerateFolds;
import org.higherkindedj.optics.annotations.GenerateLenses;
import java.util.List;

@GenerateLenses
public record Product(String name, double price, String category, boolean inStock) {}

@GenerateLenses
@GenerateFolds
public record Order(String orderId, List&lt;Product&gt; items, String customerName) {}
</code></pre>
<p>This generates:</p>
<ul>
<li><code>OrderFolds.items()</code> → <code>Fold&lt;Order, Product&gt;</code> (focuses on all products)</li>
<li><code>OrderFolds.orderId()</code> → <code>Fold&lt;Order, String&gt;</code> (focuses on the order ID)</li>
<li><code>OrderFolds.customerName()</code> → <code>Fold&lt;Order, String&gt;</code> (focuses on customer name)</li>
</ul>
<h4 id="customising-the-generated-package-3"><a class="header" href="#customising-the-generated-package-3">Customising the Generated Package</a></h4>
<p>By default, generated classes are placed in the same package as the annotated record. You can specify a different package using the <code>targetPackage</code> attribute:</p>
<pre><code class="language-java">// Generated class will be placed in org.example.generated.optics
@GenerateFolds(targetPackage = "org.example.generated.optics")
public record Order(String orderId, List&lt;Product&gt; items, String customerName) {}
</code></pre>
<p>This is useful when you need to avoid name collisions or organise generated code separately.</p>
<h3 id="step-2-the-core-fold-operations"><a class="header" href="#step-2-the-core-fold-operations">Step 2: The Core Fold Operations</a></h3>
<p>A <code>Fold&lt;S, A&gt;</code> provides these essential query operations:</p>
<h4 id="getallsource-extract-all-focused-values"><a class="header" href="#getallsource-extract-all-focused-values"><strong><code>getAll(source)</code></strong>: Extract All Focused Values</a></h4>
<p>Returns a <code>List&lt;A&gt;</code> containing all the values the Fold focuses on.</p>
<pre><code class="language-java">Fold&lt;Order, Product&gt; itemsFold = OrderFolds.items();
Order order = new Order("ORD-123", List.of(
    new Product("Laptop", 999.99, "Electronics", true),
    new Product("Mouse", 25.00, "Electronics", true),
    new Product("Desk", 350.00, "Furniture", false)
), "Alice");

List&lt;Product&gt; allProducts = itemsFold.getAll(order);
// Result: [Product[Laptop, 999.99, ...], Product[Mouse, 25.00, ...], Product[Desk, 350.00, ...]]
</code></pre>
<h4 id="previewsource-get-the-first-value"><a class="header" href="#previewsource-get-the-first-value"><strong><code>preview(source)</code></strong>: Get the First Value</a></h4>
<p>Returns an <code>Optional&lt;A&gt;</code> containing the first focused value, or <code>Optional.empty()</code> if none exist.</p>
<pre><code class="language-java">Optional&lt;Product&gt; firstProduct = itemsFold.preview(order);
// Result: Optional[Product[Laptop, 999.99, ...]]

Order emptyOrder = new Order("ORD-456", List.of(), "Bob");
Optional&lt;Product&gt; noProduct = itemsFold.preview(emptyOrder);
// Result: Optional.empty
</code></pre>
<h4 id="findpredicate-source-find-first-matching-value"><a class="header" href="#findpredicate-source-find-first-matching-value"><strong><code>find(predicate, source)</code></strong>: Find First Matching Value</a></h4>
<p>Returns an <code>Optional&lt;A&gt;</code> containing the first value that matches the predicate.</p>
<pre><code class="language-java">Optional&lt;Product&gt; expensiveProduct = itemsFold.find(
    product -&gt; product.price() &gt; 500.00,
    order
);
// Result: Optional[Product[Laptop, 999.99, ...]]
</code></pre>
<h4 id="existspredicate-source-check-if-any-match"><a class="header" href="#existspredicate-source-check-if-any-match"><strong><code>exists(predicate, source)</code></strong>: Check If Any Match</a></h4>
<p>Returns <code>true</code> if at least one focused value matches the predicate.</p>
<pre><code class="language-java">boolean hasOutOfStock = itemsFold.exists(
    product -&gt; !product.inStock(),
    order
);
// Result: true (Desk is out of stock)
</code></pre>
<h4 id="allpredicate-source-check-if-all-match"><a class="header" href="#allpredicate-source-check-if-all-match"><strong><code>all(predicate, source)</code></strong>: Check If All Match</a></h4>
<p>Returns <code>true</code> if all focused values match the predicate (returns <code>true</code> for empty collections).</p>
<pre><code class="language-java">boolean allInStock = itemsFold.all(
    product -&gt; product.inStock(),
    order
);
// Result: false (Desk is out of stock)
</code></pre>
<h4 id="isemptysource-check-for-empty"><a class="header" href="#isemptysource-check-for-empty"><strong><code>isEmpty(source)</code></strong>: Check for Empty</a></h4>
<p>Returns <code>true</code> if there are zero focused values.</p>
<pre><code class="language-java">boolean hasItems = !itemsFold.isEmpty(order);
// Result: true
</code></pre>
<h4 id="lengthsource-count-values"><a class="header" href="#lengthsource-count-values"><strong><code>length(source)</code></strong>: Count Values</a></h4>
<p>Returns the number of focused values as an <code>int</code>.</p>
<pre><code class="language-java">int itemCount = itemsFold.length(order);
// Result: 3
</code></pre>
<h3 id="step-25-maybe-based-fold-extensions"><a class="header" href="#step-25-maybe-based-fold-extensions">Step 2.5: Maybe-Based Fold Extensions</a></h3>
<div id="admonition-extension-methods" class="admonition admonish-note" role="note" aria-labelledby="admonition-extension-methods-title">
<div class="admonition-title">
<div id="admonition-extension-methods-title">
<p>Extension Methods</p>
</div>
<a class="admonition-anchor-link" href="optics/folds.html#admonition-extension-methods"></a>
</div>
<div>
<p>Higher-kinded-j provides extension methods that integrate <code>Fold</code> with the <code>Maybe</code> type, offering a more functional approach to handling absent values compared to Java's <code>Optional</code>. These extensions are available via static imports from <code>FoldExtensions</code>.</p>
</div>
</div>
<h4 id="the-challenge-working-with-nullable-values"><a class="header" href="#the-challenge-working-with-nullable-values">The Challenge: Working with Nullable Values</a></h4>
<p>Standard Fold operations use <code>Optional&lt;A&gt;</code> for operations that might not find a value (like <code>preview</code> and <code>find</code>). While <code>Optional</code> works well, functional programming often prefers <code>Maybe</code> because it:</p>
<ul>
<li>Integrates seamlessly with Higher-Kinded Types (HKT)</li>
<li>Works consistently with other monadic operations (<code>flatMap</code>, <code>map</code>, <code>fold</code>)</li>
<li>Provides better composition with validation and error handling types</li>
<li>Offers a more principled functional API</li>
</ul>
<p>Think of <code>Maybe</code> as <code>Optional</code>'s more functional cousin; they both represent "a value or nothing", but <code>Maybe</code> plays more nicely with the rest of the functional toolkit.</p>
<h4 id="think-of-maybe-based-extensions-like"><a class="header" href="#think-of-maybe-based-extensions-like">Think of Maybe-Based Extensions Like...</a></h4>
<ul>
<li><strong>A search that returns "found" or "not found"</strong> - <code>Maybe</code> explicitly models presence or absence</li>
<li><strong>A safe lookup in a dictionary</strong> - Either you get the value wrapped in <code>Just</code>, or you get <code>Nothing</code></li>
<li><strong>A nullable pointer that can't cause NPE</strong> - You must explicitly check before unwrapping</li>
<li><strong>Optional's functional sibling</strong> - Same concept, better integration with functional patterns</li>
</ul>
<h4 id="the-three-extension-methods"><a class="header" href="#the-three-extension-methods">The Three Extension Methods</a></h4>
<p>All three methods are static imports from <code>org.higherkindedj.optics.extensions.FoldExtensions</code>:</p>
<pre><code class="language-java">import static org.higherkindedj.optics.extensions.FoldExtensions.*;
</code></pre>
<h5 id="1-previewmaybefold-source---get-first-value-as-maybe"><a class="header" href="#1-previewmaybefold-source---get-first-value-as-maybe">1. <code>previewMaybe(fold, source)</code> - Get First Value as Maybe</a></h5>
<p>The <code>previewMaybe</code> method is the <code>Maybe</code>-based equivalent of <code>preview()</code>. It returns the first focused value wrapped in <code>Maybe</code>, or <code>Maybe.nothing()</code> if none exist.</p>
<pre><code class="language-java">import org.higherkindedj.hkt.maybe.Maybe;
import static org.higherkindedj.optics.extensions.FoldExtensions.previewMaybe;

Fold&lt;Order, Product&gt; itemsFold = OrderFolds.items();
Order order = new Order("ORD-123", List.of(
    new Product("Laptop", 999.99, "Electronics", true),
    new Product("Mouse", 25.00, "Electronics", true)
), "Alice");

Maybe&lt;Product&gt; firstProduct = previewMaybe(itemsFold, order);
// Result: Just(Product[Laptop, 999.99, ...])

Order emptyOrder = new Order("ORD-456", List.of(), "Bob");
Maybe&lt;Product&gt; noProduct = previewMaybe(itemsFold, emptyOrder);
// Result: Nothing
</code></pre>
<p><strong>When to use <code>previewMaybe</code> vs <code>preview</code>:</strong></p>
<ul>
<li>Use <code>previewMaybe</code> when working in a functional pipeline with other <code>Maybe</code> values</li>
<li>Use <code>preview</code> when interoperating with standard Java code expecting <code>Optional</code></li>
<li>Use <code>previewMaybe</code> when you need HKT compatibility for generic functional abstractions</li>
</ul>
<h5 id="2-findmaybefold-predicate-source---find-first-match-as-maybe"><a class="header" href="#2-findmaybefold-predicate-source---find-first-match-as-maybe">2. <code>findMaybe(fold, predicate, source)</code> - Find First Match as Maybe</a></h5>
<p>The <code>findMaybe</code> method is the <code>Maybe</code>-based equivalent of <code>find()</code>. It returns the first focused value matching the predicate, or <code>Maybe.nothing()</code> if no match is found.</p>
<pre><code class="language-java">import static org.higherkindedj.optics.extensions.FoldExtensions.findMaybe;

Fold&lt;Order, Product&gt; itemsFold = OrderFolds.items();

Maybe&lt;Product&gt; expensiveProduct = findMaybe(
    itemsFold,
    product -&gt; product.price() &gt; 500.00,
    order
);
// Result: Just(Product[Laptop, 999.99, ...])

Maybe&lt;Product&gt; luxuryProduct = findMaybe(
    itemsFold,
    product -&gt; product.price() &gt; 5000.00,
    order
);
// Result: Nothing
</code></pre>
<p><strong>Common Use Cases:</strong></p>
<ul>
<li><strong>Product search</strong>: Find first available item matching criteria</li>
<li><strong>Validation</strong>: Locate the first invalid field in a form</li>
<li><strong>Configuration</strong>: Find the first matching configuration option</li>
<li><strong>Inventory</strong>: Locate first in-stock item in a category</li>
</ul>
<h5 id="3-getallmaybefold-source---get-all-values-as-maybe-wrapped-list"><a class="header" href="#3-getallmaybefold-source---get-all-values-as-maybe-wrapped-list">3. <code>getAllMaybe(fold, source)</code> - Get All Values as Maybe-Wrapped List</a></h5>
<p>The <code>getAllMaybe</code> method returns all focused values as <code>Maybe&lt;List&lt;A&gt;&gt;</code>. If the Fold finds at least one value, you get <code>Just(List&lt;A&gt;)</code>. If it finds nothing, you get <code>Nothing</code>.</p>
<p>This is particularly useful when you want to distinguish between "found an empty collection" and "found no results".</p>
<pre><code class="language-java">import static org.higherkindedj.optics.extensions.FoldExtensions.getAllMaybe;

Fold&lt;Order, Product&gt; itemsFold = OrderFolds.items();

Maybe&lt;List&lt;Product&gt;&gt; allProducts = getAllMaybe(itemsFold, order);
// Result: Just([Product[Laptop, ...], Product[Mouse, ...]])

Order emptyOrder = new Order("ORD-456", List.of(), "Bob");
Maybe&lt;List&lt;Product&gt;&gt; noProducts = getAllMaybe(itemsFold, emptyOrder);
// Result: Nothing
</code></pre>
<p><strong>When to use <code>getAllMaybe</code> vs <code>getAll</code>:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Scenario</th><th>Use <code>getAll()</code></th><th>Use <code>getAllMaybe()</code></th></tr></thead><tbody>
<tr><td>You need the list regardless of emptiness</td><td>Returns <code>List&lt;A&gt;</code> (possibly empty)</td><td>Overkill</td></tr>
<tr><td>You want to treat empty results as a failure case</td><td>Must check <code>isEmpty()</code> manually</td><td>Returns <code>Nothing</code> for empty results</td></tr>
<tr><td>You're chaining functional operations with Maybe</td><td>Requires conversion</td><td>Directly composable</td></tr>
<tr><td>Performance-critical batch processing</td><td>Direct list access</td><td>Extra Maybe wrapping</td></tr>
</tbody></table>
</div>
<h4 id="real-world-scenario-product-search-with-maybe"><a class="header" href="#real-world-scenario-product-search-with-maybe">Real-World Scenario: Product Search with Maybe</a></h4>
<p>Here's a practical example showing how Maybe-based extensions simplify null-safe querying:</p>
<pre><code class="language-java">import org.higherkindedj.optics.Fold;
import org.higherkindedj.optics.annotations.GenerateFolds;
import org.higherkindedj.hkt.maybe.Maybe;
import static org.higherkindedj.optics.extensions.FoldExtensions.*;

@GenerateFolds
public record ProductCatalog(List&lt;Product&gt; products) {}

public class ProductSearchService {
    private static final Fold&lt;ProductCatalog, Product&gt; ALL_PRODUCTS =
        ProductCatalogFolds.products();

    // Find the cheapest in-stock product in a category
    public Maybe&lt;Product&gt; findCheapestInCategory(
        ProductCatalog catalog,
        String category
    ) {
        return getAllMaybe(ALL_PRODUCTS, catalog)
            .map(products -&gt; products.stream()
                .filter(p -&gt; category.equals(p.category()))
                .filter(Product::inStock)
                .min(Comparator.comparing(Product::price))
                .orElse(null)
            )
            .flatMap(Maybe::fromNullable);  // Convert null to Nothing
    }

    // Get first premium product (&gt;£1000)
    public Maybe&lt;Product&gt; findPremiumProduct(ProductCatalog catalog) {
        return findMaybe(
            ALL_PRODUCTS,
            product -&gt; product.price() &gt; 1000.00,
            catalog
        );
    }

    // Check if any products are available
    public boolean hasAvailableProducts(ProductCatalog catalog) {
        return getAllMaybe(ALL_PRODUCTS, catalog)
            .map(products -&gt; products.stream().anyMatch(Product::inStock))
            .getOrElse(false);
    }

    // Extract all product names (or empty message)
    public String getProductSummary(ProductCatalog catalog) {
        return getAllMaybe(ALL_PRODUCTS, catalog)
            .map(products -&gt; products.stream()
                .map(Product::name)
                .collect(Collectors.joining(", "))
            )
            .getOrElse("No products available");
    }
}
</code></pre>
<h4 id="optional-vs-maybe-a-comparison"><a class="header" href="#optional-vs-maybe-a-comparison">Optional vs Maybe: A Comparison</a></h4>
<p>Understanding when to use each type helps you make informed decisions:</p>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th><code>Optional&lt;A&gt;</code></th><th><code>Maybe&lt;A&gt;</code></th></tr></thead><tbody>
<tr><td><strong>Purpose</strong></td><td>Standard Java optional values</td><td>Functional optional values with HKT support</td></tr>
<tr><td><strong>Package</strong></td><td><code>java.util.Optional</code></td><td><code>org.higherkindedj.hkt.maybe.Maybe</code></td></tr>
<tr><td><strong>HKT Support</strong></td><td>No</td><td>Yes (integrates with <code>Kind&lt;F, A&gt;</code>)</td></tr>
<tr><td><strong>Monadic Operations</strong></td><td>Limited (<code>map</code>, <code>flatMap</code>, <code>filter</code>)</td><td>Full (<code>map</code>, <code>flatMap</code>, <code>filter</code>, <code>fold</code>, <code>getOrElse</code>, etc.)</td></tr>
<tr><td><strong>Java Interop</strong></td><td>Native support</td><td>Requires conversion</td></tr>
<tr><td><strong>Functional Composition</strong></td><td>Basic</td><td>Excellent (works with Applicative, Monad, etc.)</td></tr>
<tr><td><strong>Pattern Matching</strong></td><td><code>ifPresent()</code>, <code>orElse()</code></td><td><code>isJust()</code>, <code>isNothing()</code>, <code>fold()</code></td></tr>
<tr><td><strong>Use Cases</strong></td><td>Standard Java APIs, interop</td><td>Functional pipelines, HKT abstractions</td></tr>
<tr><td><strong>Conversion</strong></td><td><code>Maybe.fromOptional(opt)</code></td><td><code>maybe.toOptional()</code></td></tr>
</tbody></table>
</div>
<p><strong>Best Practice</strong>: Use <code>Optional</code> at API boundaries (public methods, external libraries) and <code>Maybe</code> internally in functional pipelines.</p>
<h4 id="when-to-use-each-extension-method"><a class="header" href="#when-to-use-each-extension-method">When to Use Each Extension Method</a></h4>
<p>Here's a decision matrix to help you choose the right method:</p>
<p><strong>Use <code>previewMaybe</code> when:</strong></p>
<ul>
<li>You need the first value from a Fold</li>
<li>You're working in a functional pipeline with other <code>Maybe</code> values</li>
<li>You want to chain operations (<code>map</code>, <code>flatMap</code>, <code>fold</code>) on the result</li>
<li>You need HKT compatibility</li>
</ul>
<pre><code class="language-java">// Example: Get first expensive product and calculate discount
Maybe&lt;Double&gt; discountedPrice = previewMaybe(productsFold, order)
    .filter(p -&gt; p.price() &gt; 100)
    .map(p -&gt; p.price() * 0.9);
</code></pre>
<p><strong>Use <code>findMaybe</code> when:</strong></p>
<ul>
<li>You need to locate a specific value matching a predicate</li>
<li>You want to avoid the verbosity of <code>getAll().stream().filter().findFirst()</code></li>
<li>You're building search functionality</li>
<li>You want to short-circuit on the first match (performance)</li>
</ul>
<pre><code class="language-java">// Example: Find first out-of-stock item
Maybe&lt;Product&gt; outOfStock = findMaybe(
    productsFold,
    p -&gt; !p.inStock(),
    order
);
</code></pre>
<p><strong>Use <code>getAllMaybe</code> when:</strong></p>
<ul>
<li>You want to treat empty results as a "nothing" case</li>
<li>You want to chain functional operations on the entire result set</li>
<li>You're building batch processing pipelines</li>
<li>You need to propagate "nothing found" through your computation</li>
</ul>
<pre><code class="language-java">// Example: Process all products or provide default behaviour
String report = getAllMaybe(productsFold, order)
    .map(products -&gt; generateReport(products))
    .getOrElse("No products to report");
</code></pre>
<h4 id="integration-with-existing-fold-operations"><a class="header" href="#integration-with-existing-fold-operations">Integration with Existing Fold Operations</a></h4>
<p>Maybe-based extensions work seamlessly alongside standard Fold operations. You can mix and match based on your needs:</p>
<pre><code class="language-java">Fold&lt;Order, Product&gt; itemsFold = OrderFolds.items();

// Standard Fold operations
List&lt;Product&gt; allItems = itemsFold.getAll(order);           // Always returns list
Optional&lt;Product&gt; firstOpt = itemsFold.preview(order);     // Optional-based
int count = itemsFold.length(order);                        // Primitive int

// Maybe-based extensions
Maybe&lt;Product&gt; firstMaybe = previewMaybe(itemsFold, order);     // Maybe-based
Maybe&lt;Product&gt; matchMaybe = findMaybe(itemsFold, p -&gt; ..., order);  // Maybe-based
Maybe&lt;List&lt;Product&gt;&gt; allMaybe = getAllMaybe(itemsFold, order);      // Maybe-wrapped list
</code></pre>
<p><strong>Conversion Between Optional and Maybe:</strong></p>
<pre><code class="language-java">// Convert Optional to Maybe
Optional&lt;Product&gt; optional = itemsFold.preview(order);
Maybe&lt;Product&gt; maybe = Maybe.fromOptional(optional);

// Convert Maybe to Optional
Maybe&lt;Product&gt; maybe = previewMaybe(itemsFold, order);
Optional&lt;Product&gt; optional = maybe.toOptional();
</code></pre>
<h4 id="performance-considerations-1"><a class="header" href="#performance-considerations-1">Performance Considerations</a></h4>
<p>Maybe-based extensions have minimal overhead:</p>
<ul>
<li><strong><code>previewMaybe</code></strong>: Same performance as <code>preview()</code>, just wraps in <code>Maybe</code> instead of <code>Optional</code></li>
<li><strong><code>findMaybe</code></strong>: Identical to <code>find()</code> - short-circuits on first match</li>
<li><strong><code>getAllMaybe</code></strong>: Adds one extra <code>Maybe</code> wrapping over <code>getAll()</code> - negligible cost</li>
</ul>
<p><strong>Optimisation Tip</strong>: For performance-critical code, prefer <code>getAll()</code> if you don't need the Maybe semantics. The extra wrapping and pattern matching adds a small but measurable cost in tight loops.</p>
<h4 id="practical-example-safe-navigation-with-maybe"><a class="header" href="#practical-example-safe-navigation-with-maybe">Practical Example: Safe Navigation with Maybe</a></h4>
<p>Combining <code>getAllMaybe</code> with composed folds creates powerful null-safe query pipelines:</p>
<pre><code class="language-java">import org.higherkindedj.optics.Fold;
import org.higherkindedj.hkt.maybe.Maybe;
import static org.higherkindedj.optics.extensions.FoldExtensions.*;

@GenerateFolds
public record OrderHistory(List&lt;Order&gt; orders) {}

public class OrderAnalytics {
    private static final Fold&lt;OrderHistory, Order&gt; ORDERS =
        OrderHistoryFolds.orders();
    private static final Fold&lt;Order, Product&gt; PRODUCTS =
        OrderFolds.items();

    // Calculate total revenue, handling empty history gracefully
    public double calculateRevenue(OrderHistory history) {
        return getAllMaybe(ORDERS, history)
            .flatMap(orders -&gt; {
                List&lt;Double&gt; prices = orders.stream()
                    .flatMap(order -&gt; getAllMaybe(PRODUCTS, order)
                        .map(products -&gt; products.stream().map(Product::price))
                        .getOrElse(Stream.empty()))
                    .toList();
                return prices.isEmpty() ? Maybe.nothing() : Maybe.just(prices);
            })
            .map(prices -&gt; prices.stream().mapToDouble(Double::doubleValue).sum())
            .getOrElse(0.0);
    }

    // Find most expensive product across all orders
    public Maybe&lt;Product&gt; findMostExpensive(OrderHistory history) {
        return getAllMaybe(ORDERS, history)
            .flatMap(orders -&gt; {
                List&lt;Product&gt; allProducts = orders.stream()
                    .flatMap(order -&gt; getAllMaybe(PRODUCTS, order)
                        .map(List::stream)
                        .getOrElse(Stream.empty()))
                    .toList();
                return allProducts.isEmpty()
                    ? Maybe.nothing()
                    : Maybe.fromNullable(allProducts.stream()
                        .max(Comparator.comparing(Product::price))
                        .orElse(null));
            });
    }
}
</code></pre>
<div id="admonition-complete-example" class="admonition admonish-note" role="note" aria-labelledby="admonition-complete-example-title">
<div class="admonition-title">
<div id="admonition-complete-example-title">
<p>Complete Example</p>
</div>
<a class="admonition-anchor-link" href="optics/folds.html#admonition-complete-example"></a>
</div>
<div>
<p>See <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/extensions/FoldExtensionsExample.java">FoldExtensionsExample.java</a> for a runnable demonstration of all Maybe-based Fold extensions.</p>
</div>
</div>
<hr />
<h3 id="step-3-composing-folds-for-deep-queries"><a class="header" href="#step-3-composing-folds-for-deep-queries">Step 3: Composing Folds for Deep Queries</a></h3>
<p>Folds can be composed with other optics to create deep query paths. When composing with <code>Lens</code>, <code>Prism</code>, or other <code>Fold</code> instances, use <code>andThen()</code>.</p>
<pre><code class="language-java">// Get all product names from all orders in history
Fold&lt;OrderHistory, Order&gt; historyToOrders = OrderHistoryFolds.orders();
Fold&lt;Order, Product&gt; orderToProducts = OrderFolds.items();
Lens&lt;Product, String&gt; productToName = ProductLenses.name();

Fold&lt;OrderHistory, String&gt; historyToAllProductNames =
    historyToOrders
        .andThen(orderToProducts)
        .andThen(productToName.asFold());

OrderHistory history = new OrderHistory(List.of(order1, order2, order3));
List&lt;String&gt; allProductNames = historyToAllProductNames.getAll(history);
// Result: ["Laptop", "Mouse", "Desk", "Keyboard", "Monitor", ...]
</code></pre>
<h3 id="step-4-aggregation-with-foldmap-and-monoids"><a class="header" href="#step-4-aggregation-with-foldmap-and-monoids">Step 4: Aggregation with <code>foldMap</code> and Monoids</a></h3>
<p>The most powerful feature of <code>Fold</code> is its ability to aggregate data using <strong>monoids</strong>. This is where Fold truly shines for combining values in flexible, reusable ways.</p>
<h4 id="understanding-monoids-the-simple-explanation"><a class="header" href="#understanding-monoids-the-simple-explanation">Understanding Monoids: The Simple Explanation</a></h4>
<p>Think of a monoid as a recipe for combining things. It needs two ingredients:</p>
<ol>
<li><strong>A starting value</strong> (called <code>empty</code>) - like starting with 0 when adding numbers, or "" when joining strings</li>
<li><strong>A combining rule</strong> (called <code>combine</code>) - like "add these two numbers" or "concatenate these two strings"</li>
</ol>
<p><strong>Simple Examples:</strong></p>
<ul>
<li><strong>Adding numbers</strong>: Start with 0, combine by adding → <code>0 + 5 + 10 + 3 = 18</code></li>
<li><strong>Joining strings</strong>: Start with "", combine by concatenating → <code>"" + "Hello" + " " + "World" = "Hello World"</code></li>
<li><strong>Finding maximum</strong>: Start with negative infinity, combine by taking larger value</li>
<li><strong>Checking all conditions</strong>: Start with <code>true</code>, combine with AND (&amp;&amp;) → all must be true</li>
</ul>
<h4 id="the-power-of-foldmap"><a class="header" href="#the-power-of-foldmap">The Power of <code>foldMap</code></a></h4>
<p>The <code>foldMap</code> method lets you:</p>
<ol>
<li>Transform each focused value into a "combinable" type</li>
<li>Automatically merge all those values using a monoid</li>
</ol>
<p><strong>Example: Calculate Total Price</strong></p>
<pre><code class="language-java">import org.higherkindedj.hkt.Monoid;

Fold&lt;Order, Product&gt; products = OrderFolds.items();

// Define how to combine prices (addition)
Monoid&lt;Double&gt; sumMonoid = new Monoid&lt;&gt;() {
    @Override
    public Double empty() { return 0.0; }  // Start with zero
    @Override
    public Double combine(Double a, Double b) { return a + b; }  // Add them
};

// Extract each product's price and sum them all
double totalPrice = products.foldMap(
    sumMonoid,
    product -&gt; product.price(),  // Extract price from each product
    order
);
// Result: 1374.99 (999.99 + 25.00 + 350.00)
</code></pre>
<p><strong>What's happening here?</strong></p>
<ol>
<li>For each <code>Product</code> in the order, extract its <code>price</code> → <code>[999.99, 25.00, 350.00]</code></li>
<li>Start with <code>0.0</code> (the empty value)</li>
<li>Combine them: <code>0.0 + 999.99 + 25.00 + 350.00 = 1374.99</code></li>
</ol>
<h4 id="common-monoid-patterns"><a class="header" href="#common-monoid-patterns">Common Monoid Patterns</a></h4>
<p>Here are the most useful monoid patterns for everyday use. <strong>Best Practice</strong>: Use the standard implementations from the <code>Monoids</code> utility class whenever possible:</p>
<pre><code class="language-java">import org.higherkindedj.hkt.Monoids;

// Standard monoids available out of the box:
Monoid&lt;Double&gt; sumDouble = Monoids.doubleAddition();
Monoid&lt;Double&gt; productDouble = Monoids.doubleMultiplication();
Monoid&lt;Integer&gt; sumInt = Monoids.integerAddition();
Monoid&lt;Integer&gt; productInt = Monoids.integerMultiplication();
Monoid&lt;Long&gt; sumLong = Monoids.longAddition();
Monoid&lt;Boolean&gt; andMonoid = Monoids.booleanAnd();
Monoid&lt;Boolean&gt; orMonoid = Monoids.booleanOr();
Monoid&lt;String&gt; stringConcat = Monoids.string();
Monoid&lt;List&lt;A&gt;&gt; listConcat = Monoids.list();
Monoid&lt;Set&lt;A&gt;&gt; setUnion = Monoids.set();
Monoid&lt;Optional&lt;A&gt;&gt; firstWins = Monoids.firstOptional();
Monoid&lt;Optional&lt;A&gt;&gt; lastWins = Monoids.lastOptional();
Monoid&lt;Optional&lt;A&gt;&gt; maxValue = Monoids.maximum();
Monoid&lt;Optional&lt;A&gt;&gt; minValue = Monoids.minimum();
</code></pre>
<p><strong>Sum (Adding Numbers)</strong></p>
<pre><code class="language-java">// Use standard monoid from Monoids class
Monoid&lt;Double&gt; sumMonoid = Monoids.doubleAddition();

// Calculate total revenue
double revenue = productsFold.foldMap(sumMonoid, ProductItem::price, order);
</code></pre>
<p><strong>Product (Multiplying Numbers)</strong></p>
<pre><code class="language-java">Monoid&lt;Double&gt; productMonoid = Monoids.doubleMultiplication();

// Calculate compound discount (e.g., 0.9 * 0.95 * 0.85)
double finalMultiplier = discountsFold.foldMap(productMonoid, d -&gt; d, discounts);
</code></pre>
<p><strong>String Concatenation</strong></p>
<pre><code class="language-java">Monoid&lt;String&gt; stringMonoid = Monoids.string();

// Join all product names
String allNames = productsFold.foldMap(stringMonoid, ProductItem::name, order);
</code></pre>
<p><strong>List Accumulation</strong></p>
<pre><code class="language-java">Monoid&lt;List&lt;String&gt;&gt; listMonoid = Monoids.list();

// Collect all categories (with duplicates)
List&lt;String&gt; categories = productsFold.foldMap(listMonoid,
    p -&gt; List.of(p.category()), order);
</code></pre>
<p><strong>Boolean AND (All Must Be True)</strong></p>
<pre><code class="language-java">Monoid&lt;Boolean&gt; andMonoid = Monoids.booleanAnd();

// Check if all products are in stock
boolean allInStock = productsFold.foldMap(andMonoid, ProductItem::inStock, order);
</code></pre>
<p><strong>Boolean OR (Any Can Be True)</strong></p>
<pre><code class="language-java">Monoid&lt;Boolean&gt; orMonoid = Monoids.booleanOr();

// Check if any product is expensive
boolean hasExpensive = productsFold.foldMap(orMonoid,
    p -&gt; p.price() &gt; 1000.0, order);
</code></pre>
<p><strong>Maximum Value</strong></p>
<pre><code class="language-java">// Use Optional-based maximum from Monoids
Monoid&lt;Optional&lt;Double&gt;&gt; maxMonoid = Monoids.maximum();

// Find highest price (returns Optional to handle empty collections)
Optional&lt;Double&gt; maxPrice = productsFold.foldMap(maxMonoid,
    p -&gt; Optional.of(p.price()), order);

// Or create a custom one for raw doubles:
Monoid&lt;Double&gt; rawMaxMonoid = new Monoid&lt;&gt;() {
    @Override public Double empty() { return Double.NEGATIVE_INFINITY; }
    @Override public Double combine(Double a, Double b) { return Math.max(a, b); }
};

double maxPriceRaw = productsFold.foldMap(rawMaxMonoid, ProductItem::price, order);
</code></pre>
<h4 id="why-monoids-matter"><a class="header" href="#why-monoids-matter">Why Monoids Matter</a></h4>
<p>Monoids give you:</p>
<ul>
<li><strong>Composability</strong>: Combine complex aggregations from simple building blocks</li>
<li><strong>Reusability</strong>: Define a monoid once, use it everywhere</li>
<li><strong>Correctness</strong>: The monoid laws guarantee consistent behaviour</li>
<li><strong>Flexibility</strong>: Create custom aggregations for your domain</li>
</ul>
<p><strong>Pro Tip</strong>: You can create custom monoids for any domain-specific aggregation logic, like calculating weighted averages, combining validation results, or merging configuration objects.</p>
<hr />
<h2 id="when-to-use-folds-vs-other-approaches"><a class="header" href="#when-to-use-folds-vs-other-approaches">When to Use Folds vs Other Approaches</a></h2>
<h3 id="use-fold-when"><a class="header" href="#use-fold-when">Use Fold When:</a></h3>
<ul>
<li><strong>Read-only queries</strong> - You only need to extract or check data</li>
<li><strong>Intent matters</strong> - You want to express "this is a query, not a modification"</li>
<li><strong>Composable searches</strong> - Building reusable query paths</li>
<li><strong>Aggregations</strong> - Using monoids for custom combining logic</li>
<li><strong>CQRS patterns</strong> - Separating queries from commands</li>
</ul>
<pre><code class="language-java">// Perfect for read-only analysis
Fold&lt;OrderHistory, Product&gt; allProducts =
    OrderHistoryFolds.orders()
        .andThen(OrderFolds.items());

boolean hasElectronics = allProducts.exists(
    p -&gt; "Electronics".equals(p.category()),
    history
);
</code></pre>
<h3 id="use-traversal-when-1"><a class="header" href="#use-traversal-when-1">Use Traversal When:</a></h3>
<ul>
<li><strong>Modifications needed</strong> - You need to update the data</li>
<li><strong>Effectful updates</strong> - Using <code>modifyF</code> for validation or async operations</li>
<li><strong>Bulk transformations</strong> - Changing multiple values at once</li>
</ul>
<pre><code class="language-java">// Use Traversal for modifications
Traversal&lt;Order, Product&gt; productTraversal = OrderTraversals.items();
Order discountedOrder = Traversals.modify(
    productTraversal.andThen(ProductLenses.price().asTraversal()),
    price -&gt; price * 0.9,
    order
);
</code></pre>
<h3 id="use-stream-api-when"><a class="header" href="#use-stream-api-when">Use Stream API When:</a></h3>
<ul>
<li><strong>Complex filtering</strong> - Multiple filter/map/reduce operations</li>
<li><strong>Parallel processing</strong> - Taking advantage of parallel streams</li>
<li><strong>Standard Java collections</strong> - Working with flat collections</li>
<li><strong>Stateful operations</strong> - Operations that require maintaining state</li>
</ul>
<pre><code class="language-java">// Better with streams for complex pipelines
List&lt;String&gt; topExpensiveItems = order.items().stream()
    .filter(p -&gt; p.price() &gt; 100)
    .sorted(Comparator.comparing(Product::price).reversed())
    .limit(5)
    .map(Product::name)
    .collect(toList());
</code></pre>
<h3 id="use-direct-field-access-when"><a class="header" href="#use-direct-field-access-when">Use Direct Field Access When:</a></h3>
<ul>
<li><strong>Simple cases</strong> - Single, straightforward field read</li>
<li><strong>Performance critical</strong> - Minimal abstraction overhead</li>
<li><strong>One-off operations</strong> - Not building reusable logic</li>
</ul>
<pre><code class="language-java">// Just use direct access for simple cases
String customerName = order.customerName();
</code></pre>
<hr />
<h2 id="common-pitfalls-14"><a class="header" href="#common-pitfalls-14">Common Pitfalls</a></h2>
<h3 id="dont-do-this-6"><a class="header" href="#dont-do-this-6">Don't Do This:</a></h3>
<pre><code class="language-java">// Inefficient: Creating folds repeatedly in loops
for (Order order : orders) {
    Fold&lt;Order, Product&gt; fold = OrderFolds.items();
    List&lt;Product&gt; products = fold.getAll(order);
    // ... process products
}

// Over-engineering: Using Fold for trivial single-field access
Fold&lt;Order, String&gt; customerFold = OrderFolds.customerName();
String name = customerFold.getAll(order).get(0); // Just use order.customerName()!

// Wrong tool: Trying to modify data with a Fold
// Folds are read-only - this won't compile
// Fold&lt;Order, Product&gt; items = OrderFolds.items();
// Order updated = items.set(newProduct, order); // ❌ No 'set' method!

// Verbose: Unnecessary conversion when Traversal is already available
Traversal&lt;Order, Product&gt; traversal = OrderTraversals.items();
Fold&lt;Order, Product&gt; fold = traversal.asFold();
List&lt;Product&gt; products = fold.getAll(order); // Just use Traversals.getAll() directly!
</code></pre>
<h3 id="do-this-instead-6"><a class="header" href="#do-this-instead-6">Do This Instead:</a></h3>
<pre><code class="language-java">// Efficient: Create fold once, reuse many times
Fold&lt;Order, Product&gt; itemsFold = OrderFolds.items();
for (Order order : orders) {
    List&lt;Product&gt; products = itemsFold.getAll(order);
    // ... process products
}

// Right tool: Direct access for simple cases
String name = order.customerName();

// Clear intent: Use Traversal when you need modifications
Traversal&lt;Order, Product&gt; itemsTraversal = OrderTraversals.items();
Order updated = Traversals.modify(itemsTraversal, this::applyDiscount, order);

// Clear purpose: Use Fold when expressing query intent
Fold&lt;Order, Product&gt; queryItems = OrderFolds.items();
boolean hasExpensive = queryItems.exists(p -&gt; p.price() &gt; 1000, order);
</code></pre>
<hr />
<h2 id="performance-notes-5"><a class="header" href="#performance-notes-5">Performance Notes</a></h2>
<p>Folds are optimised for query operations:</p>
<ul>
<li><strong>Memory efficient</strong>: Uses iterators internally, no intermediate collections for most operations</li>
<li><strong>Lazy evaluation</strong>: Short-circuits on operations like <code>find</code> and <code>exists</code> (stops at first match)</li>
<li><strong>Reusable</strong>: Composed folds can be stored and reused across your application</li>
<li><strong>Type-safe</strong>: All operations checked at compile time</li>
<li><strong>Zero allocation</strong>: <code>foldMap</code> with monoids avoids creating intermediate collections</li>
</ul>
<p><strong>Best Practice</strong>: For frequently used query paths, create them once and store as constants:</p>
<pre><code class="language-java">public class OrderQueries {
    public static final Fold&lt;OrderHistory, Product&gt; ALL_PRODUCTS =
        OrderHistoryFolds.orders()
            .andThen(OrderFolds.items());

    public static final Fold&lt;OrderHistory, Double&gt; ALL_PRICES =
        ALL_PRODUCTS.andThen(ProductLenses.price().asFold());

    public static final Fold&lt;Order, Product&gt; ELECTRONICS =
        OrderFolds.items(); // Can filter with exists/find/getAll + stream filter
}
</code></pre>
<hr />
<h2 id="real-world-example-order-analytics"><a class="header" href="#real-world-example-order-analytics">Real-World Example: Order Analytics</a></h2>
<p>Here's a practical example showing comprehensive use of Fold for business analytics:</p>
<pre><code class="language-java">import org.higherkindedj.optics.Fold;
import org.higherkindedj.optics.Lens;
import org.higherkindedj.optics.annotations.GenerateFolds;
import org.higherkindedj.optics.annotations.GenerateLenses;
import org.higherkindedj.hkt.Monoid;
import java.time.LocalDate;
import java.util.*;

@GenerateLenses
@GenerateFolds
public record Product(String name, double price, String category, boolean inStock) {}

@GenerateLenses
@GenerateFolds
public record Order(String orderId, List&lt;Product&gt; items, String customerName, LocalDate orderDate) {}

@GenerateLenses
@GenerateFolds
public record OrderHistory(List&lt;Order&gt; orders) {}

public class OrderAnalytics {
    private static final Fold&lt;Order, Product&gt; ORDER_ITEMS = OrderFolds.items();
    private static final Fold&lt;OrderHistory, Order&gt; HISTORY_ORDERS = OrderHistoryFolds.orders();
    private static final Fold&lt;OrderHistory, Product&gt; ALL_PRODUCTS =
        HISTORY_ORDERS.andThen(ORDER_ITEMS);

    private static final Monoid&lt;Double&gt; SUM_MONOID = new Monoid&lt;&gt;() {
        @Override public Double empty() { return 0.0; }
        @Override public Double combine(Double a, Double b) { return a + b; }
    };

    // Calculate total revenue across all orders
    public static double calculateRevenue(OrderHistory history) {
        return ALL_PRODUCTS.foldMap(SUM_MONOID, Product::price, history);
    }

    // Find most expensive product across all orders
    public static Optional&lt;Product&gt; findMostExpensiveProduct(OrderHistory history) {
        return ALL_PRODUCTS.getAll(history).stream()
            .max(Comparator.comparing(Product::price));
    }

    // Check if any order has out-of-stock items
    public static boolean hasOutOfStockIssues(OrderHistory history) {
        return ALL_PRODUCTS.exists(p -&gt; !p.inStock(), history);
    }

    // Get all unique categories
    public static Set&lt;String&gt; getAllCategories(OrderHistory history) {
        Fold&lt;OrderHistory, String&gt; categories =
            ALL_PRODUCTS.andThen(ProductLenses.category().asFold());
        return new HashSet&lt;&gt;(categories.getAll(history));
    }

    // Count products in a specific category
    public static int countByCategory(OrderHistory history, String category) {
        return (int) ALL_PRODUCTS.getAll(history).stream()
            .filter(p -&gt; category.equals(p.category()))
            .count();
    }

    // Calculate average order value
    public static double calculateAverageOrderValue(OrderHistory history) {
        List&lt;Order&gt; allOrders = HISTORY_ORDERS.getAll(history);
        if (allOrders.isEmpty()) return 0.0;

        double totalRevenue = calculateRevenue(history);
        return totalRevenue / allOrders.size();
    }

    // Find orders with specific product
    public static List&lt;Order&gt; findOrdersContaining(OrderHistory history, String productName) {
        return HISTORY_ORDERS.getAll(history).stream()
            .filter(order -&gt; ORDER_ITEMS.exists(
                p -&gt; productName.equals(p.name()),
                order
            ))
            .toList();
    }
}
</code></pre>
<hr />
<h2 id="the-relationship-to-foldable"><a class="header" href="#the-relationship-to-foldable">The Relationship to Foldable</a></h2>
<h3 id="quick-summary"><a class="header" href="#quick-summary">Quick Summary</a></h3>
<p>If you're just getting started, here's what you need to know: A <code>Fold&lt;S, A&gt;</code> is closely related to the <code>Foldable</code> type class from functional programming. While <code>Foldable&lt;F&gt;</code> works with any container type <code>F</code> (like <code>List</code>, <code>Optional</code>, <code>Tree</code>), a <code>Fold&lt;S, A&gt;</code> lets you treat any structure <code>S</code> as if it were a foldable container of <code>A</code> values: even when <code>S</code> isn't actually a collection.</p>
<p><strong>Key Connection</strong>: Both use <code>foldMap</code> to aggregate values using monoids. The <code>Fold</code> optic brings this powerful abstraction to arbitrary data structures, not just collections.</p>
<h3 id="in-depth-explanation"><a class="header" href="#in-depth-explanation">In-Depth Explanation</a></h3>
<p>For those familiar with functional programming or interested in the deeper theory:</p>
<h4 id="the-foldable-type-class"><a class="header" href="#the-foldable-type-class">The Foldable Type Class</a></h4>
<p>The <a href="optics/../functional/foldable_and_traverse.html"><code>Foldable&lt;F&gt;</code> type class</a> in higher-kinded-j represents any data structure <code>F</code> that can be "folded up" or reduced to a summary value. It's defined with this signature:</p>
<pre><code class="language-java">public interface Foldable&lt;F&gt; {
  &lt;A, M&gt; M foldMap(
      Monoid&lt;M&gt; monoid,
      Function&lt;? super A, ? extends M&gt; f,
      Kind&lt;F, A&gt; fa
  );
}
</code></pre>
<p>Common instances include:</p>
<ul>
<li><code>List&lt;A&gt;</code> - fold over all elements</li>
<li><code>Optional&lt;A&gt;</code> - fold over zero or one element</li>
<li><code>Either&lt;E, A&gt;</code> - fold over the right value if present</li>
<li><code>Tree&lt;A&gt;</code> - fold over all nodes in a tree</li>
</ul>
<h4 id="how-fold-relates-to-foldable"><a class="header" href="#how-fold-relates-to-foldable">How Fold Relates to Foldable</a></h4>
<p>A <code>Fold&lt;S, A&gt;</code> can be thought of as a <strong>first-class, composable lens into a Foldable structure</strong>. More precisely:</p>
<ol>
<li><strong>Virtualization</strong>: <code>Fold&lt;S, A&gt;</code> lets you "view" any structure <code>S</code> as a virtual <code>Foldable</code> container of <code>A</code> values, even if <code>S</code> is not inherently a collection</li>
<li><strong>Composition</strong>: Unlike <code>Foldable&lt;F&gt;</code>, which is fixed to a specific container type <code>F</code>, <code>Fold&lt;S, A&gt;</code> can be composed with other optics to create deep query paths</li>
<li><strong>Reification</strong>: A <code>Fold</code> reifies (makes concrete) the act of folding, turning it into a first-class value you can pass around, store, and combine</li>
</ol>
<p><strong>Example Comparison</strong>:</p>
<pre><code class="language-java">// Using Foldable directly on a List
Foldable&lt;ListKind.Witness&gt; listFoldable = ListTraverse.INSTANCE;
List&lt;Integer&gt; numbers = List.of(1, 2, 3, 4, 5);
int sum = listFoldable.foldMap(sumMonoid, Function.identity(), LIST.widen(numbers));

// Using a Fold optic to query nested structure
Fold&lt;Order, Integer&gt; quantities = OrderFolds.items()
    .andThen(ProductLenses.quantity().asFold());
int totalQuantity = quantities.foldMap(sumMonoid, Function.identity(), order);
</code></pre>
<p>The <code>Fold</code> optic gives you the power of <code>Foldable</code>, but for <strong>arbitrary access paths</strong> through your domain model, not just direct containers.</p>
<h4 id="fold-laws-and-foldable-laws"><a class="header" href="#fold-laws-and-foldable-laws">Fold Laws and Foldable Laws</a></h4>
<p>Both <code>Fold</code> and <code>Foldable</code> obey the same monoid laws:</p>
<ol>
<li><strong>Left identity</strong>: <code>combine(empty, x) = x</code></li>
<li><strong>Right identity</strong>: <code>combine(x, empty) = x</code></li>
<li><strong>Associativity</strong>: <code>combine(combine(x, y), z) = combine(x, combine(y, z))</code></li>
</ol>
<p>This means <code>foldMap</code> produces consistent, predictable results regardless of how the fold is internally structured.</p>
<h4 id="practical-implications"><a class="header" href="#practical-implications">Practical Implications</a></h4>
<p>Understanding this relationship helps you:</p>
<ul>
<li><strong>Transfer knowledge</strong>: If you learn <code>Foldable</code>, you understand the core of <code>Fold</code></li>
<li><strong>Recognise patterns</strong>: Monoid aggregation is universal across both abstractions</li>
<li><strong>Build intuition</strong>: A <code>Fold</code> is like having a custom <code>Foldable</code> instance for each access path in your domain</li>
<li><strong>Compose freely</strong>: You can convert between optics and type classes when needed (e.g., <code>Lens.asFold()</code>)</li>
</ul>
<p><strong>Further Reading</strong>:</p>
<ul>
<li><a href="optics/../functional/foldable_and_traverse.html">Foldable and Traverse in higher-kinded-j</a> - Deep dive into the type class</li>
<li><a href="https://hackage.haskell.org/package/lens-5.2.3/docs/Control-Lens-Fold.html">Haskell Lens Library - Folds</a> - The original inspiration</li>
<li><a href="https://leanpub.com/optics-by-example">Optics By Example (Book)</a> - Comprehensive treatment of folds in Haskell</li>
</ul>
<hr />
<h2 id="complete-runnable-example-4"><a class="header" href="#complete-runnable-example-4">Complete, Runnable Example</a></h2>
<p>This example demonstrates all major Fold operations in a single, cohesive application:</p>
<pre><code class="language-java">package org.higherkindedj.example.optics;

import org.higherkindedj.optics.Fold;
import org.higherkindedj.optics.Lens;
import org.higherkindedj.optics.annotations.GenerateFolds;
import org.higherkindedj.optics.annotations.GenerateLenses;
import org.higherkindedj.hkt.Monoid;
import org.higherkindedj.hkt.Monoids;
import java.util.*;

public class FoldUsageExample {

    @GenerateLenses
    @GenerateFolds
    public record ProductItem(String name, double price, String category, boolean inStock) {}

    @GenerateLenses
    @GenerateFolds
    public record Order(String orderId, List&lt;ProductItem&gt; items, String customerName) {}

    @GenerateLenses
    @GenerateFolds
    public record OrderHistory(List&lt;Order&gt; orders) {}

    public static void main(String[] args) {
        // Create sample data
        var order1 = new Order("ORD-001", List.of(
            new ProductItem("Laptop", 999.99, "Electronics", true),
            new ProductItem("Mouse", 25.00, "Electronics", true),
            new ProductItem("Desk", 350.00, "Furniture", false)
        ), "Alice");

        var order2 = new Order("ORD-002", List.of(
            new ProductItem("Keyboard", 75.00, "Electronics", true),
            new ProductItem("Monitor", 450.00, "Electronics", true),
            new ProductItem("Chair", 200.00, "Furniture", true)
        ), "Bob");

        var history = new OrderHistory(List.of(order1, order2));

        System.out.println("=== FOLD USAGE EXAMPLE ===\n");

        // --- SCENARIO 1: Basic Query Operations ---
        System.out.println("--- Scenario 1: Basic Query Operations ---");
        Fold&lt;Order, ProductItem&gt; itemsFold = OrderFolds.items();

        List&lt;ProductItem&gt; allItems = itemsFold.getAll(order1);
        System.out.println("All items: " + allItems.size() + " products");

        Optional&lt;ProductItem&gt; firstItem = itemsFold.preview(order1);
        System.out.println("First item: " + firstItem.map(ProductItem::name).orElse("none"));

        int count = itemsFold.length(order1);
        System.out.println("Item count: " + count);

        boolean isEmpty = itemsFold.isEmpty(order1);
        System.out.println("Is empty: " + isEmpty + "\n");

        // --- SCENARIO 2: Conditional Queries ---
        System.out.println("--- Scenario 2: Conditional Queries ---");

        boolean hasOutOfStock = itemsFold.exists(p -&gt; !p.inStock(), order1);
        System.out.println("Has out of stock items: " + hasOutOfStock);

        boolean allInStock = itemsFold.all(ProductItem::inStock, order1);
        System.out.println("All items in stock: " + allInStock);

        Optional&lt;ProductItem&gt; expensiveItem = itemsFold.find(p -&gt; p.price() &gt; 500, order1);
        System.out.println("First expensive item: " + expensiveItem.map(ProductItem::name).orElse("none") + "\n");

        // --- SCENARIO 3: Composition ---
        System.out.println("--- Scenario 3: Composed Folds ---");

        Fold&lt;OrderHistory, ProductItem&gt; allProducts =
            OrderHistoryFolds.orders().andThen(OrderFolds.items());

        List&lt;ProductItem&gt; allProductsFromHistory = allProducts.getAll(history);
        System.out.println("Total products across all orders: " + allProductsFromHistory.size());

        Fold&lt;OrderHistory, String&gt; allCategories =
            allProducts.andThen(ProductItemLenses.category().asFold());

        Set&lt;String&gt; uniqueCategories = new HashSet&lt;&gt;(allCategories.getAll(history));
        System.out.println("Unique categories: " + uniqueCategories + "\n");

        // --- SCENARIO 4: Monoid Aggregation ---
        System.out.println("--- Scenario 4: Monoid-Based Aggregation ---");

        // Use standard monoids from Monoids utility class
        Monoid&lt;Double&gt; sumMonoid = Monoids.doubleAddition();

        double orderTotal = itemsFold.foldMap(sumMonoid, ProductItem::price, order1);
        System.out.println("Order 1 total: £" + String.format("%.2f", orderTotal));

        double historyTotal = allProducts.foldMap(sumMonoid, ProductItem::price, history);
        System.out.println("All orders total: £" + String.format("%.2f", historyTotal));

        // Boolean AND monoid for checking conditions
        Monoid&lt;Boolean&gt; andMonoid = Monoids.booleanAnd();

        boolean allAffordable = itemsFold.foldMap(andMonoid, p -&gt; p.price() &lt; 1000, order1);
        System.out.println("All items under £1000: " + allAffordable);

        // Boolean OR monoid for checking any condition
        Monoid&lt;Boolean&gt; orMonoid = Monoids.booleanOr();

        boolean hasElectronics = allProducts.foldMap(orMonoid,
            p -&gt; "Electronics".equals(p.category()), history);
        System.out.println("Has electronics: " + hasElectronics + "\n");

        // --- SCENARIO 5: Analytics ---
        System.out.println("--- Scenario 5: Real-World Analytics ---");

        // Most expensive product
        Optional&lt;ProductItem&gt; mostExpensive = allProducts.getAll(history).stream()
            .max(Comparator.comparing(ProductItem::price));
        System.out.println("Most expensive product: " +
            mostExpensive.map(p -&gt; p.name() + " (£" + p.price() + ")").orElse("none"));

        // Average price
        List&lt;ProductItem&gt; allProds = allProducts.getAll(history);
        double avgPrice = allProds.isEmpty() ? 0.0 :
            historyTotal / allProds.size();
        System.out.println("Average product price: £" + String.format("%.2f", avgPrice));

        // Count by category
        long electronicsCount = allProducts.getAll(history).stream()
            .filter(p -&gt; "Electronics".equals(p.category()))
            .count();
        System.out.println("Electronics count: " + electronicsCount);

        System.out.println("\n=== END OF EXAMPLE ===");
    }
}
</code></pre>
<p><strong>Expected Output:</strong></p>
<pre><code>=== FOLD USAGE EXAMPLE ===

--- Scenario 1: Basic Query Operations ---
All items: 3 products
First item: Laptop
Item count: 3
Is empty: false

--- Scenario 2: Conditional Queries ---
Has out of stock items: true
All items in stock: false
First expensive item: Laptop

--- Scenario 3: Composed Folds ---
Total products across all orders: 6
Unique categories: [Electronics, Furniture]

--- Scenario 4: Monoid-Based Aggregation ---
Order 1 total: £1374.99
All orders total: £2099.99
All items under £1000: true
Has electronics: true

--- Scenario 5: Real-World Analytics ---
Most expensive product: Laptop (£999.99)
Average product price: £349.99
Electronics count: 4

=== END OF EXAMPLE ===
</code></pre>
<hr />
<h2 id="why-folds-are-essential"><a class="header" href="#why-folds-are-essential">Why Folds Are Essential</a></h2>
<p><code>Fold</code> completes the optics toolkit by providing:</p>
<ul>
<li><strong>Clear Intent</strong>: Explicitly read-only operations prevent accidental modifications</li>
<li><strong>Composability</strong>: Chain folds with other optics for deep queries</li>
<li><strong>Aggregation Power</strong>: Use monoids for flexible, reusable combining logic</li>
<li><strong>Type Safety</strong>: All queries checked at compile time</li>
<li><strong>Reusability</strong>: Build query libraries tailored to your domain</li>
<li><strong>CQRS Support</strong>: Separate query models from command models cleanly</li>
<li><strong>Performance</strong>: Optimised for read-only access with short-circuiting and lazy evaluation</li>
</ul>
<p>By adding <code>Fold</code> to your arsenal alongside <code>Lens</code>, <code>Prism</code>, <code>Iso</code>, and <code>Traversal</code>, you have complete coverage for both reading and writing immutable data structures in a type-safe, composable way.</p>
<p>The key insight: <strong>Folds make queries first-class citizens in your codebase</strong>, just as valuable and well-designed as the commands that modify state.</p>
<hr />
<p><strong>Previous:</strong> <a href="optics/traversals.html">Traversals: Handling Bulk Updates</a>
<strong>Next:</strong> <a href="optics/filtered_optics.html">Filtered Optics: Predicate-Based Composition</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="getters-a-practical-guide"><a class="header" href="#getters-a-practical-guide">Getters: A Practical Guide</a></h1>
<h2 id="composable-read-only-access"><a class="header" href="#composable-read-only-access"><em>Composable Read-Only Access</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="optics/getters.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to extract values from structures using composable, read-only optics</li>
<li>Using <code>@GenerateGetters</code> to create type-safe value extractors automatically</li>
<li>Understanding the relationship between Getter and Fold</li>
<li>Creating computed and derived values without storing them</li>
<li>Composing Getters with other optics for deep data extraction</li>
<li>Factory methods: <code>of</code>, <code>to</code>, <code>constant</code>, <code>identity</code>, <code>first</code>, <code>second</code></li>
<li>Null-safe navigation with <code>getMaybe</code> for functional optional handling</li>
<li>When to use Getter vs Lens vs direct field access</li>
<li>Building data transformation pipelines with clear read-only intent</li>
</ul>
</div>
</div>
<div id="admonition-example-code" class="admonition admonish-note" role="note" aria-labelledby="admonition-example-code-title">
<div class="admonition-title">
<div id="admonition-example-code-title">
<p>Example Code</p>
</div>
<a class="admonition-anchor-link" href="optics/getters.html#admonition-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/GetterUsageExample.java">GetterUsageExample</a></p>
</div>
</div>
<p>In previous guides, we explored <strong><code>Fold</code></strong> for querying zero or more elements from a structure. But what if you need to extract exactly one value? What if you want a composable accessor for a single, guaranteed-to-exist value? This is where <strong><code>Getter</code></strong> excels.</p>
<p>A <strong><code>Getter</code></strong> is the simplest read-only optic: it extracts precisely one value from a source. Think of it as a <strong>function wrapped in optic form</strong>, enabling composition with other optics whilst maintaining read-only semantics.</p>
<hr />
<h2 id="the-scenario-employee-reporting-system"><a class="header" href="#the-scenario-employee-reporting-system">The Scenario: Employee Reporting System</a></h2>
<p>Consider a corporate reporting system where you need to extract various pieces of information from employee records:</p>
<p><strong>The Data Model:</strong></p>
<pre><code class="language-java">@GenerateGetters
public record Person(String firstName, String lastName, int age, Address address) {}

@GenerateGetters
public record Address(String street, String city, String zipCode, String country) {}

@GenerateGetters
public record Company(String name, Person ceo, List&lt;Person&gt; employees, Address headquarters) {}
</code></pre>
<p><strong>Common Extraction Needs:</strong></p>
<ul>
<li>"Get the CEO's full name"</li>
<li>"Extract the company's headquarters city"</li>
<li>"Calculate the CEO's age group"</li>
<li>"Generate an employee's email address"</li>
<li>"Compute the length of a person's full name"</li>
</ul>
<p>A <code>Getter</code> makes these extractions type-safe, composable, and expressive.</p>
<hr />
<h2 id="think-of-getters-like"><a class="header" href="#think-of-getters-like">Think of Getters Like...</a></h2>
<ul>
<li><strong>A functional accessor</strong>: Extracting a specific value from a container</li>
<li><strong>A read-only lens</strong>: Focusing on one element without modification capability</li>
<li><strong>A computed property</strong>: Deriving values on-the-fly without storage</li>
<li><strong>A data pipeline stage</strong>: Composable extraction steps</li>
<li><strong>A pure function in optic form</strong>: Wrapping functions for composition</li>
</ul>
<hr />
<h2 id="getter-vs-lens-vs-fold-understanding-the-differences"><a class="header" href="#getter-vs-lens-vs-fold-understanding-the-differences">Getter vs Lens vs Fold: Understanding the Differences</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th>Getter</th><th>Lens</th><th>Fold</th></tr></thead><tbody>
<tr><td><strong>Focus</strong></td><td>Exactly one element</td><td>Exactly one element</td><td>Zero or more elements</td></tr>
<tr><td><strong>Can modify?</strong></td><td>No</td><td>Yes</td><td>No</td></tr>
<tr><td><strong>Core operation</strong></td><td><code>get(source)</code></td><td><code>get(source)</code>, <code>set(value, source)</code></td><td><code>foldMap(monoid, fn, source)</code></td></tr>
<tr><td><strong>Use case</strong></td><td>Computed/derived values</td><td>Field access with updates</td><td>Queries over collections</td></tr>
<tr><td><strong>Intent</strong></td><td>"Extract this single value"</td><td>"Get or set this field"</td><td>"Query all these values"</td></tr>
</tbody></table>
</div>
<p><strong>Key Insight</strong>: Every <code>Lens</code> can be viewed as a <code>Getter</code> (its read-only half), but not every <code>Getter</code> can be a <code>Lens</code>. A <code>Getter</code> extends <code>Fold</code>, meaning it inherits all query operations (<code>exists</code>, <code>all</code>, <code>find</code>, <code>preview</code>) whilst guaranteeing exactly one focused element.</p>
<hr />
<h2 id="a-step-by-step-walkthrough-6"><a class="header" href="#a-step-by-step-walkthrough-6">A Step-by-Step Walkthrough</a></h2>
<h3 id="step-1-creating-getters"><a class="header" href="#step-1-creating-getters">Step 1: Creating Getters</a></h3>
<h4 id="using-generategetters-annotation"><a class="header" href="#using-generategetters-annotation">Using <code>@GenerateGetters</code> Annotation</a></h4>
<p>Annotating a record with <strong><code>@GenerateGetters</code></strong> creates a companion class (e.g., <code>PersonGetters</code>) containing a <code>Getter</code> for each field:</p>
<pre><code class="language-java">import org.higherkindedj.optics.annotations.GenerateGetters;

@GenerateGetters
public record Person(String firstName, String lastName, int age, Address address) {}
</code></pre>
<p>This generates:</p>
<ul>
<li><code>PersonGetters.firstName()</code> → <code>Getter&lt;Person, String&gt;</code></li>
<li><code>PersonGetters.lastName()</code> → <code>Getter&lt;Person, String&gt;</code></li>
<li><code>PersonGetters.age()</code> → <code>Getter&lt;Person, Integer&gt;</code></li>
<li><code>PersonGetters.address()</code> → <code>Getter&lt;Person, Address&gt;</code></li>
</ul>
<p>Plus convenience methods:</p>
<ul>
<li><code>PersonGetters.getFirstName(person)</code> → <code>String</code></li>
<li><code>PersonGetters.getLastName(person)</code> → <code>String</code></li>
<li>etc.</li>
</ul>
<h4 id="customising-the-generated-package-4"><a class="header" href="#customising-the-generated-package-4">Customising the Generated Package</a></h4>
<p>By default, generated classes are placed in the same package as the annotated record. You can specify a different package using the <code>targetPackage</code> attribute:</p>
<pre><code class="language-java">// Generated class will be placed in org.example.generated.optics
@GenerateGetters(targetPackage = "org.example.generated.optics")
public record Person(String firstName, String lastName, int age, Address address) {}
</code></pre>
<p>This is useful when you need to avoid name collisions or organise generated code separately.</p>
<h4 id="using-factory-methods"><a class="header" href="#using-factory-methods">Using Factory Methods</a></h4>
<p>Create Getters programmatically for computed or derived values:</p>
<pre><code class="language-java">// Simple field extraction
Getter&lt;Person, String&gt; firstName = Getter.of(Person::firstName);

// Computed value
Getter&lt;Person, String&gt; fullName = Getter.of(p -&gt; p.firstName() + " " + p.lastName());

// Derived value
Getter&lt;Person, String&gt; initials = Getter.of(p -&gt;
    p.firstName().charAt(0) + "." + p.lastName().charAt(0) + ".");

// Alternative factory (alias for of)
Getter&lt;String, Integer&gt; stringLength = Getter.to(String::length);
</code></pre>
<h3 id="step-2-core-getter-operations"><a class="header" href="#step-2-core-getter-operations">Step 2: Core Getter Operations</a></h3>
<h4 id="getsource-extract-the-focused-value"><a class="header" href="#getsource-extract-the-focused-value"><strong><code>get(source)</code></strong>: Extract the Focused Value</a></h4>
<p>The fundamental operation: returns exactly one value:</p>
<pre><code class="language-java">Person person = new Person("Jane", "Smith", 45, address);

Getter&lt;Person, String&gt; fullName = Getter.of(p -&gt; p.firstName() + " " + p.lastName());
String name = fullName.get(person);
// Result: "Jane Smith"

Getter&lt;Person, Integer&gt; age = Getter.of(Person::age);
int years = age.get(person);
// Result: 45
</code></pre>
<h3 id="step-3-composing-getters"><a class="header" href="#step-3-composing-getters">Step 3: Composing Getters</a></h3>
<p>Chain Getters together to extract deeply nested values:</p>
<pre><code class="language-java">Getter&lt;Person, Address&gt; addressGetter = Getter.of(Person::address);
Getter&lt;Address, String&gt; cityGetter = Getter.of(Address::city);

// Compose: Person → Address → String
Getter&lt;Person, String&gt; personCity = addressGetter.andThen(cityGetter);

Person person = new Person("Jane", "Smith", 45,
    new Address("123 Main St", "London", "EC1A", "UK"));

String city = personCity.get(person);
// Result: "London"
</code></pre>
<h4 id="deep-composition-chain"><a class="header" href="#deep-composition-chain">Deep Composition Chain</a></h4>
<pre><code class="language-java">Getter&lt;Company, Person&gt; ceoGetter = Getter.of(Company::ceo);
Getter&lt;Person, String&gt; fullNameGetter = Getter.of(p -&gt; p.firstName() + " " + p.lastName());
Getter&lt;String, Integer&gt; lengthGetter = Getter.of(String::length);

// Compose: Company → Person → String → Integer
Getter&lt;Company, Integer&gt; ceoNameLength = ceoGetter
    .andThen(fullNameGetter)
    .andThen(lengthGetter);

Company company = new Company("TechCorp", ceo, employees, headquarters);
int length = ceoNameLength.get(company);
// Result: 10 (length of "Jane Smith")
</code></pre>
<h3 id="step-4-getter-as-a-fold"><a class="header" href="#step-4-getter-as-a-fold">Step 4: Getter as a Fold</a></h3>
<p>Since <code>Getter</code> extends <code>Fold</code>, you inherit all query operations, but they operate on exactly one element:</p>
<pre><code class="language-java">Getter&lt;Person, Integer&gt; ageGetter = Getter.of(Person::age);
Person person = new Person("Jane", "Smith", 45, address);

// preview() returns Optional with the single value
Optional&lt;Integer&gt; age = ageGetter.preview(person);
// Result: Optional[45]

// getAll() returns a single-element list
List&lt;Integer&gt; ages = ageGetter.getAll(person);
// Result: [45]

// exists() checks if the single value matches
boolean isExperienced = ageGetter.exists(a -&gt; a &gt; 40, person);
// Result: true

// all() checks the single value (always same as exists for Getter)
boolean isSenior = ageGetter.all(a -&gt; a &gt;= 65, person);
// Result: false

// find() returns the value if it matches
Optional&lt;Integer&gt; foundAge = ageGetter.find(a -&gt; a &gt; 30, person);
// Result: Optional[45]

// length() always returns 1 for Getter
int count = ageGetter.length(person);
// Result: 1

// isEmpty() always returns false for Getter
boolean empty = ageGetter.isEmpty(person);
// Result: false
</code></pre>
<h3 id="step-5-combining-getters-with-folds"><a class="header" href="#step-5-combining-getters-with-folds">Step 5: Combining Getters with Folds</a></h3>
<p>Compose Getters with Folds for powerful queries:</p>
<pre><code class="language-java">Getter&lt;Company, List&lt;Person&gt;&gt; employeesGetter = Getter.of(Company::employees);
Fold&lt;List&lt;Person&gt;, Person&gt; listFold = Fold.of(list -&gt; list);
Getter&lt;Person, String&gt; fullNameGetter = Getter.of(p -&gt; p.firstName() + " " + p.lastName());

// Company → List&lt;Person&gt; → Person (multiple) → String
Fold&lt;Company, String&gt; allEmployeeNames = employeesGetter
    .asFold()  // Convert Getter to Fold
    .andThen(listFold)
    .andThen(fullNameGetter.asFold());

List&lt;String&gt; names = allEmployeeNames.getAll(company);
// Result: ["John Doe", "Alice Johnson", "Bob Williams"]

boolean hasExperienced = listFold.andThen(Getter.of(Person::age).asFold())
    .exists(age -&gt; age &gt; 40, employees);
// Result: depends on employee ages
</code></pre>
<h3 id="step-6-maybe-based-getter-extension"><a class="header" href="#step-6-maybe-based-getter-extension">Step 6: Maybe-Based Getter Extension</a></h3>
<div id="admonition-extension-method" class="admonition admonish-note" role="note" aria-labelledby="admonition-extension-method-title">
<div class="admonition-title">
<div id="admonition-extension-method-title">
<p>Extension Method</p>
</div>
<a class="admonition-anchor-link" href="optics/getters.html#admonition-extension-method"></a>
</div>
<div>
<p>Higher-kinded-j provides the <code>getMaybe</code> extension method that integrates <code>Getter</code> with the <code>Maybe</code> type, enabling null-safe navigation through potentially nullable fields. This extension is available via static import from <code>GetterExtensions</code>.</p>
</div>
</div>
<h4 id="the-challenge-null-safe-navigation"><a class="header" href="#the-challenge-null-safe-navigation">The Challenge: Null-Safe Navigation</a></h4>
<p>When working with nested data structures, intermediate values may be <code>null</code>, leading to <code>NullPointerException</code> if not handled carefully. Traditional approaches require verbose null checks at each level:</p>
<pre><code class="language-java">// Verbose traditional approach with null checks
Person person = company.getCeo();
if (person != null) {
    Address address = person.getAddress();
    if (address != null) {
        String city = address.getCity();
        if (city != null) {
            System.out.println("City: " + city);
        }
    }
}
</code></pre>
<p>The <code>getMaybe</code> extension method provides a more functional approach by wrapping extracted values in <code>Maybe</code>, which explicitly models presence or absence without the risk of NPE.</p>
<h4 id="think-of-getmaybe-like"><a class="header" href="#think-of-getmaybe-like">Think of getMaybe Like...</a></h4>
<ul>
<li><strong>A safe elevator</strong> - Transports you to the desired floor, or tells you it's unavailable</li>
<li><strong>A null-safe wrapper</strong> - Extracts values whilst protecting against null</li>
<li><strong>Optional's functional cousin</strong> - Same safety guarantees, better functional composition</li>
<li><strong>A maybe-monad extractor</strong> - Lifts extraction into the Maybe context</li>
</ul>
<h4 id="how-getmaybe-works"><a class="header" href="#how-getmaybe-works">How getMaybe Works</a></h4>
<p>The <code>getMaybe</code> static method is imported from <code>GetterExtensions</code>:</p>
<pre><code class="language-java">import static org.higherkindedj.optics.extensions.GetterExtensions.getMaybe;
</code></pre>
<p><strong>Signature:</strong></p>
<pre><code class="language-java">public static &lt;S, A&gt; Maybe&lt;A&gt; getMaybe(Getter&lt;S, A&gt; getter, S source)
</code></pre>
<p>It extracts a value using the provided <code>Getter</code> and wraps it in <code>Maybe</code>:</p>
<ul>
<li>If the extracted value is <strong>non-null</strong>, returns <code>Just(value)</code></li>
<li>If the extracted value is <strong>null</strong>, returns <code>Nothing</code></li>
</ul>
<h4 id="basic-usage-example"><a class="header" href="#basic-usage-example">Basic Usage Example</a></h4>
<pre><code class="language-java">import org.higherkindedj.optics.Getter;
import org.higherkindedj.hkt.maybe.Maybe;
import static org.higherkindedj.optics.extensions.GetterExtensions.getMaybe;

public record Person(String firstName, String lastName, Address address) {}
public record Address(String street, String city) {}

Getter&lt;Person, String&gt; firstNameGetter = Getter.of(Person::firstName);
Getter&lt;Person, Address&gt; addressGetter = Getter.of(Person::address);

Person person = new Person("Jane", "Smith", address);

// Extract non-null value
Maybe&lt;String&gt; name = getMaybe(firstNameGetter, person);
// Result: Just("Jane")

// Extract nullable value
Person personWithNullAddress = new Person("Bob", "Jones", null);
Maybe&lt;Address&gt; address = getMaybe(addressGetter, personWithNullAddress);
// Result: Nothing
</code></pre>
<h4 id="safe-navigation-with-composed-getters"><a class="header" href="#safe-navigation-with-composed-getters">Safe Navigation with Composed Getters</a></h4>
<p>The real power of <code>getMaybe</code> emerges when navigating nested structures with potentially null intermediate values. By using <code>flatMap</code>, you can safely chain extractions:</p>
<pre><code class="language-java">Getter&lt;Person, Address&gt; addressGetter = Getter.of(Person::address);
Getter&lt;Address, String&gt; cityGetter = Getter.of(Address::city);

// Safe navigation: Person → Maybe&lt;Address&gt; → Maybe&lt;String&gt;
Person personWithAddress = new Person("Jane", "Smith",
    new Address("123 Main St", "London"));

Maybe&lt;String&gt; city = getMaybe(addressGetter, personWithAddress)
    .flatMap(addr -&gt; getMaybe(cityGetter, addr));
// Result: Just("London")

// Safe with null intermediate
Person personWithNullAddress = new Person("Bob", "Jones", null);

Maybe&lt;String&gt; noCity = getMaybe(addressGetter, personWithNullAddress)
    .flatMap(addr -&gt; getMaybe(cityGetter, addr));
// Result: Nothing (safely handles null address)
</code></pre>
<p><strong>Key Pattern</strong>: Use <code>flatMap</code> to chain <code>getMaybe</code> calls, creating a null-safe pipeline.</p>
<h4 id="comparison-direct-access-vs-getmaybe"><a class="header" href="#comparison-direct-access-vs-getmaybe">Comparison: Direct Access vs getMaybe</a></h4>
<p>Understanding when to use each approach:</p>
<div class="table-wrapper"><table><thead><tr><th>Approach</th><th>Null Safety</th><th>Composability</th><th>Verbosity</th><th>Use Case</th></tr></thead><tbody>
<tr><td><strong>Direct field access</strong></td><td>NPE risk</td><td>No</td><td>Minimal</td><td>Known non-null values</td></tr>
<tr><td><strong>Manual null checks</strong></td><td>Safe</td><td>No</td><td>Very verbose</td><td>Simple cases</td></tr>
<tr><td><strong>Optional chaining</strong></td><td>Safe</td><td>Limited</td><td>Moderate</td><td>Java interop</td></tr>
<tr><td><strong>getMaybe</strong></td><td>Safe</td><td>Excellent</td><td>Concise</td><td>Functional pipelines</td></tr>
</tbody></table>
</div>
<p><strong>Example Comparison:</strong></p>
<pre><code class="language-java">// Direct access (risky)
String city1 = person.address().city(); // NPE if address is null!

// Manual null checks (verbose)
String city2 = null;
if (person.address() != null &amp;&amp; person.address().city() != null) {
    city2 = person.address().city();
}

// Optional chaining (better)
Optional&lt;String&gt; city3 = Optional.ofNullable(person.address())
    .map(Address::city);

// getMaybe (best for functional code)
Maybe&lt;String&gt; city4 = getMaybe(addressGetter, person)
    .flatMap(addr -&gt; getMaybe(cityGetter, addr));
</code></pre>
<h4 id="integration-with-maybe-operations"><a class="header" href="#integration-with-maybe-operations">Integration with Maybe Operations</a></h4>
<p>Once you've extracted a value into <code>Maybe</code>, you can leverage the full power of monadic operations:</p>
<pre><code class="language-java">Getter&lt;Person, Address&gt; addressGetter = Getter.of(Person::address);
Getter&lt;Address, String&gt; cityGetter = Getter.of(Address::city);

Person person = new Person("Jane", "Smith",
    new Address("123 Main St", "London"));

// Extract and transform
Maybe&lt;String&gt; uppercaseCity = getMaybe(addressGetter, person)
    .flatMap(addr -&gt; getMaybe(cityGetter, addr))
    .map(String::toUpperCase);
// Result: Just("LONDON")

// Extract with default
String cityOrDefault = getMaybe(addressGetter, person)
    .flatMap(addr -&gt; getMaybe(cityGetter, addr))
    .getOrElse("Unknown");
// Result: "London"

// Extract and filter
Maybe&lt;String&gt; longCityName = getMaybe(addressGetter, person)
    .flatMap(addr -&gt; getMaybe(cityGetter, addr))
    .filter(name -&gt; name.length() &gt; 5);
// Result: Just("London") (length is 6)

// Chain multiple operations
String report = getMaybe(addressGetter, person)
    .flatMap(addr -&gt; getMaybe(cityGetter, addr))
    .map(city -&gt; "Person lives in " + city)
    .getOrElse("Address unknown");
// Result: "Person lives in London"
</code></pre>
<h4 id="when-to-use-getmaybe"><a class="header" href="#when-to-use-getmaybe">When to Use getMaybe</a></h4>
<p><strong>Use <code>getMaybe</code> when:</strong></p>
<ul>
<li>Navigating through <strong>potentially null</strong> intermediate values</li>
<li>Building <strong>functional pipelines</strong> with Maybe-based operations</li>
<li>You want <strong>explicit presence/absence</strong> semantics</li>
<li>Composing with other Maybe-returning functions</li>
<li>Working within HKT-based abstractions</li>
</ul>
<pre><code class="language-java">// Perfect for null-safe navigation
Maybe&lt;String&gt; safeCity = getMaybe(addressGetter, person)
    .flatMap(addr -&gt; getMaybe(cityGetter, addr));
</code></pre>
<p><strong>Use standard <code>get()</code> when:</strong></p>
<ul>
<li>You <strong>know</strong> the values are non-null</li>
<li>You're working in <strong>performance-critical</strong> code</li>
<li>You want <strong>immediate NPE</strong> on unexpected nulls (fail-fast)</li>
</ul>
<pre><code class="language-java">// Fine when values are guaranteed non-null
String knownCity = cityGetter.get(knownAddress);
</code></pre>
<p><strong>Use <code>Getter.preview()</code> when:</strong></p>
<ul>
<li>You prefer Java's <code>Optional</code> for <strong>interoperability</strong></li>
<li>Working at API boundaries with standard Java code</li>
</ul>
<pre><code class="language-java">// Good for Java interop
Optional&lt;String&gt; optionalCity = cityGetter.preview(address);
</code></pre>
<h4 id="real-world-scenario-employee-profile-lookup"><a class="header" href="#real-world-scenario-employee-profile-lookup">Real-World Scenario: Employee Profile Lookup</a></h4>
<p>Here's a practical example showing how <code>getMaybe</code> simplifies complex null-safe extractions:</p>
<pre><code class="language-java">import org.higherkindedj.optics.Getter;
import org.higherkindedj.hkt.maybe.Maybe;
import static org.higherkindedj.optics.extensions.GetterExtensions.getMaybe;

public record Employee(String id, PersonalInfo personalInfo) {}
public record PersonalInfo(ContactInfo contactInfo, EmergencyContact emergencyContact) {}
public record ContactInfo(String email, String phone, Address address) {}
public record EmergencyContact(String name, String phone) {}
public record Address(String street, String city, String postcode) {}

public class EmployeeService {
    private static final Getter&lt;Employee, PersonalInfo&gt; PERSONAL_INFO =
        Getter.of(Employee::personalInfo);
    private static final Getter&lt;PersonalInfo, ContactInfo&gt; CONTACT_INFO =
        Getter.of(PersonalInfo::contactInfo);
    private static final Getter&lt;ContactInfo, Address&gt; ADDRESS =
        Getter.of(ContactInfo::address);
    private static final Getter&lt;Address, String&gt; CITY =
        Getter.of(Address::city);

    // Extract employee city with full null safety
    public Maybe&lt;String&gt; getEmployeeCity(Employee employee) {
        return getMaybe(PERSONAL_INFO, employee)
            .flatMap(info -&gt; getMaybe(CONTACT_INFO, info))
            .flatMap(contact -&gt; getMaybe(ADDRESS, contact))
            .flatMap(addr -&gt; getMaybe(CITY, addr));
    }

    // Generate location-based welcome message
    public String generateWelcomeMessage(Employee employee) {
        return getEmployeeCity(employee)
            .map(city -&gt; "Welcome to our " + city + " office!")
            .getOrElse("Welcome to our company!");
    }

    // Check if employee is in specific city
    public boolean isEmployeeInCity(Employee employee, String targetCity) {
        return getEmployeeCity(employee)
            .filter(city -&gt; city.equalsIgnoreCase(targetCity))
            .isJust();
    }

    // Collect all cities from employee list (skipping unknowns)
    public List&lt;String&gt; getAllCities(List&lt;Employee&gt; employees) {
        return employees.stream()
            .map(this::getEmployeeCity)
            .filter(Maybe::isJust)
            .map(Maybe::get)
            .distinct()
            .toList();
    }

    // Get city or fallback to emergency contact location
    public String getAnyCityInfo(Employee employee) {
        Getter&lt;PersonalInfo, EmergencyContact&gt; emergencyGetter =
            Getter.of(PersonalInfo::emergencyContact);

        // Try primary address first
        Maybe&lt;String&gt; primaryCity = getMaybe(PERSONAL_INFO, employee)
            .flatMap(info -&gt; getMaybe(CONTACT_INFO, info))
            .flatMap(contact -&gt; getMaybe(ADDRESS, contact))
            .flatMap(addr -&gt; getMaybe(CITY, addr));

        // If not found, could try emergency contact (simplified example)
        return primaryCity.getOrElse("Location unknown");
    }
}
</code></pre>
<h4 id="performance-considerations-2"><a class="header" href="#performance-considerations-2">Performance Considerations</a></h4>
<p><code>getMaybe</code> adds minimal overhead:</p>
<ul>
<li><strong>One null check</strong>: Checks if the extracted value is null</li>
<li><strong>One Maybe wrapping</strong>: Creates <code>Just</code> or <code>Nothing</code> instance</li>
<li><strong>Same extraction cost</strong>: Uses <code>Getter.get()</code> internally</li>
</ul>
<p><strong>Optimisation Tip</strong>: For performance-critical hot paths where values are guaranteed non-null, use <code>Getter.get()</code> directly. For most business logic, the safety and composability of <code>getMaybe</code> far outweigh the negligible cost.</p>
<pre><code class="language-java">// Hot path with guaranteed non-null (use direct get)
String fastAccess = nameGetter.get(person);

// Business logic with potential nulls (use getMaybe)
Maybe&lt;String&gt; safeAccess = getMaybe(addressGetter, person)
    .flatMap(addr -&gt; getMaybe(cityGetter, addr));
</code></pre>
<h4 id="practical-pattern-building-maybe-safe-composed-getters"><a class="header" href="#practical-pattern-building-maybe-safe-composed-getters">Practical Pattern: Building Maybe-Safe Composed Getters</a></h4>
<p>Create reusable null-safe extraction functions:</p>
<pre><code class="language-java">public class SafeGetters {
    // Create a null-safe composed getter using Maybe
    public static &lt;A, B, C&gt; Function&lt;A, Maybe&lt;C&gt;&gt; safePath(
        Getter&lt;A, B&gt; first,
        Getter&lt;B, C&gt; second
    ) {
        return source -&gt; getMaybe(first, source)
            .flatMap(intermediate -&gt; getMaybe(second, intermediate));
    }

    // Usage example
    private static final Function&lt;Person, Maybe&lt;String&gt;&gt; SAFE_CITY_LOOKUP =
        safePath(
            Getter.of(Person::address),
            Getter.of(Address::city)
        );

    public static void main(String[] args) {
        Person person = new Person("Jane", "Smith", null);
        Maybe&lt;String&gt; city = SAFE_CITY_LOOKUP.apply(person);
        // Result: Nothing (safely handled null address)
    }
}
</code></pre>
<div id="admonition-complete-example" class="admonition admonish-note" role="note" aria-labelledby="admonition-complete-example-title">
<div class="admonition-title">
<div id="admonition-complete-example-title">
<p>Complete Example</p>
</div>
<a class="admonition-anchor-link" href="optics/getters.html#admonition-complete-example"></a>
</div>
<div>
<p>See <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/extensions/GetterExtensionsExample.java">GetterExtensionsExample.java</a> for a runnable demonstration of <code>getMaybe</code> with practical scenarios.</p>
</div>
</div>
<hr />
<h2 id="built-in-helper-getters"><a class="header" href="#built-in-helper-getters">Built-in Helper Getters</a></h2>
<p>Higher-Kinded-J provides several utility Getters:</p>
<h3 id="identity-returns-the-source-itself"><a class="header" href="#identity-returns-the-source-itself"><strong><code>identity()</code></strong>: Returns the Source Itself</a></h3>
<pre><code class="language-java">Getter&lt;String, String&gt; id = Getter.identity();
String result = id.get("Hello");
// Result: "Hello"
</code></pre>
<p>Useful as a base case in composition or for type adaptation.</p>
<h3 id="constantvalue-always-returns-the-same-value"><a class="header" href="#constantvalue-always-returns-the-same-value"><strong><code>constant(value)</code></strong>: Always Returns the Same Value</a></h3>
<pre><code class="language-java">Getter&lt;String, Integer&gt; always42 = Getter.constant(42);
int result = always42.get("anything");
// Result: 42
</code></pre>
<p>Useful for providing default values in pipelines.</p>
<h3 id="first-and-second-pair-element-extractors"><a class="header" href="#first-and-second-pair-element-extractors"><strong><code>first()</code></strong> and <strong><code>second()</code></strong>: Pair Element Extractors</a></h3>
<pre><code class="language-java">Map.Entry&lt;Person, Address&gt; pair = new AbstractMap.SimpleEntry&lt;&gt;(ceo, hqAddress);

Getter&lt;Map.Entry&lt;Person, Address&gt;, Person&gt; firstGetter = Getter.first();
Getter&lt;Map.Entry&lt;Person, Address&gt;, Address&gt; secondGetter = Getter.second();

Person person = firstGetter.get(pair);
// Result: the CEO Person

Address address = secondGetter.get(pair);
// Result: the headquarters Address
</code></pre>
<hr />
<h2 id="when-to-use-getter-vs-other-approaches"><a class="header" href="#when-to-use-getter-vs-other-approaches">When to Use Getter vs Other Approaches</a></h2>
<h3 id="use-getter-when"><a class="header" href="#use-getter-when">Use Getter When:</a></h3>
<ul>
<li>You need <strong>computed or derived values</strong> without storing them</li>
<li>You want <strong>composable extraction</strong> pipelines</li>
<li>You're building <strong>reporting or analytics</strong> features</li>
<li>You need <strong>type-safe accessors</strong> that compose with other optics</li>
<li>You want <strong>clear read-only intent</strong> in your code</li>
</ul>
<pre><code class="language-java">// Good: Computed value without storage overhead
Getter&lt;Person, String&gt; email = Getter.of(p -&gt;
    p.firstName().toLowerCase() + "." + p.lastName().toLowerCase() + "@company.com");

// Good: Composable pipeline
Getter&lt;Company, String&gt; ceoCityUppercase = ceoGetter
    .andThen(addressGetter)
    .andThen(cityGetter)
    .andThen(Getter.of(String::toUpperCase));
</code></pre>
<h3 id="use-lens-when-1"><a class="header" href="#use-lens-when-1">Use Lens When:</a></h3>
<ul>
<li>You need <strong>both reading and writing</strong></li>
<li>You're working with <strong>mutable state</strong> (functionally)</li>
</ul>
<pre><code class="language-java">// Use Lens when you need to modify
Lens&lt;Person, String&gt; firstName = Lens.of(
    Person::firstName,
    (p, name) -&gt; new Person(name, p.lastName(), p.age(), p.address()));

Person updated = firstName.set("Janet", person);
</code></pre>
<h3 id="use-fold-when-1"><a class="header" href="#use-fold-when-1">Use Fold When:</a></h3>
<ul>
<li>You're querying <strong>zero or more elements</strong></li>
<li>You need to <strong>aggregate or search</strong> collections</li>
</ul>
<pre><code class="language-java">// Use Fold for collections
Fold&lt;Order, Product&gt; itemsFold = Fold.of(Order::items);
List&lt;Product&gt; all = itemsFold.getAll(order);
</code></pre>
<h3 id="use-direct-field-access-when-1"><a class="header" href="#use-direct-field-access-when-1">Use Direct Field Access When:</a></h3>
<ul>
<li>You need <strong>maximum performance</strong> with no abstraction overhead</li>
<li>You're not composing with other optics</li>
</ul>
<pre><code class="language-java">// Direct access when composition isn't needed
String name = person.firstName();
</code></pre>
<hr />
<h2 id="real-world-use-cases"><a class="header" href="#real-world-use-cases">Real-World Use Cases</a></h2>
<h3 id="data-transformation-pipelines"><a class="header" href="#data-transformation-pipelines">Data Transformation Pipelines</a></h3>
<pre><code class="language-java">Getter&lt;Person, String&gt; email = Getter.of(p -&gt;
    p.firstName().toLowerCase() + "." + p.lastName().toLowerCase() + "@techcorp.com");

Getter&lt;Person, String&gt; badgeId = Getter.of(p -&gt;
    p.lastName().substring(0, Math.min(3, p.lastName().length())).toUpperCase() +
    String.format("%04d", p.age() * 100));

// Generate employee reports
for (Person emp : company.employees()) {
    System.out.println("Employee: " + fullName.get(emp));
    System.out.println("  Email: " + email.get(emp));
    System.out.println("  Badge: " + badgeId.get(emp));
}
</code></pre>
<h3 id="analytics-and-reporting"><a class="header" href="#analytics-and-reporting">Analytics and Reporting</a></h3>
<pre><code class="language-java">Fold&lt;Company, Person&gt; allEmployees = Fold.of(Company::employees);
Getter&lt;Person, Integer&gt; age = Getter.of(Person::age);

// Calculate total age
int totalAge = allEmployees.andThen(age.asFold())
    .foldMap(sumMonoid(), Function.identity(), company);

// Calculate average age
double averageAge = (double) totalAge / company.employees().size();

// Check conditions
boolean allFromUK = allEmployees.andThen(addressGetter.asFold())
    .andThen(countryGetter.asFold())
    .all(c -&gt; c.equals("UK"), company);
</code></pre>
<h3 id="api-response-mapping"><a class="header" href="#api-response-mapping">API Response Mapping</a></h3>
<pre><code class="language-java">// Extract specific fields from nested API responses
Getter&lt;ApiResponse, User&gt; userGetter = Getter.of(ApiResponse::user);
Getter&lt;User, Profile&gt; profileGetter = Getter.of(User::profile);
Getter&lt;Profile, String&gt; displayName = Getter.of(Profile::displayName);

Getter&lt;ApiResponse, String&gt; userName = userGetter
    .andThen(profileGetter)
    .andThen(displayName);

String name = userName.get(response);
</code></pre>
<hr />
<h2 id="common-pitfalls-15"><a class="header" href="#common-pitfalls-15">Common Pitfalls</a></h2>
<h3 id="dont-use-getter-when-you-need-to-modify"><a class="header" href="#dont-use-getter-when-you-need-to-modify">Don't Use Getter When You Need to Modify</a></h3>
<pre><code class="language-java">// Wrong: Getter can't modify
Getter&lt;Person, String&gt; nameGetter = Getter.of(Person::firstName);
// nameGetter.set("Jane", person); // Compilation error - no set method!
</code></pre>
<h3 id="use-lens-when-modification-is-required"><a class="header" href="#use-lens-when-modification-is-required">Use Lens When Modification Is Required</a></h3>
<pre><code class="language-java">// Correct: Use Lens for read-write access
Lens&lt;Person, String&gt; nameLens = Lens.of(Person::firstName, (p, n) -&gt;
    new Person(n, p.lastName(), p.age(), p.address()));

Person updated = nameLens.set("Jane", person);
</code></pre>
<h3 id="dont-overlook-null-safety"><a class="header" href="#dont-overlook-null-safety">Don't Overlook Null Safety</a></h3>
<pre><code class="language-java">// Risky: Getter doesn't handle null values specially
Getter&lt;NullableRecord, String&gt; getter = Getter.of(NullableRecord::value);
String result = getter.get(new NullableRecord(null)); // Returns null
</code></pre>
<h3 id="handle-nulls-explicitly"><a class="header" href="#handle-nulls-explicitly">Handle Nulls Explicitly</a></h3>
<pre><code class="language-java">// Safe: Handle nulls in the getter function
Getter&lt;NullableRecord, String&gt; safeGetter = Getter.of(r -&gt;
    r.value() != null ? r.value() : "default");
</code></pre>
<hr />
<h2 id="performance-considerations-3"><a class="header" href="#performance-considerations-3">Performance Considerations</a></h2>
<p>Getters are <strong>extremely lightweight</strong>:</p>
<ul>
<li><strong>Zero overhead</strong>: Just a function wrapper</li>
<li><strong>No reflection</strong>: Direct method references</li>
<li><strong>Inline-friendly</strong>: JIT can optimise away the abstraction</li>
<li><strong>Lazy evaluation</strong>: Values computed only when <code>get()</code> is called</li>
</ul>
<p><strong>Best Practice</strong>: Use Getters freely; they add minimal runtime cost whilst providing excellent composability and type safety.</p>
<pre><code class="language-java">// Efficient: Computed on demand
Getter&lt;Person, String&gt; fullName = Getter.of(p -&gt; p.firstName() + " " + p.lastName());

// No storage overhead, computed each time get() is called
String name1 = fullName.get(person1);
String name2 = fullName.get(person2);
</code></pre>
<hr />
<h2 id="complete-runnable-example-5"><a class="header" href="#complete-runnable-example-5">Complete, Runnable Example</a></h2>
<pre><code class="language-java">import org.higherkindedj.optics.Getter;
import org.higherkindedj.optics.Fold;
import org.higherkindedj.hkt.Monoid;
import java.util.*;
import java.util.function.Function;

public class GetterExample {

    public record Person(String firstName, String lastName, int age, Address address) {}
    public record Address(String street, String city, String zipCode, String country) {}
    public record Company(String name, Person ceo, List&lt;Person&gt; employees, Address headquarters) {}

    public static void main(String[] args) {
        // Create sample data
        Address ceoAddress = new Address("123 Executive Blvd", "London", "EC1A", "UK");
        Person ceo = new Person("Jane", "Smith", 45, ceoAddress);

        List&lt;Person&gt; employees = List.of(
            new Person("John", "Doe", 30, new Address("456 Oak St", "Manchester", "M1", "UK")),
            new Person("Alice", "Johnson", 28, new Address("789 Elm Ave", "Birmingham", "B1", "UK")),
            new Person("Bob", "Williams", 35, new Address("321 Pine Rd", "Leeds", "LS1", "UK"))
        );

        Address hqAddress = new Address("1000 Corporate Way", "London", "EC2A", "UK");
        Company company = new Company("TechCorp", ceo, employees, hqAddress);

        // === Basic Getters ===
        Getter&lt;Person, String&gt; fullName = Getter.of(p -&gt; p.firstName() + " " + p.lastName());
        Getter&lt;Person, Integer&gt; age = Getter.of(Person::age);

        System.out.println("CEO: " + fullName.get(ceo));
        System.out.println("CEO Age: " + age.get(ceo));

        // === Computed Values ===
        Getter&lt;Person, String&gt; initials = Getter.of(p -&gt;
            p.firstName().charAt(0) + "." + p.lastName().charAt(0) + ".");
        Getter&lt;Person, String&gt; email = Getter.of(p -&gt;
            p.firstName().toLowerCase() + "." + p.lastName().toLowerCase() + "@techcorp.com");

        System.out.println("CEO Initials: " + initials.get(ceo));
        System.out.println("CEO Email: " + email.get(ceo));

        // === Composition ===
        Getter&lt;Person, Address&gt; addressGetter = Getter.of(Person::address);
        Getter&lt;Address, String&gt; cityGetter = Getter.of(Address::city);
        Getter&lt;Company, Person&gt; ceoGetter = Getter.of(Company::ceo);

        Getter&lt;Person, String&gt; personCity = addressGetter.andThen(cityGetter);
        Getter&lt;Company, String&gt; companyCeoCity = ceoGetter.andThen(personCity);

        System.out.println("CEO City: " + personCity.get(ceo));
        System.out.println("Company CEO City: " + companyCeoCity.get(company));

        // === Getter as Fold ===
        Optional&lt;Integer&gt; ceoAge = age.preview(ceo);
        boolean isExperienced = age.exists(a -&gt; a &gt; 40, ceo);
        int ageCount = age.length(ceo); // Always 1 for Getter

        System.out.println("CEO Age (Optional): " + ceoAge);
        System.out.println("CEO is Experienced: " + isExperienced);
        System.out.println("Age Count: " + ageCount);

        // === Employee Analysis ===
        Fold&lt;List&lt;Person&gt;, Person&gt; listFold = Fold.of(list -&gt; list);

        List&lt;String&gt; employeeNames = listFold.andThen(fullName.asFold()).getAll(employees);
        System.out.println("Employee Names: " + employeeNames);

        List&lt;String&gt; employeeEmails = listFold.andThen(email.asFold()).getAll(employees);
        System.out.println("Employee Emails: " + employeeEmails);

        // Calculate average age
        int totalAge = listFold.andThen(age.asFold())
            .foldMap(sumMonoid(), Function.identity(), employees);
        double avgAge = (double) totalAge / employees.size();
        System.out.println("Average Employee Age: " + String.format("%.1f", avgAge));

        // Check if all from UK
        Getter&lt;Address, String&gt; countryGetter = Getter.of(Address::country);
        boolean allUK = listFold.andThen(addressGetter.asFold())
            .andThen(countryGetter.asFold())
            .all(c -&gt; c.equals("UK"), employees);
        System.out.println("All Employees from UK: " + allUK);
    }

    private static Monoid&lt;Integer&gt; sumMonoid() {
        return new Monoid&lt;&gt;() {
            @Override public Integer empty() { return 0; }
            @Override public Integer combine(Integer a, Integer b) { return a + b; }
        };
    }
}
</code></pre>
<p><strong>Expected Output:</strong></p>
<pre><code>CEO: Jane Smith
CEO Age: 45
CEO Initials: J.S.
CEO Email: jane.smith@techcorp.com
CEO City: London
Company CEO City: London
CEO Age (Optional): Optional[45]
CEO is Experienced: true
Age Count: 1
Employee Names: [John Doe, Alice Johnson, Bob Williams]
Employee Emails: [john.doe@techcorp.com, alice.johnson@techcorp.com, bob.williams@techcorp.com]
Average Employee Age: 31.0
All Employees from UK: true
</code></pre>
<hr />
<h2 id="why-getters-are-important"><a class="header" href="#why-getters-are-important">Why Getters Are Important</a></h2>
<p><code>Getter</code> completes the read-only optics family by providing:</p>
<ul>
<li><strong>Single-element focus</strong>: Guarantees exactly one value (unlike Fold's zero-or-more)</li>
<li><strong>Composability</strong>: Chains beautifully with other optics</li>
<li><strong>Computed values</strong>: Derive data without storage overhead</li>
<li><strong>Clear intent</strong>: Explicitly read-only, preventing accidental modifications</li>
<li><strong>Type safety</strong>: Compile-time guarantees on extraction paths</li>
<li><strong>Fold inheritance</strong>: Leverages query operations (exists, all, find) for single values</li>
</ul>
<p>By adding <code>Getter</code> to your optics toolkit alongside <code>Lens</code>, <code>Prism</code>, <code>Iso</code>, <code>Traversal</code>, and <code>Fold</code>, you have precise control over read-only access patterns. Use <code>Getter</code> when you need composable value extraction, <code>Fold</code> when you query collections, and <code>Lens</code> when you need both reading and writing.</p>
<p>The key insight: <strong>Getters make pure functions first-class composable citizens</strong>, allowing you to build sophisticated data extraction pipelines with clarity and type safety.</p>
<hr />
<p><strong>Previous:</strong> <a href="optics/indexed_optics.html">Indexed Optics: Position-Aware Operations</a>
<strong>Next:</strong> <a href="optics/setters.html">Setters: Composable Write-Only Modifications</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="setters-a-practical-guide"><a class="header" href="#setters-a-practical-guide">Setters: A Practical Guide</a></h1>
<h2 id="composable-write-only-modifications"><a class="header" href="#composable-write-only-modifications"><em>Composable Write-Only Modifications</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="optics/setters.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to modify data structures using composable, write-only optics</li>
<li>Using <code>@GenerateSetters</code> to create type-safe modifiers automatically</li>
<li>Understanding the relationship between Setter and Traversal</li>
<li>Creating modification pipelines without read access</li>
<li>Effectful modifications using Applicative contexts</li>
<li>Factory methods: <code>of</code>, <code>fromGetSet</code>, <code>forList</code>, <code>forMapValues</code>, <code>identity</code></li>
<li>When to use Setter vs Lens vs Traversal</li>
<li>Building batch update and normalisation pipelines</li>
</ul>
</div>
</div>
<div id="admonition-example-code" class="admonition admonish-note" role="note" aria-labelledby="admonition-example-code-title">
<div class="admonition-title">
<div id="admonition-example-code-title">
<p>Example Code</p>
</div>
<a class="admonition-anchor-link" href="optics/setters.html#admonition-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/SetterUsageExample.java">SetterUsageExample</a></p>
</div>
</div>
<p>In the previous guide, we explored <strong><code>Getter</code></strong> for composable read-only access. Now we turn to its dual: <strong><code>Setter</code></strong>, a write-only optic that modifies data without necessarily reading it first.</p>
<p>A <strong><code>Setter</code></strong> is an optic that focuses on transforming elements within a structure. Unlike a <code>Lens</code>, which provides both getting and setting, a <code>Setter</code> concentrates solely on modification, making it ideal for batch updates, data normalisation, and transformation pipelines where read access isn't required.</p>
<hr />
<h2 id="the-scenario-user-management-system"><a class="header" href="#the-scenario-user-management-system">The Scenario: User Management System</a></h2>
<p>Consider a user management system where you need to perform various modifications:</p>
<p><strong>The Data Model:</strong></p>
<pre><code class="language-java">@GenerateSetters
public record User(String username, String email, int loginCount, UserSettings settings) {}

@GenerateSetters
public record UserSettings(
    String theme, boolean notifications, int fontSize, Map&lt;String, String&gt; preferences) {}

@GenerateSetters
public record Product(String name, double price, int stock, List&lt;String&gt; tags) {}

@GenerateSetters
public record Inventory(List&lt;Product&gt; products, String warehouseId) {}
</code></pre>
<p><strong>Common Modification Needs:</strong></p>
<ul>
<li>"Normalise all usernames to lowercase"</li>
<li>"Increment login count after authentication"</li>
<li>"Apply 10% discount to all products"</li>
<li>"Restock all items by 10 units"</li>
<li>"Convert all product names to title case"</li>
<li>"Set all user themes to dark mode"</li>
</ul>
<p>A <code>Setter</code> makes these modifications type-safe, composable, and expressive.</p>
<hr />
<h2 id="think-of-setters-like"><a class="header" href="#think-of-setters-like">Think of Setters Like...</a></h2>
<ul>
<li><strong>A functional modifier</strong>: Transforming values without reading</li>
<li><strong>A write-only lens</strong>: Focusing on modification only</li>
<li><strong>A batch transformer</strong>: Applying changes to multiple elements</li>
<li><strong>A data normalisation tool</strong>: Standardising formats across structures</li>
<li><strong>A pipeline stage</strong>: Composable modification steps</li>
</ul>
<hr />
<h2 id="setter-vs-lens-vs-traversal-understanding-the-differences"><a class="header" href="#setter-vs-lens-vs-traversal-understanding-the-differences">Setter vs Lens vs Traversal: Understanding the Differences</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th>Setter</th><th>Lens</th><th>Traversal</th></tr></thead><tbody>
<tr><td><strong>Focus</strong></td><td>One or more elements</td><td>Exactly one element</td><td>Zero or more elements</td></tr>
<tr><td><strong>Can read?</strong></td><td>No (typically)</td><td>Yes</td><td>Yes</td></tr>
<tr><td><strong>Can modify?</strong></td><td>Yes</td><td>Yes</td><td>Yes</td></tr>
<tr><td><strong>Core operations</strong></td><td><code>modify</code>, <code>set</code></td><td><code>get</code>, <code>set</code>, <code>modify</code></td><td><code>modifyF</code>, <code>getAll</code></td></tr>
<tr><td><strong>Use case</strong></td><td>Write-only pipelines</td><td>Read-write field access</td><td>Collection traversals</td></tr>
<tr><td><strong>Intent</strong></td><td>"Transform these values"</td><td>"Get or set this field"</td><td>"Update all these elements"</td></tr>
</tbody></table>
</div>
<p><strong>Key Insight</strong>: A <code>Setter</code> can be viewed as the write-only half of a <code>Lens</code>. It extends <code>Optic</code>, enabling composition with other optics and supporting effectful modifications via <code>modifyF</code>. Choose <code>Setter</code> when you want to emphasise write-only intent or when read access isn't needed.</p>
<hr />
<h2 id="a-step-by-step-walkthrough-7"><a class="header" href="#a-step-by-step-walkthrough-7">A Step-by-Step Walkthrough</a></h2>
<h3 id="step-1-creating-setters"><a class="header" href="#step-1-creating-setters">Step 1: Creating Setters</a></h3>
<h4 id="using-generatesetters-annotation"><a class="header" href="#using-generatesetters-annotation">Using <code>@GenerateSetters</code> Annotation</a></h4>
<p>Annotating a record with <strong><code>@GenerateSetters</code></strong> creates a companion class (e.g., <code>UserSetters</code>) containing a <code>Setter</code> for each field:</p>
<pre><code class="language-java">import org.higherkindedj.optics.annotations.GenerateSetters;

@GenerateSetters
public record User(String username, String email, int loginCount, UserSettings settings) {}
</code></pre>
<p>This generates:</p>
<ul>
<li><code>UserSetters.username()</code> → <code>Setter&lt;User, String&gt;</code></li>
<li><code>UserSetters.email()</code> → <code>Setter&lt;User, String&gt;</code></li>
<li><code>UserSetters.loginCount()</code> → <code>Setter&lt;User, Integer&gt;</code></li>
<li><code>UserSetters.settings()</code> → <code>Setter&lt;User, UserSettings&gt;</code></li>
</ul>
<p>Plus convenience methods:</p>
<ul>
<li><code>UserSetters.withUsername(user, newUsername)</code> → <code>User</code></li>
<li><code>UserSetters.withEmail(user, newEmail)</code> → <code>User</code></li>
<li>etc.</li>
</ul>
<h4 id="customising-the-generated-package-5"><a class="header" href="#customising-the-generated-package-5">Customising the Generated Package</a></h4>
<p>By default, generated classes are placed in the same package as the annotated record. You can specify a different package using the <code>targetPackage</code> attribute:</p>
<pre><code class="language-java">// Generated class will be placed in org.example.generated.optics
@GenerateSetters(targetPackage = "org.example.generated.optics")
public record User(String username, String email, int loginCount, UserSettings settings) {}
</code></pre>
<p>This is useful when you need to avoid name collisions or organise generated code separately.</p>
<h4 id="using-factory-methods-1"><a class="header" href="#using-factory-methods-1">Using Factory Methods</a></h4>
<p>Create Setters programmatically:</p>
<pre><code class="language-java">// Using fromGetSet for single-element focus
Setter&lt;User, String&gt; usernameSetter = Setter.fromGetSet(
    User::username,
    (user, newUsername) -&gt; new User(newUsername, user.email(), user.loginCount(), user.settings()));

// Using of for transformation-based definition
Setter&lt;Person, String&gt; nameSetter = Setter.of(
    f -&gt; person -&gt; new Person(f.apply(person.name()), person.age()));

// Built-in collection setters
Setter&lt;List&lt;Integer&gt;, Integer&gt; listSetter = Setter.forList();
Setter&lt;Map&lt;String, Double&gt;, Double&gt; mapValuesSetter = Setter.forMapValues();
</code></pre>
<h3 id="step-2-core-setter-operations"><a class="header" href="#step-2-core-setter-operations">Step 2: Core Setter Operations</a></h3>
<h4 id="modifyfunction-source-transform-the-focused-value"><a class="header" href="#modifyfunction-source-transform-the-focused-value"><strong><code>modify(function, source)</code></strong>: Transform the Focused Value</a></h4>
<p>Applies a function to modify the focused element:</p>
<pre><code class="language-java">Setter&lt;User, String&gt; usernameSetter = Setter.fromGetSet(
    User::username,
    (u, name) -&gt; new User(name, u.email(), u.loginCount(), u.settings()));

User user = new User("JOHN_DOE", "john@example.com", 10, settings);

// Transform username to lowercase
User normalised = usernameSetter.modify(String::toLowerCase, user);
// Result: User("john_doe", "john@example.com", 10, settings)

// Append suffix
User suffixed = usernameSetter.modify(name -&gt; name + "_admin", user);
// Result: User("JOHN_DOE_admin", "john@example.com", 10, settings)
</code></pre>
<h4 id="setvalue-source-replace-the-focused-value"><a class="header" href="#setvalue-source-replace-the-focused-value"><strong><code>set(value, source)</code></strong>: Replace the Focused Value</a></h4>
<p>Sets all focused elements to a specific value:</p>
<pre><code class="language-java">Setter&lt;User, Integer&gt; loginCountSetter = Setter.fromGetSet(
    User::loginCount,
    (u, count) -&gt; new User(u.username(), u.email(), count, u.settings()));

User user = new User("john", "john@example.com", 10, settings);
User reset = loginCountSetter.set(0, user);
// Result: User("john", "john@example.com", 0, settings)
</code></pre>
<h3 id="step-3-composing-setters"><a class="header" href="#step-3-composing-setters">Step 3: Composing Setters</a></h3>
<p>Chain Setters together for deep modifications:</p>
<pre><code class="language-java">Setter&lt;User, UserSettings&gt; settingsSetter = Setter.fromGetSet(
    User::settings,
    (u, s) -&gt; new User(u.username(), u.email(), u.loginCount(), s));

Setter&lt;UserSettings, String&gt; themeSetter = Setter.fromGetSet(
    UserSettings::theme,
    (s, theme) -&gt; new UserSettings(theme, s.notifications(), s.fontSize(), s.preferences()));

// Compose: User → UserSettings → String
Setter&lt;User, String&gt; userThemeSetter = settingsSetter.andThen(themeSetter);

User user = new User("john", "john@example.com", 10,
    new UserSettings("light", true, 14, Map.of()));

User darkModeUser = userThemeSetter.set("dark", user);
// Result: User with settings.theme = "dark"
</code></pre>
<h4 id="deep-composition-chain-1"><a class="header" href="#deep-composition-chain-1">Deep Composition Chain</a></h4>
<pre><code class="language-java">Setter&lt;User, UserSettings&gt; settingsSetter = /* ... */;
Setter&lt;UserSettings, Integer&gt; fontSizeSetter = /* ... */;

Setter&lt;User, Integer&gt; userFontSizeSetter = settingsSetter.andThen(fontSizeSetter);

User largerFont = userFontSizeSetter.modify(size -&gt; size + 2, user);
// Result: User with settings.fontSize increased by 2
</code></pre>
<h3 id="step-4-collection-setters"><a class="header" href="#step-4-collection-setters">Step 4: Collection Setters</a></h3>
<p>Higher-Kinded-J provides built-in Setters for collections:</p>
<h4 id="forlist-modify-all-list-elements"><a class="header" href="#forlist-modify-all-list-elements"><strong><code>forList()</code></strong>: Modify All List Elements</a></h4>
<pre><code class="language-java">Setter&lt;List&lt;Integer&gt;, Integer&gt; listSetter = Setter.forList();

List&lt;Integer&gt; numbers = List.of(1, 2, 3, 4, 5);

// Double all values
List&lt;Integer&gt; doubled = listSetter.modify(x -&gt; x * 2, numbers);
// Result: [2, 4, 6, 8, 10]

// Set all to same value
List&lt;Integer&gt; allZeros = listSetter.set(0, numbers);
// Result: [0, 0, 0, 0, 0]
</code></pre>
<h4 id="formapvalues-modify-all-map-values"><a class="header" href="#formapvalues-modify-all-map-values"><strong><code>forMapValues()</code></strong>: Modify All Map Values</a></h4>
<pre><code class="language-java">Setter&lt;Map&lt;String, Integer&gt;, Integer&gt; mapSetter = Setter.forMapValues();

Map&lt;String, Integer&gt; scores = Map.of("Alice", 85, "Bob", 90, "Charlie", 78);

// Add 5 points to all scores
Map&lt;String, Integer&gt; curved = mapSetter.modify(score -&gt; Math.min(100, score + 5), scores);
// Result: {Alice=90, Bob=95, Charlie=83}

// Reset all scores
Map&lt;String, Integer&gt; reset = mapSetter.set(0, scores);
// Result: {Alice=0, Bob=0, Charlie=0}
</code></pre>
<h3 id="step-5-nested-collection-setters"><a class="header" href="#step-5-nested-collection-setters">Step 5: Nested Collection Setters</a></h3>
<p>Compose Setters for complex nested modifications:</p>
<pre><code class="language-java">Setter&lt;Inventory, List&lt;Product&gt;&gt; productsSetter = Setter.fromGetSet(
    Inventory::products,
    (inv, prods) -&gt; new Inventory(prods, inv.warehouseId()));

Setter&lt;List&lt;Product&gt;, Product&gt; productListSetter = Setter.forList();

Setter&lt;Product, Double&gt; priceSetter = Setter.fromGetSet(
    Product::price,
    (p, price) -&gt; new Product(p.name(), price, p.stock(), p.tags()));

// Compose: Inventory → List&lt;Product&gt; → Product
Setter&lt;Inventory, Product&gt; allProductsSetter = productsSetter.andThen(productListSetter);

Inventory inventory = new Inventory(
    List.of(
        new Product("Laptop", 999.99, 50, List.of("electronics")),
        new Product("Keyboard", 79.99, 100, List.of("accessories")),
        new Product("Monitor", 299.99, 30, List.of("displays"))),
    "WH-001");

// Apply 10% discount to all products
Inventory discounted = allProductsSetter.modify(
    product -&gt; priceSetter.modify(price -&gt; price * 0.9, product),
    inventory);
// Result: All product prices reduced by 10%

// Restock all products
Setter&lt;Product, Integer&gt; stockSetter = Setter.fromGetSet(
    Product::stock,
    (p, stock) -&gt; new Product(p.name(), p.price(), stock, p.tags()));

Inventory restocked = allProductsSetter.modify(
    product -&gt; stockSetter.modify(stock -&gt; stock + 10, product),
    inventory);
// Result: All product stock increased by 10
</code></pre>
<h3 id="step-6-effectful-modifications"><a class="header" href="#step-6-effectful-modifications">Step 6: Effectful Modifications</a></h3>
<p>Setters support effectful modifications via <code>modifyF</code>, allowing you to compose modifications that might fail or have side effects:</p>
<pre><code class="language-java">Setter&lt;User, String&gt; usernameSetter = Setter.fromGetSet(
    User::username,
    (u, name) -&gt; new User(name, u.email(), u.loginCount(), u.settings()));

// Validation: username must be at least 3 characters and lowercase
Function&lt;String, Kind&lt;OptionalKind.Witness, String&gt;&gt; validateUsername = username -&gt; {
    if (username.length() &gt;= 3 &amp;&amp; username.matches("[a-z_]+")) {
        return OptionalKindHelper.OPTIONAL.widen(Optional.of(username));
    } else {
        return OptionalKindHelper.OPTIONAL.widen(Optional.empty());
    }
};

User validUser = new User("john_doe", "john@example.com", 10, settings);
Kind&lt;OptionalKind.Witness, User&gt; result =
    usernameSetter.modifyF(validateUsername, validUser, OptionalMonad.INSTANCE);

Optional&lt;User&gt; validated = OptionalKindHelper.OPTIONAL.narrow(result);
// Result: Optional[User with validated username]

User invalidUser = new User("ab", "a@test.com", 0, settings); // Too short
Kind&lt;OptionalKind.Witness, User&gt; invalidResult =
    usernameSetter.modifyF(validateUsername, invalidUser, OptionalMonad.INSTANCE);

Optional&lt;User&gt; invalidValidated = OptionalKindHelper.OPTIONAL.narrow(invalidResult);
// Result: Optional.empty (validation failed)
</code></pre>
<h4 id="sequencing-effects-in-collections"><a class="header" href="#sequencing-effects-in-collections">Sequencing Effects in Collections</a></h4>
<pre><code class="language-java">Setter&lt;List&lt;Integer&gt;, Integer&gt; listSetter = Setter.forList();

List&lt;Integer&gt; numbers = List.of(1, 2, 3);

Function&lt;Integer, Kind&lt;OptionalKind.Witness, Integer&gt;&gt; doubleIfPositive = n -&gt; {
    if (n &gt; 0) {
        return OptionalKindHelper.OPTIONAL.widen(Optional.of(n * 2));
    } else {
        return OptionalKindHelper.OPTIONAL.widen(Optional.empty());
    }
};

Kind&lt;OptionalKind.Witness, List&lt;Integer&gt;&gt; result =
    listSetter.modifyF(doubleIfPositive, numbers, OptionalMonad.INSTANCE);

Optional&lt;List&lt;Integer&gt;&gt; doubled = OptionalKindHelper.OPTIONAL.narrow(result);
// Result: Optional[[2, 4, 6]]

// With negative number (will fail)
List&lt;Integer&gt; withNegative = List.of(1, -2, 3);
Kind&lt;OptionalKind.Witness, List&lt;Integer&gt;&gt; failedResult =
    listSetter.modifyF(doubleIfPositive, withNegative, OptionalMonad.INSTANCE);

Optional&lt;List&lt;Integer&gt;&gt; failed = OptionalKindHelper.OPTIONAL.narrow(failedResult);
// Result: Optional.empty (validation failed on -2)
</code></pre>
<h3 id="step-7-converting-to-traversal"><a class="header" href="#step-7-converting-to-traversal">Step 7: Converting to Traversal</a></h3>
<p>Setters can be viewed as Traversals, enabling integration with other optics:</p>
<pre><code class="language-java">Setter&lt;User, String&gt; nameSetter = Setter.fromGetSet(
    User::username,
    (u, name) -&gt; new User(name, u.email(), u.loginCount(), u.settings()));

Traversal&lt;User, String&gt; nameTraversal = nameSetter.asTraversal();

// Now you can use Traversal operations
Function&lt;String, Kind&lt;OptionalKind.Witness, String&gt;&gt; toUpper =
    s -&gt; OptionalKindHelper.OPTIONAL.widen(Optional.of(s.toUpperCase()));

Kind&lt;OptionalKind.Witness, User&gt; result =
    nameTraversal.modifyF(toUpper, user, OptionalMonad.INSTANCE);
</code></pre>
<hr />
<h2 id="built-in-helper-setters"><a class="header" href="#built-in-helper-setters">Built-in Helper Setters</a></h2>
<h3 id="identity-modifies-the-source-itself"><a class="header" href="#identity-modifies-the-source-itself"><strong><code>identity()</code></strong>: Modifies the Source Itself</a></h3>
<pre><code class="language-java">Setter&lt;String, String&gt; identitySetter = Setter.identity();

String result = identitySetter.modify(String::toUpperCase, "hello");
// Result: "HELLO"

String replaced = identitySetter.set("world", "hello");
// Result: "world"
</code></pre>
<p>Useful as a base case in composition or for direct value transformation.</p>
<hr />
<h2 id="when-to-use-setter-vs-other-approaches"><a class="header" href="#when-to-use-setter-vs-other-approaches">When to Use Setter vs Other Approaches</a></h2>
<h3 id="use-setter-when"><a class="header" href="#use-setter-when">Use Setter When:</a></h3>
<ul>
<li>You need <strong>write-only access</strong> without reading</li>
<li>You're building <strong>batch transformation</strong> pipelines</li>
<li>You want <strong>clear modification intent</strong> in your code</li>
<li>You need <strong>effectful modifications</strong> with validation</li>
<li>You're performing <strong>data normalisation</strong> across structures</li>
</ul>
<pre><code class="language-java">// Good: Batch normalisation
Setter&lt;List&lt;String&gt;, String&gt; listSetter = Setter.forList();
List&lt;String&gt; normalised = listSetter.modify(String::trim, rawStrings);

// Good: Composable deep modification
Setter&lt;Company, String&gt; employeeNamesSetter = companySetter
    .andThen(employeesSetter)
    .andThen(personNameSetter);
</code></pre>
<h3 id="use-lens-when-2"><a class="header" href="#use-lens-when-2">Use Lens When:</a></h3>
<ul>
<li>You need <strong>both reading and writing</strong></li>
<li>You want to <strong>get and set</strong> the same field</li>
</ul>
<pre><code class="language-java">// Use Lens when you need to read
Lens&lt;User, String&gt; usernameLens = Lens.of(
    User::username,
    (u, name) -&gt; new User(name, u.email(), u.loginCount(), u.settings()));

String current = usernameLens.get(user); // Read
User updated = usernameLens.set("new_name", user); // Write
</code></pre>
<h3 id="use-traversal-when-2"><a class="header" href="#use-traversal-when-2">Use Traversal When:</a></h3>
<ul>
<li>You need <strong>read operations</strong> (<code>getAll</code>) on collections</li>
<li>You're working with <strong>optional</strong> or multiple focuses</li>
</ul>
<pre><code class="language-java">// Use Traversal when you need to extract values too
Traversal&lt;Order, Product&gt; productTraversal = /* ... */;
List&lt;Product&gt; all = Traversals.getAll(productTraversal, order); // Read
</code></pre>
<h3 id="use-direct-mutation-when"><a class="header" href="#use-direct-mutation-when">Use Direct Mutation When:</a></h3>
<ul>
<li>You're working with <strong>mutable objects</strong> (not recommended in FP)</li>
<li><strong>Performance</strong> is absolutely critical</li>
</ul>
<pre><code class="language-java">// Direct mutation (only for mutable objects)
user.setUsername("new_name"); // Avoid in functional programming
</code></pre>
<hr />
<h2 id="real-world-use-cases-1"><a class="header" href="#real-world-use-cases-1">Real-World Use Cases</a></h2>
<h3 id="data-normalisation-pipeline"><a class="header" href="#data-normalisation-pipeline">Data Normalisation Pipeline</a></h3>
<pre><code class="language-java">Setter&lt;List&lt;Product&gt;, Product&gt; productSetter = Setter.forList();
Setter&lt;Product, String&gt; nameSetter = Setter.fromGetSet(
    Product::name,
    (p, name) -&gt; new Product(name, p.price(), p.stock(), p.tags()));

Function&lt;String, String&gt; normalise = name -&gt; {
    String trimmed = name.trim();
    return trimmed.substring(0, 1).toUpperCase() +
           trimmed.substring(1).toLowerCase();
};

List&lt;Product&gt; rawProducts = List.of(
    new Product("  LAPTOP  ", 999.99, 50, List.of()),
    new Product("keyboard", 79.99, 100, List.of()),
    new Product("MONITOR", 299.99, 30, List.of()));

List&lt;Product&gt; normalised = productSetter.modify(
    product -&gt; nameSetter.modify(normalise, product),
    rawProducts);
// Result: [Product("Laptop", ...), Product("Keyboard", ...), Product("Monitor", ...)]
</code></pre>
<h3 id="currency-conversion"><a class="header" href="#currency-conversion">Currency Conversion</a></h3>
<pre><code class="language-java">Setter&lt;Product, Double&gt; priceSetter = /* ... */;
double exchangeRate = 0.92; // USD to EUR

List&lt;Product&gt; euroProducts = productSetter.modify(
    product -&gt; priceSetter.modify(price -&gt; price * exchangeRate, product),
    usdProducts);
</code></pre>
<h3 id="batch-user-updates"><a class="header" href="#batch-user-updates">Batch User Updates</a></h3>
<pre><code class="language-java">Setter&lt;List&lt;User&gt;, User&gt; usersSetter = Setter.forList();
Setter&lt;User, Integer&gt; loginCountSetter = /* ... */;

// Reset all login counts
List&lt;User&gt; resetUsers = usersSetter.modify(
    user -&gt; loginCountSetter.set(0, user),
    users);

// Increment all login counts
List&lt;User&gt; incremented = usersSetter.modify(
    user -&gt; loginCountSetter.modify(count -&gt; count + 1, user),
    users);
</code></pre>
<h3 id="theme-migration"><a class="header" href="#theme-migration">Theme Migration</a></h3>
<pre><code class="language-java">Setter&lt;User, String&gt; userThemeSetter = settingsSetter.andThen(themeSetter);

// Migrate all users to dark mode
List&lt;User&gt; darkModeUsers = usersSetter.modify(
    user -&gt; userThemeSetter.set("dark", user),
    users);
</code></pre>
<hr />
<h2 id="common-pitfalls-16"><a class="header" href="#common-pitfalls-16">Common Pitfalls</a></h2>
<h3 id="dont-use-setterof-for-effectful-operations"><a class="header" href="#dont-use-setterof-for-effectful-operations">Don't Use <code>Setter.of()</code> for Effectful Operations</a></h3>
<pre><code class="language-java">// Warning: Setter.of() doesn't support modifyF properly
Setter&lt;Person, String&gt; nameSetter = Setter.of(
    f -&gt; person -&gt; new Person(f.apply(person.name()), person.age()));

// This will throw UnsupportedOperationException!
nameSetter.modifyF(validateFn, person, applicative);
</code></pre>
<h3 id="use-fromgetset-for-effectful-support"><a class="header" href="#use-fromgetset-for-effectful-support">Use <code>fromGetSet()</code> for Effectful Support</a></h3>
<pre><code class="language-java">// Correct: fromGetSet supports modifyF
Setter&lt;Person, String&gt; nameSetter = Setter.fromGetSet(
    Person::name,
    (p, name) -&gt; new Person(name, p.age()));

// Works correctly
nameSetter.modifyF(validateFn, person, applicative);
</code></pre>
<h3 id="dont-forget-immutability"><a class="header" href="#dont-forget-immutability">Don't Forget Immutability</a></h3>
<pre><code class="language-java">// Wrong: Modifying in place (if mutable)
setter.modify(obj -&gt; { obj.setValue(newValue); return obj; }, source);
</code></pre>
<h3 id="always-return-new-instances"><a class="header" href="#always-return-new-instances">Always Return New Instances</a></h3>
<pre><code class="language-java">// Correct: Return new immutable instance
Setter&lt;Product, Double&gt; priceSetter = Setter.fromGetSet(
    Product::price,
    (p, price) -&gt; new Product(p.name(), price, p.stock(), p.tags()));
</code></pre>
<hr />
<h2 id="performance-considerations-4"><a class="header" href="#performance-considerations-4">Performance Considerations</a></h2>
<p>Setters are <strong>lightweight and efficient</strong>:</p>
<ul>
<li><strong>Minimal overhead</strong>: Just function composition</li>
<li><strong>No reflection</strong>: Direct method calls</li>
<li><strong>Lazy application</strong>: Modifications only applied when executed</li>
<li><strong>JIT-friendly</strong>: Can be inlined by the JVM</li>
<li><strong>O(n) collection operations</strong>: <code>forList()</code> and <code>forMapValues()</code> are optimised to avoid quadratic time complexity</li>
</ul>
<h3 id="optimised-collection-operations"><a class="header" href="#optimised-collection-operations">Optimised Collection Operations</a></h3>
<p>The <code>modifyF</code> implementations in <code>forList()</code> and <code>forMapValues()</code> use efficient algorithms:</p>
<ul>
<li><strong>Right-to-left folding</strong>: Uses <code>LinkedList</code> with O(1) prepending instead of repeated array copying</li>
<li><strong>Single pass construction</strong>: Collects effects first, sequences them, then builds the final collection once</li>
<li><strong>Linear time complexity</strong>: O(n) for lists and maps with n elements</li>
</ul>
<p>This means you can safely use effectful modifications on large collections without performance concerns:</p>
<pre><code class="language-java">// Efficient even for large lists
Setter&lt;List&lt;Integer&gt;, Integer&gt; listSetter = Setter.forList();
List&lt;Integer&gt; largeList = /* thousands of elements */;

// O(n) time complexity, not O(n²)
Kind&lt;OptionalKind.Witness, List&lt;Integer&gt;&gt; result =
    listSetter.modifyF(validateAndTransform, largeList, OptionalMonad.INSTANCE);
</code></pre>
<p><strong>Best Practice</strong>: Compose Setters at initialisation time, then reuse:</p>
<pre><code class="language-java">// Define once
private static final Setter&lt;Company, Double&gt; ALL_PRODUCT_PRICES =
    companySetter.andThen(productsSetter).andThen(priceSetter);

// Reuse many times
Company discounted = ALL_PRODUCT_PRICES.modify(p -&gt; p * 0.9, company);
Company inflated = ALL_PRODUCT_PRICES.modify(p -&gt; p * 1.05, company);
</code></pre>
<hr />
<h2 id="complete-runnable-example-6"><a class="header" href="#complete-runnable-example-6">Complete, Runnable Example</a></h2>
<pre><code class="language-java">import org.higherkindedj.optics.Setter;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.optional.OptionalKind;
import org.higherkindedj.hkt.optional.OptionalKindHelper;
import org.higherkindedj.hkt.optional.OptionalMonad;
import java.util.*;
import java.util.function.Function;

public class SetterExample {

    public record User(String username, String email, int loginCount, UserSettings settings) {}
    public record UserSettings(String theme, boolean notifications, int fontSize) {}
    public record Product(String name, double price, int stock) {}

    public static void main(String[] args) {
        // === Basic Setters ===
        Setter&lt;User, String&gt; usernameSetter = Setter.fromGetSet(
            User::username,
            (u, name) -&gt; new User(name, u.email(), u.loginCount(), u.settings()));

        Setter&lt;User, Integer&gt; loginCountSetter = Setter.fromGetSet(
            User::loginCount,
            (u, count) -&gt; new User(u.username(), u.email(), count, u.settings()));

        UserSettings settings = new UserSettings("light", true, 14);
        User user = new User("JOHN_DOE", "john@example.com", 10, settings);

        // Normalise username
        User normalised = usernameSetter.modify(String::toLowerCase, user);
        System.out.println("Normalised: " + normalised.username());

        // Increment login count
        User incremented = loginCountSetter.modify(count -&gt; count + 1, user);
        System.out.println("Login count: " + incremented.loginCount());

        // === Composition ===
        Setter&lt;User, UserSettings&gt; settingsSetter = Setter.fromGetSet(
            User::settings,
            (u, s) -&gt; new User(u.username(), u.email(), u.loginCount(), s));

        Setter&lt;UserSettings, String&gt; themeSetter = Setter.fromGetSet(
            UserSettings::theme,
            (s, theme) -&gt; new UserSettings(theme, s.notifications(), s.fontSize()));

        Setter&lt;User, String&gt; userThemeSetter = settingsSetter.andThen(themeSetter);

        User darkMode = userThemeSetter.set("dark", user);
        System.out.println("Theme: " + darkMode.settings().theme());

        // === Collection Setters ===
        Setter&lt;List&lt;Integer&gt;, Integer&gt; listSetter = Setter.forList();

        List&lt;Integer&gt; numbers = List.of(1, 2, 3, 4, 5);
        List&lt;Integer&gt; doubled = listSetter.modify(x -&gt; x * 2, numbers);
        System.out.println("Doubled: " + doubled);

        // === Product Batch Update ===
        Setter&lt;Product, Double&gt; priceSetter = Setter.fromGetSet(
            Product::price,
            (p, price) -&gt; new Product(p.name(), price, p.stock()));

        Setter&lt;List&lt;Product&gt;, Product&gt; productsSetter = Setter.forList();

        List&lt;Product&gt; products = List.of(
            new Product("Laptop", 999.99, 50),
            new Product("Keyboard", 79.99, 100),
            new Product("Monitor", 299.99, 30));

        // Apply 10% discount
        List&lt;Product&gt; discounted = productsSetter.modify(
            product -&gt; priceSetter.modify(price -&gt; price * 0.9, product),
            products);

        System.out.println("Discounted prices:");
        for (Product p : discounted) {
            System.out.printf("  %s: £%.2f%n", p.name(), p.price());
        }

        // === Effectful Modification ===
        Function&lt;String, Kind&lt;OptionalKind.Witness, String&gt;&gt; validateUsername =
            username -&gt; {
                if (username.length() &gt;= 3 &amp;&amp; username.matches("[a-z_]+")) {
                    return OptionalKindHelper.OPTIONAL.widen(Optional.of(username));
                } else {
                    return OptionalKindHelper.OPTIONAL.widen(Optional.empty());
                }
            };

        User validUser = new User("john_doe", "john@example.com", 10, settings);
        Kind&lt;OptionalKind.Witness, User&gt; validResult =
            usernameSetter.modifyF(validateUsername, validUser, OptionalMonad.INSTANCE);

        Optional&lt;User&gt; validated = OptionalKindHelper.OPTIONAL.narrow(validResult);
        System.out.println("Valid username: " + validated.map(User::username).orElse("INVALID"));

        User invalidUser = new User("ab", "a@test.com", 0, settings);
        Kind&lt;OptionalKind.Witness, User&gt; invalidResult =
            usernameSetter.modifyF(validateUsername, invalidUser, OptionalMonad.INSTANCE);

        Optional&lt;User&gt; invalidValidated = OptionalKindHelper.OPTIONAL.narrow(invalidResult);
        System.out.println("Invalid username: " + invalidValidated.map(User::username).orElse("INVALID"));

        // === Data Normalisation ===
        Setter&lt;Product, String&gt; nameSetter = Setter.fromGetSet(
            Product::name,
            (p, name) -&gt; new Product(name, p.price(), p.stock()));

        Function&lt;String, String&gt; titleCase = name -&gt; {
            String trimmed = name.trim();
            return trimmed.substring(0, 1).toUpperCase() + trimmed.substring(1).toLowerCase();
        };

        List&lt;Product&gt; rawProducts = List.of(
            new Product("  LAPTOP  ", 999.99, 50),
            new Product("keyboard", 79.99, 100),
            new Product("MONITOR", 299.99, 30));

        List&lt;Product&gt; normalisedProducts = productsSetter.modify(
            product -&gt; nameSetter.modify(titleCase, product),
            rawProducts);

        System.out.println("Normalised product names:");
        for (Product p : normalisedProducts) {
            System.out.println("  - " + p.name());
        }
    }
}
</code></pre>
<p><strong>Expected Output:</strong></p>
<pre><code>Normalised: john_doe
Login count: 11
Theme: dark
Doubled: [2, 4, 6, 8, 10]
Discounted prices:
  Laptop: £899.99
  Keyboard: £71.99
  Monitor: £269.99
Valid username: john_doe
Invalid username: INVALID
Normalised product names:
  - Laptop
  - Keyboard
  - Monitor
</code></pre>
<hr />
<h2 id="why-setters-are-important"><a class="header" href="#why-setters-are-important">Why Setters Are Important</a></h2>
<p><code>Setter</code> provides a focused, write-only approach to data modification:</p>
<ul>
<li><strong>Clear intent</strong>: Explicitly write-only, preventing accidental reads</li>
<li><strong>Composability</strong>: Chains beautifully for deep, nested modifications</li>
<li><strong>Batch operations</strong>: Natural fit for updating collections</li>
<li><strong>Effectful support</strong>: Integrates with validation and error handling via Applicatives</li>
<li><strong>Type safety</strong>: Compile-time guarantees on modification paths</li>
<li><strong>Immutability-friendly</strong>: Designed for functional, immutable data structures</li>
</ul>
<p>By adding <code>Setter</code> to your optics toolkit alongside <code>Getter</code>, <code>Lens</code>, <code>Prism</code>, <code>Iso</code>, <code>Traversal</code>, and <code>Fold</code>, you gain fine-grained control over both reading and writing patterns. Use <code>Setter</code> when you need composable write-only access, <code>Getter</code> for read-only extraction, and <code>Lens</code> when you need both.</p>
<p>The key insight: <strong>Setters make modifications first-class composable operations</strong>, allowing you to build sophisticated data transformation pipelines with clarity, type safety, and clear functional intent.</p>
<hr />
<p><strong>Previous:</strong> <a href="optics/getters.html">Getters: Composable Read-Only Access</a>
<strong>Next:</strong> <a href="optics/profunctor_optics.html">Profunctor Optics: Advanced Data Transformation</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="common-data-structure-traversals"><a class="header" href="#common-data-structure-traversals">Common Data Structure Traversals</a></h1>
<h2 id="extending-traversal-power-to-optional-map-and-tuple-types"><a class="header" href="#extending-traversal-power-to-optional-map-and-tuple-types"><em>Extending Traversal Power to Optional, Map, and Tuple Types</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="optics/common_data_structure_traversals.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>Traversing Optional values with affine traversals (0-1 cardinality)</li>
<li>Bulk transformations on Map values whilst preserving keys</li>
<li>Parallel operations on Tuple2 pairs when elements share a type</li>
<li>Composing structure traversals with lenses and filtered optics</li>
<li>Real-world patterns: configuration management, feature flags, coordinate transforms</li>
<li>When to use structure traversals vs direct access vs Stream API</li>
</ul>
</div>
</div>
<div id="admonition-example-code" class="admonition admonish-note" role="note" aria-labelledby="admonition-example-code-title">
<div class="admonition-title">
<div id="admonition-example-code-title">
<p>Example Code</p>
</div>
<a class="admonition-anchor-link" href="optics/common_data_structure_traversals.html#admonition-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/OptionalMapTraversalsExample.java">OptionalMapTraversalsExample</a></p>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/TupleTraversalsExample.java">TupleTraversalsExample</a></p>
</div>
</div>
<p>So far, we've explored traversals for collections: lists, sets, and arrays. But Java applications work with many other data structures that benefit from traversal operations: Optional values that might be empty, Map collections where we need to transform values whilst preserving keys, and Tuple pairs that represent related data.</p>
<p>These structures share a common need: <strong>apply a transformation uniformly across their contents whilst maintaining structural integrity</strong>. Higher-kinded-j's traversal combinators make this declarative, composable, and type-safe.</p>
<hr />
<h2 id="think-of-structure-traversals-like"><a class="header" href="#think-of-structure-traversals-like">Think of Structure Traversals Like...</a></h2>
<ul>
<li><strong>Java Stream's <code>Optional.map()</code></strong>: Like <code>optional.map(transform)</code> but composable with other optics</li>
<li><strong>Scala's for-comprehensions</strong>: Similar to <code>for { x &lt;- option } yield transform(x)</code>, but integrated into optic pipelines</li>
<li><strong>Database UPDATE statements</strong>: Like <code>UPDATE config SET value = transform(value)</code>, preserving structure</li>
<li><strong>Functional map operations</strong>: Like <code>fmap</code> in Haskell, lifting pure functions into wrapped contexts</li>
</ul>
<p>The key insight: these aren't special cases; they're <strong>traversals with specific cardinality</strong>:</p>
<ul>
<li><code>Optional&lt;A&gt;</code>: 0 or 1 element (affine traversal)</li>
<li><code>Map&lt;K, V&gt;</code>: 0 to N values, preserving keys</li>
<li><code>Tuple2&lt;A, A&gt;</code>: Exactly 2 elements (when same type)</li>
</ul>
<hr />
<h2 id="three-categories-of-structure-traversals"><a class="header" href="#three-categories-of-structure-traversals">Three Categories of Structure Traversals</a></h2>
<p>Higher-kinded-j provides factory methods in <code>Traversals</code> and dedicated utility classes:</p>
<div class="table-wrapper"><table><thead><tr><th>Structure</th><th>Method</th><th>Cardinality</th><th>Use Case</th></tr></thead><tbody>
<tr><td><strong>Optional</strong></td><td><code>Traversals.forOptional()</code></td><td>0 or 1</td><td>Nullable fields, configuration values</td></tr>
<tr><td><strong>Map Values</strong></td><td><code>Traversals.forMapValues()</code></td><td>0 to N</td><td>Bulk value transforms, preserving keys</td></tr>
<tr><td><strong>Tuple2 Pairs</strong></td><td><code>TupleTraversals.both()</code></td><td>Exactly 2</td><td>Coordinate systems, min/max pairs</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="optional-traversals-handling-absent-values-declaratively"><a class="header" href="#optional-traversals-handling-absent-values-declaratively">Optional Traversals: Handling Absent Values Declaratively</a></h2>
<h3 id="the-problem-with-nested-optionals"><a class="header" href="#the-problem-with-nested-optionals">The Problem with Nested Optionals</a></h3>
<p>Traditional Optional handling becomes verbose when working with nested structures:</p>
<pre><code class="language-java">@GenerateLenses
public record ServerConfig(
    String hostname,
    Optional&lt;Integer&gt; port,
    Optional&lt;String&gt; sslCertPath
) {}

@GenerateLenses
public record ApplicationConfig(
    String appName,
    Optional&lt;ServerConfig&gt; server
) {}

// Traditional: Nested map() calls
ApplicationConfig updated = config.server()
    .map(server -&gt; server.port()
        .map(p -&gt; server.withPort(Optional.of(p + 1000)))  // Offset ports
        .orElse(server)
    )
    .map(newServer -&gt; config.withServer(Optional.of(newServer)))
    .orElse(config);
</code></pre>
<p>This pattern doesn't compose with other optics and mixes traversal logic with transformation logic.</p>
<h3 id="the-solution-foroptional-traversal"><a class="header" href="#the-solution-foroptional-traversal">The Solution: <code>forOptional()</code> Traversal</a></h3>
<p>The <code>forOptional()</code> method creates an <strong>affine traversal</strong>, focusing on 0 or 1 element.</p>
<pre><code class="language-java">import org.higherkindedj.optics.util.Traversals;

// Create an Optional traversal
Traversal&lt;Optional&lt;Integer&gt;, Integer&gt; optTraversal = Traversals.forOptional();

// Modify the value if present
Optional&lt;Integer&gt; maybePort = Optional.of(8080);
Optional&lt;Integer&gt; offsetPort = Traversals.modify(optTraversal, p -&gt; p + 1000, maybePort);
// Result: Optional.of(9080)

// Empty Optional remains empty
Optional&lt;Integer&gt; empty = Optional.empty();
Optional&lt;Integer&gt; stillEmpty = Traversals.modify(optTraversal, p -&gt; p + 1000, empty);
// Result: Optional.empty()

// Extract value as a list
List&lt;Integer&gt; values = Traversals.getAll(optTraversal, maybePort);
// Result: [8080]  (or [] for empty)
</code></pre>
<h3 id="composing-with-lenses-for-nested-optionals"><a class="header" href="#composing-with-lenses-for-nested-optionals">Composing with Lenses for Nested Optionals</a></h3>
<pre><code class="language-java">// Compose Optional traversal with lens traversal
Traversal&lt;ApplicationConfig, Integer&gt; serverPorts =
    ApplicationConfigLenses.server().asTraversal()
        .andThen(Traversals.forOptional())
        .andThen(ServerConfigLenses.port().asTraversal())
        .andThen(Traversals.forOptional());

// Offset all server ports in one operation
ApplicationConfig updated = Traversals.modify(serverPorts, p -&gt; p + 1000, config);
// Works whether server and port are present or absent
</code></pre>
<h3 id="real-world-example-feature-flag-management"><a class="header" href="#real-world-example-feature-flag-management">Real-World Example: Feature Flag Management</a></h3>
<pre><code class="language-java">@GenerateLenses
public record FeatureFlags(Map&lt;String, Optional&lt;Boolean&gt;&gt; flags) {}

public class FeatureFlagService {

    // Enable all flags that are currently set (respect absent flags)
    public static FeatureFlags enableAllSet(FeatureFlags config) {
        Traversal&lt;Map&lt;String, Optional&lt;Boolean&gt;&gt;, Optional&lt;Boolean&gt;&gt; allFlagValues =
            Traversals.forMapValues();

        Traversal&lt;Map&lt;String, Optional&lt;Boolean&gt;&gt;, Boolean&gt; presentFlags =
            allFlagValues.andThen(Traversals.forOptional());

        Map&lt;String, Optional&lt;Boolean&gt;&gt; updated = Traversals.modify(
            presentFlags,
            flag -&gt; true,  // Enable all present flags
            config.flags()
        );

        return new FeatureFlags(updated);
    }
}
</code></pre>
<hr />
<h2 id="map-value-traversals-bulk-transformations-preserving-keys"><a class="header" href="#map-value-traversals-bulk-transformations-preserving-keys">Map Value Traversals: Bulk Transformations Preserving Keys</a></h2>
<h3 id="the-problem-with-map-streams"><a class="header" href="#the-problem-with-map-streams">The Problem with Map Streams</a></h3>
<p>Transforming Map values whilst preserving keys requires ceremony:</p>
<pre><code class="language-java">Map&lt;String, Double&gt; prices = Map.of(
    "widget", 10.0,
    "gadget", 25.0,
    "gizmo", 15.0
);

// Traditional: Stream + collect
Map&lt;String, Double&gt; inflated = prices.entrySet().stream()
    .collect(Collectors.toMap(
        Map.Entry::getKey,
        e -&gt; e.getValue() * 1.1  // 10% price increase
    ));
</code></pre>
<p>This pattern doesn't compose and requires reconstructing the entire map.</p>
<h3 id="the-solution-formapvalues-traversal"><a class="header" href="#the-solution-formapvalues-traversal">The Solution: <code>forMapValues()</code> Traversal</a></h3>
<p>The <code>forMapValues()</code> method creates a traversal focusing on <strong>all values</strong> whilst preserving key structure.</p>
<pre><code class="language-java">// Create a Map values traversal
Traversal&lt;Map&lt;String, Double&gt;, Double&gt; priceTraversal = Traversals.forMapValues();

// Apply 10% increase to all values
Map&lt;String, Double&gt; inflated = Traversals.modify(priceTraversal, price -&gt; price * 1.1, prices);
// Result: {widget=11.0, gadget=27.5, gizmo=16.5}

// Extract all values
List&lt;Double&gt; allPrices = Traversals.getAll(priceTraversal, prices);
// Result: [10.0, 25.0, 15.0]

// Compose with filtered for conditional updates
Traversal&lt;Map&lt;String, Double&gt;, Double&gt; expensiveItems =
    priceTraversal.filtered(price -&gt; price &gt; 20.0);

Map&lt;String, Double&gt; discounted = Traversals.modify(
    expensiveItems,
    price -&gt; price * 0.9,  // 10% discount on expensive items only
    prices
);
// Result: {widget=10.0, gadget=22.5, gizmo=15.0}
</code></pre>
<h3 id="real-world-example-configuration-value-normalisation"><a class="header" href="#real-world-example-configuration-value-normalisation">Real-World Example: Configuration Value Normalisation</a></h3>
<pre><code class="language-java">@GenerateLenses
public record DatabaseConfig(
    Map&lt;String, String&gt; connectionProperties
) {}

public class ConfigNormaliser {

    // Trim all connection property values
    public static DatabaseConfig normaliseProperties(DatabaseConfig config) {
        Traversal&lt;Map&lt;String, String&gt;, String&gt; allPropertyValues =
            Traversals.forMapValues();

        Map&lt;String, String&gt; trimmed = Traversals.modify(
            allPropertyValues,
            String::trim,
            config.connectionProperties()
        );

        return new DatabaseConfig(trimmed);
    }

    // Redact sensitive values (password, token)
    public static DatabaseConfig redactSensitive(DatabaseConfig config) {
        // Use an indexed traversal to access both key and value during modification
        IndexedTraversal&lt;String, Map&lt;String, String&gt;, String&gt; allProperties =
            IndexedTraversals.forMap();

        Map&lt;String, String&gt; redacted = IndexedTraversals.imodify(
            allProperties,
            (key, value) -&gt; {
                if (key.toLowerCase().contains("password") || key.toLowerCase().contains("token")) {
                    return "***REDACTED***";
                }
                return value;
            },
            config.connectionProperties()
        );

        return new DatabaseConfig(redacted);
    }
}
</code></pre>
<h3 id="composing-map-traversals-with-nested-structures"><a class="header" href="#composing-map-traversals-with-nested-structures">Composing Map Traversals with Nested Structures</a></h3>
<pre><code class="language-java">@GenerateLenses
public record ServiceRegistry(
    Map&lt;String, ServerConfig&gt; services
) {}

// Transform all server ports across all services
Traversal&lt;ServiceRegistry, Integer&gt; allServicePorts =
    ServiceRegistryLenses.services().asTraversal()
        .andThen(Traversals.forMapValues())
        .andThen(ServerConfigLenses.port().asTraversal())
        .andThen(Traversals.forOptional());

ServiceRegistry updated = Traversals.modify(
    allServicePorts,
    port -&gt; port + 1000,  // Offset all ports
    registry
);
</code></pre>
<hr />
<h2 id="tuple-traversals-parallel-transformations-on-pairs"><a class="header" href="#tuple-traversals-parallel-transformations-on-pairs">Tuple Traversals: Parallel Transformations on Pairs</a></h2>
<h3 id="the-problem-with-manual-tuple-updates"><a class="header" href="#the-problem-with-manual-tuple-updates">The Problem with Manual Tuple Updates</a></h3>
<p>Applying the same operation to both elements of a tuple requires duplication:</p>
<pre><code class="language-java">Tuple2&lt;Integer, Integer&gt; range = new Tuple2&lt;&gt;(10, 20);

// Traditional: Manual, repetitive
Tuple2&lt;Integer, Integer&gt; doubled = new Tuple2&lt;&gt;(
    range._1() * 2,
    range._2() * 2
);
</code></pre>
<p>When tuples represent related data (coordinates, ranges, min/max pairs), we want to express "apply this transformation to both elements" declaratively.</p>
<h3 id="the-solution-tupletraversalsboth"><a class="header" href="#the-solution-tupletraversalsboth">The Solution: <code>TupleTraversals.both()</code></a></h3>
<p>The <code>both()</code> method creates a traversal that focuses on <strong>both elements</strong> when they share a type.</p>
<pre><code class="language-java">import org.higherkindedj.optics.util.TupleTraversals;
import org.higherkindedj.hkt.tuple.Tuple2;

// Create a tuple traversal (when both elements are same type)
Traversal&lt;Tuple2&lt;Integer, Integer&gt;, Integer&gt; bothInts = TupleTraversals.both();

// Double both elements
Tuple2&lt;Integer, Integer&gt; range = new Tuple2&lt;&gt;(10, 20);
Tuple2&lt;Integer, Integer&gt; doubled = Traversals.modify(bothInts, x -&gt; x * 2, range);
// Result: Tuple2(20, 40)

// Extract both elements
List&lt;Integer&gt; values = Traversals.getAll(bothInts, range);
// Result: [10, 20]

// Works with any shared type
Traversal&lt;Tuple2&lt;String, String&gt;, String&gt; bothStrings = TupleTraversals.both();
Tuple2&lt;String, String&gt; names = new Tuple2&lt;&gt;("alice", "bob");
Tuple2&lt;String, String&gt; capitalised = Traversals.modify(
    bothStrings,
    s -&gt; s.substring(0, 1).toUpperCase() + s.substring(1),
    names
);
// Result: Tuple2("Alice", "Bob")
</code></pre>
<h3 id="real-world-example-geographic-coordinate-transformations"><a class="header" href="#real-world-example-geographic-coordinate-transformations">Real-World Example: Geographic Coordinate Transformations</a></h3>
<pre><code class="language-java">@GenerateLenses
public record Location(
    String name,
    Tuple2&lt;Double, Double&gt; coordinates  // (latitude, longitude)
) {}

public class CoordinateTransforms {

    // Apply precision rounding to both lat/lon
    public static Location roundCoordinates(Location location, int decimals) {
        Traversal&lt;Tuple2&lt;Double, Double&gt;, Double&gt; bothCoords = TupleTraversals.both();

        double factor = Math.pow(10, decimals);
        Tuple2&lt;Double, Double&gt; rounded = Traversals.modify(
            bothCoords,
            coord -&gt; Math.round(coord * factor) / factor,
            location.coordinates()
        );

        return new Location(location.name(), rounded);
    }

    // Offset coordinates by a fixed delta
    public static Location offsetCoordinates(Location location, double delta) {
        Traversal&lt;Tuple2&lt;Double, Double&gt;, Double&gt; bothCoords = TupleTraversals.both();

        Tuple2&lt;Double, Double&gt; offset = Traversals.modify(
            bothCoords,
            coord -&gt; coord + delta,
            location.coordinates()
        );

        return new Location(location.name(), offset);
    }
}
</code></pre>
<h3 id="composing-with-nested-structures"><a class="header" href="#composing-with-nested-structures">Composing with Nested Structures</a></h3>
<pre><code class="language-java">@GenerateLenses
public record BoundingBox(
    Tuple2&lt;Integer, Integer&gt; topLeft,
    Tuple2&lt;Integer, Integer&gt; bottomRight
) {}

// Scale coordinates in the top-left corner
Traversal&lt;BoundingBox, Integer&gt; topLeftCoords =
    BoundingBoxLenses.topLeft().asTraversal()
        .andThen(TupleTraversals.both());

BoundingBox scaled = Traversals.modify(topLeftCoords, coord -&gt; coord * 2, box);

// To scale all coordinates, you would compose traversals for each field separately
// or create a custom traversal that focuses on all four coordinates
</code></pre>
<hr />
<h2 id="when-to-use-structure-traversals-vs-other-approaches"><a class="header" href="#when-to-use-structure-traversals-vs-other-approaches">When to Use Structure Traversals vs Other Approaches</a></h2>
<h3 id="use-structure-traversals-when"><a class="header" href="#use-structure-traversals-when">Use Structure Traversals When:</a></h3>
<ul>
<li><strong>Reusable transformations</strong> - Define once, compose with other optics</li>
<li><strong>Nested optionals</strong> - Avoiding <code>.map().map().map()</code> chains</li>
<li><strong>Bulk map updates</strong> - Transforming all values whilst preserving keys</li>
<li><strong>Parallel tuple operations</strong> - Same transformation to both elements</li>
<li><strong>Immutable updates</strong> - Structure preserved, only focused elements transformed</li>
</ul>
<pre><code class="language-java">// Perfect: Declarative, composable, reusable
Traversal&lt;ServiceConfig, Integer&gt; allTimeouts =
    ServiceConfigLenses.endpoints().asTraversal()
        .andThen(Traversals.forMapValues())
        .andThen(EndpointLenses.timeout().asTraversal())
        .andThen(Traversals.forOptional());

ServiceConfig increased = Traversals.modify(allTimeouts, t -&gt; t + 1000, config);
</code></pre>
<h3 id="use-direct-access-when"><a class="header" href="#use-direct-access-when">Use Direct Access When:</a></h3>
<ul>
<li><strong>Single Optional</strong> - Simple <code>map()</code> or <code>orElse()</code> is clearer</li>
<li><strong>Specific Map key</strong> - <code>map.get(key)</code> is more direct</li>
<li><strong>Type-specific logic</strong> - Different transformations per tuple element</li>
</ul>
<pre><code class="language-java">// Better with direct access: Single Optional
Optional&lt;Integer&gt; port = config.port().map(p -&gt; p + 1000);

// Better with get: Specific key
Double price = prices.getOrDefault("widget", 0.0) * 1.1;

// Better with manual: Different operations per element
Tuple2&lt;Integer, String&gt; result = new Tuple2&lt;&gt;(
    tuple._1() * 2,        // Double the integer
    tuple._2().toUpperCase()  // Uppercase the string
);
</code></pre>
<h3 id="use-stream-api-when-1"><a class="header" href="#use-stream-api-when-1">Use Stream API When:</a></h3>
<ul>
<li><strong>Complex filtering</strong> - Multiple conditions</li>
<li><strong>Aggregations</strong> - Collecting to new structures</li>
<li><strong>No structural preservation</strong> - Extracting or transforming to different shape</li>
</ul>
<pre><code class="language-java">// Better with streams: Complex filtering
List&lt;Integer&gt; values = map.values().stream()
    .filter(v -&gt; v &gt; 10)
    .filter(v -&gt; v &lt; 100)
    .collect(toList());
</code></pre>
<hr />
<h2 id="common-pitfalls-17"><a class="header" href="#common-pitfalls-17">Common Pitfalls</a></h2>
<h3 id="dont-do-this-7"><a class="header" href="#dont-do-this-7">Don't Do This:</a></h3>
<pre><code class="language-java">// Inefficient: Creating traversals in loops
for (Map.Entry&lt;String, Double&gt; entry : prices.entrySet()) {
    Traversal&lt;Map&lt;String, Double&gt;, Double&gt; values = Traversals.forMapValues();
    // Process each value... inefficient!
}

// Over-engineering: Using traversals for simple cases
Traversal&lt;Optional&lt;String&gt;, String&gt; opt = Traversals.forOptional();
String result = optional.map(s -&gt; s.toUpperCase()).orElse("default");
// Just use: optional.map(String::toUpperCase).orElse("default")

// Type confusion: Trying to use both() with different types
Tuple2&lt;Integer, String&gt; mixed = new Tuple2&lt;&gt;(42, "hello");
// TupleTraversals.both() won't work here; types must match!
</code></pre>
<h3 id="do-this-instead-7"><a class="header" href="#do-this-instead-7">Do This Instead:</a></h3>
<pre><code class="language-java">// Efficient: Create traversal once, apply to entire structure
Traversal&lt;Map&lt;String, Double&gt;, Double&gt; priceTraversal = Traversals.forMapValues();
Map&lt;String, Double&gt; updated = Traversals.modify(priceTraversal, p -&gt; p * 1.1, prices);

// Right tool: Use direct methods for simple cases
String result = optional.map(String::toUpperCase).orElse("default");

// Correct types: Use separate lenses for mixed tuples
Lens&lt;Tuple2&lt;Integer, String&gt;, Integer&gt; first = Tuple2Lenses._1();
Lens&lt;Tuple2&lt;Integer, String&gt;, String&gt; second = Tuple2Lenses._2();
Tuple2&lt;Integer, String&gt; updated = new Tuple2&lt;&gt;(
    first.get(mixed) * 2,
    second.get(mixed).toUpperCase()
);
</code></pre>
<hr />
<h2 id="performance-notes-6"><a class="header" href="#performance-notes-6">Performance Notes</a></h2>
<p>Structure traversals are optimised for immutability:</p>
<ul>
<li><strong>Single pass</strong>: No intermediate collections</li>
<li><strong>Structural sharing</strong>: Unchanged portions reuse original references</li>
<li><strong>No boxing overhead</strong>: Direct map operations without streams</li>
<li><strong>Lazy evaluation</strong>: Short-circuits on empty optionals</li>
</ul>
<p><strong>Best Practice</strong>: Store commonly-used structure traversals as constants:</p>
<pre><code class="language-java">public class ConfigOptics {
    // Reusable structure traversals
    public static final Traversal&lt;Optional&lt;String&gt;, String&gt; OPTIONAL_STRING =
        Traversals.forOptional();

    public static final Traversal&lt;Map&lt;String, Integer&gt;, Integer&gt; MAP_INT_VALUES =
        Traversals.forMapValues();

    public static final Traversal&lt;Tuple2&lt;Double, Double&gt;, Double&gt; COORDINATE_PAIR =
        TupleTraversals.both();

    // Domain-specific compositions
    public static final Traversal&lt;ServerConfig, Integer&gt; ALL_PORTS =
        ServerConfigLenses.endpoints().asTraversal()
            .andThen(MAP_INT_VALUES);
}
</code></pre>
<hr />
<h2 id="related-resources"><a class="header" href="#related-resources">Related Resources</a></h2>
<p><strong>Functional Java Libraries</strong>:</p>
<ul>
<li><a href="https://github.com/aol/cyclops">Cyclops</a> - Functional control structures</li>
<li><a href="https://github.com/functionaljava/functionaljava">Functional Java</a> - Classic FP utilities</li>
</ul>
<p><strong>Further Reading</strong>:</p>
<ul>
<li><em>Functional Programming in Java</em> by Venkat Subramaniam - Optional and immutable patterns</li>
<li><em>Modern Java in Action</em> by Raoul-Gabriel Urma - Functional data processing</li>
<li><a href="https://leanpub.com/optics-by-example">Optics By Example</a> - Comprehensive optics guide (Haskell)</li>
</ul>
<p><strong>Type Theory Background</strong>:</p>
<ul>
<li><strong>Affine Traversals</strong>: Focusing on 0 or 1 element (Optional)</li>
<li><strong>Bitraversable</strong>: Traversing structures with two type parameters (Tuple2, Either)</li>
<li><a href="https://arxiv.org/abs/1703.10857">Profunctor Optics: Modular Data Accessors</a> - Theoretical foundation</li>
</ul>
<hr />
<h2 id="summary-13"><a class="header" href="#summary-13">Summary</a></h2>
<p>Structure traversals extend the traversal pattern to common Java data types:</p>
<div class="table-wrapper"><table><thead><tr><th>Structure</th><th>Traversal</th><th>Key Benefit</th></tr></thead><tbody>
<tr><td><strong>Optional</strong></td><td><code>forOptional()</code></td><td>Null-safe composition without <code>.map()</code> chains</td></tr>
<tr><td><strong>Map Values</strong></td><td><code>forMapValues()</code></td><td>Bulk value transformation preserving keys</td></tr>
<tr><td><strong>Tuple2 Pairs</strong></td><td><code>both()</code></td><td>Parallel operations on homogeneous pairs</td></tr>
</tbody></table>
</div>
<p>These tools transform how you work with wrapped and paired values:</p>
<p><strong>Before</strong> (Imperative):</p>
<ul>
<li>Manual Optional chaining</li>
<li>Stream + collect for Maps</li>
<li>Repetitive tuple updates</li>
</ul>
<p><strong>After</strong> (Declarative):</p>
<ul>
<li>Composable Optional traversals</li>
<li>Direct map value transformations</li>
<li>Unified tuple operations</li>
</ul>
<p>By incorporating structure traversals into your optics toolkit, you gain the ability to express complex transformations declaratively, compose them seamlessly with other optics, and maintain type safety throughout, all whilst preserving the immutability and referential transparency that make functional programming powerful.</p>
<hr />
<p><strong>Previous:</strong> <a href="optics/string_traversals.html">String Traversals: Declarative Text Processing</a>
<strong>Next:</strong> <a href="optics/indexed_optics.html">Indexed Optics: Position-Aware Operations</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="limiting-traversals-focusing-on-list-portions"><a class="header" href="#limiting-traversals-focusing-on-list-portions">Limiting Traversals: Focusing on List Portions</a></h1>
<h2 id="declarative-slicing-for-targeted-operations"><a class="header" href="#declarative-slicing-for-targeted-operations"><em>Declarative Slicing for Targeted Operations</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="optics/limiting_traversals.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to focus on specific portions of lists (first n, last n, slices)</li>
<li>Using <code>ListTraversals</code> factory methods for index-based operations</li>
<li>The difference between limiting traversals and Stream's <code>limit()</code>/<code>skip()</code></li>
<li>Composing limiting traversals with lenses, prisms, and filtered optics</li>
<li>Understanding edge case handling (negative indices, bounds exceeding list size)</li>
<li>Real-world patterns for pagination, batch processing, and time-series windowing</li>
<li>When to use limiting traversals vs Stream API vs manual loops</li>
</ul>
</div>
</div>
<div id="admonition-example-code" class="admonition admonish-note" role="note" aria-labelledby="admonition-example-code-title">
<div class="admonition-title">
<div id="admonition-example-code-title">
<p>Example Code</p>
</div>
<a class="admonition-anchor-link" href="optics/limiting_traversals.html#admonition-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/ListTraversalsExample.java">ListTraversalsExample</a></p>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/PaginationExample.java">PaginationExample</a></p>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/BatchProcessingExample.java">BatchProcessingExample</a></p>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/TimeSeriesWindowingExample.java">TimeSeriesWindowingExample</a></p>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/PredicateListTraversalsExample.java">PredicateListTraversalsExample</a></p>
</div>
</div>
<p>In our journey through optics, we've seen how <strong>Traversal</strong> handles bulk operations on all elements of a collection, and how <strong>filtered optics</strong> let us focus on elements matching a predicate. But what about focusing on elements by <em>position</em>: the first few items, the last few, or a specific slice?</p>
<p>Traditionally, working with list portions requires breaking out of your optic composition to use streams or manual index manipulation. <strong>Limiting traversals</strong> solve this elegantly by making positional focus a first-class part of your optic composition.</p>
<hr />
<h2 id="the-scenario-product-catalogue-management"><a class="header" href="#the-scenario-product-catalogue-management">The Scenario: Product Catalogue Management</a></h2>
<p>Imagine you're building an e-commerce platform where you need to:</p>
<ul>
<li>Display only the <strong>first 10 products</strong> on a landing page</li>
<li>Apply discounts to <strong>all except the last 3</strong> featured items</li>
<li>Process customer orders in <strong>chunks of 50</strong> for batch shipping</li>
<li>Analyse <strong>the most recent 7 days</strong> of time-series sales data</li>
<li>Update metadata for products <strong>between positions 5 and 15</strong> in a ranked list</li>
</ul>
<p><strong>The Data Model:</strong></p>
<pre><code class="language-java">@GenerateLenses
public record Product(String sku, String name, double price, int stock) {
    Product applyDiscount(double percentage) {
        return new Product(sku, name, price * (1 - percentage), stock);
    }
}

@GenerateLenses
public record Catalogue(String name, List&lt;Product&gt; products) {}

@GenerateLenses
public record Order(String id, List&lt;LineItem&gt; items, LocalDateTime created) {}

@GenerateLenses
public record LineItem(Product product, int quantity) {}

@GenerateLenses
public record SalesMetric(LocalDate date, double revenue, int transactions) {}
</code></pre>
<p><strong>The Traditional Approach:</strong></p>
<pre><code class="language-java">// Verbose: Manual slicing breaks optic composition
List&lt;Product&gt; firstTen = catalogue.products().subList(0, Math.min(10, catalogue.products().size()));
List&lt;Product&gt; discounted = firstTen.stream()
    .map(p -&gt; p.applyDiscount(0.1))
    .collect(Collectors.toList());
// Now reconstruct the full list... tedious!
List&lt;Product&gt; fullList = new ArrayList&lt;&gt;(discounted);
fullList.addAll(catalogue.products().subList(Math.min(10, catalogue.products().size()), catalogue.products().size()));
Catalogue updated = new Catalogue(catalogue.name(), fullList);

// Even worse with nested structures
List&lt;Order&gt; chunk = orders.subList(startIndex, Math.min(startIndex + chunkSize, orders.size()));
// Process chunk... then what? How do we put it back?
</code></pre>
<p>This approach forces you to abandon the declarative power of optics, manually managing indices, bounds checking, and list reconstruction. <strong>Limiting traversals</strong> let you express this intent directly within your optic composition.</p>
<hr />
<h2 id="think-of-limiting-traversals-like"><a class="header" href="#think-of-limiting-traversals-like">Think of Limiting Traversals Like...</a></h2>
<ul>
<li><strong>Java Stream's <code>limit()</code> and <code>skip()</code></strong>: Like <code>stream.limit(n)</code> and <code>stream.skip(n)</code>, but composable with immutable data transformations and integrated into optic pipelines</li>
<li><strong>SQL's LIMIT and OFFSET clauses</strong>: Like database pagination (<code>LIMIT 10 OFFSET 20</code>), but for in-memory immutable structures, enabling declarative pagination logic</li>
<li><strong>Spring Batch chunk processing</strong>: Similar to Spring Batch's chunk-oriented processing: divide a list into manageable segments for targeted transformation whilst preserving the complete dataset</li>
<li><strong>ArrayList.subList() but better</strong>: Like <code>List.subList(from, to)</code>, but instead of a mutable view, you get an immutable optic that composes with lenses, prisms, and filtered traversals</li>
</ul>
<p>The key insight: positional focus becomes part of your optic's <em>identity</em>, not an external slicing operation applied afterwards.</p>
<hr />
<h2 id="five-ways-to-limit-focus"><a class="header" href="#five-ways-to-limit-focus">Five Ways to Limit Focus</a></h2>
<p>Higher-kinded-j's <code>ListTraversals</code> utility class provides five complementary factory methods:</p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Description</th><th>SQL Equivalent</th></tr></thead><tbody>
<tr><td><strong><code>taking(n)</code></strong></td><td>Focus on first n elements</td><td><code>LIMIT n</code></td></tr>
<tr><td><strong><code>dropping(n)</code></strong></td><td>Skip first n, focus on rest</td><td><code>OFFSET n</code> (then all)</td></tr>
<tr><td><strong><code>takingLast(n)</code></strong></td><td>Focus on last n elements</td><td><code>ORDER BY id DESC LIMIT n</code></td></tr>
<tr><td><strong><code>droppingLast(n)</code></strong></td><td>Focus on all except last n</td><td><code>LIMIT (size - n)</code></td></tr>
<tr><td><strong><code>slicing(from, to)</code></strong></td><td>Focus on range [from, to)</td><td><code>LIMIT (to-from) OFFSET from</code></td></tr>
</tbody></table>
</div>
<p>Each serves different needs, and they can be combined with other optics for powerful compositions.</p>
<hr />
<h2 id="a-step-by-step-walkthrough-8"><a class="header" href="#a-step-by-step-walkthrough-8">A Step-by-Step Walkthrough</a></h2>
<h3 id="step-1-basic-usage--takingint-n"><a class="header" href="#step-1-basic-usage--takingint-n">Step 1: Basic Usage – <code>taking(int n)</code></a></h3>
<p>The most intuitive method: focus on at most the first <code>n</code> elements.</p>
<pre><code class="language-java">import org.higherkindedj.optics.util.ListTraversals;
import org.higherkindedj.optics.util.Traversals;

// Create a traversal for first 3 products
Traversal&lt;List&lt;Product&gt;, Product&gt; first3 = ListTraversals.taking(3);

List&lt;Product&gt; products = List.of(
    new Product("SKU001", "Widget", 10.0, 100),
    new Product("SKU002", "Gadget", 25.0, 50),
    new Product("SKU003", "Gizmo", 15.0, 75),
    new Product("SKU004", "Doohickey", 30.0, 25),
    new Product("SKU005", "Thingamajig", 20.0, 60)
);

// Apply 10% discount to ONLY first 3 products
List&lt;Product&gt; result = Traversals.modify(first3, p -&gt; p.applyDiscount(0.1), products);
// First 3 discounted; last 2 preserved unchanged

// Extract ONLY first 3 products
List&lt;Product&gt; firstThree = Traversals.getAll(first3, products);
// Returns: [Widget, Gadget, Gizmo]
</code></pre>
<p><strong>Critical Semantic</strong>: During <strong>modification</strong>, non-focused elements are <em>preserved unchanged</em> in the structure. During <strong>queries</strong> (like <code>getAll</code>), they are <em>excluded</em> from the results. This preserves the overall structure whilst focusing operations on the subset you care about.</p>
<h3 id="step-2-skipping-elements--droppingint-n"><a class="header" href="#step-2-skipping-elements--droppingint-n">Step 2: Skipping Elements – <code>dropping(int n)</code></a></h3>
<p>Focus on all elements <em>after</em> skipping the first <code>n</code>:</p>
<pre><code class="language-java">// Skip first 2, focus on the rest
Traversal&lt;List&lt;Product&gt;, Product&gt; afterFirst2 = ListTraversals.dropping(2);

List&lt;Product&gt; result = Traversals.modify(afterFirst2, p -&gt; p.applyDiscount(0.15), products);
// First 2 unchanged; last 3 get 15% discount

List&lt;Product&gt; skipped = Traversals.getAll(afterFirst2, products);
// Returns: [Gizmo, Doohickey, Thingamajig]
</code></pre>
<h3 id="step-3-focusing-on-the-end--takinglastint-n"><a class="header" href="#step-3-focusing-on-the-end--takinglastint-n">Step 3: Focusing on the End – <code>takingLast(int n)</code></a></h3>
<p>Focus on the last <code>n</code> elements, perfect for "most recent" scenarios:</p>
<pre><code class="language-java">// Focus on last 2 products
Traversal&lt;List&lt;Product&gt;, Product&gt; last2 = ListTraversals.takingLast(2);

List&lt;Product&gt; result = Traversals.modify(last2, p -&gt; p.applyDiscount(0.2), products);
// First 3 unchanged; last 2 get 20% discount

List&lt;Product&gt; lastTwo = Traversals.getAll(last2, products);
// Returns: [Doohickey, Thingamajig]
</code></pre>
<h3 id="step-4-excluding-from-the-end--droppinglastint-n"><a class="header" href="#step-4-excluding-from-the-end--droppinglastint-n">Step 4: Excluding from the End – <code>droppingLast(int n)</code></a></h3>
<p>Focus on all elements <em>except</em> the last <code>n</code>:</p>
<pre><code class="language-java">// Focus on all except last 2
Traversal&lt;List&lt;Product&gt;, Product&gt; exceptLast2 = ListTraversals.droppingLast(2);

List&lt;Product&gt; result = Traversals.modify(exceptLast2, p -&gt; p.applyDiscount(0.05), products);
// First 3 get 5% discount; last 2 unchanged

List&lt;Product&gt; allButLastTwo = Traversals.getAll(exceptLast2, products);
// Returns: [Widget, Gadget, Gizmo]
</code></pre>
<h3 id="step-5-precise-slicing--slicingint-from-int-to"><a class="header" href="#step-5-precise-slicing--slicingint-from-int-to">Step 5: Precise Slicing – <code>slicing(int from, int to)</code></a></h3>
<p>Focus on elements within a half-open range <code>[from, to)</code>, exactly like <code>List.subList()</code>:</p>
<pre><code class="language-java">// Focus on indices 1, 2, 3 (0-indexed, exclusive end)
Traversal&lt;List&lt;Product&gt;, Product&gt; slice = ListTraversals.slicing(1, 4);

List&lt;Product&gt; result = Traversals.modify(slice, p -&gt; p.applyDiscount(0.12), products);
// Index 0 unchanged; indices 1-3 discounted; index 4 unchanged

List&lt;Product&gt; sliced = Traversals.getAll(slice, products);
// Returns: [Gadget, Gizmo, Doohickey]
</code></pre>
<hr />
<h2 id="predicate-based-focusing-beyond-fixed-indices"><a class="header" href="#predicate-based-focusing-beyond-fixed-indices">Predicate-Based Focusing: Beyond Fixed Indices</a></h2>
<p>Whilst index-based limiting is powerful, many real-world scenarios require <strong>conditional focusing</strong>: stopping when a condition is met rather than at a fixed position. <code>ListTraversals</code> provides three predicate-based methods that complement the fixed-index approaches:</p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Description</th><th>Use Case</th></tr></thead><tbody>
<tr><td><strong><code>takingWhile(Predicate)</code></strong></td><td>Focus on longest prefix where predicate holds</td><td>Processing ordered data until threshold</td></tr>
<tr><td><strong><code>droppingWhile(Predicate)</code></strong></td><td>Skip prefix whilst predicate holds</td><td>Ignoring header/preamble sections</td></tr>
<tr><td><strong><code>element(int)</code></strong></td><td>Focus on single element at index (0-1 cardinality)</td><td>Safe indexed access without exceptions</td></tr>
</tbody></table>
</div>
<p>These methods enable <strong>runtime-determined focusing</strong>: the number of elements in focus depends on the data itself, not a predetermined count.</p>
<h3 id="step-6-conditional-prefix-with-takingwhilepredicate"><a class="header" href="#step-6-conditional-prefix-with-takingwhilepredicate">Step 6: Conditional Prefix with <code>takingWhile(Predicate)</code></a></h3>
<p>The <code>takingWhile()</code> method focuses on the <strong>longest prefix</strong> of elements satisfying a predicate. Once an element fails the test, traversal stops, even if later elements would pass.</p>
<pre><code class="language-java">// Focus on products whilst price &lt; 20
Traversal&lt;List&lt;Product&gt;, Product&gt; affordablePrefix =
    ListTraversals.takingWhile(p -&gt; p.price() &lt; 20.0);

List&lt;Product&gt; products = List.of(
    new Product("SKU001", "Widget", 10.0, 100),
    new Product("SKU002", "Gadget", 15.0, 50),
    new Product("SKU003", "Gizmo", 25.0, 75),   // Stops here
    new Product("SKU004", "Thing", 12.0, 25)    // Not included despite &lt; 20
);

// Apply discount only to initial affordable items
List&lt;Product&gt; result = Traversals.modify(
    affordablePrefix,
    p -&gt; p.applyDiscount(0.1),
    products
);
// Widget and Gadget discounted; Gizmo and Thing unchanged

// Extract the affordable prefix
List&lt;Product&gt; affordable = Traversals.getAll(affordablePrefix, products);
// Returns: [Widget, Gadget]  (stops at first expensive item)
</code></pre>
<p><strong>Key Semantic</strong>: Unlike <code>filtered()</code>, which tests all elements, <code>takingWhile()</code> is <strong>sequential and prefix-oriented</strong>. It's the optics equivalent of Stream's <code>takeWhile()</code>.</p>
<p><strong>Real-World Use Cases</strong>:</p>
<ul>
<li><strong>Time-series data</strong>: Process events before a timestamp threshold</li>
<li><strong>Sorted lists</strong>: Extract items below a value boundary</li>
<li><strong>Log processing</strong>: Capture startup messages before first error</li>
<li><strong>Priority queues</strong>: Handle high-priority items before switching logic</li>
</ul>
<pre><code class="language-java">// Time-series: Process transactions before cutoff
LocalDateTime cutoff = LocalDateTime.of(2025, 1, 1, 0, 0);
Traversal&lt;List&lt;Transaction&gt;, Transaction&gt; beforeCutoff =
    ListTraversals.takingWhile(t -&gt; t.timestamp().isBefore(cutoff));

List&lt;Transaction&gt; processed = Traversals.modify(
    beforeCutoff,
    t -&gt; t.withStatus("PROCESSED"),
    transactions
);
</code></pre>
<h3 id="step-7-skipping-prefix-with-droppingwhilepredicate"><a class="header" href="#step-7-skipping-prefix-with-droppingwhilepredicate">Step 7: Skipping Prefix with <code>droppingWhile(Predicate)</code></a></h3>
<p>The <code>droppingWhile()</code> method is the complement to <code>takingWhile()</code>: it <strong>skips the prefix</strong> whilst the predicate holds, then focuses on all remaining elements.</p>
<pre><code class="language-java">// Skip low-stock products, focus on well-stocked ones
Traversal&lt;List&lt;Product&gt;, Product&gt; wellStocked =
    ListTraversals.droppingWhile(p -&gt; p.stock() &lt; 50);

List&lt;Product&gt; products = List.of(
    new Product("SKU001", "Widget", 10.0, 20),
    new Product("SKU002", "Gadget", 25.0, 30),
    new Product("SKU003", "Gizmo", 15.0, 75),   // First to pass
    new Product("SKU004", "Thing", 12.0, 25)    // Included despite &lt; 50
);

// Restock only well-stocked items (and everything after)
List&lt;Product&gt; restocked = Traversals.modify(
    wellStocked,
    p -&gt; new Product(p.sku(), p.name(), p.price(), p.stock() + 50),
    products
);
// Widget and Gadget unchanged; Gizmo and Thing restocked

List&lt;Product&gt; focused = Traversals.getAll(wellStocked, products);
// Returns: [Gizmo, Thing]
</code></pre>
<p><strong>Real-World Use Cases</strong>:</p>
<ul>
<li><strong>Skipping headers</strong>: Process CSV data after metadata rows</li>
<li><strong>Log analysis</strong>: Ignore initialisation messages, focus on runtime</li>
<li><strong>Pagination</strong>: Skip already-processed records in batch jobs</li>
<li><strong>Protocol parsing</strong>: Discard handshake, process payload</li>
</ul>
<pre><code class="language-java">// Skip configuration lines in log file
Traversal&lt;String, String&gt; runtimeLogs =
    StringTraversals.lined()
        .filtered(line -&gt; !line.startsWith("[CONFIG]"));

// Apply to log data
String logs = "[CONFIG] Database URL\n[CONFIG] Port\nINFO: System started\nERROR: Connection failed";
String result = Traversals.modify(runtimeLogs, String::toUpperCase, logs);
// Result: "[CONFIG] Database URL\n[CONFIG] Port\nINFO: SYSTEM STARTED\nERROR: CONNECTION FAILED"
</code></pre>
<h3 id="step-8-single-element-access-with-elementint"><a class="header" href="#step-8-single-element-access-with-elementint">Step 8: Single Element Access with <code>element(int)</code></a></h3>
<p>The <code>element()</code> method creates an <strong>affine traversal</strong> (0-1 cardinality) focusing on a single element at the given index. Unlike direct array access, it never throws <code>IndexOutOfBoundsException</code>.</p>
<pre><code class="language-java">// Focus on element at index 2
Traversal&lt;List&lt;Product&gt;, Product&gt; thirdProduct = ListTraversals.element(2);

List&lt;Product&gt; products = List.of(
    new Product("SKU001", "Widget", 10.0, 100),
    new Product("SKU002", "Gadget", 25.0, 50),
    new Product("SKU003", "Gizmo", 15.0, 75)
);

// Modify only the third product
List&lt;Product&gt; updated = Traversals.modify(
    thirdProduct,
    p -&gt; p.applyDiscount(0.2),
    products
);
// Only Gizmo discounted

// Extract the element (if present)
List&lt;Product&gt; element = Traversals.getAll(thirdProduct, products);
// Returns: [Gizmo]

// Out of bounds: gracefully returns empty
List&lt;Product&gt; outOfBounds = Traversals.getAll(
    ListTraversals.element(10),
    products
);
// Returns: [] (no exception)
</code></pre>
<p><strong>When to Use <code>element()</code> vs <code>Ixed</code></strong>:</p>
<ul>
<li><strong><code>element()</code></strong>: For composition with other traversals, when index is known at construction time</li>
<li><strong><code>Ixed</code></strong>: For dynamic indexed access, more general type class approach</li>
</ul>
<pre><code class="language-java">// Compose element() with nested structures
Traversal&lt;List&lt;List&lt;Product&gt;&gt;, Product&gt; secondListThirdProduct =
    ListTraversals.element(1)  // Second list
        .andThen(ListTraversals.element(2));  // Third product in that list

// Ixed for dynamic access
IxedInstances.listIxed().ix(userProvidedIndex).getOptional(products);
</code></pre>
<h3 id="combining-predicate-based-and-index-based-traversals"><a class="header" href="#combining-predicate-based-and-index-based-traversals">Combining Predicate-Based and Index-Based Traversals</a></h3>
<p>The real power emerges when mixing approaches:</p>
<pre><code class="language-java">// Take first 10 products where stock &gt; 0, then filter by price
Traversal&lt;List&lt;Product&gt;, Product&gt; topAffordableInStock =
    ListTraversals.taking(10)
        .andThen(ListTraversals.takingWhile(p -&gt; p.stock() &gt; 0))
        .filtered(p -&gt; p.price() &lt; 30.0);

// Skip warmup period, then take next 100 events
Traversal&lt;List&lt;Event&gt;, Event&gt; steadyState =
    ListTraversals.droppingWhile(e -&gt; e.isWarmup())
        .andThen(ListTraversals.taking(100));
</code></pre>
<hr />
<h2 id="edge-case-handling"><a class="header" href="#edge-case-handling">Edge Case Handling</a></h2>
<p>All limiting traversal methods handle edge cases gracefully and consistently:</p>
<div class="table-wrapper"><table><thead><tr><th>Edge Case</th><th>Behaviour</th><th>Rationale</th></tr></thead><tbody>
<tr><td><strong><code>n &lt; 0</code></strong></td><td>Treated as 0 (identity traversal)</td><td>Graceful degradation, no exceptions</td></tr>
<tr><td><strong><code>n &gt; list.size()</code></strong></td><td>Clamped to list bounds</td><td>Focus on all available elements</td></tr>
<tr><td><strong>Empty list</strong></td><td>Returns empty list unchanged</td><td>No elements to focus on</td></tr>
<tr><td><strong><code>from &gt;= to</code> in slicing</strong></td><td>Identity traversal (no focus)</td><td>Empty range semantics</td></tr>
<tr><td><strong>Negative <code>from</code> in slicing</strong></td><td>Clamped to 0</td><td>Start from beginning</td></tr>
</tbody></table>
</div>
<pre><code class="language-java">// Examples of edge case handling
List&lt;Integer&gt; numbers = List.of(1, 2, 3);

// n &gt; size: focuses on all elements
List&lt;Integer&gt; result1 = Traversals.getAll(ListTraversals.taking(100), numbers);
// Returns: [1, 2, 3]

// Negative n: identity (no focus)
List&lt;Integer&gt; result2 = Traversals.getAll(ListTraversals.taking(-5), numbers);
// Returns: []

// Inverted range: no focus
List&lt;Integer&gt; result3 = Traversals.getAll(ListTraversals.slicing(3, 1), numbers);
// Returns: []

// Empty list: safe operation
List&lt;Integer&gt; result4 = Traversals.modify(ListTraversals.taking(3), x -&gt; x * 2, List.of());
// Returns: []
</code></pre>
<p>This philosophy ensures <strong>no runtime exceptions</strong> from index bounds, making limiting traversals safe for dynamic data.</p>
<hr />
<h2 id="composing-limiting-traversals"><a class="header" href="#composing-limiting-traversals">Composing Limiting Traversals</a></h2>
<p>The real power emerges when you compose limiting traversals with other optics:</p>
<h3 id="with-lenses--deep-updates"><a class="header" href="#with-lenses--deep-updates">With Lenses – Deep Updates</a></h3>
<pre><code class="language-java">Traversal&lt;List&lt;Product&gt;, Product&gt; first5 = ListTraversals.taking(5);
Lens&lt;Product, Double&gt; priceLens = ProductLenses.price();

// Compose: first 5 products → their prices
Traversal&lt;List&lt;Product&gt;, Double&gt; first5Prices =
    first5.andThen(priceLens.asTraversal());

// Increase prices of first 5 products by 10%
List&lt;Product&gt; result = Traversals.modify(first5Prices, price -&gt; price * 1.1, products);
</code></pre>
<h3 id="with-filtered-traversals--conditional-slicing"><a class="header" href="#with-filtered-traversals--conditional-slicing">With Filtered Traversals – Conditional Slicing</a></h3>
<pre><code class="language-java">// First 10 products that are also low stock
Traversal&lt;List&lt;Product&gt;, Product&gt; first10LowStock =
    ListTraversals.taking(10).filtered(p -&gt; p.stock() &lt; 50);

// Restock only first 10 low-stock products
List&lt;Product&gt; restocked = Traversals.modify(
    first10LowStock,
    p -&gt; new Product(p.sku(), p.name(), p.price(), p.stock() + 100),
    products
);
</code></pre>
<h3 id="with-nested-structures--batch-processing"><a class="header" href="#with-nested-structures--batch-processing">With Nested Structures – Batch Processing</a></h3>
<pre><code class="language-java">// Focus on first 50 orders
Traversal&lt;List&lt;Order&gt;, Order&gt; first50Orders = ListTraversals.taking(50);

// Focus on all line items in those orders
Traversal&lt;List&lt;Order&gt;, LineItem&gt; first50OrderItems =
    first50Orders.andThen(OrderTraversals.items());

// Apply bulk discount to items in first 50 orders
List&lt;Order&gt; processed = Traversals.modify(
    first50OrderItems,
    item -&gt; new LineItem(item.product().applyDiscount(0.05), item.quantity()),
    orders
);
</code></pre>
<hr />
<h2 id="when-to-use-limiting-traversals-vs-other-approaches"><a class="header" href="#when-to-use-limiting-traversals-vs-other-approaches">When to Use Limiting Traversals vs Other Approaches</a></h2>
<h3 id="use-limiting-traversals-when"><a class="header" href="#use-limiting-traversals-when">Use Limiting Traversals When:</a></h3>
<ul>
<li><strong>Positional focus</strong> - You need to operate on elements by index position</li>
<li><strong>Structural preservation</strong> - Non-focused elements must remain in the list</li>
<li><strong>Composable pipelines</strong> - Building complex optic chains with lenses and prisms</li>
<li><strong>Immutable updates</strong> - Transforming portions whilst keeping data immutable</li>
<li><strong>Reusable logic</strong> - Define once, compose everywhere</li>
</ul>
<pre><code class="language-java">// Perfect: Declarative, composable, reusable
Traversal&lt;Catalogue, Double&gt; first10Prices =
    CatalogueLenses.products().asTraversal()
        .andThen(ListTraversals.taking(10))
        .andThen(ProductLenses.price().asTraversal());

Catalogue updated = Traversals.modify(first10Prices, p -&gt; p * 0.9, catalogue);
</code></pre>
<h3 id="use-stream-api-when-2"><a class="header" href="#use-stream-api-when-2">Use Stream API When:</a></h3>
<ul>
<li><strong>Terminal operations</strong> - Counting, finding, collecting to new structures</li>
<li><strong>Complex transformations</strong> - Multiple chained operations with sorting/grouping</li>
<li><strong>No structural preservation needed</strong> - You're extracting data, not updating in place</li>
<li><strong>Performance-critical paths</strong> - Minimal abstraction overhead</li>
</ul>
<pre><code class="language-java">// Better with streams: Complex aggregation
int totalStock = products.stream()
    .limit(100)
    .mapToInt(Product::stock)
    .sum();
</code></pre>
<h3 id="use-manual-loops-when-1"><a class="header" href="#use-manual-loops-when-1">Use Manual Loops When:</a></h3>
<ul>
<li><strong>Early termination with side effects</strong> - Need to break out of loop</li>
<li><strong>Index-dependent logic</strong> - Processing depends on knowing the exact index</li>
<li><strong>Imperative control flow</strong> - Complex branching based on position</li>
</ul>
<pre><code class="language-java">// Sometimes explicit indexing is clearest
for (int i = 0; i &lt; Math.min(10, products.size()); i++) {
    if (products.get(i).stock() == 0) {
        notifyOutOfStock(products.get(i), i);
        break;
    }
}
</code></pre>
<hr />
<h2 id="common-pitfalls-18"><a class="header" href="#common-pitfalls-18">Common Pitfalls</a></h2>
<h3 id="dont-do-this-8"><a class="header" href="#dont-do-this-8">Don't Do This:</a></h3>
<pre><code class="language-java">// Inefficient: Recreating traversals in loops
for (int page = 0; page &lt; totalPages; page++) {
    var slice = ListTraversals.slicing(page * 10, (page + 1) * 10);
    processPage(Traversals.getAll(slice, products));
}

// Confusing: Mixing with Stream operations unnecessarily
List&lt;Product&gt; result = Traversals.getAll(ListTraversals.taking(5), products)
    .stream()
    .limit(3)  // Why limit again? Already took 5!
    .collect(toList());

// Wrong expectation: Thinking it removes elements
Traversal&lt;List&lt;Product&gt;, Product&gt; first3 = ListTraversals.taking(3);
List&lt;Product&gt; modified = Traversals.modify(first3, Product::applyDiscount, products);
// modified.size() == products.size()! Structure preserved, not truncated

// Over-engineering: Using slicing for single element
Traversal&lt;List&lt;Product&gt;, Product&gt; atIndex5 = ListTraversals.slicing(5, 6);
// Consider using Ixed type class for single-element access instead
</code></pre>
<h3 id="do-this-instead-8"><a class="header" href="#do-this-instead-8">Do This Instead:</a></h3>
<pre><code class="language-java">// Efficient: Create traversal once, vary parameters
Traversal&lt;List&lt;Product&gt;, Product&gt; takeN(int n) {
    return ListTraversals.taking(n);
}
// Or store commonly used ones as constants
static final Traversal&lt;List&lt;Product&gt;, Product&gt; FIRST_PAGE = ListTraversals.taking(10);

// Clear: Keep operations at appropriate abstraction level
List&lt;Product&gt; firstFive = Traversals.getAll(ListTraversals.taking(5), products);
// If you need further processing, do it separately

// Correct expectation: Use getAll for extraction, modify for transformation
List&lt;Product&gt; onlyFirst5 = Traversals.getAll(first5, products);  // Extracts subset
List&lt;Product&gt; allWithFirst5Updated = Traversals.modify(first5, p -&gt; p.applyDiscount(0.1), products);  // Updates in place

// Right tool: Use Ixed for single indexed access
Optional&lt;Product&gt; fifth = IxedInstances.listIxed().ix(4).getOptional(products);
</code></pre>
<hr />
<h2 id="performance-notes-7"><a class="header" href="#performance-notes-7">Performance Notes</a></h2>
<p>Limiting traversals are optimised for efficiency:</p>
<ul>
<li><strong>Single pass</strong>: No intermediate list creation; slicing happens during traversal</li>
<li><strong>Structural sharing</strong>: Unchanged portions of the list are reused, not copied</li>
<li><strong>Lazy bounds checking</strong>: Index calculations are minimal and performed once</li>
<li><strong>No boxing overhead</strong>: Direct list operations without stream intermediaries</li>
<li><strong>Composable without penalty</strong>: Chaining with other optics adds no extra iteration</li>
</ul>
<p><strong>Best Practice</strong>: Store frequently-used limiting traversals as constants:</p>
<pre><code class="language-java">public class CatalogueOptics {
    // Pagination constants
    public static final int PAGE_SIZE = 20;

    public static Traversal&lt;List&lt;Product&gt;, Product&gt; page(int pageNum) {
        return ListTraversals.slicing(pageNum * PAGE_SIZE, (pageNum + 1) * PAGE_SIZE);
    }

    // Featured products (first 5)
    public static final Traversal&lt;Catalogue, Product&gt; FEATURED =
        CatalogueLenses.products().asTraversal()
            .andThen(ListTraversals.taking(5));

    // Latest additions (last 10)
    public static final Traversal&lt;Catalogue, Product&gt; LATEST =
        CatalogueLenses.products().asTraversal()
            .andThen(ListTraversals.takingLast(10));

    // Exclude promotional items at end
    public static final Traversal&lt;Catalogue, Product&gt; NON_PROMOTIONAL =
        CatalogueLenses.products().asTraversal()
            .andThen(ListTraversals.droppingLast(3));
}
</code></pre>
<hr />
<h2 id="real-world-example-e-commerce-pagination"><a class="header" href="#real-world-example-e-commerce-pagination">Real-World Example: E-Commerce Pagination</a></h2>
<p>Here's a comprehensive example demonstrating limiting traversals in a business context:</p>
<pre><code class="language-java">package org.higherkindedj.example.optics;

import org.higherkindedj.optics.*;
import org.higherkindedj.optics.util.*;
import java.util.*;

public class PaginationExample {

    public record Product(String sku, String name, double price, boolean featured) {
        Product applyDiscount(double pct) {
            return new Product(sku, name, price * (1 - pct), featured);
        }
    }

    public static void main(String[] args) {
        List&lt;Product&gt; catalogue = createCatalogue();

        System.out.println("=== E-COMMERCE PAGINATION WITH LIMITING TRAVERSALS ===\n");

        // --- Scenario 1: Basic Pagination ---
        System.out.println("--- Scenario 1: Paginated Product Display ---");

        int pageSize = 3;
        int totalPages = (int) Math.ceil(catalogue.size() / (double) pageSize);

        for (int page = 0; page &lt; totalPages; page++) {
            Traversal&lt;List&lt;Product&gt;, Product&gt; pageTraversal =
                ListTraversals.slicing(page * pageSize, (page + 1) * pageSize);

            List&lt;Product&gt; pageProducts = Traversals.getAll(pageTraversal, catalogue);
            System.out.printf("Page %d: %s%n", page + 1,
                pageProducts.stream().map(Product::name).toList());
        }

        // --- Scenario 2: Featured Products ---
        System.out.println("\n--- Scenario 2: Featured Products (First 3) ---");

        Traversal&lt;List&lt;Product&gt;, Product&gt; featured = ListTraversals.taking(3);
        List&lt;Product&gt; featuredProducts = Traversals.getAll(featured, catalogue);
        featuredProducts.forEach(p -&gt;
            System.out.printf("  %s - £%.2f%n", p.name(), p.price()));

        // --- Scenario 3: Apply Discount to Featured ---
        System.out.println("\n--- Scenario 3: 10% Discount on Featured ---");

        List&lt;Product&gt; withDiscount = Traversals.modify(featured, p -&gt; p.applyDiscount(0.1), catalogue);
        System.out.println("After discount on first 3:");
        withDiscount.forEach(p -&gt; System.out.printf("  %s: £%.2f%n", p.name(), p.price()));

        // --- Scenario 4: Exclude Last Items ---
        System.out.println("\n--- Scenario 4: All Except Last 2 (Clearance) ---");

        Traversal&lt;List&lt;Product&gt;, Product&gt; nonClearance = ListTraversals.droppingLast(2);
        List&lt;Product&gt; regularStock = Traversals.getAll(nonClearance, catalogue);
        System.out.println("Regular stock: " + regularStock.stream().map(Product::name).toList());

        System.out.println("\n=== PAGINATION COMPLETE ===");
    }

    private static List&lt;Product&gt; createCatalogue() {
        return List.of(
            new Product("SKU001", "Laptop", 999.99, true),
            new Product("SKU002", "Mouse", 29.99, false),
            new Product("SKU003", "Keyboard", 79.99, true),
            new Product("SKU004", "Monitor", 349.99, true),
            new Product("SKU005", "Webcam", 89.99, false),
            new Product("SKU006", "Headset", 149.99, false),
            new Product("SKU007", "USB Hub", 39.99, false),
            new Product("SKU008", "Desk Lamp", 44.99, false)
        );
    }
}
</code></pre>
<p><strong>Expected Output:</strong></p>
<pre><code>=== E-COMMERCE PAGINATION WITH LIMITING TRAVERSALS ===

--- Scenario 1: Paginated Product Display ---
Page 1: [Laptop, Mouse, Keyboard]
Page 2: [Monitor, Webcam, Headset]
Page 3: [USB Hub, Desk Lamp]

--- Scenario 2: Featured Products (First 3) ---
  Laptop - £999.99
  Mouse - £29.99
  Keyboard - £79.99

--- Scenario 3: 10% Discount on Featured ---
After discount on first 3:
  Laptop: £899.99
  Mouse: £26.99
  Keyboard: £71.99
  Monitor: £349.99
  Webcam: £89.99
  Headset: £149.99
  USB Hub: £39.99
  Desk Lamp: £44.99

--- Scenario 4: All Except Last 2 (Clearance) ---
Regular stock: [Laptop, Mouse, Keyboard, Monitor, Webcam, Headset]

=== PAGINATION COMPLETE ===
</code></pre>
<hr />
<h2 id="the-relationship-to-functional-programming-libraries"><a class="header" href="#the-relationship-to-functional-programming-libraries">The Relationship to Functional Programming Libraries</a></h2>
<p>For those familiar with functional programming, higher-kinded-j's limiting traversals are inspired by similar patterns in:</p>
<h3 id="haskells-lens-library"><a class="header" href="#haskells-lens-library">Haskell's Lens Library</a></h3>
<p>The <a href="https://hackage.haskell.org/package/lens-5.2.3/docs/Control-Lens-Traversal.html"><code>Control.Lens.Traversal</code></a> module provides:</p>
<pre><code class="language-haskell">taking :: Int -&gt; Traversal' [a] a
dropping :: Int -&gt; Traversal' [a] a
</code></pre>
<p>These create traversals that focus on the first/remaining elements, exactly what our <code>ListTraversals.taking()</code> and <code>dropping()</code> do.</p>
<h3 id="scalas-monocle-library"><a class="header" href="#scalas-monocle-library">Scala's Monocle Library</a></h3>
<p><a href="https://www.optics.dev/Monocle/">Monocle</a> provides similar index-based optics:</p>
<pre><code class="language-scala">import monocle.function.Index._

// Focus on element at index
val atIndex: Optional[List[A], A] = index(3)

// Take first n (via custom combinator)
val firstN: Traversal[List[A], A] = ...
</code></pre>
<h3 id="key-differences-in-higher-kinded-j"><a class="header" href="#key-differences-in-higher-kinded-j">Key Differences in Higher-Kinded-J</a></h3>
<ul>
<li><strong>Explicit Applicative instances</strong> rather than implicit type class resolution</li>
<li><strong>Java's type system</strong> requires more explicit composition steps</li>
<li><strong>Additional methods</strong> like <code>takingLast</code> and <code>droppingLast</code> not standard in Haskell lens</li>
<li><strong>Edge case handling</strong> follows Java conventions (no exceptions, graceful clamping)</li>
</ul>
<p><strong>Further Reading:</strong></p>
<ul>
<li><a href="https://hackage.haskell.org/package/lens-tutorial-1.0.4/docs/Control-Lens-Tutorial.html">Haskell Lens Tutorial</a> - Original inspiration for optics</li>
<li><a href="https://leanpub.com/optics-by-example">Optics By Example</a> by Chris Penner - Comprehensive book on optics in Haskell</li>
<li><a href="https://www.optics.dev/Monocle/">Monocle Documentation</a> - Scala optics library with similar patterns</li>
<li><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/stream/Stream.html">Java Stream API</a> - Comparison with <code>limit()</code> and <code>skip()</code></li>
</ul>
<hr />
<h2 id="summary-the-power-of-limiting-traversals"><a class="header" href="#summary-the-power-of-limiting-traversals">Summary: The Power of Limiting Traversals</a></h2>
<p>Limiting traversals bring <strong>positional focus</strong> into the heart of your optic compositions:</p>
<ul>
<li><strong><code>taking(n)</code></strong>: Focus on first n elements</li>
<li><strong><code>dropping(n)</code></strong>: Skip first n, focus on rest</li>
<li><strong><code>takingLast(n)</code></strong>: Focus on last n elements</li>
<li><strong><code>droppingLast(n)</code></strong>: Focus on all except last n</li>
<li><strong><code>slicing(from, to)</code></strong>: Focus on index range [from, to)</li>
</ul>
<p>These tools transform how you work with list portions in immutable data structures:</p>
<div class="table-wrapper"><table><thead><tr><th>Before (Imperative)</th><th>After (Declarative)</th></tr></thead><tbody>
<tr><td>Manual <code>subList()</code> with bounds checking</td><td>Single limiting traversal</td></tr>
<tr><td>Index manipulation breaking composition</td><td>Positional focus as part of optic chain</td></tr>
<tr><td>Explicit list reconstruction</td><td>Automatic structural preservation</td></tr>
<tr><td>Mix of "what" and "how"</td><td>Pure expression of intent</td></tr>
</tbody></table>
</div>
<p>By incorporating limiting traversals into your toolkit, you gain:</p>
<ul>
<li><strong>Expressiveness</strong>: Say "first 10 products" once, compose with other optics</li>
<li><strong>Safety</strong>: No <code>IndexOutOfBoundsException</code>; graceful edge case handling</li>
<li><strong>Composability</strong>: Chain with lenses, prisms, filtered traversals seamlessly</li>
<li><strong>Immutability</strong>: Structure preserved, only focused elements transformed</li>
<li><strong>Clarity</strong>: Business logic separate from index arithmetic</li>
</ul>
<p>Limiting traversals represent the natural evolution of optics for list manipulation: where Stream's <code>limit()</code> and <code>skip()</code> meet the composable, type-safe world of functional optics, all whilst maintaining full referential transparency and structural preservation.</p>
<hr />
<p><strong>Previous:</strong> <a href="optics/filtered_optics.html">Filtered Optics: Predicate-Based Composition</a>
<strong>Next:</strong> <a href="optics/string_traversals.html">String Traversals: Declarative Text Processing</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="optics-iii-precision-and-filtering"><a class="header" href="#optics-iii-precision-and-filtering">Optics III: Precision and Filtering</a></h1>
<blockquote>
<p><em>"I believe the angle and direction of the lines are full of secret meaning."</em></p>
<p>– J.G. Ballard, <em>Crash</em></p>
</blockquote>
<hr />
<p>Sometimes you don't want <em>all</em> the elements. Sometimes you want the expensive ones. Or the ones at specific indices. Or the ones that match a condition known only at runtime.</p>
<p>Optics handle this through filtering and indexing: techniques that narrow focus to exactly the subset you need. A filtered Traversal only operates on elements matching a predicate. An indexed Traversal carries position information alongside each element. Together, they provide surgical precision that would otherwise require verbose, error-prone manual iteration.</p>
<p>The At and Ixed type classes extend this precision to maps and indexed collections, offering principled ways to access, insert, or remove elements at specific keys. If you've ever written <code>map.get(key)</code> followed by null checks and conditional puts, you'll appreciate what these abstractions provide.</p>
<p>This chapter also revisits Prisms with advanced patterns: the <code>nearly</code> prism for predicate-based matching, <code>doesNotMatch</code> for exclusion filtering, and composition strategies for complex sealed interface hierarchies. These are the tools you reach for when the basic patterns no longer suffice.</p>
<p>Fair warning: some of this material is dense. It rewards careful reading.</p>
<hr />
<h2 id="filtering-in-action"><a class="header" href="#filtering-in-action">Filtering in Action</a></h2>
<p>The concept is straightforward; the power is in the composition:</p>
<pre><code>    Order Items: [Laptop, Mouse, Monitor, Keyboard]
                    │       │       │        │
                    ▼       ▼       ▼        ▼
    Unfiltered:   [✓]     [✓]     [✓]      [✓]

    filtered(price &gt; £100):
                  [✓]     [ ]     [✓]      [ ]
                   │               │
                   ▼               ▼
    Focused:   [Laptop]       [Monitor]

    → modify(applyDiscount) only affects Laptop and Monitor
</code></pre>
<p>The filter becomes part of the optic itself, not scattered through your business logic.</p>
<hr />
<h2 id="indexed-access"><a class="header" href="#indexed-access">Indexed Access</a></h2>
<p>When position matters:</p>
<pre><code>    List: ["A", "B", "C", "D"]
           │     │     │     │
    Index: 0     1     2     3

    ┌─────────────────────────────────────────────┐
    │  IndexedTraversal                           │
    │                                             │
    │  getAll → [(0,"A"), (1,"B"), (2,"C"), ...]  │
    │                                             │
    │  modifyIndexed((i, v) -&gt; v + i)             │
    │    → ["A0", "B1", "C2", "D3"]               │
    └─────────────────────────────────────────────┘
</code></pre>
<hr />
<h2 id="what-youll-learn-5"><a class="header" href="#what-youll-learn-5">What You'll Learn</a></h2>
<div id="admonition-in-this-chapter" class="admonition admonish-info" role="note" aria-labelledby="admonition-in-this-chapter-title">
<div class="admonition-title">
<div id="admonition-in-this-chapter-title">
<p>In This Chapter</p>
</div>
<a class="admonition-anchor-link" href="optics/ch3_intro.html#admonition-in-this-chapter"></a>
</div>
<div>
<ul>
<li><strong>Filtered Optics</strong> – Apply predicates to narrow which elements a Traversal affects. Only modify items over a certain price, or extract elements matching a condition.</li>
<li><strong>Indexed Optics</strong> – Carry position information alongside values. Know which index you're modifying, or transform values based on their position in a collection.</li>
<li><strong>String Traversals</strong> – Treat strings as collections of characters. Modify individual characters, filter by character properties, or transform text character-by-character.</li>
<li><strong>At and Ixed</strong> – Type classes for indexed access. <code>At</code> handles keys that may or may not exist (like Map entries); <code>Ixed</code> handles indices that should exist (like List positions).</li>
<li><strong>Advanced Prism Patterns</strong> – Beyond basic sum types: <code>nearly</code> matches values close to a target, <code>doesNotMatch</code> inverts a Prism's focus, and complex hierarchies compose cleanly.</li>
<li><strong>Profunctor Optics</strong> – Transform the input and output types of optics. Adapt an optic for a different representation without rewriting it.</li>
</ul>
</div>
</div>
<hr />
<h2 id="chapter-contents-5"><a class="header" href="#chapter-contents-5">Chapter Contents</a></h2>
<ol>
<li><a href="optics/filtered_optics.html">Filtered Optics</a> - Predicate-based targeting within traversals</li>
<li><a href="optics/indexed_optics.html">Indexed Optics</a> - Position-aware operations on collections</li>
<li><a href="optics/string_traversals.html">String Traversals</a> - Character-level operations on text</li>
<li><a href="optics/indexed_access.html">Indexed Access</a> - At and Ixed type classes for indexed access patterns</li>
<li><a href="optics/advanced_prism_patterns.html">Advanced Prism Patterns</a> - <code>nearly</code>, <code>doesNotMatch</code>, and complex matching</li>
<li><a href="optics/profunctor_optics.html">Profunctor Optics</a> - Type adaptation with contramap, map, and dimap</li>
</ol>
<hr />
<p><strong>Next:</strong> <a href="optics/filtered_optics.html">Filtered Optics</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="filtered-optics-predicate-based-composition"><a class="header" href="#filtered-optics-predicate-based-composition">Filtered Optics: Predicate-Based Composition</a></h1>
<h2 id="declarative-filtering-for-targeted-operations"><a class="header" href="#declarative-filtering-for-targeted-operations"><em>Declarative Filtering for Targeted Operations</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="optics/filtered_optics.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to filter elements within traversals and folds using predicates</li>
<li>Using <code>filtered()</code> for declarative, composable filtering as part of optic composition</li>
<li>The difference between filtering during modification vs filtering during queries</li>
<li>Advanced filtering with <code>filterBy()</code> for query-based predicates</li>
<li>The static <code>Traversals.filtered()</code> combinator for affine traversals</li>
<li>Understanding lazy evaluation semantics (preserved structure vs excluded queries)</li>
<li>When to use filtered optics vs Stream API vs conditional logic</li>
<li>Real-world patterns for customer segmentation, inventory management, and analytics</li>
</ul>
</div>
</div>
<div id="admonition-example-code" class="admonition admonish-note" role="note" aria-labelledby="admonition-example-code-title">
<div class="admonition-title">
<div id="admonition-example-code-title">
<p>Example Code</p>
</div>
<a class="admonition-anchor-link" href="optics/filtered_optics.html#admonition-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/FilteredTraversalExample.java">FilteredTraversalExample</a></p>
</div>
</div>
<p>In our journey through optics, we've seen how <strong>Traversal</strong> handles bulk operations on collections and how <strong>Fold</strong> provides read-only queries. But what happens when you need to operate on only <em>some</em> elements, those that satisfy a specific condition?</p>
<p>Traditionally, filtering requires breaking out of your optic composition to use streams or loops, mixing the <em>what</em> (your transformation logic) with the <em>how</em> (iteration and filtering). <strong>Filtered optics</strong> solve this elegantly by making filtering a first-class part of your optic composition.</p>
<hr />
<h2 id="the-scenario-customer-segmentation-in-a-saas-platform"><a class="header" href="#the-scenario-customer-segmentation-in-a-saas-platform">The Scenario: Customer Segmentation in a SaaS Platform</a></h2>
<p>Imagine you're building a Software-as-a-Service platform where you need to:</p>
<ul>
<li>Grant bonuses only to <strong>active</strong> users</li>
<li>Send notifications to users with <strong>overdue invoices</strong></li>
<li>Analyse spending patterns for customers with <strong>high-value orders</strong></li>
<li>Update pricing only for products <strong>in specific categories</strong></li>
</ul>
<p><strong>The Data Model:</strong></p>
<pre><code class="language-java">@GenerateLenses
public record User(String name, boolean active, int score, SubscriptionTier tier) {
    User grantBonus() {
        return new User(name, active, score + 100, tier);
    }
}

@GenerateLenses
@GenerateFolds
public record Invoice(String id, double amount, boolean overdue) {}

@GenerateLenses
@GenerateFolds
public record Customer(String name, List&lt;Invoice&gt; invoices, SubscriptionTier tier) {}

@GenerateLenses
@GenerateFolds
public record Platform(List&lt;User&gt; users, List&lt;Customer&gt; customers) {}

public enum SubscriptionTier { FREE, BASIC, PREMIUM, ENTERPRISE }
</code></pre>
<p><strong>The Traditional Approach:</strong></p>
<pre><code class="language-java">// Verbose: Manual filtering breaks optic composition
List&lt;User&gt; updatedUsers = platform.users().stream()
    .map(user -&gt; user.active() ? user.grantBonus() : user)
    .collect(Collectors.toList());
Platform updatedPlatform = new Platform(updatedUsers, platform.customers());

// Even worse with nested structures
List&lt;Customer&gt; customersWithOverdue = platform.customers().stream()
    .filter(customer -&gt; customer.invoices().stream()
        .anyMatch(Invoice::overdue))
    .collect(Collectors.toList());
</code></pre>
<p>This approach forces you to abandon the declarative power of optics, manually managing iteration and reconstruction. <strong>Filtered optics</strong> let you express this intent directly within your optic composition.</p>
<hr />
<h2 id="think-of-filtered-optics-like"><a class="header" href="#think-of-filtered-optics-like">Think of Filtered Optics Like...</a></h2>
<ul>
<li><strong>A SQL WHERE clause</strong>: <code>SELECT * FROM users WHERE active = true</code></li>
<li><strong>A spotlight with a mask</strong>: Illuminates only the items that match your criteria</li>
<li><strong>A sieve</strong>: Allows matching elements to pass through whilst blocking others</li>
<li><strong>A conditional lens</strong>: Focuses only on elements satisfying a predicate</li>
<li><strong>A smart selector</strong>: Like CSS selectors that target specific elements based on attributes</li>
</ul>
<p>The key insight: filtering becomes part of your optic's <em>identity</em>, not an external operation applied afterwards.</p>
<hr />
<h2 id="three-ways-to-filter"><a class="header" href="#three-ways-to-filter">Three Ways to Filter</a></h2>
<p>Higher-kinded-j provides three complementary approaches to filtered optics:</p>
<div class="table-wrapper"><table><thead><tr><th>Approach</th><th>Signature</th><th>Use Case</th></tr></thead><tbody>
<tr><td><strong>Instance method</strong></td><td><code>traversal.filtered(predicate)</code></td><td>Filter within an existing traversal</td></tr>
<tr><td><strong>Static combinator</strong></td><td><code>Traversals.filtered(predicate)</code></td><td>Create a reusable affine traversal</td></tr>
<tr><td><strong>Query-based filter</strong></td><td><code>traversal.filterBy(fold, predicate)</code></td><td>Filter based on nested properties</td></tr>
</tbody></table>
</div>
<p>Each serves different needs, and they can be combined for powerful compositions.</p>
<hr />
<h2 id="a-step-by-step-walkthrough-9"><a class="header" href="#a-step-by-step-walkthrough-9">A Step-by-Step Walkthrough</a></h2>
<h3 id="step-1-instance-method--filteredpredicate"><a class="header" href="#step-1-instance-method--filteredpredicate">Step 1: Instance Method – <code>filtered(Predicate)</code></a></h3>
<p>The most intuitive approach: call <code>filtered()</code> on any <code>Traversal</code> or <code>Fold</code> to create a new optic that only focuses on matching elements.</p>
<h4 id="on-traversals-read--write"><a class="header" href="#on-traversals-read--write">On Traversals (Read + Write)</a></h4>
<pre><code class="language-java">// Create a traversal for all users
Traversal&lt;List&lt;User&gt;, User&gt; allUsers = Traversals.forList();

// Filter to active users only
Traversal&lt;List&lt;User&gt;, User&gt; activeUsers = allUsers.filtered(User::active);

// Grant bonus ONLY to active users
List&lt;User&gt; result = Traversals.modify(activeUsers, User::grantBonus, users);
// Active users get bonus; inactive users preserved unchanged

// Extract ONLY active users
List&lt;User&gt; actives = Traversals.getAll(activeUsers, users);
// Returns only those matching the predicate
</code></pre>
<p><strong>Critical Semantic</strong>: During <strong>modification</strong>, non-matching elements are <em>preserved unchanged</em> in the structure. During <strong>queries</strong> (like <code>getAll</code>), they are <em>excluded</em> from the results. This preserves the overall structure whilst focusing operations on the subset you care about.</p>
<h4 id="on-folds-read-only"><a class="header" href="#on-folds-read-only">On Folds (Read-Only)</a></h4>
<pre><code class="language-java">// Fold from Order to Items
Fold&lt;Order, Item&gt; itemsFold = Fold.of(Order::items);

// Filter to expensive items only
Fold&lt;Order, Item&gt; expensiveItems = itemsFold.filtered(item -&gt; item.price() &gt; 100);

// Query operations work on filtered subset
int count = expensiveItems.length(order);           // Count expensive items
List&lt;Item&gt; expensive = expensiveItems.getAll(order); // Get expensive items
double total = expensiveItems.foldMap(sumMonoid, Item::price, order); // Sum expensive
boolean allPremium = expensiveItems.all(Item::isPremium, order);  // Check expensive items
</code></pre>
<h3 id="step-2-composing-filtered-traversals"><a class="header" href="#step-2-composing-filtered-traversals">Step 2: Composing Filtered Traversals</a></h3>
<p>The real power emerges when you compose filtered optics with other optics:</p>
<pre><code class="language-java">// Compose: list → filtered users → user name
Traversal&lt;List&lt;User&gt;, String&gt; activeUserNames =
    Traversals.&lt;User&gt;forList()
        .filtered(User::active)
        .andThen(UserLenses.name().asTraversal());

List&lt;User&gt; users = List.of(
    new User("alice", true, 100, PREMIUM),
    new User("bob", false, 200, FREE),
    new User("charlie", true, 150, BASIC)
);

// Get only active user names
List&lt;String&gt; names = Traversals.getAll(activeUserNames, users);
// Result: ["alice", "charlie"]

// Uppercase only active user names
List&lt;User&gt; result = Traversals.modify(activeUserNames, String::toUpperCase, users);
// Result: [User("ALICE", true, 100), User("bob", false, 200), User("CHARLIE", true, 150)]
// Notice: bob remains unchanged because he's inactive
</code></pre>
<h3 id="step-3-chaining-multiple-filters"><a class="header" href="#step-3-chaining-multiple-filters">Step 3: Chaining Multiple Filters</a></h3>
<p>Filters can be chained to create complex predicates:</p>
<pre><code class="language-java">// Active users with high scores (AND logic)
Traversal&lt;List&lt;User&gt;, User&gt; activeHighScorers =
    Traversals.&lt;User&gt;forList()
        .filtered(User::active)
        .filtered(user -&gt; user.score() &gt; 120);

// Premium or Enterprise tier users
Traversal&lt;List&lt;User&gt;, User&gt; premiumUsers =
    Traversals.&lt;User&gt;forList()
        .filtered(user -&gt; user.tier() == PREMIUM || user.tier() == ENTERPRISE);
</code></pre>
<h3 id="step-4-static-combinator--traversalsfiltered"><a class="header" href="#step-4-static-combinator--traversalsfiltered">Step 4: Static Combinator – <code>Traversals.filtered()</code></a></h3>
<p>The static method creates an <strong>affine traversal</strong> (0 or 1 focus) that can be composed anywhere in a chain:</p>
<pre><code class="language-java">// Create a reusable filter
Traversal&lt;User, User&gt; activeFilter = Traversals.filtered(User::active);

// Use standalone
User user = new User("Alice", true, 100, BASIC);
User result = Traversals.modify(activeFilter, User::grantBonus, user);
// If active, grants bonus; otherwise returns unchanged

// Compose into a pipeline
Traversal&lt;List&lt;User&gt;, String&gt; activeUserNames =
    Traversals.&lt;User&gt;forList()
        .andThen(Traversals.filtered(User::active))  // Static combinator
        .andThen(UserLenses.name().asTraversal());
</code></pre>
<p><strong>When to use the static combinator vs instance method:</strong></p>
<ul>
<li><strong>Static combinator</strong>: When you want a reusable filter that can be inserted into different compositions</li>
<li><strong>Instance method</strong>: When filtering is a natural part of a specific traversal's behaviour</li>
</ul>
<p>Both approaches are semantically equivalent; choose based on readability and reusability:</p>
<pre><code class="language-java">// These are equivalent:
Traversal&lt;List&lt;User&gt;, User&gt; approach1 = Traversals.&lt;User&gt;forList().filtered(User::active);
Traversal&lt;List&lt;User&gt;, User&gt; approach2 = Traversals.&lt;User&gt;forList().andThen(Traversals.filtered(User::active));
</code></pre>
<h3 id="step-5-advanced-filtering--filterbyfold-predicate"><a class="header" href="#step-5-advanced-filtering--filterbyfold-predicate">Step 5: Advanced Filtering – <code>filterBy(Fold, Predicate)</code></a></h3>
<p>Sometimes you need to filter based on <em>nested</em> properties or aggregated queries. The <code>filterBy</code> method accepts a <code>Fold</code> that queries each element, including only those where at least one queried value matches the predicate.</p>
<p><strong>Example: Customers with Overdue Invoices</strong></p>
<pre><code class="language-java">Traversal&lt;List&lt;Customer&gt;, Customer&gt; allCustomers = Traversals.forList();
Fold&lt;Customer, Invoice&gt; customerInvoices = Fold.of(Customer::invoices);

// Filter customers who have ANY overdue invoice
Traversal&lt;List&lt;Customer&gt;, Customer&gt; customersWithOverdue =
    allCustomers.filterBy(customerInvoices, Invoice::overdue);

// Update tier for customers with overdue invoices
Lens&lt;Customer, SubscriptionTier&gt; tierLens = CustomerLenses.tier();
List&lt;Customer&gt; updated = Traversals.modify(
    customersWithOverdue.andThen(tierLens.asTraversal()),
    tier -&gt; SubscriptionTier.BASIC,  // Downgrade tier
    customers
);
</code></pre>
<p><strong>Example: Orders with High-Value Items</strong></p>
<pre><code class="language-java">Traversal&lt;List&lt;Order&gt;, Order&gt; allOrders = Traversals.forList();
Fold&lt;Order, Item&gt; orderItems = Fold.of(Order::items);

// Orders containing at least one item over £500
Traversal&lt;List&lt;Order&gt;, Order&gt; highValueOrders =
    allOrders.filterBy(orderItems, item -&gt; item.price() &gt; 500);

List&lt;Order&gt; result = Traversals.getAll(highValueOrders, orders);
// Returns orders that have at least one expensive item
</code></pre>
<p><strong>Example: Using Composed Folds</strong></p>
<pre><code class="language-java">Traversal&lt;List&lt;Customer&gt;, Customer&gt; allCustomers = Traversals.forList();
Fold&lt;Customer, Order&gt; customerOrders = Fold.of(Customer::orders);
Fold&lt;Order, Item&gt; orderItems = Fold.of(Order::items);

// Fold from Customer to all their Items (across all orders)
Fold&lt;Customer, Item&gt; customerItems = customerOrders.andThen(orderItems);

// Customers who have purchased any premium product
Traversal&lt;List&lt;Customer&gt;, Customer&gt; premiumBuyers =
    allCustomers.filterBy(customerItems, Item::isPremium);

// Mark them as VIP
Lens&lt;Customer, String&gt; nameLens = CustomerLenses.name();
Traversal&lt;List&lt;Customer&gt;, String&gt; premiumBuyerNames =
    premiumBuyers.andThen(nameLens.asTraversal());

List&lt;Customer&gt; result = Traversals.modify(
    premiumBuyerNames,
    name -&gt; name + " [VIP]",
    customers
);
</code></pre>
<hr />
<h2 id="understanding-the-semantics-preserved-vs-excluded"><a class="header" href="#understanding-the-semantics-preserved-vs-excluded">Understanding the Semantics: Preserved vs Excluded</a></h2>
<p>A crucial aspect of filtered optics is understanding what happens to non-matching elements:</p>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Non-Matching Elements</th></tr></thead><tbody>
<tr><td><strong><code>modify</code></strong> / <strong><code>modifyF</code></strong></td><td>Preserved unchanged in the structure</td></tr>
<tr><td><strong><code>getAll</code></strong></td><td>Excluded from results</td></tr>
<tr><td><strong><code>foldMap</code></strong> / <strong><code>exists</code></strong> / <strong><code>all</code></strong></td><td>Excluded from aggregation</td></tr>
<tr><td><strong><code>length</code></strong></td><td>Not counted</td></tr>
</tbody></table>
</div>
<p><strong>Visual Example:</strong></p>
<pre><code class="language-java">List&lt;User&gt; users = List.of(
    new User("Alice", true, 100),   // active
    new User("Bob", false, 200),    // inactive
    new User("Charlie", true, 150)  // active
);

Traversal&lt;List&lt;User&gt;, User&gt; activeUsers = forList().filtered(User::active);

// MODIFY: Structure preserved, only matching modified
List&lt;User&gt; modified = Traversals.modify(activeUsers, User::grantBonus, users);
// [User(Alice, true, 200), User(Bob, false, 200), User(Charlie, true, 250)]
//  ↑ modified               ↑ UNCHANGED           ↑ modified

// QUERY: Only matching elements returned
List&lt;User&gt; gotten = Traversals.getAll(activeUsers, users);
// [User(Alice, true, 100), User(Charlie, true, 150)]
// Bob is EXCLUDED entirely
</code></pre>
<p>This behaviour is intentional: it allows you to <strong>transform selectively</strong> whilst maintaining referential integrity, and <strong>query selectively</strong> without polluting results.</p>
<hr />
<h2 id="when-to-use-filtered-optics-vs-other-approaches"><a class="header" href="#when-to-use-filtered-optics-vs-other-approaches">When to Use Filtered Optics vs Other Approaches</a></h2>
<h3 id="use-filtered-optics-when"><a class="header" href="#use-filtered-optics-when">Use Filtered Optics When:</a></h3>
<ul>
<li><strong>Declarative composition</strong> - You want filtering to be part of the optic's definition</li>
<li><strong>Selective modifications</strong> - Modify only elements matching criteria</li>
<li><strong>Reusable filters</strong> - Define once, compose everywhere</li>
<li><strong>Type-safe pipelines</strong> - Filter as part of a larger optic chain</li>
<li><strong>Intent clarity</strong> - Express "active users" as a single concept</li>
</ul>
<pre><code class="language-java">// Perfect: Declarative, composable, reusable
Traversal&lt;Platform, User&gt; activeEnterpriseUsers =
    PlatformTraversals.users()
        .filtered(User::active)
        .filtered(user -&gt; user.tier() == ENTERPRISE);

Platform updated = Traversals.modify(activeEnterpriseUsers, User::grantBonus, platform);
</code></pre>
<h3 id="use-stream-api-when-3"><a class="header" href="#use-stream-api-when-3">Use Stream API When:</a></h3>
<ul>
<li><strong>Complex transformations</strong> - Multiple map/filter/reduce operations</li>
<li><strong>Collecting to different structures</strong> - Need to change the collection type</li>
<li><strong>Statistical operations</strong> - Sorting, limiting, grouping</li>
<li><strong>One-off queries</strong> - Not building reusable logic</li>
</ul>
<pre><code class="language-java">// Better with streams: Complex pipeline with sorting and limiting
List&lt;String&gt; topActiveUserNames = users.stream()
    .filter(User::active)
    .sorted(Comparator.comparing(User::score).reversed())
    .limit(10)
    .map(User::name)
    .collect(toList());
</code></pre>
<h3 id="use-conditional-logic-when"><a class="header" href="#use-conditional-logic-when">Use Conditional Logic When:</a></h3>
<ul>
<li><strong>Control flow</strong> - Early returns, exceptions, complex branching</li>
<li><strong>Side effects</strong> - Logging, metrics, external calls based on conditions</li>
<li><strong>Performance critical</strong> - Minimal abstraction overhead needed</li>
</ul>
<pre><code class="language-java">// Sometimes explicit logic is clearest
for (User user : users) {
    if (user.active() &amp;&amp; user.score() &lt; 0) {
        throw new IllegalStateException("Active user with negative score: " + user);
    }
}
</code></pre>
<hr />
<h2 id="common-pitfalls-19"><a class="header" href="#common-pitfalls-19">Common Pitfalls</a></h2>
<h3 id="dont-do-this-9"><a class="header" href="#dont-do-this-9">Don't Do This:</a></h3>
<pre><code class="language-java">// Inefficient: Recreating filtered traversals in loops
for (Platform platform : platforms) {
    var activeUsers = Traversals.&lt;User&gt;forList().filtered(User::active);
    Traversals.modify(activeUsers, User::grantBonus, platform.users());
}

// Confusing: Mixing filtering approaches
List&lt;User&gt; activeUsers = Traversals.getAll(userTraversal, users).stream()
    .filter(User::active)  // Filtering AFTER optic extraction defeats the purpose
    .collect(toList());

// Wrong mental model: Expecting structure change
Traversal&lt;List&lt;User&gt;, User&gt; active = forList().filtered(User::active);
List&lt;User&gt; result = Traversals.modify(active, User::grantBonus, users);
// result still has same LENGTH as users! Non-matching preserved, not removed

// Over-engineering: Filtering for trivial cases
Fold&lt;User, Boolean&gt; isActiveFold = UserLenses.active().asFold();
boolean active = isActiveFold.getAll(user).get(0); // Just use user.active()!
</code></pre>
<h3 id="do-this-instead-9"><a class="header" href="#do-this-instead-9">Do This Instead:</a></h3>
<pre><code class="language-java">// Efficient: Create filtered optic once, reuse many times
Traversal&lt;List&lt;User&gt;, User&gt; activeUsers = Traversals.&lt;User&gt;forList().filtered(User::active);
for (Platform platform : platforms) {
    Traversals.modify(activeUsers, User::grantBonus, platform.users());
}

// Clear: Filter is part of the optic definition
Traversal&lt;List&lt;User&gt;, User&gt; activeUsers = forList().filtered(User::active);
List&lt;User&gt; result = Traversals.getAll(activeUsers, users);
// Returns only active users

// Correct expectation: Use getAll for extraction, modify for transformation
List&lt;User&gt; onlyActives = Traversals.getAll(activeUsers, users);  // Filters results
List&lt;User&gt; allWithActivesBonused = Traversals.modify(activeUsers, User::grantBonus, users);  // Preserves structure

// Simple: Use direct access for trivial cases
boolean isActive = user.active();
</code></pre>
<hr />
<h2 id="performance-notes-8"><a class="header" href="#performance-notes-8">Performance Notes</a></h2>
<p>Filtered optics are optimised for efficiency:</p>
<ul>
<li><strong>Lazy evaluation</strong>: The predicate is only called when needed</li>
<li><strong>Short-circuiting</strong>: Operations like <code>exists</code> and <code>find</code> stop at first match</li>
<li><strong>No intermediate collections</strong>: Filtering happens during traversal, not before</li>
<li><strong>Structural sharing</strong>: Unmodified parts of the structure are reused</li>
<li><strong>Single pass</strong>: Both filtering and transformation occur in one traversal</li>
</ul>
<p><strong>Best Practice</strong>: Store frequently-used filtered traversals as constants:</p>
<pre><code class="language-java">public class PlatformOptics {
    public static final Traversal&lt;Platform, User&gt; ACTIVE_USERS =
        PlatformTraversals.users().filtered(User::active);

    public static final Traversal&lt;Platform, User&gt; PREMIUM_ACTIVE_USERS =
        ACTIVE_USERS.filtered(user -&gt; user.tier() == PREMIUM);

    public static final Traversal&lt;Platform, Customer&gt; CUSTOMERS_WITH_OVERDUE =
        PlatformTraversals.customers()
            .filterBy(CustomerFolds.invoices(), Invoice::overdue);

    public static final Fold&lt;Platform, Invoice&gt; ALL_OVERDUE_INVOICES =
        PlatformFolds.customers()
            .andThen(CustomerFolds.invoices())
            .filtered(Invoice::overdue);
}
</code></pre>
<hr />
<h2 id="real-world-example-customer-analytics-dashboard"><a class="header" href="#real-world-example-customer-analytics-dashboard">Real-World Example: Customer Analytics Dashboard</a></h2>
<p>Here's a comprehensive example demonstrating filtered optics in a business context:</p>
<pre><code class="language-java">package org.higherkindedj.example.optics;

import org.higherkindedj.optics.*;
import org.higherkindedj.optics.util.Traversals;
import org.higherkindedj.hkt.Monoids;
import java.util.*;

public class CustomerAnalytics {

    public record Item(String name, int price, String category, boolean premium) {}
    public record Order(String id, List&lt;Item&gt; items, double total) {}
    public record Customer(String name, List&lt;Order&gt; orders, boolean vip) {}

    // Reusable optics
    private static final Fold&lt;Customer, Order&gt; CUSTOMER_ORDERS = Fold.of(Customer::orders);
    private static final Fold&lt;Order, Item&gt; ORDER_ITEMS = Fold.of(Order::items);
    private static final Fold&lt;Customer, Item&gt; ALL_CUSTOMER_ITEMS =
        CUSTOMER_ORDERS.andThen(ORDER_ITEMS);

    public static void main(String[] args) {
        List&lt;Customer&gt; customers = createSampleData();

        System.out.println("=== CUSTOMER ANALYTICS WITH FILTERED OPTICS ===\n");

        // --- Analysis 1: High-Value Customer Identification ---
        System.out.println("--- Analysis 1: High-Value Customers ---");

        Traversal&lt;List&lt;Customer&gt;, Customer&gt; allCustomers = Traversals.forList();
        Fold&lt;Customer, Double&gt; orderTotals = CUSTOMER_ORDERS.andThen(
            Getter.of(Order::total).asFold()
        );

        // Customers with any order over £500
        Traversal&lt;List&lt;Customer&gt;, Customer&gt; bigSpenders =
            allCustomers.filterBy(orderTotals, total -&gt; total &gt; 500);

        List&lt;Customer&gt; highValue = Traversals.getAll(bigSpenders, customers);
        System.out.println("Customers with orders over £500: " +
            highValue.stream().map(Customer::name).toList());

        // --- Analysis 2: Premium Product Buyers ---
        System.out.println("\n--- Analysis 2: Premium Product Buyers ---");

        Fold&lt;Customer, Item&gt; premiumItems = ALL_CUSTOMER_ITEMS.filtered(Item::premium);

        for (Customer customer : customers) {
            int premiumCount = premiumItems.length(customer);
            if (premiumCount &gt; 0) {
                double premiumSpend = premiumItems.foldMap(Monoids.doubleAddition(),
                    item -&gt; (double) item.price(), customer);
                System.out.printf("%s: %d premium items, £%.2f total%n",
                    customer.name(), premiumCount, premiumSpend);
            }
        }

        // --- Analysis 3: Category-Specific Queries ---
        System.out.println("\n--- Analysis 3: Electronics Spending ---");

        Fold&lt;Customer, Item&gt; electronicsItems =
            ALL_CUSTOMER_ITEMS.filtered(item -&gt; "Electronics".equals(item.category()));

        for (Customer customer : customers) {
            double electronicsSpend = electronicsItems.foldMap(Monoids.doubleAddition(),
                item -&gt; (double) item.price(), customer);
            if (electronicsSpend &gt; 0) {
                System.out.printf("%s spent £%.2f on Electronics%n",
                    customer.name(), electronicsSpend);
            }
        }

        // --- Analysis 4: Mark VIP Customers ---
        System.out.println("\n--- Analysis 4: Auto-Mark VIP Customers ---");

        // Customers who bought premium items AND have any order over £300
        Traversal&lt;List&lt;Customer&gt;, Customer&gt; potentialVIPs =
            allCustomers
                .filterBy(ALL_CUSTOMER_ITEMS, Item::premium)  // Has premium items
                .filterBy(orderTotals, total -&gt; total &gt; 300); // Has high-value orders

        Lens&lt;Customer, Boolean&gt; vipLens =
            Lens.of(Customer::vip, (c, v) -&gt; new Customer(c.name(), c.orders(), v));

        List&lt;Customer&gt; updatedCustomers = Traversals.modify(
            potentialVIPs.andThen(vipLens.asTraversal()),
            _ -&gt; true,
            customers
        );

        for (Customer c : updatedCustomers) {
            if (c.vip()) {
                System.out.println(c.name() + " is now VIP");
            }
        }

        // --- Analysis 5: Aggregated Statistics ---
        System.out.println("\n--- Analysis 5: Platform Statistics ---");

        Fold&lt;List&lt;Customer&gt;, Customer&gt; customerFold = Fold.of(list -&gt; list);
        Fold&lt;List&lt;Customer&gt;, Item&gt; allItems = customerFold.andThen(ALL_CUSTOMER_ITEMS);

        Fold&lt;List&lt;Customer&gt;, Item&gt; expensiveItems = allItems.filtered(i -&gt; i.price() &gt; 100);
        Fold&lt;List&lt;Customer&gt;, Item&gt; cheapItems = allItems.filtered(i -&gt; i.price() &lt;= 100);

        int totalExpensive = expensiveItems.length(customers);
        int totalCheap = cheapItems.length(customers);
        double expensiveRevenue = expensiveItems.foldMap(Monoids.doubleAddition(),
            i -&gt; (double) i.price(), customers);

        System.out.printf("Expensive items (&gt;£100): %d items, £%.2f revenue%n",
            totalExpensive, expensiveRevenue);
        System.out.printf("Budget items (≤£100): %d items%n", totalCheap);

        System.out.println("\n=== END OF ANALYTICS ===");
    }

    private static List&lt;Customer&gt; createSampleData() {
        return List.of(
            new Customer("Alice", List.of(
                new Order("A1", List.of(
                    new Item("Laptop", 999, "Electronics", true),
                    new Item("Mouse", 25, "Electronics", false)
                ), 1024.0),
                new Order("A2", List.of(
                    new Item("Desk", 350, "Furniture", false)
                ), 350.0)
            ), false),
            new Customer("Bob", List.of(
                new Order("B1", List.of(
                    new Item("Book", 20, "Books", false),
                    new Item("Pen", 5, "Stationery", false)
                ), 25.0)
            ), false),
            new Customer("Charlie", List.of(
                new Order("C1", List.of(
                    new Item("Phone", 800, "Electronics", true),
                    new Item("Case", 50, "Accessories", false)
                ), 850.0),
                new Order("C2", List.of(
                    new Item("Headphones", 250, "Electronics", true)
                ), 250.0)
            ), false)
        );
    }
}
</code></pre>
<p><strong>Expected Output:</strong></p>
<pre><code>=== CUSTOMER ANALYTICS WITH FILTERED OPTICS ===

--- Analysis 1: High-Value Customers ---
Customers with orders over £500: [Alice, Charlie]

--- Analysis 2: Premium Product Buyers ---
Alice: 1 premium items, £999.00 total
Charlie: 2 premium items, £1050.00 total

--- Analysis 3: Electronics Spending ---
Alice spent £1024.00 on Electronics
Charlie spent £1050.00 on Electronics

--- Analysis 4: Auto-Mark VIP Customers ---
Alice is now VIP
Charlie is now VIP

--- Analysis 5: Platform Statistics ---
Expensive items (&gt;£100): 5 items, £3149.00 revenue
Budget items (≤£100): 4 items

=== END OF ANALYTICS ===
</code></pre>
<hr />
<h2 id="the-relationship-to-haskells-lens-library"><a class="header" href="#the-relationship-to-haskells-lens-library">The Relationship to Haskell's Lens Library</a></h2>
<p>For those familiar with functional programming, higher-kinded-j's filtered optics are inspired by Haskell's <a href="https://hackage.haskell.org/package/lens">lens library</a>, specifically the <a href="https://hackage.haskell.org/package/lens-5.2.3/docs/Control-Lens-Traversal.html#v:filtered"><code>filtered</code></a> combinator.</p>
<p>In Haskell:</p>
<pre><code class="language-haskell">filtered :: (a -&gt; Bool) -&gt; Traversal' a a
</code></pre>
<p>This creates a traversal that focuses on the value only if it satisfies the predicate, exactly what our <code>Traversals.filtered(Predicate)</code> does.</p>
<p><strong>Key differences:</strong></p>
<ul>
<li>Higher-kinded-j uses explicit <code>Applicative</code> instances rather than implicit type class resolution</li>
<li>Java's type system requires more explicit composition steps</li>
<li>The <code>filterBy</code> method is an extension not present in standard lens</li>
</ul>
<p><strong>Further Reading:</strong></p>
<ul>
<li><a href="https://hackage.haskell.org/package/lens-tutorial-1.0.4/docs/Control-Lens-Tutorial.html">Haskell Lens Tutorial: Traversal</a> - Original inspiration</li>
<li><a href="https://leanpub.com/optics-by-example">Optics By Example</a> by Chris Penner - Comprehensive book on optics</li>
<li><a href="https://www.optics.dev/Monocle/">Monocle (Scala)</a> - Similar library for Scala with <code>filtered</code> support</li>
</ul>
<hr />
<h2 id="summary-the-power-of-filtered-optics"><a class="header" href="#summary-the-power-of-filtered-optics">Summary: The Power of Filtered Optics</a></h2>
<p>Filtered optics bring <strong>declarative filtering</strong> into the heart of your optic compositions:</p>
<ul>
<li><strong><code>filtered(Predicate)</code></strong>: Focus on elements matching a condition</li>
<li><strong><code>filterBy(Fold, Predicate)</code></strong>: Focus on elements where a nested query matches</li>
<li><strong><code>Traversals.filtered(Predicate)</code></strong>: Create reusable affine filter combinators</li>
</ul>
<p>These tools transform how you work with collections in immutable data structures:</p>
<div class="table-wrapper"><table><thead><tr><th>Before (Imperative)</th><th>After (Declarative)</th></tr></thead><tbody>
<tr><td>Manual loops with conditionals</td><td>Single filtered traversal</td></tr>
<tr><td>Stream pipelines breaking composition</td><td>Filters as part of optic chain</td></tr>
<tr><td>Logic scattered across codebase</td><td>Reusable, composable filter optics</td></tr>
<tr><td>Mix of "what" and "how"</td><td>Pure expression of intent</td></tr>
</tbody></table>
</div>
<p>By incorporating filtered optics into your toolkit, you gain:</p>
<ul>
<li><strong>Expressiveness</strong>: Say "active users" once, use everywhere</li>
<li><strong>Composability</strong>: Chain filters, compose with lenses, build complex paths</li>
<li><strong>Type safety</strong>: All operations checked at compile time</li>
<li><strong>Immutability</strong>: Structure preserved, only targets modified</li>
<li><strong>Performance</strong>: Single-pass, lazy evaluation, no intermediate collections</li>
</ul>
<p>Filtered optics represent the pinnacle of declarative data manipulation in Java: the <em>what</em> (your business logic) is cleanly separated from the <em>how</em> (iteration, filtering, reconstruction), all whilst maintaining full type safety and referential transparency.</p>
<hr />
<p><strong>Previous:</strong> <a href="optics/folds.html">Folds: Querying Immutable Data</a>
<strong>Next:</strong> <a href="optics/indexed_optics.html">Indexed Optics: Position-Aware Operations</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="indexed-optics-position-aware-operations"><a class="header" href="#indexed-optics-position-aware-operations">Indexed Optics: Position-Aware Operations</a></h1>
<h2 id="tracking-indices-during-transformations"><a class="header" href="#tracking-indices-during-transformations"><em>Tracking Indices During Transformations</em></a></h2>
<p><img src="optics/../images/indexed-optics.jpg" alt="indexed-optics.jpg" /></p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="optics/indexed_optics.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to access both index and value during optic operations</li>
<li>Using IndexedTraversal for position-aware bulk updates</li>
<li>Using IndexedFold for queries that need position information</li>
<li>Using IndexedLens for field name tracking and debugging</li>
<li>Creating indexed traversals for Lists and Maps with IndexedTraversals utility</li>
<li>Composing indexed optics with paired indices (Pair&lt;I, J&gt;)</li>
<li>Converting between indexed and non-indexed optics</li>
<li>When to use indexed optics vs standard optics</li>
<li>Real-world patterns for debugging, audit trails, and position-based logic</li>
</ul>
</div>
</div>
<div id="admonition-example-code" class="admonition admonish-note" role="note" aria-labelledby="admonition-example-code-title">
<div class="admonition-title">
<div id="admonition-example-code-title">
<p>Example Code</p>
</div>
<a class="admonition-anchor-link" href="optics/indexed_optics.html#admonition-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/IndexedOpticsExample.java">IndexedOpticsExample</a></p>
</div>
</div>
<p>In our journey through optics, we've mastered how to focus on parts of immutable data structures, whether it's a single field with <strong>Lens</strong>, an optional value with <strong>Prism</strong>, or multiple elements with <strong>Traversal</strong>. But sometimes, knowing <em>where</em> you are is just as important as knowing <em>what</em> you're looking at.</p>
<p>Consider these scenarios:</p>
<ul>
<li><strong>Numbering items</strong> in a packing list: "Item 1: Laptop, Item 2: Mouse..."</li>
<li><strong>Tracking field names</strong> for audit logs: "User modified field 'email' from..."</li>
<li><strong>Processing map entries</strong> where both key and value matter: "For metadata key 'priority', set value to..."</li>
<li><strong>Debugging nested updates</strong> by seeing the complete path: "Changed scores[2] from 100 to 150"</li>
</ul>
<p>Standard optics give you the <em>value</em>. <strong>Indexed optics</strong> give you both the <em>index</em> and the <em>value</em>.</p>
<hr />
<h2 id="the-scenario-e-commerce-order-processing"><a class="header" href="#the-scenario-e-commerce-order-processing">The Scenario: E-Commerce Order Processing</a></h2>
<p>Imagine building an order fulfilment system where position information drives business logic.</p>
<p><strong>The Data Model:</strong></p>
<pre><code class="language-java">@GenerateLenses
public record LineItem(String productName, int quantity, double price) {}

@GenerateLenses
@GenerateTraversals
public record Order(String orderId, List&lt;LineItem&gt; items, Map&lt;String, String&gt; metadata) {}

@GenerateLenses
public record Customer(String name, String email) {}
</code></pre>
<p><strong>Business Requirements:</strong></p>
<ol>
<li><strong>Generate packing slips</strong> with numbered items: "Item 1: Laptop (£999.99)"</li>
<li><strong>Process metadata</strong> with key awareness: "Set shipping method based on 'priority' key"</li>
<li><strong>Audit trail</strong> showing which fields were modified: "Updated Customer.email at 2025-01-15 10:30"</li>
<li><strong>Position-based pricing</strong> for bulk orders: "Items at even positions get 10% discount"</li>
</ol>
<p><strong>The Traditional Approach:</strong></p>
<pre><code class="language-java">// Verbose: Manual index tracking
List&lt;String&gt; packingSlip = new ArrayList&lt;&gt;();
for (int i = 0; i &lt; order.items().size(); i++) {
    LineItem item = order.items().get(i);
    packingSlip.add("Item " + (i + 1) + ": " + item.productName());
}

// Or with streams, losing type-safety
AtomicInteger counter = new AtomicInteger(1);
order.items().stream()
    .map(item -&gt; "Item " + counter.getAndIncrement() + ": " + item.productName())
    .collect(toList());

// Map processing requires breaking into entries
order.metadata().entrySet().stream()
    .map(entry -&gt; processWithKey(entry.getKey(), entry.getValue()))
    .collect(toMap(Entry::getKey, Entry::getValue));
</code></pre>
<p>This approach forces manual index management, mixing the <em>what</em> (transformation logic) with the <em>how</em> (index tracking). <strong>Indexed optics</strong> provide a declarative, type-safe solution.</p>
<hr />
<h2 id="think-of-indexed-optics-like"><a class="header" href="#think-of-indexed-optics-like">Think of Indexed Optics Like...</a></h2>
<ul>
<li><strong>GPS coordinates</strong>: Not just the destination, but the latitude and longitude</li>
<li><strong>Line numbers in an editor</strong>: Every line knows its position in the file</li>
<li><strong>Map.Entry</strong>: Provides both key and value instead of just the value</li>
<li><strong>Breadcrumbs in a file system</strong>: Showing the complete path to each file</li>
<li><strong>A numbered list</strong>: Each element has both content and a position</li>
<li><strong>Spreadsheet cells</strong>: Both the cell reference (A1, B2) and the value</li>
</ul>
<p>The key insight: indexed optics make <em>position</em> a first-class citizen, accessible during every operation.</p>
<hr />
<h2 id="part-i-the-basics"><a class="header" href="#part-i-the-basics">Part I: The Basics</a></h2>
<h3 id="the-three-indexed-optics"><a class="header" href="#the-three-indexed-optics">The Three Indexed Optics</a></h3>
<p>Higher-kinded-j provides three indexed optics that mirror their standard counterparts:</p>
<div class="table-wrapper"><table><thead><tr><th>Standard Optic</th><th>Indexed Variant</th><th>Index Type</th><th>Use Case</th></tr></thead><tbody>
<tr><td><strong>Traversal&lt;S, A&gt;</strong></td><td><strong>IndexedTraversal&lt;I, S, A&gt;</strong></td><td><code>I</code> (any type)</td><td>Position-aware bulk updates (List indices, Map keys)</td></tr>
<tr><td><strong>Fold&lt;S, A&gt;</strong></td><td><strong>IndexedFold&lt;I, S, A&gt;</strong></td><td><code>I</code> (any type)</td><td>Position-aware read-only queries</td></tr>
<tr><td><strong>Lens&lt;S, A&gt;</strong></td><td><strong>IndexedLens&lt;I, S, A&gt;</strong></td><td><code>I</code> (any type)</td><td>Field name tracking for single-field access</td></tr>
</tbody></table>
</div>
<p>The additional type parameter <code>I</code> represents the <strong>index type</strong>:</p>
<ul>
<li>For <code>List&lt;A&gt;</code>: <code>I</code> is <code>Integer</code> (position 0, 1, 2...)</li>
<li>For <code>Map&lt;K, V&gt;</code>: <code>I</code> is <code>K</code> (the key type)</li>
<li>For record fields: <code>I</code> is <code>String</code> (field name)</li>
<li>Custom: Any type that makes sense for your domain</li>
</ul>
<hr />
<h2 id="a-step-by-step-walkthrough-10"><a class="header" href="#a-step-by-step-walkthrough-10">A Step-by-Step Walkthrough</a></h2>
<h3 id="step-1-creating-indexed-traversals"><a class="header" href="#step-1-creating-indexed-traversals">Step 1: Creating Indexed Traversals</a></h3>
<p>The <code>IndexedTraversals</code> utility class provides factory methods for common cases.</p>
<h4 id="for-lists-integer-indices"><a class="header" href="#for-lists-integer-indices">For Lists: Integer Indices</a></h4>
<pre><code class="language-java">import org.higherkindedj.optics.indexed.IndexedTraversal;
import org.higherkindedj.optics.util.IndexedTraversals;

// Create an indexed traversal for List elements
IndexedTraversal&lt;Integer, List&lt;LineItem&gt;, LineItem&gt; itemsWithIndex =
    IndexedTraversals.forList();

List&lt;LineItem&gt; items = List.of(
    new LineItem("Laptop", 1, 999.99),
    new LineItem("Mouse", 2, 24.99),
    new LineItem("Keyboard", 1, 79.99)
);
</code></pre>
<p>The <code>forList()</code> factory creates a traversal where each element is paired with its zero-based index.</p>
<h4 id="for-maps-key-based-indices"><a class="header" href="#for-maps-key-based-indices">For Maps: Key-Based Indices</a></h4>
<pre><code class="language-java">// Create an indexed traversal for Map values
IndexedTraversal&lt;String, Map&lt;String, String&gt;, String&gt; metadataWithKeys =
    IndexedTraversals.forMap();

Map&lt;String, String&gt; metadata = Map.of(
    "priority", "express",
    "gift-wrap", "true",
    "delivery-note", "Leave at door"
);
</code></pre>
<p>The <code>forMap()</code> factory creates a traversal where each value is paired with its key.</p>
<hr />
<h3 id="step-2-accessing-index-value-pairs"><a class="header" href="#step-2-accessing-index-value-pairs">Step 2: Accessing Index-Value Pairs</a></h3>
<p>Indexed optics provide specialized methods that give you access to both the index and the value.</p>
<h4 id="extracting-all-index-value-pairs"><a class="header" href="#extracting-all-index-value-pairs">Extracting All Index-Value Pairs</a></h4>
<pre><code class="language-java">import org.higherkindedj.optics.indexed.Pair;

// Get list of (index, item) pairs
List&lt;Pair&lt;Integer, LineItem&gt;&gt; indexedItems = itemsWithIndex.toIndexedList(items);

for (Pair&lt;Integer, LineItem&gt; pair : indexedItems) {
    int position = pair.first();
    LineItem item = pair.second();
    System.out.println("Position " + position + ": " + item.productName());
}
// Output:
// Position 0: Laptop
// Position 1: Mouse
// Position 2: Keyboard
</code></pre>
<h4 id="using-indexedfold-for-queries"><a class="header" href="#using-indexedfold-for-queries">Using IndexedFold for Queries</a></h4>
<pre><code class="language-java">import org.higherkindedj.optics.indexed.IndexedFold;

// Convert to read-only indexed fold
IndexedFold&lt;Integer, List&lt;LineItem&gt;, LineItem&gt; itemsFold =
    itemsWithIndex.asIndexedFold();

// Find item at a specific position
Pair&lt;Integer, LineItem&gt; found = itemsFold.findWithIndex(
    (index, item) -&gt; index == 1,
    items
).orElse(null);

System.out.println("Item at index 1: " + found.second().productName());
// Output: Item at index 1: Mouse

// Check if any even-positioned item is expensive
boolean hasExpensiveEven = itemsFold.existsWithIndex(
    (index, item) -&gt; index % 2 == 0 &amp;&amp; item.price() &gt; 500,
    items
);
</code></pre>
<hr />
<h3 id="step-3-position-aware-modifications"><a class="header" href="#step-3-position-aware-modifications">Step 3: Position-Aware Modifications</a></h3>
<p>The real power emerges when you modify elements based on their position.</p>
<h4 id="numbering-items-in-a-packing-slip"><a class="header" href="#numbering-items-in-a-packing-slip">Numbering Items in a Packing Slip</a></h4>
<pre><code class="language-java">// Modify product names to include position numbers
List&lt;LineItem&gt; numbered = IndexedTraversals.imodify(
    itemsWithIndex,
    (index, item) -&gt; new LineItem(
        "Item " + (index + 1) + ": " + item.productName(),
        item.quantity(),
        item.price()
    ),
    items
);

for (LineItem item : numbered) {
    System.out.println(item.productName());
}
// Output:
// Item 1: Laptop
// Item 2: Mouse
// Item 3: Keyboard
</code></pre>
<h4 id="position-based-discount-logic"><a class="header" href="#position-based-discount-logic">Position-Based Discount Logic</a></h4>
<pre><code class="language-java">// Apply 10% discount to items at even positions (0, 2, 4...)
List&lt;LineItem&gt; discounted = IndexedTraversals.imodify(
    itemsWithIndex,
    (index, item) -&gt; {
        if (index % 2 == 0) {
            double discountedPrice = item.price() * 0.9;
            return new LineItem(item.productName(), item.quantity(), discountedPrice);
        }
        return item;
    },
    items
);

// Position 0 (Laptop): £999.99 → £899.99
// Position 1 (Mouse): £24.99 (unchanged)
// Position 2 (Keyboard): £79.99 → £71.99
</code></pre>
<h4 id="map-processing-with-key-awareness"><a class="header" href="#map-processing-with-key-awareness">Map Processing with Key Awareness</a></h4>
<pre><code class="language-java">IndexedTraversal&lt;String, Map&lt;String, String&gt;, String&gt; metadataTraversal =
    IndexedTraversals.forMap();

Map&lt;String, String&gt; processed = IndexedTraversals.imodify(
    metadataTraversal,
    (key, value) -&gt; {
        // Add key prefix to all values for debugging
        return "[" + key + "] " + value;
    },
    metadata
);

// Results:
// "priority" → "[priority] express"
// "gift-wrap" → "[gift-wrap] true"
// "delivery-note" → "[delivery-note] Leave at door"
</code></pre>
<hr />
<h3 id="step-4-filtering-with-index-awareness"><a class="header" href="#step-4-filtering-with-index-awareness">Step 4: Filtering with Index Awareness</a></h3>
<p>Indexed traversals support filtering, allowing you to focus on specific positions or keys.</p>
<h4 id="filter-by-index"><a class="header" href="#filter-by-index">Filter by Index</a></h4>
<pre><code class="language-java">// Focus only on even-positioned items
IndexedTraversal&lt;Integer, List&lt;LineItem&gt;, LineItem&gt; evenPositions =
    itemsWithIndex.filterIndex(index -&gt; index % 2 == 0);

List&lt;Pair&lt;Integer, LineItem&gt;&gt; evenItems =
    IndexedTraversals.toIndexedList(evenPositions, items);
// Returns: [(0, Laptop), (2, Keyboard)]

// Modify only even-positioned items
List&lt;LineItem&gt; result = IndexedTraversals.imodify(
    evenPositions,
    (index, item) -&gt; new LineItem(
        item.productName() + " [SALE]",
        item.quantity(),
        item.price()
    ),
    items
);
// Laptop and Keyboard get "[SALE]" suffix, Mouse unchanged
</code></pre>
<h4 id="filter-by-value-with-index-available"><a class="header" href="#filter-by-value-with-index-available">Filter by Value with Index Available</a></h4>
<pre><code class="language-java">// Focus on expensive items, but still track their original positions
IndexedTraversal&lt;Integer, List&lt;LineItem&gt;, LineItem&gt; expensiveItems =
    itemsWithIndex.filteredWithIndex((index, item) -&gt; item.price() &gt; 50);

List&lt;Pair&lt;Integer, LineItem&gt;&gt; expensive =
    IndexedTraversals.toIndexedList(expensiveItems, items);
// Returns: [(0, Laptop), (2, Keyboard)]
// Notice: indices are preserved (0 and 2), not renumbered
</code></pre>
<h4 id="filter-map-by-key-pattern"><a class="header" href="#filter-map-by-key-pattern">Filter Map by Key Pattern</a></h4>
<pre><code class="language-java">// Focus on metadata keys starting with "delivery"
IndexedTraversal&lt;String, Map&lt;String, String&gt;, String&gt; deliveryMetadata =
    metadataTraversal.filterIndex(key -&gt; key.startsWith("delivery"));

List&lt;Pair&lt;String, String&gt;&gt; deliveryEntries =
    deliveryMetadata.toIndexedList(metadata);
// Returns: [("delivery-note", "Leave at door")]
</code></pre>
<hr />
<h3 id="step-5-indexedlens-for-field-tracking"><a class="header" href="#step-5-indexedlens-for-field-tracking">Step 5: IndexedLens for Field Tracking</a></h3>
<p>An <code>IndexedLens</code> focuses on exactly one field whilst providing its name or identifier.</p>
<pre><code class="language-java">import org.higherkindedj.optics.indexed.IndexedLens;

// Create an indexed lens for the customer email field
IndexedLens&lt;String, Customer, String&gt; emailLens = IndexedLens.of(
    "email",                 // The index: field name
    Customer::email,         // Getter
    (customer, newEmail) -&gt; new Customer(customer.name(), newEmail)  // Setter
);

Customer customer = new Customer("Alice", "alice@example.com");

// Get both field name and value
Pair&lt;String, String&gt; fieldInfo = emailLens.iget(customer);
System.out.println("Field: " + fieldInfo.first());      // email
System.out.println("Value: " + fieldInfo.second());     // alice@example.com

// Modify with field name awareness
Customer updated = emailLens.imodify(
    (fieldName, oldValue) -&gt; {
        System.out.println("Updating field '" + fieldName + "' from " + oldValue);
        return "alice.smith@example.com";
    },
    customer
);
// Output: Updating field 'email' from alice@example.com
</code></pre>
<p><strong>Use case</strong>: Audit logging that records <em>which</em> field changed, not just the new value.</p>
<hr />
<h3 id="step-6-converting-between-indexed-and-non-indexed"><a class="header" href="#step-6-converting-between-indexed-and-non-indexed">Step 6: Converting Between Indexed and Non-Indexed</a></h3>
<p>Every indexed optic can be converted to its standard (non-indexed) counterpart.</p>
<pre><code class="language-java">import org.higherkindedj.optics.Traversal;

// Start with indexed traversal
IndexedTraversal&lt;Integer, List&lt;LineItem&gt;, LineItem&gt; indexed =
    IndexedTraversals.forList();

// Drop the index to get a standard traversal
Traversal&lt;List&lt;LineItem&gt;, LineItem&gt; standard = indexed.unindexed();

// Now you can use standard traversal methods
List&lt;LineItem&gt; uppercased = Traversals.modify(
    standard.andThen(Lens.of(
        LineItem::productName,
        (item, name) -&gt; new LineItem(name, item.quantity(), item.price())
    ).asTraversal()),
    String::toUpperCase,
    items
);
</code></pre>
<p><strong>When to convert</strong>: When you need the index for <em>some</em> operations but not others, start indexed and convert as needed.</p>
<hr />
<h3 id="when-to-use-indexed-optics-vs-standard-optics"><a class="header" href="#when-to-use-indexed-optics-vs-standard-optics">When to Use Indexed Optics vs Standard Optics</a></h3>
<p>Understanding when indexed optics add value is crucial for writing clear, maintainable code.</p>
<h4 id="use-indexed-optics-when"><a class="header" href="#use-indexed-optics-when">Use Indexed Optics When:</a></h4>
<ul>
<li><strong>Position-based logic</strong> - Different behaviour for even/odd indices, first/last elements</li>
<li><strong>Numbering or labelling</strong> - Adding sequence numbers, prefixes, or position markers</li>
<li><strong>Map operations</strong> - Both key and value are needed during transformation</li>
<li><strong>Audit trails</strong> - Recording which field or position was modified</li>
<li><strong>Debugging complex updates</strong> - Tracking the path to each change</li>
<li><strong>Index-based filtering</strong> - Operating on specific positions or key patterns</li>
</ul>
<pre><code class="language-java">// Perfect: Position drives the logic
IndexedTraversal&lt;Integer, List&lt;Product&gt;, Product&gt; productsIndexed =
    IndexedTraversals.forList();

List&lt;Product&gt; prioritised = productsIndexed.imodify(
    (index, product) -&gt; {
        // First 3 products get express shipping
        String shipping = index &lt; 3 ? "express" : "standard";
        return product.withShipping(shipping);
    },
    products
);
</code></pre>
<h4 id="use-standard-optics-when"><a class="header" href="#use-standard-optics-when">Use Standard Optics When:</a></h4>
<ul>
<li><strong>Position irrelevant</strong> - Pure value transformations</li>
<li><strong>Simpler code</strong> - Index tracking adds unnecessary complexity</li>
<li><strong>Performance critical</strong> - Minimal overhead needed (though indexed optics are optimised)</li>
<li><strong>No positional logic</strong> - All elements treated identically</li>
</ul>
<pre><code class="language-java">// Better with standard optics: Index not needed
Traversal&lt;List&lt;Product&gt;, Double&gt; prices =
    Traversals.&lt;Product&gt;forList()
        .andThen(ProductLenses.price().asTraversal());

List&lt;Product&gt; inflated = Traversals.modify(prices, price -&gt; price * 1.1, products);
// All prices increased by 10%, position doesn't matter
</code></pre>
<hr />
<h3 id="common-patterns-position-based-operations"><a class="header" href="#common-patterns-position-based-operations">Common Patterns: Position-Based Operations</a></h3>
<h4 id="pattern-1-adding-sequence-numbers"><a class="header" href="#pattern-1-adding-sequence-numbers">Pattern 1: Adding Sequence Numbers</a></h4>
<pre><code class="language-java">// Generate a numbered list for display
IndexedTraversal&lt;Integer, List&lt;String&gt;, String&gt; indexed = IndexedTraversals.forList();

List&lt;String&gt; tasks = List.of("Review PR", "Update docs", "Run tests");

List&lt;String&gt; numbered = IndexedTraversals.imodify(
    indexed,
    (i, task) -&gt; (i + 1) + ". " + task,
    tasks
);
// ["1. Review PR", "2. Update docs", "3. Run tests"]
</code></pre>
<h4 id="pattern-2-firstlast-element-special-handling"><a class="header" href="#pattern-2-firstlast-element-special-handling">Pattern 2: First/Last Element Special Handling</a></h4>
<pre><code class="language-java">IndexedTraversal&lt;Integer, List&lt;LineItem&gt;, LineItem&gt; itemsIndexed =
    IndexedTraversals.forList();

List&lt;LineItem&gt; items = List.of(/* ... */);
int lastIndex = items.size() - 1;

List&lt;LineItem&gt; marked = IndexedTraversals.imodify(
    itemsIndexed,
    (index, item) -&gt; {
        String marker = "";
        if (index == 0) marker = "[FIRST] ";
        if (index == lastIndex) marker = "[LAST] ";
        return new LineItem(
            marker + item.productName(),
            item.quantity(),
            item.price()
        );
    },
    items
);
</code></pre>
<h4 id="pattern-3-map-key-value-transformations"><a class="header" href="#pattern-3-map-key-value-transformations">Pattern 3: Map Key-Value Transformations</a></h4>
<pre><code class="language-java">IndexedTraversal&lt;String, Map&lt;String, Integer&gt;, Integer&gt; mapIndexed =
    IndexedTraversals.forMap();

Map&lt;String, Integer&gt; scores = Map.of(
    "alice", 100,
    "bob", 85,
    "charlie", 92
);

// Create display strings incorporating both key and value
List&lt;String&gt; results = IndexedTraversals.toIndexedList(mapIndexed, scores).stream()
    .map(pair -&gt; pair.first() + " scored " + pair.second())
    .toList();
// ["alice scored 100", "bob scored 85", "charlie scored 92"]
</code></pre>
<h4 id="pattern-4-position-based-filtering"><a class="header" href="#pattern-4-position-based-filtering">Pattern 4: Position-Based Filtering</a></h4>
<pre><code class="language-java">IndexedTraversal&lt;Integer, List&lt;String&gt;, String&gt; indexed = IndexedTraversals.forList();

List&lt;String&gt; values = List.of("a", "b", "c", "d", "e", "f");

// Take only odd positions (1, 3, 5)
IndexedTraversal&lt;Integer, List&lt;String&gt;, String&gt; oddPositions =
    indexed.filterIndex(i -&gt; i % 2 == 1);

List&lt;String&gt; odd = IndexedTraversals.getAll(oddPositions, values);
// ["b", "d", "f"]
</code></pre>
<hr />
<h3 id="common-pitfalls-20"><a class="header" href="#common-pitfalls-20">Common Pitfalls</a></h3>
<h4 id="dont-do-this-10"><a class="header" href="#dont-do-this-10">Don't Do This:</a></h4>
<pre><code class="language-java">// Inefficient: Recreating indexed traversals in loops
for (Order order : orders) {
    var indexed = IndexedTraversals.&lt;LineItem&gt;forList();
    IndexedTraversals.imodify(indexed, (i, item) -&gt; numberItem(i, item), order.items());
}

// Over-engineering: Using indexed optics when index isn't needed
IndexedTraversal&lt;Integer, List&lt;String&gt;, String&gt; indexed = IndexedTraversals.forList();
List&lt;String&gt; upper = IndexedTraversals.imodify(indexed, (i, s) -&gt; s.toUpperCase(), list);
// Index parameter 'i' is never used! Use standard Traversals.modify()

// Confusing: Manual index tracking alongside indexed optics
AtomicInteger counter = new AtomicInteger(0);
IndexedTraversals.imodify(indexed, (i, item) -&gt; {
    int myIndex = counter.getAndIncrement(); // Redundant!
    return process(myIndex, item);
}, items);

// Wrong: Expecting indices to be renumbered after filtering
IndexedTraversal&lt;Integer, List&lt;String&gt;, String&gt; evenOnly =
    indexed.filterIndex(i -&gt; i % 2 == 0);
List&lt;Pair&lt;Integer, String&gt;&gt; pairs = IndexedTraversals.toIndexedList(evenOnly, list);
// Indices are [0, 2, 4], NOT [0, 1, 2] - original positions preserved!
</code></pre>
<h4 id="do-this-instead-10"><a class="header" href="#do-this-instead-10">Do This Instead:</a></h4>
<pre><code class="language-java">// Efficient: Create indexed traversal once, reuse many times
IndexedTraversal&lt;Integer, List&lt;LineItem&gt;, LineItem&gt; itemsIndexed =
    IndexedTraversals.forList();

for (Order order : orders) {
    IndexedTraversals.imodify(itemsIndexed, (i, item) -&gt; numberItem(i, item), order.items());
}

// Simple: Use standard traversals when index isn't needed
Traversal&lt;List&lt;String&gt;, String&gt; standard = Traversals.forList();
List&lt;String&gt; upper = Traversals.modify(standard, String::toUpperCase, list);

// Clear: Trust the indexed optic to provide correct indices
IndexedTraversals.imodify(indexed, (providedIndex, item) -&gt; {
    // Use providedIndex directly, it's correct
    return process(providedIndex, item);
}, items);

// Understand: Filtered indexed traversals preserve original indices
IndexedTraversal&lt;Integer, List&lt;String&gt;, String&gt; evenOnly =
    indexed.filterIndex(i -&gt; i % 2 == 0);
List&lt;Pair&lt;Integer, String&gt;&gt; pairs = IndexedTraversals.toIndexedList(evenOnly, list);
// If you need renumbered indices, transform after extraction:
List&lt;Pair&lt;Integer, String&gt;&gt; renumbered = IntStream.range(0, pairs.size())
    .mapToObj(newIndex -&gt; new Pair&lt;&gt;(newIndex, pairs.get(newIndex).second()))
    .toList();
</code></pre>
<hr />
<h3 id="performance-notes-9"><a class="header" href="#performance-notes-9">Performance Notes</a></h3>
<p>Indexed optics are designed to be efficient:</p>
<ul>
<li><strong>No additional traversals</strong> - Index computed during normal iteration</li>
<li><strong>Lazy index creation</strong> - <code>Pair&lt;I, A&gt;</code> objects only created when needed</li>
<li><strong>Minimal overhead</strong> - Index tracking adds negligible cost</li>
<li><strong>Reusable compositions</strong> - Indexed optics can be composed and cached</li>
<li><strong>No boxing for primitives</strong> - When using integer indices directly</li>
</ul>
<p><strong>Best Practice</strong>: Create indexed optics once and store as constants:</p>
<pre><code class="language-java">public class OrderOptics {
    public static final IndexedTraversal&lt;Integer, List&lt;LineItem&gt;, LineItem&gt;
        ITEMS_WITH_INDEX = IndexedTraversals.forList();

    public static final IndexedTraversal&lt;String, Map&lt;String, String&gt;, String&gt;
        METADATA_WITH_KEYS = IndexedTraversals.forMap();

    // Compose with filtering
    public static final IndexedTraversal&lt;Integer, List&lt;LineItem&gt;, LineItem&gt;
        EVEN_POSITIONED_ITEMS = ITEMS_WITH_INDEX.filterIndex(i -&gt; i % 2 == 0);
}
</code></pre>
<hr />
<h2 id="part-ii-advanced-topics"><a class="header" href="#part-ii-advanced-topics">Part II: Advanced Topics</a></h2>
<h3 id="composing-indexed-optics-with-paired-indices"><a class="header" href="#composing-indexed-optics-with-paired-indices">Composing Indexed Optics with Paired Indices</a></h3>
<p>When you compose two indexed optics, the indices form a <strong>pair</strong> representing the path through nested structures.</p>
<pre><code class="language-java">import org.higherkindedj.optics.indexed.Pair;

// Nested structure: List of Orders, each with List of Items
record Order(String id, List&lt;LineItem&gt; items) {}

// First level: indexed traversal for orders
IndexedTraversal&lt;Integer, List&lt;Order&gt;, Order&gt; ordersIndexed =
    IndexedTraversals.forList();

// Second level: lens to items field
Lens&lt;Order, List&lt;LineItem&gt;&gt; itemsLens =
    Lens.of(Order::items, (order, items) -&gt; new Order(order.id(), items));

// Third level: indexed traversal for items
IndexedTraversal&lt;Integer, List&lt;LineItem&gt;, LineItem&gt; itemsIndexed =
    IndexedTraversals.forList();

// Compose: orders → items field → each item with PAIRED indices
IndexedTraversal&lt;Pair&lt;Integer, Integer&gt;, List&lt;Order&gt;, LineItem&gt; composed =
    ordersIndexed
        .iandThen(itemsLens)
        .iandThen(itemsIndexed);

List&lt;Order&gt; orders = List.of(
    new Order("ORD-1", List.of(
        new LineItem("Laptop", 1, 999.99),
        new LineItem("Mouse", 1, 24.99)
    )),
    new Order("ORD-2", List.of(
        new LineItem("Keyboard", 1, 79.99),
        new LineItem("Monitor", 1, 299.99)
    ))
);

// Access with paired indices: (order index, item index)
List&lt;Pair&lt;Pair&lt;Integer, Integer&gt;, LineItem&gt;&gt; all = composed.toIndexedList(orders);

for (Pair&lt;Pair&lt;Integer, Integer&gt;, LineItem&gt; entry : all) {
    Pair&lt;Integer, Integer&gt; indices = entry.first();
    LineItem item = entry.second();
    System.out.printf("Order %d, Item %d: %s%n",
        indices.first(), indices.second(), item.productName());
}
// Output:
// Order 0, Item 0: Laptop
// Order 0, Item 1: Mouse
// Order 1, Item 0: Keyboard
// Order 1, Item 1: Monitor
</code></pre>
<p><strong>Use case</strong>: Generating globally unique identifiers like "Order 3, Item 5" or "Row 2, Column 7".</p>
<hr />
<h3 id="index-transformation-and-mapping"><a class="header" href="#index-transformation-and-mapping">Index Transformation and Mapping</a></h3>
<p>You can transform indices whilst preserving the optic composition.</p>
<pre><code class="language-java">// Start with integer indices (0, 1, 2...)
IndexedTraversal&lt;Integer, List&lt;LineItem&gt;, LineItem&gt; zeroIndexed =
    IndexedTraversals.forList();

// Transform to 1-based indices (1, 2, 3...)
IndexedTraversal&lt;Integer, List&lt;LineItem&gt;, LineItem&gt; oneIndexed =
    zeroIndexed.reindex(i -&gt; i + 1);

List&lt;LineItem&gt; items = List.of(/* ... */);

List&lt;String&gt; numbered = oneIndexed.imodify(
    (index, item) -&gt; "Item " + index + ": " + item.productName(),
    items
).stream()
    .map(LineItem::productName)
    .toList();
// ["Item 1: Laptop", "Item 2: Mouse", "Item 3: Keyboard"]
</code></pre>
<p><strong>Note</strong>: The <code>reindex</code> method is conceptual. In practice, you'd transform indices in your <code>imodify</code> function:</p>
<pre><code class="language-java">zeroIndexed.imodify((zeroBasedIndex, item) -&gt; {
    int oneBasedIndex = zeroBasedIndex + 1;
    return new LineItem("Item " + oneBasedIndex + ": " + item.productName(),
                        item.quantity(), item.price());
}, items);
</code></pre>
<hr />
<h3 id="combining-index-filtering-with-value-filtering"><a class="header" href="#combining-index-filtering-with-value-filtering">Combining Index Filtering with Value Filtering</a></h3>
<p>You can layer multiple filters for precise control.</p>
<pre><code class="language-java">IndexedTraversal&lt;Integer, List&lt;LineItem&gt;, LineItem&gt; itemsIndexed =
    IndexedTraversals.forList();

// Filter: even positions AND expensive items
IndexedTraversal&lt;Integer, List&lt;LineItem&gt;, LineItem&gt; targeted =
    itemsIndexed
        .filterIndex(i -&gt; i % 2 == 0)              // Even positions only
        .filtered(item -&gt; item.price() &gt; 50);       // Expensive items only

List&lt;LineItem&gt; items = List.of(
    new LineItem("Laptop", 1, 999.99),    // Index 0, expensive ✓
    new LineItem("Pen", 1, 2.99),         // Index 1, cheap ✗
    new LineItem("Keyboard", 1, 79.99),   // Index 2, expensive ✓
    new LineItem("Mouse", 1, 24.99),      // Index 3, cheap ✗
    new LineItem("Monitor", 1, 299.99)    // Index 4, expensive ✓
);

List&lt;Pair&lt;Integer, LineItem&gt;&gt; results = targeted.toIndexedList(items);
// Returns: [(0, Laptop), (2, Keyboard), (4, Monitor)]
// All at even positions AND expensive
</code></pre>
<hr />
<h3 id="audit-trail-pattern-field-change-tracking"><a class="header" href="#audit-trail-pattern-field-change-tracking">Audit Trail Pattern: Field Change Tracking</a></h3>
<p>A powerful real-world pattern is tracking <em>which</em> fields change in your domain objects.</p>
<pre><code class="language-java">// Generic field audit logger
public class AuditLog {
    public record FieldChange&lt;A&gt;(
        String fieldName,
        A oldValue,
        A newValue,
        Instant timestamp
    ) {}

    public static &lt;A&gt; Function&lt;Pair&lt;String, A&gt;, A&gt; loggedModification(
        Function&lt;A, A&gt; transformation,
        List&lt;FieldChange&lt;?&gt;&gt; auditLog
    ) {
        return pair -&gt; {
            String fieldName = pair.first();
            A oldValue = pair.second();
            A newValue = transformation.apply(oldValue);

            if (!oldValue.equals(newValue)) {
                auditLog.add(new FieldChange&lt;&gt;(
                    fieldName,
                    oldValue,
                    newValue,
                    Instant.now()
                ));
            }

            return newValue;
        };
    }
}

// Usage with indexed lens
IndexedLens&lt;String, Customer, String&gt; emailLens = IndexedLens.of(
    "email",
    Customer::email,
    (c, email) -&gt; new Customer(c.name(), email)
);

List&lt;AuditLog.FieldChange&lt;?&gt;&gt; audit = new ArrayList&lt;&gt;();

Customer customer = new Customer("Alice", "alice@old.com");

Customer updated = emailLens.imodify(
    AuditLog.loggedModification(
        email -&gt; "alice@new.com",
        audit
    ),
    customer
);

// Check audit log
for (AuditLog.FieldChange&lt;?&gt; change : audit) {
    System.out.printf("Field '%s' changed from %s to %s at %s%n",
        change.fieldName(),
        change.oldValue(),
        change.newValue(),
        change.timestamp()
    );
}
// Output: Field 'email' changed from alice@old.com to alice@new.com at 2025-01-15T10:30:00Z
</code></pre>
<hr />
<h3 id="debugging-pattern-path-tracking-in-nested-updates"><a class="header" href="#debugging-pattern-path-tracking-in-nested-updates">Debugging Pattern: Path Tracking in Nested Updates</a></h3>
<p>When debugging complex nested updates, indexed optics reveal the complete path to each modification.</p>
<pre><code class="language-java">// Nested structure with multiple levels
record Item(String name, double price) {}
record Order(List&lt;Item&gt; items) {}
record Customer(String name, List&lt;Order&gt; orders) {}

// Build an indexed path through the structure
IndexedTraversal&lt;Integer, List&lt;Customer&gt;, Customer&gt; customersIdx =
    IndexedTraversals.forList();

Lens&lt;Customer, List&lt;Order&gt;&gt; ordersLens =
    Lens.of(Customer::orders, (c, o) -&gt; new Customer(c.name(), o));

IndexedTraversal&lt;Integer, List&lt;Order&gt;, Order&gt; ordersIdx =
    IndexedTraversals.forList();

Lens&lt;Order, List&lt;Item&gt;&gt; itemsLens =
    Lens.of(Order::items, (order, items) -&gt; new Order(items));

IndexedTraversal&lt;Integer, List&lt;Item&gt;, Item&gt; itemsIdx =
    IndexedTraversals.forList();

Lens&lt;Item, Double&gt; priceLens =
    Lens.of(Item::price, (item, price) -&gt; new Item(item.name(), price));

// Compose the full indexed path
IndexedTraversal&lt;Pair&lt;Pair&lt;Integer, Integer&gt;, Integer&gt;, List&lt;Customer&gt;, Double&gt; fullPath =
    customersIdx
        .iandThen(ordersLens)
        .iandThen(ordersIdx)
        .iandThen(itemsLens)
        .iandThen(itemsIdx)
        .iandThen(priceLens);

List&lt;Customer&gt; customers = List.of(/* ... */);

// Modify with full path visibility
List&lt;Customer&gt; updated = fullPath.imodify(
    (indices, price) -&gt; {
        int customerIdx = indices.first().first();
        int orderIdx = indices.first().second();
        int itemIdx = indices.second();

        System.out.printf(
            "Updating price at [customer=%d, order=%d, item=%d]: %.2f → %.2f%n",
            customerIdx, orderIdx, itemIdx, price, price * 1.1
        );

        return price * 1.1;  // 10% increase
    },
    customers
);
// Output shows complete path to every modified price:
// Updating price at [customer=0, order=0, item=0]: 999.99 → 1099.99
// Updating price at [customer=0, order=0, item=1]: 24.99 → 27.49
// Updating price at [customer=0, order=1, item=0]: 79.99 → 87.99
// ...
</code></pre>
<hr />
<h3 id="working-with-pair-utilities"><a class="header" href="#working-with-pair-utilities">Working with Pair Utilities</a></h3>
<p>The <code>Pair&lt;A, B&gt;</code> type provides utility methods for manipulation.</p>
<pre><code class="language-java">import org.higherkindedj.optics.indexed.Pair;

Pair&lt;Integer, String&gt; pair = new Pair&lt;&gt;(1, "Hello");

// Access components
int first = pair.first();       // 1
String second = pair.second();  // "Hello"

// Transform components
Pair&lt;Integer, String&gt; modified = pair.withSecond("World");
// Result: Pair(1, "World")

Pair&lt;String, String&gt; transformed = pair.withFirst("One");
// Result: Pair("One", "Hello")

// Swap
Pair&lt;String, Integer&gt; swapped = pair.swap();
// Result: Pair("Hello", 1)

// Factory method
Pair&lt;String, Integer&gt; created = Pair.of("Key", 42);
</code></pre>
<p>For converting to/from <code>Tuple2</code> (when working with hkj-core utilities):</p>
<pre><code class="language-java">import org.higherkindedj.hkt.Tuple2;
import org.higherkindedj.optics.util.IndexedTraversals;

Pair&lt;String, Integer&gt; pair = Pair.of("key", 100);

// Convert to Tuple2
Tuple2&lt;String, Integer&gt; tuple = IndexedTraversals.pairToTuple2(pair);

// Convert back to Pair
Pair&lt;String, Integer&gt; converted = IndexedTraversals.tuple2ToPair(tuple);
</code></pre>
<hr />
<h3 id="real-world-example-order-fulfilment-dashboard"><a class="header" href="#real-world-example-order-fulfilment-dashboard">Real-World Example: Order Fulfilment Dashboard</a></h3>
<p>Here's a comprehensive example demonstrating indexed optics in a business context.</p>
<pre><code class="language-java">package org.higherkindedj.example.optics;

import java.time.Instant;
import java.util.*;
import org.higherkindedj.optics.indexed.*;
import org.higherkindedj.optics.util.IndexedTraversals;

public class OrderFulfilmentDashboard {

    public record LineItem(String productName, int quantity, double price) {}

    public record Order(
        String orderId,
        List&lt;LineItem&gt; items,
        Map&lt;String, String&gt; metadata
    ) {}

    public static void main(String[] args) {
        Order order = new Order(
            "ORD-12345",
            List.of(
                new LineItem("Laptop", 1, 999.99),
                new LineItem("Mouse", 2, 24.99),
                new LineItem("Keyboard", 1, 79.99),
                new LineItem("Monitor", 1, 299.99)
            ),
            new LinkedHashMap&lt;&gt;(Map.of(
                "priority", "express",
                "gift-wrap", "true",
                "delivery-note", "Leave at door"
            ))
        );

        System.out.println("=== ORDER FULFILMENT DASHBOARD ===\n");

        // --- Task 1: Generate Packing Slip ---
        System.out.println("--- Packing Slip ---");
        generatePackingSlip(order);

        // --- Task 2: Apply Position-Based Discounts ---
        System.out.println("\n--- Position-Based Discounts ---");
        Order discounted = applyPositionDiscounts(order);
        System.out.println("Original total: £" + calculateTotal(order));
        System.out.println("Discounted total: £" + calculateTotal(discounted));

        // --- Task 3: Process Metadata with Key Awareness ---
        System.out.println("\n--- Metadata Processing ---");
        processMetadata(order);

        // --- Task 4: Identify High-Value Positions ---
        System.out.println("\n--- High-Value Items ---");
        identifyHighValuePositions(order);

        System.out.println("\n=== END OF DASHBOARD ===");
    }

    private static void generatePackingSlip(Order order) {
        IndexedTraversal&lt;Integer, List&lt;LineItem&gt;, LineItem&gt; itemsIndexed =
            IndexedTraversals.forList();

        List&lt;Pair&lt;Integer, LineItem&gt;&gt; indexedItems =
            itemsIndexed.toIndexedList(order.items());

        System.out.println("Order: " + order.orderId());
        for (Pair&lt;Integer, LineItem&gt; pair : indexedItems) {
            int position = pair.first() + 1;  // 1-based for display
            LineItem item = pair.second();
            System.out.printf("  Item %d: %s (Qty: %d) - £%.2f%n",
                position,
                item.productName(),
                item.quantity(),
                item.price() * item.quantity()
            );
        }
    }

    private static Order applyPositionDiscounts(Order order) {
        IndexedTraversal&lt;Integer, List&lt;LineItem&gt;, LineItem&gt; itemsIndexed =
            IndexedTraversals.forList();

        // Every 3rd item gets 15% off (positions 2, 5, 8...)
        List&lt;LineItem&gt; discounted = itemsIndexed.imodify(
            (index, item) -&gt; {
                if ((index + 1) % 3 == 0) {
                    double newPrice = item.price() * 0.85;
                    System.out.printf("  Position %d (%s): £%.2f → £%.2f (15%% off)%n",
                        index + 1, item.productName(), item.price(), newPrice);
                    return new LineItem(item.productName(), item.quantity(), newPrice);
                }
                return item;
            },
            order.items()
        );

        return new Order(order.orderId(), discounted, order.metadata());
    }

    private static void processMetadata(Order order) {
        IndexedTraversal&lt;String, Map&lt;String, String&gt;, String&gt; metadataIndexed =
            IndexedTraversals.forMap();

        IndexedFold&lt;String, Map&lt;String, String&gt;, String&gt; fold =
            metadataIndexed.asIndexedFold();

        List&lt;Pair&lt;String, String&gt;&gt; entries = fold.toIndexedList(order.metadata());

        for (Pair&lt;String, String&gt; entry : entries) {
            String key = entry.first();
            String value = entry.second();

            // Process based on key
            switch (key) {
                case "priority" -&gt;
                    System.out.println("  Shipping priority: " + value.toUpperCase());
                case "gift-wrap" -&gt;
                    System.out.println("  Gift wrapping: " +
                        (value.equals("true") ? "Required" : "Not required"));
                case "delivery-note" -&gt;
                    System.out.println("  Special instructions: " + value);
                default -&gt;
                    System.out.println("  " + key + ": " + value);
            }
        }
    }

    private static void identifyHighValuePositions(Order order) {
        IndexedTraversal&lt;Integer, List&lt;LineItem&gt;, LineItem&gt; itemsIndexed =
            IndexedTraversals.forList();

        // Filter to items over £100
        IndexedTraversal&lt;Integer, List&lt;LineItem&gt;, LineItem&gt; highValue =
            itemsIndexed.filteredWithIndex((index, item) -&gt; item.price() &gt; 100);

        List&lt;Pair&lt;Integer, LineItem&gt;&gt; expensive = highValue.toIndexedList(order.items());

        System.out.println("  Items over £100 (require special handling):");
        for (Pair&lt;Integer, LineItem&gt; pair : expensive) {
            System.out.printf("    Position %d: %s (£%.2f)%n",
                pair.first() + 1,
                pair.second().productName(),
                pair.second().price()
            );
        }
    }

    private static double calculateTotal(Order order) {
        return order.items().stream()
            .mapToDouble(item -&gt; item.price() * item.quantity())
            .sum();
    }
}
</code></pre>
<p><strong>Expected Output:</strong></p>
<pre><code>=== ORDER FULFILMENT DASHBOARD ===

--- Packing Slip ---
Order: ORD-12345
  Item 1: Laptop (Qty: 1) - £999.99
  Item 2: Mouse (Qty: 2) - £49.98
  Item 3: Keyboard (Qty: 1) - £79.99
  Item 4: Monitor (Qty: 1) - £299.99

--- Position-Based Discounts ---
  Position 3 (Keyboard): £79.99 → £67.99 (15% off)
Original total: £1429.95
Discounted total: £1417.95

--- Metadata Processing ---
  Shipping priority: EXPRESS
  Gift wrapping: Required
  Special instructions: Leave at door

--- High-Value Items ---
  Items over £100 (require special handling):
    Position 1: Laptop (£999.99)
    Position 4: Monitor (£299.99)

=== END OF DASHBOARD ===
</code></pre>
<hr />
<h2 id="the-relationship-to-haskells-lens-library-1"><a class="header" href="#the-relationship-to-haskells-lens-library-1">The Relationship to Haskell's Lens Library</a></h2>
<p>For those familiar with functional programming, higher-kinded-j's indexed optics are inspired by Haskell's <a href="https://hackage.haskell.org/package/lens">lens library</a>, specifically indexed traversals and indexed folds.</p>
<p>In Haskell:</p>
<pre><code class="language-haskell">itraversed :: IndexedTraversal Int ([] a) a
</code></pre>
<p>This creates an indexed traversal over lists where the index is an integer: exactly what our <code>IndexedTraversals.forList()</code> provides.</p>
<p><strong>Key differences:</strong></p>
<ul>
<li>Higher-kinded-j uses explicit <code>Applicative</code> instances rather than implicit type class resolution</li>
<li>Java's type system requires explicit <code>Pair&lt;I, A&gt;</code> for index-value pairs</li>
<li>The <code>imodify</code> and <code>iget</code> methods provide a more Java-friendly API</li>
<li>Map-based traversals (<code>forMap</code>) are a practical extension for Java's collection library</li>
</ul>
<p><strong>Further Reading:</strong></p>
<ul>
<li><a href="https://hackage.haskell.org/package/lens-tutorial-1.0.4/docs/Control-Lens-Tutorial.html">Haskell Lens Tutorial: Indexed Optics</a> - Original inspiration</li>
<li><a href="https://leanpub.com/optics-by-example">Optics By Example</a> by Chris Penner - Chapter on indexed optics</li>
<li><a href="https://www.optics.dev/Monocle/">Monocle (Scala)</a> - Similar indexed optics for Scala</li>
</ul>
<div id="admonition-for-comprehension-integration" class="admonition admonish-tip" role="note" aria-labelledby="admonition-for-comprehension-integration-title">
<div class="admonition-title">
<div id="admonition-for-comprehension-integration-title">
<p>For Comprehension Integration</p>
</div>
<a class="admonition-anchor-link" href="optics/indexed_optics.html#admonition-for-comprehension-integration"></a>
</div>
<div>
<p>For a fluent, comprehension-style API for indexed traversal operations, see <a href="optics/../functional/for_comprehension.html#position-aware-traversals-with-forindexed">For Comprehensions: Position-Aware Traversals with ForIndexed</a>. This provides an alternative syntax for position-based filtering, modifying, and collecting traversal targets.</p>
</div>
</div>
<hr />
<h2 id="summary-the-power-of-indexed-optics"><a class="header" href="#summary-the-power-of-indexed-optics">Summary: The Power of Indexed Optics</a></h2>
<p>Indexed optics bring <strong>position awareness</strong> into your functional data transformations:</p>
<ul>
<li><strong>IndexedTraversal&lt;I, S, A&gt;</strong>: Bulk operations with index tracking</li>
<li><strong>IndexedFold&lt;I, S, A&gt;</strong>: Read-only queries with position information</li>
<li><strong>IndexedLens&lt;I, S, A&gt;</strong>: Single-field access with field name tracking</li>
</ul>
<p>These tools transform how you work with collections and records:</p>
<div class="table-wrapper"><table><thead><tr><th>Before (Manual Index Tracking)</th><th>After (Declarative Indexed Optics)</th></tr></thead><tbody>
<tr><td>Manual loop counters</td><td>Built-in index access</td></tr>
<tr><td>AtomicInteger for streams</td><td>Type-safe <code>imodify</code></td></tr>
<tr><td>Breaking into Map.entrySet()</td><td>Direct key-value processing</td></tr>
<tr><td>Complex audit logging logic</td><td>Field tracking with <code>IndexedLens</code></td></tr>
<tr><td>Scattered position logic</td><td>Composable indexed transformations</td></tr>
</tbody></table>
</div>
<p>By incorporating indexed optics into your toolkit, you gain:</p>
<ul>
<li><strong>Expressiveness</strong>: Say "numbered list items" declaratively</li>
<li><strong>Type safety</strong>: Compile-time checked index types</li>
<li><strong>Composability</strong>: Chain indexed optics, filter by position, compose with standard optics</li>
<li><strong>Debugging power</strong>: Track complete paths through nested structures</li>
<li><strong>Audit trails</strong>: Record which fields changed, not just values</li>
<li><strong>Performance</strong>: Minimal overhead, lazy index computation</li>
</ul>
<p>Indexed optics represent the fusion of position awareness with functional composition: enabling you to write code that is simultaneously more declarative, more powerful, and more maintainable than traditional index-tracking approaches.</p>
<hr />
<p><strong>Previous:</strong> <a href="optics/common_data_structure_traversals.html">Common Data Structure Traversals</a>
<strong>Next:</strong> <a href="optics/getters.html">Getters: Read-Only Optics</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="string-traversals-declarative-text-processing"><a class="header" href="#string-traversals-declarative-text-processing">String Traversals: Declarative Text Processing</a></h1>
<h2 id="type-safe-text-manipulation-without-regex-complexity"><a class="header" href="#type-safe-text-manipulation-without-regex-complexity"><em>Type-Safe Text Manipulation Without Regex Complexity</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="optics/string_traversals.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>Breaking strings into traversable units (characters, words, lines)</li>
<li>Declarative text normalisation and validation</li>
<li>Composing string traversals with filtered optics for pattern matching</li>
<li>Real-world text processing: logs, CSV, configuration files</li>
<li>When to use string traversals vs Stream API vs regex</li>
<li>Performance characteristics and best practices</li>
</ul>
</div>
</div>
<div id="admonition-example-code" class="admonition admonish-note" role="note" aria-labelledby="admonition-example-code-title">
<div class="admonition-title">
<div id="admonition-example-code-title">
<p>Example Code</p>
</div>
<a class="admonition-anchor-link" href="optics/string_traversals.html#admonition-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/StringTraversalsExample.java">StringTraversalsExample</a></p>
</div>
</div>
<p>Working with text in Java often feels like choosing between extremes: verbose manual string manipulation with <code>substring()</code> and <code>indexOf()</code>, or cryptic regular expressions that become unmaintainable. String traversals offer a middle path: declarative, composable, and type-safe.</p>
<p>Consider these common scenarios from enterprise Java applications:</p>
<ul>
<li><strong>Configuration Management</strong>: Normalising property values across <code>.properties</code> files</li>
<li><strong>Log Analysis</strong>: Filtering and transforming log entries line-by-line</li>
<li><strong>Data Import</strong>: Processing CSV files with per-field transformations</li>
<li><strong>API Integration</strong>: Standardising email addresses from external systems</li>
<li><strong>Validation</strong>: Checking character-level constraints (length, allowed characters)</li>
</ul>
<p>The traditional approach mixes parsing logic with transformation logic, making code difficult to test and reuse:</p>
<pre><code class="language-java">// Traditional: Mixed concerns, hard to compose
String normaliseEmail(String email) {
    String[] parts = email.toLowerCase().split("@");
    if (parts.length != 2) throw new IllegalArgumentException();
    String domain = parts[1].trim();
    return parts[0] + "@" + domain;
}

// What if we need to normalise just the domain? Or multiple emails in a document?
// We'd need separate methods or complex parameters.
</code></pre>
<p><strong>String traversals</strong> let you separate the "what" (the structure) from the "how" (the transformation), making your text processing logic reusable and composable.</p>
<hr />
<h2 id="think-of-string-traversals-like"><a class="header" href="#think-of-string-traversals-like">Think of String Traversals Like...</a></h2>
<ul>
<li><strong>Java Stream's split() + map()</strong>: Like <code>text.lines().map(...)</code> but integrated into optic composition</li>
<li><strong>IntelliJ's "Replace in Selection"</strong>: Focus on text units, transform them, reassemble automatically</li>
<li><strong>Unix text tools</strong>: Similar to <code>awk</code> and <code>sed</code> pipelines, but type-safe and composable</li>
<li><strong>SQL's string functions</strong>: Like <code>UPPER()</code>, <code>TRIM()</code>, <code>SPLIT_PART()</code>, but for immutable Java strings</li>
</ul>
<p>The key insight: text structure (characters, words, lines) becomes part of your optic's identity, not preprocessing before the real work.</p>
<hr />
<h2 id="three-ways-to-decompose-text"><a class="header" href="#three-ways-to-decompose-text">Three Ways to Decompose Text</a></h2>
<p>The <code>StringTraversals</code> utility class provides three fundamental decompositions:</p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Unit</th><th>Example Input</th><th>Focused Elements</th></tr></thead><tbody>
<tr><td><strong><code>chars()</code></strong></td><td>Characters</td><td><code>"hello"</code></td><td><code>['h', 'e', 'l', 'l', 'o']</code></td></tr>
<tr><td><strong><code>worded()</code></strong></td><td>Words (by <code>\s+</code>)</td><td><code>"hello world"</code></td><td><code>["hello", "world"]</code></td></tr>
<tr><td><strong><code>lined()</code></strong></td><td>Lines (by <code>\n</code>, <code>\r\n</code>, <code>\r</code>)</td><td><code>"line1\nline2"</code></td><td><code>["line1", "line2"]</code></td></tr>
</tbody></table>
</div>
<p>Each returns a <code>Traversal&lt;String, ?&gt;</code> that can be composed with other optics and applied via <code>Traversals.modify()</code> or <code>Traversals.getAll()</code>.</p>
<hr />
<h2 id="a-step-by-step-walkthrough-11"><a class="header" href="#a-step-by-step-walkthrough-11">A Step-by-Step Walkthrough</a></h2>
<h3 id="step-1-character-level-processing-with-chars"><a class="header" href="#step-1-character-level-processing-with-chars">Step 1: Character-Level Processing with <code>chars()</code></a></h3>
<p>The <code>chars()</code> traversal breaks a string into individual characters, allowing transformations at the finest granularity.</p>
<pre><code class="language-java">import org.higherkindedj.optics.util.StringTraversals;
import org.higherkindedj.optics.util.Traversals;

// Create a character traversal
Traversal&lt;String, Character&gt; charTraversal = StringTraversals.chars();

// Transform all characters to uppercase
String uppercased = Traversals.modify(charTraversal, Character::toUpperCase, "hello world");
// Result: "HELLO WORLD"

// Extract all characters as a list
List&lt;Character&gt; chars = Traversals.getAll(charTraversal, "abc");
// Result: ['a', 'b', 'c']

// Compose with filtered for selective transformation
Traversal&lt;String, Character&gt; vowels = charTraversal.filtered(c -&gt;
    "aeiouAEIOU".indexOf(c) &gt;= 0
);
String result = Traversals.modify(vowels, Character::toUpperCase, "hello world");
// Result: "hEllO wOrld"  (only vowels uppercased)
</code></pre>
<p><strong>Use Cases</strong>:</p>
<ul>
<li>Character-level validation (alphanumeric checks)</li>
<li>ROT13 or Caesar cipher transformations</li>
<li>Character frequency analysis</li>
<li>Removing or replacing specific characters</li>
</ul>
<h3 id="step-2-word-level-processing-with-worded"><a class="header" href="#step-2-word-level-processing-with-worded">Step 2: Word-Level Processing with <code>worded()</code></a></h3>
<p>The <code>worded()</code> traversal splits by whitespace (<code>\s+</code>), focusing on each word independently.</p>
<p><strong>Key Semantics</strong>:</p>
<ul>
<li>Multiple consecutive spaces are normalised to single spaces</li>
<li>Leading and trailing whitespace is removed</li>
<li>Empty strings or whitespace-only strings produce no words</li>
</ul>
<pre><code class="language-java">Traversal&lt;String, String&gt; wordTraversal = StringTraversals.worded();

// Capitalise each word
String capitalised = Traversals.modify(
    wordTraversal,
    word -&gt; word.substring(0, 1).toUpperCase() + word.substring(1).toLowerCase(),
    "hello WORLD from JAVA"
);
// Result: "Hello World From Java"

// Extract all words (whitespace normalisation automatic)
List&lt;String&gt; words = Traversals.getAll(wordTraversal, "foo  bar\t\tbaz");
// Result: ["foo", "bar", "baz"]

// Compose with filtered for conditional transformation
Traversal&lt;String, String&gt; longWords = wordTraversal.filtered(w -&gt; w.length() &gt; 5);
String emphasised = Traversals.modify(longWords, w -&gt; w.toUpperCase(), "make software better");
// Result: "make SOFTWARE BETTER"
</code></pre>
<p><strong>Use Cases</strong>:</p>
<ul>
<li>Title case formatting</li>
<li>Stop word filtering</li>
<li>Word-based text normalisation</li>
<li>Search query processing</li>
<li>Email domain extraction</li>
</ul>
<h3 id="step-3-line-level-processing-with-lined"><a class="header" href="#step-3-line-level-processing-with-lined">Step 3: Line-Level Processing with <code>lined()</code></a></h3>
<p>The <code>lined()</code> traversal splits by line separators (<code>\n</code>, <code>\r\n</code>, or <code>\r</code>), treating each line as a focus target.</p>
<p><strong>Key Semantics</strong>:</p>
<ul>
<li>All line endings are normalised to <code>\n</code> in output</li>
<li>Empty strings produce no lines</li>
<li>Trailing newlines are preserved in individual line processing</li>
</ul>
<pre><code class="language-java">Traversal&lt;String, String&gt; lineTraversal = StringTraversals.lined();

// Prefix each line with a marker
String prefixed = Traversals.modify(
    lineTraversal,
    line -&gt; "&gt; " + line,
    "line1\nline2\nline3"
);
// Result: "&gt; line1\n&gt; line2\n&gt; line3"

// Extract all non-empty lines
List&lt;String&gt; lines = Traversals.getAll(lineTraversal, "first\n\nthird");
// Result: ["first", "", "third"]  (empty line preserved)

// Filter lines by content
Traversal&lt;String, String&gt; errorLines = lineTraversal.filtered(line -&gt;
    line.contains("ERROR")
);
String errors = Traversals.getAll(errorLines, logContent).stream()
    .collect(Collectors.joining("\n"));
</code></pre>
<p><strong>Use Cases</strong>:</p>
<ul>
<li>Log file filtering and transformation</li>
<li>CSV row processing</li>
<li>Configuration file parsing</li>
<li>Code formatting (indentation, comments)</li>
<li>Multi-line text validation</li>
</ul>
<hr />
<h2 id="real-world-example-email-normalisation-service"><a class="header" href="#real-world-example-email-normalisation-service">Real-World Example: Email Normalisation Service</a></h2>
<p>A common requirement in enterprise systems: normalise email addresses from various sources before storage.</p>
<pre><code class="language-java">import org.higherkindedj.optics.util.StringTraversals;
import org.higherkindedj.optics.util.Traversals;

public class EmailNormaliser {

    // Normalise the local part (before @) to lowercase
    // Normalise the domain (after @) to lowercase and trim
    public static String normalise(String email) {
        Traversal&lt;String, String&gt; words = StringTraversals.worded();

        // Split email by @ symbol (treated as whitespace separator for this example)
        // In production, you'd want more robust parsing
        String lowercased = Traversals.modify(words, String::toLowerCase, email);

        return lowercased.trim();
    }

    // More sophisticated: normalise domain parts separately
    public static String normaliseDomain(String email) {
        int atIndex = email.indexOf('@');
        if (atIndex == -1) return email;

        String local = email.substring(0, atIndex);
        String domain = email.substring(atIndex + 1);

        // Normalise domain components
        Traversal&lt;String, String&gt; domainParts = StringTraversals.worded();
        String normalisedDomain = Traversals.modify(
            domainParts,
            String::toLowerCase,
            domain.replace(".", " ")  // Split domain by dots
        ).replace(" ", ".");  // Rejoin

        return local + "@" + normalisedDomain;
    }
}
</code></pre>
<hr />
<h2 id="composing-string-traversals"><a class="header" href="#composing-string-traversals">Composing String Traversals</a></h2>
<p>The power emerges when combining string traversals with other optics:</p>
<h3 id="with-filtered-traversals--pattern-matching"><a class="header" href="#with-filtered-traversals--pattern-matching">With Filtered Traversals – Pattern Matching</a></h3>
<pre><code class="language-java">// Find and transform lines starting with a prefix
Traversal&lt;String, String&gt; commentLines =
    StringTraversals.lined().filtered(line -&gt; line.trim().startsWith("#"));

String withoutComments = Traversals.modify(
    commentLines,
    line -&gt; "",  // Remove comment lines by replacing with empty
    sourceCode
);
</code></pre>
<h3 id="with-nested-structures--bulk-text-processing"><a class="header" href="#with-nested-structures--bulk-text-processing">With Nested Structures – Bulk Text Processing</a></h3>
<pre><code class="language-java">@GenerateLenses
public record Document(String title, List&lt;String&gt; paragraphs) {}

// Capitalise first letter of each word in all paragraphs
Traversal&lt;Document, String&gt; allWords =
    DocumentLenses.paragraphs().asTraversal()
        .andThen(Traversals.forList())
        .andThen(StringTraversals.worded());

Document formatted = Traversals.modify(
    allWords,
    word -&gt; word.substring(0, 1).toUpperCase() + word.substring(1),
    document
);
</code></pre>
<h3 id="with-effectful-operations--validation"><a class="header" href="#with-effectful-operations--validation">With Effectful Operations – Validation</a></h3>
<pre><code class="language-java">import org.higherkindedj.hkt.optional.OptionalMonad;

// Validate that all words are alphanumeric
Traversal&lt;String, String&gt; words = StringTraversals.worded();

Function&lt;String, Kind&lt;OptionalKind.Witness, String&gt;&gt; validateWord = word -&gt; {
    boolean alphanumeric = word.chars().allMatch(Character::isLetterOrDigit);
    return alphanumeric
        ? OptionalKindHelper.OPTIONAL.widen(Optional.of(word))
        : OptionalKindHelper.OPTIONAL.widen(Optional.empty());
};

Optional&lt;String&gt; validated = OptionalKindHelper.OPTIONAL.narrow(
    words.modifyF(validateWord, input, OptionalMonad.INSTANCE)
);
// Returns Optional.empty() if any word contains non-alphanumeric characters
</code></pre>
<hr />
<h2 id="common-patterns-4"><a class="header" href="#common-patterns-4">Common Patterns</a></h2>
<h3 id="log-file-processing"><a class="header" href="#log-file-processing">Log File Processing</a></h3>
<pre><code class="language-java">// Extract ERROR lines from application logs
Traversal&lt;String, String&gt; errorLines =
    StringTraversals.lined().filtered(line -&gt; line.contains("ERROR"));

List&lt;String&gt; errors = Traversals.getAll(errorLines, logContent);

// Add timestamps to each line
Traversal&lt;String, String&gt; allLines = StringTraversals.lined();
String timestamped = Traversals.modify(
    allLines,
    line -&gt; LocalDateTime.now() + " " + line,
    originalLog
);
</code></pre>
<h3 id="csv-processing"><a class="header" href="#csv-processing">CSV Processing</a></h3>
<pre><code class="language-java">// Process CSV by splitting into lines, then cells
Traversal&lt;String, String&gt; rows = StringTraversals.lined();
Traversal&lt;String, String&gt; cells = StringTraversals.worded();  // Simplified; use split(",") in production

// Transform specific column (e.g., third column to uppercase)
String processedCsv = Traversals.modify(
    rows,
    row -&gt; {
        List&lt;String&gt; parts = List.of(row.split(","));
        if (parts.size() &gt; 2) {
            List&lt;String&gt; modified = new ArrayList&lt;&gt;(parts);
            modified.set(2, parts.get(2).toUpperCase());
            return String.join(",", modified);
        }
        return row;
    },
    csvContent
);
</code></pre>
<h3 id="configuration-file-normalisation"><a class="header" href="#configuration-file-normalisation">Configuration File Normalisation</a></h3>
<pre><code class="language-java">// Trim all property values in .properties format
Traversal&lt;String, String&gt; propertyLines = StringTraversals.lined();

String normalised = Traversals.modify(
    propertyLines,
    line -&gt; {
        if (line.contains("=")) {
            String[] parts = line.split("=", 2);
            return parts[0].trim() + "=" + parts[1].trim();
        }
        return line;
    },
    propertiesContent
);
</code></pre>
<hr />
<h2 id="when-to-use-string-traversals-vs-other-approaches"><a class="header" href="#when-to-use-string-traversals-vs-other-approaches">When to Use String Traversals vs Other Approaches</a></h2>
<h3 id="use-string-traversals-when"><a class="header" href="#use-string-traversals-when">Use String Traversals When:</a></h3>
<ul>
<li><strong>Reusable text transformations</strong> - Define once, apply across multiple strings</li>
<li><strong>Composable pipelines</strong> - Building complex optic chains with lenses and prisms</li>
<li><strong>Type-safe operations</strong> - Character/word/line transformations with compile-time safety</li>
<li><strong>Immutable updates</strong> - Transforming text whilst keeping data immutable</li>
<li><strong>Declarative intent</strong> - Express "what" without "how" (no manual indexing)</li>
</ul>
<pre><code class="language-java">// Perfect: Reusable, composable, declarative
Traversal&lt;Config, String&gt; allPropertyValues =
    ConfigLenses.properties().asTraversal()
        .andThen(StringTraversals.lined())
        .andThen(StringTraversals.worded());

Config trimmed = Traversals.modify(allPropertyValues, String::trim, config);
</code></pre>
<h3 id="use-stream-api-when-4"><a class="header" href="#use-stream-api-when-4">Use Stream API When:</a></h3>
<ul>
<li><strong>Complex filtering</strong> - Multiple conditions with short-circuiting</li>
<li><strong>Aggregations</strong> - Counting, collecting to new structures</li>
<li><strong>No structural preservation needed</strong> - Extracting data, not updating in place</li>
<li><strong>One-time operations</strong> - Not reused across different contexts</li>
</ul>
<pre><code class="language-java">// Better with streams: Complex aggregation
long wordCount = text.lines()
    .flatMap(line -&gt; Arrays.stream(line.split("\\s+")))
    .filter(word -&gt; word.length() &gt; 5)
    .count();
</code></pre>
<h3 id="use-regular-expressions-when"><a class="header" href="#use-regular-expressions-when">Use Regular Expressions When:</a></h3>
<ul>
<li><strong>Complex pattern matching</strong> - Extracting structured data (emails, URLs, dates)</li>
<li><strong>Search and replace</strong> - Simple find-and-replace operations</li>
<li><strong>Validation</strong> - Checking format compliance (phone numbers, postal codes)</li>
</ul>
<pre><code class="language-java">// Sometimes regex is clearest
Pattern emailPattern = Pattern.compile("[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}");
Matcher matcher = emailPattern.matcher(text);
while (matcher.find()) {
    processEmail(matcher.group());
}
</code></pre>
<hr />
<h2 id="common-pitfalls-21"><a class="header" href="#common-pitfalls-21">Common Pitfalls</a></h2>
<h3 id="dont-do-this-11"><a class="header" href="#dont-do-this-11">Don't Do This:</a></h3>
<pre><code class="language-java">// Inefficient: Creating traversals in loops
for (String paragraph : document.paragraphs()) {
    Traversal&lt;String, String&gt; words = StringTraversals.worded();
    Traversals.modify(words, String::toUpperCase, paragraph);
}

// Over-engineering: Using traversals for simple operations
Traversal&lt;String, Character&gt; chars = StringTraversals.chars();
String upper = Traversals.modify(chars, Character::toUpperCase, "hello");
// Just use: "hello".toUpperCase()

// Wrong expectation: Thinking it changes string length
Traversal&lt;String, Character&gt; chars = StringTraversals.chars();
String result = Traversals.modify(chars.filtered(c -&gt; c != 'a'), c -&gt; c, "banana");
// Result: "banana" (still 6 chars, 'a' positions unchanged)
// Filtered traversals preserve structure!
</code></pre>
<h3 id="do-this-instead-11"><a class="header" href="#do-this-instead-11">Do This Instead:</a></h3>
<pre><code class="language-java">// Efficient: Create traversal once, reuse
Traversal&lt;String, String&gt; words = StringTraversals.worded();
List&lt;String&gt; processed = document.paragraphs().stream()
    .map(p -&gt; Traversals.modify(words, String::toUpperCase, p))
    .collect(toList());

// Right tool: Use built-in methods for simple cases
String upper = text.toUpperCase();  // Simple and clear

// Correct expectation: Use getAll for extraction
Traversal&lt;String, Character&gt; vowels = StringTraversals.chars()
    .filtered(c -&gt; "aeiou".indexOf(c) &gt;= 0);
List&lt;Character&gt; extracted = Traversals.getAll(vowels, "banana");
// Result: ['a', 'a', 'a'] - extracts vowels without changing structure
</code></pre>
<hr />
<h2 id="performance-notes-10"><a class="header" href="#performance-notes-10">Performance Notes</a></h2>
<p>String traversals are optimised for immutability:</p>
<ul>
<li><strong>Single pass</strong>: Text is decomposed and reconstructed in one traversal</li>
<li><strong>No intermediate strings</strong>: Operates on character/word lists internally</li>
<li><strong>Structural sharing</strong>: For filtered operations, unchanged portions reference original</li>
<li><strong>Lazy bounds checking</strong>: Minimal overhead for validation</li>
</ul>
<p><strong>Best Practice</strong>: For frequently used string transformations, create traversals as constants:</p>
<pre><code class="language-java">public class TextProcessing {
    // Reusable string traversals
    public static final Traversal&lt;String, String&gt; WORDS =
        StringTraversals.worded();

    public static final Traversal&lt;String, String&gt; LINES =
        StringTraversals.lined();

    public static final Traversal&lt;String, Character&gt; VOWELS =
        StringTraversals.chars().filtered(c -&gt; "aeiouAEIOU".indexOf(c) &gt;= 0);

    // Domain-specific compositions
    public static final Traversal&lt;String, String&gt; ERROR_LOG_LINES =
        LINES.filtered(line -&gt; line.contains("ERROR"));
}
</code></pre>
<hr />
<h2 id="integration-with-functional-java-ecosystem"><a class="header" href="#integration-with-functional-java-ecosystem">Integration with Functional Java Ecosystem</a></h2>
<p>String traversals complement existing functional libraries:</p>
<h3 id="cyclops-integration"><a class="header" href="#cyclops-integration">Cyclops Integration</a></h3>
<pre><code class="language-java">import cyclops.control.Validated;

// Validate each word using Cyclops Validated
Traversal&lt;String, String&gt; words = StringTraversals.worded();

Function&lt;String, Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, String&gt;&gt; validateLength =
    word -&gt; word.length() &lt;= 10
        ? VALIDATED.widen(Validated.valid(word))
        : VALIDATED.widen(Validated.invalid(List.of("Word too long: " + word)));

Validated&lt;List&lt;String&gt;, String&gt; result = VALIDATED.narrow(
    words.modifyF(validateLength, input, validatedApplicative)
);
</code></pre>
<hr />
<h2 id="related-resources-1"><a class="header" href="#related-resources-1">Related Resources</a></h2>
<p><strong>Functional Java Libraries</strong>:</p>
<ul>
<li><a href="https://github.com/aol/cyclops">Cyclops</a> - Functional control structures and higher-kinded types</li>
<li><a href="https://github.com/jOOQ/jOOL">jOOλ</a> - Functional utilities complementing Java Streams</li>
</ul>
<p><strong>Further Reading</strong>:</p>
<ul>
<li><em>Functional Programming in Java</em> by Venkat Subramaniam - Practical FP patterns</li>
<li><em>Modern Java in Action</em> by Raoul-Gabriel Urma - Streams, lambdas, and functional style</li>
<li><a href="https://leanpub.com/optics-by-example">Optics By Example</a> by Chris Penner - Haskell optics comprehensive guide</li>
</ul>
<p><strong>Comparison with Other Languages</strong>:</p>
<ul>
<li>Haskell's <a href="https://hackage.haskell.org/package/text-2.0.2/docs/Data-Text.html"><code>Data.Text</code></a> - Similar text processing with optics</li>
<li>Scala's <a href="https://www.optics.dev/Monocle/">Monocle</a> - String traversals via <code>Traversal[String, Char]</code></li>
</ul>
<hr />
<p><strong>Previous:</strong> <a href="optics/limiting_traversals.html">Limiting Traversals: Focusing on List Portions</a>
<strong>Next:</strong> <a href="optics/common_data_structure_traversals.html">Common Data Structure Traversals</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="indexed-access-at-and-ixed-type-classes"><a class="header" href="#indexed-access-at-and-ixed-type-classes">Indexed Access: At and Ixed Type Classes</a></h1>
<h2 id="crud-and-safe-partial-access-for-collections"><a class="header" href="#crud-and-safe-partial-access-for-collections"><em>CRUD and Safe Partial Access for Collections</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="optics/indexed_access.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to insert, update, and delete entries in indexed structures using <code>At</code></li>
<li>How to safely access and update existing elements using <code>Ixed</code></li>
<li>The key difference: At provides full CRUD, Ixed provides read/update only</li>
<li>Factory methods: <code>mapAt()</code>, <code>listAt()</code>, <code>mapIx()</code>, <code>listIx()</code></li>
<li>Composing with Lenses for deep access into nested collections</li>
<li>Using <code>Prisms.some()</code> to unwrap Optional for chained modifications</li>
<li>When to use At vs Ixed vs direct collection operations</li>
</ul>
</div>
</div>
<div id="admonition-example-code" class="admonition admonish-note" role="note" aria-labelledby="admonition-example-code-title">
<div class="admonition-title">
<div id="admonition-example-code-title">
<p>Example Code</p>
</div>
<a class="admonition-anchor-link" href="optics/indexed_access.html#admonition-example-code"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/AtUsageExample.java">AtUsageExample</a></li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/IxedUsageExample.java">IxedUsageExample</a></li>
</ul>
</div>
</div>
<p>In previous guides, we explored <strong>Lens</strong> for accessing product fields and <strong>Traversal</strong> for operating over collections. But what happens when you need to <em>insert</em> a new entry into a map, <em>delete</em> an existing key, or <em>safely update</em> a specific list index without risking exceptions?</p>
<p>This is where <strong>At</strong> and <strong>Ixed</strong> fill crucial gaps:</p>
<ul>
<li><strong>At</strong> provides full CRUD (Create, Read, Update, Delete) operations via <code>Lens&lt;S, Optional&lt;A&gt;&gt;</code></li>
<li><strong>Ixed</strong> provides safe read/update-only access via <code>Traversal&lt;S, A&gt;</code> that never changes structure</li>
</ul>
<hr />
<h2 id="at-vs-ixed-choosing-the-right-tool"><a class="header" href="#at-vs-ixed-choosing-the-right-tool">At vs Ixed: Choosing the Right Tool</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th>At</th><th>Ixed</th></tr></thead><tbody>
<tr><td><strong>Focus</strong></td><td>Optional presence at index</td><td>Zero or one existing element</td></tr>
<tr><td><strong>Can insert?</strong></td><td>Yes</td><td>No</td></tr>
<tr><td><strong>Can delete?</strong></td><td>Yes</td><td>No</td></tr>
<tr><td><strong>Core operation</strong></td><td><code>Lens&lt;S, Optional&lt;A&gt;&gt;</code></td><td><code>Traversal&lt;S, A&gt;</code></td></tr>
<tr><td><strong>Missing index</strong></td><td>Returns <code>Optional.empty()</code></td><td>Focus is empty (no-op)</td></tr>
<tr><td><strong>Use case</strong></td><td>Map/List CRUD</td><td>Safe partial access</td></tr>
<tr><td><strong>Structure change</strong></td><td>Can change size</td><td>Never changes shape</td></tr>
</tbody></table>
</div><div id="admonition-when-to-use-which" class="admonition admonish-tip" role="note" aria-labelledby="admonition-when-to-use-which-title">
<div class="admonition-title">
<div id="admonition-when-to-use-which-title">
<p>When to Use Which</p>
</div>
<a class="admonition-anchor-link" href="optics/indexed_access.html#admonition-when-to-use-which"></a>
</div>
<div>
<p>Use <strong>At</strong> when you need to add new entries or remove existing ones.</p>
<p>Use <strong>Ixed</strong> when you want safe read/update that never accidentally modifies structure: operations become no-ops for missing indices.</p>
</div>
</div>
<hr />
<h2 id="part-1-at--full-crud-operations"><a class="header" href="#part-1-at--full-crud-operations">Part 1: At – Full CRUD Operations</a></h2>
<h3 id="creating-at-instances"><a class="header" href="#creating-at-instances">Creating At Instances</a></h3>
<pre><code class="language-java">import org.higherkindedj.optics.At;
import org.higherkindedj.optics.at.AtInstances;

// At instance for Map&lt;String, Integer&gt;
At&lt;Map&lt;String, Integer&gt;, String, Integer&gt; mapAt = AtInstances.mapAt();

// At instance for List&lt;String&gt;
At&lt;List&lt;String&gt;, Integer, String&gt; listAt = AtInstances.listAt();

// At instance for List with auto-padding
At&lt;List&lt;String&gt;, Integer, String&gt; paddedListAt = AtInstances.listAtWithPadding(null);
</code></pre>
<h3 id="crud-operations"><a class="header" href="#crud-operations">CRUD Operations</a></h3>
<h4 id="create--insert"><a class="header" href="#create--insert">Create / Insert</a></h4>
<pre><code class="language-java">Map&lt;String, Integer&gt; scores = new HashMap&lt;&gt;();
scores.put("alice", 100);

At&lt;Map&lt;String, Integer&gt;, String, Integer&gt; mapAt = AtInstances.mapAt();

// Insert a new entry
Map&lt;String, Integer&gt; withBob = mapAt.insertOrUpdate("bob", 85, scores);
// Result: {alice=100, bob=85}

// Original unchanged (immutability)
System.out.println(scores); // {alice=100}
</code></pre>
<h4 id="read--query"><a class="header" href="#read--query">Read / Query</a></h4>
<pre><code class="language-java">Optional&lt;Integer&gt; aliceScore = mapAt.get("alice", withBob);
// Result: Optional[100]

Optional&lt;Integer&gt; charlieScore = mapAt.get("charlie", withBob);
// Result: Optional.empty()

boolean hasAlice = mapAt.contains("alice", withBob);
// Result: true
</code></pre>
<h4 id="update--modify"><a class="header" href="#update--modify">Update / Modify</a></h4>
<pre><code class="language-java">// Update existing value
Map&lt;String, Integer&gt; updatedScores = mapAt.insertOrUpdate("alice", 110, withBob);
// Result: {alice=110, bob=85}

// Modify with function
Map&lt;String, Integer&gt; bonusScores = mapAt.modify("bob", x -&gt; x + 10, updatedScores);
// Result: {alice=110, bob=95}

// Modify non-existent key is a no-op
Map&lt;String, Integer&gt; unchanged = mapAt.modify("charlie", x -&gt; x + 10, bonusScores);
// Result: {alice=110, bob=95} (no charlie key)
</code></pre>
<h4 id="delete--remove"><a class="header" href="#delete--remove">Delete / Remove</a></h4>
<pre><code class="language-java">Map&lt;String, Integer&gt; afterRemove = mapAt.remove("alice", bonusScores);
// Result: {bob=95}

// Remove non-existent key is a no-op
Map&lt;String, Integer&gt; stillSame = mapAt.remove("charlie", afterRemove);
// Result: {bob=95}
</code></pre>
<h3 id="the-lens-to-optional-pattern"><a class="header" href="#the-lens-to-optional-pattern">The Lens to Optional Pattern</a></h3>
<p>The core of At is its <code>at(index)</code> method, which returns a <code>Lens&lt;S, Optional&lt;A&gt;&gt;</code>:</p>
<pre><code class="language-java">Lens&lt;Map&lt;String, Integer&gt;, Optional&lt;Integer&gt;&gt; aliceLens = mapAt.at("alice");

Map&lt;String, Integer&gt; scores = new HashMap&lt;&gt;(Map.of("alice", 100));

// Get: Returns Optional
Optional&lt;Integer&gt; score = aliceLens.get(scores);
// Result: Optional[100]

// Set with Optional.of(): Insert or update
Map&lt;String, Integer&gt; updated = aliceLens.set(Optional.of(150), scores);
// Result: {alice=150}

// Set with Optional.empty(): Delete
Map&lt;String, Integer&gt; deleted = aliceLens.set(Optional.empty(), scores);
// Result: {}
</code></pre>
<h3 id="deep-composition-with-at"><a class="header" href="#deep-composition-with-at">Deep Composition with At</a></h3>
<pre><code class="language-java">record Config(Map&lt;String, String&gt; settings) {}

Lens&lt;Config, Map&lt;String, String&gt;&gt; settingsLens =
    Lens.of(Config::settings, (c, s) -&gt; new Config(s));

At&lt;Map&lt;String, String&gt;, String, String&gt; mapAt = AtInstances.mapAt();

// Compose: Config → Map&lt;String, String&gt; → Optional&lt;String&gt;
Lens&lt;Config, Optional&lt;String&gt;&gt; debugSettingLens =
    settingsLens.andThen(mapAt.at("debug"));

Config config = new Config(new HashMap&lt;&gt;());

// Insert new setting through composed lens
Config withDebug = debugSettingLens.set(Optional.of("true"), config);
// Result: Config[settings={debug=true}]

// Delete setting through composed lens
Config withoutDebug = debugSettingLens.set(Optional.empty(), withDebug);
// Result: Config[settings={}]
</code></pre>
<hr />
<h2 id="part-2-ixed--safe-partial-access"><a class="header" href="#part-2-ixed--safe-partial-access">Part 2: Ixed – Safe Partial Access</a></h2>
<h3 id="creating-ixed-instances"><a class="header" href="#creating-ixed-instances">Creating Ixed Instances</a></h3>
<pre><code class="language-java">import org.higherkindedj.optics.At;
import org.higherkindedj.optics.Ixed;
import org.higherkindedj.optics.at.AtInstances;
import org.higherkindedj.optics.ixed.IxedInstances;

// Ixed instance for Map&lt;String, Integer&gt;
Ixed&lt;Map&lt;String, Integer&gt;, String, Integer&gt; mapIx = IxedInstances.mapIx();

// Ixed instance for List&lt;String&gt;
Ixed&lt;List&lt;String&gt;, Integer, String&gt; listIx = IxedInstances.listIx();

// Create Ixed from any At instance
At&lt;Map&lt;String, String&gt;, String, String&gt; customAt = AtInstances.mapAt();
Ixed&lt;Map&lt;String, String&gt;, String, String&gt; customIx = IxedInstances.fromAt(customAt);
</code></pre>
<h3 id="safe-read-operations"><a class="header" href="#safe-read-operations">Safe Read Operations</a></h3>
<pre><code class="language-java">Map&lt;String, Integer&gt; ports = new HashMap&lt;&gt;();
ports.put("http", 8080);
ports.put("https", 8443);

Ixed&lt;Map&lt;String, Integer&gt;, String, Integer&gt; mapIx = IxedInstances.mapIx();

// Read existing key
Optional&lt;Integer&gt; httpPort = IxedInstances.get(mapIx, "http", ports);
// Result: Optional[8080]

// Read missing key - no exception, just empty
Optional&lt;Integer&gt; ftpPort = IxedInstances.get(mapIx, "ftp", ports);
// Result: Optional.empty()
</code></pre>
<h3 id="update-operations-no-insertion"><a class="header" href="#update-operations-no-insertion">Update Operations (No Insertion!)</a></h3>
<p>The crucial difference from At: <code>update</code> only modifies <em>existing</em> entries:</p>
<pre><code class="language-java">// Update existing key - works as expected
Map&lt;String, Integer&gt; updatedPorts = IxedInstances.update(mapIx, "http", 9000, ports);
// Result: {http=9000, https=8443}

// Attempt to "update" non-existent key - NO-OP!
Map&lt;String, Integer&gt; samePorts = IxedInstances.update(mapIx, "ftp", 21, ports);
// Result: {http=8080, https=8443} - NO ftp key added!
</code></pre>
<div id="admonition-key-difference" class="admonition admonish-warning" role="note" aria-labelledby="admonition-key-difference-title">
<div class="admonition-title">
<div id="admonition-key-difference-title">
<p>Key Difference</p>
</div>
<a class="admonition-anchor-link" href="optics/indexed_access.html#admonition-key-difference"></a>
</div>
<div>
<p><strong>At</strong> will insert new entries with <code>insertOrUpdate</code>.</p>
<p><strong>Ixed</strong> will silently do nothing for missing keys; it never changes the structure's shape.</p>
</div>
</div>
<h3 id="safe-list-access"><a class="header" href="#safe-list-access">Safe List Access</a></h3>
<pre><code class="language-java">Ixed&lt;List&lt;String&gt;, Integer, String&gt; listIx = IxedInstances.listIx();
List&lt;String&gt; items = new ArrayList&lt;&gt;(List.of("apple", "banana", "cherry"));

// Access valid index
Optional&lt;String&gt; second = IxedInstances.get(listIx, 1, items);
// Result: Optional["banana"]

// Access out-of-bounds - no exception!
Optional&lt;String&gt; tenth = IxedInstances.get(listIx, 10, items);
// Result: Optional.empty()

// Update out-of-bounds - no-op, no exception
List&lt;String&gt; unchanged = IxedInstances.update(listIx, 10, "grape", items);
// Result: ["apple", "banana", "cherry"] - no element added!
</code></pre>
<h3 id="composition-with-ixed"><a class="header" href="#composition-with-ixed">Composition with Ixed</a></h3>
<pre><code class="language-java">record Config(Map&lt;String, Integer&gt; settings) {}

Lens&lt;Config, Map&lt;String, Integer&gt;&gt; settingsLens =
    Lens.of(Config::settings, (c, s) -&gt; new Config(s));

Ixed&lt;Map&lt;String, Integer&gt;, String, Integer&gt; mapIx = IxedInstances.mapIx();

// Compose: Config → Map&lt;String, Integer&gt; → Integer (0-or-1)
Traversal&lt;Config, Integer&gt; maxConnectionsTraversal =
    settingsLens.asTraversal().andThen(mapIx.ix("maxConnections"));

Config config = new Config(new HashMap&lt;&gt;(Map.of("maxConnections", 100)));

// Safe modification through composed traversal
Config updated = Traversals.modify(maxConnectionsTraversal, x -&gt; x * 2, config);
// Result: Config[settings={maxConnections=200}]

// Missing key = empty focus, modification is no-op
Traversal&lt;Config, Integer&gt; missingTraversal =
    settingsLens.asTraversal().andThen(mapIx.ix("nonexistent"));

Config unchanged = Traversals.modify(missingTraversal, x -&gt; x + 1, config);
// Result: Config unchanged, no "nonexistent" key added
</code></pre>
<hr />
<h2 id="list-specific-considerations"><a class="header" href="#list-specific-considerations">List-Specific Considerations</a></h2>
<h3 id="deletion-shifts-indices-at-only"><a class="header" href="#deletion-shifts-indices-at-only">Deletion Shifts Indices (At only)</a></h3>
<div id="admonition-index-shifting" class="admonition admonish-warning" role="note" aria-labelledby="admonition-index-shifting-title">
<div class="admonition-title">
<div id="admonition-index-shifting-title">
<p>Index Shifting</p>
</div>
<a class="admonition-anchor-link" href="optics/indexed_access.html#admonition-index-shifting"></a>
</div>
<div>
<p>When using <code>At.remove()</code> on a list, subsequent indices shift:</p>
<pre><code class="language-java">At&lt;List&lt;String&gt;, Integer, String&gt; at = AtInstances.listAt();
List&lt;String&gt; items = new ArrayList&lt;&gt;(List.of("a", "b", "c", "d"));

List&lt;String&gt; step1 = at.remove(1, items); // ["a", "c", "d"]

// "d" is now at index 2, not index 3!
Optional&lt;String&gt; result = at.get(3, step1);
// Result: Optional.empty() - index 3 is now out of bounds
</code></pre>
<p>When removing multiple elements, iterate backwards to preserve indices.</p>
</div>
</div>
<h3 id="bounds-checking"><a class="header" href="#bounds-checking">Bounds Checking</a></h3>
<pre><code class="language-java">At&lt;List&lt;String&gt;, Integer, String&gt; listAt = AtInstances.listAt();

// Update at invalid index throws exception
assertThrows(IndexOutOfBoundsException.class, () -&gt;
    listAt.insertOrUpdate(10, "oops", items));

// Use listAtWithPadding for auto-expansion
At&lt;List&lt;String&gt;, Integer, String&gt; paddedAt = AtInstances.listAtWithPadding(null);

List&lt;String&gt; sparse = new ArrayList&lt;&gt;(List.of("a"));
List&lt;String&gt; expanded = paddedAt.insertOrUpdate(4, "e", sparse);
// Result: ["a", null, null, null, "e"]
</code></pre>
<hr />
<h2 id="common-pitfalls-22"><a class="header" href="#common-pitfalls-22">Common Pitfalls</a></h2>
<div id="admonition-avoid-null-values-in-maps" class="admonition admonish-failure" role="note" aria-labelledby="admonition-avoid-null-values-in-maps-title">
<div class="admonition-title">
<div id="admonition-avoid-null-values-in-maps-title">
<p>Avoid: Null values in maps</p>
</div>
<a class="admonition-anchor-link" href="optics/indexed_access.html#admonition-avoid-null-values-in-maps"></a>
</div>
<div>
<pre><code class="language-java">Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
map.put("nullKey", null);

At&lt;Map&lt;String, Integer&gt;, String, Integer&gt; at = AtInstances.mapAt();
Optional&lt;Integer&gt; result = at.get("nullKey", map);
// Result: Optional.empty() - NOT Optional.of(null)!

// Java's Optional cannot hold null values
</code></pre>
</div>
</div>
<div id="admonition-avoid-expecting-ixed-to-insert" class="admonition admonish-failure" role="note" aria-labelledby="admonition-avoid-expecting-ixed-to-insert-title">
<div class="admonition-title">
<div id="admonition-avoid-expecting-ixed-to-insert-title">
<p>Avoid: Expecting Ixed to insert</p>
</div>
<a class="admonition-anchor-link" href="optics/indexed_access.html#admonition-avoid-expecting-ixed-to-insert"></a>
</div>
<div>
<pre><code class="language-java">Ixed&lt;Map&lt;String, Integer&gt;, String, Integer&gt; mapIx = IxedInstances.mapIx();
Map&lt;String, Integer&gt; empty = new HashMap&lt;&gt;();

Map&lt;String, Integer&gt; result = IxedInstances.update(mapIx, "key", 100, empty);
// Result: {} - STILL EMPTY! No insertion occurred.

// If you need insertion, use At instead
</code></pre>
</div>
</div>
<div id="admonition-do-use-prismssome-for-value-level-operations-with-at" class="admonition admonish-success" role="note" aria-labelledby="admonition-do-use-prismssome-for-value-level-operations-with-at-title">
<div class="admonition-title">
<div id="admonition-do-use-prismssome-for-value-level-operations-with-at-title">
<p>Do: Use Prisms.some() for value-level operations with At</p>
</div>
<a class="admonition-anchor-link" href="optics/indexed_access.html#admonition-do-use-prismssome-for-value-level-operations-with-at"></a>
</div>
<div>
<pre><code class="language-java">Lens&lt;Config, Optional&lt;String&gt;&gt; settingLens =
    settingsLens.andThen(mapAt.at("theme"));

Prism&lt;Optional&lt;String&gt;, String&gt; some = Prisms.some();
Traversal&lt;Config, String&gt; valueTraversal =
    settingLens.asTraversal().andThen(some.asTraversal());

// Now you can work with the actual String, not Optional&lt;String&gt;
Config result = Traversals.modify(valueTraversal, String::trim, config);
</code></pre>
</div>
</div>
<hr />
<h2 id="performance-considerations-5"><a class="header" href="#performance-considerations-5">Performance Considerations</a></h2>
<p>Both At and Ixed create new collection instances on every modification:</p>
<pre><code class="language-java">// Each operation copies the entire map - O(n)
Map&lt;String, Integer&gt; step1 = at.insertOrUpdate("a", 1, map);   // Copy
Map&lt;String, Integer&gt; step2 = at.insertOrUpdate("b", 2, step1); // Copy
Map&lt;String, Integer&gt; step3 = at.remove("c", step2);            // Copy
</code></pre>
<div id="admonition-batch-modifications" class="admonition admonish-tip" role="note" aria-labelledby="admonition-batch-modifications-title">
<div class="admonition-title">
<div id="admonition-batch-modifications-title">
<p>Batch Modifications</p>
</div>
<a class="admonition-anchor-link" href="optics/indexed_access.html#admonition-batch-modifications"></a>
</div>
<div>
<p>For multiple updates, consider direct bulk construction then switch to optics for subsequent immutable operations:</p>
<pre><code class="language-java">Map&lt;String, Integer&gt; result = new HashMap&lt;&gt;(original);
result.put("a", 1);
result.put("b", 2);
result.remove("c");
// Now use At/Ixed for subsequent immutable operations
</code></pre>
</div>
</div>
<hr />
<h2 id="summary-14"><a class="header" href="#summary-14">Summary</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Use Case</th><th>Tool</th><th>Why</th></tr></thead><tbody>
<tr><td>Add new map entry</td><td><code>At.insertOrUpdate()</code></td><td>Only At can insert</td></tr>
<tr><td>Delete map entry</td><td><code>At.remove()</code></td><td>Only At can delete</td></tr>
<tr><td>Update if exists, else no-op</td><td><code>Ixed.update()</code></td><td>Safe, structure-preserving</td></tr>
<tr><td>Safe list access without exceptions</td><td><code>Ixed.get()</code></td><td>Returns Optional.empty() for invalid indices</td></tr>
<tr><td>Deep nested CRUD</td><td>At + Lens composition</td><td>Full control over nested maps</td></tr>
<tr><td>Deep nested read/update</td><td>Ixed + Lens composition</td><td>Safe partial access</td></tr>
</tbody></table>
</div>
<p>Both type classes maintain immutability and compose naturally with the rest of the optics ecosystem.</p>
<hr />
<p><a href="optics/string_traversals.html">Previous: String Traversals</a> | <a href="optics/advanced_prism_patterns.html">Next: Advanced Prism Patterns</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="advanced-prism-patterns"><a class="header" href="#advanced-prism-patterns">Advanced Prism Patterns</a></h1>
<h2 id="real-world-applications-of-prisms-in-production-systems"><a class="header" href="#real-world-applications-of-prisms-in-production-systems"><em>Real-World Applications of Prisms in Production Systems</em></a></h2>
<p><img src="optics/../images/prism.jpeg" alt="prism-advanced.jpeg" /></p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="optics/advanced_prism_patterns.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>Configuration management with layered prism composition</li>
<li>API response handling with type-safe error recovery</li>
<li>Data validation pipelines using prisms for conditional processing</li>
<li>Event processing systems with prism-based routing</li>
<li>State machine implementations using prisms for transitions</li>
<li>Plugin architectures with type-safe variant handling</li>
<li>Performance optimisation patterns for production systems</li>
<li>Testing strategies for prism-heavy codebases</li>
</ul>
</div>
</div>
<div id="admonition-hands-on-practice" class="admonition admonish-note" role="note" aria-labelledby="admonition-hands-on-practice-title">
<div class="admonition-title">
<div id="admonition-hands-on-practice-title">
<p>Hands On Practice</p>
</div>
<a class="admonition-anchor-link" href="optics/advanced_prism_patterns.html#admonition-hands-on-practice"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/optics/Tutorial10_AdvancedPrismPatterns.java">Tutorial10_AdvancedPrismPatterns.java</a></p>
</div>
</div>
<div id="admonition-example-code" class="admonition admonish-note" role="note" aria-labelledby="admonition-example-code-title">
<div class="admonition-title">
<div id="admonition-example-code-title">
<p>Example Code</p>
</div>
<a class="admonition-anchor-link" href="optics/advanced_prism_patterns.html#admonition-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/ConfigurationManagementExample.java">ConfigurationManagementExample</a>
<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/ApiResponseHandlingExample.java">ApiResponseHandlingExample</a>
<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/DataValidationPipelineExample.java">DataValidationPipelineExample</a>
<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/EventProcessingExample.java">EventProcessingExample</a>
<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/StateMachineExample.java">StateMachineExample</a>
<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/PluginSystemExample.java">PluginSystemExample</a></p>
</div>
</div>
<p>This guide explores sophisticated prism patterns encountered in production Java applications. We'll move beyond basic type matching to examine how prisms enable elegant solutions to complex architectural problems.</p>
<div id="admonition-prerequisites" class="admonition admonish-note" role="note" aria-labelledby="admonition-prerequisites-title">
<div class="admonition-title">
<div id="admonition-prerequisites-title">
<p>Prerequisites</p>
</div>
<a class="admonition-anchor-link" href="optics/advanced_prism_patterns.html#admonition-prerequisites"></a>
</div>
<div>
<p>This guide assumes familiarity with prism fundamentals including <code>getOptional()</code>, <code>build()</code>, convenience methods (<code>matches()</code>, <code>modify()</code>, <code>modifyWhen()</code>, etc.), and the <code>Prisms</code> utility class. If you're new to prisms, start with <a href="optics/prisms.html">Prisms: A Practical Guide</a> which covers:</p>
<ul>
<li>Core prism operations and type-safe variant handling</li>
<li>The 7 convenience methods for streamlined operations</li>
<li>The <code>Prisms</code> utility class for common patterns</li>
<li>Composition with lenses and traversals</li>
</ul>
</div>
</div>
<hr />
<h2 id="pattern-1-configuration-management"><a class="header" href="#pattern-1-configuration-management">Pattern 1: Configuration Management</a></h2>
<h3 id="type-safe-layered-configuration-resolution"><a class="header" href="#type-safe-layered-configuration-resolution"><em>Type-Safe, Layered Configuration Resolution</em></a></h3>
<p>Configuration systems often deal with multiple sources (environment variables, files, defaults) and various data types. Prisms provide a type-safe way to navigate this complexity.</p>
<h3 id="the-challenge"><a class="header" href="#the-challenge">The Challenge</a></h3>
<pre><code class="language-java">// Traditional approach: brittle and verbose
Object rawValue = config.get("database.connection.pool.size");
if (rawValue instanceof Integer i) {
    return i &gt; 0 ? i : DEFAULT_POOL_SIZE;
} else if (rawValue instanceof String s) {
    try {
        int parsed = Integer.parseInt(s);
        return parsed &gt; 0 ? parsed : DEFAULT_POOL_SIZE;
    } catch (NumberFormatException e) {
        return DEFAULT_POOL_SIZE;
    }
}
return DEFAULT_POOL_SIZE;
</code></pre>
<h3 id="the-prism-solution"><a class="header" href="#the-prism-solution">The Prism Solution</a></h3>
<pre><code class="language-java">@GeneratePrisms
sealed interface ConfigValue permits StringValue, IntValue, BoolValue, NestedConfig {}

record StringValue(String value) implements ConfigValue {}
record IntValue(int value) implements ConfigValue {}
record BoolValue(boolean value) implements ConfigValue {}
record NestedConfig(Map&lt;String, ConfigValue&gt; values) implements ConfigValue {}

public class ConfigResolver {
    private static final Prism&lt;ConfigValue, IntValue&gt; INT =
        ConfigValuePrisms.intValue();
    private static final Prism&lt;ConfigValue, StringValue&gt; STRING =
        ConfigValuePrisms.stringValue();

    public static int getPoolSize(ConfigValue value) {
        // Try integer first, fall back to parsing string
        return INT.mapOptional(IntValue::value, value)
            .filter(i -&gt; i &gt; 0)
            .or(() -&gt; STRING.mapOptional(StringValue::value, value)
                .flatMap(ConfigResolver::safeParseInt)
                .filter(i -&gt; i &gt; 0))
            .orElse(DEFAULT_POOL_SIZE);
    }

    private static Optional&lt;Integer&gt; safeParseInt(String s) {
        try {
            return Optional.of(Integer.parseInt(s));
        } catch (NumberFormatException e) {
            return Optional.empty();
        }
    }
}
</code></pre>
<h3 id="nested-configuration-access"><a class="header" href="#nested-configuration-access">Nested Configuration Access</a></h3>
<pre><code class="language-java">// Build a type-safe path through nested configuration
Prism&lt;ConfigValue, NestedConfig&gt; nested = ConfigValuePrisms.nestedConfig();
Lens&lt;NestedConfig, Map&lt;String, ConfigValue&gt;&gt; values = NestedConfigLenses.values();

Traversal&lt;ConfigValue, ConfigValue&gt; databaseConfig =
    nested.asTraversal()
        .andThen(values.asTraversal())
        .andThen(Traversals.forMap("database"))
        .andThen(nested.asTraversal())
        .andThen(values.asTraversal())
        .andThen(Traversals.forMap("connection"));

// Extract with fallback
ConfigValue rootConfig = loadConfiguration(); // Top-level configuration object
Optional&lt;ConfigValue&gt; connConfig = Traversals.getAll(databaseConfig, rootConfig)
    .stream().findFirst();
</code></pre>
<div id="admonition-configuration-best-practices" class="admonition admonish-tip" role="note" aria-labelledby="admonition-configuration-best-practices-title">
<div class="admonition-title">
<div id="admonition-configuration-best-practices-title">
<p>Configuration Best Practices</p>
</div>
<a class="admonition-anchor-link" href="optics/advanced_prism_patterns.html#admonition-configuration-best-practices"></a>
</div>
<div>
<ul>
<li><strong>Cache composed prisms</strong>: Configuration paths don't change at runtime</li>
<li><strong>Use <code>orElse()</code> chains</strong>: Handle type coercion gracefully</li>
<li><strong>Validate at load time</strong>: Use <code>modifyWhen()</code> to enforce constraints</li>
<li><strong>Provide clear defaults</strong>: Always have fallback values</li>
</ul>
</div>
</div>
<hr />
<h2 id="pattern-2-api-response-handling"><a class="header" href="#pattern-2-api-response-handling">Pattern 2: API Response Handling</a></h2>
<h3 id="type-safe-http-response-processing"><a class="header" href="#type-safe-http-response-processing"><em>Type-Safe HTTP Response Processing</em></a></h3>
<p>Modern APIs return varying response types based on status codes. Prisms provide elegant error handling and recovery strategies.</p>
<h3 id="the-challenge-1"><a class="header" href="#the-challenge-1">The Challenge</a></h3>
<pre><code class="language-java">// Traditional approach: error-prone branching
if (response.status() == 200) {
    return processSuccess((SuccessResponse) response);
} else if (response.status() == 400) {
    ValidationError err = (ValidationError) response;
    return handleValidation(err);
} else if (response.status() == 500) {
    return handleServerError((ServerError) response);
} else if (response.status() == 429) {
    return retryWithBackoff((RateLimitError) response);
}
// What about 401, 403, 404, ...?
</code></pre>
<h3 id="the-prism-solution-1"><a class="header" href="#the-prism-solution-1">The Prism Solution</a></h3>
<pre><code class="language-java">@GeneratePrisms
@GenerateLenses
sealed interface ApiResponse permits Success, ValidationError, ServerError,
                                     RateLimitError, AuthError, NotFoundError {}

record Success(JsonValue data, int statusCode) implements ApiResponse {}
record ValidationError(List&lt;String&gt; errors, String field) implements ApiResponse {}
record ServerError(String message, String traceId) implements ApiResponse {}
record RateLimitError(long retryAfterMs) implements ApiResponse {}
record AuthError(String realm) implements ApiResponse {}
record NotFoundError(String resource) implements ApiResponse {}

public class ApiHandler {
    // Reusable prisms for each response type
    private static final Prism&lt;ApiResponse, Success&gt; SUCCESS =
        ApiResponsePrisms.success();
    private static final Prism&lt;ApiResponse, ValidationError&gt; VALIDATION =
        ApiResponsePrisms.validationError();
    private static final Prism&lt;ApiResponse, RateLimitError&gt; RATE_LIMIT =
        ApiResponsePrisms.rateLimitError();
    private static final Prism&lt;ApiResponse, ServerError&gt; SERVER_ERROR =
        ApiResponsePrisms.serverError();

    public Either&lt;String, JsonValue&gt; handleResponse(ApiResponse response) {
        // Try success first
        return SUCCESS.mapOptional(Success::data, response)
            .map(Either::&lt;String, JsonValue&gt;right)
            // Then validation errors
            .or(() -&gt; VALIDATION.mapOptional(
                err -&gt; Either.&lt;String, JsonValue&gt;left(
                    "Validation failed: " + String.join(", ", err.errors())
                ),
                response
            ))
            // Then server errors
            .or(() -&gt; SERVER_ERROR.mapOptional(
                err -&gt; Either.&lt;String, JsonValue&gt;left(
                    "Server error: " + err.message() + " [" + err.traceId() + "]"
                ),
                response
            ))
            .orElse(Either.left("Unknown error type"));
    }

    public boolean isRetryable(ApiResponse response) {
        return RATE_LIMIT.matches(response) || SERVER_ERROR.matches(response);
    }

    public Optional&lt;Long&gt; getRetryDelay(ApiResponse response) {
        return RATE_LIMIT.mapOptional(RateLimitError::retryAfterMs, response);
    }
}
</code></pre>
<h3 id="advanced-response-pipeline-with-fallbacks"><a class="header" href="#advanced-response-pipeline-with-fallbacks">Advanced: Response Pipeline with Fallbacks</a></h3>
<pre><code class="language-java">public class ResilientApiClient {
    public CompletableFuture&lt;JsonValue&gt; fetchWithFallbacks(String endpoint) {
        return primaryApi.call(endpoint)
            .thenCompose(response -&gt;
                SUCCESS.mapOptional(Success::data, response)
                    .map(CompletableFuture::completedFuture)
                    .or(() -&gt; RATE_LIMIT.mapOptional(
                        err -&gt; CompletableFuture.supplyAsync(
                            () -&gt; callSecondaryApi(endpoint),
                            delayedExecutor(err.retryAfterMs(), TimeUnit.MILLISECONDS)
                        ),
                        response
                    ))
                    .orElseGet(() -&gt; CompletableFuture.failedFuture(
                        new ApiException("Unrecoverable error")
                    ))
            );
    }
}
</code></pre>
<div id="admonition-production-considerations" class="admonition admonish-warning" role="note" aria-labelledby="admonition-production-considerations-title">
<div class="admonition-title">
<div id="admonition-production-considerations-title">
<p>Production Considerations</p>
</div>
<a class="admonition-anchor-link" href="optics/advanced_prism_patterns.html#admonition-production-considerations"></a>
</div>
<div>
<p>When using prisms for API handling:</p>
<ul>
<li><strong>Log unmatched cases</strong>: Track responses that don't match any prism</li>
<li><strong>Metrics</strong>: Count matches per prism type for monitoring</li>
<li><strong>Circuit breakers</strong>: Integrate retry logic with circuit breaker patterns</li>
<li><strong>Structured logging</strong>: Use <code>mapOptional()</code> to extract error details</li>
</ul>
</div>
</div>
<hr />
<h2 id="pattern-3-data-validation-pipelines"><a class="header" href="#pattern-3-data-validation-pipelines">Pattern 3: Data Validation Pipelines</a></h2>
<h3 id="composable-type-safe-validation-logic"><a class="header" href="#composable-type-safe-validation-logic"><em>Composable, Type-Safe Validation Logic</em></a></h3>
<p>Validation often requires checking different data types and applying conditional rules. Prisms make validation logic declarative and reusable.</p>
<h3 id="the-challenge-2"><a class="header" href="#the-challenge-2">The Challenge</a></h3>
<p>ETL pipelines process heterogeneous data where validation rules depend on data types:</p>
<pre><code class="language-java">// Traditional approach: imperative branching
List&lt;ValidationError&gt; errors = new ArrayList&lt;&gt;();
for (Object value : row.values()) {
    if (value instanceof String s) {
        if (s.length() &gt; MAX_STRING_LENGTH) {
            errors.add(new ValidationError("String too long: " + s));
        }
    } else if (value instanceof Integer i) {
        if (i &lt; 0) {
            errors.add(new ValidationError("Negative integer: " + i));
        }
    }
    // ... more type checks
}
</code></pre>
<h3 id="the-prism-solution-2"><a class="header" href="#the-prism-solution-2">The Prism Solution</a></h3>
<pre><code class="language-java">@GeneratePrisms
sealed interface DataValue permits StringData, IntData, DoubleData, NullData {}

record StringData(String value) implements DataValue {}
record IntData(int value) implements DataValue {}
record DoubleData(double value) implements DataValue {}
record NullData() implements DataValue {}

public class ValidationPipeline {
    // Validation rules as prism transformations
    private static final Prism&lt;DataValue, StringData&gt; STRING =
        DataValuePrisms.stringData();
    private static final Prism&lt;DataValue, IntData&gt; INT =
        DataValuePrisms.intData();

    public static List&lt;String&gt; validate(List&lt;DataValue&gt; row) {
        return row.stream()
            .flatMap(value -&gt; Stream.concat(
                // Validate strings
                STRING.mapOptional(
                    s -&gt; s.value().length() &gt; MAX_STRING_LENGTH
                        ? Optional.of("String too long: " + s.value())
                        : Optional.empty(),
                    value
                ).stream(),
                // Validate integers
                INT.mapOptional(
                    i -&gt; i.value() &lt; 0
                        ? Optional.of("Negative integer: " + i.value())
                        : Optional.empty(),
                    value
                ).stream()
            ))
            .collect(Collectors.toList());
    }

    // Sanitise data by modifying only invalid values
    public static List&lt;DataValue&gt; sanitise(List&lt;DataValue&gt; row) {
        return row.stream()
            .map(value -&gt;
                // Truncate long strings
                STRING.modifyWhen(
                    s -&gt; s.value().length() &gt; MAX_STRING_LENGTH,
                    s -&gt; new StringData(s.value().substring(0, MAX_STRING_LENGTH)),
                    value
                )
            )
            .map(value -&gt;
                // Clamp negative integers to zero
                INT.modifyWhen(
                    i -&gt; i.value() &lt; 0,
                    i -&gt; new IntData(0),
                    value
                )
            )
            .collect(Collectors.toList());
    }
}
</code></pre>
<h3 id="advanced-validation-with-accumulation"><a class="header" href="#advanced-validation-with-accumulation">Advanced: Validation with Accumulation</a></h3>
<p>Using <code>Either</code> and prisms for validation that accumulates errors:</p>
<pre><code class="language-java">public class AccumulatingValidator {
    public static Either&lt;List&lt;String&gt;, List&lt;DataValue&gt;&gt; validateAll(List&lt;DataValue&gt; row) {
        List&lt;String&gt; errors = new ArrayList&lt;&gt;();
        List&lt;DataValue&gt; sanitised = new ArrayList&lt;&gt;();

        for (DataValue value : row) {
            // Validate and potentially sanitise each value
            DataValue processed = value;

            // Check strings
            processed = STRING.modifyWhen(
                s -&gt; s.value().length() &gt; MAX_STRING_LENGTH,
                s -&gt; {
                    errors.add("Truncated: " + s.value());
                    return new StringData(s.value().substring(0, MAX_STRING_LENGTH));
                },
                processed
            );

            // Check integers
            processed = INT.modifyWhen(
                i -&gt; i.value() &lt; 0,
                i -&gt; {
                    errors.add("Clamped negative: " + i.value());
                    return new IntData(0);
                },
                processed
            );

            sanitised.add(processed);
        }

        return errors.isEmpty()
            ? Either.right(sanitised)
            : Either.left(errors);
    }
}
</code></pre>
<div id="admonition-validation-pipeline-best-practices" class="admonition admonish-tip" role="note" aria-labelledby="admonition-validation-pipeline-best-practices-title">
<div class="admonition-title">
<div id="admonition-validation-pipeline-best-practices-title">
<p>Validation Pipeline Best Practices</p>
</div>
<a class="admonition-anchor-link" href="optics/advanced_prism_patterns.html#admonition-validation-pipeline-best-practices"></a>
</div>
<div>
<ul>
<li><strong>Compose validators</strong>: Build complex validation from simple prism rules</li>
<li><strong>Use <code>modifyWhen()</code> for sanitisation</strong>: Fix values whilst tracking changes</li>
<li><strong>Accumulate errors</strong>: Don't fail-fast; collect all validation issues</li>
<li><strong>Type-specific rules</strong>: Let prisms dispatch to appropriate validators</li>
</ul>
</div>
</div>
<hr />
<h2 id="pattern-4-event-processing"><a class="header" href="#pattern-4-event-processing">Pattern 4: Event Processing</a></h2>
<h3 id="type-safe-event-routing-and-handling"><a class="header" href="#type-safe-event-routing-and-handling"><em>Type-Safe Event Routing and Handling</em></a></h3>
<p>Event-driven systems receive heterogeneous event types that require different processing logic. Prisms provide type-safe routing without <code>instanceof</code> cascades.</p>
<h3 id="the-challenge-3"><a class="header" href="#the-challenge-3">The Challenge</a></h3>
<pre><code class="language-java">// Traditional approach: brittle event dispatching
public void handleEvent(Event event) {
    if (event instanceof UserCreated uc) {
        sendWelcomeEmail(uc.userId(), uc.email());
        provisionResources(uc.userId());
    } else if (event instanceof UserDeleted ud) {
        cleanupResources(ud.userId());
        archiveData(ud.userId());
    } else if (event instanceof OrderPlaced op) {
        processPayment(op.orderId());
        updateInventory(op.items());
    }
    // Grows with each new event type
}
</code></pre>
<h3 id="the-prism-solution-3"><a class="header" href="#the-prism-solution-3">The Prism Solution</a></h3>
<pre><code class="language-java">@GeneratePrisms
@GenerateLenses
sealed interface DomainEvent permits UserCreated, UserDeleted, UserUpdated,
                                     OrderPlaced, OrderCancelled, PaymentProcessed {}

record UserCreated(String userId, String email, Instant timestamp) implements DomainEvent {}
record UserDeleted(String userId, Instant timestamp) implements DomainEvent {}
record UserUpdated(String userId, Map&lt;String, String&gt; changes, Instant timestamp) implements DomainEvent {}
record OrderPlaced(String orderId, List&lt;LineItem&gt; items, Instant timestamp) implements DomainEvent {}
record OrderCancelled(String orderId, String reason, Instant timestamp) implements DomainEvent {}
record PaymentProcessed(String orderId, double amount, Instant timestamp) implements DomainEvent {}

public class EventRouter {
    private static final Prism&lt;DomainEvent, UserCreated&gt; USER_CREATED =
        DomainEventPrisms.userCreated();
    private static final Prism&lt;DomainEvent, UserDeleted&gt; USER_DELETED =
        DomainEventPrisms.userDeleted();
    private static final Prism&lt;DomainEvent, OrderPlaced&gt; ORDER_PLACED =
        DomainEventPrisms.orderPlaced();

    // Declarative event handler registry
    private final Map&lt;Prism&lt;DomainEvent, ?&gt;, Consumer&lt;DomainEvent&gt;&gt; handlers = Map.of(
        USER_CREATED, event -&gt; USER_CREATED.mapOptional(
            uc -&gt; {
                sendWelcomeEmail(uc.userId(), uc.email());
                provisionResources(uc.userId());
                return uc;
            },
            event
        ),
        USER_DELETED, event -&gt; USER_DELETED.mapOptional(
            ud -&gt; {
                cleanupResources(ud.userId());
                archiveData(ud.userId());
                return ud;
            },
            event
        ),
        ORDER_PLACED, event -&gt; ORDER_PLACED.mapOptional(
            op -&gt; {
                processPayment(op.orderId());
                updateInventory(op.items());
                return op;
            },
            event
        )
    );

    public void route(DomainEvent event) {
        handlers.entrySet().stream()
            .filter(entry -&gt; entry.getKey().matches(event))
            .findFirst()
            .ifPresentOrElse(
                entry -&gt; entry.getValue().accept(event),
                () -&gt; log.warn("Unhandled event type: {}", event.getClass())
            );
    }
}
</code></pre>
<h3 id="advanced-event-filtering-and-transformation"><a class="header" href="#advanced-event-filtering-and-transformation">Advanced: Event Filtering and Transformation</a></h3>
<pre><code class="language-java">public class EventProcessor {
    // Process only recent user events
    public List&lt;DomainEvent&gt; getRecentUserEvents(
        List&lt;DomainEvent&gt; events,
        Instant since
    ) {
        Prism&lt;DomainEvent, UserCreated&gt; userCreated = USER_CREATED;
        Prism&lt;DomainEvent, UserDeleted&gt; userDeleted = USER_DELETED;

        return events.stream()
            .filter(e -&gt;
                // Match user events with timestamp filter
                userCreated.mapOptional(
                    uc -&gt; uc.timestamp().isAfter(since) ? uc : null,
                    e
                ).isPresent()
                ||
                userDeleted.mapOptional(
                    ud -&gt; ud.timestamp().isAfter(since) ? ud : null,
                    e
                ).isPresent()
            )
            .collect(Collectors.toList());
    }

    // Transform events for audit log
    public List&lt;AuditEntry&gt; toAuditLog(List&lt;DomainEvent&gt; events) {
        return events.stream()
            .flatMap(event -&gt;
                // Extract audit entries from different event types
                USER_CREATED.mapOptional(
                    uc -&gt; new AuditEntry("USER_CREATED", uc.userId(), uc.timestamp()),
                    event
                ).or(() -&gt;
                    ORDER_PLACED.mapOptional(
                        op -&gt; new AuditEntry("ORDER_PLACED", op.orderId(), op.timestamp()),
                        event
                    )
                ).stream()
            )
            .collect(Collectors.toList());
    }
}
</code></pre>
<div id="admonition-event-processing-best-practices" class="admonition admonish-tip" role="note" aria-labelledby="admonition-event-processing-best-practices-title">
<div class="admonition-title">
<div id="admonition-event-processing-best-practices-title">
<p>Event Processing Best Practices</p>
</div>
<a class="admonition-anchor-link" href="optics/advanced_prism_patterns.html#admonition-event-processing-best-practices"></a>
</div>
<div>
<ul>
<li><strong>Registry pattern</strong>: Map prisms to handlers for extensibility</li>
<li><strong>Metrics</strong>: Track event types processed using <code>matches()</code></li>
<li><strong>Dead letter queue</strong>: Log events that match no prism</li>
<li><strong>Event sourcing</strong>: Use prisms to replay specific event types</li>
</ul>
</div>
</div>
<hr />
<h2 id="pattern-5-state-machines"><a class="header" href="#pattern-5-state-machines">Pattern 5: State Machines</a></h2>
<h3 id="type-safe-state-transitions"><a class="header" href="#type-safe-state-transitions"><em>Type-Safe State Transitions</em></a></h3>
<p>State machines with complex transition rules benefit from prisms' ability to safely match states and transform between them.</p>
<h3 id="the-challenge-4"><a class="header" href="#the-challenge-4">The Challenge</a></h3>
<pre><code class="language-java">// Traditional approach: verbose state management
public Order transition(Order order, OrderEvent event) {
    if (order.state() instanceof Pending &amp;&amp; event instanceof PaymentReceived) {
        return order.withState(new Processing(((PaymentReceived) event).transactionId()));
    } else if (order.state() instanceof Processing &amp;&amp; event instanceof ShippingCompleted) {
        return order.withState(new Shipped(((ShippingCompleted) event).trackingNumber()));
    }
    // Many more transitions...
    throw new IllegalStateException("Invalid transition");
}
</code></pre>
<h3 id="the-prism-solution-4"><a class="header" href="#the-prism-solution-4">The Prism Solution</a></h3>
<pre><code class="language-java">@GeneratePrisms
sealed interface OrderState permits Pending, Processing, Shipped, Delivered, Cancelled {}

record Pending(Instant createdAt) implements OrderState {}
record Processing(String transactionId, Instant startedAt) implements OrderState {}
record Shipped(String trackingNumber, Instant shippedAt) implements OrderState {}
record Delivered(Instant deliveredAt) implements OrderState {}
record Cancelled(String reason, Instant cancelledAt) implements OrderState {}

@GeneratePrisms
sealed interface OrderEvent permits PaymentReceived, ShippingCompleted,
                                    DeliveryConfirmed, CancellationRequested {}

record PaymentReceived(String transactionId) implements OrderEvent {}
record ShippingCompleted(String trackingNumber) implements OrderEvent {}
record DeliveryConfirmed() implements OrderEvent {}
record CancellationRequested(String reason) implements OrderEvent {}

public class OrderStateMachine {
    private static final Prism&lt;OrderState, Pending&gt; PENDING =
        OrderStatePrisms.pending();
    private static final Prism&lt;OrderState, Processing&gt; PROCESSING =
        OrderStatePrisms.processing();
    private static final Prism&lt;OrderState, Shipped&gt; SHIPPED =
        OrderStatePrisms.shipped();

    private static final Prism&lt;OrderEvent, PaymentReceived&gt; PAYMENT =
        OrderEventPrisms.paymentReceived();
    private static final Prism&lt;OrderEvent, ShippingCompleted&gt; SHIPPING =
        OrderEventPrisms.shippingCompleted();
    private static final Prism&lt;OrderEvent, DeliveryConfirmed&gt; DELIVERY =
        OrderEventPrisms.deliveryConfirmed();

    // Define valid transitions as prism combinations
    public Optional&lt;OrderState&gt; transition(OrderState currentState, OrderEvent event) {
        // Pending -&gt; Processing (on payment)
        if (PENDING.matches(currentState) &amp;&amp; PAYMENT.matches(event)) {
            return PAYMENT.mapOptional(
                payment -&gt; new Processing(payment.transactionId(), Instant.now()),
                event
            );
        }

        // Processing -&gt; Shipped (on shipping)
        if (PROCESSING.matches(currentState) &amp;&amp; SHIPPING.matches(event)) {
            return SHIPPING.mapOptional(
                shipping -&gt; new Shipped(shipping.trackingNumber(), Instant.now()),
                event
            );
        }

        // Shipped -&gt; Delivered (on confirmation)
        if (SHIPPED.matches(currentState) &amp;&amp; DELIVERY.matches(event)) {
            return Optional.of(new Delivered(Instant.now()));
        }

        return Optional.empty(); // Invalid transition
    }

    // Guard conditions using prisms
    public boolean canCancel(OrderState state) {
        // Can cancel if Pending or Processing
        return PENDING.matches(state) || PROCESSING.matches(state);
    }

    // Extract state-specific data
    public Optional&lt;String&gt; getTrackingNumber(OrderState state) {
        return SHIPPED.mapOptional(Shipped::trackingNumber, state);
    }
}
</code></pre>
<h3 id="advanced-transition-table"><a class="header" href="#advanced-transition-table">Advanced: Transition Table</a></h3>
<pre><code class="language-java">import org.higherkindedj.optics.util.Pair; // Pair utility from hkj-optics

public class AdvancedStateMachine {
    // Define transitions as a declarative table
    private static final Map&lt;
        Pair&lt;Prism&lt;OrderState, ?&gt;, Prism&lt;OrderEvent, ?&gt;&gt;,
        BiFunction&lt;OrderState, OrderEvent, OrderState&gt;
    &gt; TRANSITIONS = Map.of(
        Pair.of(PENDING, PAYMENT),
        (state, event) -&gt; PAYMENT.mapOptional(
            p -&gt; new Processing(p.transactionId(), Instant.now()),
            event
        ).orElse(state),

        Pair.of(PROCESSING, SHIPPING),
        (state, event) -&gt; SHIPPING.mapOptional(
            s -&gt; new Shipped(s.trackingNumber(), Instant.now()),
            event
        ).orElse(state)
    );

    public OrderState process(OrderState state, OrderEvent event) {
        return TRANSITIONS.entrySet().stream()
            .filter(entry -&gt;
                entry.getKey().first().matches(state) &amp;&amp;
                entry.getKey().second().matches(event)
            )
            .findFirst()
            .map(entry -&gt; entry.getValue().apply(state, event))
            .orElseThrow(() -&gt; new IllegalStateException(
                "Invalid transition: " + state + " -&gt; " + event
            ));
    }
}
</code></pre>
<div id="admonition-state-machine-best-practices" class="admonition admonish-tip" role="note" aria-labelledby="admonition-state-machine-best-practices-title">
<div class="admonition-title">
<div id="admonition-state-machine-best-practices-title">
<p>State Machine Best Practices</p>
</div>
<a class="admonition-anchor-link" href="optics/advanced_prism_patterns.html#admonition-state-machine-best-practices"></a>
</div>
<div>
<ul>
<li><strong>Exhaustive matching</strong>: Ensure all valid transitions are covered</li>
<li><strong>Guard conditions</strong>: Use <code>matches()</code> for pre-condition checks</li>
<li><strong>Immutability</strong>: States are immutable; transitions create new instances</li>
<li><strong>Audit trail</strong>: Log state transitions using prism metadata</li>
</ul>
</div>
</div>
<hr />
<h2 id="pattern-6-plugin-systems"><a class="header" href="#pattern-6-plugin-systems">Pattern 6: Plugin Systems</a></h2>
<h3 id="type-safe-plugin-discovery-and-execution"><a class="header" href="#type-safe-plugin-discovery-and-execution"><em>Type-Safe Plugin Discovery and Execution</em></a></h3>
<p>Plugin architectures require dynamic dispatch to various plugin types whilst maintaining type safety.</p>
<h3 id="the-challenge-5"><a class="header" href="#the-challenge-5">The Challenge</a></h3>
<pre><code class="language-java">// Traditional approach: reflection and casting
public void executePlugin(Plugin plugin, Object context) {
    if (plugin.getClass().getName().equals("DatabasePlugin")) {
        ((DatabasePlugin) plugin).execute((DatabaseContext) context);
    } else if (plugin.getClass().getName().equals("FileSystemPlugin")) {
        ((FileSystemPlugin) plugin).execute((FileSystemContext) context);
    }
    // Fragile and unsafe
}
</code></pre>
<h3 id="the-prism-solution-5"><a class="header" href="#the-prism-solution-5">The Prism Solution</a></h3>
<pre><code class="language-java">@GeneratePrisms
sealed interface Plugin permits DatabasePlugin, FileSystemPlugin,
                                 NetworkPlugin, ComputePlugin {}

record DatabasePlugin(String query, DatabaseConfig config) implements Plugin {
    public Result execute(DatabaseContext ctx) {
        return ctx.executeQuery(query, config);
    }
}

record FileSystemPlugin(Path path, FileOperation operation) implements Plugin {
    public Result execute(FileSystemContext ctx) {
        return ctx.performOperation(path, operation);
    }
}

record NetworkPlugin(URL endpoint, HttpMethod method) implements Plugin {
    public Result execute(NetworkContext ctx) {
        return ctx.makeRequest(endpoint, method);
    }
}

record ComputePlugin(String script, Runtime runtime) implements Plugin {
    public Result execute(ComputeContext ctx) {
        return ctx.runScript(script, runtime);
    }
}

public class PluginExecutor {
    private static final Prism&lt;Plugin, DatabasePlugin&gt; DB =
        PluginPrisms.databasePlugin();
    private static final Prism&lt;Plugin, FileSystemPlugin&gt; FS =
        PluginPrisms.fileSystemPlugin();
    private static final Prism&lt;Plugin, NetworkPlugin&gt; NET =
        PluginPrisms.networkPlugin();
    private static final Prism&lt;Plugin, ComputePlugin&gt; COMPUTE =
        PluginPrisms.computePlugin();

    public Either&lt;String, Result&gt; execute(
        Plugin plugin,
        ExecutionContext context
    ) {
        // Type-safe dispatch to appropriate handler
        return DB.mapOptional(
            dbPlugin -&gt; context.getDatabaseContext()
                .map(dbPlugin::execute)
                .map(Either::&lt;String, Result&gt;right)
                .orElse(Either.left("Database context not available")),
            plugin
        ).or(() -&gt;
            FS.mapOptional(
                fsPlugin -&gt; context.getFileSystemContext()
                    .map(fsPlugin::execute)
                    .map(Either::&lt;String, Result&gt;right)
                    .orElse(Either.left("FileSystem context not available")),
                plugin
            )
        ).or(() -&gt;
            NET.mapOptional(
                netPlugin -&gt; context.getNetworkContext()
                    .map(netPlugin::execute)
                    .map(Either::&lt;String, Result&gt;right)
                    .orElse(Either.left("Network context not available")),
                plugin
            )
        ).or(() -&gt;
            COMPUTE.mapOptional(
                computePlugin -&gt; context.getComputeContext()
                    .map(computePlugin::execute)
                    .map(Either::&lt;String, Result&gt;right)
                    .orElse(Either.left("Compute context not available")),
                plugin
            )
        ).orElse(Either.left("Unknown plugin type"));
    }

    // Validate plugin before execution
    public List&lt;String&gt; validate(Plugin plugin) {
        List&lt;String&gt; errors = new ArrayList&lt;&gt;();

        DB.mapOptional(p -&gt; {
            if (p.query().isEmpty()) {
                errors.add("Database query cannot be empty");
            }
            return p;
        }, plugin);

        FS.mapOptional(p -&gt; {
            if (!Files.exists(p.path())) {
                errors.add("File path does not exist: " + p.path());
            }
            return p;
        }, plugin);

        return errors;
    }
}
</code></pre>
<h3 id="advanced-plugin-composition"><a class="header" href="#advanced-plugin-composition">Advanced: Plugin Composition</a></h3>
<pre><code class="language-java">public class CompositePlugin {
    // Combine multiple plugins into a pipeline
    public static Plugin pipeline(List&lt;Plugin&gt; plugins) {
        return new CompositePluginImpl(plugins);
    }

    // Filter plugins by type for batch operations
    public static List&lt;DatabasePlugin&gt; getAllDatabasePlugins(List&lt;Plugin&gt; plugins) {
        Prism&lt;Plugin, DatabasePlugin&gt; dbPrism = DB;
        return plugins.stream()
            .flatMap(p -&gt; dbPrism.getOptional(p).stream())
            .collect(Collectors.toList());
    }

    // Transform plugins based on environment
    public static List&lt;Plugin&gt; adaptForEnvironment(
        List&lt;Plugin&gt; plugins,
        Environment env
    ) {
        return plugins.stream()
            .map(plugin -&gt;
                // Modify database plugins for different environments
                DB.modifyWhen(
                    db -&gt; env == Environment.PRODUCTION,
                    db -&gt; new DatabasePlugin(
                        db.query(),
                        db.config().withReadReplica()
                    ),
                    plugin
                )
            )
            .collect(Collectors.toList());
    }
}
</code></pre>
<div id="admonition-plugin-architecture-best-practices" class="admonition admonish-tip" role="note" aria-labelledby="admonition-plugin-architecture-best-practices-title">
<div class="admonition-title">
<div id="admonition-plugin-architecture-best-practices-title">
<p>Plugin Architecture Best Practices</p>
</div>
<a class="admonition-anchor-link" href="optics/advanced_prism_patterns.html#admonition-plugin-architecture-best-practices"></a>
</div>
<div>
<ul>
<li><strong>Capability detection</strong>: Use <code>matches()</code> to check plugin capabilities</li>
<li><strong>Fail-safe execution</strong>: Always handle unmatched plugin types</li>
<li><strong>Plugin validation</strong>: Use prisms to validate configuration before execution</li>
<li><strong>Metrics</strong>: Track plugin execution by type using prism-based routing</li>
</ul>
</div>
</div>
<hr />
<h2 id="performance-optimisation-patterns"><a class="header" href="#performance-optimisation-patterns">Performance Optimisation Patterns</a></h2>
<h3 id="caching-composed-prisms"><a class="header" href="#caching-composed-prisms">Caching Composed Prisms</a></h3>
<pre><code class="language-java">public class OptimisedPrismCache {
    // Cache expensive optic compositions
    private static final Map&lt;String, Object&gt; OPTIC_CACHE =
        new ConcurrentHashMap&lt;&gt;();

    @SuppressWarnings("unchecked")
    public static &lt;T&gt; T getCached(
        String key,
        Supplier&lt;T&gt; factory
    ) {
        return (T) OPTIC_CACHE.computeIfAbsent(key, k -&gt; factory.get());
    }

    // Example usage: caching a composed traversal
    private static final Traversal&lt;Config, String&gt; DATABASE_HOST =
        getCached("config.database.host", () -&gt;
            ConfigLenses.database()
                .asTraversal()
                .andThen(Prisms.some().asTraversal())
                .andThen(Prisms.right().asTraversal())
                .andThen(DatabaseSettingsLenses.host().asTraversal())
        );
}
</code></pre>
<h3 id="bulk-operations-with-prisms"><a class="header" href="#bulk-operations-with-prisms">Bulk Operations with Prisms</a></h3>
<pre><code class="language-java">public class BulkProcessor {
    // Process multiple items efficiently
    public static &lt;S, A&gt; List&lt;A&gt; extractAll(
        Prism&lt;S, A&gt; prism,
        List&lt;S&gt; items
    ) {
        return items.stream()
            .flatMap(item -&gt; prism.getOptional(item).stream())
            .collect(Collectors.toList());
    }

    // Partition items by prism match
    public static &lt;S, A&gt; Map&lt;Boolean, List&lt;S&gt;&gt; partitionByMatch(
        Prism&lt;S, A&gt; prism,
        List&lt;S&gt; items
    ) {
        return items.stream()
            .collect(Collectors.partitioningBy(prism::matches));
    }
}
</code></pre>
<hr />
<h2 id="testing-strategies"><a class="header" href="#testing-strategies">Testing Strategies</a></h2>
<h3 id="testing-prism-based-logic"><a class="header" href="#testing-prism-based-logic">Testing Prism-Based Logic</a></h3>
<pre><code class="language-java">public class PrismTestPatterns {
    @Test
    void testPrismMatching() {
        Prism&lt;ApiResponse, Success&gt; success = ApiResponsePrisms.success();

        ApiResponse successResponse = new Success(jsonData, 200);
        ApiResponse errorResponse = new ServerError("Error", "trace123");

        // Verify matching behaviour
        assertTrue(success.matches(successResponse));
        assertFalse(success.matches(errorResponse));

        // Verify extraction
        assertThat(success.getOptional(successResponse))
            .isPresent()
            .get()
            .extracting(Success::statusCode)
            .isEqualTo(200);
    }

    @Test
    void testComposedPrisms() {
        // Test deep prism compositions
        Prism&lt;Config, String&gt; hostPrism = buildHostPrism();

        Config validConfig = createValidConfig();
        Config invalidConfig = createInvalidConfig();

        assertThat(hostPrism.getOptional(validConfig)).isPresent();
        assertThat(hostPrism.getOptional(invalidConfig)).isEmpty();
    }

    @Test
    void testConditionalOperations() {
        Prism&lt;ConfigValue, IntValue&gt; intPrism = ConfigValuePrisms.intValue();

        ConfigValue value = new IntValue(42);

        // Test modifyWhen
        ConfigValue result = intPrism.modifyWhen(
            i -&gt; i.value() &gt; 0,
            i -&gt; new IntValue(i.value() * 2),
            value
        );

        assertThat(intPrism.getOptional(result))
            .isPresent()
            .get()
            .extracting(IntValue::value)
            .isEqualTo(84);
    }
}
</code></pre>
<hr />
<div id="admonition-further-reading" class="admonition admonish-tip" role="note" aria-labelledby="admonition-further-reading-title">
<div class="admonition-title">
<div id="admonition-further-reading-title">
<p>Further Reading</p>
</div>
<a class="admonition-anchor-link" href="optics/advanced_prism_patterns.html#admonition-further-reading"></a>
</div>
<div>
<ul>
<li><strong>Monocle</strong>: <a href="https://www.optics.dev/Monocle/">Scala Optics Library</a> - Production-ready Scala optics with extensive patterns</li>
<li><strong>Haskell Lens</strong>: <a href="https://hackage.haskell.org/package/lens">Canonical Reference</a> - The original comprehensive optics library</li>
<li><strong>Lens Tutorial</strong>: <a href="https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial">A Little Lens Starter Tutorial</a> - Beginner-friendly introduction</li>
</ul>
</div>
</div>
<div id="admonition-hands-on-learning" class="admonition admonish-info" role="note" aria-labelledby="admonition-hands-on-learning-title">
<div class="admonition-title">
<div id="admonition-hands-on-learning-title">
<p>Hands-On Learning</p>
</div>
<a class="admonition-anchor-link" href="optics/advanced_prism_patterns.html#admonition-hands-on-learning"></a>
</div>
<div>
<p>Practice advanced prism patterns in <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/optics/Tutorial10_AdvancedPrismPatterns.java">Tutorial 10: Advanced Prism Patterns</a> (8 exercises, ~12 minutes).</p>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="optics/prisms.html">Prisms: A Practical Guide</a>
<strong>Next:</strong> <a href="optics/iso.html">Isomorphisms: Data Equivalence</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="profunctor-optics-advanced-data-transformation"><a class="header" href="#profunctor-optics-advanced-data-transformation">Profunctor Optics: Advanced Data Transformation</a></h1>
<h2 id="adapting-optics-to-different-data-types"><a class="header" href="#adapting-optics-to-different-data-types"><em>Adapting Optics to Different Data Types</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="optics/profunctor_optics.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to adapt existing optics to work with different data types</li>
<li>Using <code>contramap</code> to change source types and <code>map</code> to change target types</li>
<li>Combining both adaptations with <code>dimap</code> for complete format conversion</li>
<li>Creating reusable adapter patterns for API integration</li>
<li>Working with type-safe wrapper classes and legacy system integration</li>
<li>When to use profunctor adaptations vs creating new optics from scratch</li>
</ul>
</div>
</div>
<div id="admonition-example-code" class="admonition admonish-note" role="note" aria-labelledby="admonition-example-code-title">
<div class="admonition-title">
<div id="admonition-example-code-title">
<p>Example Code</p>
</div>
<a class="admonition-anchor-link" href="optics/profunctor_optics.html#admonition-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/profunctor/OpticProfunctorExample.java">OpticProfunctorExample</a></p>
</div>
</div>
<p>In the previous optics guides, we explored how to work with data structures directly using <code>Lens</code>, <code>Prism</code>, <code>Iso</code>, and <code>Traversal</code>. But what happens when you need to use an optic designed for one data type with a completely different data structure? What if you want to adapt an existing optic to work with new input or output formats?</p>
<p>This is where the <strong>profunctor</strong> nature of optics becomes invaluable. Every optic in higher-kinded-j is fundamentally a profunctor, which means it can be adapted to work with different source and target types using powerful transformation operations.</p>
<hr />
<h2 id="the-challenge-type-mismatch-in-real-systems"><a class="header" href="#the-challenge-type-mismatch-in-real-systems">The Challenge: Type Mismatch in Real Systems</a></h2>
<p>In real-world applications, you frequently encounter situations where:</p>
<ul>
<li><strong>Legacy Integration</strong>: You have optics designed for old data structures but need to work with new ones</li>
<li><strong>API Adaptation</strong>: External APIs use different field names or data formats than your internal models</li>
<li><strong>Type Safety</strong>: You want to work with strongly-typed wrapper classes but reuse optics designed for raw values</li>
<li><strong>Data Migration</strong>: You're transitioning between data formats and need optics that work with both</li>
</ul>
<p>Consider this scenario: you have a well-tested <code>Lens</code> that operates on a <code>Person</code> record, but you need to use it with an <code>Employee</code> record that contains a <code>Person</code> as a nested field. Rather than rewriting the lens, you can <strong>adapt</strong> it.</p>
<h2 id="think-of-profunctor-adaptations-like"><a class="header" href="#think-of-profunctor-adaptations-like">Think of Profunctor Adaptations Like...</a></h2>
<ul>
<li><strong>Universal adapters</strong>: Like electrical plug adapters that make devices work in different countries</li>
<li><strong>Translation layers</strong>: Converting between different "languages" of data representation</li>
<li><strong>Lens filters</strong>: Modifying what the optic sees (input) and what it produces (output)</li>
<li><strong>Pipeline adapters</strong>: Connecting optics that weren't originally designed to work together</li>
</ul>
<h2 id="the-three-profunctor-operations"><a class="header" href="#the-three-profunctor-operations">The Three Profunctor Operations</a></h2>
<p>Every optic provides three powerful adaptation methods that mirror the core profunctor operations:</p>
<h3 id="1-contramap-adapting-the-source-type"><a class="header" href="#1-contramap-adapting-the-source-type">1. <strong><code>contramap</code></strong>: Adapting the Source Type</a></h3>
<p>The <code>contramap</code> operation allows you to adapt an optic to work with a different source type by providing a function that converts from the new source to the original source.</p>
<p><strong>Use Case</strong>: You have a <code>Lens&lt;Person, String&gt;</code> for getting a person's first name, but you want to use it with <code>Employee</code> objects.</p>
<pre><code class="language-java">// Original lens: Person -&gt; String (first name)
Lens&lt;Person, String&gt; firstNameLens = PersonLenses.firstName();

// Adapt it to work with Employee by providing the conversion
Lens&lt;Employee, String&gt; employeeFirstNameLens = 
    firstNameLens.contramap(employee -&gt; employee.personalInfo());

// Now you can use the adapted lens directly on Employee objects
Employee employee = new Employee(123, new Person("Alice", "Johnson", ...), "Engineering");
String firstName = employeeFirstNameLens.get(employee); // "Alice"
</code></pre>
<h3 id="2-map-adapting-the-target-type"><a class="header" href="#2-map-adapting-the-target-type">2. <strong><code>map</code></strong>: Adapting the Target Type</a></h3>
<p>The <code>map</code> operation adapts an optic to work with a different target type by providing a function that converts from the original target to the new target.</p>
<p><strong>Use Case</strong>: You have a <code>Lens&lt;Person, LocalDate&gt;</code> for birth dates, but you want to work with formatted strings instead.</p>
<pre><code class="language-java">// Original lens: Person -&gt; LocalDate
Lens&lt;Person, LocalDate&gt; birthDateLens = PersonLenses.birthDate();

// Adapt it to work with formatted strings
Lens&lt;Person, String&gt; birthDateStringLens = 
    birthDateLens.map(date -&gt; date.format(DateTimeFormatter.ISO_LOCAL_DATE));

// The adapted lens now returns strings
Person person = new Person("Bob", "Smith", LocalDate.of(1985, 12, 25), ...);
String dateString = birthDateStringLens.get(person); // "1985-12-25"
</code></pre>
<h3 id="3-dimap-adapting-both-source-and-target-types"><a class="header" href="#3-dimap-adapting-both-source-and-target-types">3. <strong><code>dimap</code></strong>: Adapting Both Source and Target Types</a></h3>
<p>The <code>dimap</code> operation is the most powerful: it adapts both the source and target types simultaneously. This is perfect for converting between completely different data representations.</p>
<p><strong>Use Case</strong>: You have optics designed for internal <code>Person</code> objects but need to work with external <code>PersonDto</code> objects that use different field structures.</p>
<pre><code class="language-java">// Original traversal: Person -&gt; String (hobbies)
Traversal&lt;Person, String&gt; hobbiesTraversal = PersonTraversals.hobbies();

// Adapt it to work with PersonDto (different source) and call them "interests" (different context)
Traversal&lt;PersonDto, String&gt; interestsTraversal = 
    hobbiesTraversal.dimap(
        // Convert PersonDto to Person
        dto -&gt; new Person(
            dto.fullName().split(" ")[0],
            dto.fullName().split(" ")[1], 
            LocalDate.parse(dto.birthDateString()),
            dto.interests()
        ),
        // Convert Person back to PersonDto  
        person -&gt; new PersonDto(
            person.firstName() + " " + person.lastName(),
            person.birthDate().format(DateTimeFormatter.ISO_LOCAL_DATE),
            person.hobbies()
        )
    );
</code></pre>
<hr />
<h2 id="decision-guide-when-to-use-each-operation"><a class="header" href="#decision-guide-when-to-use-each-operation">Decision Guide: When to Use Each Operation</a></h2>
<h3 id="use-contramap-when"><a class="header" href="#use-contramap-when">Use <code>contramap</code> When:</a></h3>
<ul>
<li><strong>Different source type, same target</strong> - Existing optic works perfectly, just need different input</li>
<li><strong>Extracting nested data</strong> - Your new type contains the old type as a field</li>
<li><strong>Wrapper type handling</strong> - Working with strongly-typed wrappers around base types</li>
</ul>
<p>java</p>
<pre><code class="language-java">// Perfect for extracting nested data
Lens&lt;Order, String&gt; customerNameLens = 
    OrderLenses.customer().contramap(invoice -&gt; invoice.order());
</code></pre>
<h3 id="use-map-when"><a class="header" href="#use-map-when">Use <code>map</code> When:</a></h3>
<ul>
<li><strong>Same source, different target format</strong> - You want to transform the output</li>
<li><strong>Data presentation</strong> - Converting raw data to display formats</li>
<li><strong>Type strengthening</strong> - Wrapping raw values in type-safe containers</li>
</ul>
<p>java</p>
<pre><code class="language-java">// Perfect for presentation formatting
Lens&lt;Product, String&gt; formattedPriceLens = 
    ProductLenses.price().map(price -&gt; "£" + price.setScale(2));
</code></pre>
<h3 id="use-dimap-when"><a class="header" href="#use-dimap-when">Use <code>dimap</code> When:</a></h3>
<ul>
<li><strong>Complete format conversion</strong> - Both input and output need transformation</li>
<li><strong>API integration</strong> - External systems use completely different data structures</li>
<li><strong>Legacy system support</strong> - Bridging between old and new data formats</li>
<li><strong>Data migration</strong> - Supporting multiple data representations simultaneously</li>
</ul>
<p>java</p>
<pre><code class="language-java">// Perfect for API integration
Traversal&lt;ApiUserDto, String&gt; apiRolesTraversal = 
    UserTraversals.roles().dimap(
        dto -&gt; convertApiDtoToUser(dto),
        userLogin -&gt; convertUserToApiDto(userLogin)
    );
</code></pre>
<hr />
<h2 id="common-pitfalls-23"><a class="header" href="#common-pitfalls-23">Common Pitfalls</a></h2>
<h3 id="dont-do-this-12"><a class="header" href="#dont-do-this-12">Don't Do This:</a></h3>
<pre><code class="language-java">// Creating adapters inline repeatedly
var lens1 = PersonLenses.firstName().contramap(emp -&gt; emp.person());
var lens2 = PersonLenses.firstName().contramap(emp -&gt; emp.person());
var lens3 = PersonLenses.firstName().contramap(emp -&gt; emp.person());

// Over-adapting simple cases
Lens&lt;Person, String&gt; nameUpper = PersonLenses.firstName()
    .map(String::toUpperCase)
    .map(s -&gt; s.trim())
    .map(s -&gt; s.replace(" ", "_")); // Just write one function!

// Forgetting null safety in conversions
Lens&lt;EmployeeDto, String&gt; unsafeLens = PersonLenses.firstName()
    .contramap(dto -&gt; dto.person()); // What if dto.person() is null?

// Complex conversions without error handling
Traversal&lt;String, LocalDate&gt; fragileParser = 
    Iso.of(LocalDate::toString, LocalDate::parse).asTraversal()
    .contramap(complexString -&gt; extractDatePart(complexString)); // Might throw!
</code></pre>
<h3 id="do-this-instead-12"><a class="header" href="#do-this-instead-12">Do This Instead:</a></h3>
<pre><code class="language-java">// Create adapters once, reuse everywhere
public static final Lens&lt;Employee, String&gt; EMPLOYEE_FIRST_NAME = 
    PersonLenses.firstName().contramap(Employee::personalInfo);

// Combine transformations efficiently
Function&lt;String, String&gt; normalise = name -&gt; 
    name.toUpperCase().trim().replace(" ", "_");
Lens&lt;Person, String&gt; normalisedNameLens = PersonLenses.firstName().map(normalise);

// Handle null safety explicitly
Lens&lt;EmployeeDto, Optional&lt;String&gt;&gt; safeNameLens = PersonLenses.firstName()
    .contramap((EmployeeDto dto) -&gt; Optional.ofNullable(dto.person()))
    .map(Optional::of);

// Use safe conversions with proper error handling
Function&lt;String, Either&lt;String, LocalDate&gt;&gt; safeParse = str -&gt; {
    try {
        return Either.right(LocalDate.parse(extractDatePart(str)));
    } catch (Exception e) {
        return Either.left("Invalid date: " + str);
    }
};
</code></pre>
<hr />
<h2 id="performance-notes-11"><a class="header" href="#performance-notes-11">Performance Notes</a></h2>
<p>Profunctor adaptations are designed for efficiency:</p>
<ul>
<li><strong>Automatic fusion</strong>: Multiple <code>contramap</code> or <code>map</code> operations are automatically combined</li>
<li><strong>Lazy evaluation</strong>: Conversions only happen when the optic is actually used</li>
<li><strong>No boxing overhead</strong>: Simple transformations are inlined by the JVM</li>
<li><strong>Reusable adapters</strong>: Create once, use many times without additional overhead</li>
</ul>
<p><strong>Best Practice</strong>: Create adapted optics as constants and reuse them:</p>
<pre><code class="language-java">public class OpticAdapters {
    // Create once, use everywhere
    public static final Lens&lt;Employee, String&gt; FIRST_NAME = 
        PersonLenses.firstName().contramap(Employee::personalInfo);
  
    public static final Lens&lt;Employee, String&gt; FORMATTED_BIRTH_DATE = 
        PersonLenses.birthDate()
            .contramap(Employee::personalInfo)
            .map(date -&gt; date.format(DateTimeFormatter.DD_MM_YYYY));
      
    public static final Traversal&lt;CompanyDto, String&gt; EMPLOYEE_EMAILS = 
        CompanyTraversals.employees()
            .contramap((CompanyDto dto) -&gt; convertDtoToCompany(dto))
            .andThen(EmployeeTraversals.contacts())
            .andThen(ContactLenses.email().asTraversal());
}
</code></pre>
<hr />
<h2 id="real-world-example-api-integration"><a class="header" href="#real-world-example-api-integration">Real-World Example: API Integration</a></h2>
<p>Let's explore a comprehensive example where you need to integrate with an external API that uses different field names and data structures than your internal models.</p>
<p><strong>The Scenario</strong>: Your internal system uses <code>Employee</code> records, but the external API expects <code>EmployeeDto</code> objects with different field names:</p>
<pre><code class="language-java">// Internal model
@GenerateLenses
@GenerateTraversals
public record Employee(int id, Person personalInfo, String department) {}

@GenerateLenses
@GenerateTraversals  
public record Person(String firstName, String lastName, LocalDate birthDate, List&lt;String&gt; skills) {}

// External API model  
@GenerateLenses
public record EmployeeDto(int employeeId, PersonDto person, String dept) {}

@GenerateLenses
public record PersonDto(String fullName, String birthDateString, List&lt;String&gt; expertise) {}
</code></pre>
<p><strong>The Solution</strong>: Create an adapter that converts between these formats while reusing your existing optics:</p>
<pre><code class="language-java">public class ApiIntegration {
  
    // Conversion utilities
    private static Employee dtoToEmployee(EmployeeDto dto) {
        PersonDto personDto = dto.person();
        String[] nameParts = personDto.fullName().split(" ", 2);
        Person person = new Person(
            nameParts[0],
            nameParts.length &gt; 1 ? nameParts[1] : "",
            LocalDate.parse(personDto.birthDateString()),
            personDto.expertise()
        );
        return new Employee(dto.employeeId(), person, dto.dept());
    }
  
    private static EmployeeDto employeeToDto(Employee employee) {
        Person person = employee.personalInfo();
        PersonDto personDto = new PersonDto(
            person.firstName() + " " + person.lastName(),
            person.birthDate().toString(),
            person.skills()
        );
        return new EmployeeDto(employee.id(), personDto, employee.department());
    }
  
    // Adapted optics for API integration
    public static final Lens&lt;EmployeeDto, String&gt; API_EMPLOYEE_DEPARTMENT = 
        EmployeeLenses.department().dimap(
            ApiIntegration::dtoToEmployee,
            ApiIntegration::employeeToDto
        );
  
    public static final Lens&lt;EmployeeDto, String&gt; API_EMPLOYEE_FIRST_NAME = 
        EmployeeLenses.personalInfo()
            .andThen(PersonLenses.firstName())
            .dimap(
                ApiIntegration::dtoToEmployee,
                ApiIntegration::employeeToDto
            );
  
    public static final Traversal&lt;EmployeeDto, String&gt; API_EMPLOYEE_SKILLS = 
        EmployeeTraversals.personalInfo()
            .andThen(PersonTraversals.skills())
            .dimap(
                ApiIntegration::dtoToEmployee,
                ApiIntegration::employeeToDto
            );
  
    // Use the adapters seamlessly with external data
    public void processApiData(EmployeeDto externalEmployee) {
        // Update department using existing business logic
        EmployeeDto promoted = API_EMPLOYEE_DEPARTMENT.modify(
            dept -&gt; "Senior " + dept, 
            externalEmployee
        );
    
        // Normalise skills using existing traversal logic
        EmployeeDto normalisedSkills = Traversals.modify(
            API_EMPLOYEE_SKILLS,
            skill -&gt; skill.toLowerCase().trim(),
            externalEmployee
        );
    
        sendToApi(promoted);
        sendToApi(normalisedSkills);
    }
}
</code></pre>
<hr />
<h2 id="working-with-type-safe-wrappers"><a class="header" href="#working-with-type-safe-wrappers">Working with Type-Safe Wrappers</a></h2>
<p>Another powerful use case is adapting optics to work with strongly-typed wrapper classes while maintaining type safety.</p>
<p><strong>The Challenge</strong>: You want to use string manipulation functions on wrapper types:</p>
<pre><code class="language-java">// Strongly-typed wrappers
public record UserId(String value) {}
public record UserName(String value) {}
public record Email(String value) {}

@GenerateLenses
public record User(UserId id, UserName name, Email email, LocalDate createdAt) {}
</code></pre>
<p><strong>The Solution</strong>: Create adapted lenses that unwrap and rewrap values:</p>
<pre><code class="language-java">public class WrapperAdapters {
  
    // Generic wrapper lens creator
    public static &lt;W&gt; Lens&lt;W, String&gt; stringWrapperLens(
        Function&lt;W, String&gt; unwrap,
        Function&lt;String, W&gt; wrap
    ) {
        return Lens.of(unwrap, (wrapper, newValue) -&gt; wrap.apply(newValue));
    }
  
    // Specific wrapper lenses
    public static final Lens&lt;UserId, String&gt; USER_ID_STRING = 
        stringWrapperLens(UserId::value, UserId::new);
      
    public static final Lens&lt;UserName, String&gt; USER_NAME_STRING = 
        stringWrapperLens(UserName::value, UserName::new);
      
    public static final Lens&lt;Email, String&gt; EMAIL_STRING = 
        stringWrapperLens(Email::value, Email::new);
  
    // Composed lenses for User operations
    public static final Lens&lt;User, String&gt; USER_NAME_VALUE = 
        UserLenses.name().andThen(USER_NAME_STRING);
      
    public static final Lens&lt;User, String&gt; USER_EMAIL_VALUE = 
        UserLenses.email().andThen(EMAIL_STRING);
  
    // Usage examples
    public User normaliseUser(User userLogin) {
        return USER_NAME_VALUE.modify(name -&gt; 
            Arrays.stream(name.toLowerCase().split(" "))
                .map(word -&gt; Character.toUpperCase(word.charAt(0)) + word.substring(1))
                .collect(joining(" ")),
            userLogin
        );
    }
  
    public User updateEmailDomain(User userLogin, String newDomain) {
        return USER_EMAIL_VALUE.modify(email -&gt; {
            String localPart = email.substring(0, email.indexOf('@'));
            return localPart + "@" + newDomain;
        }, userLogin);
    }
}
</code></pre>
<hr />
<h2 id="migration-patterns"><a class="header" href="#migration-patterns">Migration Patterns</a></h2>
<p>Profunctor adaptations are particularly valuable during system migrations:</p>
<h3 id="legacy-system-integration"><a class="header" href="#legacy-system-integration">Legacy System Integration</a></h3>
<pre><code class="language-java">// You have optics for PersonV1, but data is now PersonV2
public record PersonV1(String name, int age) {}

@GenerateLenses
public record PersonV2(String firstName, String lastName, LocalDate birthDate) {}

public class MigrationAdapters {
  
    // Convert between versions
    private static PersonV1 v2ToV1(PersonV2 v2) {
        return new PersonV1(
            v2.firstName() + " " + v2.lastName(),
            Period.between(v2.birthDate(), LocalDate.now()).getYears()
        );
    }
  
    private static PersonV2 v1ToV2(PersonV1 v1) {
        String[] nameParts = v1.name().split(" ", 2);
        return new PersonV2(
            nameParts[0],
            nameParts.length &gt; 1 ? nameParts[1] : "",
            LocalDate.now().minusYears(v1.age())
        );
    }
  
    // Existing V1 optics work with V2 data
    public static final Lens&lt;PersonV2, String&gt; V2_NAME_FROM_V1_LENS = 
        // Assume we have a V1 name lens
        Lens.of(PersonV1::name, (p1, name) -&gt; new PersonV1(name, p1.age()))
            .dimap(MigrationAdapters::v2ToV1, MigrationAdapters::v1ToV2);
}
</code></pre>
<h3 id="database-schema-evolution"><a class="header" href="#database-schema-evolution">Database Schema Evolution</a></h3>
<pre><code class="language-java">// Old database entity
public record CustomerEntityV1(Long id, String name, String email) {}

// New database entity  
@GenerateLenses
public record CustomerEntityV2(Long id, String firstName, String lastName, String emailAddress, boolean active) {}

public class SchemaAdapters {
  
    // Adapter for name field
    public static final Lens&lt;CustomerEntityV2, String&gt; FULL_NAME_ADAPTER = 
        Lens.of(CustomerEntityV1::name, (v1, name) -&gt; new CustomerEntityV1(v1.id(), name, v1.email()))
            .dimap(
                // V2 -&gt; V1 conversion
                v2 -&gt; new CustomerEntityV1(v2.id(), v2.firstName() + " " + v2.lastName(), v2.emailAddress()),
                // V1 -&gt; V2 conversion  
                v1 -&gt; {
                    String[] parts = v1.name().split(" ", 2);
                    return new CustomerEntityV2(
                        v1.id(),
                        parts[0],
                        parts.length &gt; 1 ? parts[1] : "",
                        v1.email(),
                        true // Default active status
                    );
                }
            );
}
</code></pre>
<hr />
<h2 id="complete-runnable-example-7"><a class="header" href="#complete-runnable-example-7">Complete, Runnable Example</a></h2>
<p>This comprehensive example demonstrates all three profunctor operations in a realistic scenario:</p>
<pre><code class="language-java">package org.higherkindedj.example.optics.profunctor;

import org.higherkindedj.optics.Lens;
import org.higherkindedj.optics.Traversal;
import org.higherkindedj.optics.annotations.GenerateLenses;
import org.higherkindedj.optics.annotations.GenerateTraversals;
import org.higherkindedj.optics.util.Traversals;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.Optional;

public class OpticProfunctorExample {

    // Internal data model
    @GenerateLenses
    @GenerateTraversals
    public record Person(String firstName, String lastName, LocalDate birthDate, List&lt;String&gt; hobbies) {}
  
    @GenerateLenses
    public record Employee(int id, Person personalInfo, String department) {}
  
    // External API model
    @GenerateLenses
    public record PersonDto(String fullName, String birthDateString, List&lt;String&gt; interests) {}
  
    @GenerateLenses  
    public record EmployeeDto(int employeeId, PersonDto person, String dept) {}
  
    // Type-safe wrapper
    public record UserId(long value) {}
  
    @GenerateLenses
    public record UserProfile(UserId id, String displayName, boolean active) {}

    public static void main(String[] args) {
        System.out.println("=== PROFUNCTOR OPTICS EXAMPLE ===");
      
        // Test data
        var person = new Person("Alice", "Johnson", 
            LocalDate.of(1985, 6, 15), 
            List.of("reading", "cycling", "photography"));
        var employee = new Employee(123, person, "Engineering");
      
        // --- SCENARIO 1: contramap - Adapt source type ---
        System.out.println("--- Scenario 1: contramap (Source Adaptation) ---");
      
        // Original lens works on Person, adapt it for Employee
        Lens&lt;Person, String&gt; firstNameLens = PersonLenses.firstName();
        Lens&lt;Employee, String&gt; employeeFirstNameLens = 
            firstNameLens.contramap(Employee::personalInfo);
      
        String name = employeeFirstNameLens.get(employee);
        Employee renamedEmployee = employeeFirstNameLens.set("Alicia", employee);
      
        System.out.println("Original employee: " + employee);
        System.out.println("Extracted name: " + name);
        System.out.println("Renamed employee: " + renamedEmployee);
        System.out.println();
      
        // --- SCENARIO 2: map - Adapt target type ---
        System.out.println("--- Scenario 2: map (Target Adaptation) ---");
      
        // Original lens returns LocalDate, adapt it to return formatted string
        Lens&lt;Person, LocalDate&gt; birthDateLens = PersonLenses.birthDate();
        Lens&lt;Person, String&gt; birthDateStringLens = 
            birthDateLens.map(date -&gt; date.format(DateTimeFormatter.ISO_LOCAL_DATE));
      
        String formattedDate = birthDateStringLens.get(person);
        // Note: set operation would need to parse the string back to LocalDate
        System.out.println("Person: " + person);
        System.out.println("Formatted birth date: " + formattedDate);
        System.out.println();
      
        // --- SCENARIO 3: dimap - Adapt both source and target ---
        System.out.println("--- Scenario 3: dimap (Both Source and Target Adaptation) ---");
      
        // Convert between internal Person and external PersonDto
        Traversal&lt;Person, String&gt; hobbiesTraversal = PersonTraversals.hobbies();
        Traversal&lt;PersonDto, String&gt; interestsTraversal = hobbiesTraversal.dimap(
            // PersonDto -&gt; Person
            dto -&gt; {
                String[] nameParts = dto.fullName().split(" ", 2);
                return new Person(
                    nameParts[0],
                    nameParts.length &gt; 1 ? nameParts[1] : "",
                    LocalDate.parse(dto.birthDateString()),
                    dto.interests()
                );
            },
            // Person -&gt; PersonDto  
            p -&gt; new PersonDto(
                p.firstName() + " " + p.lastName(),
                p.birthDate().toString(),
                p.hobbies()
            )
        );
      
        var personDto = new PersonDto("Bob Smith", "1990-03-20", 
            List.of("gaming", "cooking", "travel"));
      
        List&lt;String&gt; extractedInterests = Traversals.getAll(interestsTraversal, personDto);
        PersonDto updatedDto = Traversals.modify(interestsTraversal, 
            interest -&gt; interest.toUpperCase(), personDto);
      
        System.out.println("Original DTO: " + personDto);
        System.out.println("Extracted interests: " + extractedInterests);
        System.out.println("Updated DTO: " + updatedDto);
        System.out.println();
      
        // --- SCENARIO 4: Working with wrapper types ---
        System.out.println("--- Scenario 4: Wrapper Type Integration ---");
      
        // Create a lens that works directly with the wrapped value
        Lens&lt;UserId, Long&gt; userIdValueLens = Lens.of(UserId::value, (id, newValue) -&gt; new UserId(newValue));
        Lens&lt;UserProfile, Long&gt; profileIdValueLens = 
            UserProfileLenses.id().andThen(userIdValueLens);
      
        var userProfile = new UserProfile(new UserId(456L), "Alice J.", true);
      
        Long idValue = profileIdValueLens.get(userProfile);
        UserProfile updatedProfile = profileIdValueLens.modify(id -&gt; id + 1000, userProfile);
      
        System.out.println("Original profile: " + userProfile);
        System.out.println("Extracted ID value: " + idValue);
        System.out.println("Updated profile: " + updatedProfile);
        System.out.println();
      
        // --- SCENARIO 5: Chaining adaptations ---
        System.out.println("--- Scenario 5: Chaining Adaptations ---");
      
        // Chain multiple adaptations: Employee -&gt; Person -&gt; String (formatted)
        Lens&lt;Employee, String&gt; formattedEmployeeName = 
            PersonLenses.firstName()
                .contramap(Employee::personalInfo)  // Employee -&gt; Person
                .map(name -&gt; "Mr/Ms. " + name.toUpperCase()); // String -&gt; Formatted String
      
        String formalName = formattedEmployeeName.get(employee);
        Employee formalEmployee = formattedEmployeeName.set("Mr/Ms. ROBERT", employee);
      
        System.out.println("Original employee: " + employee);
        System.out.println("Formal name: " + formalName);
        System.out.println("Employee with formal name: " + formalEmployee);
        System.out.println();
      
        // --- SCENARIO 6: Safe adaptations with Optional ---
        System.out.println("--- Scenario 6: Safe Adaptations ---");
      
        // Handle potentially null fields safely
        Lens&lt;Optional&lt;Person&gt;, Optional&lt;String&gt;&gt; safeNameLens = 
            PersonLenses.firstName()
                .map(Optional::of)
                .contramap(optPerson -&gt; optPerson.orElse(new Person("", "", LocalDate.now(), List.of())));
      
        Optional&lt;Person&gt; maybePerson = Optional.of(person);
        Optional&lt;Person&gt; emptyPerson = Optional.empty();
      
        Optional&lt;String&gt; safeName1 = safeNameLens.get(maybePerson);
        Optional&lt;String&gt; safeName2 = safeNameLens.get(emptyPerson);
      
        System.out.println("Safe name from present person: " + safeName1);
        System.out.println("Safe name from empty person: " + safeName2);
    }
}
</code></pre>
<p><strong>Expected Output:</strong></p>
<pre><code>=== PROFUNCTOR OPTICS EXAMPLE ===
--- Scenario 1: contramap (Source Adaptation) ---
Original employee: Employee[id=123, personalInfo=Person[firstName=Alice, lastName=Johnson, birthDate=1985-06-15, hobbies=[reading, cycling, photography]], department=Engineering]
Extracted name: Alice
Renamed employee: Employee[id=123, personalInfo=Person[firstName=Alicia, lastName=Johnson, birthDate=1985-06-15, hobbies=[reading, cycling, photography]], department=Engineering]

--- Scenario 2: map (Target Adaptation) ---
Person: Person[firstName=Alice, lastName=Johnson, birthDate=1985-06-15, hobbies=[reading, cycling, photography]]
Formatted birth date: 1985-06-15

--- Scenario 3: dimap (Both Source and Target Adaptation) ---
Original DTO: PersonDto[fullName=Bob Smith, birthDateString=1990-03-20, interests=[gaming, cooking, travel]]
Extracted interests: [gaming, cooking, travel]
Updated DTO: PersonDto[fullName=Bob Smith, birthDateString=1990-03-20, interests=[GAMING, COOKING, TRAVEL]]

--- Scenario 4: Wrapper Type Integration ---
Original profile: UserProfile[id=UserId[value=456], displayName=Alice J., active=true]
Extracted ID value: 456
Updated profile: UserProfile[id=UserId[value=1456], displayName=Alice J., active=true]

--- Scenario 5: Chaining Adaptations ---
Original employee: Employee[id=123, personalInfo=Person[firstName=Alice, lastName=Johnson, birthDate=1985-06-15, hobbies=[reading, cycling, photography]], department=Engineering]
Formal name: Mr/Ms. ALICE
Employee with formal name: Employee[id=123, personalInfo=Person[firstName=ROBERT, lastName=Johnson, birthDate=1985-06-15, hobbies=[reading, cycling, photography]], department=Engineering]

--- Scenario 6: Safe Adaptations ---
Safe name from present person: Optional[Alice]
Safe name from empty person: Optional[]
</code></pre>
<hr />
<h2 id="integration-with-existing-optics"><a class="header" href="#integration-with-existing-optics">Integration with Existing Optics</a></h2>
<p>Profunctor adaptations work seamlessly with all the optic types and features you've already learned:</p>
<h3 id="with-effectful-updates"><a class="header" href="#with-effectful-updates">With Effectful Updates</a></h3>
<pre><code class="language-java">// Original effectful lens
Lens&lt;Person, String&gt; emailLens = PersonLenses.email();

// Adapt it for Employee and use with validation
Lens&lt;Employee, String&gt; employeeEmailLens = emailLens.contramap(Employee::personalInfo);

// Use with effectful validation as normal
Kind&lt;ValidatedKind.Witness&lt;String&gt;, Employee&gt; result = 
    employeeEmailLens.modifyF(this::validateEmail, employee, validatedApplicative);
</code></pre>
<h3 id="with-deep-composition"><a class="header" href="#with-deep-composition">With Deep Composition</a></h3>
<pre><code class="language-java">// Compose adapted optics just like regular optics
Traversal&lt;EmployeeDto, String&gt; deepPath = 
    apiAdapter.asTraversal()
        .andThen(PersonTraversals.hobbies())
        .andThen(stringProcessor);
</code></pre>
<p>This profunctor capability makes higher-kinded-j optics incredibly flexible and reusable, allowing you to adapt existing, well-tested optics to work with new data formats and requirements without rewriting your core business logic.</p>
<hr />
<p><strong>Previous:</strong> <a href="optics/setters.html">Setters: Composable Write-Only Modifications</a>
<strong>Next:</strong> <a href="optics/composing_optics.html">Capstone Example: Deep Validation</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="optics-iv-java-friendly-apis"><a class="header" href="#optics-iv-java-friendly-apis">Optics IV: Java-Friendly APIs</a></h1>
<blockquote>
<p><em>"There was no particular reason to respect the language of the Establishment."</em></p>
<p>– Norman Mailer, <em>The Armies of the Night</em></p>
</blockquote>
<hr />
<p>Optics originated in Haskell, a language with rather different conventions to Java. Method names like <code>view</code>, <code>over</code>, and <code>preview</code> don't match what Java developers expect, and the parameter ordering (value before source) feels backwards to anyone accustomed to the receiver-first style.</p>
<p>This chapter addresses that gap with three complementary APIs, each suited to different needs.</p>
<hr />
<h2 id="which-api-should-i-use"><a class="header" href="#which-api-should-i-use">Which API Should I Use?</a></h2>
<div id="admonition-start-here" class="admonition admonish-tip" role="note" aria-labelledby="admonition-start-here-title">
<div class="admonition-title">
<div id="admonition-start-here-title">
<p>Start Here</p>
</div>
<a class="admonition-anchor-link" href="optics/ch4_intro.html#admonition-start-here"></a>
</div>
<div>
<p><strong>For most users, the Focus DSL is the recommended starting point.</strong> It provides the most intuitive, IDE-friendly experience for navigating and modifying nested data structures.</p>
</div>
</div>
<pre><code>┌─────────────────────────────────────────────────────────────────────────────┐
│                        CHOOSING YOUR API                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────────┐                                                        │
│  │  Focus DSL      │ ◄─── START HERE                                        │
│  │  (Recommended)  │      Path-based navigation with full type safety       │
│  └────────┬────────┘      CompanyFocus.departments().employees().name()     │
│           │                                                                 │
│           │  Need validation-aware modifications?                           │
│           │  Working with Either/Maybe/Validated?                           │
│           ▼                                                                 │
│  ┌─────────────────┐                                                        │
│  │  Fluent API     │      Static methods + builders for effectful ops       │
│  │  (OpticOps)     │      OpticOps.modifyEither(user, lens, validator)      │
│  └────────┬────────┘                                                        │
│           │                                                                 │
│           │  Need audit trails? Dry-runs? Multiple execution strategies?    │
│           ▼                                                                 │
│  ┌─────────────────┐                                                        │
│  │  Free Monad DSL │      Programs as data, interpreted later               │
│  │  (Advanced)     │      OpticPrograms.get(...).flatMap(...)               │
│  └─────────────────┘                                                        │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<hr />
<h2 id="the-three-apis-at-a-glance"><a class="header" href="#the-three-apis-at-a-glance">The Three APIs at a Glance</a></h2>
<h3 id="focus-dsl-the-primary-api"><a class="header" href="#focus-dsl-the-primary-api">Focus DSL: The Primary API</a></h3>
<p>The Focus DSL provides fluent, path-based navigation that mirrors how you think about your data:</p>
<pre><code class="language-java">// Navigate deeply nested structures with type safety
String city = CompanyFocus.headquarters().city().get(company);

// Modify values at any depth
Company updated = CompanyFocus.departments()
    .employees()
    .salary()
    .modifyAll(s -&gt; s.multiply(1.10), company);
</code></pre>
<p>Use <code>@GenerateFocus</code> on your records to generate path builders automatically. The DSL handles collections (<code>.each()</code>), optionals (<code>.some()</code>), and indexed access (<code>.at(index)</code>) naturally.</p>
<p><strong>Best for:</strong> Day-to-day optic operations, deep navigation, IDE discoverability, learning optics.</p>
<h3 id="fluent-api-validation-and-effects"><a class="header" href="#fluent-api-validation-and-effects">Fluent API: Validation and Effects</a></h3>
<p>The <code>OpticOps</code> class provides static methods and builders for operations that involve validation or effects:</p>
<pre><code class="language-java">// Validation-aware modification with error accumulation
Validated&lt;List&lt;String&gt;, Order&gt; result = OpticOps.modifyAllValidated(
    order,
    orderPricesTraversal,
    price -&gt; validatePrice(price)
);

// Effectful operations with type classes
Kind&lt;CompletableFutureKind.Witness, User&gt; asyncResult = OpticOps.modifyF(
    user, emailLens, this::fetchVerifiedEmail, cfApplicative
);
</code></pre>
<p><strong>Best for:</strong> Validation pipelines, error accumulation, async operations, integration with <code>Either</code>/<code>Maybe</code>/<code>Validated</code>.</p>
<h3 id="free-monad-dsl-programs-as-data"><a class="header" href="#free-monad-dsl-programs-as-data">Free Monad DSL: Programs as Data</a></h3>
<p>The Free Monad DSL separates <em>what</em> from <em>how</em>, letting you build optic programs as data structures that can be interpreted in multiple ways:</p>
<pre><code class="language-java">// Build a program (no execution yet)
Free&lt;OpticOpKind.Witness, Person&gt; program = OpticPrograms
    .get(person, ageLens)
    .flatMap(age -&gt; OpticPrograms.set(person, ageLens, age + 1));

// Choose how to execute
Person result = OpticInterpreters.direct().run(program);      // Production
LoggingInterpreter logger = OpticInterpreters.logging();
Person logged = logger.run(program);                          // With audit trail
</code></pre>
<p><strong>Best for:</strong> Audit trails, dry-runs, testing without side effects, complex conditional workflows.</p>
<hr />
<h2 id="programs-as-data"><a class="header" href="#programs-as-data">Programs as Data</a></h2>
<p>The Free Monad DSL separates <em>what</em> from <em>how</em>:</p>
<pre><code>    ┌─────────────────────────────────────────────────────────┐
    │  PROGRAM (Description)                                  │
    │                                                         │
    │   get(age) ─────► flatMap ─────► set(age + 1)          │
    │                                                         │
    │  A data structure representing operations               │
    │  No side effects yet!                                   │
    └────────────────────────┬────────────────────────────────┘
                             │
                             ▼
    ┌────────────────────────┴────────────────────────────────┐
    │                   INTERPRETERS                          │
    │                                                         │
    │  ┌─────────┐   ┌─────────┐   ┌───────────┐             │
    │  │ Direct  │   │ Logging │   │ Validating│             │
    │  │   Run   │   │  Audit  │   │  Dry-Run  │             │
    │  └────┬────┘   └────┬────┘   └─────┬─────┘             │
    │       │             │              │                    │
    │       ▼             ▼              ▼                    │
    │   Person       Audit Log     Valid/Invalid             │
    └─────────────────────────────────────────────────────────┘
</code></pre>
<p>Same program, different execution strategies.</p>
<hr />
<h2 id="what-youll-learn-6"><a class="header" href="#what-youll-learn-6">What You'll Learn</a></h2>
<div id="admonition-in-this-chapter" class="admonition admonish-info" role="note" aria-labelledby="admonition-in-this-chapter-title">
<div class="admonition-title">
<div id="admonition-in-this-chapter-title">
<p>In This Chapter</p>
</div>
<a class="admonition-anchor-link" href="optics/ch4_intro.html#admonition-in-this-chapter"></a>
</div>
<div>
<ul>
<li><strong>Focus DSL</strong> – The recommended starting point for most users. Navigate nested structures with a fluent, path-based API that provides full IDE autocomplete support.</li>
<li><strong>Fluent API</strong> – When modifications need validation or can fail, the <code>OpticOps</code> class provides builders that integrate with Either, Maybe, and Validated for error handling.</li>
<li><strong>Validation Integration</strong> – Combine optics with functional error types. Validate all fields in a nested structure and accumulate every error, not just the first.</li>
<li><strong>Free Monad DSL</strong> – Describe optic operations as data structures, then interpret them later. Enables dry-runs, audit trails, and testable programs.</li>
<li><strong>Interpreters</strong> – Multiple ways to run the same optic program: direct execution for production, logging for debugging, validation for testing.</li>
</ul>
</div>
</div>
<hr />
<h2 id="chapter-contents-6"><a class="header" href="#chapter-contents-6">Chapter Contents</a></h2>
<ol>
<li><a href="optics/focus_dsl.html">Focus DSL</a> - Path-based navigation with type safety and IDE support</li>
<li><a href="optics/kind_field_support.html">Kind Field Support</a> - Automatic traversal for Kind&lt;F, A&gt; record fields</li>
<li><a href="optics/fluent_api.html">Fluent API</a> - Static methods and builders for validation-aware modifications</li>
<li><a href="optics/free_monad_dsl.html">Free Monad DSL</a> - Building optic programs as composable data</li>
<li><a href="optics/interpreters.html">Interpreters</a> - Multiple execution strategies for the same program</li>
</ol>
<hr />
<p><strong>Next:</strong> <a href="optics/focus_dsl.html">Focus DSL</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="focus-dsl-path-based-optic-syntax"><a class="header" href="#focus-dsl-path-based-optic-syntax">Focus DSL: Path-Based Optic Syntax</a></h1>
<h2 id="type-safe-navigation-through-nested-data"><a class="header" href="#type-safe-navigation-through-nested-data"><em>Type-Safe Navigation Through Nested Data</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="optics/focus_dsl.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to navigate deeply nested data structures with type-safe paths</li>
<li>Using <code>@GenerateFocus</code> to generate path builders automatically</li>
<li><strong>Fluent cross-type navigation</strong> with generated navigators (no <code>.via()</code> needed)</li>
<li>The difference between <code>FocusPath</code>, <code>AffinePath</code>, and <code>TraversalPath</code></li>
<li>Collection navigation with <code>.each()</code>, <code>.at()</code>, <code>.some()</code>, <code>.nullable()</code>, and <code>.traverseOver()</code></li>
<li><strong>Seamless nullable field handling</strong> with <code>@Nullable</code> annotation detection</li>
<li>Type class integration: effectful operations, monoid aggregation, and Traverse support</li>
<li>Working with sum types using <code>instanceOf()</code> and conditional modification with <code>modifyWhen()</code></li>
<li>Composing Focus paths with existing optics</li>
<li>Debugging paths with <code>traced()</code></li>
<li>When to use Focus DSL vs manual lens composition</li>
</ul>
</div>
</div>
<div id="admonition-hands-on-practice" class="admonition admonish-note" role="note" aria-labelledby="admonition-hands-on-practice-title">
<div class="admonition-title">
<div id="admonition-hands-on-practice-title">
<p>Hands On Practice</p>
</div>
<a class="admonition-anchor-link" href="optics/focus_dsl.html#admonition-hands-on-practice"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/optics/Tutorial12_FocusDSL.java">Tutorial12_FocusDSL.java</a> | <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/optics/Tutorial13_AdvancedFocusDSL.java">Tutorial13_AdvancedFocusDSL.java</a></p>
</div>
</div>
<div id="admonition-example-code" class="admonition admonish-note" role="note" aria-labelledby="admonition-example-code-title">
<div class="admonition-title">
<div id="admonition-example-code-title">
<p>Example Code</p>
</div>
<a class="admonition-anchor-link" href="optics/focus_dsl.html#admonition-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/focus/NavigatorExample.java">NavigatorExample</a> | <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/focus/TraverseIntegrationExample.java">TraverseIntegrationExample</a> | <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/focus/ValidationPipelineExample.java">ValidationPipelineExample</a></p>
</div>
</div>
<p>The Focus DSL provides a fluent, path-based syntax for working with optics. Instead of manually composing lenses, prisms, and traversals, you can navigate through your data structures using intuitive method chains that mirror the shape of your data.</p>
<hr />
<h2 id="the-problem-verbose-manual-composition"><a class="header" href="#the-problem-verbose-manual-composition">The Problem: Verbose Manual Composition</a></h2>
<p>When working with deeply nested data structures, manual optic composition becomes verbose:</p>
<pre><code class="language-java">// Manual composition - verbose and repetitive
Lens&lt;Company, String&gt; employeeNameLens =
    CompanyLenses.departments()
        .andThen(DepartmentLenses.employees())
        .andThen(EmployeeLenses.name());

// Must compose at each use site
String name = employeeNameLens.get(company);
</code></pre>
<p>With the Focus DSL, the same operation becomes:</p>
<pre><code class="language-java">// Focus DSL - fluent and intuitive
String name = CompanyFocus.departments().employees().name().get(company);
</code></pre>
<hr />
<h2 id="think-of-focus-paths-like"><a class="header" href="#think-of-focus-paths-like">Think of Focus Paths Like...</a></h2>
<ul>
<li><strong>File system paths</strong>: <code>/company/departments/employees/name</code></li>
<li><strong>JSON pointers</strong>: <code>$.departments[*].employees[*].name</code></li>
<li><strong>XPath expressions</strong>: <code>//department/employee/name</code></li>
<li><strong>IDE navigation</strong>: Click through nested fields with autocomplete</li>
</ul>
<p>The key difference: Focus paths are fully type-safe, with compile-time checking at every step.</p>
<hr />
<h2 id="a-step-by-step-walkthrough-12"><a class="header" href="#a-step-by-step-walkthrough-12">A Step-by-Step Walkthrough</a></h2>
<h3 id="step-1-annotate-your-records"><a class="header" href="#step-1-annotate-your-records">Step 1: Annotate Your Records</a></h3>
<p>Add <code>@GenerateFocus</code> alongside <code>@GenerateLenses</code> to generate path builders:</p>
<pre><code class="language-java">import org.higherkindedj.optics.annotations.GenerateLenses;
import org.higherkindedj.optics.annotations.GenerateFocus;

@GenerateLenses
@GenerateFocus
public record Company(String name, List&lt;Department&gt; departments) {}

@GenerateLenses
@GenerateFocus
public record Department(String name, List&lt;Employee&gt; employees) {}

@GenerateLenses
@GenerateFocus
public record Employee(String name, int age, Optional&lt;String&gt; email) {}
</code></pre>
<h3 id="step-2-use-generated-focus-classes"><a class="header" href="#step-2-use-generated-focus-classes">Step 2: Use Generated Focus Classes</a></h3>
<p>The annotation processor generates companion Focus classes with path builders:</p>
<pre><code class="language-java">// Generated: CompanyFocus.java
// Navigate to company name
FocusPath&lt;Company, String&gt; namePath = CompanyFocus.name();
String companyName = namePath.get(company);

// Navigate through collections
TraversalPath&lt;Company, Department&gt; deptPath = CompanyFocus.departments();
List&lt;Department&gt; allDepts = deptPath.getAll(company);

// Navigate to specific index
AffinePath&lt;Company, Department&gt; firstDeptPath = CompanyFocus.department(0);
Optional&lt;Department&gt; firstDept = firstDeptPath.getOptional(company);
</code></pre>
<h3 id="step-3-chain-navigation-methods"><a class="header" href="#step-3-chain-navigation-methods">Step 3: Chain Navigation Methods</a></h3>
<p>Focus paths support fluent chaining for deep navigation:</p>
<pre><code class="language-java">// Deep path through collections
TraversalPath&lt;Company, String&gt; allEmployeeNames =
    CompanyFocus.departments()     // TraversalPath&lt;Company, Department&gt;
        .employees()               // TraversalPath&lt;Company, Employee&gt;
        .name();                   // TraversalPath&lt;Company, String&gt;

// Get all employee names across all departments
List&lt;String&gt; names = allEmployeeNames.getAll(company);

// Modify all employee names
Company updated = allEmployeeNames.modifyAll(String::toUpperCase, company);
</code></pre>
<hr />
<h2 id="the-three-path-types"><a class="header" href="#the-three-path-types">The Three Path Types</a></h2>
<p>Focus DSL provides three path types, mirroring the optic hierarchy:</p>
<pre><code>         FocusPath&lt;S, A&gt;
        (exactly one focus)
               |
        AffinePath&lt;S, A&gt;
      (zero or one focus)
               |
      TraversalPath&lt;S, A&gt;
      (zero or more focus)
</code></pre>
<h3 id="focuspath-exactly-one-element"><a class="header" href="#focuspath-exactly-one-element">FocusPath: Exactly One Element</a></h3>
<p><code>FocusPath&lt;S, A&gt;</code> wraps a <code>Lens&lt;S, A&gt;</code> and guarantees exactly one focused element:</p>
<pre><code class="language-java">// Always succeeds - the field always exists
FocusPath&lt;Employee, String&gt; namePath = EmployeeFocus.name();

String name = namePath.get(employee);           // Always returns a value
Employee updated = namePath.set("Bob", employee);  // Always succeeds
Employee modified = namePath.modify(String::toUpperCase, employee);
</code></pre>
<p><strong>Key Operations:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Return Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>get(S)</code></td><td><code>A</code></td><td>Extract the focused value</td></tr>
<tr><td><code>set(A, S)</code></td><td><code>S</code></td><td>Replace the focused value</td></tr>
<tr><td><code>modify(Function&lt;A,A&gt;, S)</code></td><td><code>S</code></td><td>Transform the focused value</td></tr>
<tr><td><code>toLens()</code></td><td><code>Lens&lt;S, A&gt;</code></td><td>Extract underlying optic</td></tr>
</tbody></table>
</div>
<h3 id="affinepath-zero-or-one-element"><a class="header" href="#affinepath-zero-or-one-element">AffinePath: Zero or One Element</a></h3>
<p><code>AffinePath&lt;S, A&gt;</code> wraps an <code>Affine&lt;S, A&gt;</code> for optional access:</p>
<pre><code class="language-java">// May or may not have a value
AffinePath&lt;Employee, String&gt; emailPath = EmployeeFocus.email();

Optional&lt;String&gt; email = emailPath.getOptional(employee);  // May be empty
Employee updated = emailPath.set("new@email.com", employee);  // Always succeeds
Employee modified = emailPath.modify(String::toLowerCase, employee);  // No-op if absent
</code></pre>
<p><strong>Key Operations:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Return Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>getOptional(S)</code></td><td><code>Optional&lt;A&gt;</code></td><td>Extract if present</td></tr>
<tr><td><code>set(A, S)</code></td><td><code>S</code></td><td>Replace (creates if structure allows)</td></tr>
<tr><td><code>modify(Function&lt;A,A&gt;, S)</code></td><td><code>S</code></td><td>Transform if present</td></tr>
<tr><td><code>matches(S)</code></td><td><code>boolean</code></td><td>Check if value exists</td></tr>
<tr><td><code>toAffine()</code></td><td><code>Affine&lt;S, A&gt;</code></td><td>Extract underlying optic</td></tr>
</tbody></table>
</div>
<h3 id="traversalpath-zero-or-more-elements"><a class="header" href="#traversalpath-zero-or-more-elements">TraversalPath: Zero or More Elements</a></h3>
<p><code>TraversalPath&lt;S, A&gt;</code> wraps a <code>Traversal&lt;S, A&gt;</code> for collection access:</p>
<pre><code class="language-java">// Focuses on multiple elements
TraversalPath&lt;Department, Employee&gt; employeesPath = DepartmentFocus.employees();

List&lt;Employee&gt; all = employeesPath.getAll(department);    // All employees
Department updated = employeesPath.setAll(defaultEmployee, department);
Department modified = employeesPath.modifyAll(e -&gt; promote(e), department);
</code></pre>
<p><strong>Key Operations:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Return Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>getAll(S)</code></td><td><code>List&lt;A&gt;</code></td><td>Extract all focused values</td></tr>
<tr><td><code>setAll(A, S)</code></td><td><code>S</code></td><td>Replace all focused values</td></tr>
<tr><td><code>modifyAll(Function&lt;A,A&gt;, S)</code></td><td><code>S</code></td><td>Transform all focused values</td></tr>
<tr><td><code>filter(Predicate&lt;A&gt;)</code></td><td><code>TraversalPath&lt;S, A&gt;</code></td><td>Filter focused elements</td></tr>
<tr><td><code>toTraversal()</code></td><td><code>Traversal&lt;S, A&gt;</code></td><td>Extract underlying optic</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="collection-navigation"><a class="header" href="#collection-navigation">Collection Navigation</a></h2>
<p>The Focus DSL provides intuitive methods for navigating collections:</p>
<h3 id="each---traverse-all-elements"><a class="header" href="#each---traverse-all-elements"><code>.each()</code> - Traverse All Elements</a></h3>
<p>Converts a collection field to a traversal over its elements:</p>
<pre><code class="language-java">// List&lt;Department&gt; -&gt; traversal over Department
TraversalPath&lt;Company, Department&gt; allDepts = CompanyFocus.departments();

// Equivalent to calling .each() on a FocusPath to List&lt;T&gt;
</code></pre>
<h3 id="atindex---access-by-index"><a class="header" href="#atindex---access-by-index"><code>.at(index)</code> - Access by Index</a></h3>
<p>Focuses on a single element at a specific index:</p>
<pre><code class="language-java">// Focus on first department
AffinePath&lt;Company, Department&gt; firstDept = CompanyFocus.department(0);

// Focus on third employee in second department
AffinePath&lt;Company, Employee&gt; specificEmployee =
    CompanyFocus.department(1).employee(2);

// Returns empty if index out of bounds
Optional&lt;Department&gt; maybe = firstDept.getOptional(emptyCompany);
</code></pre>
<h3 id="atkeykey---access-map-values"><a class="header" href="#atkeykey---access-map-values"><code>.atKey(key)</code> - Access Map Values</a></h3>
<p>For <code>Map&lt;K, V&gt;</code> fields, access values by key:</p>
<pre><code class="language-java">@GenerateLenses
@GenerateFocus
record Config(Map&lt;String, Setting&gt; settings) {}

// Focus on specific setting
AffinePath&lt;Config, Setting&gt; dbSetting = ConfigFocus.setting("database");

Optional&lt;Setting&gt; setting = dbSetting.getOptional(config);
</code></pre>
<h3 id="some---unwrap-optional"><a class="header" href="#some---unwrap-optional"><code>.some()</code> - Unwrap Optional</a></h3>
<p>For <code>Optional&lt;T&gt;</code> fields, unwrap to the inner value:</p>
<pre><code class="language-java">// Email is Optional&lt;String&gt;
AffinePath&lt;Employee, String&gt; emailPath = EmployeeFocus.email();

// Internally uses .some() to unwrap the Optional
Optional&lt;String&gt; email = emailPath.getOptional(employee);
</code></pre>
<h3 id="nullable---handle-null-values"><a class="header" href="#nullable---handle-null-values"><code>.nullable()</code> - Handle Null Values</a></h3>
<p>For fields that may be null, use <code>.nullable()</code> to treat null as absent:</p>
<pre><code class="language-java">record LegacyUser(String name, @Nullable String nickname) {}

// If @Nullable is detected, the processor generates this automatically
// Otherwise, chain with .nullable() manually:
FocusPath&lt;LegacyUser, String&gt; rawPath = LegacyUserFocus.nickname();
AffinePath&lt;LegacyUser, String&gt; safePath = rawPath.nullable();

// Null is treated as absent (empty Optional)
LegacyUser user = new LegacyUser("Alice", null);
Optional&lt;String&gt; result = safePath.getOptional(user);  // Optional.empty()

// Non-null values work normally
LegacyUser withNick = new LegacyUser("Bob", "Bobby");
Optional&lt;String&gt; present = safePath.getOptional(withNick);  // Optional.of("Bobby")
</code></pre>
<div id="admonition-automatic-nullable-detection" class="admonition admonish-tip" role="note" aria-labelledby="admonition-automatic-nullable-detection-title">
<div class="admonition-title">
<div id="admonition-automatic-nullable-detection-title">
<p>Automatic @Nullable Detection</p>
</div>
<a class="admonition-anchor-link" href="optics/focus_dsl.html#admonition-automatic-nullable-detection"></a>
</div>
<div>
<p>When a field is annotated with <code>@Nullable</code> (from JSpecify, JSR-305, JetBrains, etc.), the <code>@GenerateFocus</code> processor automatically generates an <code>AffinePath</code> with <code>.nullable()</code> applied. No manual chaining required.</p>
</div>
</div>
<hr />
<h2 id="composition-with-existing-optics"><a class="header" href="#composition-with-existing-optics">Composition with Existing Optics</a></h2>
<p>Focus paths compose seamlessly with existing optics using <code>.via()</code>:</p>
<h3 id="path--lens--path-or-affine"><a class="header" href="#path--lens--path-or-affine">Path + Lens = Path (or Affine)</a></h3>
<pre><code class="language-java">// Existing lens for a computed property
Lens&lt;Employee, String&gt; fullNameLens = Lens.of(
    e -&gt; e.firstName() + " " + e.lastName(),
    (e, name) -&gt; { /* setter logic */ }
);

// Compose Focus path with existing lens
FocusPath&lt;Department, String&gt; employeeFullName =
    DepartmentFocus.manager().via(fullNameLens);
</code></pre>
<h3 id="path--prism--affinepath"><a class="header" href="#path--prism--affinepath">Path + Prism = AffinePath</a></h3>
<pre><code class="language-java">// Prism for sealed interface variant
Prism&lt;Shape, Circle&gt; circlePrism = ShapePrisms.circle();

// Compose to get AffinePath
AffinePath&lt;Drawing, Circle&gt; firstCircle =
    DrawingFocus.shape(0).via(circlePrism);
</code></pre>
<h3 id="path--traversal--traversalpath"><a class="header" href="#path--traversal--traversalpath">Path + Traversal = TraversalPath</a></h3>
<pre><code class="language-java">// Custom traversal
Traversal&lt;String, Character&gt; charsTraversal = StringTraversals.chars();

// Compose for character-level access
TraversalPath&lt;Employee, Character&gt; nameChars =
    EmployeeFocus.name().via(charsTraversal);
</code></pre>
<hr />
<h2 id="fluent-navigation-with-generated-navigators"><a class="header" href="#fluent-navigation-with-generated-navigators">Fluent Navigation with Generated Navigators</a></h2>
<div id="admonition-zero-boilerplate-cross-type-navigation" class="admonition admonish-tip" role="note" aria-labelledby="admonition-zero-boilerplate-cross-type-navigation-title">
<div class="admonition-title">
<div id="admonition-zero-boilerplate-cross-type-navigation-title">
<p>Zero-Boilerplate Cross-Type Navigation</p>
</div>
<a class="admonition-anchor-link" href="optics/focus_dsl.html#admonition-zero-boilerplate-cross-type-navigation"></a>
</div>
<div>
<p>When navigating across multiple record types, the standard approach requires explicit <code>.via()</code> calls at each boundary. Generated navigators eliminate this boilerplate, enabling chains like <code>CompanyFocus.headquarters().city()</code> directly.</p>
</div>
</div>
<h3 id="the-problem-explicit-composition"><a class="header" href="#the-problem-explicit-composition">The Problem: Explicit Composition</a></h3>
<p>Without navigators, cross-type navigation requires <code>.via()</code> at each type boundary:</p>
<pre><code class="language-java">// Without navigators - explicit .via() at each step
String city = CompanyFocus.headquarters()
    .via(AddressFocus.city().toLens())
    .get(company);

// Deep navigation becomes verbose
String managerCity = CompanyFocus.departments()
    .each()
    .via(DepartmentFocus.manager().toLens())
    .via(PersonFocus.address().toLens())
    .via(AddressFocus.city().toLens())
    .get(company);
</code></pre>
<h3 id="the-solution-generated-navigators"><a class="header" href="#the-solution-generated-navigators">The Solution: Generated Navigators</a></h3>
<p>Enable navigator generation with <code>generateNavigators = true</code>:</p>
<pre><code class="language-java">@GenerateFocus(generateNavigators = true)
record Company(String name, Address headquarters) {}

@GenerateFocus(generateNavigators = true)
record Address(String street, String city) {}

// With navigators - fluent chaining
String city = CompanyFocus.headquarters().city().get(company);

// Navigators chain naturally
Company updated = CompanyFocus.headquarters().city()
    .modify(String::toUpperCase, company);
</code></pre>
<h3 id="how-navigators-work"><a class="header" href="#how-navigators-work">How Navigators Work</a></h3>
<p>When <code>generateNavigators = true</code>, the processor generates navigator wrapper classes for fields whose types are also annotated with <code>@GenerateFocus</code>. The generated code looks like:</p>
<pre><code class="language-java">// Generated in CompanyFocus.java
public static HeadquartersNavigator&lt;Company&gt; headquarters() {
    return new HeadquartersNavigator&lt;&gt;(
        FocusPath.of(Lens.of(Company::headquarters, ...))
    );
}

// Generated inner class
public static final class HeadquartersNavigator&lt;S&gt; {
    private final FocusPath&lt;S, Address&gt; delegate;

    // Delegate methods - same as FocusPath
    public Address get(S source) { return delegate.get(source); }
    public S set(Address value, S source) { return delegate.set(value, source); }
    public S modify(Function&lt;Address, Address&gt; f, S source) { ... }

    // Navigation methods for Address fields
    public FocusPath&lt;S, String&gt; street() {
        return delegate.via(AddressFocus.street().toLens());
    }

    public FocusPath&lt;S, String&gt; city() {
        return delegate.via(AddressFocus.city().toLens());
    }

    // Access underlying path
    public FocusPath&lt;S, Address&gt; toPath() { return delegate; }
}
</code></pre>
<h3 id="path-type-widening"><a class="header" href="#path-type-widening">Path Type Widening</a></h3>
<p>Navigators automatically widen path types when navigating through optional or collection fields:</p>
<div class="table-wrapper"><table><thead><tr><th>Source Field Type</th><th>Navigator Returns</th></tr></thead><tbody>
<tr><td>Regular field (<code>Address address</code>)</td><td><code>FocusPath</code> methods</td></tr>
<tr><td>Optional field (<code>Optional&lt;Address&gt;</code>)</td><td><code>AffinePath</code> methods</td></tr>
<tr><td>Collection field (<code>List&lt;Address&gt;</code>)</td><td><code>TraversalPath</code> methods</td></tr>
</tbody></table>
</div>
<pre><code class="language-java">@GenerateFocus(generateNavigators = true)
record User(String name, Optional&lt;Address&gt; homeAddress, List&lt;Address&gt; workAddresses) {}

// homeAddress navigator methods return AffinePath
Optional&lt;String&gt; homeCity = UserFocus.homeAddress().city().getOptional(user);

// workAddresses navigator methods return TraversalPath
List&lt;String&gt; workCities = UserFocus.workAddresses().city().getAll(user);
</code></pre>
<h3 id="controlling-navigator-generation"><a class="header" href="#controlling-navigator-generation">Controlling Navigator Generation</a></h3>
<h4 id="depth-limiting"><a class="header" href="#depth-limiting">Depth Limiting</a></h4>
<p>Prevent excessive code generation for deeply nested structures:</p>
<pre><code class="language-java">@GenerateFocus(generateNavigators = true, maxNavigatorDepth = 2)
record Root(Level1 child) {}

// Depth 1: child() returns Level1Navigator
// Depth 2: child().nested() returns FocusPath (not a navigator)
// Beyond depth 2: use .via() for further navigation

FocusPath&lt;Root, String&gt; deepPath = RootFocus.child().nested()
    .via(Level3Focus.value().toLens());
</code></pre>
<h4 id="field-filtering"><a class="header" href="#field-filtering">Field Filtering</a></h4>
<p>Include only specific fields in navigator generation:</p>
<pre><code class="language-java">@GenerateFocus(generateNavigators = true, includeFields = {"primary"})
record MultiAddress(Address primary, Address secondary, Address backup) {}

// primary() returns navigator with navigation methods
// secondary() and backup() return standard FocusPath&lt;MultiAddress, Address&gt;
</code></pre>
<p>Or exclude specific fields:</p>
<pre><code class="language-java">@GenerateFocus(generateNavigators = true, excludeFields = {"internal"})
record Config(Settings user, Settings internal) {}

// user() returns navigator
// internal() returns standard FocusPath (no nested navigation)
</code></pre>
<h3 id="when-to-use-navigators"><a class="header" href="#when-to-use-navigators">When to Use Navigators</a></h3>
<p><strong>Enable navigators when:</strong></p>
<ul>
<li>Navigating across multiple record types frequently</li>
<li>Deep navigation is common in your codebase</li>
<li>You want IDE autocomplete for nested fields</li>
<li>Teaching or onboarding developers</li>
</ul>
<p><strong>Keep navigators disabled when:</strong></p>
<ul>
<li>Fields reference third-party types (not annotated with <code>@GenerateFocus</code>)</li>
<li>You need minimal generated code footprint</li>
<li>The project has shallow data structures</li>
</ul>
<h3 id="combining-navigators-with-other-features"><a class="header" href="#combining-navigators-with-other-features">Combining Navigators with Other Features</a></h3>
<p>Navigators work seamlessly with all Focus DSL features:</p>
<pre><code class="language-java">// With type class operations
Company validated = CompanyFocus.headquarters().city()
    .modifyF(this::validateCity, company, EitherMonad.INSTANCE);

// With conditional modification
Company updated = CompanyFocus.departments()
    .each()
    .modifyWhen(d -&gt; d.name().equals("Engineering"), this::promote, company);

// With tracing for debugging
FocusPath&lt;Company, String&gt; traced = CompanyFocus.headquarters().city()
    .traced((company, city) -&gt; System.out.println("City: " + city));
</code></pre>
<hr />
<h2 id="type-class-integration"><a class="header" href="#type-class-integration">Type Class Integration</a></h2>
<p>The Focus DSL integrates deeply with higher-kinded-j type classes, enabling effectful operations, monoid-based aggregation, and generic collection traversal.</p>
<h3 id="effectful-modification-with-modifyf"><a class="header" href="#effectful-modification-with-modifyf">Effectful Modification with <code>modifyF()</code></a></h3>
<p>All path types support <code>modifyF()</code> for effectful transformations:</p>
<pre><code class="language-java">// Validation - accumulate all errors
Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, User&gt; result = userPath.modifyF(
    email -&gt; EmailValidator.validate(email),
    user,
    ValidatedApplicative.instance()
);

// Async updates with CompletableFuture
Kind&lt;CompletableFutureKind.Witness, Config&gt; asyncResult = configPath.modifyF(
    key -&gt; fetchNewApiKey(key),  // Returns CompletableFuture
    config,
    CompletableFutureApplicative.INSTANCE
);

// IO operations
Kind&lt;IOKind.Witness, User&gt; ioResult = userPath.modifyF(
    name -&gt; IO.of(() -&gt; readFromDatabase(name)),
    user,
    IOMonad.INSTANCE
);
</code></pre>
<h3 id="monoid-based-aggregation-with-foldmap"><a class="header" href="#monoid-based-aggregation-with-foldmap">Monoid-Based Aggregation with <code>foldMap()</code></a></h3>
<p><code>TraversalPath</code> supports <code>foldMap()</code> for aggregating values:</p>
<pre><code class="language-java">// Sum all salaries using integer addition monoid
int totalSalary = employeesPath.foldMap(
    Monoids.integerAddition(),
    Employee::salary,
    company
);

// Concatenate all names
String allNames = employeesPath.foldMap(
    Monoids.string(),
    Employee::name,
    company
);

// Custom monoid for set union
Set&lt;String&gt; allSkills = employeesPath.foldMap(
    Monoids.set(),
    e -&gt; e.skills(),
    company
);
</code></pre>
<h3 id="generic-collection-traversal-with-traverseover"><a class="header" href="#generic-collection-traversal-with-traverseover">Generic Collection Traversal with <code>traverseOver()</code></a></h3>
<p>When working with collections wrapped in <code>Kind&lt;F, A&gt;</code>, use <code>traverseOver()</code> with a <code>Traverse</code> instance:</p>
<pre><code class="language-java">// Given a field with Kind&lt;ListKind.Witness, Role&gt; type
FocusPath&lt;User, Kind&lt;ListKind.Witness, Role&gt;&gt; rolesPath = UserFocus.roles();

// Traverse into the collection
TraversalPath&lt;User, Role&gt; allRoles =
    rolesPath.&lt;ListKind.Witness, Role&gt;traverseOver(ListTraverse.INSTANCE);

// Now operate on individual roles
List&lt;Role&gt; roles = allRoles.getAll(user);
User updated = allRoles.modifyAll(Role::promote, user);
</code></pre>
<p><strong>When to use <code>traverseOver()</code> vs <code>each()</code>:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Use Case</th></tr></thead><tbody>
<tr><td><code>each()</code></td><td>Standard <code>List&lt;T&gt;</code> or <code>Set&lt;T&gt;</code> fields</td></tr>
<tr><td><code>traverseOver()</code></td><td><code>Kind&lt;F, T&gt;</code> fields with custom Traverse</td></tr>
</tbody></table>
</div>
<pre><code class="language-java">// For List&lt;T&gt; - use each()
TraversalPath&lt;Team, User&gt; members = TeamFocus.membersList().each();

// For Kind&lt;ListKind.Witness, T&gt; - use traverseOver()
TraversalPath&lt;Team, User&gt; members = TeamFocus.membersKind()
    .&lt;ListKind.Witness, User&gt;traverseOver(ListTraverse.INSTANCE);
</code></pre>
<h3 id="conditional-modification-with-modifywhen"><a class="header" href="#conditional-modification-with-modifywhen">Conditional Modification with <code>modifyWhen()</code></a></h3>
<p>Modify only elements that match a predicate:</p>
<pre><code class="language-java">// Give raises only to senior employees
Company updated = CompanyFocus.employees()
    .modifyWhen(
        e -&gt; e.yearsOfService() &gt; 5,
        e -&gt; e.withSalary(e.salary().multiply(1.10)),
        company
    );

// Enable only premium features
Config updated = ConfigFocus.features()
    .modifyWhen(
        f -&gt; f.tier() == Tier.PREMIUM,
        Feature::enable,
        config
    );
</code></pre>
<h3 id="working-with-sum-types-using-instanceof"><a class="header" href="#working-with-sum-types-using-instanceof">Working with Sum Types using <code>instanceOf()</code></a></h3>
<p>Focus on specific variants of sealed interfaces:</p>
<pre><code class="language-java">sealed interface Shape permits Circle, Rectangle, Triangle {}

// Focus on circles only
AffinePath&lt;Shape, Circle&gt; circlePath = AffinePath.instanceOf(Circle.class);

// Compose with other paths
TraversalPath&lt;Drawing, Double&gt; circleRadii =
    DrawingFocus.shapes()
        .via(AffinePath.instanceOf(Circle.class))
        .via(CircleFocus.radius());

// Modify only circles
Drawing updated = DrawingFocus.shapes()
    .via(AffinePath.instanceOf(Circle.class))
    .modifyAll(c -&gt; c.withRadius(c.radius() * 2), drawing);
</code></pre>
<h3 id="path-debugging-with-traced"><a class="header" href="#path-debugging-with-traced">Path Debugging with <code>traced()</code></a></h3>
<p>Debug complex path navigation by observing values:</p>
<pre><code class="language-java">// Add tracing to see what values are accessed
FocusPath&lt;Company, String&gt; debugPath = CompanyFocus.ceo().name()
    .traced((company, name) -&gt;
        System.out.println("Accessing CEO name: " + name + " from " + company.name()));

// Every get() call now logs the accessed value
String name = debugPath.get(company);

// For TraversalPath, observe all values
TraversalPath&lt;Company, Employee&gt; tracedEmployees = CompanyFocus.employees()
    .traced((company, employees) -&gt;
        System.out.println("Found " + employees.size() + " employees"));
</code></pre>
<hr />
<h2 id="bridging-to-effect-paths"><a class="header" href="#bridging-to-effect-paths">Bridging to Effect Paths</a></h2>
<p>Focus paths and Effect paths share the same <code>via</code> composition operator but navigate different
domains. The bridge API enables seamless transitions between them.</p>
<pre><code>                    FOCUS-EFFECT BRIDGE

    ┌─────────────────────────────────────────────────────┐
    │                   Optics Domain                      │
    │  FocusPath&lt;S, A&gt; ──────────────────────────────────  │
    │  AffinePath&lt;S, A&gt; ──────────────────────────────────│
    │  TraversalPath&lt;S, A&gt; ───────────────────────────────│
    └──────────────────────────┬──────────────────────────┘
                               │
                               │ toMaybePath(source)
                               │ toEitherPath(source, error)
                               │ toTryPath(source, supplier)
                               ▼
    ┌─────────────────────────────────────────────────────┐
    │                   Effects Domain                     │
    │  MaybePath&lt;A&gt; ──────────────────────────────────────│
    │  EitherPath&lt;E, A&gt; ──────────────────────────────────│
    │  TryPath&lt;A&gt; ────────────────────────────────────────│
    │  IOPath&lt;A&gt; ─────────────────────────────────────────│
    │  ValidationPath&lt;E, A&gt; ──────────────────────────────│
    └──────────────────────────┬──────────────────────────┘
                               │
                               │ focus(FocusPath)
                               │ focus(AffinePath, error)
                               ▼
    ┌─────────────────────────────────────────────────────┐
    │           Back to Optics (within effect)             │
    │  EffectPath&lt;B&gt; ─────────────────────────────────────│
    └─────────────────────────────────────────────────────┘
</code></pre>
<h3 id="direction-1-focuspath--effectpath"><a class="header" href="#direction-1-focuspath--effectpath">Direction 1: FocusPath → EffectPath</a></h3>
<p>Extract a value using optics and wrap it in an effect for further processing:</p>
<pre><code class="language-java">// FocusPath always has a value, so these always succeed
FocusPath&lt;User, String&gt; namePath = UserFocus.name();
MaybePath&lt;String&gt; maybeName = namePath.toMaybePath(user);          // → Just(name)
EitherPath&lt;E, String&gt; eitherName = namePath.toEitherPath(user);    // → Right(name)
TryPath&lt;String&gt; tryName = namePath.toTryPath(user);                // → Success(name)

// AffinePath may not have a value
AffinePath&lt;User, String&gt; emailPath = UserFocus.email();  // Optional&lt;String&gt; → String
MaybePath&lt;String&gt; maybeEmail = emailPath.toMaybePath(user);        // → Just or Nothing
EitherPath&lt;String, String&gt; eitherEmail =
    emailPath.toEitherPath(user, "Email not configured");          // → Right or Left
</code></pre>
<p><strong>Bridge Methods on FocusPath:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Return Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>toMaybePath(S)</code></td><td><code>MaybePath&lt;A&gt;</code></td><td>Always <code>Just(value)</code></td></tr>
<tr><td><code>toEitherPath(S)</code></td><td><code>EitherPath&lt;E, A&gt;</code></td><td>Always <code>Right(value)</code></td></tr>
<tr><td><code>toTryPath(S)</code></td><td><code>TryPath&lt;A&gt;</code></td><td>Always <code>Success(value)</code></td></tr>
<tr><td><code>toIdPath(S)</code></td><td><code>IdPath&lt;A&gt;</code></td><td>Trivial effect wrapper</td></tr>
</tbody></table>
</div>
<p><strong>Bridge Methods on AffinePath:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Return Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>toMaybePath(S)</code></td><td><code>MaybePath&lt;A&gt;</code></td><td><code>Just</code> if present, <code>Nothing</code> otherwise</td></tr>
<tr><td><code>toEitherPath(S, E)</code></td><td><code>EitherPath&lt;E, A&gt;</code></td><td><code>Right</code> if present, <code>Left(error)</code> otherwise</td></tr>
<tr><td><code>toTryPath(S, Supplier&lt;Throwable&gt;)</code></td><td><code>TryPath&lt;A&gt;</code></td><td><code>Success</code> or <code>Failure</code></td></tr>
<tr><td><code>toOptionalPath(S)</code></td><td><code>OptionalPath&lt;A&gt;</code></td><td>Wraps in Java <code>Optional</code> effect</td></tr>
</tbody></table>
</div>
<p><strong>Bridge Methods on TraversalPath:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Return Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>toListPath(S)</code></td><td><code>ListPath&lt;A&gt;</code></td><td>All focused values as list</td></tr>
<tr><td><code>toStreamPath(S)</code></td><td><code>StreamPath&lt;A&gt;</code></td><td>Lazy stream of values</td></tr>
<tr><td><code>toMaybePath(S)</code></td><td><code>MaybePath&lt;A&gt;</code></td><td>First value if any</td></tr>
</tbody></table>
</div>
<h3 id="direction-2-effectpathfocus"><a class="header" href="#direction-2-effectpathfocus">Direction 2: EffectPath.focus()</a></h3>
<p>Apply structural navigation inside an effect context:</p>
<pre><code class="language-java">// Start with an effect containing a complex structure
EitherPath&lt;Error, User&gt; userPath = Path.right(user);

// Navigate within the effect using optics
EitherPath&lt;Error, String&gt; namePath = userPath.focus(UserFocus.name());

// AffinePath requires an error for the absent case
EitherPath&lt;Error, String&gt; emailPath =
    userPath.focus(UserFocus.email(), new Error("Email required"));
</code></pre>
<p><strong>focus() Method Signatures:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Effect Type</th><th>FocusPath Signature</th><th>AffinePath Signature</th></tr></thead><tbody>
<tr><td><code>MaybePath&lt;A&gt;</code></td><td><code>focus(FocusPath&lt;A, B&gt;)</code> → <code>MaybePath&lt;B&gt;</code></td><td><code>focus(AffinePath&lt;A, B&gt;)</code> → <code>MaybePath&lt;B&gt;</code></td></tr>
<tr><td><code>EitherPath&lt;E, A&gt;</code></td><td><code>focus(FocusPath&lt;A, B&gt;)</code> → <code>EitherPath&lt;E, B&gt;</code></td><td><code>focus(AffinePath&lt;A, B&gt;, E)</code> → <code>EitherPath&lt;E, B&gt;</code></td></tr>
<tr><td><code>TryPath&lt;A&gt;</code></td><td><code>focus(FocusPath&lt;A, B&gt;)</code> → <code>TryPath&lt;B&gt;</code></td><td><code>focus(AffinePath&lt;A, B&gt;, Supplier&lt;Throwable&gt;)</code> → <code>TryPath&lt;B&gt;</code></td></tr>
<tr><td><code>IOPath&lt;A&gt;</code></td><td><code>focus(FocusPath&lt;A, B&gt;)</code> → <code>IOPath&lt;B&gt;</code></td><td><code>focus(AffinePath&lt;A, B&gt;, Supplier&lt;RuntimeException&gt;)</code> → <code>IOPath&lt;B&gt;</code></td></tr>
<tr><td><code>ValidationPath&lt;E, A&gt;</code></td><td><code>focus(FocusPath&lt;A, B&gt;)</code> → <code>ValidationPath&lt;E, B&gt;</code></td><td><code>focus(AffinePath&lt;A, B&gt;, E)</code> → <code>ValidationPath&lt;E, B&gt;</code></td></tr>
<tr><td><code>IdPath&lt;A&gt;</code></td><td><code>focus(FocusPath&lt;A, B&gt;)</code> → <code>IdPath&lt;B&gt;</code></td><td><code>focus(AffinePath&lt;A, B&gt;)</code> → <code>MaybePath&lt;B&gt;</code></td></tr>
</tbody></table>
</div>
<h3 id="when-to-use-each-direction"><a class="header" href="#when-to-use-each-direction">When to Use Each Direction</a></h3>
<p><strong>Use FocusPath → EffectPath when:</strong></p>
<ul>
<li>You have data and want to start an effect pipeline</li>
<li>Extracting values that need validation or async processing</li>
<li>Converting optic results into monadic workflows</li>
</ul>
<pre><code class="language-java">// Extract and validate
EitherPath&lt;ValidationError, String&gt; validated =
    UserFocus.email()
        .toEitherPath(user, new ValidationError("Email required"))
        .via(email -&gt; validateEmailFormat(email));
</code></pre>
<p><strong>Use EffectPath.focus() when:</strong></p>
<ul>
<li>You're already in an effect context (e.g., after a service call)</li>
<li>Drilling down into effect results</li>
<li>Building validation pipelines that extract and check nested fields</li>
</ul>
<pre><code class="language-java">// Service returns effect, then navigate
EitherPath&lt;Error, Order&gt; orderResult = orderService.findById(orderId);
EitherPath&lt;Error, String&gt; customerName =
    orderResult
        .focus(OrderFocus.customer())
        .focus(CustomerFocus.name());
</code></pre>
<h3 id="practical-example-validation-pipeline"><a class="header" href="#practical-example-validation-pipeline">Practical Example: Validation Pipeline</a></h3>
<p>Combining both directions for a complete validation workflow:</p>
<pre><code class="language-java">// Domain model
record RegistrationForm(String username, Optional&lt;String&gt; email, Address address) {}
record Address(String street, Optional&lt;String&gt; postcode) {}

// Validation using Focus-Effect bridge
EitherPath&lt;List&lt;String&gt;, RegistrationForm&gt; validateForm(RegistrationForm form) {
    var formPath = Path.&lt;List&lt;String&gt;, RegistrationForm&gt;right(form);

    // Validate username (always present)
    var usernameValid = formPath
        .focus(FormFocus.username())
        .via(name -&gt; name.length() &gt;= 3
            ? Path.right(name)
            : Path.left(List.of("Username too short")));

    // Validate email if present
    var emailValid = formPath
        .focus(FormFocus.email(), List.of("Email required for notifications"))
        .via(email -&gt; email.contains("@")
            ? Path.right(email)
            : Path.left(List.of("Invalid email format")));

    // Combine validations
    return usernameValid.via(u -&gt; emailValid.map(e -&gt; form));
}
</code></pre>
<div id="admonition-see-also" class="admonition admonish-tip" role="note" aria-labelledby="admonition-see-also-title">
<div class="admonition-title">
<div id="admonition-see-also-title">
<p>See Also</p>
</div>
<a class="admonition-anchor-link" href="optics/focus_dsl.html#admonition-see-also"></a>
</div>
<div>
<ul>
<li><a href="optics/../effect/effect_path_overview.html">Effect Path Overview</a> - Railway model and effect composition</li>
<li><a href="optics/../effect/focus_integration.html">Focus-Effect Integration</a> - Complete bridging guide</li>
<li><a href="optics/../effect/capabilities.html">Capability Interfaces</a> - Powers behind effect operations</li>
</ul>
</div>
</div>
<hr />
<h2 id="generated-class-structure"><a class="header" href="#generated-class-structure">Generated Class Structure</a></h2>
<p>For a record like:</p>
<pre><code class="language-java">@GenerateLenses
@GenerateFocus
record Employee(
    String name,
    int age,
    Optional&lt;String&gt; email,
    @Nullable String nickname,
    List&lt;Skill&gt; skills
) {}
</code></pre>
<p>The processor generates:</p>
<pre><code class="language-java">@Generated
public final class EmployeeFocus {
    private EmployeeFocus() {}

    // Required fields -&gt; FocusPath
    public static FocusPath&lt;Employee, String&gt; name() {
        return FocusPath.of(EmployeeLenses.name());
    }

    public static FocusPath&lt;Employee, Integer&gt; age() {
        return FocusPath.of(EmployeeLenses.age());
    }

    // Optional&lt;T&gt; field -&gt; AffinePath (automatically unwraps with .some())
    public static AffinePath&lt;Employee, String&gt; email() {
        return FocusPath.of(EmployeeLenses.email()).some();
    }

    // @Nullable field -&gt; AffinePath (automatically handles null with .nullable())
    public static AffinePath&lt;Employee, String&gt; nickname() {
        return FocusPath.of(EmployeeLenses.nickname()).nullable();
    }

    // List&lt;T&gt; field -&gt; TraversalPath (traverses elements)
    public static TraversalPath&lt;Employee, Skill&gt; skills() {
        return FocusPath.of(EmployeeLenses.skills()).each();
    }

    // Indexed access to List&lt;T&gt; -&gt; AffinePath
    public static AffinePath&lt;Employee, Skill&gt; skill(int index) {
        return FocusPath.of(EmployeeLenses.skills()).at(index);
    }
}
</code></pre>
<hr />
<h2 id="integration-with-free-monad-dsl"><a class="header" href="#integration-with-free-monad-dsl">Integration with Free Monad DSL</a></h2>
<p>Focus paths integrate with <code>OpticPrograms</code> for complex workflows:</p>
<pre><code class="language-java">// Build a program using Focus paths
Free&lt;OpticOpKind.Witness, Company&gt; program = OpticPrograms
    .get(company, CompanyFocus.name().toLens())
    .flatMap(name -&gt; {
        if (name.startsWith("Acme")) {
            return OpticPrograms.modifyAll(
                company,
                CompanyFocus.departments().employees().age().toTraversal(),
                age -&gt; age + 1
            );
        } else {
            return OpticPrograms.pure(company);
        }
    });

// Execute with interpreter
Company result = OpticInterpreters.direct().run(program);
</code></pre>
<hr />
<h2 id="when-to-use-focus-dsl-vs-manual-composition"><a class="header" href="#when-to-use-focus-dsl-vs-manual-composition">When to Use Focus DSL vs Manual Composition</a></h2>
<h3 id="use-focus-dsl-when"><a class="header" href="#use-focus-dsl-when">Use Focus DSL When:</a></h3>
<ul>
<li><strong>Navigating deeply nested structures</strong> with many levels</li>
<li><strong>IDE autocomplete is important</strong> for discoverability</li>
<li><strong>Teaching or onboarding</strong> developers new to optics</li>
<li><strong>Prototyping</strong> before optimising for performance</li>
</ul>
<pre><code class="language-java">// Focus DSL - clear intent, discoverable
List&lt;String&gt; emails = CompanyFocus
    .departments()
    .employees()
    .email()
    .getAll(company);
</code></pre>
<h3 id="use-manual-composition-when"><a class="header" href="#use-manual-composition-when">Use Manual Composition When:</a></h3>
<ul>
<li><strong>Custom optics</strong> (computed properties, validated updates)</li>
<li><strong>Performance-critical code</strong> (avoid intermediate allocations)</li>
<li><strong>Reusable optic libraries</strong> (compose once, use everywhere)</li>
<li><strong>Complex conditional logic</strong> in the optic itself</li>
</ul>
<pre><code class="language-java">// Manual composition - more control, reusable
public static final Lens&lt;Company, String&gt; CEO_NAME =
    CompanyLenses.ceo()
        .andThen(ExecutiveLenses.person())
        .andThen(PersonLenses.fullName());
</code></pre>
<h3 id="hybrid-approach-recommended"><a class="header" href="#hybrid-approach-recommended">Hybrid Approach (Recommended)</a></h3>
<p>Use Focus DSL for navigation, then extract for reuse:</p>
<pre><code class="language-java">// Use Focus for exploration
var path = CompanyFocus.departments().employees().email();

// Extract and store the composed optic
public static final Traversal&lt;Company, String&gt; ALL_EMAILS =
    path.toTraversal();

// Reuse the extracted optic
List&lt;String&gt; emails = Traversals.getAll(ALL_EMAILS, company);
</code></pre>
<hr />
<h2 id="common-patterns-5"><a class="header" href="#common-patterns-5">Common Patterns</a></h2>
<h3 id="pattern-1-batch-updates"><a class="header" href="#pattern-1-batch-updates">Pattern 1: Batch Updates</a></h3>
<pre><code class="language-java">// Give all employees in Engineering a raise
Company updated = CompanyFocus
    .departments()
    .filter(d -&gt; d.name().equals("Engineering"))
    .employees()
    .salary()
    .modifyAll(s -&gt; s.multiply(new BigDecimal("1.10")), company);
</code></pre>
<h3 id="pattern-2-safe-deep-access"><a class="header" href="#pattern-2-safe-deep-access">Pattern 2: Safe Deep Access</a></h3>
<pre><code class="language-java">// Safely access deeply nested optional
Optional&lt;String&gt; managerEmail = CompanyFocus
    .department(0)
    .manager()
    .email()
    .getOptional(company);

// Handle absence gracefully
String email = managerEmail.orElse("no-manager@company.com");
</code></pre>
<h3 id="pattern-3-validation-with-focus"><a class="header" href="#pattern-3-validation-with-focus">Pattern 3: Validation with Focus</a></h3>
<pre><code class="language-java">// Validate all employee ages
Validated&lt;List&lt;String&gt;, Company&gt; result = OpticOps.modifyAllValidated(
    company,
    CompanyFocus.departments().employees().age().toTraversal(),
    age -&gt; age &gt;= 18 &amp;&amp; age &lt;= 100
        ? Validated.valid(age)
        : Validated.invalid("Invalid age: " + age)
);
</code></pre>
<hr />
<h2 id="performance-considerations-6"><a class="header" href="#performance-considerations-6">Performance Considerations</a></h2>
<p>Focus paths add a thin abstraction layer over raw optics:</p>
<ul>
<li><strong>Path creation</strong>: Minimal overhead (simple wrapper objects)</li>
<li><strong>Traversal</strong>: Identical to underlying optic performance</li>
<li><strong>Memory</strong>: One additional object per path segment</li>
</ul>
<p><strong>Best Practice</strong>: For hot paths, extract the underlying optic:</p>
<pre><code class="language-java">// Cold path - Focus DSL is fine
var result = CompanyFocus.departments().name().getAll(company);

// Hot path - extract and cache the optic
private static final Traversal&lt;Company, String&gt; DEPT_NAMES =
    CompanyFocus.departments().name().toTraversal();

for (Company c : manyCompanies) {
    var names = Traversals.getAll(DEPT_NAMES, c);  // Faster
}
</code></pre>
<hr />
<h2 id="customising-generated-code"><a class="header" href="#customising-generated-code">Customising Generated Code</a></h2>
<h3 id="target-package"><a class="header" href="#target-package">Target Package</a></h3>
<pre><code class="language-java">@GenerateFocus(targetPackage = "com.myapp.optics.focus")
record User(String name) {}
// Generates: com.myapp.optics.focus.UserFocus
</code></pre>
<h3 id="navigator-generation"><a class="header" href="#navigator-generation">Navigator Generation</a></h3>
<p>Enable fluent cross-type navigation with generated navigator classes:</p>
<pre><code class="language-java">@GenerateFocus(generateNavigators = true)
record Company(String name, Address headquarters) {}

@GenerateFocus(generateNavigators = true)
record Address(String street, String city) {}

// Now navigate fluently without .via():
String city = CompanyFocus.headquarters().city().get(company);
</code></pre>
<h3 id="navigator-depth-limiting"><a class="header" href="#navigator-depth-limiting">Navigator Depth Limiting</a></h3>
<p>Control how deep navigator generation goes with <code>maxNavigatorDepth</code>:</p>
<pre><code class="language-java">@GenerateFocus(generateNavigators = true, maxNavigatorDepth = 2)
record Organisation(Division division) {}

// Depth 1: Returns DivisionNavigator
// Depth 2: Returns FocusPath (not a navigator)
// Beyond: Use .via() for further navigation
</code></pre>
<h3 id="field-filtering-1"><a class="header" href="#field-filtering-1">Field Filtering</a></h3>
<p>Control which fields get navigator generation:</p>
<pre><code class="language-java">// Only generate navigators for specific fields
@GenerateFocus(generateNavigators = true, includeFields = {"homeAddress"})
record Person(String name, Address homeAddress, Address workAddress) {}

// Or exclude specific fields
@GenerateFocus(generateNavigators = true, excludeFields = {"backup"})
record Config(Settings main, Settings backup) {}
</code></pre>
<hr />
<h2 id="lens-fallback-for-non-annotated-types"><a class="header" href="#lens-fallback-for-non-annotated-types">Lens Fallback for Non-Annotated Types</a></h2>
<p>When navigating to a type without <code>@GenerateFocus</code>, you can continue with <code>.via()</code>:</p>
<pre><code class="language-java">// ThirdPartyRecord doesn't have @GenerateFocus
@GenerateLenses
@GenerateFocus
record MyRecord(ThirdPartyRecord external) {}

// Navigate as far as Focus allows, then use .via() with existing lens
FocusPath&lt;MyRecord, ThirdPartyRecord&gt; externalPath = MyRecordFocus.external();
FocusPath&lt;MyRecord, String&gt; deepPath = externalPath.via(ThirdPartyLenses.someField());
</code></pre>
<hr />
<h2 id="common-pitfalls-24"><a class="header" href="#common-pitfalls-24">Common Pitfalls</a></h2>
<h3 id="dont-recreate-paths-in-loops"><a class="header" href="#dont-recreate-paths-in-loops">Don't: Recreate paths in loops</a></h3>
<pre><code class="language-java">// Bad - creates new path objects each iteration
for (Company c : companies) {
    var names = CompanyFocus.departments().name().getAll(c);
}
</code></pre>
<h3 id="do-extract-and-reuse"><a class="header" href="#do-extract-and-reuse">Do: Extract and reuse</a></h3>
<pre><code class="language-java">// Good - create path once
var deptNames = CompanyFocus.departments().name();
for (Company c : companies) {
    var names = deptNames.getAll(c);
}
</code></pre>
<h3 id="dont-ignore-the-path-type"><a class="header" href="#dont-ignore-the-path-type">Don't: Ignore the path type</a></h3>
<pre><code class="language-java">// Confusing - what does this return?
var result = somePath.get(source);  // Might fail if AffinePath!
</code></pre>
<h3 id="do-use-the-appropriate-method"><a class="header" href="#do-use-the-appropriate-method">Do: Use the appropriate method</a></h3>
<pre><code class="language-java">// Clear - FocusPath always has a value
String name = namePath.get(employee);

// Clear - AffinePath might be empty
Optional&lt;String&gt; email = emailPath.getOptional(employee);

// Clear - TraversalPath has multiple values
List&lt;String&gt; names = namesPath.getAll(department);
</code></pre>
<hr />
<h2 id="troubleshooting-and-faq"><a class="header" href="#troubleshooting-and-faq">Troubleshooting and FAQ</a></h2>
<h3 id="compilation-errors"><a class="header" href="#compilation-errors">Compilation Errors</a></h3>
<h4 id="cannot-infer-type-arguments-for-traverseover"><a class="header" href="#cannot-infer-type-arguments-for-traverseover">"Cannot infer type arguments for traverseOver"</a></h4>
<p><strong>Problem:</strong></p>
<pre><code class="language-java">// This fails to compile
TraversalPath&lt;User, Role&gt; allRoles = rolesPath.traverseOver(ListTraverse.INSTANCE);
</code></pre>
<p><strong>Solution:</strong> Provide explicit type parameters:</p>
<pre><code class="language-java">// Add explicit type witnesses
TraversalPath&lt;User, Role&gt; allRoles =
    rolesPath.&lt;ListKind.Witness, Role&gt;traverseOver(ListTraverse.INSTANCE);
</code></pre>
<p>Java's type inference struggles with higher-kinded types. Explicit type parameters help the compiler.</p>
<h4 id="incompatible-types-when-chaining-eachvia"><a class="header" href="#incompatible-types-when-chaining-eachvia">"Incompatible types when chaining .each().via()"</a></h4>
<p><strong>Problem:</strong></p>
<pre><code class="language-java">// Type inference fails on long chains
TraversalPath&lt;Company, Integer&gt; salaries =
    FocusPath.of(companyDeptLens).each().via(deptEmployeesLens).each().via(salaryLens);
</code></pre>
<p><strong>Solution:</strong> Break the chain into intermediate variables:</p>
<pre><code class="language-java">// Use intermediate variables
TraversalPath&lt;Company, Department&gt; depts = FocusPath.of(companyDeptLens).each();
TraversalPath&lt;Company, Employee&gt; employees = depts.via(deptEmployeesLens).each();
TraversalPath&lt;Company, Integer&gt; salaries = employees.via(salaryLens);
</code></pre>
<h4 id="sealed-or-non-sealed-local-classes-are-not-allowed"><a class="header" href="#sealed-or-non-sealed-local-classes-are-not-allowed">"Sealed or non-sealed local classes are not allowed"</a></h4>
<p><strong>Problem:</strong> Defining sealed interfaces inside test methods fails:</p>
<pre><code class="language-java">@Test void myTest() {
    sealed interface Wrapper permits A, B {}  // Compilation error!
    record A() implements Wrapper {}
}
</code></pre>
<p><strong>Solution:</strong> Move sealed interfaces to class level:</p>
<pre><code class="language-java">class MyTest {
    sealed interface Wrapper permits A, B {}
    record A() implements Wrapper {}

    @Test void myTest() {
        // Use Wrapper here
    }
}
</code></pre>
<h4 id="method-reference-new-doesnt-work-with-single-field-records-as-bifunction"><a class="header" href="#method-reference-new-doesnt-work-with-single-field-records-as-bifunction">"Method reference ::new doesn't work with single-field records as BiFunction"</a></h4>
<p><strong>Problem:</strong></p>
<pre><code class="language-java">// This fails for single-field records
Lens&lt;Outer, Inner&gt; lens = Lens.of(Outer::inner, Outer::new);  // Error!
</code></pre>
<p><strong>Solution:</strong> Use explicit lambda:</p>
<pre><code class="language-java">Lens&lt;Outer, Inner&gt; lens = Lens.of(Outer::inner, (o, i) -&gt; new Outer(i));
</code></pre>
<h3 id="runtime-issues-1"><a class="header" href="#runtime-issues-1">Runtime Issues</a></h3>
<h4 id="getall-returns-empty-unexpectedly"><a class="header" href="#getall-returns-empty-unexpectedly">"getAll() returns empty unexpectedly"</a></h4>
<p><strong>Checklist:</strong></p>
<ol>
<li>Check if the AffinePath in the chain has focus (use <code>matches()</code> to verify)</li>
<li>Verify <code>instanceOf()</code> matches the actual runtime type</li>
<li>Ensure the source data actually contains elements</li>
</ol>
<pre><code class="language-java">// Debug with traced()
TraversalPath&lt;User, Role&gt; traced = rolesPath.traced(
    (user, roles) -&gt; System.out.println("Found " + roles.size() + " roles")
);
List&lt;Role&gt; roles = traced.getAll(user);
</code></pre>
<h4 id="modifyall-doesnt-change-anything"><a class="header" href="#modifyall-doesnt-change-anything">"modifyAll() doesn't change anything"</a></h4>
<p><strong>Causes:</strong></p>
<ul>
<li>The traversal has no focus (AffinePath didn't match)</li>
<li>The predicate in <code>modifyWhen()</code> never matches</li>
<li>The source collection is empty</li>
</ul>
<pre><code class="language-java">// Check focus exists
int count = path.count(source);
System.out.println("Path focuses on " + count + " elements");
</code></pre>
<h3 id="faq"><a class="header" href="#faq">FAQ</a></h3>
<h4 id="q-when-should-i-use-each-vs-traverseover"><a class="header" href="#q-when-should-i-use-each-vs-traverseover">Q: When should I use <code>each()</code> vs <code>traverseOver()</code>?</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Scenario</th><th>Use</th></tr></thead><tbody>
<tr><td>Field is <code>List&lt;T&gt;</code></td><td><code>each()</code></td></tr>
<tr><td>Field is <code>Set&lt;T&gt;</code></td><td><code>each()</code></td></tr>
<tr><td>Field is <code>Kind&lt;ListKind.Witness, T&gt;</code></td><td><code>traverseOver(ListTraverse.INSTANCE)</code></td></tr>
<tr><td>Field is <code>Kind&lt;MaybeKind.Witness, T&gt;</code></td><td><code>traverseOver(MaybeTraverse.INSTANCE)</code></td></tr>
<tr><td>Custom traversable type</td><td><code>traverseOver(YourTraverse.INSTANCE)</code></td></tr>
</tbody></table>
</div>
<h4 id="q-why-use-maybemonadinstance-for-modifyf-instead-of-a-dedicated-applicative"><a class="header" href="#q-why-use-maybemonadinstance-for-modifyf-instead-of-a-dedicated-applicative">Q: Why use <code>MaybeMonad.INSTANCE</code> for <code>modifyF()</code> instead of a dedicated Applicative?</a></h4>
<p><code>MaybeMonad</code> extends <code>Applicative</code>, so it works for <code>modifyF()</code>. Higher-Kinded-J doesn't provide a separate <code>MaybeApplicative</code> because:</p>
<ul>
<li>Monad already provides all Applicative operations</li>
<li>Having one instance simplifies the API</li>
<li>Most effects you'll use with <code>modifyF()</code> are monadic anyway</li>
</ul>
<pre><code class="language-java">// Use MaybeMonad for Maybe-based validation
Kind&lt;MaybeKind.Witness, Config&gt; result =
    keyPath.modifyF(validateKey, config, MaybeMonad.INSTANCE);
</code></pre>
<h4 id="q-can-i-use-focus-dsl-with-third-party-types"><a class="header" href="#q-can-i-use-focus-dsl-with-third-party-types">Q: Can I use Focus DSL with third-party types?</a></h4>
<p>Yes, use <code>.via()</code> to compose with manually created optics:</p>
<pre><code class="language-java">// Create lens for third-party type
Lens&lt;ThirdPartyType, String&gt; fieldLens = Lens.of(
    ThirdPartyType::getField,
    (obj, value) -&gt; obj.toBuilder().field(value).build()
);

// Compose with Focus path
FocusPath&lt;MyRecord, String&gt; path = MyRecordFocus.external().via(fieldLens);
</code></pre>
<h4 id="q-how-do-i-handle-nullable-fields"><a class="header" href="#q-how-do-i-handle-nullable-fields">Q: How do I handle nullable fields?</a></h4>
<p>The Focus DSL provides four approaches for handling nullable fields, from most to least automated:</p>
<p><strong>Option 1: Use <code>@Nullable</code> annotation (Recommended)</strong></p>
<p>Annotate nullable fields with <code>@Nullable</code> from JSpecify, JSR-305, or similar. The processor automatically generates <code>AffinePath</code> with null-safe access:</p>
<pre><code class="language-java">import org.jspecify.annotations.Nullable;

@GenerateFocus
record User(String name, @Nullable String nickname) {}

// Generated: AffinePath that handles null automatically
AffinePath&lt;User, String&gt; nicknamePath = UserFocus.nickname();

User user = new User("Alice", null);
Optional&lt;String&gt; result = nicknamePath.getOptional(user);  // Optional.empty()

User withNick = new User("Bob", "Bobby");
Optional&lt;String&gt; present = nicknamePath.getOptional(withNick);  // Optional.of("Bobby")
</code></pre>
<p>Supported nullable annotations:</p>
<ul>
<li><code>org.jspecify.annotations.Nullable</code></li>
<li><code>javax.annotation.Nullable</code></li>
<li><code>jakarta.annotation.Nullable</code></li>
<li><code>org.jetbrains.annotations.Nullable</code></li>
<li><code>androidx.annotation.Nullable</code></li>
<li><code>edu.umd.cs.findbugs.annotations.Nullable</code></li>
</ul>
<p><strong>Option 2: Use <code>.nullable()</code> method</strong></p>
<p>For existing <code>FocusPath</code> instances, chain with <code>.nullable()</code> to handle nulls:</p>
<pre><code class="language-java">// If you have a FocusPath to a nullable field
FocusPath&lt;LegacyUser, String&gt; rawPath = LegacyUserFocus.nickname();

// Chain with nullable() for null-safe access
AffinePath&lt;LegacyUser, String&gt; safePath = rawPath.nullable();

Optional&lt;String&gt; result = safePath.getOptional(user);  // Empty if null
</code></pre>
<p><strong>Option 3: Use <code>AffinePath.ofNullable()</code> factory</strong></p>
<p>For manual creation without code generation:</p>
<pre><code class="language-java">// Create a nullable-aware AffinePath directly
AffinePath&lt;User, String&gt; nicknamePath = AffinePath.ofNullable(
    User::nickname,
    (user, nickname) -&gt; new User(user.name(), nickname)
);
</code></pre>
<p><strong>Option 4: Wrap in <code>Optional</code> (Alternative design)</strong></p>
<p>If you control the data model, consider using <code>Optional&lt;T&gt;</code> instead of nullable fields:</p>
<pre><code class="language-java">// Model absence explicitly with Optional
record User(String name, Optional&lt;String&gt; email) {}

// Focus DSL handles it naturally with .some()
AffinePath&lt;User, String&gt; emailPath = UserFocus.email();  // Uses .some() internally
</code></pre>
<h4 id="q-whats-the-performance-overhead-of-focus-dsl"><a class="header" href="#q-whats-the-performance-overhead-of-focus-dsl">Q: What's the performance overhead of Focus DSL?</a></h4>
<ul>
<li><strong>Path creation</strong>: Negligible (thin wrapper objects)</li>
<li><strong>Operations</strong>: Same as underlying optics</li>
<li><strong>Hot paths</strong>: Extract and cache the optic</li>
</ul>
<pre><code class="language-java">// For performance-critical code, cache the extracted optic
private static final Traversal&lt;Company, String&gt; EMPLOYEE_NAMES =
    CompanyFocus.departments().employees().name().toTraversal();

// Use the cached optic in hot loops
for (Company c : companies) {
    List&lt;String&gt; names = Traversals.getAll(EMPLOYEE_NAMES, c);
}
</code></pre>
<h4 id="q-can-i-create-focus-paths-programmatically-at-runtime"><a class="header" href="#q-can-i-create-focus-paths-programmatically-at-runtime">Q: Can I create Focus paths programmatically (at runtime)?</a></h4>
<p>Focus paths are designed for compile-time type safety. For runtime-dynamic paths, use the underlying optics directly:</p>
<pre><code class="language-java">// Build optics dynamically
Traversal&lt;JsonNode, String&gt; dynamicPath = buildTraversalFromJsonPath(jsonPathString);

// Wrap in a path if needed
TraversalPath&lt;JsonNode, String&gt; path = TraversalPath.of(dynamicPath);
</code></pre>
<hr />
<div id="admonition-further-reading" class="admonition admonish-tip" role="note" aria-labelledby="admonition-further-reading-title">
<div class="admonition-title">
<div id="admonition-further-reading-title">
<p>Further Reading</p>
</div>
<a class="admonition-anchor-link" href="optics/focus_dsl.html#admonition-further-reading"></a>
</div>
<div>
<ul>
<li><strong>Monocle</strong>: <a href="https://www.optics.dev/Monocle/docs/focus">Focus DSL</a> - Scala's equivalent, inspiration for this design</li>
</ul>
</div>
</div>
<div id="admonition-see-also-1" class="admonition admonish-tip" role="note" aria-labelledby="admonition-see-also-1-title">
<div class="admonition-title">
<div id="admonition-see-also-1-title">
<p>See Also</p>
</div>
<a class="admonition-anchor-link" href="optics/focus_dsl.html#admonition-see-also-1"></a>
</div>
<div>
<ul>
<li><a href="optics/lenses.html">Lenses</a> - Foundation concepts</li>
<li><a href="optics/fluent_api.html">Fluent API</a> - Alternative fluent patterns</li>
<li><a href="optics/free_monad_dsl.html">Free Monad DSL</a> - Composable optic programs</li>
</ul>
</div>
</div>
<div id="admonition-hands-on-learning" class="admonition admonish-info" role="note" aria-labelledby="admonition-hands-on-learning-title">
<div class="admonition-title">
<div id="admonition-hands-on-learning-title">
<p>Hands-On Learning</p>
</div>
<a class="admonition-anchor-link" href="optics/focus_dsl.html#admonition-hands-on-learning"></a>
</div>
<div>
<p>Practice the Focus DSL in <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/optics/Tutorial12_FocusDSL.java">Tutorial 12: Focus DSL</a> (10 exercises, ~12 minutes) and <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/optics/Tutorial13_AdvancedFocusDSL.java">Tutorial 13: Advanced Focus DSL</a> (8 exercises, ~12 minutes).</p>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="optics/ch4_intro.html">Introduction</a>
<strong>Next:</strong> <a href="optics/kind_field_support.html">Kind Field Support</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="kind-field-support-in-focus-dsl"><a class="header" href="#kind-field-support-in-focus-dsl">Kind Field Support in Focus DSL</a></h1>
<h2 id="automatic-traversal-for-higher-kinded-type-fields"><a class="header" href="#automatic-traversal-for-higher-kinded-type-fields"><em>Automatic Traversal for Higher-Kinded Type Fields</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="optics/kind_field_support.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How the Focus DSL automatically handles <code>Kind&lt;F, A&gt;</code> record fields</li>
<li>Convention-based detection for library types (ListKind, MaybeKind, etc.)</li>
<li>Using <code>@TraverseField</code> for custom Kind types</li>
<li>Understanding semantic classifications: EXACTLY_ONE, ZERO_OR_ONE, ZERO_OR_MORE</li>
<li>How <code>traverseOver()</code> and <code>headOption()</code> work together</li>
<li>Composing Kind field paths with other Focus DSL operations</li>
</ul>
</div>
</div>
<div id="admonition-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-code-title">
<div class="admonition-title">
<div id="admonition-example-code-title">
<p>Example Code</p>
</div>
<a class="admonition-anchor-link" href="optics/kind_field_support.html#admonition-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/focus/KindFieldFocusExample.java">KindFieldFocusExample.java</a></p>
</div>
</div>
<p>When working with Higher-Kinded-J, you often model domain data using <code>Kind&lt;F, A&gt;</code> wrapped fields. For example, a team might have members wrapped in <code>Kind&lt;ListKind.Witness, Member&gt;</code> or an optional lead wrapped in <code>Kind&lt;MaybeKind.Witness, Member&gt;</code>. The Focus DSL annotation processor automatically detects these fields and generates the appropriate traversal code.</p>
<hr />
<h2 id="the-problem-manual-traverseover-calls"><a class="header" href="#the-problem-manual-traverseover-calls">The Problem: Manual traverseOver Calls</a></h2>
<p>Without automatic Kind field support, you would need to manually compose <code>traverseOver()</code> calls:</p>
<pre><code class="language-java">// Without automatic support - verbose manual composition
@GenerateFocus
record Team(String name, Kind&lt;ListKind.Witness, Member&gt; members) {}

// Generated code would just return FocusPath to the raw Kind type:
// FocusPath&lt;Team, Kind&lt;ListKind.Witness, Member&gt;&gt; members()

// Forcing you to manually add traverseOver:
TraversalPath&lt;Team, Member&gt; memberPath = TeamFocus.members()
    .&lt;ListKind.Witness, Member&gt;traverseOver(ListTraverse.INSTANCE);
</code></pre>
<hr />
<h2 id="the-solution-automatic-kind-detection"><a class="header" href="#the-solution-automatic-kind-detection">The Solution: Automatic Kind Detection</a></h2>
<p>With Kind field support enabled, the processor automatically generates the correct path type:</p>
<pre><code class="language-java">@GenerateFocus
record Team(String name, Kind&lt;ListKind.Witness, Member&gt; members) {}

// Generated code automatically includes traverseOver:
// TraversalPath&lt;Team, Member&gt; members() {
//     return FocusPath.of(...)
//         .&lt;ListKind.Witness, Member&gt;traverseOver(ListTraverse.INSTANCE);
// }

// Usage is now straightforward:
List&lt;Member&gt; allMembers = TeamFocus.members().getAll(team);
Team updated = TeamFocus.members().modifyAll(Member::promote, team);
</code></pre>
<hr />
<h2 id="convention-based-detection"><a class="header" href="#convention-based-detection">Convention-Based Detection</a></h2>
<p>The processor automatically recognises standard Higher-Kinded-J types by their witness type:</p>
<div class="table-wrapper"><table><thead><tr><th>Witness Type</th><th>Traverse Instance</th><th>Semantics</th><th>Generated Path</th></tr></thead><tbody>
<tr><td><code>ListKind.Witness</code></td><td><code>ListTraverse.INSTANCE</code></td><td>ZERO_OR_MORE</td><td><code>TraversalPath</code></td></tr>
<tr><td><code>MaybeKind.Witness</code></td><td><code>MaybeTraverse.INSTANCE</code></td><td>ZERO_OR_ONE</td><td><code>AffinePath</code></td></tr>
<tr><td><code>OptionalKind.Witness</code></td><td><code>OptionalTraverse.INSTANCE</code></td><td>ZERO_OR_ONE</td><td><code>AffinePath</code></td></tr>
<tr><td><code>StreamKind.Witness</code></td><td><code>StreamTraverse.INSTANCE</code></td><td>ZERO_OR_MORE</td><td><code>TraversalPath</code></td></tr>
<tr><td><code>TryKind.Witness</code></td><td><code>TryTraverse.INSTANCE</code></td><td>ZERO_OR_ONE</td><td><code>AffinePath</code></td></tr>
<tr><td><code>IdKind.Witness</code></td><td><code>IdTraverse.INSTANCE</code></td><td>EXACTLY_ONE</td><td><code>AffinePath</code></td></tr>
<tr><td><code>EitherKind.Witness&lt;E&gt;</code></td><td><code>EitherTraverse.instance()</code></td><td>ZERO_OR_ONE</td><td><code>AffinePath</code></td></tr>
<tr><td><code>ValidatedKind.Witness&lt;E&gt;</code></td><td><code>ValidatedTraverse.instance()</code></td><td>ZERO_OR_ONE</td><td><code>AffinePath</code></td></tr>
</tbody></table>
</div>
<h3 id="example-multiple-kind-fields"><a class="header" href="#example-multiple-kind-fields">Example: Multiple Kind Fields</a></h3>
<pre><code class="language-java">@GenerateFocus
record ApiResponse(
    String requestId,
    Kind&lt;MaybeKind.Witness, User&gt; user,           // -&gt; AffinePath
    Kind&lt;ListKind.Witness, Warning&gt; warnings,      // -&gt; TraversalPath
    Kind&lt;EitherKind.Witness&lt;Error&gt;, Data&gt; result   // -&gt; AffinePath
) {}

// Generated methods:
// AffinePath&lt;ApiResponse, User&gt; user()
// TraversalPath&lt;ApiResponse, Warning&gt; warnings()
// AffinePath&lt;ApiResponse, Data&gt; result()
</code></pre>
<hr />
<h2 id="semantic-classifications"><a class="header" href="#semantic-classifications">Semantic Classifications</a></h2>
<p>Kind types are classified by their cardinality, which determines the generated path type:</p>
<h3 id="exactly_one"><a class="header" href="#exactly_one">EXACTLY_ONE</a></h3>
<p>Types that always contain exactly one element (e.g., <code>IdKind</code>).</p>
<pre><code class="language-java">record Wrapper(Kind&lt;IdKind.Witness, String&gt; value) {}

// Generates AffinePath (type-safe narrowing from TraversalPath)
AffinePath&lt;Wrapper, String&gt; valuePath = WrapperFocus.value();

// Always has a value (IdKind semantics)
Optional&lt;String&gt; value = valuePath.getOptional(wrapper);
</code></pre>
<div id="admonition-why-affinepath-for-exactly_one" class="admonition admonish-note" role="note" aria-labelledby="admonition-why-affinepath-for-exactly_one-title">
<div class="admonition-title">
<div id="admonition-why-affinepath-for-exactly_one-title">
<p>Why AffinePath for EXACTLY_ONE?</p>
</div>
<a class="admonition-anchor-link" href="optics/kind_field_support.html#admonition-why-affinepath-for-exactly_one"></a>
</div>
<div>
<p>Although <code>IdKind</code> always contains exactly one element, the generated code uses <code>traverseOver()</code> which returns <code>TraversalPath</code>. We narrow this to <code>AffinePath</code> via <code>headOption()</code> for type safety. This is a safe approach that works correctly at runtime.</p>
</div>
</div>
<h3 id="zero_or_one"><a class="header" href="#zero_or_one">ZERO_OR_ONE</a></h3>
<p>Types that contain zero or one element (e.g., <code>MaybeKind</code>, <code>OptionalKind</code>, <code>TryKind</code>, <code>EitherKind</code>).</p>
<pre><code class="language-java">record Config(Kind&lt;MaybeKind.Witness, String&gt; apiKey) {}

// Generates AffinePath
AffinePath&lt;Config, String&gt; keyPath = ConfigFocus.apiKey();

// May or may not have a value
Optional&lt;String&gt; key = keyPath.getOptional(config);
boolean hasKey = keyPath.matches(config);
</code></pre>
<h3 id="zero_or_more"><a class="header" href="#zero_or_more">ZERO_OR_MORE</a></h3>
<p>Types that contain zero or more elements (e.g., <code>ListKind</code>, <code>StreamKind</code>).</p>
<pre><code class="language-java">record Team(Kind&lt;ListKind.Witness, Member&gt; members) {}

// Generates TraversalPath
TraversalPath&lt;Team, Member&gt; membersPath = TeamFocus.members();

// Multiple values
List&lt;Member&gt; allMembers = membersPath.getAll(team);
int count = membersPath.count(team);
</code></pre>
<hr />
<h2 id="custom-kind-types-with-traversefield"><a class="header" href="#custom-kind-types-with-traversefield">Custom Kind Types with @TraverseField</a></h2>
<p>For Kind types not in the Higher-Kinded-J library, use <code>@TraverseField</code> to configure the traversal:</p>
<pre><code class="language-java">// Custom Kind type
public class TreeKind {
    public enum Witness {}
}

// Custom Traverse implementation
public enum TreeTraverse implements Traverse&lt;TreeKind.Witness&gt; {
    INSTANCE;
    // ... implementation
}

// Use @TraverseField to register the mapping
@GenerateFocus
record Forest(
    String name,
    @TraverseField(
        traverse = "com.example.TreeTraverse.INSTANCE",
        semantics = KindSemantics.ZERO_OR_MORE
    )
    Kind&lt;TreeKind.Witness, Tree&gt; trees
) {}

// Generated: TraversalPath&lt;Forest, Tree&gt; trees()
</code></pre>
<h3 id="traversefield-attributes"><a class="header" href="#traversefield-attributes">@TraverseField Attributes</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Attribute</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>traverse</code></td><td><code>String</code></td><td>Fully qualified expression for the Traverse instance</td></tr>
<tr><td><code>semantics</code></td><td><code>KindSemantics</code></td><td>Cardinality classification (default: <code>ZERO_OR_MORE</code>)</td></tr>
</tbody></table>
</div>
<h3 id="traverse-expression-examples"><a class="header" href="#traverse-expression-examples">Traverse Expression Examples</a></h3>
<pre><code class="language-java">// Enum singleton
@TraverseField(traverse = "com.example.TreeTraverse.INSTANCE")

// Factory method
@TraverseField(traverse = "com.example.EitherTraverse.instance()")

// Static field
@TraverseField(traverse = "com.example.MyTraverse.TRAVERSE")
</code></pre>
<hr />
<h2 id="the-headoption-method"><a class="header" href="#the-headoption-method">The headOption() Method</a></h2>
<p>When the processor generates code for <code>ZERO_OR_ONE</code> or <code>EXACTLY_ONE</code> semantics, it uses the <code>headOption()</code> method to narrow <code>TraversalPath</code> to <code>AffinePath</code>:</p>
<pre><code class="language-java">// Generated code for MaybeKind field:
public static AffinePath&lt;Config, String&gt; apiKey() {
    return FocusPath.of(...)
        .&lt;MaybeKind.Witness, String&gt;traverseOver(MaybeTraverse.INSTANCE)
        .headOption();
}
</code></pre>
<h3 id="how-headoption-works"><a class="header" href="#how-headoption-works">How headOption() Works</a></h3>
<p><code>headOption()</code> converts a <code>TraversalPath</code> (zero or more) to an <code>AffinePath</code> (zero or one):</p>
<ul>
<li><strong>Get</strong>: Returns the first element if present via <code>preview()</code></li>
<li><strong>Set</strong>: Updates all focused elements via <code>setAll()</code></li>
</ul>
<pre><code class="language-java">TraversalPath&lt;List&lt;String&gt;, String&gt; listPath = TraversalPath.of(Traversals.forList());

// Narrow to first element only
AffinePath&lt;List&lt;String&gt;, String&gt; firstPath = listPath.headOption();

// Get first element
Optional&lt;String&gt; first = firstPath.getOptional(List.of("a", "b", "c")); // Optional["a"]

// Set updates all elements (preserves traversal semantics)
List&lt;String&gt; updated = firstPath.set("X", List.of("a", "b", "c")); // ["X", "X", "X"]
</code></pre>
<hr />
<h2 id="composition-with-other-focus-operations"><a class="header" href="#composition-with-other-focus-operations">Composition with Other Focus Operations</a></h2>
<p>Kind field paths compose naturally with other Focus DSL operations:</p>
<h3 id="chaining-navigation"><a class="header" href="#chaining-navigation">Chaining Navigation</a></h3>
<pre><code class="language-java">@GenerateFocus
record Project(String name, Kind&lt;ListKind.Witness, Team&gt; teams) {}

@GenerateFocus
record Team(String name, Kind&lt;ListKind.Witness, Member&gt; members) {}

@GenerateFocus
record Member(String name, Kind&lt;ListKind.Witness, Skill&gt; skills) {}

// Chain through multiple Kind fields
TraversalPath&lt;Project, Team&gt; teamsPath = ProjectFocus.teams();
TraversalPath&lt;Team, Member&gt; membersPath = TeamFocus.members();
TraversalPath&lt;Member, Skill&gt; skillsPath = MemberFocus.skills();

// Compose for deep navigation
for (Team team : teamsPath.getAll(project)) {
    for (Member member : membersPath.getAll(team)) {
        List&lt;Skill&gt; skills = skillsPath.getAll(member);
        // Process skills...
    }
}
</code></pre>
<h3 id="filtering"><a class="header" href="#filtering">Filtering</a></h3>
<pre><code class="language-java">// Filter members with specific skills
TraversalPath&lt;Team, Member&gt; seniorDevs = TeamFocus.members()
    .filter(m -&gt; MemberFocus.skills().exists(s -&gt; s.proficiency() &gt; 90, m));

List&lt;Member&gt; experts = seniorDevs.getAll(team);
</code></pre>
<h3 id="conditional-modification-1"><a class="header" href="#conditional-modification-1">Conditional Modification</a></h3>
<pre><code class="language-java">// Improve skills only for members with low proficiency
Team updated = TeamFocus.members().modifyWhen(
    member -&gt; MemberFocus.skills().exists(s -&gt; s.proficiency() &lt; 50, member),
    member -&gt; MemberFocus.skills().modifyAll(Skill::improve, member),
    team
);
</code></pre>
<hr />
<h2 id="parameterised-witness-types"><a class="header" href="#parameterised-witness-types">Parameterised Witness Types</a></h2>
<p>Some witness types have type parameters (e.g., <code>EitherKind.Witness&lt;E&gt;</code>, <code>ValidatedKind.Witness&lt;E&gt;</code>). The processor handles these automatically:</p>
<pre><code class="language-java">@GenerateFocus
record Response(
    Kind&lt;EitherKind.Witness&lt;String&gt;, User&gt; user
) {}

// Generated code uses factory method with proper type parameters:
// public static AffinePath&lt;Response, User&gt; user() {
//     return FocusPath.of(...)
//         .&lt;EitherKind.Witness&lt;String&gt;, User&gt;traverseOver(
//             EitherTraverse.&lt;String&gt;instance()
//         )
//         .headOption();
// }
</code></pre>
<hr />
<h2 id="unknown-kind-types"><a class="header" href="#unknown-kind-types">Unknown Kind Types</a></h2>
<p>If the processor encounters a <code>Kind&lt;F, A&gt;</code> field with an unrecognised witness type and no <code>@TraverseField</code> annotation, it falls back to generating a standard <code>FocusPath</code> to the raw <code>Kind</code> type:</p>
<pre><code class="language-java">// Unknown witness type without annotation
record Data(Kind&lt;UnknownKind.Witness, String&gt; value) {}

// Falls back to: FocusPath&lt;Data, Kind&lt;UnknownKind.Witness, String&gt;&gt; value()
</code></pre>
<p>To enable automatic traversal for unknown types, add <code>@TraverseField</code> with the appropriate configuration.</p>
<hr />
<h2 id="key-takeaways"><a class="header" href="#key-takeaways">Key Takeaways</a></h2>
<div id="admonition-key-takeaways" class="admonition admonish-info" role="note" aria-labelledby="admonition-key-takeaways-title">
<div class="admonition-title">
<div id="admonition-key-takeaways-title">
<p>Key Takeaways</p>
</div>
<a class="admonition-anchor-link" href="optics/kind_field_support.html#admonition-key-takeaways"></a>
</div>
<div>
<ul>
<li><strong>Convention over configuration</strong> - Library Kind types are automatically detected and handled</li>
<li><strong>Semantic classification</strong> - EXACTLY_ONE, ZERO_OR_ONE, ZERO_OR_MORE determine the generated path type</li>
<li><strong>@TraverseField</strong> - Enables custom Kind type support with explicit Traverse configuration</li>
<li><strong>headOption()</strong> - Narrows TraversalPath to AffinePath for zero-or-one semantics</li>
<li><strong>Composable</strong> - Kind field paths integrate seamlessly with filtering, modification, and chaining</li>
</ul>
</div>
</div>
<hr />
<div id="admonition-see-also" class="admonition admonish-tip" role="note" aria-labelledby="admonition-see-also-title">
<div class="admonition-title">
<div id="admonition-see-also-title">
<p>See Also</p>
</div>
<a class="admonition-anchor-link" href="optics/kind_field_support.html#admonition-see-also"></a>
</div>
<div>
<ul>
<li><a href="optics/focus_dsl.html">Focus DSL</a> - Core Focus DSL concepts and navigation</li>
<li><a href="optics/../functional/foldable_and_traverse.html">Foldable and Traverse</a> - Understanding the Traverse type class</li>
<li><a href="optics/core_type_integration.html">Core Type Integration</a> - Working with Maybe, Either, Validated in optics</li>
</ul>
</div>
</div>
<div id="admonition-further-reading" class="admonition admonish-tip" role="note" aria-labelledby="admonition-further-reading-title">
<div class="admonition-title">
<div id="admonition-further-reading-title">
<p>Further Reading</p>
</div>
<a class="admonition-anchor-link" href="optics/kind_field_support.html#admonition-further-reading"></a>
</div>
<div>
<ul>
<li><strong>Monocle Documentation</strong>: <a href="https://www.optics.dev/Monocle/docs/optics/traversal">Traversal</a> - Scala's traversal implementation</li>
<li><strong>Cats Documentation</strong>: <a href="https://typelevel.org/cats/typeclasses/traverse.html">Traverse</a> - The Traverse type class</li>
</ul>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="optics/focus_dsl.html">Focus DSL</a>
<strong>Next:</strong> <a href="optics/fluent_api.html">Fluent API</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="fluent-api-for-optics-java-friendly-optic-operations"><a class="header" href="#fluent-api-for-optics-java-friendly-optic-operations">Fluent API for Optics: Java-Friendly Optic Operations</a></h1>
<p><img src="optics/../images/lens2.jpg" alt="Illustration of fluent API patterns for Java-friendly optic operations" /></p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="optics/fluent_api.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>Two styles of optic operations: static methods and fluent builders</li>
<li>When to use each style for maximum clarity and productivity</li>
<li>How to perform common optic operations with Java-friendly syntax</li>
<li>Validation-aware modifications with <code>Either</code>, <code>Maybe</code>, and <code>Validated</code></li>
<li>Four validation strategies for different error-handling scenarios</li>
<li>Effectful modifications using type classes</li>
<li>Practical patterns for real-world Java applications</li>
</ul>
</div>
</div>
<div id="admonition-hands-on-practice" class="admonition admonish-note" role="note" aria-labelledby="admonition-hands-on-practice-title">
<div class="admonition-title">
<div id="admonition-hands-on-practice-title">
<p>Hands On Practice</p>
</div>
<a class="admonition-anchor-link" href="optics/fluent_api.html#admonition-hands-on-practice"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/optics/Tutorial09_FluentOpticsAPI.java">Tutorial09_FluentOpticsAPI.java</a></p>
</div>
</div>
<div id="admonition-example-code" class="admonition admonish-note" role="note" aria-labelledby="admonition-example-code-title">
<div class="admonition-title">
<div id="admonition-example-code-title">
<p>Example Code</p>
</div>
<a class="admonition-anchor-link" href="optics/fluent_api.html#admonition-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/fluent/FluentOpticOpsExample.java">FluentOpticOpsExample</a></p>
</div>
</div>
<h2 id="introduction-making-optics-feel-natural-in-java"><a class="header" href="#introduction-making-optics-feel-natural-in-java">Introduction: Making Optics Feel Natural in Java</a></h2>
<p>While optics provide immense power for working with immutable data structures, their traditional functional programming syntax can feel foreign to Java developers. Method names like <code>view</code>, <code>over</code>, and <code>preview</code> don't match Java conventions, and the order of parameters can be unintuitive.</p>
<p>The <code>OpticOps</code> fluent API bridges this gap, providing two complementary styles that make optics feel natural in Java:</p>
<ol>
<li><strong>Static methods</strong> - Concise, direct operations for simple cases</li>
<li><strong>Fluent builders</strong> - Method chaining with IDE-discoverable operations</li>
</ol>
<p>Both styles operate on the same underlying optics, so you can mix and match based on what feels most natural for each situation.</p>
<hr />
<h2 id="the-two-styles-a-quick-comparison"><a class="header" href="#the-two-styles-a-quick-comparison">The Two Styles: A Quick Comparison</a></h2>
<p>Let's see both styles in action with a simple example:</p>
<pre><code class="language-java">@GenerateLenses
public record Person(String name, int age, String status) {}

Person person = new Person("Alice", 25, "ACTIVE");
Lens&lt;Person, Integer&gt; ageLens = PersonLenses.age();
</code></pre>
<h3 id="static-method-style-concise"><a class="header" href="#static-method-style-concise">Static Method Style (Concise)</a></h3>
<pre><code class="language-java">// Get a value
int age = OpticOps.get(person, ageLens);

// Set a value
Person updated = OpticOps.set(person, ageLens, 30);

// Modify a value
Person modified = OpticOps.modify(person, ageLens, a -&gt; a + 1);
</code></pre>
<h3 id="fluent-builder-style-explicit"><a class="header" href="#fluent-builder-style-explicit">Fluent Builder Style (Explicit)</a></h3>
<pre><code class="language-java">// Get a value
int age = OpticOps.getting(person).through(ageLens);

// Set a value
Person updated = OpticOps.setting(person).through(ageLens, 30);

// Modify a value
Person modified = OpticOps.modifying(person).through(ageLens, a -&gt; a + 1);
</code></pre>
<p>Both produce identical results. The choice is about <strong>readability</strong> and <strong>discoverability</strong> for your specific use case.</p>
<hr />
<h2 id="part-1-static-methods---simple-and-direct"><a class="header" href="#part-1-static-methods---simple-and-direct">Part 1: Static Methods - Simple and Direct</a></h2>
<p>Static methods provide the most concise syntax. They follow a consistent pattern: operation name, source object, optic, and optional parameters.</p>
<h3 id="getting-values"><a class="header" href="#getting-values">Getting Values</a></h3>
<h4 id="basic-get-operations"><a class="header" href="#basic-get-operations">Basic Get Operations</a></h4>
<pre><code class="language-java">// Get a required value (Lens or Getter)
String name = OpticOps.get(person, PersonLenses.name());

// Get an optional value (Prism or Traversal)
Optional&lt;Address&gt; address = OpticOps.preview(person, PersonPrisms.homeAddress());

// Get all values (Traversal or Fold)
List&lt;String&gt; playerNames = OpticOps.getAll(team, TeamTraversals.playerNames());
</code></pre>
<div id="admonition-practical-example-extracting-data" class="admonition admonish-example" role="note" aria-labelledby="admonition-practical-example-extracting-data-title">
<div class="admonition-title">
<div id="admonition-practical-example-extracting-data-title">
<p>Practical Example: Extracting Data</p>
</div>
<a class="admonition-anchor-link" href="optics/fluent_api.html#admonition-practical-example-extracting-data"></a>
</div>
<div>
<pre><code class="language-java">@GenerateLenses
@GenerateTraversals
public record Team(String name, List&lt;Player&gt; players) {}

@GenerateLenses
public record Player(String name, int score) {}

Team team = new Team("Wildcats",
    List.of(
        new Player("Alice", 100),
        new Player("Bob", 85)
    ));

// Get all player names
List&lt;String&gt; names = OpticOps.getAll(
    team,
    TeamTraversals.players().andThen(PlayerLenses.name().asTraversal())
);
// Result: ["Alice", "Bob"]
</code></pre>
</div>
</div>
<h3 id="setting-values"><a class="header" href="#setting-values">Setting Values</a></h3>
<pre><code class="language-java">// Set a single value (Lens)
Person updated = OpticOps.set(person, PersonLenses.age(), 30);

// Set all values (Traversal)
Team teamWithBonuses = OpticOps.setAll(
    team,
    TeamTraversals.players().andThen(PlayerLenses.score().asTraversal()),
    100  // Everyone gets 100 points!
);
</code></pre>
<h3 id="modifying-values"><a class="header" href="#modifying-values">Modifying Values</a></h3>
<p>The <code>modify</code> operations are particularly powerful because they transform existing values rather than replacing them:</p>
<pre><code class="language-java">// Modify a single value
Person olderPerson = OpticOps.modify(
    person,
    PersonLenses.age(),
    age -&gt; age + 1
);

// Modify all values
Team teamWithDoubledScores = OpticOps.modifyAll(
    team,
    TeamTraversals.players().andThen(PlayerLenses.score().asTraversal()),
    score -&gt; score * 2
);
</code></pre>
<h3 id="querying-data"><a class="header" href="#querying-data">Querying Data</a></h3>
<p>These operations work with <code>Fold</code> and <code>Traversal</code> to query data without modification:</p>
<pre><code class="language-java">// Check if any element matches
boolean hasHighScorer = OpticOps.exists(
    team,
    TeamTraversals.players().andThen(PlayerLenses.score().asTraversal()),
    score -&gt; score &gt; 90
);

// Check if all elements match
boolean allPassed = OpticOps.all(
    team,
    TeamTraversals.players().andThen(PlayerLenses.score().asTraversal()),
    score -&gt; score &gt;= 50
);

// Count elements
int playerCount = OpticOps.count(team, TeamTraversals.players());

// Check if empty
boolean noPlayers = OpticOps.isEmpty(team, TeamTraversals.players());

// Find first matching element
Optional&lt;Player&gt; topScorer = OpticOps.find(
    team,
    TeamTraversals.players(),
    player -&gt; player.score() &gt; 90
);
</code></pre>
<h3 id="effectful-modifications"><a class="header" href="#effectful-modifications">Effectful Modifications</a></h3>
<p>These are the most powerful operations, allowing modifications that can fail, accumulate errors, or execute asynchronously:</p>
<pre><code class="language-java">// Modify with an effect (e.g., validation)
// Note: Error should be your application's error type (e.g., String, List&lt;String&gt;, or a custom error class)
Functor&lt;Validated.Witness&lt;Error&gt;&gt; validatedFunctor =
    ValidatedApplicative.instance(ErrorSemigroup.instance());

Validated&lt;Error, Person&gt; result = OpticOps.modifyF(
    person,
    PersonLenses.age(),
    age -&gt; validateAge(age + 1),  // Returns Validated&lt;Error, Integer&gt;
    validatedFunctor
);

// Modify all with effects (e.g., async operations)
Applicative&lt;CompletableFutureKind.Witness&gt; cfApplicative =
    CompletableFutureMonad.instance();

CompletableFuture&lt;Team&gt; asyncResult = OpticOps.modifyAllF(
    team,
    TeamTraversals.players().andThen(PlayerLenses.score().asTraversal()),
    score -&gt; fetchBonusAsync(score),  // Returns CompletableFuture&lt;Integer&gt;
    cfApplicative
).thenApply(CompletableFutureKind::narrow);
</code></pre>
<hr />
<h2 id="part-2-fluent-builders---explicit-and-discoverable"><a class="header" href="#part-2-fluent-builders---explicit-and-discoverable">Part 2: Fluent Builders - Explicit and Discoverable</a></h2>
<p>Fluent builders provide excellent IDE support through method chaining. They make the intent of your code crystal clear.</p>
<h3 id="the-getbuilder-pattern"><a class="header" href="#the-getbuilder-pattern">The GetBuilder Pattern</a></h3>
<pre><code class="language-java">// Start with getting(source), then specify the optic
int age = OpticOps.getting(person).through(PersonLenses.age());

Optional&lt;Address&gt; addr = OpticOps.getting(person)
    .maybeThrough(PersonPrisms.homeAddress());

List&lt;String&gt; names = OpticOps.getting(team)
    .allThrough(TeamTraversals.playerNames());
</code></pre>
<h3 id="the-setbuilder-pattern"><a class="header" href="#the-setbuilder-pattern">The SetBuilder Pattern</a></h3>
<pre><code class="language-java">// Start with setting(source), then specify optic and value
Person updated = OpticOps.setting(person)
    .through(PersonLenses.age(), 30);

Team updatedTeam = OpticOps.setting(team)
    .allThrough(
        TeamTraversals.players().andThen(PlayerLenses.score().asTraversal()),
        100
    );
</code></pre>
<h3 id="the-modifybuilder-pattern"><a class="header" href="#the-modifybuilder-pattern">The ModifyBuilder Pattern</a></h3>
<pre><code class="language-java">// Start with modifying(source), then specify optic and function
Person modified = OpticOps.modifying(person)
    .through(PersonLenses.age(), age -&gt; age + 1);

Team modifiedTeam = OpticOps.modifying(team)
    .allThrough(
        TeamTraversals.players().andThen(PlayerLenses.score().asTraversal()),
        score -&gt; score * 2
    );

// Effectful modifications
Validated&lt;Error, Person&gt; result = OpticOps.modifying(person)
    .throughF(
        PersonLenses.age(),
        age -&gt; validateAge(age + 1),
        validatedFunctor
    );
</code></pre>
<h3 id="the-querybuilder-pattern"><a class="header" href="#the-querybuilder-pattern">The QueryBuilder Pattern</a></h3>
<pre><code class="language-java">// Start with querying(source), then specify checks
boolean hasHighScorer = OpticOps.querying(team)
    .anyMatch(
        TeamTraversals.players().andThen(PlayerLenses.score().asTraversal()),
        score -&gt; score &gt; 90
    );

boolean allPassed = OpticOps.querying(team)
    .allMatch(
        TeamTraversals.players().andThen(PlayerLenses.score().asTraversal()),
        score -&gt; score &gt;= 50
    );

Optional&lt;Player&gt; found = OpticOps.querying(team)
    .findFirst(TeamTraversals.players(), player -&gt; player.score() &gt; 90);

int count = OpticOps.querying(team)
    .count(TeamTraversals.players());

boolean empty = OpticOps.querying(team)
    .isEmpty(TeamTraversals.players());
</code></pre>
<hr />
<h2 id="part-25-validation-aware-modifications"><a class="header" href="#part-25-validation-aware-modifications">Part 2.5: Validation-Aware Modifications</a></h2>
<div id="admonition-core-types-integration" class="admonition admonish-tip" role="note" aria-labelledby="admonition-core-types-integration-title">
<div class="admonition-title">
<div id="admonition-core-types-integration-title">
<p>Core Types Integration</p>
</div>
<a class="admonition-anchor-link" href="optics/fluent_api.html#admonition-core-types-integration"></a>
</div>
<div>
<p>This section demonstrates <strong>Phase 2</strong> of the optics core types integration, which brings validation-aware modifications directly into <code>OpticOps</code>. These methods integrate seamlessly with higher-kinded-j's core types (<code>Either</code>, <code>Maybe</code>, <code>Validated</code>) to provide type-safe, composable validation workflows.</p>
</div>
</div>
<div id="admonition-comprehensive-example" class="admonition admonish-note" role="note" aria-labelledby="admonition-comprehensive-example-title">
<div class="admonition-title">
<div id="admonition-comprehensive-example-title">
<p>Comprehensive Example</p>
</div>
<a class="admonition-anchor-link" href="optics/fluent_api.html#admonition-comprehensive-example"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/fluent/FluentValidationExample.java">FluentValidationExample</a></p>
</div>
</div>
<h3 id="think-of-validation-aware-modifications-like"><a class="header" href="#think-of-validation-aware-modifications-like">Think of Validation-Aware Modifications Like...</a></h3>
<ul>
<li><strong>A quality control checkpoint</strong> - Every modification must pass validation before being applied</li>
<li><strong>Airport security screening</strong> - Some checks stop at the first issue (fast-track), others collect all problems (thorough inspection)</li>
<li><strong>Form validation on a website</strong> - You can show either the first error or all errors at once</li>
<li><strong>Code review process</strong> - Accumulate all feedback rather than stopping at the first comment</li>
</ul>
<h3 id="the-challenge-validation-during-updates"><a class="header" href="#the-challenge-validation-during-updates">The Challenge: Validation During Updates</a></h3>
<p>Traditional optic operations assume modifications always succeed. But in real applications, updates often need validation:</p>
<pre><code class="language-java">// Problem: No validation during modification
Person updated = OpticOps.modify(person, PersonLenses.age(), age -&gt; age + 1);
// What if the new age is invalid? No way to handle errors!

// Problem: Manual validation is verbose and error-prone
int currentAge = OpticOps.get(person, PersonLenses.age());
if (currentAge + 1 &gt;= 0 &amp;&amp; currentAge + 1 &lt;= 120) {
    person = OpticOps.set(person, PersonLenses.age(), currentAge + 1);
} else {
    // Handle error... but how do we return both success and failure?
}
</code></pre>
<p><strong>Validation-aware modifications</strong> solve this by integrating validation directly into the optic operation, returning a result type that represents either success or failure.</p>
<h3 id="the-solution-four-validation-strategies"><a class="header" href="#the-solution-four-validation-strategies">The Solution: Four Validation Strategies</a></h3>
<p><code>OpticOps</code> provides four complementary validation methods, each suited to different scenarios:</p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Core Type</th><th>Behaviour</th><th>Best For</th></tr></thead><tbody>
<tr><td><code>modifyEither</code></td><td><code>Either&lt;E, S&gt;</code></td><td>Short-circuit on first error</td><td>Sequential validation, fail-fast workflows</td></tr>
<tr><td><code>modifyMaybe</code></td><td><code>Maybe&lt;S&gt;</code></td><td>Success or nothing (no error details)</td><td>Optional enrichment, silent failure</td></tr>
<tr><td><code>modifyAllValidated</code></td><td><code>Validated&lt;List&lt;E&gt;, S&gt;</code></td><td>Accumulate ALL errors</td><td>Form validation, comprehensive feedback</td></tr>
<tr><td><code>modifyAllEither</code></td><td><code>Either&lt;E, S&gt;</code></td><td>Stop at first error in collection</td><td>Performance-critical batch validation</td></tr>
</tbody></table>
</div><div id="admonition-quick-comparison" class="admonition admonish-example" role="note" aria-labelledby="admonition-quick-comparison-title">
<div class="admonition-title">
<div id="admonition-quick-comparison-title">
<p>Quick Comparison</p>
</div>
<a class="admonition-anchor-link" href="optics/fluent_api.html#admonition-quick-comparison"></a>
</div>
<div>
<pre><code class="language-java">// Same validation logic, different error handling strategies
Order order = new Order("ORD-123", List.of(
    new BigDecimal("-10.00"),    // Invalid: negative
    new BigDecimal("15000.00")   // Invalid: too high
));

// Strategy 1: Either - stops at FIRST error
Either&lt;String, Order&gt; result1 = OpticOps.modifyAllEither(
    order, orderPricesTraversal, price -&gt; validatePrice(price)
);
// Result: Left("Price cannot be negative: -10.00")

// Strategy 2: Validated - collects ALL errors
Validated&lt;List&lt;String&gt;, Order&gt; result2 = OpticOps.modifyAllValidated(
    order, orderPricesTraversal, price -&gt; validatePrice(price)
);
// Result: Invalid(["Price cannot be negative: -10.00",
//                  "Price exceeds maximum: 15000.00"])
</code></pre>
</div>
</div>
<h3 id="static-method-style-validation-operations"><a class="header" href="#static-method-style-validation-operations">Static Method Style: Validation Operations</a></h3>
<h4 id="single-field-validation-with-modifyeither"><a class="header" href="#single-field-validation-with-modifyeither">Single-Field Validation with <code>modifyEither</code></a></h4>
<p>Perfect for validating and modifying a single field where you want to fail fast with detailed error messages.</p>
<pre><code class="language-java">@GenerateLenses
public record User(String username, String email, int age) {}

// Validate email format
Either&lt;String, User&gt; result = OpticOps.modifyEither(
    user,
    UserLenses.email(),
    email -&gt; {
        if (email.matches("^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$")) {
            return Either.right(email);  // Valid
        } else {
            return Either.left("Invalid email format: " + email);  // Error
        }
    }
);

// Handle the result
result.fold(
    error -&gt; {
        log.error("Validation failed: {}", error);
        return null;
    },
    validUser -&gt; {
        log.info("User updated: {}", validUser.email());
        return null;
    }
);
</code></pre>
<h4 id="optional-validation-with-modifymaybe"><a class="header" href="#optional-validation-with-modifymaybe">Optional Validation with <code>modifyMaybe</code></a></h4>
<p>Useful when validation failure shouldn't produce error messages: either it works or it doesn't.</p>
<pre><code class="language-java">// Trim and validate bio (silent failure if too long)
Maybe&lt;User&gt; result = OpticOps.modifyMaybe(
    user,
    UserLenses.bio(),
    bio -&gt; {
        String trimmed = bio.trim();
        if (trimmed.length() &lt;= 500) {
            return Maybe.just(trimmed);  // Success
        } else {
            return Maybe.nothing();  // Too long, fail silently
        }
    }
);

// Check if validation succeeded
if (result.isJust()) {
    User validUser = result.get();
    // Proceed with valid user
} else {
    // Validation failed, use fallback logic
}
</code></pre>
<h4 id="multi-field-validation-with-error-accumulation"><a class="header" href="#multi-field-validation-with-error-accumulation">Multi-Field Validation with Error Accumulation</a></h4>
<p>The most powerful option: validate multiple fields and collect <strong>all</strong> validation errors, not just the first one.</p>
<pre><code class="language-java">@GenerateTraversals
public record Order(String orderId, List&lt;BigDecimal&gt; itemPrices) {}

// Validate ALL prices and accumulate errors
Validated&lt;List&lt;String&gt;, Order&gt; result = OpticOps.modifyAllValidated(
    order,
    orderPricesTraversal,
    price -&gt; {
        if (price.compareTo(BigDecimal.ZERO) &lt; 0) {
            return Validated.invalid("Price cannot be negative: " + price);
        } else if (price.compareTo(new BigDecimal("10000")) &gt; 0) {
            return Validated.invalid("Price exceeds maximum: " + price);
        } else {
            return Validated.valid(price);  // Valid price
        }
    }
);

// Handle accumulated errors
result.fold(
    errors -&gt; {
        System.out.println("Validation failed with " + errors.size() + " errors:");
        errors.forEach(error -&gt; System.out.println("  - " + error));
        return null;
    },
    validOrder -&gt; {
        System.out.println("All prices validated successfully!");
        return null;
    }
);
</code></pre>
<h4 id="multi-field-validation-with-short-circuiting"><a class="header" href="#multi-field-validation-with-short-circuiting">Multi-Field Validation with Short-Circuiting</a></h4>
<p>When you have many fields to validate but want to stop at the first error (better performance, less detailed feedback):</p>
<pre><code class="language-java">// Validate all prices, stop at FIRST error
Either&lt;String, Order&gt; result = OpticOps.modifyAllEither(
    order,
    orderPricesTraversal,
    price -&gt; validatePrice(price)  // Returns Either&lt;String, BigDecimal&gt;
);

// Only the first error is reported
result.fold(
    firstError -&gt; System.out.println("Failed: " + firstError),
    validOrder -&gt; System.out.println("Success!")
);
</code></pre>
<h3 id="fluent-builder-style-modifyingwithvalidation"><a class="header" href="#fluent-builder-style-modifyingwithvalidation">Fluent Builder Style: ModifyingWithValidation</a></h3>
<p>The fluent API provides a dedicated builder for validation-aware modifications, making the intent even clearer:</p>
<pre><code class="language-java">// Start with modifyingWithValidation(source), then choose validation strategy

// Single field with Either
Either&lt;String, User&gt; result1 = OpticOps.modifyingWithValidation(user)
    .throughEither(UserLenses.email(), email -&gt; validateEmail(email));

// Single field with Maybe
Maybe&lt;User&gt; result2 = OpticOps.modifyingWithValidation(user)
    .throughMaybe(UserLenses.bio(), bio -&gt; validateBio(bio));

// All fields with Validated (error accumulation)
Validated&lt;List&lt;String&gt;, Order&gt; result3 = OpticOps.modifyingWithValidation(order)
    .allThroughValidated(orderPricesTraversal, price -&gt; validatePrice(price));

// All fields with Either (short-circuit)
Either&lt;String, Order&gt; result4 = OpticOps.modifyingWithValidation(order)
    .allThroughEither(orderPricesTraversal, price -&gt; validatePrice(price));
</code></pre>
<h3 id="real-world-scenario-user-registration"><a class="header" href="#real-world-scenario-user-registration">Real-World Scenario: User Registration</a></h3>
<p>Let's see how to use validation-aware modifications for a complete user registration workflow:</p>
<pre><code class="language-java">@GenerateLenses
public record UserRegistration(String username, String email, int age, String bio) {}

// Scenario: Sequential validation (stop at first error)
Either&lt;String, UserRegistration&gt; validateRegistration(UserRegistration form) {
    return OpticOps.modifyEither(form, UserLenses.username(), this::validateUsername)
        .flatMap(user -&gt; OpticOps.modifyEither(user, UserLenses.email(), this::validateEmail))
        .flatMap(user -&gt; OpticOps.modifyEither(user, UserLenses.age(), this::validateAge))
        .flatMap(user -&gt; OpticOps.modifyEither(user, UserLenses.bio(), this::validateBio));
}

private Either&lt;String, String&gt; validateUsername(String username) {
    if (username.length() &lt; 3) {
        return Either.left("Username must be at least 3 characters");
    }
    if (username.length() &gt; 20) {
        return Either.left("Username must not exceed 20 characters");
    }
    if (!username.matches("^[a-zA-Z0-9_]+$")) {
        return Either.left("Username can only contain letters, numbers, and underscores");
    }
    return Either.right(username);
}

// Usage
validateRegistration(formData).fold(
    error -&gt; {
        System.out.println("Registration failed: " + error);
        // Show error to user, stop processing
        return null;
    },
    validForm -&gt; {
        System.out.println("Registration successful!");
        // Proceed with user creation
        return null;
    }
);
</code></pre>
<h3 id="real-world-scenario-bulk-data-import"><a class="header" href="#real-world-scenario-bulk-data-import">Real-World Scenario: Bulk Data Import</a></h3>
<p>When importing data, you often want to collect <strong>all</strong> validation errors to give comprehensive feedback:</p>
<pre><code class="language-java">@GenerateTraversals
public record DataImport(List&lt;String&gt; emailAddresses, String importedBy) {}

// Validate all emails, accumulate ALL errors
Validated&lt;List&lt;String&gt;, DataImport&gt; validateImport(DataImport importData) {
    return OpticOps.modifyingWithValidation(importData)
        .allThroughValidated(
            DataImportTraversals.emailAddresses(),
            email -&gt; {
                if (!email.matches("^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$")) {
                    return Validated.invalid("Invalid email: " + email);
                } else {
                    return Validated.valid(email.toLowerCase().trim());  // Normalise
                }
            }
        );
}

// Usage
validateImport(importBatch).fold(
    errors -&gt; {
        System.out.println("Import failed with " + errors.size() + " invalid emails:");
        errors.forEach(error -&gt; System.out.println("  - " + error));
        // User can fix ALL errors at once
        return null;
    },
    validImport -&gt; {
        System.out.println("Import successful! " +
                          validImport.emailAddresses().size() +
                          " emails validated.");
        return null;
    }
);
</code></pre>
<h3 id="when-to-use-each-validation-strategy"><a class="header" href="#when-to-use-each-validation-strategy">When to Use Each Validation Strategy</a></h3>
<h4 id="use-modifyeither-when"><a class="header" href="#use-modifyeither-when">Use <code>modifyEither</code> When:</a></h4>
<p><strong>Sequential workflows</strong> where you want to stop at the first error</p>
<pre><code class="language-java">// Login validation - stop at first failure
OpticOps.modifyEither(credentials, CredentialsLenses.username(), this::validateUsername)
    .flatMap(c -&gt; OpticOps.modifyEither(c, CredentialsLenses.password(), this::checkPassword))
</code></pre>
<p><strong>Single-field validation</strong> with detailed error messages</p>
<p><strong>Early exit is beneficial</strong> (no point continuing if a critical field is invalid)</p>
<h4 id="use-modifymaybe-when"><a class="header" href="#use-modifymaybe-when">Use <code>modifyMaybe</code> When:</a></h4>
<p><strong>Optional enrichment</strong> where failure is acceptable</p>
<pre><code class="language-java">// Try to geocode address, but it's okay if it fails
OpticOps.modifyMaybe(order, OrderLenses.address(), addr -&gt; geocodeAddress(addr))
</code></pre>
<p><strong>Error details aren't needed</strong> (just success/failure)</p>
<p><strong>Silent failures are acceptable</strong></p>
<h4 id="use-modifyallvalidated-when"><a class="header" href="#use-modifyallvalidated-when">Use <code>modifyAllValidated</code> When:</a></h4>
<p><strong>Form validation</strong> where users need to see all errors at once</p>
<pre><code class="language-java">// Show all validation errors on a registration form
OpticOps.modifyAllValidated(form, formFieldsTraversal, this::validateField)
</code></pre>
<p><strong>Comprehensive feedback is important</strong></p>
<p><strong>User experience matters</strong> (fixing all errors in one go)</p>
<h4 id="use-modifyalleither-when"><a class="header" href="#use-modifyalleither-when">Use <code>modifyAllEither</code> When:</a></h4>
<p><strong>Performance is critical</strong> and you have many fields to validate</p>
<p><strong>First error is sufficient</strong> for debugging or logging</p>
<p><strong>Resource-intensive validation</strong> where stopping early saves time</p>
<h3 id="comparison-with-traditional-modifyf"><a class="header" href="#comparison-with-traditional-modifyf">Comparison with Traditional <code>modifyF</code></a></h3>
<p>The validation methods simplify common patterns that previously required manual <code>Applicative</code> wiring:</p>
<p><strong>Before (using <code>modifyF</code>):</strong></p>
<pre><code class="language-java">// Manual applicative construction with explicit error type conversion
Applicative&lt;Validated.Witness&lt;List&lt;String&gt;&gt;&gt; app =
    ValidatedApplicative.instance(ListSemigroup.instance());

Validated&lt;List&lt;String&gt;, Order&gt; result = OpticOps.modifyAllF(
    order,
    orderPricesTraversal,
    price -&gt; {
        Validated&lt;String, BigDecimal&gt; validatedPrice = validatePrice(price);
        // Must convert error type from String to List&lt;String&gt;
        return ValidatedKindHelper.VALIDATED.widen(
            validatedPrice.bimap(List::of, Function.identity())
        );
    },
    app
).narrow();
</code></pre>
<p><strong>After (using <code>modifyAllValidated</code>):</strong></p>
<pre><code class="language-java">// Clean, concise, and clear intent
Validated&lt;List&lt;String&gt;, Order&gt; result = OpticOps.modifyAllValidated(
    order,
    orderPricesTraversal,
    price -&gt; validatePrice(price)
);
</code></pre>
<div id="admonition-when-to-use-modifyf" class="admonition admonish-info" role="note" aria-labelledby="admonition-when-to-use-modifyf-title">
<div class="admonition-title">
<div id="admonition-when-to-use-modifyf-title">
<p>When to Use modifyF</p>
</div>
<a class="admonition-anchor-link" href="optics/fluent_api.html#admonition-when-to-use-modifyf"></a>
</div>
<div>
<p>The traditional <code>modifyF</code> methods are still valuable for:</p>
<ul>
<li>Custom effect types beyond <code>Either</code>, <code>Maybe</code>, and <code>Validated</code></li>
<li>Advanced applicative scenarios with custom combinators</li>
<li>Asynchronous validation (e.g., <code>CompletableFuture</code>)</li>
<li>Integration with third-party effect systems</li>
</ul>
<p>For standard validation scenarios, the dedicated methods are clearer and more concise.</p>
</div>
</div>
<h3 id="performance-considerations-7"><a class="header" href="#performance-considerations-7">Performance Considerations</a></h3>
<ul>
<li><strong><code>Either</code> short-circuiting</strong>: Stops at first error, potentially faster for large collections</li>
<li><strong><code>Validated</code> accumulation</strong>: Checks all elements, more work but better UX</li>
<li><strong><code>Maybe</code></strong>: Minimal overhead, just success/nothing</li>
<li><strong>Object allocation</strong>: All methods create new result objects (standard immutable pattern)</li>
</ul>
<div id="admonition-optimisation-strategy" class="admonition admonish-tip" role="note" aria-labelledby="admonition-optimisation-strategy-title">
<div class="admonition-title">
<div id="admonition-optimisation-strategy-title">
<p>Optimisation Strategy</p>
</div>
<a class="admonition-anchor-link" href="optics/fluent_api.html#admonition-optimisation-strategy"></a>
</div>
<div>
<p>For performance-critical code with large collections:</p>
<ol>
<li>Use <code>modifyAllEither</code> if first-error is acceptable</li>
<li>Use <code>modifyAllValidated</code> if comprehensive errors are required</li>
<li>Consider pre-filtering with <code>Stream</code> API before validation</li>
<li>Cache compiled validators (e.g., compiled regex patterns)</li>
</ol>
</div>
</div>
<h3 id="integration-with-existing-validation"><a class="header" href="#integration-with-existing-validation">Integration with Existing Validation</a></h3>
<p>Validation-aware modifications work seamlessly with existing validation libraries:</p>
<pre><code class="language-java">// Jakarta Bean Validation integration
import jakarta.validation.Validator;
import jakarta.validation.ConstraintViolation;

Either&lt;List&lt;String&gt;, User&gt; validateWithJakarta(User user, Validator validator) {
    return OpticOps.modifyEither(
        user,
        UserLenses.email(),
        email -&gt; {
            Set&lt;ConstraintViolation&lt;String&gt;&gt; violations =
                validator.validate(email);

            if (violations.isEmpty()) {
                return Either.right(email);
            } else {
                return Either.left(
                    violations.stream()
                        .map(ConstraintViolation::getMessage)
                        .collect(Collectors.toList())
                );
            }
        }
    );
}
</code></pre>
<hr />
<h2 id="part-3-real-world-examples"><a class="header" href="#part-3-real-world-examples">Part 3: Real-World Examples</a></h2>
<h3 id="example-1-e-commerce-order-processing"><a class="header" href="#example-1-e-commerce-order-processing">Example 1: E-Commerce Order Processing</a></h3>
<pre><code class="language-java">@GenerateLenses
@GenerateTraversals
public record Order(String orderId,
                    OrderStatus status,
                    List&lt;OrderItem&gt; items,
                    ShippingAddress address) {}

@GenerateLenses
public record OrderItem(String productId, int quantity, BigDecimal price) {}

@GenerateLenses
public record ShippingAddress(String street, String city, String postCode) {}

// Scenario: Apply bulk discount and update shipping
Order processOrder(Order order, BigDecimal discountPercent) {
    // Apply discount using fluent API
    Order discountedOrder = OpticOps.modifying(order)
        .allThrough(
            OrderTraversals.items().andThen(OrderItemLenses.price().asTraversal()),
            price -&gt; price.multiply(BigDecimal.ONE.subtract(discountPercent))
        );

    // Update status using static method
    return OpticOps.set(
        discountedOrder,
        OrderLenses.status(),
        OrderStatus.PROCESSING
    );
}
</code></pre>
<h3 id="example-2-validation-with-error-accumulation"><a class="header" href="#example-2-validation-with-error-accumulation">Example 2: Validation with Error Accumulation</a></h3>
<pre><code class="language-java">// Using Validated to accumulate all validation errors
Validated&lt;List&lt;String&gt;, Order&gt; validateOrder(Order order) {
    Applicative&lt;Validated.Witness&lt;List&lt;String&gt;&gt;&gt; applicative =
        ValidatedApplicative.instance(ListSemigroup.instance());

    // Validate all item quantities
    return OpticOps.modifyAllF(
        order,
        OrderTraversals.items().andThen(OrderItemLenses.quantity().asTraversal()),
        qty -&gt; {
            if (qty &gt; 0 &amp;&amp; qty &lt;= 1000) {
                return Validated.valid(qty);
            } else {
                return Validated.invalid(List.of(
                    "Quantity must be between 1 and 1000, got: " + qty
                ));
            }
        },
        applicative
    ).narrow();
}
</code></pre>
<h3 id="example-3-async-database-updates"><a class="header" href="#example-3-async-database-updates">Example 3: Async Database Updates</a></h3>
<pre><code class="language-java">// Using CompletableFuture for async operations
CompletableFuture&lt;Team&gt; updatePlayerScoresAsync(
    Team team,
    Function&lt;Player, CompletableFuture&lt;Integer&gt;&gt; fetchNewScore
) {
    Applicative&lt;CompletableFutureKind.Witness&gt; cfApplicative =
        CompletableFutureMonad.instance();

    return OpticOps.modifyAllF(
        team,
        TeamTraversals.players(),
        player -&gt; fetchNewScore.apply(player)
            .thenApply(newScore -&gt;
                OpticOps.set(player, PlayerLenses.score(), newScore)
            )
            .thenApply(CompletableFutureKind::of),
        cfApplicative
    ).thenApply(kind -&gt; CompletableFutureKind.narrow(kind).join());
}
</code></pre>
<hr />
<h2 id="when-to-use-each-style"><a class="header" href="#when-to-use-each-style">When to Use Each Style</a></h2>
<h3 id="use-static-methods-when"><a class="header" href="#use-static-methods-when">Use Static Methods When:</a></h3>
<p><strong>Performing simple, one-off operations</strong></p>
<pre><code class="language-java">// Clear and concise
String name = OpticOps.get(person, PersonLenses.name());
</code></pre>
<p><strong>Chaining is not needed</strong></p>
<pre><code class="language-java">// Direct transformation
Person older = OpticOps.modify(person, PersonLenses.age(), a -&gt; a + 1);
</code></pre>
<p><strong>Performance is critical</strong> (slightly less object allocation)</p>
<h3 id="use-fluent-builders-when"><a class="header" href="#use-fluent-builders-when">Use Fluent Builders When:</a></h3>
<p><strong>Building complex workflows</strong></p>
<pre><code class="language-java">import static java.util.stream.Collectors.toList;

// Clear intent at each step
return OpticOps.getting(order)
    .allThrough(OrderTraversals.items())
    .stream()
    .filter(item -&gt; item.quantity() &gt; 10)
    .map(OrderItem::productId)
    .collect(toList());
</code></pre>
<p><strong>IDE autocomplete is important</strong> (great for discovery)</p>
<p><strong>Code reviews matter</strong> (explicit intent)</p>
<p><strong>Teaching or documentation</strong> (self-explanatory)</p>
<hr />
<h2 id="common-patterns-and-idioms"><a class="header" href="#common-patterns-and-idioms">Common Patterns and Idioms</a></h2>
<h3 id="pattern-1-pipeline-transformations"><a class="header" href="#pattern-1-pipeline-transformations">Pattern 1: Pipeline Transformations</a></h3>
<pre><code class="language-java">// Sequential transformations for multi-step pipeline
// Note: Result and Data should be your application's domain types with appropriate lenses
Result processData(Data input) {
    Data afterStage1 = OpticOps.modifying(input)
        .through(DataLenses.stage1(), this::transformStage1);

    Data afterStage2 = OpticOps.modifying(afterStage1)
        .through(DataLenses.stage2(), this::transformStage2);

    return OpticOps.modifying(afterStage2)
        .through(DataLenses.stage3(), this::transformStage3);
}
</code></pre>
<h3 id="pattern-2-conditional-updates"><a class="header" href="#pattern-2-conditional-updates">Pattern 2: Conditional Updates</a></h3>
<pre><code class="language-java">// Static style for simple conditionals
Person updateIfAdult(Person person) {
    int age = OpticOps.get(person, PersonLenses.age());
    return age &gt;= 18
        ? OpticOps.set(person, PersonLenses.status(), "ADULT")
        : person;
}
</code></pre>
<h3 id="pattern-3-bulk-operations-with-filtering"><a class="header" href="#pattern-3-bulk-operations-with-filtering">Pattern 3: Bulk Operations with Filtering</a></h3>
<pre><code class="language-java">// Combine both styles for clarity
Team updateTopPerformers(Team team, int threshold) {
    // Use fluent for query
    List&lt;Player&gt; topPerformers = OpticOps.querying(team)
        .allThrough(TeamTraversals.players())
        .stream()
        .filter(p -&gt; p.score() &gt;= threshold)
        .toList();

    // Use static for transformation
    return OpticOps.modifyAll(
        team,
        TeamTraversals.players(),
        player -&gt; topPerformers.contains(player)
            ? OpticOps.set(player, PlayerLenses.status(), "STAR")
            : player
    );
}
</code></pre>
<hr />
<h2 id="performance-considerations-8"><a class="header" href="#performance-considerations-8">Performance Considerations</a></h2>
<h3 id="object-allocation"><a class="header" href="#object-allocation">Object Allocation</a></h3>
<ul>
<li><strong>Static methods</strong>: Minimal allocation (just the result)</li>
<li><strong>Fluent builders</strong>: Create intermediate builder objects</li>
<li><strong>Impact</strong>: Negligible for most applications; avoid in tight loops</li>
</ul>
<h3 id="optic-composition"><a class="header" href="#optic-composition">Optic Composition</a></h3>
<p>Both styles benefit from composing optics once and reusing them:</p>
<pre><code class="language-java">// Good: Compose once, use many times
Lens&lt;Order, BigDecimal&gt; orderToTotalPrice =
    OrderTraversals.items()
        .andThen(OrderItemLenses.price().asTraversal())
        .andThen(someAggregationLens);

orders.stream()
    .map(order -&gt; OpticOps.getAll(order, orderToTotalPrice))
    .collect(toList());

// Avoid: Recomposing in loop
orders.stream()
    .map(order -&gt; OpticOps.getAll(
        order,
        OrderTraversals.items()
            .andThen(OrderItemLenses.price().asTraversal())  // Recomposed each time!
    ))
    .collect(toList());
</code></pre>
<hr />
<h2 id="integration-with-existing-java-code"><a class="header" href="#integration-with-existing-java-code">Integration with Existing Java Code</a></h2>
<h3 id="working-with-streams"><a class="header" href="#working-with-streams">Working with Streams</a></h3>
<pre><code class="language-java">// Optics integrate naturally with Stream API
List&lt;String&gt; highScorerNames = OpticOps.getting(team)
    .allThrough(TeamTraversals.players())
    .stream()
    .filter(p -&gt; p.score() &gt; 90)
    .map(p -&gt; OpticOps.get(p, PlayerLenses.name()))
    .collect(toList());
</code></pre>
<h3 id="working-with-optional"><a class="header" href="#working-with-optional">Working with Optional</a></h3>
<pre><code class="language-java">// Optics and Optional work together
Optional&lt;Person&gt; maybePerson = findPerson(id);

Optional&lt;Integer&gt; age = maybePerson
    .map(p -&gt; OpticOps.get(p, PersonLenses.age()));

Person updated = maybePerson
    .map(p -&gt; OpticOps.modify(p, PersonLenses.age(), a -&gt; a + 1))
    .orElse(new Person("Default", 0, "UNKNOWN"));
</code></pre>
<hr />
<h2 id="common-pitfalls-25"><a class="header" href="#common-pitfalls-25">Common Pitfalls</a></h2>
<h3 id="dont-call-get-then-set"><a class="header" href="#dont-call-get-then-set">Don't: Call <code>get</code> then <code>set</code></a></h3>
<pre><code class="language-java">// Inefficient - two traversals
int age = OpticOps.get(person, PersonLenses.age());
Person updated = OpticOps.set(person, PersonLenses.age(), age + 1);
</code></pre>
<h3 id="do-use-modify"><a class="header" href="#do-use-modify">Do: Use <code>modify</code></a></h3>
<pre><code class="language-java">// Efficient - single traversal
Person updated = OpticOps.modify(person, PersonLenses.age(), a -&gt; a + 1);
</code></pre>
<h3 id="dont-recompose-optics-unnecessarily"><a class="header" href="#dont-recompose-optics-unnecessarily">Don't: Recompose optics unnecessarily</a></h3>
<pre><code class="language-java">// Bad - composing in a loop
for (Order order : orders) {
    var itemPrices = OrderTraversals.items()
        .andThen(OrderItemLenses.price().asTraversal());  // Composed each iteration!
    process(OpticOps.getAll(order, itemPrices));
}
</code></pre>
<h3 id="do-compose-once-reuse"><a class="header" href="#do-compose-once-reuse">Do: Compose once, reuse</a></h3>
<pre><code class="language-java">// Good - compose outside loop
var itemPrices = OrderTraversals.items()
    .andThen(OrderItemLenses.price().asTraversal());

for (Order order : orders) {
    process(OpticOps.getAll(order, itemPrices));
}
</code></pre>
<hr />
<div id="admonition-further-reading" class="admonition admonish-tip" role="note" aria-labelledby="admonition-further-reading-title">
<div class="admonition-title">
<div id="admonition-further-reading-title">
<p>Further Reading</p>
</div>
<a class="admonition-anchor-link" href="optics/fluent_api.html#admonition-further-reading"></a>
</div>
<div>
<ul>
<li><strong>Martin Fowler</strong>: <a href="https://martinfowler.com/bliki/FluentInterface.html">Fluent Interface</a> - The original pattern description</li>
<li><strong>Haskell Lens</strong>: <a href="https://hackage.haskell.org/package/lens-tutorial">Lens Tutorial</a> - Deeper theoretical understanding</li>
</ul>
</div>
</div>
<div id="admonition-hands-on-learning" class="admonition admonish-info" role="note" aria-labelledby="admonition-hands-on-learning-title">
<div class="admonition-title">
<div id="admonition-hands-on-learning-title">
<p>Hands-On Learning</p>
</div>
<a class="admonition-anchor-link" href="optics/fluent_api.html#admonition-hands-on-learning"></a>
</div>
<div>
<p>Practice the fluent API in <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/optics/Tutorial09_FluentOpticsAPI.java">Tutorial 09: Fluent Optics API</a> (7 exercises, ~10 minutes).</p>
</div>
</div>
<hr />
<p><strong>Next Steps:</strong></p>
<ul>
<li><a href="optics/free_monad_dsl.html">Free Monad DSL for Optics</a> - Build composable programs</li>
<li><a href="optics/interpreters.html">Optic Interpreters</a> - Multiple execution strategies</li>
<li><a href="optics/composing_optics.html">Advanced Patterns</a> - Complex real-world scenarios</li>
</ul>
<hr />
<p><strong>Previous:</strong> <a href="optics/kind_field_support.html">Kind Field Support</a>
<strong>Next:</strong> <a href="optics/free_monad_dsl.html">Free Monad DSL</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="free-monad-dsl-composable-optic-programs"><a class="header" href="#free-monad-dsl-composable-optic-programs">Free Monad DSL: Composable Optic Programs</a></h1>
<p><img src="optics/../images/lens2.jpg" alt="free_monad.jpg" /></p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="optics/free_monad_dsl.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>What Free monads are and why they're powerful for optics</li>
<li>How to build composable optic programs step by step</li>
<li>Separating program description from execution</li>
<li>Using conditional logic and branching in programs</li>
<li>Real-world scenarios: audit trails, validation, and testing</li>
<li>Creating reusable program fragments</li>
</ul>
</div>
</div>
<div id="admonition-hands-on-practice" class="admonition admonish-note" role="note" aria-labelledby="admonition-hands-on-practice-title">
<div class="admonition-title">
<div id="admonition-hands-on-practice-title">
<p>Hands On Practice</p>
</div>
<a class="admonition-anchor-link" href="optics/free_monad_dsl.html#admonition-hands-on-practice"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/optics/Tutorial11_AdvancedOpticsDSL.java">Tutorial11_AdvancedOpticsDSL.java</a></p>
</div>
</div>
<div id="admonition-example-code" class="admonition admonish-note" role="note" aria-labelledby="admonition-example-code-title">
<div class="admonition-title">
<div id="admonition-example-code-title">
<p>Example Code</p>
</div>
<a class="admonition-anchor-link" href="optics/free_monad_dsl.html#admonition-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/fluent/FreeMonadOpticDSLExample.java">FreeMonadOpticDSLExample</a></p>
</div>
</div>
<h2 id="introduction-beyond-immediate-execution"><a class="header" href="#introduction-beyond-immediate-execution">Introduction: Beyond Immediate Execution</a></h2>
<p>When you use optics directly, they execute immediately. You read a value, transform a field, update a structure; all happens right away. This direct execution is perfect for simple cases, but what if you need more?</p>
<p>Consider these real-world requirements:</p>
<ul>
<li><strong>Audit trails</strong>: Record every data change for compliance</li>
<li><strong>Validation</strong>: Check all constraints before making any changes</li>
<li><strong>Testing</strong>: Verify your logic without touching real data</li>
<li><strong>Optimisation</strong>: Analyse and fuse multiple operations for efficiency</li>
<li><strong>Dry-runs</strong>: See what would change without actually changing it</li>
</ul>
<p>This is where the Free monad DSL comes in. It lets you <strong>describe</strong> a sequence of optic operations as data, then <strong>interpret</strong> that description in different ways.</p>
<div id="admonition-the-core-insight" class="admonition admonish-tip" role="note" aria-labelledby="admonition-the-core-insight-title">
<div class="admonition-title">
<div id="admonition-the-core-insight-title">
<p>The Core Insight</p>
</div>
<a class="admonition-anchor-link" href="optics/free_monad_dsl.html#admonition-the-core-insight"></a>
</div>
<div>
<p>A Free monad program is like a recipe. Writing the recipe doesn't cook the meal; it just describes what to do. You can review the recipe, validate it, translate it, or follow it to cook. The Free monad DSL gives you that same power with optic operations.</p>
</div>
</div>
<hr />
<h2 id="part-1-understanding-free-monads-gently"><a class="header" href="#part-1-understanding-free-monads-gently">Part 1: Understanding Free Monads (Gently)</a></h2>
<h3 id="what-is-a-free-monad"><a class="header" href="#what-is-a-free-monad">What Is a Free Monad?</a></h3>
<p>A Free monad is a way to build a <strong>program as data</strong>. Instead of executing operations immediately, you construct a data structure that describes what operations to perform. Later, you choose how to execute (interpret) that structure.</p>
<p>Think of it like this:</p>
<pre><code class="language-java">// Direct execution (happens immediately)
Person updated = PersonLenses.age().set(30, person);

// Free monad (just builds a description)
Free&lt;OpticOpKind.Witness, Person&gt; program =
    OpticPrograms.set(person, PersonLenses.age(), 30);
// Nothing happened yet! We just described what to do.

// Now we choose how to interpret it
Person result = OpticInterpreters.direct().run(program);
// NOW it executed
</code></pre>
<h3 id="why-is-this-useful"><a class="header" href="#why-is-this-useful">Why Is This Useful?</a></h3>
<p>By separating <strong>description</strong> from <strong>execution</strong>, you can:</p>
<ol>
<li><strong>Review</strong> the program before running it</li>
<li><strong>Validate</strong> all operations without executing them</li>
<li><strong>Log</strong> every operation for audit trails</li>
<li><strong>Test</strong> the logic with mock data</li>
<li><strong>Transform</strong> the program (optimise, translate, etc.)</li>
</ol>
<p>For optics specifically, this means you can build complex data transformation workflows and then choose how to execute them based on your needs.</p>
<hr />
<h2 id="part-2-building-your-first-optic-program"><a class="header" href="#part-2-building-your-first-optic-program">Part 2: Building Your First Optic Program</a></h2>
<h3 id="simple-programs-get-set-modify"><a class="header" href="#simple-programs-get-set-modify">Simple Programs: Get, Set, Modify</a></h3>
<p>Let's start with the basics:</p>
<pre><code class="language-java">@GenerateLenses
public record Person(String name, int age, String status) {}

Person person = new Person("Alice", 25, "ACTIVE");

// Build a program that gets the age
Free&lt;OpticOpKind.Witness, Integer&gt; getProgram =
    OpticPrograms.get(person, PersonLenses.age());

// Build a program that sets the age
Free&lt;OpticOpKind.Witness, Person&gt; setProgram =
    OpticPrograms.set(person, PersonLenses.age(), 30);

// Build a program that modifies the age
Free&lt;OpticOpKind.Witness, Person&gt; modifyProgram =
    OpticPrograms.modify(person, PersonLenses.age(), age -&gt; age + 1);
</code></pre>
<p>At this point, <strong>nothing has executed</strong>. We've just built descriptions of operations. To actually run them:</p>
<pre><code class="language-java">// Execute with direct interpreter
DirectOpticInterpreter interpreter = OpticInterpreters.direct();

Integer age = interpreter.run(getProgram);           // 25
Person updated = interpreter.run(setProgram);         // age is now 30
Person modified = interpreter.run(modifyProgram);     // age is now 26
</code></pre>
<hr />
<h3 id="composing-programs-the-power-of-flatmap"><a class="header" href="#composing-programs-the-power-of-flatmap">Composing Programs: The Power of <code>flatMap</code></a></h3>
<p>The real power emerges when you compose multiple operations. The <code>flatMap</code> method lets you sequence operations where each step can depend on previous results:</p>
<pre><code class="language-java">// Program: Get the age, then if they're an adult, increment it
Free&lt;OpticOpKind.Witness, Person&gt; adultBirthdayProgram =
    OpticPrograms.get(person, PersonLenses.age())
        .flatMap(age -&gt; {
            if (age &gt;= 18) {
                return OpticPrograms.modify(
                    person,
                    PersonLenses.age(),
                    a -&gt; a + 1
                );
            } else {
                // Return unchanged person
                return OpticPrograms.pure(person);
            }
        });

// Execute it
Person result = OpticInterpreters.direct().run(adultBirthdayProgram);
</code></pre>
<p>Let's break down what's happening:</p>
<ol>
<li><code>get</code> creates a program that will retrieve the age</li>
<li><code>flatMap</code> says "once you have the age, use it to decide what to do next"</li>
<li>Inside <code>flatMap</code>, we make a decision based on the age value</li>
<li>We return a new program (either <code>modify</code> or <code>pure</code>)</li>
<li>The interpreter executes the composed program step by step</li>
</ol>
<hr />
<h3 id="multi-step-programs-complex-workflows"><a class="header" href="#multi-step-programs-complex-workflows">Multi-Step programs: Complex Workflows</a></h3>
<p>You can chain multiple <code>flatMap</code> calls to build sophisticated workflows:</p>
<pre><code class="language-java">@GenerateLenses
public record Employee(String name, int salary, EmployeeStatus status) {}

enum EmployeeStatus { JUNIOR, SENIOR, RETIRED }

// Program: Annual review and potential promotion
Free&lt;OpticOpKind.Witness, Employee&gt; annualReviewProgram(Employee employee) {
    return OpticPrograms.get(employee, EmployeeLenses.salary())
        .flatMap(currentSalary -&gt; {
            // Step 1: Give a 10% raise
            int newSalary = currentSalary + (currentSalary / 10);
            return OpticPrograms.set(employee, EmployeeLenses.salary(), newSalary);
        })
        .flatMap(raisedEmployee -&gt;
            // Step 2: Check if salary justifies promotion
            OpticPrograms.get(raisedEmployee, EmployeeLenses.salary())
                .flatMap(salary -&gt; {
                    if (salary &gt; 100_000) {
                        return OpticPrograms.set(
                            raisedEmployee,
                            EmployeeLenses.status(),
                            EmployeeStatus.SENIOR
                        );
                    } else {
                        return OpticPrograms.pure(raisedEmployee);
                    }
                })
        );
}

// Execute for an employee
Employee alice = new Employee("Alice", 95_000, EmployeeStatus.JUNIOR);
Free&lt;OpticOpKind.Witness, Employee&gt; program = annualReviewProgram(alice);

Employee promoted = OpticInterpreters.direct().run(program);
// Result: Employee("Alice", 104_500, SENIOR)
</code></pre>
<hr />
<h2 id="part-3-working-with-collections-traversals-and-folds"><a class="header" href="#part-3-working-with-collections-traversals-and-folds">Part 3: Working with Collections (Traversals and Folds)</a></h2>
<p>The DSL works beautifully with traversals for batch operations:</p>
<pre><code class="language-java">@GenerateLenses
@GenerateTraversals
public record Team(String name, List&lt;Player&gt; players) {}

@GenerateLenses
public record Player(String name, int score) {}

Team team = new Team("Wildcats",
    List.of(
        new Player("Alice", 80),
        new Player("Bob", 90)
    ));

// Program: Double all scores and check if everyone passes
Free&lt;OpticOpKind.Witness, Boolean&gt; scoreUpdateProgram =
    OpticPrograms.modifyAll(
        team,
        TeamTraversals.players().andThen(PlayerLenses.score().asTraversal()),
        score -&gt; score * 2
    )
    .flatMap(updatedTeam -&gt;
        // Now check if all players have passing scores
        OpticPrograms.all(
            updatedTeam,
            TeamTraversals.players().andThen(PlayerLenses.score().asTraversal()),
            score -&gt; score &gt;= 100
        )
    );

// Execute
Boolean allPass = OpticInterpreters.direct().run(scoreUpdateProgram);
// Result: true (Alice: 160, Bob: 180)
</code></pre>
<h3 id="querying-with-programs"><a class="header" href="#querying-with-programs">Querying with programs</a></h3>
<pre><code class="language-java">// Program: Find all high scorers
Free&lt;OpticOpKind.Witness, List&lt;Player&gt;&gt; findHighScorers =
    OpticPrograms.getAll(team, TeamTraversals.players())
        .flatMap(players -&gt; {
            List&lt;Player&gt; highScorers = players.stream()
                .filter(p -&gt; p.score() &gt; 85)
                .toList();
            return OpticPrograms.pure(highScorers);
        });

// Execute
List&lt;Player&gt; topPlayers = OpticInterpreters.direct().run(findHighScorers);
</code></pre>
<hr />
<h2 id="part-4-real-world-scenarios"><a class="header" href="#part-4-real-world-scenarios">Part 4: Real-World Scenarios</a></h2>
<h3 id="scenario-1-data-migration-with-validation"><a class="header" href="#scenario-1-data-migration-with-validation">Scenario 1: Data Migration with Validation</a></h3>
<pre><code class="language-java">@GenerateLenses
public record UserV1(String username, String email) {}

@GenerateLenses
public record UserV2(String username, String email, boolean verified) {}

// Note: Either is from higher-kinded-j (org.higherkindedj.hkt.either.Either)
// It represents a value that can be either a Left (error) or Right (success)

// Program: Migrate user with email validation
Free&lt;OpticOpKind.Witness, Either&lt;String, UserV2&gt;&gt; migrateUser(UserV1 oldUser) {
    return OpticPrograms.get(oldUser, UserV1Lenses.email())
        .flatMap(email -&gt; {
            if (email.contains("@") &amp;&amp; email.contains(".")) {
                // Valid email - proceed with migration
                UserV2 newUser = new UserV2(
                    oldUser.username(),
                    email,
                    false  // Will be verified later
                );
                return OpticPrograms.pure(Either.right(newUser));
            } else {
                // Invalid email - fail migration
                return OpticPrograms.pure(Either.left(
                    "Invalid email: " + email
                ));
            }
        });
}

// Execute migration
Free&lt;OpticOpKind.Witness, Either&lt;String, UserV2&gt;&gt; program =
    migrateUser(new UserV1("alice", "alice@example.com"));

Either&lt;String, UserV2&gt; result = OpticInterpreters.direct().run(program);
</code></pre>
<div id="admonition-why-use-free-monad-here" class="admonition admonish-tip" role="note" aria-labelledby="admonition-why-use-free-monad-here-title">
<div class="admonition-title">
<div id="admonition-why-use-free-monad-here-title">
<p>Why Use Free Monad Here?</p>
</div>
<a class="admonition-anchor-link" href="optics/free_monad_dsl.html#admonition-why-use-free-monad-here"></a>
</div>
<div>
<p>By building the migration as a program, you can:</p>
<ul>
<li>Validate the entire migration plan before executing</li>
<li>Log every transformation for audit purposes</li>
<li>Test the migration logic without touching real data</li>
<li>Roll back if any step fails</li>
</ul>
</div>
</div>
<hr />
<h3 id="scenario-2-audit-trail-for-financial-transactions"><a class="header" href="#scenario-2-audit-trail-for-financial-transactions">Scenario 2: Audit Trail for Financial Transactions</a></h3>
<pre><code class="language-java">@GenerateLenses
public record Account(String accountId, BigDecimal balance) {}

@GenerateLenses
public record Transaction(Account from, Account to, BigDecimal amount) {}

// Program: Transfer money between accounts
Free&lt;OpticOpKind.Witness, Transaction&gt; transferProgram(
    Transaction transaction
) {
    return OpticPrograms.get(transaction, TransactionLenses.amount())
        .flatMap(amount -&gt;
            // Deduct from source account
            OpticPrograms.modify(
                transaction,
                TransactionLenses.from().andThen(AccountLenses.balance()),
                balance -&gt; balance.subtract(amount)
            )
        )
        .flatMap(txn -&gt;
            // Add to destination account
            OpticPrograms.modify(
                txn,
                TransactionLenses.to().andThen(AccountLenses.balance()),
                balance -&gt; balance.add(txn.amount())
            )
        );
}

// Execute with logging for audit trail
Account acc1 = new Account("ACC001", new BigDecimal("1000.00"));
Account acc2 = new Account("ACC002", new BigDecimal("500.00"));
Transaction txn = new Transaction(acc1, acc2, new BigDecimal("100.00"));

Free&lt;OpticOpKind.Witness, Transaction&gt; program = transferProgram(txn);

// Use logging interpreter to record every operation
LoggingOpticInterpreter logger = OpticInterpreters.logging();
Transaction result = logger.run(program);

// Review audit trail
logger.getLog().forEach(System.out::println);
/* Output:
GET: TransactionLenses.amount() -&gt; 100.00
MODIFY: TransactionLenses.from().andThen(AccountLenses.balance()) from 1000.00 to 900.00
MODIFY: TransactionLenses.to().andThen(AccountLenses.balance()) from 500.00 to 600.00
*/
</code></pre>
<hr />
<h3 id="scenario-3-dry-run-validation-before-production"><a class="header" href="#scenario-3-dry-run-validation-before-production">Scenario 3: Dry-Run Validation Before Production</a></h3>
<pre><code class="language-java">@GenerateLenses
@GenerateTraversals
public record ProductCatalogue(List&lt;Product&gt; products) {}

@GenerateLenses
public record Product(String id, BigDecimal price, int stock) {}

// Program: Bulk price update
Free&lt;OpticOpKind.Witness, ProductCatalogue&gt; bulkPriceUpdate(
    ProductCatalogue catalogue,
    BigDecimal markup
) {
    return OpticPrograms.modifyAll(
        catalogue,
        ProductCatalogueTraversals.products()
            .andThen(ProductLenses.price().asTraversal()),
        price -&gt; price.multiply(BigDecimal.ONE.add(markup))
    );
}

// First, validate without executing
ProductCatalogue catalogue = new ProductCatalogue(
    List.of(
        new Product("P001", new BigDecimal("99.99"), 10),
        new Product("P002", new BigDecimal("49.99"), 5)
    )
);

Free&lt;OpticOpKind.Witness, ProductCatalogue&gt; program =
    bulkPriceUpdate(catalogue, new BigDecimal("0.10"));  // 10% markup

// Validate first
ValidationOpticInterpreter validator = OpticInterpreters.validating();
ValidationOpticInterpreter.ValidationResult validation =
    validator.validate(program);

if (validation.isValid()) {
    // All good - now execute for real
    ProductCatalogue updated = OpticInterpreters.direct().run(program);
    System.out.println("Price update successful!");
} else {
    // Something wrong - review errors
    validation.errors().forEach(System.err::println);
    validation.warnings().forEach(System.out::println);
}
</code></pre>
<hr />
<h2 id="part-5-advanced-patterns"><a class="header" href="#part-5-advanced-patterns">Part 5: Advanced Patterns</a></h2>
<h3 id="pattern-1-reusable-program-fragments"><a class="header" href="#pattern-1-reusable-program-fragments">Pattern 1: Reusable Program Fragments</a></h3>
<p>You can build libraries of reusable program fragments:</p>
<pre><code class="language-java">// Library of common operations
public class PersonPrograms {
    public static Free&lt;OpticOpKind.Witness, Person&gt; celebrateBirthday(
        Person person
    ) {
        return OpticPrograms.modify(
            person,
            PersonLenses.age(),
            age -&gt; age + 1
        );
    }

    public static Free&lt;OpticOpKind.Witness, Person&gt; promoteIfEligible(
        Person person
    ) {
        return OpticPrograms.get(person, PersonLenses.age())
            .flatMap(age -&gt; {
                if (age &gt;= 30) {
                    return OpticPrograms.set(
                        person,
                        PersonLenses.status(),
                        "SENIOR"
                    );
                } else {
                    return OpticPrograms.pure(person);
                }
            });
    }

    // Combine operations
    public static Free&lt;OpticOpKind.Witness, Person&gt; annualUpdate(
        Person person
    ) {
        return celebrateBirthday(person)
            .flatMap(PersonPrograms::promoteIfEligible);
    }
}

// Use them
Person alice = new Person("Alice", 29, "JUNIOR");
Free&lt;OpticOpKind.Witness, Person&gt; program = PersonPrograms.annualUpdate(alice);
Person updated = OpticInterpreters.direct().run(program);
</code></pre>
<hr />
<h3 id="pattern-2-conditional-branching"><a class="header" href="#pattern-2-conditional-branching">Pattern 2: Conditional Branching</a></h3>
<pre><code class="language-java">enum PerformanceRating { EXCELLENT, GOOD, SATISFACTORY, POOR }

// Program with complex branching logic
Free&lt;OpticOpKind.Witness, Employee&gt; processPerformanceReview(
    Employee employee,
    PerformanceRating rating
) {
    return switch (rating) {
        case EXCELLENT -&gt; OpticPrograms.modify(
            employee,
            EmployeeLenses.salary(),
            salary -&gt; salary + (salary / 5)  // 20% raise
        ).flatMap(emp -&gt;
            OpticPrograms.set(emp, EmployeeLenses.status(), EmployeeStatus.SENIOR)
        );

        case GOOD -&gt; OpticPrograms.modify(
            employee,
            EmployeeLenses.salary(),
            salary -&gt; salary + (salary / 10)  // 10% raise
        );

        case SATISFACTORY -&gt; OpticPrograms.pure(employee);  // No change

        case POOR -&gt; OpticPrograms.set(
            employee,
            EmployeeLenses.status(),
            EmployeeStatus.PROBATION
        );
    };
}
</code></pre>
<hr />
<h3 id="pattern-3-accumulating-results"><a class="header" href="#pattern-3-accumulating-results">Pattern 3: Accumulating Results</a></h3>
<pre><code class="language-java">// Note: Tuple and Tuple2 are from higher-kinded-j (org.higherkindedj.hkt.tuple.Tuple, Tuple2)
// Tuple.of() creates a Tuple2 instance to pair two values together

// Program that accumulates statistics while processing
record ProcessingStats(int processed, int modified, int skipped) {}

Free&lt;OpticOpKind.Witness, Tuple2&lt;Team, ProcessingStats&gt;&gt; processTeamWithStats(
    Team team
) {
    // This is simplified - in practice you'd thread stats through flatMaps
    return OpticPrograms.getAll(team, TeamTraversals.players())
        .flatMap(players -&gt; {
            int processed = players.size();
            int modified = (int) players.stream()
                .filter(p -&gt; p.score() &lt; 50)
                .count();
            int skipped = processed - modified;

            return OpticPrograms.modifyAll(
                team,
                TeamTraversals.players(),
                player -&gt; player.score() &lt; 50
                    ? OpticOps.set(player, PlayerLenses.score(), 50)
                    : player
            ).map(updatedTeam -&gt;
                Tuple.of(
                    updatedTeam,
                    new ProcessingStats(processed, modified, skipped)
                )
            );
        });
}
</code></pre>
<hr />
<h2 id="part-6-comparison-with-direct-execution"><a class="header" href="#part-6-comparison-with-direct-execution">Part 6: Comparison with Direct Execution</a></h2>
<h3 id="when-to-use-free-monad-dsl"><a class="header" href="#when-to-use-free-monad-dsl">When to Use Free Monad DSL</a></h3>
<p><strong>Use Free Monad DSL when you need:</strong></p>
<ul>
<li>Audit trails and logging</li>
<li>Validation before execution</li>
<li>Testing complex logic</li>
<li>Multiple execution strategies</li>
<li>Optimisation opportunities</li>
<li>Dry-run capabilities</li>
</ul>
<h3 id="when-to-use-direct-execution"><a class="header" href="#when-to-use-direct-execution">When to Use Direct Execution</a></h3>
<p><strong>Use Direct Execution (<a href="optics/fluent_api.html">Fluent API</a>) when:</strong></p>
<ul>
<li>Simple, straightforward operations</li>
<li>No need for introspection</li>
<li>Performance is critical</li>
<li>The workflow is stable and well-understood</li>
</ul>
<hr />
<h3 id="side-by-side-comparison"><a class="header" href="#side-by-side-comparison">Side-by-Side Comparison</a></h3>
<pre><code class="language-java">// Direct execution (immediate)
Person result = OpticOps.modify(
    person,
    PersonLenses.age(),
    age -&gt; age + 1
);

// Free monad (deferred)
Free&lt;OpticOpKind.Witness, Person&gt; program =
    OpticPrograms.modify(
        person,
        PersonLenses.age(),
        age -&gt; age + 1
    );

Person result = OpticInterpreters.direct().run(program);
</code></pre>
<p>The Free monad version requires more code, but gives you the power to:</p>
<pre><code class="language-java">// Log it
LoggingOpticInterpreter logger = OpticInterpreters.logging();
Person result = logger.run(program);
logger.getLog().forEach(System.out::println);

// Validate it
ValidationOpticInterpreter validator = OpticInterpreters.validating();
ValidationResult validation = validator.validate(program);

// Test it with mocks
MockOpticInterpreter mock = new MockOpticInterpreter();
Person mockResult = mock.run(program);
</code></pre>
<hr />
<h2 id="common-pitfalls-26"><a class="header" href="#common-pitfalls-26">Common Pitfalls</a></h2>
<h3 id="dont-forget-that-programs-are-immutable"><a class="header" href="#dont-forget-that-programs-are-immutable">Don't: Forget that programs are immutable</a></h3>
<pre><code class="language-java">// Wrong - trying to "modify" a program
Free&lt;OpticOpKind.Witness, Person&gt; program = OpticPrograms.get(person, PersonLenses.age());
program.flatMap(age -&gt; ...);  // This returns a NEW program!

// The original program is unchanged
</code></pre>
<h3 id="do-assign-the-result-of-flatmap"><a class="header" href="#do-assign-the-result-of-flatmap">Do: Assign the result of <code>flatMap</code></a></h3>
<pre><code class="language-java">// Correct - capture the new program
Free&lt;OpticOpKind.Witness, Person&gt; program =
    OpticPrograms.get(person, PersonLenses.age())
        .flatMap(age -&gt; OpticPrograms.modify(person, PersonLenses.age(), a -&gt; a + 1));
</code></pre>
<hr />
<h3 id="dont-mix-side-effects-in-program-construction"><a class="header" href="#dont-mix-side-effects-in-program-construction">Don't: Mix side effects in program construction</a></h3>
<pre><code class="language-java">// Wrong - side effect during construction
Free&lt;OpticOpKind.Witness, Person&gt; program =
    OpticPrograms.get(person, PersonLenses.age())
        .flatMap(age -&gt; {
            System.out.println("Age: " + age);  // Side effect!
            return OpticPrograms.pure(person);
        });
</code></pre>
<h3 id="do-keep-program-construction-pure"><a class="header" href="#do-keep-program-construction-pure">Do: Keep program construction pure</a></h3>
<pre><code class="language-java">// Correct - side effects only in interpreters
Free&lt;OpticOpKind.Witness, Person&gt; program =
    OpticPrograms.get(person, PersonLenses.age())
        .flatMap(age -&gt; OpticPrograms.pure(person));

// Side effects happen during interpretation
LoggingOpticInterpreter logger = OpticInterpreters.logging();
Person result = logger.run(program);
logger.getLog().forEach(System.out::println);  // Side effect here is fine
</code></pre>
<hr />
<div id="admonition-further-reading" class="admonition admonish-tip" role="note" aria-labelledby="admonition-further-reading-title">
<div class="admonition-title">
<div id="admonition-further-reading-title">
<p>Further Reading</p>
</div>
<a class="admonition-anchor-link" href="optics/free_monad_dsl.html#admonition-further-reading"></a>
</div>
<div>
<ul>
<li><strong>Gabriel Gonzalez</strong>: <a href="https://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html">Why Free Monads Matter</a> - The foundational explanation</li>
<li><strong>Scott Wlaschin</strong>: <a href="https://fsharpforfunandprofit.com/rop/">Railway Oriented Programming</a> - Error handling patterns</li>
</ul>
</div>
</div>
<div id="admonition-hands-on-learning" class="admonition admonish-info" role="note" aria-labelledby="admonition-hands-on-learning-title">
<div class="admonition-title">
<div id="admonition-hands-on-learning-title">
<p>Hands-On Learning</p>
</div>
<a class="admonition-anchor-link" href="optics/free_monad_dsl.html#admonition-hands-on-learning"></a>
</div>
<div>
<p>Practice the Free Monad DSL in <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/optics/Tutorial11_AdvancedOpticsDSL.java">Tutorial 11: Advanced Optics DSL</a> (7 exercises, ~12 minutes).</p>
</div>
</div>
<hr />
<p><strong>Next Steps:</strong></p>
<ul>
<li><a href="optics/interpreters.html">Optic Interpreters</a> - Deep dive into execution strategies</li>
<li><a href="optics/fluent_api.html">Fluent API for Optics</a> - Direct execution patterns</li>
<li><a href="optics/composing_optics.html">Advanced Patterns</a> - Complex real-world scenarios</li>
</ul>
<hr />
<p><strong>Previous:</strong> <a href="optics/fluent_api.html">Fluent API</a>
<strong>Next:</strong> <a href="optics/interpreters.html">Interpreters</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="optic-interpreters-multiple-execution-strategies"><a class="header" href="#optic-interpreters-multiple-execution-strategies">Optic Interpreters: Multiple Execution Strategies</a></h1>
<p><img src="optics/../images/lens2.jpg" alt="interpreters.jpg" /></p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="optics/interpreters.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How the Interpreter pattern separates description from execution</li>
<li>The three built-in interpreters: Direct, Logging, and Validation</li>
<li>When to use each interpreter effectively</li>
<li>How to create custom interpreters for specific needs</li>
<li>Combining interpreters for powerful workflows</li>
<li>Real-world applications: audit trails, testing, and optimisation</li>
</ul>
</div>
</div>
<div id="admonition-example-code" class="admonition admonish-note" role="note" aria-labelledby="admonition-example-code-title">
<div class="admonition-title">
<div id="admonition-example-code-title">
<p>Example Code</p>
</div>
<a class="admonition-anchor-link" href="optics/interpreters.html#admonition-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/fluent/OpticInterpretersExample.java">OpticInterpretersExample</a></p>
</div>
</div>
<h2 id="introduction-the-power-of-interpretation"><a class="header" href="#introduction-the-power-of-interpretation">Introduction: The Power of Interpretation</a></h2>
<p>In the <a href="optics/free_monad_dsl.html">Free Monad DSL</a> guide, we learnt how to build optic operations as programs: data structures that describe what to do, rather than doing it immediately. But a description alone is useless without execution. That's where <strong>interpreters</strong> come in.</p>
<p>An interpreter takes a program and executes it in a specific way. By providing different interpreters, you can run the same program with completely different behaviours:</p>
<ul>
<li><strong>DirectOpticInterpreter</strong>: Executes operations immediately (production use)</li>
<li><strong>LoggingOpticInterpreter</strong>: Records every operation for audit trails</li>
<li><strong>ValidationOpticInterpreter</strong>: Checks constraints without modifying data</li>
<li><strong>Custom interpreters</strong>: Performance profiling, testing, mocking, and more</li>
</ul>
<p>This separation of concerns, <em>what to do</em> vs <em>how to do it</em>, is the essence of the Interpreter pattern and the key to the Free monad's flexibility.</p>
<div id="admonition-the-core-benefit" class="admonition admonish-tip" role="note" aria-labelledby="admonition-the-core-benefit-title">
<div class="admonition-title">
<div id="admonition-the-core-benefit-title">
<p>The Core Benefit</p>
</div>
<a class="admonition-anchor-link" href="optics/interpreters.html#admonition-the-core-benefit"></a>
</div>
<div>
<p>Write your business logic once as a program. Execute it in multiple ways: validate it in tests, log it in production, mock it during development, and optimise it for performance, all without changing the business logic itself.</p>
</div>
</div>
<hr />
<h2 id="part-1-the-interpreter-pattern-explained"><a class="header" href="#part-1-the-interpreter-pattern-explained">Part 1: The Interpreter Pattern Explained</a></h2>
<h3 id="from-design-patterns-to-functional-programming"><a class="header" href="#from-design-patterns-to-functional-programming">From Design Patterns to Functional Programming</a></h3>
<p>The Interpreter pattern, described in the Gang of Four's <em>Design Patterns</em>, suggests representing operations as objects in an abstract syntax tree (AST), then traversing that tree to execute them. The Free monad is essentially a functional programming implementation of this pattern.</p>
<pre><code class="language-java">// Our "AST" - a program built from operations
Free&lt;OpticOpKind.Witness, Person&gt; program =
    OpticPrograms.get(person, PersonLenses.age())
        .flatMap(age -&gt;
            OpticPrograms.modify(person, PersonLenses.age(), a -&gt; a + 1)
        );

// Our "interpreter" - executes the AST
DirectOpticInterpreter interpreter = OpticInterpreters.direct();
Person result = interpreter.run(program);
</code></pre>
<h3 id="why-multiple-interpreters"><a class="header" href="#why-multiple-interpreters">Why Multiple Interpreters?</a></h3>
<p>Different situations require different execution strategies:</p>
<div class="table-wrapper"><table><thead><tr><th><strong>Situation</strong></th><th><strong>Interpreter</strong></th><th><strong>Why</strong></th></tr></thead><tbody>
<tr><td>Production execution</td><td>Direct</td><td>Fast, straightforward</td></tr>
<tr><td>Compliance &amp; auditing</td><td>Logging</td><td>Records every change</td></tr>
<tr><td>Pre-flight checks</td><td>Validation</td><td>Verifies without executing</td></tr>
<tr><td>Unit testing</td><td>Mock/Custom</td><td>No real data needed</td></tr>
<tr><td>Performance tuning</td><td>Profiling/Custom</td><td>Measures execution time</td></tr>
<tr><td>Dry-run simulations</td><td>Validation</td><td>See what would happen</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="part-2-the-direct-interpreter"><a class="header" href="#part-2-the-direct-interpreter">Part 2: The Direct Interpreter</a></h2>
<p>The <code>DirectOpticInterpreter</code> is the simplest interpreter: it executes optic operations immediately, exactly as you'd expect.</p>
<h3 id="basic-usage-1"><a class="header" href="#basic-usage-1">Basic Usage</a></h3>
<pre><code class="language-java">@GenerateLenses
public record Person(String name, int age) {}

Person person = new Person("Alice", 25);

// Build a program
Free&lt;OpticOpKind.Witness, Person&gt; program =
    OpticPrograms.modify(person, PersonLenses.age(), age -&gt; age + 1);

// Execute with direct interpreter
DirectOpticInterpreter interpreter = OpticInterpreters.direct();
Person result = interpreter.run(program);

System.out.println(result);  // Person("Alice", 26)
</code></pre>
<h3 id="when-to-use-11"><a class="header" href="#when-to-use-11">When to Use</a></h3>
<p><strong>Production execution</strong>: When you just want to run the operations
<strong>Simple workflows</strong>: When audit trails or validation aren't needed
<strong>Performance-critical paths</strong>: Minimal overhead</p>
<h3 id="characteristics"><a class="header" href="#characteristics">Characteristics</a></h3>
<ul>
<li><strong>Fast</strong>: No additional processing</li>
<li><strong>Simple</strong>: Executes exactly as described</li>
<li><strong>No Side Effects</strong>: Pure optic operations only</li>
</ul>
<div id="admonition-production-workflow" class="admonition admonish-example" role="note" aria-labelledby="admonition-production-workflow-title">
<div class="admonition-title">
<div id="admonition-production-workflow-title">
<p>Production Workflow</p>
</div>
<a class="admonition-anchor-link" href="optics/interpreters.html#admonition-production-workflow"></a>
</div>
<div>
<pre><code class="language-java">@GenerateLenses
record Employee(String name, int salary, String status) {}

enum PerformanceRating { EXCELLENT, GOOD, SATISFACTORY, POOR }

// Employee management system
public Employee processAnnualReview(
    Employee employee,
    PerformanceRating rating
) {
    Free&lt;OpticOpKind.Witness, Employee&gt; program =
        buildReviewProgram(employee, rating);

    // Direct execution in production
    return OpticInterpreters.direct().run(program);
}
</code></pre>
</div>
</div>
<hr />
<h2 id="part-3-the-logging-interpreter"><a class="header" href="#part-3-the-logging-interpreter">Part 3: The Logging Interpreter</a></h2>
<p>The <code>LoggingOpticInterpreter</code> executes operations whilst recording detailed logs of every operation performed. This is invaluable for:</p>
<ul>
<li><strong>Audit trails</strong>: Compliance requirements (GDPR, SOX, etc.)</li>
<li><strong>Debugging</strong>: Understanding what happened when</li>
<li><strong>Monitoring</strong>: Tracking data changes in production</li>
</ul>
<h3 id="basic-usage-2"><a class="header" href="#basic-usage-2">Basic Usage</a></h3>
<pre><code class="language-java">@GenerateLenses
public record Account(String accountId, BigDecimal balance) {}

Account account = new Account("ACC001", new BigDecimal("1000.00"));

// Build a program
Free&lt;OpticOpKind.Witness, Account&gt; program =
    OpticPrograms.modify(
        account,
        AccountLenses.balance(),
        balance -&gt; balance.subtract(new BigDecimal("100.00"))
    );

// Execute with logging
LoggingOpticInterpreter logger = OpticInterpreters.logging();
Account result = logger.run(program);

// Review the log
List&lt;String&gt; log = logger.getLog();
log.forEach(System.out::println);
/* Output:
MODIFY: AccountLenses.balance() from 1000.00 to 900.00
*/
</code></pre>
<h3 id="comprehensive-example-financial-transaction-audit"><a class="header" href="#comprehensive-example-financial-transaction-audit">Comprehensive Example: Financial Transaction Audit</a></h3>
<pre><code class="language-java">@GenerateLenses
public record Transaction(
    String txnId,
    Account from,
    Account to,
    BigDecimal amount,
    LocalDateTime timestamp
) {}

// Build a transfer program
Free&lt;OpticOpKind.Witness, Transaction&gt; transferProgram(Transaction txn) {
    return OpticPrograms.get(txn, TransactionLenses.amount())
        .flatMap(amount -&gt;
            // Debit source account
            OpticPrograms.modify(
                txn,
                TransactionLenses.from().andThen(AccountLenses.balance()),
                balance -&gt; balance.subtract(amount)
            )
        )
        .flatMap(debited -&gt;
            // Credit destination account
            OpticPrograms.modify(
                debited,
                TransactionLenses.to().andThen(AccountLenses.balance()),
                balance -&gt; balance.add(debited.amount())
            )
        );
}

// Execute with audit logging
Transaction txn = new Transaction(
    "TXN-12345",
    new Account("ACC001", new BigDecimal("1000.00")),
    new Account("ACC002", new BigDecimal("500.00")),
    new BigDecimal("250.00"),
    LocalDateTime.now()
);

LoggingOpticInterpreter logger = OpticInterpreters.logging();
Transaction result = logger.run(transferProgram(txn));

// Persist audit trail to database
logger.getLog().forEach(entry -&gt; auditService.record(txn.txnId(), entry));
</code></pre>
<h3 id="log-format"><a class="header" href="#log-format">Log Format</a></h3>
<p>The logging interpreter provides detailed, human-readable logs:</p>
<pre><code>GET: TransactionLenses.amount() -&gt; 250.00
MODIFY: TransactionLenses.from().andThen(AccountLenses.balance()) from 1000.00 to 750.00
MODIFY: TransactionLenses.to().andThen(AccountLenses.balance()) from 500.00 to 750.00
</code></pre>
<h3 id="managing-logs"><a class="header" href="#managing-logs">Managing Logs</a></h3>
<pre><code class="language-java">LoggingOpticInterpreter logger = OpticInterpreters.logging();

// Run first program
logger.run(program1);
List&lt;String&gt; firstLog = logger.getLog();

// Clear for next program
logger.clearLog();

// Run second program
logger.run(program2);
List&lt;String&gt; secondLog = logger.getLog();
</code></pre>
<div id="admonition-performance-consideration" class="admonition admonish-warning" role="note" aria-labelledby="admonition-performance-consideration-title">
<div class="admonition-title">
<div id="admonition-performance-consideration-title">
<p>Performance Consideration</p>
</div>
<a class="admonition-anchor-link" href="optics/interpreters.html#admonition-performance-consideration"></a>
</div>
<div>
<p>The logging interpreter does add overhead (string formatting, list management). For high-frequency operations, consider:</p>
<ul>
<li>Using sampling (log every Nth transaction)</li>
<li>Async logging (log to queue, process later)</li>
<li>Conditional logging (only for high-value transactions)</li>
</ul>
</div>
</div>
<hr />
<h2 id="part-4-the-validation-interpreter"><a class="header" href="#part-4-the-validation-interpreter">Part 4: The Validation Interpreter</a></h2>
<p>The <code>ValidationOpticInterpreter</code> performs a "dry-run" of your program, checking constraints and collecting errors/warnings <strong>without actually executing the operations</strong>. This is perfect for:</p>
<ul>
<li><strong>Pre-flight checks</strong>: Validate before committing</li>
<li><strong>Testing</strong>: Verify logic without side effects</li>
<li><strong>What-if scenarios</strong>: See what would happen</li>
</ul>
<h3 id="basic-usage-3"><a class="header" href="#basic-usage-3">Basic Usage</a></h3>
<pre><code class="language-java">@GenerateLenses
public record Person(String name, int age) {}

Person person = new Person("Alice", 25);

// Build a program
Free&lt;OpticOpKind.Witness, Person&gt; program =
    OpticPrograms.set(person, PersonLenses.name(), null);  // Oops!

// Validate without executing
ValidationOpticInterpreter validator = OpticInterpreters.validating();
ValidationOpticInterpreter.ValidationResult result = validator.validate(program);

if (!result.isValid()) {
    // Has errors
    result.errors().forEach(System.err::println);
}

if (result.hasWarnings()) {
    // Has warnings
    result.warnings().forEach(System.out::println);
    // Output: "SET operation with null value: PersonLenses.name()"
}
</code></pre>
<h3 id="validation-rules"><a class="header" href="#validation-rules">Validation Rules</a></h3>
<p>The validation interpreter checks for:</p>
<ol>
<li><strong>Null values</strong>: Warns when setting null</li>
<li><strong>Modifier failures</strong>: Errors when modifiers throw exceptions</li>
<li><strong>Custom constraints</strong>: (via custom interpreter subclass)</li>
</ol>
<h3 id="real-world-example-data-migration-validation"><a class="header" href="#real-world-example-data-migration-validation">Real-World Example: Data Migration Validation</a></h3>
<pre><code class="language-java">@GenerateLenses
public record UserV1(String username, String email, Integer age) {}

@GenerateLenses
public record UserV2(
    String username,
    String email,
    int age,  // Now non-null!
    boolean verified
) {}

// Migration program
Free&lt;OpticOpKind.Witness, UserV2&gt; migrateUser(UserV1 oldUser) {
    return OpticPrograms.get(oldUser, UserV1Lenses.age())
        .flatMap(age -&gt; {
            if (age == null) {
                // This would fail!
                throw new IllegalArgumentException("Age cannot be null in V2");
            }

            UserV2 newUser = new UserV2(
                oldUser.username(),
                oldUser.email(),
                age,
                false
            );

            return OpticPrograms.pure(newUser);
        });
}

// Validate migration for each user
List&lt;UserV1&gt; oldUsers = loadOldUsers();
List&lt;ValidationResult&gt; validations = new ArrayList&lt;&gt;();

for (UserV1 user : oldUsers) {
    Free&lt;OpticOpKind.Witness, UserV2&gt; program = migrateUser(user);

    ValidationOpticInterpreter validator = OpticInterpreters.validating();
    ValidationResult validation = validator.validate(program);

    validations.add(validation);

    if (!validation.isValid()) {
        System.err.println("User " + user.username() + " failed validation:");
        validation.errors().forEach(System.err::println);
    }
}

// Only proceed if all valid
if (validations.stream().allMatch(ValidationResult::isValid)) {
    // Execute migrations with direct interpreter
    oldUsers.forEach(user -&gt; {
        Free&lt;OpticOpKind.Witness, UserV2&gt; program = migrateUser(user);
        UserV2 migrated = OpticInterpreters.direct().run(program);
        saveNewUser(migrated);
    });
}
</code></pre>
<h3 id="validation-result-api"><a class="header" href="#validation-result-api">Validation Result API</a></h3>
<pre><code class="language-java">// Simple exception for validation failures
class ValidationException extends RuntimeException {
    public ValidationException(String message) {
        super(message);
    }
    public ValidationException(List&lt;String&gt; errors) {
        super("Validation failed: " + String.join(", ", errors));
    }
}

// Simple exception for business logic failures
class BusinessException extends RuntimeException {
    public BusinessException(String message, Throwable cause) {
        super(message, cause);
    }
}

public record ValidationResult(
    List&lt;String&gt; errors,    // Blocking issues
    List&lt;String&gt; warnings   // Non-blocking concerns
) {
    public boolean isValid() {
        return errors.isEmpty();
    }

    public boolean hasWarnings() {
        return !warnings.isEmpty();
    }
}
</code></pre>
<div id="admonition-testing-tip" class="admonition admonish-tip" role="note" aria-labelledby="admonition-testing-tip-title">
<div class="admonition-title">
<div id="admonition-testing-tip-title">
<p>Testing Tip</p>
</div>
<a class="admonition-anchor-link" href="optics/interpreters.html#admonition-testing-tip"></a>
</div>
<div>
<p>Use the validation interpreter in unit tests to verify program structure without executing operations:</p>
<pre><code class="language-java">@Test
void testProgramLogic() {
    Free&lt;OpticOpKind.Witness, Person&gt; program =
        buildComplexProgram(testData);

    ValidationOpticInterpreter validator = OpticInterpreters.validating();
    ValidationResult result = validator.validate(program);

    // Verify no errors in logic
    assertTrue(result.isValid());
}
</code></pre>
</div>
</div>
<hr />
<h2 id="part-5-creating-custom-interpreters"><a class="header" href="#part-5-creating-custom-interpreters">Part 5: Creating Custom Interpreters</a></h2>
<p>You can create custom interpreters for specific needs: performance profiling, mocking, optimisation, or any other execution strategy.</p>
<h3 id="the-interpreter-interface"><a class="header" href="#the-interpreter-interface">The Interpreter Interface</a></h3>
<p>All interpreters implement a natural transformation from <code>OpticOp</code> to some effect type (usually <code>Id</code> for simplicity):</p>
<pre><code class="language-java">public interface OpticInterpreter {
    &lt;A&gt; A run(Free&lt;OpticOpKind.Witness, A&gt; program);
}
</code></pre>
<h3 id="example-1-performance-profiling-interpreter"><a class="header" href="#example-1-performance-profiling-interpreter">Example 1: Performance Profiling Interpreter</a></h3>
<pre><code class="language-java">public final class ProfilingOpticInterpreter {
    private final Map&lt;String, Long&gt; executionTimes = new HashMap&lt;&gt;();
    private final Map&lt;String, Integer&gt; executionCounts = new HashMap&lt;&gt;();

    public &lt;A&gt; A run(Free&lt;OpticOpKind.Witness, A&gt; program) {
        Function&lt;Kind&lt;OpticOpKind.Witness, ?&gt;, Kind&lt;IdKind.Witness, ?&gt;&gt; transform =
            kind -&gt; {
                OpticOp&lt;?, ?&gt; op = OpticOpKindHelper.OP.narrow(
                    (Kind&lt;OpticOpKind.Witness, Object&gt;) kind
                );

                String opName = getOperationName(op);
                long startTime = System.nanoTime();

                // Execute the operation
                Object result = executeOperation(op);

                long endTime = System.nanoTime();
                long duration = endTime - startTime;

                // Record metrics
                executionTimes.merge(opName, duration, Long::sum);
                executionCounts.merge(opName, 1, Integer::sum);

                return Id.of(result);
            };

        Kind&lt;IdKind.Witness, A&gt; resultKind =
            program.foldMap(transform, IdMonad.instance());
        return IdKindHelper.ID.narrow(resultKind).value();
    }

    public Map&lt;String, Long&gt; getAverageExecutionTimes() {
        Map&lt;String, Long&gt; averages = new HashMap&lt;&gt;();
        executionTimes.forEach((op, totalTime) -&gt; {
            int count = executionCounts.get(op);
            averages.put(op, totalTime / count);
        });
        return averages;
    }

    private String getOperationName(OpticOp&lt;?, ?&gt; op) {
        return switch (op) {
            case OpticOp.Get&lt;?, ?&gt; get -&gt; "GET: " + get.optic().getClass().getSimpleName();
            case OpticOp.Set&lt;?, ?&gt; set -&gt; "SET: " + set.optic().getClass().getSimpleName();
            case OpticOp.Modify&lt;?, ?&gt; mod -&gt; "MODIFY: " + mod.optic().getClass().getSimpleName();
            // ... other cases
            default -&gt; "UNKNOWN";
        };
    }

    private Object executeOperation(OpticOp&lt;?, ?&gt; op) {
        // Execute using direct interpretation logic
        return switch (op) {
            case OpticOp.Get&lt;?, ?&gt; get -&gt; get.optic().get(get.source());
            case OpticOp.Set&lt;?, ?&gt; set -&gt; set.optic().set(set.newValue(), set.source());
            case OpticOp.Modify&lt;?, ?&gt; mod -&gt; {
                var current = mod.optic().get(mod.source());
                var updated = mod.modifier().apply(current);
                yield mod.optic().set(updated, mod.source());
            }
            // ... other cases
        };
    }
}
</code></pre>
<p><strong>Usage:</strong></p>
<pre><code class="language-java">Free&lt;OpticOpKind.Witness, Team&gt; program = buildComplexTeamUpdate(team);

ProfilingOpticInterpreter profiler = new ProfilingOpticInterpreter();
Team result = profiler.run(program);

// Analyse performance
Map&lt;String, Long&gt; avgTimes = profiler.getAverageExecutionTimes();
avgTimes.forEach((op, time) -&gt;
    System.out.println(op + ": " + time + "ns average")
);
</code></pre>
<hr />
<h3 id="example-2-mock-interpreter-for-testing"><a class="header" href="#example-2-mock-interpreter-for-testing">Example 2: Mock Interpreter for Testing</a></h3>
<pre><code class="language-java">public final class MockOpticInterpreter&lt;S&gt; {
    private final S mockData;

    public MockOpticInterpreter(S mockData) {
        this.mockData = mockData;
    }

    @SuppressWarnings("unchecked")
    public &lt;A&gt; A run(Free&lt;OpticOpKind.Witness, A&gt; program) {
        Function&lt;Kind&lt;OpticOpKind.Witness, ?&gt;, Kind&lt;IdKind.Witness, ?&gt;&gt; transform =
            kind -&gt; {
                OpticOp&lt;?, ?&gt; op = OpticOpKindHelper.OP.narrow(
                    (Kind&lt;OpticOpKind.Witness, Object&gt;) kind
                );

                // All operations just return mock data
                Object result = switch (op) {
                    case OpticOp.Get&lt;?, ?&gt; ignored -&gt; mockData;
                    case OpticOp.Set&lt;?, ?&gt; ignored -&gt; mockData;
                    case OpticOp.Modify&lt;?, ?&gt; ignored -&gt; mockData;
                    case OpticOp.GetAll&lt;?, ?&gt; ignored -&gt; List.of(mockData);
                    case OpticOp.Preview&lt;?, ?&gt; ignored -&gt; Optional.of(mockData);
                    default -&gt; throw new UnsupportedOperationException(
                        "Unsupported operation: " + op.getClass().getSimpleName()
                    );
                };

                return Id.of(result);
            };

        Kind&lt;IdKind.Witness, A&gt; resultKind =
            program.foldMap(transform, IdMonad.instance());
        return IdKindHelper.ID.narrow(resultKind).value();
    }
}
</code></pre>
<p><strong>Usage in tests:</strong></p>
<pre><code class="language-java">@Test
void testBusinessLogic() {
    // Create mock data
    Person mockPerson = new Person("MockUser", 99);

    // Build program (business logic)
    Free&lt;OpticOpKind.Witness, Person&gt; program =
        buildComplexBusinessLogic(mockPerson);

    // Execute with mock interpreter (no real data needed!)
    MockOpticInterpreter&lt;Person&gt; mock = new MockOpticInterpreter&lt;&gt;(mockPerson);
    Person result = mock.run(program);

    // Verify result
    assertEquals("MockUser", result.name());
}
</code></pre>
<hr />
<h2 id="part-6-combining-interpreters"><a class="header" href="#part-6-combining-interpreters">Part 6: Combining Interpreters</a></h2>
<p>You can run the same program through multiple interpreters for powerful workflows:</p>
<h3 id="pattern-1-validate-then-execute"><a class="header" href="#pattern-1-validate-then-execute">Pattern 1: Validate-Then-Execute</a></h3>
<pre><code class="language-java">Free&lt;OpticOpKind.Witness, Order&gt; orderProcessing = buildOrderProgram(order);

// Step 1: Validate
ValidationOpticInterpreter validator = OpticInterpreters.validating();
ValidationResult validation = validator.validate(orderProcessing);

if (!validation.isValid()) {
    validation.errors().forEach(System.err::println);
    throw new ValidationException("Order processing failed validation");
}

// Step 2: Execute with logging
LoggingOpticInterpreter logger = OpticInterpreters.logging();
Order result = logger.run(orderProcessing);

// Step 3: Persist audit trail
logger.getLog().forEach(entry -&gt; auditRepository.save(order.id(), entry));
</code></pre>
<hr />
<h3 id="pattern-2-profile-optimise-execute"><a class="header" href="#pattern-2-profile-optimise-execute">Pattern 2: Profile-Optimise-Execute</a></h3>
<pre><code class="language-java">Free&lt;OpticOpKind.Witness, Dataset&gt; dataProcessing = buildDataPipeline(dataset);

// Step 1: Profile to find bottlenecks
ProfilingOpticInterpreter profiler = new ProfilingOpticInterpreter();
profiler.run(dataProcessing);

Map&lt;String, Long&gt; times = profiler.getAverageExecutionTimes();
String slowest = times.entrySet().stream()
    .max(Map.Entry.comparingByValue())
    .map(Map.Entry::getKey)
    .orElse("none");

System.out.println("Slowest operation: " + slowest);

// Step 2: Optimise program based on profiling
Free&lt;OpticOpKind.Witness, Dataset&gt; optimised = optimiseProgram(
    dataProcessing,
    slowest
);

// Step 3: Execute optimised program
Dataset result = OpticInterpreters.direct().run(optimised);
</code></pre>
<hr />
<h3 id="pattern-3-test-validate-execute-pipeline"><a class="header" href="#pattern-3-test-validate-execute-pipeline">Pattern 3: Test-Validate-Execute Pipeline</a></h3>
<pre><code class="language-java">// Development: Mock interpreter
MockOpticInterpreter&lt;Order&gt; mockInterp = new MockOpticInterpreter&lt;&gt;(mockOrder);
Order mockResult = mockInterp.run(program);
assert mockResult.status() == OrderStatus.COMPLETED;

// Staging: Validation interpreter
ValidationResult validation = OpticInterpreters.validating().validate(program);
assert validation.isValid();

// Production: Logging interpreter
LoggingOpticInterpreter logger = OpticInterpreters.logging();
Order prodResult = logger.run(program);
logger.getLog().forEach(auditService::record);
</code></pre>
<hr />
<h2 id="part-7-best-practices"><a class="header" href="#part-7-best-practices">Part 7: Best Practices</a></h2>
<h3 id="choose-the-right-interpreter"><a class="header" href="#choose-the-right-interpreter">Choose the Right Interpreter</a></h3>
<div class="table-wrapper"><table><thead><tr><th><strong>Use Case</strong></th><th><strong>Interpreter</strong></th><th><strong>Reason</strong></th></tr></thead><tbody>
<tr><td>Production CRUD</td><td>Direct</td><td>Fast, simple</td></tr>
<tr><td>Financial transactions</td><td>Logging</td><td>Audit trail</td></tr>
<tr><td>Data migration</td><td>Validation</td><td>Safety checks</td></tr>
<tr><td>Unit tests</td><td>Mock/Custom</td><td>No dependencies</td></tr>
<tr><td>Performance tuning</td><td>Profiling</td><td>Measure impact</td></tr>
<tr><td>Compliance</td><td>Logging</td><td>Regulatory requirements</td></tr>
</tbody></table>
</div>
<hr />
<h3 id="interpreter-lifecycle"><a class="header" href="#interpreter-lifecycle">Interpreter Lifecycle</a></h3>
<pre><code class="language-java">// Good: Reuse interpreter for multiple programs
LoggingOpticInterpreter logger = OpticInterpreters.logging();

for (Transaction txn : transactions) {
    Free&lt;OpticOpKind.Witness, Transaction&gt; program = buildTransfer(txn);
    Transaction result = logger.run(program);
    // Log accumulates across programs
}

List&lt;String&gt; fullAuditTrail = logger.getLog();

// Bad: Creating new interpreter each time loses history
for (Transaction txn : transactions) {
    LoggingOpticInterpreter logger = OpticInterpreters.logging();  // New each time!
    Transaction result = logger.run(buildTransfer(txn));
    // Can only see this program's log
}
</code></pre>
<hr />
<h3 id="error-handling-3"><a class="header" href="#error-handling-3">Error Handling</a></h3>
<pre><code class="language-java">Free&lt;OpticOpKind.Witness, Order&gt; program = buildOrderProcessing(order);

// Wrap interpreter execution in try-catch
try {
    // Validate first
    ValidationResult validation = OpticInterpreters.validating().validate(program);

    if (!validation.isValid()) {
        throw new ValidationException(validation.errors());
    }

    // Execute with logging
    LoggingOpticInterpreter logger = OpticInterpreters.logging();
    Order result = logger.run(program);

    // Success - persist log
    auditRepository.saveAll(logger.getLog());

    return result;

} catch (ValidationException e) {
    // Handle validation errors
    logger.error("Validation failed", e);
    throw new BusinessException("Order processing failed validation", e);

} catch (Exception e) {
    // Handle execution errors
    logger.error("Execution failed", e);
    throw new BusinessException("Order processing failed", e);
}
</code></pre>
<hr />
<div id="admonition-further-reading" class="admonition admonish-tip" role="note" aria-labelledby="admonition-further-reading-title">
<div class="admonition-title">
<div id="admonition-further-reading-title">
<p>Further Reading</p>
</div>
<a class="admonition-anchor-link" href="optics/interpreters.html#admonition-further-reading"></a>
</div>
<div>
<ul>
<li><strong>Bartosz Milewski</strong>: <a href="https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/">Category Theory for Programmers</a> - Natural transformations and functors</li>
<li><strong>Gabriel Gonzalez</strong>: <a href="https://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html">Why Free Monads Matter</a> - Free monad interpreters</li>
</ul>
</div>
</div>
<hr />
<p><strong>Next Steps:</strong></p>
<ul>
<li><a href="optics/free_monad_dsl.html">Free Monad DSL for Optics</a> - Building composable programs</li>
<li><a href="optics/fluent_api.html">Fluent API for Optics</a> - Direct execution patterns</li>
<li><a href="optics/cookbook.html">Cookbook</a> - Real-world recipes and patterns</li>
</ul>
<hr />
<p><strong>Previous:</strong> <a href="optics/free_monad_dsl.html">Free Monad DSL</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="optics-v-integration-and-recipes"><a class="header" href="#optics-v-integration-and-recipes">Optics V: Integration and Recipes</a></h1>
<blockquote>
<p><em>"Anything worth doing is worth doing right."</em></p>
<p>– Hunter S. Thompson, <em>Fear and Loathing in Las Vegas</em></p>
</blockquote>
<hr />
<p>Theory is useful; working code is better.</p>
<p>This chapter brings together everything from the previous four into practical patterns you can apply directly. The capstone example demonstrates a complete validation workflow: composing Lens, Prism, and Traversal to validate permissions nested deep within a form structure. It's the sort of problem that would require dozens of lines of imperative code, handled in a few declarative compositions.</p>
<p>The integration sections cover how optics work with higher-kinded-j's core types: extending Lenses and Traversals with additional capabilities, using Prisms for Optional, Either, and other standard containers. If you've wondered how to combine optics with the rest of the library, this is where you'll find answers.</p>
<p>The cookbook provides ready-to-use recipes for common problems: updating nested optionals, modifying specific sum type variants, bulk collection operations with filtering, configuration management, and audit trail generation. Each recipe includes the problem statement, solution code, and explanation of why it works.</p>
<p>Copy freely. That's what they're for.</p>
<hr />
<h2 id="which-optic-do-i-need"><a class="header" href="#which-optic-do-i-need">Which Optic Do I Need?</a></h2>
<p>When facing a new problem, this flowchart helps:</p>
<pre><code>                     ┌─────────────────────┐
                     │ What are you doing? │
                     └──────────┬──────────┘
                                │
           ┌────────────────────┼────────────────────┐
           ▼                    ▼                    ▼
    ┌─────────────┐     ┌─────────────┐     ┌─────────────┐
    │   Reading   │     │  Modifying  │     │ Transforming│
    │    only?    │     │   values?   │     │   types?    │
    └──────┬──────┘     └──────┬──────┘     └──────┬──────┘
           │                   │                   │
           ▼                   │                   ▼
    ┌─────────────┐            │            ┌─────────────┐
    │How many     │            │            │    ISO      │
    │targets?     │            │            └─────────────┘
    └──────┬──────┘            │
           │                   │
    ┌──────┴──────┐            │
    ▼             ▼            ▼
┌───────┐   ┌──────────┐  ┌─────────────┐
│ One   │   │Zero-more │  │How many     │
│       │   │          │  │targets?     │
└───┬───┘   └────┬─────┘  └──────┬──────┘
    │            │               │
    ▼            ▼        ┌──────┴──────┐
┌───────┐   ┌────────┐    ▼             ▼
│GETTER │   │ FOLD   │ ┌───────┐  ┌──────────┐
└───────┘   └────────┘ │ One   │  │Zero-more │
                       └───┬───┘  └────┬─────┘
                           │           │
                 ┌─────────┴───┐       │
                 ▼             ▼       ▼
           ┌──────────┐ ┌─────────┐ ┌──────────┐
           │ Required │ │Optional │ │TRAVERSAL │
           └────┬─────┘ └────┬────┘ └──────────┘
                │            │
                ▼            ▼
           ┌────────┐   ┌─────────┐
           │  LENS  │   │ PRISM   │
           └────────┘   └─────────┘
</code></pre>
<hr />
<h2 id="the-complete-pipeline"><a class="header" href="#the-complete-pipeline">The Complete Pipeline</a></h2>
<p>Optics compose to handle complex real-world scenarios:</p>
<pre><code>    Form
     │
     │ FormLenses.principal()        ← LENS (required field)
     ▼
    Principal (sealed interface)
     │
     │ PrincipalPrisms.user()        ← PRISM (might be Guest)
     ▼
    User
     │
     │ UserTraversals.permissions()  ← TRAVERSAL (list of perms)
     ▼
    List&lt;Permission&gt;
     │
     │ each                          ← focus on each
     ▼
    Permission
     │
     │ PermissionLenses.name()       ← LENS (required field)
     ▼
    String
     │
     │ validate(name)                ← effectful modification
     ▼
    Validated&lt;Error, String&gt;

    ═══════════════════════════════════════════════════════════
    Result: Validated&lt;List&lt;Error&gt;, Form&gt;
</code></pre>
<p>All permissions validated. All errors accumulated. Original structure preserved.</p>
<hr />
<h2 id="what-youll-learn-7"><a class="header" href="#what-youll-learn-7">What You'll Learn</a></h2>
<div id="admonition-in-this-chapter" class="admonition admonish-info" role="note" aria-labelledby="admonition-in-this-chapter-title">
<div class="admonition-title">
<div id="admonition-in-this-chapter-title">
<p>In This Chapter</p>
</div>
<a class="admonition-anchor-link" href="optics/ch5_intro.html#admonition-in-this-chapter"></a>
</div>
<div>
<ul>
<li><strong>Composing Optics</strong> – A complete walkthrough building a validation pipeline that composes Lens, Prism, and Traversal to validate deeply nested permissions in a form structure.</li>
<li><strong>Core Type Integration</strong> – How optics work with the library's functional types. Use Prisms to focus on Right values in Either, or Some values in Maybe.</li>
<li><strong>Optics Extensions</strong> – Additional capabilities beyond the basics. Extended Lens operations, Traversal utilities, and convenience methods for common patterns.</li>
<li><strong>Cookbook</strong> – Copy-paste solutions for frequent problems. Updating nested optionals, modifying specific sum type variants, bulk collection operations, configuration management.</li>
<li><strong>Auditing Complex Data</strong> – A production-ready example generating audit trails. Track every change to a complex nested structure with full before/after comparisons.</li>
</ul>
</div>
</div>
<hr />
<h2 id="chapter-contents-7"><a class="header" href="#chapter-contents-7">Chapter Contents</a></h2>
<ol>
<li><a href="optics/composing_optics.html">Composing Optics</a> - A complete validation workflow example</li>
<li><a href="optics/core_type_integration.html">Core Type Integration</a> - Using optics with Either, Maybe, Validated, and Optional</li>
<li><a href="optics/optics_extensions.html">Optics Extensions</a> - Extended capabilities for Lens and Traversal</li>
<li><a href="optics/cookbook.html">Cookbook</a> - Ready-to-use recipes for common problems</li>
<li><a href="optics/auditing_complex_data_example.html">Auditing Complex Data</a> - Real-world audit trail generation</li>
</ol>
<hr />
<p><strong>Next:</strong> <a href="optics/composing_optics.html">Composing Optics</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="capstone-example"><a class="header" href="#capstone-example">Capstone Example:</a></h1>
<h2 id="composing-optics-for-deep-validation"><a class="header" href="#composing-optics-for-deep-validation"><em>Composing Optics for Deep Validation</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="optics/composing_optics.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to compose multiple optic types into powerful processing pipelines</li>
<li>Building type-safe validation workflows with error accumulation</li>
<li>Using <code>asTraversal()</code> to ensure safe optic composition</li>
<li>Creating reusable validation paths with effectful operations</li>
<li>Simplified validation with <code>modifyAllValidated</code>, <code>modifyAllEither</code>, and <code>modifyMaybe</code></li>
<li>Understanding when composition is superior to manual validation logic</li>
<li>Advanced patterns for multi-level and conditional validation scenarios</li>
</ul>
</div>
</div>
<div id="admonition-hands-on-practice" class="admonition admonish-note" role="note" aria-labelledby="admonition-hands-on-practice-title">
<div class="admonition-title">
<div id="admonition-hands-on-practice-title">
<p>Hands On Practice</p>
</div>
<a class="admonition-anchor-link" href="optics/composing_optics.html#admonition-hands-on-practice"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/optics/Tutorial06_OpticsComposition.java">Tutorial06_OpticsComposition.java</a></p>
</div>
</div>
<div id="admonition-example-code" class="admonition admonish-note" role="note" aria-labelledby="admonition-example-code-title">
<div class="admonition-title">
<div id="admonition-example-code-title">
<p>Example Code</p>
</div>
<a class="admonition-anchor-link" href="optics/composing_optics.html#admonition-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/ValidatedTraversalExample.java">ValidatedTraversalExample</a></p>
</div>
</div>
<p>In the previous guides, we explored each core optic (<code>Lens</code>, <code>Prism</code>, <code>Iso</code> and <code>Traversal</code>) as individual tools. We've seen how they provide focused, reusable, and composable access to immutable data.</p>
<p>Now, it's time to put it all together.</p>
<p>This guide showcases the true power of the optics approach by composing multiple different optics to solve a single, complex, real-world problem: performing deep, effectful validation on a nested data structure.</p>
<hr />
<h2 id="the-scenario-validating-user-permissions"><a class="header" href="#the-scenario-validating-user-permissions">The Scenario: Validating User Permissions</a></h2>
<p>Imagine a data model for a form that can be filled out by either a registered <code>User</code> or a <code>Guest</code>. Our goal is to validate that every <code>Permission</code> held by a <code>User</code> has a valid name.</p>
<p>This single task requires us to:</p>
<ol>
<li>Focus on the form's <code>principal</code> field (<strong>a job for a Lens</strong>).</li>
<li>Safely "select" the <code>User</code> case, ignoring any <code>Guest</code>s (<strong>a job for a Prism</strong>).</li>
<li>Operate on every <code>Permission</code> in the userLogin's list (<strong>a job for a Traversal</strong>).</li>
</ol>
<hr />
<h2 id="think-of-this-composition-like"><a class="header" href="#think-of-this-composition-like">Think of This Composition Like...</a></h2>
<ul>
<li><strong>A telescope with multiple lenses</strong>: Each optic focuses deeper into the data structure</li>
<li><strong>A manufacturing pipeline</strong>: Each stage processes and refines the data further</li>
<li><strong>A filter chain</strong>: Data flows through multiple filters, each handling a specific concern</li>
<li><strong>A surgical procedure</strong>: Precise, layered operations that work together for a complex outcome</li>
</ul>
<hr />
<h3 id="1-the-data-model"><a class="header" href="#1-the-data-model">1. The Data Model</a></h3>
<p>Here is the nested data structure, annotated to generate all the optics we will need.</p>
<pre><code class="language-java">import org.higherkindedj.optics.annotations.GenerateLenses;
import org.higherkindedj.optics.annotations.GeneratePrisms;
import org.higherkindedj.optics.annotations.GenerateTraversals;
import java.util.List;

@GenerateLenses
public record Permission(String name) {}

@GeneratePrisms
public sealed interface Principal {}

@GenerateLenses
@GenerateTraversals
public record User(String username, List&lt;Permission&gt; permissions) implements Principal {}

public record Guest() implements Principal {}

@GenerateLenses
public record Form(int formId, Principal principal) {}
</code></pre>
<h3 id="2-the-validation-logic"><a class="header" href="#2-the-validation-logic">2. The Validation Logic</a></h3>
<p>Our validation function will take a permission name (<code>String</code>) and return a <code>Validated&lt;String, String&gt;</code>. The <code>Validated</code> applicative functor will automatically handle accumulating any errors found.</p>
<pre><code class="language-java">import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.validated.Validated;
import org.higherkindedj.hkt.validated.ValidatedKind;
import static org.higherkindedj.hkt.validated.ValidatedKindHelper.VALIDATED;
import java.util.Set;

private static final Set&lt;String&gt; VALID_PERMISSIONS = Set.of("PERM_READ", "PERM_WRITE", "PERM_DELETE");

public static Kind&lt;ValidatedKind.Witness&lt;String&gt;, String&gt; validatePermissionName(String name) {
    if (VALID_PERMISSIONS.contains(name)) {
        return VALIDATED.widen(Validated.valid(name));
    } else {
        return VALIDATED.widen(Validated.invalid("Invalid permission: " + name));
    }
}
</code></pre>
<h3 id="3-understanding-the-composition-strategy"><a class="header" href="#3-understanding-the-composition-strategy">3. Understanding the Composition Strategy</a></h3>
<p>Before diving into the code, let's understand why we need each type of optic and how they work together:</p>
<p><strong>Why a Lens for <code>principal</code>?</strong></p>
<ul>
<li>The <code>principal</code> field always exists in a <code>Form</code></li>
<li>We need guaranteed access to focus on this field</li>
<li>A <code>Lens</code> provides exactly this: reliable access to required data</li>
</ul>
<p><strong>Why a Prism for <code>User</code>?</strong></p>
<ul>
<li>The <code>principal</code> could be either a <code>User</code> or a <code>Guest</code></li>
<li>We only want to validate <code>User</code> permissions, ignoring <code>Guest</code>s</li>
<li>A <code>Prism</code> provides safe, optional access to specific sum type cases</li>
</ul>
<p><strong>Why a Traversal for <code>permissions</code>?</strong></p>
<ul>
<li>We need to validate <em>every</em> permission in the list</li>
<li>We want to accumulate <em>all</em> validation errors, not stop at the first one</li>
<li>A <code>Traversal</code> provides bulk operations over collections</li>
</ul>
<p><strong>Why convert everything to <code>Traversal</code>?</strong></p>
<ul>
<li><code>Traversal</code> is the most general optic type</li>
<li>It can represent zero-or-more targets (perfect for our "might be empty" scenario)</li>
<li>All other optics can be converted to <code>Traversal</code> for seamless composition</li>
</ul>
<h3 id="4-composing-the-master-optic"><a class="header" href="#4-composing-the-master-optic">4. Composing the Master Optic</a></h3>
<p>Now for the main event. We will compose our generated optics to create a single <code>Traversal</code> that declaratively represents the path from a <code>Form</code> all the way down to each permission <code>name</code>. While the new <code>with*</code> helpers are great for simple, shallow updates, a deep and conditional update like this requires composition.</p>
<p>To ensure type-safety across different optic types, we convert each <code>Lens</code> and <code>Prism</code> in the chain to a <code>Traversal</code> using the <code>.asTraversal()</code> method.</p>
<pre><code class="language-java">import org.higherkindedj.optics.Lens;
import org.higherkindedj.optics.Prism;
import org.higherkindedj.optics.Traversal;

// Get the individual generated optics
Lens&lt;Form, Principal&gt; formPrincipalLens = FormLenses.principal();
Prism&lt;Principal, User&gt; principalUserPrism = PrincipalPrisms.userLogin();
Traversal&lt;User, Permission&gt; userPermissionsTraversal = UserTraversals.permissions();
Lens&lt;Permission, String&gt; permissionNameLens = PermissionLenses.name();

// Compose them into a single, deep Traversal
Traversal&lt;Form, String&gt; formToPermissionNameTraversal =
    formPrincipalLens.asTraversal()
        .andThen(principalUserPrism.asTraversal())
        .andThen(userPermissionsTraversal)
        .andThen(permissionNameLens.asTraversal());
</code></pre>
<p>This single <code>formToPermissionNameTraversal</code> object now encapsulates the entire complex path.</p>
<hr />
<h2 id="when-to-use-optic-composition-vs-other-approaches"><a class="header" href="#when-to-use-optic-composition-vs-other-approaches">When to Use Optic Composition vs Other Approaches</a></h2>
<h3 id="use-optic-composition-when"><a class="header" href="#use-optic-composition-when">Use Optic Composition When:</a></h3>
<ul>
<li><strong>Complex nested validation</strong> - Multiple levels of data structure with conditional logic</li>
<li><strong>Reusable validation paths</strong> - The same validation logic applies to multiple scenarios</li>
<li><strong>Type-safe bulk operations</strong> - You need to ensure compile-time safety for collection operations</li>
<li><strong>Error accumulation</strong> - You want to collect all errors, not stop at the first failure</li>
</ul>
<pre><code class="language-java">// Perfect for reusable, complex validation
Traversal&lt;Company, String&gt; allEmployeeEmails = 
    CompanyTraversals.departments()
        .andThen(DepartmentTraversals.employees())
        .andThen(EmployeePrisms.active().asTraversal())  // Only active employees
        .andThen(EmployeeLenses.email().asTraversal());

// Use across multiple validation scenarios
Validated&lt;List&lt;String&gt;, Company&gt; result1 = validateEmails(company1);
Validated&lt;List&lt;String&gt;, Company&gt; result2 = validateEmails(company2);
</code></pre>
<h3 id="use-direct-validation-when"><a class="header" href="#use-direct-validation-when">Use Direct Validation When:</a></h3>
<ul>
<li><strong>Simple, flat structures</strong> - No deep nesting or conditional access needed</li>
<li><strong>One-off validation</strong> - Logic won't be reused elsewhere</li>
<li><strong>Performance critical</strong> - Minimal abstraction overhead required</li>
</ul>
<pre><code class="language-java">// Simple validation doesn't need optics
public Validated&lt;String, User&gt; validateUser(User userLogin) {
    if (userLogin.username().length() &lt; 3) {
        return Validated.invalid("Username too short");
    }
    return Validated.valid(userLogin);
}
</code></pre>
<h3 id="use-stream-processing-when"><a class="header" href="#use-stream-processing-when">Use Stream Processing When:</a></h3>
<ul>
<li><strong>Complex transformations</strong> - Multiple operations that don't map to optic patterns</li>
<li><strong>Aggregation logic</strong> - Computing statistics or summaries</li>
<li><strong>Filtering and collecting</strong> - Changing the structure of collections</li>
</ul>
<pre><code class="language-java">// Better with streams for aggregation
Map&lt;String, Long&gt; permissionCounts = forms.stream()
    .map(Form::principal)
    .filter(User.class::isInstance)
    .map(User.class::cast)
    .flatMap(userLogin -&gt; userLogin.permissions().stream())
    .collect(groupingBy(Permission::name, counting()));
</code></pre>
<hr />
<h2 id="common-pitfalls-27"><a class="header" href="#common-pitfalls-27">Common Pitfalls</a></h2>
<h3 id="dont-do-this-13"><a class="header" href="#dont-do-this-13">Don't Do This:</a></h3>
<pre><code class="language-java">// Over-composing simple cases
Traversal&lt;Form, Integer&gt; formIdTraversal = FormLenses.formId().asTraversal();
// Just use: form.formId()

// Forgetting error accumulation setup
// This won't accumulate errors properly without the right Applicative
var badResult = traversal.modifyF(validatePermissionName, form, /* wrong applicative */);

// Creating complex compositions inline
var inlineResult = FormLenses.principal().asTraversal()
    .andThen(PrincipalPrisms.userLogin().asTraversal())
    .andThen(UserTraversals.permissions())
    .andThen(PermissionLenses.name().asTraversal())
    .modifyF(validatePermissionName, form, applicative); // Hard to read and reuse

// Ignoring the path semantics
// This tries to validate ALL strings, not just permission names
Traversal&lt;Form, String&gt; badTraversal = /* any string traversal */;
</code></pre>
<h3 id="do-this-instead-13"><a class="header" href="#do-this-instead-13">Do This Instead:</a></h3>
<pre><code class="language-java">// Use direct access for simple cases
int formId = form.formId(); // Clear and direct

// Set up error accumulation properly
Applicative&lt;ValidatedKind.Witness&lt;String&gt;&gt; validatedApplicative =
    ValidatedMonad.instance(Semigroups.string("; "));

// Create reusable, well-named compositions
public static final Traversal&lt;Form, String&gt; FORM_TO_PERMISSION_NAMES =
    FormLenses.principal().asTraversal()
        .andThen(PrincipalPrisms.userLogin().asTraversal())
        .andThen(UserTraversals.permissions())
        .andThen(PermissionLenses.name().asTraversal());

// Use the well-named traversal
var result = FORM_TO_PERMISSION_NAMES.modifyF(validatePermissionName, form, validatedApplicative);

// Be specific about what you're validating
// This traversal has clear semantics: Form -&gt; User permissions -&gt; permission names
</code></pre>
<hr />
<h2 id="performance-notes-12"><a class="header" href="#performance-notes-12">Performance Notes</a></h2>
<p>Optic composition is designed for efficiency:</p>
<ul>
<li><strong>Lazy evaluation</strong>: Only processes data when actually used</li>
<li><strong>Structural sharing</strong>: Unchanged parts of data structures are reused</li>
<li><strong>Single-pass processing</strong>: <code>modifyF</code> traverses the structure only once</li>
<li><strong>Memory efficient</strong>: Only creates new objects for changed data</li>
<li><strong>JIT compiler optimisation</strong>: Complex compositions are optimised by the JVM's just-in-time compiler through method inlining</li>
</ul>
<p><strong>Best Practice</strong>: Create composed optics as constants for reuse:</p>
<pre><code class="language-java">public class ValidationOptics {
    // Reusable validation paths
    public static final Traversal&lt;Form, String&gt; USER_PERMISSION_NAMES =
        FormLenses.principal().asTraversal()
            .andThen(PrincipalPrisms.userLogin().asTraversal())
            .andThen(UserTraversals.permissions())
            .andThen(PermissionLenses.name().asTraversal());
  
    public static final Traversal&lt;Company, String&gt; EMPLOYEE_EMAILS =
        CompanyTraversals.employees()
            .andThen(EmployeeLenses.contactInfo().asTraversal())
            .andThen(ContactInfoLenses.email().asTraversal());
  
    // Helper methods for common validations
    public static Validated&lt;List&lt;String&gt;, Form&gt; validatePermissions(Form form) {
        return VALIDATED.narrow(USER_PERMISSION_NAMES.modifyF(
            ValidationOptics::validatePermissionName,
            form,
            getValidatedApplicative()
        ));
    }
}
</code></pre>
<hr />
<h2 id="advanced-composition-patterns"><a class="header" href="#advanced-composition-patterns">Advanced Composition Patterns</a></h2>
<h3 id="1-multi-level-validation"><a class="header" href="#1-multi-level-validation">1. Multi-Level Validation</a></h3>
<pre><code class="language-java">// Validate both userLogin data AND permissions in one pass
public static Validated&lt;List&lt;String&gt;, Form&gt; validateFormCompletely(Form form) {
    // First validate userLogin basic info
    var userValidation = FormLenses.principal().asTraversal()
        .andThen(PrincipalPrisms.userLogin().asTraversal())
        .andThen(UserLenses.username().asTraversal())
        .modifyF(ValidationOptics::validateUsername, form, getValidatedApplicative());
  
    // Then validate permissions
    var permissionValidation = FORM_TO_PERMISSION_NAMES
        .modifyF(ValidationOptics::validatePermissionName, form, getValidatedApplicative());
  
    // Combine both validations
    return VALIDATED.narrow(getValidatedApplicative().map2(
        userValidation,
        permissionValidation,
        (validForm1, validForm2) -&gt; validForm2 // Return the final form
    ));
}
</code></pre>
<h3 id="2-conditional-validation-paths"><a class="header" href="#2-conditional-validation-paths">2. Conditional Validation Paths</a></h3>
<pre><code class="language-java">// Different validation rules for different userLogin types
public static final Traversal&lt;Form, String&gt; ADMIN_USER_PERMISSIONS =
    FormLenses.principal().asTraversal()
        .andThen(PrincipalPrisms.userLogin().asTraversal())
        .andThen(UserPrisms.adminUser().asTraversal())  // Only admin users
        .andThen(AdminUserTraversals.permissions())
        .andThen(PermissionLenses.name().asTraversal());

public static final Traversal&lt;Form, String&gt; REGULAR_USER_PERMISSIONS =
    FormLenses.principal().asTraversal()
        .andThen(PrincipalPrisms.userLogin().asTraversal())
        .andThen(UserPrisms.regularUser().asTraversal())  // Only regular users
        .andThen(RegularUserTraversals.permissions())
        .andThen(PermissionLenses.name().asTraversal());
</code></pre>
<h3 id="3-cross-field-validation"><a class="header" href="#3-cross-field-validation">3. Cross-Field Validation</a></h3>
<pre><code class="language-java">// Validate that permissions are appropriate for userLogin role
public static Validated&lt;List&lt;String&gt;, Form&gt; validatePermissionsForRole(Form form) {
    return FormLenses.principal().asTraversal()
        .andThen(PrincipalPrisms.userLogin().asTraversal())
        .modifyF(userLogin -&gt; {
            // Custom validation that checks both role and permissions
            Set&lt;String&gt; allowedPerms = getAllowedPermissionsForRole(userLogin.role());
            List&lt;String&gt; errors = userLogin.permissions().stream()
                .map(Permission::name)
                .filter(perm -&gt; !allowedPerms.contains(perm))
                .map(perm -&gt; "Permission '" + perm + "' not allowed for role " + userLogin.role())
                .toList();
          
            return errors.isEmpty() 
                ? VALIDATED.widen(Validated.valid(userLogin))
                : VALIDATED.widen(Validated.invalid(String.join("; ", errors)));
        }, form, getValidatedApplicative());
}
</code></pre>
<hr />
<h2 id="complete-runnable-example-8"><a class="header" href="#complete-runnable-example-8">Complete, Runnable Example</a></h2>
<p>With our composed <code>Traversal</code>, we can now use <code>modifyF</code> to run our validation logic. The <code>Traversal</code> handles the navigation and filtering, while the <code>Validated</code> applicative (created with a <code>Semigroup</code> for joining error strings) handles the effects and error accumulation.</p>
<pre><code class="language-java">package org.higherkindedj.example.optics;

import static org.higherkindedj.hkt.validated.ValidatedKindHelper.VALIDATED;

import java.util.List;
import java.util.Set;
import org.higherkindedj.hkt.Applicative;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.Semigroups;
import org.higherkindedj.hkt.validated.Validated;
import org.higherkindedj.hkt.validated.ValidatedKind;
import org.higherkindedj.hkt.validated.ValidatedMonad;
import org.higherkindedj.optics.Lens;
import org.higherkindedj.optics.Prism;
import org.higherkindedj.optics.Traversal;
import org.higherkindedj.optics.annotations.GenerateLenses;
import org.higherkindedj.optics.annotations.GeneratePrisms;
import org.higherkindedj.optics.annotations.GenerateTraversals;

public class ValidatedTraversalExample {

    // --- Data Model ---
    @GenerateLenses
    public record Permission(String name) {}

    @GeneratePrisms
    public sealed interface Principal {}

    @GenerateLenses
    @GenerateTraversals
    public record User(String username, List&lt;Permission&gt; permissions) implements Principal {}

    public record Guest() implements Principal {}

    @GenerateLenses
    public record Form(int formId, Principal principal) {}

    // --- Validation Logic ---
    private static final Set&lt;String&gt; VALID_PERMISSIONS = Set.of("PERM_READ", "PERM_WRITE", "PERM_DELETE");

    public static Kind&lt;ValidatedKind.Witness&lt;String&gt;, String&gt; validatePermissionName(String name) {
        if (VALID_PERMISSIONS.contains(name)) {
            return VALIDATED.widen(Validated.valid(name));
        } else {
            return VALIDATED.widen(Validated.invalid("Invalid permission: " + name));
        }
    }

    // --- Reusable Optic Compositions ---
    public static final Traversal&lt;Form, String&gt; FORM_TO_PERMISSION_NAMES =
            FormLenses.principal().asTraversal()
                    .andThen(PrincipalPrisms.userLogin().asTraversal())
                    .andThen(UserTraversals.permissions())
                    .andThen(PermissionLenses.name().asTraversal());

    // --- Helper Methods ---
    private static Applicative&lt;ValidatedKind.Witness&lt;String&gt;&gt; getValidatedApplicative() {
        return ValidatedMonad.instance(Semigroups.string("; "));
    }

    public static Validated&lt;String, Form&gt; validateFormPermissions(Form form) {
        Kind&lt;ValidatedKind.Witness&lt;String&gt;, Form&gt; result =
                FORM_TO_PERMISSION_NAMES.modifyF(
                        ValidatedTraversalExample::validatePermissionName,
                        form,
                        getValidatedApplicative()
                );
        return VALIDATED.narrow(result);
    }

    public static void main(String[] args) {
        System.out.println("=== OPTIC COMPOSITION VALIDATION EXAMPLE ===");
        System.out.println();

        // --- SCENARIO 1: Form with valid permissions ---
        System.out.println("--- Scenario 1: Valid Permissions ---");
        var validUser = new User("alice", List.of(
                new Permission("PERM_READ"),
                new Permission("PERM_WRITE")
        ));
        var validForm = new Form(1, validUser);

        System.out.println("Input: " + validForm);
        Validated&lt;String, Form&gt; validResult = validateFormPermissions(validForm);
        System.out.println("Result: " + validResult);
        System.out.println();

        // --- SCENARIO 2: Form with multiple invalid permissions ---
        System.out.println("--- Scenario 2: Multiple Invalid Permissions ---");
        var invalidUser = new User("charlie", List.of(
                new Permission("PERM_EXECUTE"),  // Invalid
                new Permission("PERM_WRITE"),    // Valid
                new Permission("PERM_SUDO"),     // Invalid
                new Permission("PERM_READ")      // Valid
        ));
        var multipleInvalidForm = new Form(3, invalidUser);

        System.out.println("Input: " + multipleInvalidForm);
        Validated&lt;String, Form&gt; invalidResult = validateFormPermissions(multipleInvalidForm);
        System.out.println("Result (errors accumulated): " + invalidResult);
        System.out.println();

        // --- SCENARIO 3: Form with Guest principal (no targets for traversal) ---
        System.out.println("--- Scenario 3: Guest Principal (No Validation Targets) ---");
        var guestForm = new Form(4, new Guest());

        System.out.println("Input: " + guestForm);
        Validated&lt;String, Form&gt; guestResult = validateFormPermissions(guestForm);
        System.out.println("Result (path does not match): " + guestResult);
        System.out.println();

        // --- SCENARIO 4: Form with empty permissions list ---
        System.out.println("--- Scenario 4: Empty Permissions List ---");
        var emptyPermissionsUser = new User("diana", List.of());
        var emptyPermissionsForm = new Form(5, emptyPermissionsUser);

        System.out.println("Input: " + emptyPermissionsForm);
        Validated&lt;String, Form&gt; emptyResult = validateFormPermissions(emptyPermissionsForm);
        System.out.println("Result (empty list): " + emptyResult);
        System.out.println();

        // --- SCENARIO 5: Demonstrating optic reusability ---
        System.out.println("--- Scenario 5: Optic Reusability ---");

        List&lt;Form&gt; formsToValidate = List.of(validForm, multipleInvalidForm, guestForm);

        System.out.println("Batch validation results:");
        formsToValidate.forEach(form -&gt; {
            Validated&lt;String, Form&gt; result = validateFormPermissions(form);
            String status = result.isValid() ? "✓ VALID" : "✗ INVALID";
            System.out.println("  Form " + form.formId() + ": " + status);
            if (result.isInvalid()) {
                // Fix: Use getError() instead of getInvalid()
                System.out.println("    Errors: " + result.getError());
            }
        });
        System.out.println();

        // --- SCENARIO 6: Alternative validation with different error accumulation ---
        System.out.println("--- Scenario 6: Different Error Accumulation Strategy ---");

        // Use list-based error accumulation instead of string concatenation
        Applicative&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;&gt; listApplicative =
                ValidatedMonad.instance(Semigroups.list());

        // Fix: Create a proper function for list validation
        java.util.function.Function&lt;String, Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, String&gt;&gt; listValidation =
                name -&gt; VALID_PERMISSIONS.contains(name)
                        ? VALIDATED.widen(Validated.valid(name))
                        : VALIDATED.widen(Validated.invalid(List.of("Invalid permission: " + name)));

        Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Form&gt; listResult =
                FORM_TO_PERMISSION_NAMES.modifyF(listValidation, multipleInvalidForm, listApplicative);

        System.out.println("Input: " + multipleInvalidForm);
        System.out.println("Result with list accumulation: " + VALIDATED.narrow(listResult));
    }
}
</code></pre>
<p><strong>Expected Output:</strong></p>
<pre><code>=== OPTIC COMPOSITION VALIDATION EXAMPLE ===

--- Scenario 1: Valid Permissions ---
Input: Form[formId=1, principal=User[username=alice, permissions=[Permission[name=PERM_READ], Permission[name=PERM_WRITE]]]]
Result: Valid(Form[formId=1, principal=User[username=alice, permissions=[Permission[name=PERM_READ], Permission[name=PERM_WRITE]]]])

--- Scenario 2: Multiple Invalid Permissions ---
Input: Form[formId=3, principal=User[username=charlie, permissions=[Permission[name=PERM_EXECUTE], Permission[name=PERM_WRITE], Permission[name=PERM_SUDO], Permission[name=PERM_READ]]]]
Result (errors accumulated): Invalid(Invalid permission: PERM_EXECUTE; Invalid permission: PERM_SUDO)

--- Scenario 3: Guest Principal (No Validation Targets) ---
Input: Form[formId=4, principal=Guest[]]
Result (path does not match): Valid(Form[formId=4, principal=Guest[]])

--- Scenario 4: Empty Permissions List ---
Input: Form[formId=5, principal=User[username=diana, permissions=[]]]
Result (empty list): Valid(Form[formId=5, principal=User[username=diana, permissions=[]]])

--- Scenario 5: Optic Reusability ---
Batch validation results:
  Form 1: ✓ VALID
  Form 3: ✗ INVALID
    Errors: Invalid permission: PERM_EXECUTE; Invalid permission: PERM_SUDO
  Form 4: ✓ VALID

--- Scenario 6: Different Error Accumulation Strategy ---
Input: Form[formId=3, principal=User[username=charlie, permissions=[Permission[name=PERM_EXECUTE], Permission[name=PERM_WRITE], Permission[name=PERM_SUDO], Permission[name=PERM_READ]]]]
Result with list accumulation: Invalid([Invalid permission: PERM_EXECUTE, Invalid permission: PERM_SUDO])
</code></pre>
<p>This shows how our single, composed optic correctly handled all cases: it accumulated multiple failures into a single <code>Invalid</code> result, and it correctly did nothing (resulting in a <code>Valid</code> state) when the path did not match. This is the power of composing simple, reusable optics to solve complex problems in a safe, declarative, and boilerplate-free way.</p>
<hr />
<h2 id="why-this-approach-is-powerful"><a class="header" href="#why-this-approach-is-powerful">Why This Approach is Powerful</a></h2>
<p>This capstone example demonstrates several key advantages of the optics approach:</p>
<h3 id="declarative-composition"><a class="header" href="#declarative-composition"><strong>Declarative Composition</strong></a></h3>
<p>The <code>formToPermissionNameTraversal</code> reads like a clear path specification: "From a Form, go to the principal, if it's a User, then to each permission, then to each name." This is self-documenting code.</p>
<h3 id="type-safety"><a class="header" href="#type-safety"><strong>Type Safety</strong></a></h3>
<p>Every step in the composition is checked at compile time. It's impossible to accidentally apply permission validation to Guest data or to skip the User filtering step.</p>
<h3 id="automatic-error-accumulation"><a class="header" href="#automatic-error-accumulation"><strong>Automatic Error Accumulation</strong></a></h3>
<p>The <code>Validated</code> applicative automatically collects all validation errors without us having to write any error-handling boilerplate. We get comprehensive validation reports for free.</p>
<h3 id="reusability"><a class="header" href="#reusability"><strong>Reusability</strong></a></h3>
<p>The same composed optic can be used for validation, data extraction, transformation, or any other operation. We write the path once and reuse it everywhere.</p>
<h3 id="composability"><a class="header" href="#composability"><strong>Composability</strong></a></h3>
<p>Each individual optic (Lens, Prism, Traversal) can be tested and reasoned about independently, then composed to create more complex behaviour.</p>
<h3 id="graceful-handling-of-edge-cases"><a class="header" href="#graceful-handling-of-edge-cases"><strong>Graceful Handling of Edge Cases</strong></a></h3>
<p>The composition automatically handles empty collections, missing data, and type mismatches without special case code.</p>
<p>By mastering optic composition, you gain a powerful tool for building robust, maintainable data processing pipelines that are both expressive and efficient.</p>
<hr />
<h2 id="modern-simplification-validation-aware-methods"><a class="header" href="#modern-simplification-validation-aware-methods">Modern Simplification: Validation-Aware Methods</a></h2>
<div id="admonition-enhanced-validation-patterns" class="admonition admonish-tip" role="note" aria-labelledby="admonition-enhanced-validation-patterns-title">
<div class="admonition-title">
<div id="admonition-enhanced-validation-patterns-title">
<p>Enhanced Validation Patterns</p>
</div>
<a class="admonition-anchor-link" href="optics/composing_optics.html#admonition-enhanced-validation-patterns"></a>
</div>
<div>
<p>Higher-kinded-j provides specialised validation methods that simplify the patterns shown above. These methods eliminate the need for explicit <code>Applicative</code> setup whilst maintaining full type safety and error accumulation capabilities.</p>
</div>
</div>
<h3 id="the-traditional-approach-revisited"><a class="header" href="#the-traditional-approach-revisited">The Traditional Approach (Revisited)</a></h3>
<p>In the examples above, we used the general <code>modifyF</code> method with explicit <code>Applicative</code> configuration:</p>
<pre><code class="language-java">// Traditional approach: requires explicit Applicative setup
Applicative&lt;ValidatedKind.Witness&lt;String&gt;&gt; applicative =
    ValidatedMonad.instance(Semigroups.string("; "));

Kind&lt;ValidatedKind.Witness&lt;String&gt;, Form&gt; result =
    FORM_TO_PERMISSION_NAMES.modifyF(
        ValidatedTraversalExample::validatePermissionName,
        form,
        applicative
    );

Validated&lt;String, Form&gt; validated = VALIDATED.narrow(result);
</code></pre>
<p>Whilst powerful and flexible, this approach requires:</p>
<ul>
<li>Understanding of <code>Applicative</code> functors</li>
<li>Manual creation of the <code>Applicative</code> instance</li>
<li>Explicit narrowing of <code>Kind</code> results</li>
<li>Knowledge of <code>Witness</code> types and HKT encoding</li>
</ul>
<h3 id="the-simplified-approach-validation-aware-methods"><a class="header" href="#the-simplified-approach-validation-aware-methods">The Simplified Approach: Validation-Aware Methods</a></h3>
<p>The new validation-aware methods provide a more direct API for common validation patterns:</p>
<h4 id="1-error-accumulation-with-modifyallvalidated"><a class="header" href="#1-error-accumulation-with-modifyallvalidated">1. <strong>Error Accumulation with <code>modifyAllValidated</code></strong></a></h4>
<p>Simplifies the most common case: validating multiple fields and accumulating all errors.</p>
<pre><code class="language-java">import static org.higherkindedj.optics.fluent.OpticOps.modifyAllValidated;

// Simplified: direct Validated result, automatic error accumulation
Validated&lt;List&lt;String&gt;, Form&gt; result = modifyAllValidated(
    FORM_TO_PERMISSION_NAMES,
    name -&gt; VALID_PERMISSIONS.contains(name)
        ? Validated.valid(name)
        : Validated.invalid(List.of("Invalid permission: " + name)),
    form
);
</code></pre>
<p><strong>Benefits:</strong></p>
<ul>
<li>No <code>Applicative</code> setup required</li>
<li>Direct <code>Validated</code> result (no <code>Kind</code> wrapping)</li>
<li>Automatic error accumulation with <code>List&lt;E&gt;</code></li>
<li>Clear intent: "validate all and collect errors"</li>
</ul>
<h4 id="2-short-circuit-validation-with-modifyalleither"><a class="header" href="#2-short-circuit-validation-with-modifyalleither">2. <strong>Short-Circuit Validation with <code>modifyAllEither</code></strong></a></h4>
<p>For performance-critical validation that stops at the first error:</p>
<pre><code class="language-java">import static org.higherkindedj.optics.fluent.OpticOps.modifyAllEither;

// Short-circuit: stops at first error
Either&lt;String, Form&gt; result = modifyAllEither(
    FORM_TO_PERMISSION_NAMES,
    name -&gt; VALID_PERMISSIONS.contains(name)
        ? Either.right(name)
        : Either.left("Invalid permission: " + name),
    form
);
</code></pre>
<p><strong>Benefits:</strong></p>
<ul>
<li>Stops processing on first error (performance optimisation)</li>
<li>Direct <code>Either</code> result</li>
<li>Perfect for fail-fast validation</li>
<li>No unnecessary computation after failure</li>
</ul>
<h3 id="comparison-traditional-vs-validation-aware-methods"><a class="header" href="#comparison-traditional-vs-validation-aware-methods">Comparison: Traditional vs Validation-Aware Methods</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th>Traditional <code>modifyF</code></th><th>Validation-Aware Methods</th></tr></thead><tbody>
<tr><td><strong>Applicative Setup</strong></td><td>Required (explicit)</td><td>Not required (automatic)</td></tr>
<tr><td><strong>Type Complexity</strong></td><td>High (<code>Kind</code>, <code>Witness</code>)</td><td>Low (direct types)</td></tr>
<tr><td><strong>Error Accumulation</strong></td><td>Yes (via Applicative)</td><td>Yes (<code>modifyAllValidated</code>)</td></tr>
<tr><td><strong>Short-Circuiting</strong></td><td>Manual (via Either Applicative)</td><td>Built-in (<code>modifyAllEither</code>)</td></tr>
<tr><td><strong>Learning Curve</strong></td><td>Steep (HKT knowledge)</td><td>Gentle (familiar types)</td></tr>
<tr><td><strong>Flexibility</strong></td><td>Maximum (any Applicative)</td><td>Focused (common patterns)</td></tr>
<tr><td><strong>Boilerplate</strong></td><td>More (setup code)</td><td>Less (direct API)</td></tr>
<tr><td><strong>Use Case</strong></td><td>Generic effectful operations</td><td>Validation-specific scenarios</td></tr>
</tbody></table>
</div>
<h3 id="when-to-use-each-approach"><a class="header" href="#when-to-use-each-approach">When to Use Each Approach</a></h3>
<p><strong>Use <code>modifyAllValidated</code> when:</strong></p>
<ul>
<li>You need to <strong>collect all validation errors</strong></li>
<li>Building <strong>form validation</strong> or <strong>data quality checks</strong></li>
<li>Users need <strong>comprehensive error reports</strong></li>
</ul>
<pre><code class="language-java">// Perfect for form validation
Validated&lt;List&lt;String&gt;, OrderForm&gt; validated = modifyAllValidated(
    ORDER_TO_PRICES,
    price -&gt; validatePrice(price),
    orderForm
);
</code></pre>
<p><strong>Use <code>modifyAllEither</code> when:</strong></p>
<ul>
<li>You want <strong>fail-fast behaviour</strong></li>
<li>Working in <strong>performance-critical</strong> paths</li>
<li>First error is <strong>sufficient feedback</strong></li>
</ul>
<pre><code class="language-java">// Perfect for quick validation in high-throughput scenarios
Either&lt;String, OrderForm&gt; validated = modifyAllEither(
    ORDER_TO_PRICES,
    price -&gt; validatePrice(price),
    orderForm
);
</code></pre>
<p><strong>Use <code>modifyMaybe</code> when:</strong></p>
<ul>
<li>Invalid items should be <strong>silently filtered</strong></li>
<li>Building <strong>data enrichment</strong> pipelines</li>
<li>Failures are <strong>expected and ignorable</strong></li>
</ul>
<pre><code class="language-java">// Perfect for optional enrichment
Maybe&lt;OrderForm&gt; enriched = modifyMaybe(
    ORDER_TO_OPTIONAL_DISCOUNTS,
    discount -&gt; tryApplyDiscount(discount),
    orderForm
);
</code></pre>
<p><strong>Use traditional <code>modifyF</code> when:</strong></p>
<ul>
<li>Working with <strong>custom Applicative</strong> functors</li>
<li>Need <strong>maximum flexibility</strong></li>
<li>Building <strong>generic abstractions</strong></li>
<li>Using effects <strong>beyond validation</strong> (IO, Future, etc.)</li>
</ul>
<pre><code class="language-java">// Still valuable for generic effectful operations
Kind&lt;F, Form&gt; result = FORM_TO_PERMISSION_NAMES.modifyF(
    effectfulValidation,
    form,
    customApplicative
);
</code></pre>
<h3 id="real-world-example-simplified-validation"><a class="header" href="#real-world-example-simplified-validation">Real-World Example: Simplified Validation</a></h3>
<p>Here's how the original example can be simplified using the new methods:</p>
<pre><code class="language-java">import static org.higherkindedj.optics.fluent.OpticOps.modifyAllValidated;
import org.higherkindedj.hkt.validated.Validated;
import java.util.List;

public class SimplifiedValidation {
    // Same traversal as before
    public static final Traversal&lt;Form, String&gt; FORM_TO_PERMISSION_NAMES =
        FormLenses.principal().asTraversal()
            .andThen(PrincipalPrisms.userLogin().asTraversal())
            .andThen(UserTraversals.permissions())
            .andThen(PermissionLenses.name().asTraversal());

    // Simplified validation - no Applicative setup needed
    public static Validated&lt;List&lt;String&gt;, Form&gt; validateFormPermissions(Form form) {
        return modifyAllValidated(
            FORM_TO_PERMISSION_NAMES,
            name -&gt; VALID_PERMISSIONS.contains(name)
                ? Validated.valid(name)
                : Validated.invalid(List.of("Invalid permission: " + name)),
            form
        );
    }

    // Alternative: fail-fast validation
    public static Either&lt;String, Form&gt; validateFormPermissionsFast(Form form) {
        return modifyAllEither(
            FORM_TO_PERMISSION_NAMES,
            name -&gt; VALID_PERMISSIONS.contains(name)
                ? Either.right(name)
                : Either.left("Invalid permission: " + name),
            form
        );
    }
}
</code></pre>
<p><strong>Benefits of the Simplified Approach:</strong></p>
<ul>
<li><strong>~60% less code</strong>: No <code>Applicative</code> setup, no <code>Kind</code> wrapping, no narrowing</li>
<li><strong>Clearer intent</strong>: Method name explicitly states the validation strategy</li>
<li><strong>Easier to learn</strong>: Uses familiar types (<code>Validated</code>, <code>Either</code>, <code>Maybe</code>)</li>
<li><strong>Equally powerful</strong>: Same type safety, same error accumulation, same composition</li>
</ul>
<div id="admonition-complete-example" class="admonition admonish-note" role="note" aria-labelledby="admonition-complete-example-title">
<div class="admonition-title">
<div id="admonition-complete-example-title">
<p>Complete Example</p>
</div>
<a class="admonition-anchor-link" href="optics/composing_optics.html#admonition-complete-example"></a>
</div>
<div>
<p>See <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/fluent/FluentValidationExample.java">FluentValidationExample.java</a> for comprehensive demonstrations of all validation-aware methods, including complex real-world scenarios like order validation and bulk data import.</p>
</div>
</div>
<div id="admonition-see-also" class="admonition admonish-tip" role="note" aria-labelledby="admonition-see-also-title">
<div class="admonition-title">
<div id="admonition-see-also-title">
<p>See Also</p>
</div>
<a class="admonition-anchor-link" href="optics/composing_optics.html#admonition-see-also"></a>
</div>
<div>
<p>For a complete guide to validation-aware modifications including fluent builder API, integration with Jakarta Bean Validation, and performance optimisation, see <a href="optics/fluent_api.html#part-25-validation-aware-modifications">Fluent API for Optics</a>.</p>
</div>
</div>
<div id="admonition-hands-on-learning" class="admonition admonish-info" role="note" aria-labelledby="admonition-hands-on-learning-title">
<div class="admonition-title">
<div id="admonition-hands-on-learning-title">
<p>Hands-On Learning</p>
</div>
<a class="admonition-anchor-link" href="optics/composing_optics.html#admonition-hands-on-learning"></a>
</div>
<div>
<p>Practice optic composition in <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/optics/Tutorial06_OpticsComposition.java">Tutorial 06: Optics Composition</a> (7 exercises, ~10 minutes).</p>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="optics/profunctor_optics.html">Profunctor Optics: Advanced Data Transformation</a>
<strong>Next:</strong> <a href="optics/core_type_integration.html">Core Type Integration</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="working-with-core-types-and-optics"><a class="header" href="#working-with-core-types-and-optics">Working with Core Types and Optics</a></h1>
<p><img src="optics/../images/optics.jpg" alt="Diagram illustrating optics integration with functional core types like Maybe, Either, and Validated" /></p>
<p>As you've learnt from the previous chapters, optics provide a powerful way to focus on and modify immutable data structures. But what happens when the data you're working with is wrapped in Higher-Kinded-J's core types (<code>Maybe</code>, <code>Either</code>, <code>Validated</code>, or <code>Try</code>)?</p>
<p>Traditional optics work brilliantly with straightforward, deterministic data. However, real-world applications rarely deal with such certainty. Fields might be <code>null</code>, operations might fail, validation might produce errors, and database calls might throw exceptions. Handling these scenarios whilst maintaining clean, composable optics code requires a bridge between these two powerful abstractions.</p>
<p>This is where <strong>Core Type Integration</strong> comes in.</p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="optics/core_type_integration.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to use Core Type Prisms to extract values from <code>Maybe</code>, <code>Either</code>, <code>Validated</code>, and <code>Try</code> without verbose pattern matching</li>
<li>How Optics Extensions add null safety, validation, and exception handling to lenses and traversals</li>
<li>Composing core type optics with lenses for deep navigation into nested structures</li>
<li>Processing collections of core type values using prisms for filtering and extraction</li>
<li>When to use Core Type Prisms versus Optics Extensions based on your use case</li>
</ul>
</div>
</div>
<hr />
<h2 id="the-challenge-6"><a class="header" href="#the-challenge-6">The Challenge</a></h2>
<p>Consider a typical scenario: updating a user profile where some fields are optional, validation might fail, and the database operation might throw an exception.</p>
<div id="admonition-the-traditional-approach" class="admonition admonish-failure" role="note" aria-labelledby="admonition-the-traditional-approach-title">
<div class="admonition-title">
<div id="admonition-the-traditional-approach-title">
<p>The Traditional Approach</p>
</div>
<a class="admonition-anchor-link" href="optics/core_type_integration.html#admonition-the-traditional-approach"></a>
</div>
<div>
<pre><code class="language-java">public User updateUserProfile(User user, String newEmail) {
    // Null checking
    if (user == null || user.getProfile() == null) {
        return null; // Or throw exception?
    }

    // Validation
    if (newEmail == null || !newEmail.contains("@")) {
        throw new ValidationException("Invalid email");
    }

    // Try to update
    try {
        String validated = validateEmailFormat(newEmail);
        Profile updated = user.getProfile().withEmail(validated);
        return user.withProfile(updated);
    } catch (Exception e) {
        // Now what? Log and return null? Re-throw?
        log.error("Failed to update email", e);
        return null;
    }
}
</code></pre>
<p>This code is a mess of concerns: null handling, validation logic, exception management, and the actual update logic are all tangled together.</p>
</div>
</div>
<div id="admonition-the-functional-approach" class="admonition admonish-success" role="note" aria-labelledby="admonition-the-functional-approach-title">
<div class="admonition-title">
<div id="admonition-the-functional-approach-title">
<p>The Functional Approach</p>
</div>
<a class="admonition-anchor-link" href="optics/core_type_integration.html#admonition-the-functional-approach"></a>
</div>
<div>
<pre><code class="language-java">public Either&lt;String, User&gt; updateUserProfile(User user, String newEmail) {
    Lens&lt;User, Profile&gt; profileLens = UserLenses.profile();
    Lens&lt;Profile, String&gt; emailLens = ProfileLenses.email();
    Lens&lt;User, String&gt; userToEmail = profileLens.andThen(emailLens);

    return modifyEither(
        userToEmail,
        email -&gt; validateEmail(email),
        user
    );
}

private Either&lt;String, String&gt; validateEmail(String email) {
    if (email == null || !email.contains("@")) {
        return Either.left("Invalid email format");
    }
    return Either.right(email.toLowerCase());
}
</code></pre>
<p>Clean separation of concerns:</p>
<ul>
<li>Optics define the path to the data</li>
<li>Core types handle the errors</li>
<li>Business logic stays pure and testable</li>
</ul>
</div>
</div>
<hr />
<h2 id="two-complementary-approaches"><a class="header" href="#two-complementary-approaches">Two Complementary Approaches</a></h2>
<p>Higher-Kinded-J provides two integrated solutions for working with core types and optics:</p>
<h3 id="1-core-type-prisms--pattern-matching-on-functional-types"><a class="header" href="#1-core-type-prisms--pattern-matching-on-functional-types">1. Core Type Prisms – Pattern Matching on Functional Types</a></h3>
<p>Extract values from <code>Maybe</code>, <code>Either</code>, <code>Validated</code>, and <code>Try</code> using prisms, just as you would with sealed interfaces.</p>
<pre><code class="language-java">Prism&lt;Maybe&lt;User&gt;, User&gt; justPrism = Prisms.just();
Prism&lt;Try&lt;Order&gt;, Order&gt; successPrism = Prisms.success();

// Extract user if present
Optional&lt;User&gt; user = justPrism.getOptional(maybeUser);

// Extract order if successful
Optional&lt;Order&gt; order = successPrism.getOptional(tryOrder);
</code></pre>
<p><strong>Best for:</strong> Safe extraction and pattern matching on core types, composing with other optics.</p>
<h3 id="2-optics-extensions--safety-rails-for-lens-and-traversal"><a class="header" href="#2-optics-extensions--safety-rails-for-lens-and-traversal">2. Optics Extensions – Safety Rails for Lens and Traversal</a></h3>
<p>Augment lenses and traversals with built-in null safety, validation, and exception handling.</p>
<pre><code class="language-java">Lens&lt;User, String&gt; emailLens = UserLenses.email();

// Null-safe access
Maybe&lt;String&gt; email = getMaybe(emailLens, user);

// Validated modification
Either&lt;String, User&gt; updated = modifyEither(
    emailLens,
    email -&gt; validateEmail(email),
    user
);

// Bulk validation with error accumulation
Validated&lt;List&lt;String&gt;, List&lt;Order&gt;&gt; result = modifyAllValidated(
    allPrices,
    price -&gt; validatePrice(price),
    orders
);
</code></pre>
<p><strong>Best for:</strong> Individual field operations with validation, bulk operations, exception handling.</p>
<p><a href="optics/optics_extensions.html">Learn more about Optics Extensions →</a></p>
<hr />
<h2 id="core-type-prisms-in-detail"><a class="header" href="#core-type-prisms-in-detail">Core Type Prisms in Detail</a></h2>
<p>Prisms focus on <strong>one case</strong> of a sum type. They're perfect for safely extracting values from <code>Maybe</code>, <code>Either</code>, <code>Validated</code>, and <code>Try</code> without verbose pattern matching or null checks.</p>
<h3 id="maybe-prisms"><a class="header" href="#maybe-prisms">Maybe Prisms</a></h3>
<pre><code class="language-java">// Extract value from Just, returns empty Optional for Nothing
Prism&lt;Maybe&lt;A&gt;, A&gt; justPrism = Prisms.just();

Maybe&lt;String&gt; present = Maybe.just("Hello");
Maybe&lt;String&gt; absent = Maybe.nothing();

Optional&lt;String&gt; value = justPrism.getOptional(present);  // Optional["Hello"]
Optional&lt;String&gt; empty = justPrism.getOptional(absent);   // Optional.empty()

// Construct Maybe.just() from a value
Maybe&lt;String&gt; built = justPrism.build("World");  // Maybe.just("World")

// Check if it's a Just
boolean isJust = justPrism.matches(present);  // true
</code></pre>
<h3 id="either-prisms"><a class="header" href="#either-prisms">Either Prisms</a></h3>
<pre><code class="language-java">// Extract from Left and Right cases
Prism&lt;Either&lt;L, R&gt;, L&gt; leftPrism = Prisms.left();
Prism&lt;Either&lt;L, R&gt;, R&gt; rightPrism = Prisms.right();

Either&lt;String, Integer&gt; success = Either.right(42);
Either&lt;String, Integer&gt; failure = Either.left("Error");

// Extract success value
Optional&lt;Integer&gt; value = rightPrism.getOptional(success);   // Optional[42]
Optional&lt;Integer&gt; noValue = rightPrism.getOptional(failure); // Optional.empty()

// Extract error value
Optional&lt;String&gt; error = leftPrism.getOptional(failure);     // Optional["Error"]

// Construct Either values
Either&lt;String, Integer&gt; newSuccess = rightPrism.build(100);  // Either.right(100)
</code></pre>
<h3 id="validated-prisms"><a class="header" href="#validated-prisms">Validated Prisms</a></h3>
<pre><code class="language-java">// Extract from Valid and Invalid cases
Prism&lt;Validated&lt;E, A&gt;, A&gt; validPrism = Prisms.valid();
Prism&lt;Validated&lt;E, A&gt;, E&gt; invalidPrism = Prisms.invalid();

Validated&lt;String, Integer&gt; valid = Validated.valid(30);
Validated&lt;String, Integer&gt; invalid = Validated.invalid("Age must be positive");

// Extract valid value
Optional&lt;Integer&gt; age = validPrism.getOptional(valid);       // Optional[30]

// Extract validation error
Optional&lt;String&gt; error = invalidPrism.getOptional(invalid);  // Optional["Age must be positive"]
</code></pre>
<h3 id="try-prisms"><a class="header" href="#try-prisms">Try Prisms</a></h3>
<pre><code class="language-java">// Extract from Success and Failure cases
Prism&lt;Try&lt;A&gt;, A&gt; successPrism = Prisms.success();
Prism&lt;Try&lt;A&gt;, Throwable&gt; failurePrism = Prisms.failure();

Try&lt;Integer&gt; success = Try.success(42);
Try&lt;Integer&gt; failure = Try.failure(new RuntimeException("Database error"));

// Extract success value
Optional&lt;Integer&gt; value = successPrism.getOptional(success);    // Optional[42]

// Extract exception
Optional&lt;Throwable&gt; ex = failurePrism.getOptional(failure);     // Optional[RuntimeException]
</code></pre>
<hr />
<h2 id="core-type-traversals"><a class="header" href="#core-type-traversals">Core Type Traversals</a></h2>
<p>Whilst prisms <em>extract</em> values, traversals <em>modify</em> values inside core types:</p>
<h3 id="maybe-traversals"><a class="header" href="#maybe-traversals">Maybe Traversals</a></h3>
<pre><code class="language-java">import org.higherkindedj.optics.util.MaybeTraversals;

Traversal&lt;Maybe&lt;String&gt;, String&gt; justTraversal = MaybeTraversals.just();

// Modify value inside Just
Maybe&lt;String&gt; original = Maybe.just("hello");
Maybe&lt;String&gt; modified = Traversals.modify(justTraversal, String::toUpperCase, original);
// Result: Maybe.just("HELLO")

// No effect on Nothing
Maybe&lt;String&gt; nothing = Maybe.nothing();
Maybe&lt;String&gt; unchanged = Traversals.modify(justTraversal, String::toUpperCase, nothing);
// Result: Maybe.nothing()
</code></pre>
<h3 id="either-traversals"><a class="header" href="#either-traversals">Either Traversals</a></h3>
<pre><code class="language-java">import org.higherkindedj.optics.util.EitherTraversals;

Traversal&lt;Either&lt;String, Integer&gt;, Integer&gt; rightTraversal = EitherTraversals.right();
Traversal&lt;Either&lt;String, Integer&gt;, String&gt; leftTraversal = EitherTraversals.left();

// Modify Right value
Either&lt;String, Integer&gt; success = Either.right(100);
Either&lt;String, Integer&gt; doubled = Traversals.modify(rightTraversal, n -&gt; n * 2, success);
// Result: Either.right(200)

// Error enrichment with Left traversal
Either&lt;String, Integer&gt; error = Either.left("Connection failed");
Either&lt;String, Integer&gt; enriched = Traversals.modify(
    leftTraversal,
    msg -&gt; "[ERROR] " + msg,
    error
);
// Result: Either.left("[ERROR] Connection failed")
</code></pre>
<div id="admonition-error-enrichment" class="admonition admonish-tip" role="note" aria-labelledby="admonition-error-enrichment-title">
<div class="admonition-title">
<div id="admonition-error-enrichment-title">
<p>Error Enrichment</p>
</div>
<a class="admonition-anchor-link" href="optics/core_type_integration.html#admonition-error-enrichment"></a>
</div>
<div>
<p>The <code>EitherTraversals.left()</code> traversal is excellent for adding context to error messages without unwrapping the Either.</p>
</div>
</div>
<hr />
<h2 id="composition-the-real-power"><a class="header" href="#composition-the-real-power">Composition: The Real Power</a></h2>
<p>Prisms compose seamlessly with lenses and other optics to navigate deeply nested structures:</p>
<pre><code class="language-java">@GenerateLenses
record ApiResponse(int statusCode, Maybe&lt;Order&gt; data, List&lt;String&gt; warnings) {}

@GenerateLenses
record Order(String orderId, Customer customer, List&lt;OrderItem&gt; items) {}

@GenerateLenses
record Customer(String customerId, String name, String email) {}

// Full composition: ApiResponse -&gt; Maybe&lt;Order&gt; -&gt; Order -&gt; Customer -&gt; email
Lens&lt;ApiResponse, Maybe&lt;Order&gt;&gt; dataLens = ApiResponseLenses.data();
Traversal&lt;Maybe&lt;Order&gt;, Order&gt; orderTraversal = MaybeTraversals.just();
Lens&lt;Order, Customer&gt; customerLens = OrderLenses.customer();
Lens&lt;Customer, String&gt; emailLens = CustomerLenses.email();

Traversal&lt;ApiResponse, String&gt; emailPath = dataLens
    .andThen(orderTraversal)
    .andThen(customerLens.asTraversal())
    .andThen(emailLens.asTraversal());

List&lt;String&gt; emails = Traversals.toListOf(emailPath, response);
// Result: ["customer@example.com"] or [] if no order data
</code></pre>
<hr />
<h2 id="processing-collections-of-core-types"><a class="header" href="#processing-collections-of-core-types">Processing Collections of Core Types</a></h2>
<p>Prisms excel at filtering and extracting from collections:</p>
<pre><code class="language-java">List&lt;Try&lt;User&gt;&gt; dbResults = loadUsersFromDatabase(userIds);

Prism&lt;Try&lt;User&gt;, User&gt; successPrism = Prisms.success();
Prism&lt;Try&lt;User&gt;, Throwable&gt; failurePrism = Prisms.failure();

// Get all successfully loaded users
List&lt;User&gt; users = dbResults.stream()
    .flatMap(result -&gt; successPrism.getOptional(result).stream())
    .toList();

// Count successes
long successCount = dbResults.stream()
    .filter(successPrism::matches)
    .count();

// Log all errors
dbResults.stream()
    .flatMap(result -&gt; failurePrism.getOptional(result).stream())
    .forEach(error -&gt; logger.error("Database error: {}", error.getMessage()));
</code></pre>
<hr />
<h2 id="when-to-use-each-approach-1"><a class="header" href="#when-to-use-each-approach-1">When to Use Each Approach</a></h2>
<h3 id="use-core-type-prisms-when"><a class="header" href="#use-core-type-prisms-when">Use Core Type Prisms when:</a></h3>
<ul>
<li>Extracting values from <code>Maybe</code>, <code>Either</code>, <code>Validated</code>, or <code>Try</code></li>
<li>Pattern matching on functional types without <code>instanceof</code></li>
<li>Composing core types with other optics for deep navigation</li>
<li>Processing collections of core type values</li>
</ul>
<h3 id="use-optics-extensions-when"><a class="header" href="#use-optics-extensions-when">Use Optics Extensions when:</a></h3>
<ul>
<li>Accessing potentially null fields</li>
<li>Validating single field or bulk updates</li>
<li>Performing operations that might throw exceptions</li>
<li>Choosing between fail-fast and error accumulation strategies</li>
</ul>
<hr />
<h2 id="example-code"><a class="header" href="#example-code">Example Code</a></h2>
<div id="admonition-runnable-examples" class="admonition admonish-example" role="note" aria-labelledby="admonition-runnable-examples-title">
<div class="admonition-title">
<div id="admonition-runnable-examples-title">
<p>Runnable Examples</p>
</div>
<a class="admonition-anchor-link" href="optics/core_type_integration.html#admonition-runnable-examples"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/CoreTypePrismsExample.java">CoreTypePrismsExample</a> – API response processing</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/LensExtensionsExample.java">LensExtensionsExample</a> – User profile validation</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/TraversalExtensionsExample.java">TraversalExtensionsExample</a> – Bulk order processing</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/IntegrationPatternsExample.java">IntegrationPatternsExample</a> – Complete e-commerce workflow</li>
</ul>
</div>
</div>
<hr />
<h2 id="common-pitfalls-28"><a class="header" href="#common-pitfalls-28">Common Pitfalls</a></h2>
<div id="admonition-dont-mix-effect-types-carelessly" class="admonition admonish-warning" role="note" aria-labelledby="admonition-dont-mix-effect-types-carelessly-title">
<div class="admonition-title">
<div id="admonition-dont-mix-effect-types-carelessly-title">
<p>Don't Mix Effect Types Carelessly</p>
</div>
<a class="admonition-anchor-link" href="optics/core_type_integration.html#admonition-dont-mix-effect-types-carelessly"></a>
</div>
<div>
<p>Whilst all core type families work with optics, mixing them inappropriately can lead to confusing code:</p>
<pre><code class="language-java">// Confusing: Mixing Maybe and Either unnecessarily
Maybe&lt;Either&lt;String, User&gt;&gt; confusing = ...;

// Better: Choose one based on your needs
Either&lt;String, User&gt; clear = ...; // If you have an error message
Maybe&lt;User&gt; simple = ...;          // If it's just presence/absence
</code></pre>
</div>
</div>
<div id="admonition-start-with-either" class="admonition admonish-tip" role="note" aria-labelledby="admonition-start-with-either-title">
<div class="admonition-title">
<div id="admonition-start-with-either-title">
<p>Start with Either</p>
</div>
<a class="admonition-anchor-link" href="optics/core_type_integration.html#admonition-start-with-either"></a>
</div>
<div>
<p>When in doubt, start with <code>Either</code>. It's the most versatile:</p>
<ul>
<li>Carries error information (unlike <code>Maybe</code>)</li>
<li>Fails fast (unlike <code>Validated</code>)</li>
<li>Doesn't catch exceptions automatically (unlike <code>Try</code>)</li>
</ul>
<p>You can always switch to <code>Validated</code> for error accumulation or <code>Try</code> for exception handling when needed.</p>
</div>
</div>
<div id="admonition-prisms-return-optional" class="admonition admonish-warning" role="note" aria-labelledby="admonition-prisms-return-optional-title">
<div class="admonition-title">
<div id="admonition-prisms-return-optional-title">
<p>Prisms Return Optional</p>
</div>
<a class="admonition-anchor-link" href="optics/core_type_integration.html#admonition-prisms-return-optional"></a>
</div>
<div>
<p>Remember that <code>prism.getOptional()</code> returns Java's <code>Optional</code>, not <code>Maybe</code>:</p>
<pre><code class="language-java">Prism&lt;Maybe&lt;String&gt;, String&gt; justPrism = Prisms.just();
Maybe&lt;String&gt; maybeValue = Maybe.just("Hello");

// Returns Optional, not Maybe
Optional&lt;String&gt; value = justPrism.getOptional(maybeValue);

// Convert back to Maybe if needed
Maybe&lt;String&gt; backToMaybe = value
    .map(Maybe::just)
    .orElse(Maybe.nothing());
</code></pre>
</div>
</div>
<hr />
<h2 id="summary-15"><a class="header" href="#summary-15">Summary</a></h2>
<p>Core Type Integration provides:</p>
<p><strong>Safe Extraction</strong> – Extract values from <code>Maybe</code>, <code>Either</code>, <code>Validated</code>, and <code>Try</code> without null checks or verbose pattern matching</p>
<p><strong>Pattern Matching</strong> – Use <code>matches()</code> to check cases, <code>getOptional()</code> to extract values</p>
<p><strong>Composability</strong> – Combine with lenses and traversals for deep navigation</p>
<p><strong>Collection Processing</strong> – Filter, extract, and count different cases in collections</p>
<p><strong>Type Safety</strong> – The compiler ensures you handle all cases correctly</p>
<hr />
<p><strong>Next:</strong> <a href="optics/optics_extensions.html">Optics Extensions</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="optics-extensions-validated-operations"><a class="header" href="#optics-extensions-validated-operations">Optics Extensions: Validated Operations</a></h1>
<h2 id="error-handling-for-lens-and-traversal"><a class="header" href="#error-handling-for-lens-and-traversal"><em>Error Handling for Lens and Traversal</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="optics/optics_extensions.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>Safe field access with <code>getMaybe</code>, <code>getEither</code>, and <code>getValidated</code></li>
<li>Validated modifications with <code>modifyEither</code>, <code>modifyMaybe</code>, and <code>modifyValidated</code></li>
<li>Exception-safe operations with <code>modifyTry</code></li>
<li>Bulk operations with fail-fast (<code>modifyAllEither</code>) or error accumulation (<code>modifyAllValidated</code>)</li>
<li>Selective updates with <code>modifyWherePossible</code></li>
<li>Analysis methods: <code>countValid</code> and <code>collectErrors</code></li>
</ul>
</div>
</div>
<div id="admonition-example-code" class="admonition admonish-note" role="note" aria-labelledby="admonition-example-code-title">
<div class="admonition-title">
<div id="admonition-example-code-title">
<p>Example Code</p>
</div>
<a class="admonition-anchor-link" href="optics/optics_extensions.html#admonition-example-code"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/LensExtensionsExample.java">LensExtensionsExample</a></li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/TraversalExtensionsExample.java">TraversalExtensionsExample</a></li>
</ul>
</div>
</div>
<p>Traditional optics work brilliantly with clean, valid data. Real-world applications, however, deal with nullable fields, validation requirements, and operations that might throw exceptions. <strong>Optics Extensions</strong> bridge this gap by integrating lenses and traversals with Higher-Kinded-J's core types.</p>
<p>Think of optics extensions as <strong>safety rails</strong>: they catch null values, validate modifications, and handle exceptions whilst maintaining the elegance of functional composition.</p>
<hr />
<h2 id="part-1-lens-extensions"><a class="header" href="#part-1-lens-extensions">Part 1: Lens Extensions</a></h2>
<h3 id="importing-lens-extensions"><a class="header" href="#importing-lens-extensions">Importing Lens Extensions</a></h3>
<pre><code class="language-java">import static org.higherkindedj.optics.extensions.LensExtensions.*;
</code></pre>
<div id="admonition-alternative-fluent-api" class="admonition admonish-note" role="note" aria-labelledby="admonition-alternative-fluent-api-title">
<div class="admonition-title">
<div id="admonition-alternative-fluent-api-title">
<p>Alternative: Fluent API</p>
</div>
<a class="admonition-anchor-link" href="optics/optics_extensions.html#admonition-alternative-fluent-api"></a>
</div>
<div>
<p>These extension methods are also available through the <a href="optics/fluent_api.html">Fluent API</a>, which provides method chaining and a more discoverable interface.</p>
</div>
</div>
<h3 id="safe-access-methods"><a class="header" href="#safe-access-methods">Safe Access Methods</a></h3>
<h4 id="getmaybe--null-safe-field-access"><a class="header" href="#getmaybe--null-safe-field-access"><code>getMaybe</code> – Null-Safe Field Access</a></h4>
<p>Returns <code>Maybe.just(value)</code> if the field is non-null, <code>Maybe.nothing()</code> otherwise.</p>
<pre><code class="language-java">Lens&lt;UserProfile, String&gt; bioLens = UserProfileLenses.bio();

UserProfile withBio = new UserProfile("u1", "Alice", "alice@example.com", 30, "Software Engineer");
Maybe&lt;String&gt; bio = getMaybe(bioLens, withBio);  // Maybe.just("Software Engineer")

UserProfile withoutBio = new UserProfile("u2", "Bob", "bob@example.com", 25, null);
Maybe&lt;String&gt; noBio = getMaybe(bioLens, withoutBio);  // Maybe.nothing()

// Use with default
String displayBio = bio.orElse("No bio provided");
</code></pre>
<h4 id="geteither--access-with-default-error"><a class="header" href="#geteither--access-with-default-error"><code>getEither</code> – Access with Default Error</a></h4>
<p>Returns <code>Either.right(value)</code> if non-null, <code>Either.left(error)</code> if null.</p>
<pre><code class="language-java">Lens&lt;UserProfile, Integer&gt; ageLens = UserProfileLenses.age();

Either&lt;String, Integer&gt; age = getEither(ageLens, "Age not provided", profile);
// Either.right(30) or Either.left("Age not provided")

String message = age.fold(
    error -&gt; "Error: " + error,
    a -&gt; "Age: " + a
);
</code></pre>
<h4 id="getvalidated--access-with-validation-error"><a class="header" href="#getvalidated--access-with-validation-error"><code>getValidated</code> – Access with Validation Error</a></h4>
<p>Like <code>getEither</code>, but returns <code>Validated</code> for consistency with validation workflows.</p>
<pre><code class="language-java">Lens&lt;UserProfile, String&gt; emailLens = UserProfileLenses.email();

Validated&lt;String, String&gt; email = getValidated(emailLens, "Email is required", profile);
// Validated.valid("alice@example.com") or Validated.invalid("Email is required")
</code></pre>
<h3 id="modification-methods"><a class="header" href="#modification-methods">Modification Methods</a></h3>
<h4 id="modifymaybe--optional-modifications"><a class="header" href="#modifymaybe--optional-modifications"><code>modifyMaybe</code> – Optional Modifications</a></h4>
<p>Apply a modification that might not succeed. Returns <code>Maybe.just(updated)</code> if successful, <code>Maybe.nothing()</code> if it fails.</p>
<pre><code class="language-java">Lens&lt;UserProfile, String&gt; nameLens = UserProfileLenses.name();

Maybe&lt;UserProfile&gt; updated = modifyMaybe(
    nameLens,
    name -&gt; name.length() &gt;= 2 ? Maybe.just(name.toUpperCase()) : Maybe.nothing(),
    profile
);
// Maybe.just(UserProfile with name "ALICE") or Maybe.nothing()
</code></pre>
<h4 id="modifyeither--fail-fast-validation"><a class="header" href="#modifyeither--fail-fast-validation"><code>modifyEither</code> – Fail-Fast Validation</a></h4>
<p>Apply a modification with validation. Returns <code>Either.right(updated)</code> if valid, <code>Either.left(error)</code> if invalid.</p>
<pre><code class="language-java">Lens&lt;UserProfile, Integer&gt; ageLens = UserProfileLenses.age();

Either&lt;String, UserProfile&gt; updated = modifyEither(
    ageLens,
    age -&gt; {
        if (age &lt; 0) return Either.left("Age cannot be negative");
        if (age &gt; 150) return Either.left("Age must be realistic");
        return Either.right(age + 1);  // Birthday!
    },
    profile
);
</code></pre>
<h4 id="modifytry--exception-safe-modifications"><a class="header" href="#modifytry--exception-safe-modifications"><code>modifyTry</code> – Exception-Safe Modifications</a></h4>
<p>Apply a modification that might throw exceptions. Returns <code>Try.success(updated)</code> or <code>Try.failure(exception)</code>.</p>
<pre><code class="language-java">Lens&lt;UserProfile, String&gt; emailLens = UserProfileLenses.email();

Try&lt;UserProfile&gt; updated = modifyTry(
    emailLens,
    email -&gt; Try.of(() -&gt; updateEmailInDatabase(email)),
    profile
);

updated.match(
    user -&gt; logger.info("Email updated: {}", user.email()),
    error -&gt; logger.error("Update failed", error)
);
</code></pre>
<h4 id="setifvalid--conditional-updates"><a class="header" href="#setifvalid--conditional-updates"><code>setIfValid</code> – Conditional Updates</a></h4>
<p>Set a new value <strong>only if it passes validation</strong>. Unlike <code>modifyEither</code>, you provide the new value directly.</p>
<pre><code class="language-java">Lens&lt;UserProfile, String&gt; nameLens = UserProfileLenses.name();

Either&lt;String, UserProfile&gt; updated = setIfValid(
    nameLens,
    name -&gt; {
        if (name.length() &lt; 2) return Either.left("Name must be at least 2 characters");
        if (!name.matches("[A-Z][a-z]+")) return Either.left("Name must start with capital letter");
        return Either.right(name);
    },
    "Robert",
    profile
);
</code></pre>
<h3 id="chaining-multiple-lens-updates"><a class="header" href="#chaining-multiple-lens-updates">Chaining Multiple Lens Updates</a></h3>
<pre><code class="language-java">Lens&lt;UserProfile, String&gt; nameLens = UserProfileLenses.name();
Lens&lt;UserProfile, String&gt; emailLens = UserProfileLenses.email();

Either&lt;String, UserProfile&gt; result = modifyEither(
    nameLens,
    name -&gt; Either.right(capitalize(name)),
    original
).flatMap(user -&gt;
    modifyEither(
        emailLens,
        email -&gt; Either.right(email.toLowerCase()),
        user
    )
);
</code></pre>
<hr />
<h2 id="part-2-traversal-extensions"><a class="header" href="#part-2-traversal-extensions">Part 2: Traversal Extensions</a></h2>
<h3 id="importing-traversal-extensions"><a class="header" href="#importing-traversal-extensions">Importing Traversal Extensions</a></h3>
<pre><code class="language-java">import static org.higherkindedj.optics.extensions.TraversalExtensions.*;
</code></pre>
<h3 id="extraction-methods"><a class="header" href="#extraction-methods">Extraction Methods</a></h3>
<h4 id="getallmaybe--extract-all-values"><a class="header" href="#getallmaybe--extract-all-values"><code>getAllMaybe</code> – Extract All Values</a></h4>
<p>Returns <code>Maybe.just(values)</code> if any elements exist, <code>Maybe.nothing()</code> for empty collections.</p>
<pre><code class="language-java">Lens&lt;OrderItem, BigDecimal&gt; priceLens = OrderItemLenses.price();
Traversal&lt;List&lt;OrderItem&gt;, BigDecimal&gt; allPrices =
    Traversals.&lt;OrderItem&gt;forList().andThen(priceLens.asTraversal());

Maybe&lt;List&lt;BigDecimal&gt;&gt; prices = getAllMaybe(allPrices, items);
// Maybe.just([999.99, 29.99]) or Maybe.nothing()
</code></pre>
<h3 id="bulk-modification-methods"><a class="header" href="#bulk-modification-methods">Bulk Modification Methods</a></h3>
<h4 id="modifyallmaybe--all-or-nothing-modifications"><a class="header" href="#modifyallmaybe--all-or-nothing-modifications"><code>modifyAllMaybe</code> – All-or-Nothing Modifications</a></h4>
<p>Returns <code>Maybe.just(updated)</code> if <strong>all</strong> modifications succeed, <code>Maybe.nothing()</code> if <strong>any</strong> fail. Atomic operation.</p>
<pre><code class="language-java">Maybe&lt;List&lt;OrderItem&gt;&gt; updated = modifyAllMaybe(
    allPrices,
    price -&gt; price.compareTo(new BigDecimal("10")) &gt;= 0
        ? Maybe.just(price.multiply(new BigDecimal("1.1")))  // 10% increase
        : Maybe.nothing(),
    items
);
// Maybe.just([updated items]) or Maybe.nothing() if any price &lt; 10
</code></pre>
<div id="admonition-when-to-use-modifyallmaybe" class="admonition admonish-tip" role="note" aria-labelledby="admonition-when-to-use-modifyallmaybe-title">
<div class="admonition-title">
<div id="admonition-when-to-use-modifyallmaybe-title">
<p>When to Use modifyAllMaybe</p>
</div>
<a class="admonition-anchor-link" href="optics/optics_extensions.html#admonition-when-to-use-modifyallmaybe"></a>
</div>
<div>
<p>Use for <strong>atomic updates</strong> where all modifications must succeed or none should apply, for example, applying currency conversion where partial conversion would leave data inconsistent.</p>
</div>
</div>
<h4 id="modifyalleither--fail-fast-validation"><a class="header" href="#modifyalleither--fail-fast-validation"><code>modifyAllEither</code> – Fail-Fast Validation</a></h4>
<p>Returns <code>Either.right(updated)</code> if <strong>all</strong> validations pass, <code>Either.left(firstError)</code> if <strong>any</strong> fail. <strong>Stops at first error</strong>.</p>
<pre><code class="language-java">Either&lt;String, List&lt;OrderItem&gt;&gt; result = modifyAllEither(
    allPrices,
    price -&gt; {
        if (price.compareTo(BigDecimal.ZERO) &lt; 0) {
            return Either.left("Price cannot be negative");
        }
        return Either.right(price);
    },
    items
);
// Stops at first invalid price
</code></pre>
<div id="admonition-when-to-use-modifyalleither" class="admonition admonish-tip" role="note" aria-labelledby="admonition-when-to-use-modifyalleither-title">
<div class="admonition-title">
<div id="admonition-when-to-use-modifyalleither-title">
<p>When to Use modifyAllEither</p>
</div>
<a class="admonition-anchor-link" href="optics/optics_extensions.html#admonition-when-to-use-modifyalleither"></a>
</div>
<div>
<p>Use for <strong>fail-fast validation</strong> where you want to stop immediately at the first error, for example, API request validation where you reject immediately if any field is invalid.</p>
</div>
</div>
<h4 id="modifyallvalidated--error-accumulation"><a class="header" href="#modifyallvalidated--error-accumulation"><code>modifyAllValidated</code> – Error Accumulation</a></h4>
<p>Returns <code>Validated.valid(updated)</code> if <strong>all</strong> validations pass, <code>Validated.invalid(allErrors)</code> if <strong>any</strong> fail. <strong>Collects all errors</strong>.</p>
<pre><code class="language-java">Validated&lt;List&lt;String&gt;, List&lt;OrderItem&gt;&gt; result = modifyAllValidated(
    allPrices,
    price -&gt; {
        if (price.compareTo(BigDecimal.ZERO) &lt; 0) {
            return Validated.invalid("Price cannot be negative: " + price);
        }
        return Validated.valid(price);
    },
    items
);
// Checks ALL items and collects ALL errors

result.match(
    errors -&gt; {
        System.out.println("Validation failed with " + errors.size() + " errors:");
        errors.forEach(err -&gt; System.out.println("   - " + err));
    },
    updated -&gt; System.out.println("All items valid")
);
</code></pre>
<div id="admonition-when-to-use-modifyallvalidated" class="admonition admonish-tip" role="note" aria-labelledby="admonition-when-to-use-modifyallvalidated-title">
<div class="admonition-title">
<div id="admonition-when-to-use-modifyallvalidated-title">
<p>When to Use modifyAllValidated</p>
</div>
<a class="admonition-anchor-link" href="optics/optics_extensions.html#admonition-when-to-use-modifyallvalidated"></a>
</div>
<div>
<p>Use for <strong>error accumulation</strong> where you want to collect all errors, for example, form validation where users need to see all problems at once rather than one at a time.</p>
</div>
</div>
<h4 id="modifywherepossible--selective-modification"><a class="header" href="#modifywherepossible--selective-modification"><code>modifyWherePossible</code> – Selective Modification</a></h4>
<p>Modifies elements where the function returns <code>Maybe.just(value)</code>, leaves others unchanged. Best-effort operation that always succeeds.</p>
<pre><code class="language-java">Lens&lt;OrderItem, String&gt; statusLens = OrderItemLenses.status();
Traversal&lt;List&lt;OrderItem&gt;, String&gt; allStatuses =
    Traversals.&lt;OrderItem&gt;forList().andThen(statusLens.asTraversal());

// Update only "pending" items
List&lt;OrderItem&gt; updated = modifyWherePossible(
    allStatuses,
    status -&gt; status.equals("pending")
        ? Maybe.just("processing")
        : Maybe.nothing(),  // Leave non-pending unchanged
    items
);
</code></pre>
<div id="admonition-when-to-use-modifywherepossible" class="admonition admonish-tip" role="note" aria-labelledby="admonition-when-to-use-modifywherepossible-title">
<div class="admonition-title">
<div id="admonition-when-to-use-modifywherepossible-title">
<p>When to Use modifyWherePossible</p>
</div>
<a class="admonition-anchor-link" href="optics/optics_extensions.html#admonition-when-to-use-modifywherepossible"></a>
</div>
<div>
<p>Use for <strong>selective updates</strong> where only some elements should be modified, for example, status transitions that only affect items in a certain state.</p>
</div>
</div>
<h3 id="analysis-methods"><a class="header" href="#analysis-methods">Analysis Methods</a></h3>
<h4 id="countvalid--count-passing-validation"><a class="header" href="#countvalid--count-passing-validation"><code>countValid</code> – Count Passing Validation</a></h4>
<p>Count how many elements pass validation without modifying anything.</p>
<pre><code class="language-java">int validCount = countValid(
    allPrices,
    price -&gt; price.compareTo(BigDecimal.ZERO) &gt;= 0
        ? Either.right(price)
        : Either.left("Negative price"),
    items
);

System.out.println("Valid items: " + validCount + " out of " + items.size());
</code></pre>
<h4 id="collecterrors--gather-validation-failures"><a class="header" href="#collecterrors--gather-validation-failures"><code>collectErrors</code> – Gather Validation Failures</a></h4>
<p>Collect all validation errors without modifying anything. Returns empty list if all valid.</p>
<pre><code class="language-java">List&lt;String&gt; errors = collectErrors(
    allPrices,
    price -&gt; price.compareTo(BigDecimal.ZERO) &gt;= 0
        ? Either.right(price)
        : Either.left("Negative price: " + price),
    items
);

if (errors.isEmpty()) {
    System.out.println("All prices valid");
} else {
    System.out.println("Found " + errors.size() + " invalid prices:");
    errors.forEach(err -&gt; System.out.println("   - " + err));
}
</code></pre>
<hr />
<h2 id="complete-example-order-validation-pipeline"><a class="header" href="#complete-example-order-validation-pipeline">Complete Example: Order Validation Pipeline</a></h2>
<pre><code class="language-java">public sealed interface ValidationResult permits OrderApproved, OrderRejected {}
record OrderApproved(Order order) implements ValidationResult {}
record OrderRejected(List&lt;String&gt; errors) implements ValidationResult {}

public ValidationResult validateOrder(Order order) {
    Lens&lt;OrderItem, BigDecimal&gt; priceLens = OrderItemLenses.price();
    Lens&lt;OrderItem, Integer&gt; quantityLens = OrderItemLenses.quantity();

    Traversal&lt;List&lt;OrderItem&gt;, BigDecimal&gt; allPrices =
        Traversals.&lt;OrderItem&gt;forList().andThen(priceLens.asTraversal());
    Traversal&lt;List&lt;OrderItem&gt;, Integer&gt; allQuantities =
        Traversals.&lt;OrderItem&gt;forList().andThen(quantityLens.asTraversal());

    // Step 1: Validate all prices (accumulate errors)
    List&lt;String&gt; priceErrors = collectErrors(
        allPrices,
        price -&gt; validatePrice(price),
        order.items()
    );

    // Step 2: Validate all quantities (accumulate errors)
    List&lt;String&gt; quantityErrors = collectErrors(
        allQuantities,
        qty -&gt; validateQuantity(qty),
        order.items()
    );

    // Step 3: Combine all errors
    List&lt;String&gt; allErrors = Stream.of(priceErrors, quantityErrors)
        .flatMap(List::stream)
        .toList();

    if (!allErrors.isEmpty()) {
        return new OrderRejected(allErrors);
    }

    // Step 4: Apply discounts to valid items
    List&lt;OrderItem&gt; discounted = modifyWherePossible(
        allPrices,
        price -&gt; price.compareTo(new BigDecimal("100")) &gt; 0
            ? Maybe.just(price.multiply(new BigDecimal("0.9")))
            : Maybe.nothing(),
        order.items()
    );

    return new OrderApproved(new Order(order.orderId(), discounted, order.customerEmail()));
}

private Either&lt;String, BigDecimal&gt; validatePrice(BigDecimal price) {
    if (price.compareTo(BigDecimal.ZERO) &lt; 0) {
        return Either.left("Price cannot be negative");
    }
    if (price.compareTo(new BigDecimal("10000")) &gt; 0) {
        return Either.left("Price exceeds maximum");
    }
    return Either.right(price);
}

private Either&lt;String, Integer&gt; validateQuantity(Integer qty) {
    if (qty &lt;= 0) {
        return Either.left("Quantity must be positive");
    }
    if (qty &gt; 100) {
        return Either.left("Quantity exceeds maximum");
    }
    return Either.right(qty);
}
</code></pre>
<hr />
<h2 id="best-practices-1"><a class="header" href="#best-practices-1">Best Practices</a></h2>
<div id="admonition-choose-the-right-strategy" class="admonition admonish-tip" role="note" aria-labelledby="admonition-choose-the-right-strategy-title">
<div class="admonition-title">
<div id="admonition-choose-the-right-strategy-title">
<p>Choose the Right Strategy</p>
</div>
<a class="admonition-anchor-link" href="optics/optics_extensions.html#admonition-choose-the-right-strategy"></a>
</div>
<div>
<p><strong>Fail-fast (<code>modifyAllEither</code>):</strong></p>
<ul>
<li>API requests (reject immediately)</li>
<li>Critical validations (stop on first error)</li>
<li>Performance-sensitive operations</li>
</ul>
<p><strong>Error accumulation (<code>modifyAllValidated</code>):</strong></p>
<ul>
<li>Form validation (show all errors)</li>
<li>Batch processing (complete error report)</li>
<li>Better user experience</li>
</ul>
</div>
</div>
<div id="admonition-keep-validation-functions-pure" class="admonition admonish-tip" role="note" aria-labelledby="admonition-keep-validation-functions-pure-title">
<div class="admonition-title">
<div id="admonition-keep-validation-functions-pure-title">
<p>Keep Validation Functions Pure</p>
</div>
<a class="admonition-anchor-link" href="optics/optics_extensions.html#admonition-keep-validation-functions-pure"></a>
</div>
<div>
<pre><code class="language-java">// Good: Pure validator
private Either&lt;String, String&gt; validateEmail(String email) {
    if (!email.contains("@")) {
        return Either.left("Invalid email");
    }
    return Either.right(email.toLowerCase());
}

// Avoid: Impure validator with side effects
private Either&lt;String, String&gt; validateEmail(String email) {
    logger.info("Validating email: {}", email);  // Side effect
    // ...
}
</code></pre>
<p>Pure functions are easier to test, reason about, and compose.</p>
</div>
</div>
<div id="admonition-lens-extensions-dont-handle-null-sources" class="admonition admonish-warning" role="note" aria-labelledby="admonition-lens-extensions-dont-handle-null-sources-title">
<div class="admonition-title">
<div id="admonition-lens-extensions-dont-handle-null-sources-title">
<p>Lens Extensions Don't Handle Null Sources</p>
</div>
<a class="admonition-anchor-link" href="optics/optics_extensions.html#admonition-lens-extensions-dont-handle-null-sources"></a>
</div>
<div>
<p>Lens extensions handle <code>null</code> <strong>field values</strong>, but not <code>null</code> <strong>source objects</strong>:</p>
<pre><code class="language-java">UserProfile profile = null;
Maybe&lt;String&gt; bio = getMaybe(bioLens, profile);  // NullPointerException!

// Wrap the source in Maybe first
Maybe&lt;UserProfile&gt; maybeProfile = Maybe.fromNullable(profile);
Maybe&lt;String&gt; safeBio = maybeProfile.flatMap(p -&gt; getMaybe(bioLens, p));
</code></pre>
</div>
</div>
<hr />
<h2 id="summary-16"><a class="header" href="#summary-16">Summary</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Returns</th><th>Use Case</th></tr></thead><tbody>
<tr><td><code>getMaybe</code></td><td><code>Maybe&lt;A&gt;</code></td><td>Null-safe field access</td></tr>
<tr><td><code>getEither</code></td><td><code>Either&lt;E, A&gt;</code></td><td>Access with error message</td></tr>
<tr><td><code>modifyMaybe</code></td><td><code>Maybe&lt;S&gt;</code></td><td>Optional modification</td></tr>
<tr><td><code>modifyEither</code></td><td><code>Either&lt;E, S&gt;</code></td><td>Fail-fast single field validation</td></tr>
<tr><td><code>modifyTry</code></td><td><code>Try&lt;S&gt;</code></td><td>Exception-safe modifications</td></tr>
<tr><td><code>modifyAllMaybe</code></td><td><code>Maybe&lt;S&gt;</code></td><td>All-or-nothing bulk modification</td></tr>
<tr><td><code>modifyAllEither</code></td><td><code>Either&lt;E, S&gt;</code></td><td>Fail-fast bulk validation</td></tr>
<tr><td><code>modifyAllValidated</code></td><td><code>Validated&lt;List&lt;E&gt;, S&gt;</code></td><td>Error accumulation</td></tr>
<tr><td><code>modifyWherePossible</code></td><td><code>S</code></td><td>Selective modification</td></tr>
<tr><td><code>countValid</code></td><td><code>int</code></td><td>Count valid elements</td></tr>
<tr><td><code>collectErrors</code></td><td><code>List&lt;E&gt;</code></td><td>Gather all errors</td></tr>
</tbody></table>
</div>
<hr />
<p><a href="optics/core_type_integration.html">Previous: Core Type Integration</a> | <a href="optics/cookbook.html">Next: Cookbook</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="optics-cookbook"><a class="header" href="#optics-cookbook">Optics Cookbook</a></h1>
<h2 id="practical-recipes-for-common-problems"><a class="header" href="#practical-recipes-for-common-problems"><em>Practical Recipes for Common Problems</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="optics/cookbook.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>Ready-to-use patterns for common optics scenarios</li>
<li>Copy-paste recipes with explanations</li>
<li>Best practices for production code</li>
</ul>
</div>
</div>
<div id="admonition-hands-on-practice" class="admonition admonish-note" role="note" aria-labelledby="admonition-hands-on-practice-title">
<div class="admonition-title">
<div id="admonition-hands-on-practice-title">
<p>Hands On Practice</p>
</div>
<a class="admonition-anchor-link" href="optics/cookbook.html#admonition-hands-on-practice"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/optics/Tutorial08_RealWorldOptics.java">Tutorial08_RealWorldOptics.java</a></p>
</div>
</div>
<p>This cookbook provides practical recipes for common optics problems. Each recipe includes the problem statement, solution, and explanation.</p>
<hr />
<h2 id="recipe-1-updating-nested-optional-fields"><a class="header" href="#recipe-1-updating-nested-optional-fields">Recipe 1: Updating Nested Optional Fields</a></h2>
<h3 id="problem"><a class="header" href="#problem">Problem</a></h3>
<p>You have a deeply nested structure with optional fields and need to update a value that may or may not exist.</p>
<h3 id="solution"><a class="header" href="#solution">Solution</a></h3>
<pre><code class="language-java">record User(String name, Optional&lt;Profile&gt; profile) {}
record Profile(String bio, Optional&lt;Settings&gt; settings) {}
record Settings(boolean darkMode, int fontSize) {}

// Build the traversal path
Traversal&lt;User, Integer&gt; userFontSize =
    UserLenses.profile()              // Lens&lt;User, Optional&lt;Profile&gt;&gt;
        .andThen(Prisms.some())       // Prism&lt;Optional&lt;Profile&gt;, Profile&gt;
        .andThen(ProfileLenses.settings().asTraversal())  // Lens&lt;Profile, Optional&lt;Settings&gt;&gt;
        .andThen(Prisms.some().asTraversal())             // Prism&lt;Optional&lt;Settings&gt;, Settings&gt;
        .andThen(SettingsLenses.fontSize().asTraversal()); // Lens&lt;Settings, Integer&gt;

// Usage
User user = new User("Alice", Optional.of(
    new Profile("Developer", Optional.of(new Settings(true, 14)))
));

// Increase font size if it exists, otherwise leave unchanged
User updated = Traversals.modify(userFontSize, size -&gt; size + 2, user);
</code></pre>
<h3 id="why-it-works"><a class="header" href="#why-it-works">Why It Works</a></h3>
<p>Each <code>Prisms.some()</code> safely handles the Optional - if any Optional is empty, the modification is skipped and the original structure is returned unchanged.</p>
<hr />
<h2 id="recipe-2-modifying-a-specific-variant-of-a-sum-type"><a class="header" href="#recipe-2-modifying-a-specific-variant-of-a-sum-type">Recipe 2: Modifying a Specific Variant of a Sum Type</a></h2>
<h3 id="problem-1"><a class="header" href="#problem-1">Problem</a></h3>
<p>You have a sealed interface and want to modify only one specific variant whilst leaving others unchanged.</p>
<h3 id="solution-1"><a class="header" href="#solution-1">Solution</a></h3>
<pre><code class="language-java">sealed interface ApiResponse permits Success, Error, Loading {}
record Success(Data data, String timestamp) implements ApiResponse {}
record Error(String message, int code) implements ApiResponse {}
record Loading(int progress) implements ApiResponse {}

// Create prism for the Success case
Prism&lt;ApiResponse, Success&gt; successPrism = Prism.of(
    resp -&gt; resp instanceof Success s ? Optional.of(s) : Optional.empty(),
    s -&gt; s
);

// Compose with lens to access data
Traversal&lt;ApiResponse, Data&gt; successData =
    successPrism.andThen(SuccessLenses.data());

// Usage: transform data only for Success responses
ApiResponse response = new Success(new Data("original"), "2024-01-01");
ApiResponse modified = Traversals.modify(
    successData,
    data -&gt; new Data(data.value().toUpperCase()),
    response
);
// Result: Success[data=Data[value=ORIGINAL], timestamp=2024-01-01]

// Error responses pass through unchanged
ApiResponse error = new Error("Not found", 404);
ApiResponse unchanged = Traversals.modify(
    successData,
    data -&gt; new Data(data.value().toUpperCase()),
    error
);
// Result: Error[message=Not found, code=404] (unchanged)
</code></pre>
<hr />
<h2 id="recipe-3-bulk-updates-across-collections"><a class="header" href="#recipe-3-bulk-updates-across-collections">Recipe 3: Bulk Updates Across Collections</a></h2>
<h3 id="problem-2"><a class="header" href="#problem-2">Problem</a></h3>
<p>You need to update all items in a collection that match certain criteria.</p>
<h3 id="solution-2"><a class="header" href="#solution-2">Solution</a></h3>
<pre><code class="language-java">record Order(String id, List&lt;LineItem&gt; items) {}
record LineItem(String productId, int quantity, Money price) {}

// Traversal to all line items
Traversal&lt;Order, LineItem&gt; allItems =
    OrderLenses.items().asTraversal()
        .andThen(Traversals.forList());

// Traversal to high-quantity items only
Traversal&lt;Order, LineItem&gt; bulkItems =
    allItems.andThen(Traversals.filtered(item -&gt; item.quantity() &gt; 10));

// Apply 10% discount to bulk items
Order order = new Order("ORD-001", List.of(
    new LineItem("PROD-1", 5, new Money(100)),
    new LineItem("PROD-2", 15, new Money(200)),
    new LineItem("PROD-3", 20, new Money(150))
));

Order discounted = Traversals.modify(
    bulkItems,
    item -&gt; new LineItem(
        item.productId(),
        item.quantity(),
        item.price().multiply(0.9)
    ),
    order
);
// Only items with quantity &gt; 10 get the discount
</code></pre>
<hr />
<h2 id="recipe-4-extracting-values-from-polymorphic-structures"><a class="header" href="#recipe-4-extracting-values-from-polymorphic-structures">Recipe 4: Extracting Values from Polymorphic Structures</a></h2>
<h3 id="problem-3"><a class="header" href="#problem-3">Problem</a></h3>
<p>You have a list of mixed types and need to extract values from specific types only.</p>
<h3 id="solution-3"><a class="header" href="#solution-3">Solution</a></h3>
<pre><code class="language-java">sealed interface Event permits UserEvent, SystemEvent {}
record UserEvent(String userId, String action) implements Event {}
record SystemEvent(String level, String message) implements Event {}

// Prism to focus on UserEvents
Prism&lt;Event, UserEvent&gt; userEventPrism = Prism.of(
    e -&gt; e instanceof UserEvent u ? Optional.of(u) : Optional.empty(),
    u -&gt; u
);

// Traversal from list of events to user actions
Traversal&lt;List&lt;Event&gt;, String&gt; userActions =
    Traversals.&lt;Event&gt;forList()
        .andThen(userEventPrism.asTraversal())
        .andThen(UserEventLenses.action().asTraversal());

// Usage
List&lt;Event&gt; events = List.of(
    new UserEvent("user-1", "LOGIN"),
    new SystemEvent("INFO", "Server started"),
    new UserEvent("user-2", "LOGOUT"),
    new SystemEvent("WARN", "High memory usage")
);

List&lt;String&gt; actions = Traversals.getAll(userActions, events);
// Result: ["LOGIN", "LOGOUT"]
</code></pre>
<hr />
<h2 id="recipe-5-safe-map-access-with-fallback"><a class="header" href="#recipe-5-safe-map-access-with-fallback">Recipe 5: Safe Map Access with Fallback</a></h2>
<h3 id="problem-4"><a class="header" href="#problem-4">Problem</a></h3>
<p>You need to access a value in a Map that may not exist, with a sensible default.</p>
<h3 id="solution-4"><a class="header" href="#solution-4">Solution</a></h3>
<pre><code class="language-java">record Config(Map&lt;String, String&gt; settings) {}

// Traversal to a specific key
Traversal&lt;Config, String&gt; databaseUrl =
    ConfigLenses.settings().asTraversal()
        .andThen(Traversals.forMap("database.url"));

// Get with default
Config config = new Config(Map.of("app.name", "MyApp"));

List&lt;String&gt; urls = Traversals.getAll(databaseUrl, config);
String url = urls.isEmpty() ? "jdbc:postgresql://localhost/default" : urls.get(0);

// Or use Optional pattern
Optional&lt;String&gt; maybeUrl = urls.stream().findFirst();
</code></pre>
<hr />
<h2 id="recipe-6-composing-multiple-validations"><a class="header" href="#recipe-6-composing-multiple-validations">Recipe 6: Composing Multiple Validations</a></h2>
<h3 id="problem-5"><a class="header" href="#problem-5">Problem</a></h3>
<p>You need to validate multiple fields and accumulate all errors.</p>
<h3 id="solution-5"><a class="header" href="#solution-5">Solution</a></h3>
<pre><code class="language-java">import static org.higherkindedj.optics.fluent.OpticOps.modifyAllValidated;

record Registration(String email, String password, int age) {}

// Traversals for each field
Traversal&lt;Registration, String&gt; emailTraversal =
    RegistrationLenses.email().asTraversal();
Traversal&lt;Registration, String&gt; passwordTraversal =
    RegistrationLenses.password().asTraversal();
Traversal&lt;Registration, Integer&gt; ageTraversal =
    RegistrationLenses.age().asTraversal();

// Validation functions
Function&lt;String, Validated&lt;List&lt;String&gt;, String&gt;&gt; validateEmail = email -&gt;
    email.contains("@")
        ? Validated.valid(email)
        : Validated.invalid(List.of("Invalid email format"));

Function&lt;String, Validated&lt;List&lt;String&gt;, String&gt;&gt; validatePassword = password -&gt;
    password.length() &gt;= 8
        ? Validated.valid(password)
        : Validated.invalid(List.of("Password must be at least 8 characters"));

Function&lt;Integer, Validated&lt;List&lt;String&gt;, Integer&gt;&gt; validateAge = age -&gt;
    age &gt;= 18
        ? Validated.valid(age)
        : Validated.invalid(List.of("Must be 18 or older"));

// Combine validations
public Validated&lt;List&lt;String&gt;, Registration&gt; validateRegistration(Registration reg) {
    Validated&lt;List&lt;String&gt;, Registration&gt; emailResult =
        modifyAllValidated(emailTraversal, validateEmail, reg);
    Validated&lt;List&lt;String&gt;, Registration&gt; passwordResult =
        modifyAllValidated(passwordTraversal, validatePassword, reg);
    Validated&lt;List&lt;String&gt;, Registration&gt; ageResult =
        modifyAllValidated(ageTraversal, validateAge, reg);

    // Combine all validations
    return emailResult.flatMap(r1 -&gt;
        passwordResult.flatMap(r2 -&gt;
            ageResult
        )
    );
}
</code></pre>
<hr />
<h2 id="recipe-7-transforming-nested-collections"><a class="header" href="#recipe-7-transforming-nested-collections">Recipe 7: Transforming Nested Collections</a></h2>
<h3 id="problem-6"><a class="header" href="#problem-6">Problem</a></h3>
<p>You have nested collections and need to transform items at the innermost level.</p>
<h3 id="solution-6"><a class="header" href="#solution-6">Solution</a></h3>
<pre><code class="language-java">record Company(List&lt;Department&gt; departments) {}
record Department(String name, List&lt;Employee&gt; employees) {}
record Employee(String name, int salary) {}

// Traversal to all employee salaries across all departments
Traversal&lt;Company, Integer&gt; allSalaries =
    CompanyLenses.departments().asTraversal()
        .andThen(Traversals.forList())
        .andThen(DepartmentLenses.employees().asTraversal())
        .andThen(Traversals.forList())
        .andThen(EmployeeLenses.salary().asTraversal());

// Give everyone a 5% raise
Company company = /* ... */;
Company afterRaise = Traversals.modify(
    allSalaries,
    salary -&gt; (int) (salary * 1.05),
    company
);

// Get total payroll
List&lt;Integer&gt; salaries = Traversals.getAll(allSalaries, company);
int totalPayroll = salaries.stream().mapToInt(Integer::intValue).sum();
</code></pre>
<hr />
<h2 id="recipe-8-conditional-updates-based-on-related-data"><a class="header" href="#recipe-8-conditional-updates-based-on-related-data">Recipe 8: Conditional Updates Based on Related Data</a></h2>
<h3 id="problem-7"><a class="header" href="#problem-7">Problem</a></h3>
<p>You need to update a field based on the value of another field in the same structure.</p>
<h3 id="solution-7"><a class="header" href="#solution-7">Solution</a></h3>
<pre><code class="language-java">record Product(String name, Money price, boolean onSale) {}

// Create a lens for the price
Lens&lt;Product, Money&gt; priceLens = ProductLenses.price();

// Conditional discount based on onSale flag
public Product applyDiscount(Product product, double discountRate) {
    if (product.onSale()) {
        return priceLens.modify(
            price -&gt; price.multiply(1 - discountRate),
            product
        );
    }
    return product;
}

// Or using Traversal with filter
Traversal&lt;List&lt;Product&gt;, Money&gt; salePrices =
    Traversals.&lt;Product&gt;forList()
        .andThen(Traversals.filtered(Product::onSale))
        .andThen(priceLens.asTraversal());

List&lt;Product&gt; products = /* ... */;
List&lt;Product&gt; discounted = Traversals.modify(
    salePrices,
    price -&gt; price.multiply(0.8),
    products
);
</code></pre>
<hr />
<h2 id="recipe-9-working-with-either-for-error-handling"><a class="header" href="#recipe-9-working-with-either-for-error-handling">Recipe 9: Working with Either for Error Handling</a></h2>
<h3 id="problem-8"><a class="header" href="#problem-8">Problem</a></h3>
<p>You have an <code>Either&lt;Error, Success&gt;</code> and need to transform the success case whilst preserving errors.</p>
<h3 id="solution-8"><a class="header" href="#solution-8">Solution</a></h3>
<pre><code class="language-java">record ValidationError(String field, String message) {}
record UserData(String name, String email) {}

// Prism to focus on the Right (success) case
Prism&lt;Either&lt;ValidationError, UserData&gt;, UserData&gt; rightPrism = Prisms.right();

// Transform user data only on success
Either&lt;ValidationError, UserData&gt; result =
    Either.right(new UserData("alice", "alice@example.com"));

Either&lt;ValidationError, UserData&gt; transformed = rightPrism.modify(
    user -&gt; new UserData(user.name().toUpperCase(), user.email()),
    result
);
// Result: Right(UserData[name=ALICE, email=alice@example.com])

// Errors pass through unchanged
Either&lt;ValidationError, UserData&gt; errorResult =
    Either.left(new ValidationError("email", "Invalid format"));

Either&lt;ValidationError, UserData&gt; stillError = rightPrism.modify(
    user -&gt; new UserData(user.name().toUpperCase(), user.email()),
    errorResult
);
// Result: Left(ValidationError[field=email, message=Invalid format])
</code></pre>
<hr />
<h2 id="recipe-10-sorting-or-reversing-traversed-elements"><a class="header" href="#recipe-10-sorting-or-reversing-traversed-elements">Recipe 10: Sorting or Reversing Traversed Elements</a></h2>
<h3 id="problem-9"><a class="header" href="#problem-9">Problem</a></h3>
<p>You need to sort or reorder the elements focused by a Traversal.</p>
<h3 id="solution-9"><a class="header" href="#solution-9">Solution</a></h3>
<pre><code class="language-java">record Scoreboard(List&lt;Player&gt; players) {}
record Player(String name, int score) {}

// Traversal to all scores
Traversal&lt;Scoreboard, Integer&gt; scores =
    ScoreboardLenses.players().asTraversal()
        .andThen(Traversals.forList())
        .andThen(PlayerLenses.score().asTraversal());

// Sort scores (highest first)
Scoreboard board = new Scoreboard(List.of(
    new Player("Alice", 100),
    new Player("Bob", 150),
    new Player("Charlie", 75)
));

Scoreboard sorted = Traversals.sorted(
    scores,
    Comparator.reverseOrder(),
    board
);
// Result: Players now have scores [150, 100, 75] respectively

// Reverse the order
Scoreboard reversed = Traversals.reversed(scores, board);
// Result: Players now have scores [75, 150, 100]
</code></pre>
<hr />
<h2 id="best-practices-2"><a class="header" href="#best-practices-2">Best Practices</a></h2>
<h3 id="1-create-reusable-optic-constants"><a class="header" href="#1-create-reusable-optic-constants">1. Create Reusable Optic Constants</a></h3>
<pre><code class="language-java">public final class OrderOptics {
    public static final Traversal&lt;Order, Money&gt; ALL_PRICES =
        OrderLenses.items().asTraversal()
            .andThen(Traversals.forList())
            .andThen(LineItemLenses.price().asTraversal());

    public static final Traversal&lt;Order, String&gt; CUSTOMER_EMAIL =
        OrderLenses.customer()
            .andThen(CustomerPrisms.verified())
            .andThen(CustomerLenses.email().asTraversal());
}
</code></pre>
<h3 id="2-use-direct-composition-methods"><a class="header" href="#2-use-direct-composition-methods">2. Use Direct Composition Methods</a></h3>
<pre><code class="language-java">// Preferred: type-safe, clearer intent
Traversal&lt;Config, Settings&gt; direct = configLens.andThen(settingsPrism);

// Fallback: when you need maximum flexibility
Traversal&lt;Config, Settings&gt; manual =
    configLens.asTraversal().andThen(settingsPrism.asTraversal());
</code></pre>
<h3 id="3-document-complex-compositions"><a class="header" href="#3-document-complex-compositions">3. Document Complex Compositions</a></h3>
<pre><code class="language-java">/**
 * Traverses from an Order to all active promotion codes.
 *
 * Path: Order -&gt; Customer -&gt; Loyalty (if exists) -&gt; Promotions list -&gt; Active only
 */
public static final Traversal&lt;Order, String&gt; ACTIVE_PROMO_CODES =
    OrderLenses.customer()
        .andThen(CustomerPrisms.loyaltyMember())
        .andThen(LoyaltyLenses.promotions().asTraversal())
        .andThen(Traversals.forList())
        .andThen(Traversals.filtered(Promotion::isActive))
        .andThen(PromotionLenses.code().asTraversal());
</code></pre>
<h3 id="4-prefer-specific-types-when-available"><a class="header" href="#4-prefer-specific-types-when-available">4. Prefer Specific Types When Available</a></h3>
<pre><code class="language-java">// If you know it's always present, use Lens directly
Lens&lt;User, String&gt; name = UserLenses.name();
String userName = name.get(user);

// Only use Traversal when you need the flexibility
Traversal&lt;User, String&gt; optionalNickname = /* ... */;
List&lt;String&gt; nicknames = Traversals.getAll(optionalNickname, user);
</code></pre>
<hr />
<h2 id="focus-dsl-recipes"><a class="header" href="#focus-dsl-recipes">Focus DSL Recipes</a></h2>
<p>The following recipes demonstrate the Focus DSL for more ergonomic optic usage.</p>
<h3 id="recipe-11-nested-record-updates-with-focus-dsl"><a class="header" href="#recipe-11-nested-record-updates-with-focus-dsl">Recipe 11: Nested Record Updates with Focus DSL</a></h3>
<h4 id="problem-10"><a class="header" href="#problem-10">Problem</a></h4>
<p>You have deeply nested records and want to update values without verbose composition.</p>
<h4 id="solution-10"><a class="header" href="#solution-10">Solution</a></h4>
<pre><code class="language-java">record Company(String name, List&lt;Department&gt; departments) {}
record Department(String name, List&lt;Employee&gt; employees) {}
record Employee(String name, int salary) {}

// Using Focus DSL instead of manual lens composition
FocusPath&lt;Company, List&lt;Department&gt;&gt; deptPath = FocusPath.of(companyDeptsLens);
TraversalPath&lt;Company, Employee&gt; allEmployees = deptPath.each().via(deptEmployeesLens).each();
TraversalPath&lt;Company, Integer&gt; allSalaries = allEmployees.via(employeeSalaryLens);

// Give everyone a 5% raise
Company updated = allSalaries.modifyAll(s -&gt; (int) (s * 1.05), company);

// Or use generated Focus classes (with @GenerateFocus)
Company updated = CompanyFocus.departments().employees().salary()
    .modifyAll(s -&gt; (int) (s * 1.05), company);
</code></pre>
<h4 id="why-it-works-1"><a class="header" href="#why-it-works-1">Why It Works</a></h4>
<p>The Focus DSL tracks path type transitions automatically, from <code>FocusPath</code> through collections to <code>TraversalPath</code>, whilst maintaining full type safety.</p>
<hr />
<h3 id="recipe-12-sum-type-handling-with-instanceof"><a class="header" href="#recipe-12-sum-type-handling-with-instanceof">Recipe 12: Sum Type Handling with instanceOf()</a></h3>
<h4 id="problem-11"><a class="header" href="#problem-11">Problem</a></h4>
<p>You have a sealed interface and want to work with specific variants using the Focus DSL.</p>
<h4 id="solution-11"><a class="header" href="#solution-11">Solution</a></h4>
<pre><code class="language-java">sealed interface Notification permits Email, SMS, Push {}
record Email(String address, String subject, String body) implements Notification {}
record SMS(String phone, String message) implements Notification {}
record Push(String token, String title) implements Notification {}

record User(String name, List&lt;Notification&gt; notifications) {}

// Focus on Email notifications only
TraversalPath&lt;User, Notification&gt; allNotifications =
    FocusPath.of(userNotificationsLens).each();

TraversalPath&lt;User, Email&gt; emailsOnly =
    allNotifications.via(AffinePath.instanceOf(Email.class));

// Get all email addresses
List&lt;String&gt; emailAddresses = emailsOnly
    .via(emailAddressLens)
    .getAll(user);

// Update all email subjects
User updated = emailsOnly
    .via(emailSubjectLens)
    .modifyAll(subject -&gt; "[URGENT] " + subject, user);
</code></pre>
<hr />
<h3 id="recipe-13-generic-collection-traversal-with-traverseover"><a class="header" href="#recipe-13-generic-collection-traversal-with-traverseover">Recipe 13: Generic Collection Traversal with traverseOver()</a></h3>
<h4 id="problem-12"><a class="header" href="#problem-12">Problem</a></h4>
<p>Your data contains Kind-wrapped collections (e.g., <code>Kind&lt;ListKind.Witness, T&gt;</code>) rather than raw <code>List&lt;T&gt;</code>.</p>
<h4 id="solution-12"><a class="header" href="#solution-12">Solution</a></h4>
<pre><code class="language-java">record Team(String name, Kind&lt;ListKind.Witness, Member&gt; members) {}
record Member(String name, Kind&lt;ListKind.Witness, Role&gt; roles) {}
record Role(String name, int level) {}

// Path to all roles across all members
FocusPath&lt;Team, Kind&lt;ListKind.Witness, Member&gt;&gt; membersPath =
    FocusPath.of(teamMembersLens);

TraversalPath&lt;Team, Member&gt; allMembers =
    membersPath.&lt;ListKind.Witness, Member&gt;traverseOver(ListTraverse.INSTANCE);

TraversalPath&lt;Team, Kind&lt;ListKind.Witness, Role&gt;&gt; memberRoles =
    allMembers.via(memberRolesLens);

TraversalPath&lt;Team, Role&gt; allRoles =
    memberRoles.&lt;ListKind.Witness, Role&gt;traverseOver(ListTraverse.INSTANCE);

// Promote all high-level roles
Team updated = allRoles.modifyWhen(
    r -&gt; r.level() &gt;= 5,
    r -&gt; new Role(r.name(), r.level() + 1),
    team
);
</code></pre>
<hr />
<h3 id="recipe-14-validation-pipelines-with-modifyf"><a class="header" href="#recipe-14-validation-pipelines-with-modifyf">Recipe 14: Validation Pipelines with modifyF()</a></h3>
<h4 id="problem-13"><a class="header" href="#problem-13">Problem</a></h4>
<p>You need to validate and transform data, accumulating errors or short-circuiting on failure.</p>
<h4 id="solution-13"><a class="header" href="#solution-13">Solution</a></h4>
<pre><code class="language-java">record Config(String apiKey, String dbUrl, int timeout) {}

FocusPath&lt;Config, String&gt; apiKeyPath = FocusPath.of(configApiKeyLens);
FocusPath&lt;Config, String&gt; dbUrlPath = FocusPath.of(configDbUrlLens);

// Validation function returning Maybe (short-circuits on Nothing)
Function&lt;String, Kind&lt;MaybeKind.Witness, String&gt;&gt; validateApiKey = key -&gt; {
    if (key != null &amp;&amp; key.length() &gt;= 10) {
        return MaybeKindHelper.MAYBE.widen(Maybe.just(key.toUpperCase()));
    }
    return MaybeKindHelper.MAYBE.widen(Maybe.nothing());
};

// Apply validation (MaybeMonad extends Applicative)
Kind&lt;MaybeKind.Witness, Config&gt; result =
    apiKeyPath.modifyF(validateApiKey, config, MaybeMonad.INSTANCE);

Maybe&lt;Config&gt; validated = MaybeKindHelper.MAYBE.narrow(result);
if (validated.isJust()) {
    Config validConfig = validated.get();
    // Proceed with valid config
} else {
    // Handle validation failure
}
</code></pre>
<hr />
<h3 id="recipe-15-aggregation-with-foldmap"><a class="header" href="#recipe-15-aggregation-with-foldmap">Recipe 15: Aggregation with foldMap()</a></h3>
<h4 id="problem-14"><a class="header" href="#problem-14">Problem</a></h4>
<p>You need to aggregate values across a traversal (sum, max, concatenate, etc.).</p>
<h4 id="solution-14"><a class="header" href="#solution-14">Solution</a></h4>
<pre><code class="language-java">record Order(List&lt;LineItem&gt; items) {}
record LineItem(String name, int quantity, BigDecimal price) {}

TraversalPath&lt;Order, LineItem&gt; allItems = FocusPath.of(orderItemsLens).each();

// Sum quantities using integer addition monoid
Monoid&lt;Integer&gt; intSum = new Monoid&lt;&gt;() {
    @Override public Integer empty() { return 0; }
    @Override public Integer combine(Integer a, Integer b) { return a + b; }
};

int totalQuantity = allItems
    .via(lineItemQuantityLens)
    .foldMap(intSum, q -&gt; q, order);

// Sum prices using BigDecimal monoid
Monoid&lt;BigDecimal&gt; decimalSum = new Monoid&lt;&gt;() {
    @Override public BigDecimal empty() { return BigDecimal.ZERO; }
    @Override public BigDecimal combine(BigDecimal a, BigDecimal b) { return a.add(b); }
};

BigDecimal totalPrice = allItems
    .via(lineItemPriceLens)
    .foldMap(decimalSum, p -&gt; p, order);

// Collect all item names
Monoid&lt;List&lt;String&gt;&gt; listConcat = new Monoid&lt;&gt;() {
    @Override public List&lt;String&gt; empty() { return List.of(); }
    @Override public List&lt;String&gt; combine(List&lt;String&gt; a, List&lt;String&gt; b) {
        var result = new ArrayList&lt;&gt;(a);
        result.addAll(b);
        return result;
    }
};

List&lt;String&gt; allNames = allItems.foldMap(
    listConcat,
    item -&gt; List.of(item.name()),
    order
);
</code></pre>
<hr />
<h3 id="recipe-16-debugging-complex-paths-with-traced"><a class="header" href="#recipe-16-debugging-complex-paths-with-traced">Recipe 16: Debugging Complex Paths with traced()</a></h3>
<h4 id="problem-15"><a class="header" href="#problem-15">Problem</a></h4>
<p>You have a complex path composition and need to understand what values are being accessed.</p>
<h4 id="solution-15"><a class="header" href="#solution-15">Solution</a></h4>
<pre><code class="language-java">record System(List&lt;Server&gt; servers) {}
record Server(String hostname, List&lt;Service&gt; services) {}
record Service(String name, Status status) {}

TraversalPath&lt;System, Service&gt; allServices =
    FocusPath.of(systemServersLens).each().via(serverServicesLens).each();

// Add tracing to observe navigation
TraversalPath&lt;System, Service&gt; tracedServices = allServices.traced(
    (system, services) -&gt; {
        System.out.println("Accessing " + services.size() + " services");
        for (Service s : services) {
            System.out.println("  - " + s.name() + ": " + s.status());
        }
    }
);

// Every getAll() now logs
List&lt;Service&gt; services = tracedServices.getAll(system);
// Output:
// Accessing 5 services
//   - api: RUNNING
//   - db: RUNNING
//   - cache: STOPPED
//   - ...

// Note: traced() only observes getAll(), not modifyAll()
</code></pre>
<hr />
<h3 id="recipe-17-conditional-updates-with-modifywhen"><a class="header" href="#recipe-17-conditional-updates-with-modifywhen">Recipe 17: Conditional Updates with modifyWhen()</a></h3>
<h4 id="problem-16"><a class="header" href="#problem-16">Problem</a></h4>
<p>You need to update only elements that match a predicate, leaving others unchanged.</p>
<h4 id="solution-16"><a class="header" href="#solution-16">Solution</a></h4>
<pre><code class="language-java">record Inventory(List&lt;Product&gt; products) {}
record Product(String name, int stock, BigDecimal price, Category category) {}
enum Category { ELECTRONICS, CLOTHING, FOOD }

TraversalPath&lt;Inventory, Product&gt; allProducts =
    FocusPath.of(inventoryProductsLens).each();

// Apply 20% discount to electronics with low stock
Inventory updated = allProducts.modifyWhen(
    p -&gt; p.category() == Category.ELECTRONICS &amp;&amp; p.stock() &lt; 10,
    p -&gt; new Product(p.name(), p.stock(), p.price().multiply(new BigDecimal("0.80")), p.category()),
    inventory
);

// Clear stock only for food items
Inventory cleared = allProducts.modifyWhen(
    p -&gt; p.category() == Category.FOOD,
    p -&gt; new Product(p.name(), 0, p.price(), p.category()),
    inventory
);
</code></pre>
<div id="admonition-hands-on-learning" class="admonition admonish-info" role="note" aria-labelledby="admonition-hands-on-learning-title">
<div class="admonition-title">
<div id="admonition-hands-on-learning-title">
<p>Hands-On Learning</p>
</div>
<a class="admonition-anchor-link" href="optics/cookbook.html#admonition-hands-on-learning"></a>
</div>
<div>
<p>Practice real-world optics patterns in <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/optics/Tutorial08_RealWorldOptics.java">Tutorial 08: Real World Optics</a> (6 exercises, ~10 minutes).</p>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="optics/composition_rules.html">Composition Rules</a>
<strong>Next:</strong> <a href="optics/auditing_complex_data_example.html">Auditing Complex Data</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="auditing-complex-data-with-optics"><a class="header" href="#auditing-complex-data-with-optics">Auditing Complex Data with Optics</a></h1>
<h2 id="a-real-world-deep-dive-the-power-of-optics"><a class="header" href="#a-real-world-deep-dive-the-power-of-optics"><em>A Real-World Deep Dive</em>: The Power of Optics</a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="optics/auditing_complex_data_example.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>Solving complex, real-world data processing challenges with optics</li>
<li>Building conditional filtering and transformation pipelines</li>
<li>Combining all four core optic types in a single, powerful composition</li>
<li>Creating declarative, type-safe alternatives to nested loops and type casting</li>
<li>Advanced patterns like safe decoding, profunctor adaptations, and audit trails</li>
<li>When optic composition provides superior solutions to imperative approaches</li>
</ul>
</div>
</div>
<p>In modern software, we often work with complex, nested data structures. Performing a seemingly simple task, like "find and decode all production database passwords", can lead to messy, error-prone code with nested loops, <code>if</code> statements, and manual type casting.</p>
<p>This tutorial demonstrates how to solve a sophisticated, real-world problem elegantly using the full power of <strong>higher-kinded-j optics</strong>. We'll build a single, declarative, type-safe optic that performs a deep, conditional data transformation.</p>
<div id="admonition-example-code" class="admonition admonish-note" role="note" aria-labelledby="admonition-example-code-title">
<div class="admonition-title">
<div id="admonition-example-code-title">
<p>Example Code</p>
</div>
<a class="admonition-anchor-link" href="optics/auditing_complex_data_example.html#admonition-example-code"></a>
</div>
<div>
<p>All the example code for this tutorial can be found in the  `org.higherkindedj.example package in the <a href="https://github.com/higher-kinded-j/higher-kinded-j/tree/main/hkj-examples/src/main/java/org/higherkindedj/example/configaudit">Config Audit example</a>.</p>
<p>Other examples of using Optics can be found here.
<a href="https://github.com/higher-kinded-j/higher-kinded-j/tree/main/hkj-examples/src/main/java/org/higherkindedj/example/optics">Optics examples</a>.</p>
</div>
</div>
<hr />
<h2 id="the-challenge-a-conditional-config-audit"><a class="header" href="#the-challenge-a-conditional-config-audit">The Challenge: A Conditional Config Audit</a></h2>
<p>Imagine you're responsible for auditing application configurations. Your task is:</p>
<blockquote>
<p>Find every encrypted database password, but <strong>only</strong> for applications deployed to the <strong>Google Cloud Platform (<code>gcp</code>)</strong> that are running in the <strong><code>live</code> environment</strong>. For each password found, <strong>decode it from Base64</strong> into a raw <code>byte[]</code> for an audit service.</p>
</blockquote>
<p>This single sentence implies several operations:</p>
<ol>
<li><strong>Deep Traversal</strong>: Navigate from a top-level config object down into a list of settings.</li>
<li><strong>Filtering</strong>: Select only settings of a specific type (<code>EncryptedValue</code>).</li>
<li><strong>Conditional Logic</strong>: Apply this logic <em>only</em> if the top-level config meets specific criteria (<code>gcp</code> and <code>live</code>).</li>
<li><strong>Data Transformation</strong>: Decode the Base64 string into another type (<code>byte[]</code>).</li>
</ol>
<p>Doing this imperatively is a recipe for complexity. Let's build it with optics instead.</p>
<hr />
<h2 id="think-of-this-problem-like"><a class="header" href="#think-of-this-problem-like">Think of This Problem Like...</a></h2>
<ul>
<li><strong>A treasure hunt with conditional maps</strong>: Only certain maps (GCP/Live configs) contain the treasures (encrypted passwords)</li>
<li><strong>A selective mining operation</strong>: Drill down only into the right geological formations (config types) to extract specific minerals (encrypted data)</li>
<li><strong>A security scanner with filters</strong>: Only scan certain types of systems (matching deployment criteria) for specific vulnerabilities (encrypted values)</li>
<li><strong>A data archaeology expedition</strong>: Excavate only specific sites (qualified configs) to uncover particular artifacts (encoded passwords)</li>
</ul>
<hr />
<h2 id="the-four-tools-for-the-job"><a class="header" href="#the-four-tools-for-the-job">The Four Tools for the Job</a></h2>
<p>Our solution will compose the four primary optic types, each solving a specific part of the problem.</p>
<h3 id="1-lens-the-magnifying-glass"><a class="header" href="#1-lens-the-magnifying-glass">1. <strong>Lens</strong>: The Magnifying Glass</a></h3>
<p>A <code>Lens</code> provides focused access to a field within a product type (like a Java <code>record</code>). We'll use lenses to look inside our configuration objects.</p>
<ul>
<li><code>AppConfigLenses.settings()</code>: Zooms from an <code>AppConfig</code> to its <code>List&lt;Setting&gt;</code>.</li>
<li><code>SettingLenses.value()</code>: Zooms from a <code>Setting</code> to its <code>SettingValue</code>.</li>
</ul>
<h3 id="2-iso-the-universal-translator"><a class="header" href="#2-iso-the-universal-translator">2. <strong>Iso</strong>: The Universal Translator</a></h3>
<p>An <code>Iso</code> (Isomorphism) defines a lossless, two-way conversion between two types. It's perfect for handling different representations of the same data.</p>
<ul>
<li><code>DeploymentTarget &lt;-&gt; String</code>: We model our deployment target as a structured record but recognise it's isomorphic to a raw string like <code>"gcp|live"</code>. An <code>Iso</code> lets us switch between these representations.</li>
<li><code>String &lt;-&gt; byte[]</code>: Base64 is just an encoded representation of a byte array. An <code>Iso</code> is the perfect tool for handling this encoding and decoding.</li>
</ul>
<h3 id="3-prism-the-safe-filter"><a class="header" href="#3-prism-the-safe-filter">3. <strong>Prism</strong>: The Safe Filter</a></h3>
<p>A <code>Prism</code> provides focused access to a specific case within a sum type (like a <code>sealed interface</code>). It lets us safely attempt to "zoom in" on one variant, failing gracefully if the data is of a different kind.</p>
<ul>
<li><code>SettingValuePrisms.encryptedValue()</code>: This is our key filter. It will look at a <code>SettingValue</code> and only succeed if it's the <code>EncryptedValue</code> variant.</li>
</ul>
<h3 id="4-traversal-the-bulk-operator"><a class="header" href="#4-traversal-the-bulk-operator">4. <strong>Traversal</strong>: The Bulk Operator</a></h3>
<p>A <code>Traversal</code> lets us operate on zero or more targets within a larger structure. It's the ideal optic for working with collections.</p>
<ul>
<li><code>AppConfigTraversals.settings()</code>: This generated optic gives us a single tool to go from an <code>AppConfig</code> to every <code>Setting</code> inside its list.</li>
</ul>
<hr />
<h2 id="when-to-use-this-approach-vs-alternatives"><a class="header" href="#when-to-use-this-approach-vs-alternatives">When to Use This Approach vs Alternatives</a></h2>
<h3 id="use-optic-composition-when-1"><a class="header" href="#use-optic-composition-when-1">Use Optic Composition When:</a></h3>
<ul>
<li><strong>Complex conditional filtering</strong> - Multiple levels of filtering based on different criteria</li>
<li><strong>Reusable audit logic</strong> - The same audit pattern applies to different config types</li>
<li><strong>Type-safe data extraction</strong> - Ensuring compile-time safety for complex transformations</li>
<li><strong>Declarative data processing</strong> - Building self-documenting processing pipelines</li>
</ul>
<pre><code class="language-java">
// Perfect for reusable, conditional audit logic Traversal&lt;ServerConfig, byte[]&gt; sensitiveDataAuditor = ServerConfigTraversals.environments() .andThen(EnvironmentPrisms.production().asTraversal()) .andThen(EnvironmentTraversals.credentials()) .andThen(CredentialPrisms.encrypted().asTraversal()) .andThen(EncryptedCredentialIsos.base64ToBytes.asTraversal());

</code></pre>
<h3 id="use-stream-processing-when-1"><a class="header" href="#use-stream-processing-when-1">Use Stream Processing When:</a></h3>
<ul>
<li><strong>Simple filtering</strong> - Basic collection operations without complex nesting</li>
<li><strong>Performance critical paths</strong> - Minimal abstraction overhead needed</li>
<li><strong>Aggregation logic</strong> - Computing statistics or summaries</li>
</ul>
<pre><code class="language-java">
// Better with streams for simple collection processing List&lt;String&gt; allConfigNames = configs.stream() .map(AppConfig::name) .filter(name -&gt; name.startsWith("prod-")) .collect(toList());

</code></pre>
<h3 id="use-manual-iteration-when"><a class="header" href="#use-manual-iteration-when">Use Manual Iteration When:</a></h3>
<ul>
<li><strong>Early termination</strong> - You might want to stop processing on first match</li>
<li><strong>Complex business logic</strong> - Multiple conditions and branches that don't map cleanly</li>
<li><strong>Legacy integration</strong> - Working with existing imperative codebases</li>
</ul>
<pre><code class="language-java">
// Sometimes manual loops are clearest for complex logic for (AppConfig config : configs) { if (shouldAudit(config) &amp;&amp; hasEncryptedData(config)) { auditResults.add(performDetailedAudit(config)); if (auditResults.size() &gt;= MAX\_AUDITS) break; } }

</code></pre>
<hr />
<h2 id="common-pitfalls-29"><a class="header" href="#common-pitfalls-29">Common Pitfalls</a></h2>
<h3 id="dont-do-this-14"><a class="header" href="#dont-do-this-14">Don't Do This:</a></h3>
<pre><code class="language-java">
// Over-engineering simple cases Traversal&lt;String, String&gt; stringIdentity = Iso.of(s -&gt; s, s -&gt; s).asTraversal(); // Just use the string directly!

// Creating complex compositions inline var passwords = AppConfigLenses.settings().asTraversal() .andThen(SettingLenses.value().asTraversal()) .andThen(SettingValuePrisms.encryptedValue().asTraversal()) // ... 10 more lines of composition .getAll(config); // Hard to understand and reuse

// Ignoring error handling in transformations Iso&lt;String, byte[]&gt; unsafeBase64 = Iso.of( Base64.getDecoder()::decode,  // Can throw IllegalArgumentException! Base64.getEncoder()::encodeToString );

// Forgetting to test round-trip properties // No verification that encode(decode(x)) == x

</code></pre>
<h3 id="do-this-instead-14"><a class="header" href="#do-this-instead-14">Do This Instead:</a></h3>
<pre><code class="language-java">
// Use appropriate tools for simple cases String configName = config.name(); // Direct access is fine

// Create well-named, reusable compositions public static final Traversal&lt;AppConfig, byte[]&gt; GCP\_LIVE\_ENCRYPTED\_PASSWORDS = gcpLiveOnlyPrism.asTraversal() .andThen(AppConfigTraversals.settings()) .andThen(SettingLenses.value().asTraversal()) .andThen(SettingValuePrisms.encryptedValue().asTraversal()) .andThen(EncryptedValueLenses.base64Value().asTraversal()) .andThen(EncryptedValueIsos.base64.asTraversal());

// Handle errors gracefully Prism&lt;String, byte[]&gt; safeBase64Prism = Prism.of( str -&gt; { try { return Optional.of(Base64.getDecoder().decode(str)); } catch (IllegalArgumentException e) { return Optional.empty(); } }, bytes -&gt; Base64.getEncoder().encodeToString(bytes) );

// Test your compositions @Test public void testBase64RoundTrip() { String original = "test data"; String encoded = Base64.getEncoder().encodeToString(original.getBytes()); byte[] decoded = EncryptedValueIsos.base64.get(encoded); String roundTrip = new String(decoded); assertEquals(original, roundTrip); }

</code></pre>
<hr />
<h2 id="performance-notes-13"><a class="header" href="#performance-notes-13">Performance Notes</a></h2>
<p>Optic compositions are optimised for complex data processing:</p>
<ul>
<li><strong>Lazy evaluation</strong>: Complex filters only run when data actually matches</li>
<li><strong>Single-pass processing</strong>: Compositions traverse data structures only once</li>
<li><strong>Memory efficient</strong>: Only creates new objects for actual transformations</li>
<li><strong>Compile-time optimisation</strong>: Complex optic chains are inlined by the JVM</li>
<li><strong>Structural sharing</strong>: Unchanged parts of data structures are reused</li>
</ul>
<p><strong>Best Practice</strong>: Profile your specific use case and compare with stream-based alternatives:</p>
<pre><code class="language-java">
public class AuditPerformance { // For frequent auditing, create optics once and reuse 
    private static final Traversal&lt;AppConfig, byte[]&gt; AUDIT_TRAVERSAL = createAuditTraversal();

    @Benchmark
    public List&lt;byte[]&gt; opticBasedAudit(List&lt;AppConfig&gt; configs) {
        return configs.stream()
            .flatMap(config -&gt; Traversals.getAll(AUDIT_TRAVERSAL, config).stream())
            .collect(toList());
    }
  
    @Benchmark  
    public List&lt;byte[]&gt; streamBasedAudit(List&lt;AppConfig&gt; configs) {
        return configs.stream()
            .filter(this::isGcpLive)
            .flatMap(config -&gt; config.settings().stream())
            .map(Setting::value)
            .filter(EncryptedValue.class::isInstance)
            .map(EncryptedValue.class::cast)
            .map(encrypted -&gt; Base64.getDecoder().decode(encrypted.base64Value()))
            .collect(toList());
    }

}
</code></pre>
<h2 id="composing-the-solution"><a class="header" href="#composing-the-solution">Composing the Solution</a></h2>
<p>Here's how we chain these optics together. To create the most robust and general-purpose optic (a <code>Traversal</code>), we convert each part of our chain into a <code>Traversal</code> using <code>.asTraversal()</code> before composing it. This ensures type-safety and clarity throughout the process.</p>
<p>The final composed optic has the type <code>Traversal&lt;AppConfig, byte[]&gt;</code> and reads like a declarative path: <strong><code>AppConfig -&gt; (Filter for GCP/Live) -&gt; each Setting -&gt; its Value -&gt; (Filter for Encrypted) -&gt; the inner String -&gt; the raw bytes</code></strong></p>
<pre><code class="language-java">// Inside ConfigAuditExample.java

// A. First, create a Prism to act as our top-level filter.
Prism&lt;AppConfig, AppConfig&gt; gcpLiveOnlyPrism = Prism.of(
    config -&gt; {
        String rawTarget = DeploymentTarget.toRawString().get(config.target());
        return "gcp|live".equals(rawTarget) ? Optional.of(config) : Optional.empty();
    },
    config -&gt; config // The 'build' function is just identity
);

// B. Define the main traversal path to get to the data we want to audit.
Traversal&lt;AppConfig, byte[]&gt; auditTraversal =
    AppConfigTraversals.settings()                             // Traversal&lt;AppConfig, Setting&gt;
        .andThen(SettingLenses.value().asTraversal())        // Traversal&lt;AppConfig, SettingValue&gt;
        .andThen(SettingValuePrisms.encryptedValue().asTraversal()) // Traversal&lt;AppConfig, EncryptedValue&gt;
        .andThen(EncryptedValueLenses.base64Value().asTraversal())  // Traversal&lt;AppConfig, String&gt;
        .andThen(EncryptedValueIsos.base64.asTraversal());   // Traversal&lt;AppConfig, byte[]&gt;

// C. Combine the filter and the main traversal into the final optic.
Traversal&lt;AppConfig, byte[]&gt; finalAuditor = gcpLiveOnlyPrism.asTraversal().andThen(auditTraversal);

// D. Using the final optic is now trivial.
// We call a static helper method from our Traversals utility class.
List&lt;byte[]&gt; passwords = Traversals.getAll(finalAuditor, someConfig);
</code></pre>
<p>When we call <code>Traversals.getAll(finalAuditor, config)</code>, it performs the entire, complex operation and returns a simple <code>List&lt;byte[]&gt;</code> containing only the data we care about.</p>
<hr />
<h2 id="why-this-is-a-powerful-approach"><a class="header" href="#why-this-is-a-powerful-approach">Why This is a Powerful Approach</a></h2>
<ul>
<li><strong>Declarative &amp; Readable</strong>: The optic chain describes <em>what</em> data to get, not <em>how</em> to loop and check for it. The logic reads like a path, making it self-documenting.</li>
<li><strong>Composable &amp; Reusable</strong>: Every optic, and every composition, is a reusable component. We could reuse <code>gcpLiveOnlyPrism</code> for other tasks, or swap out the final <code>base64</code> Iso to perform a different transformation.</li>
<li><strong>Type-Safe</strong>: The entire operation is checked by the Java compiler. It's impossible to, for example, try to decode a <code>StringValue</code> as if it were encrypted. A mismatch in the optic chain results in a compile-time error, not a runtime <code>ClassCastException</code>.</li>
<li><strong>Architectural Purity</strong>: By having all optics share a common abstract parent (<code>Optic</code>), the library provides universal, lawful composition while allowing for specialised, efficient implementations.</li>
<li><strong>Testable</strong>: Each component can be tested independently, and the composition can be tested as a whole.</li>
</ul>
<hr />
<h2 id="taking-it-further"><a class="header" href="#taking-it-further">Taking It Further</a></h2>
<p>This example is just the beginning. Here are some ideas for extending this solution into a real-world application:</p>
<h3 id="1-safe-decoding-with-validated"><a class="header" href="#1-safe-decoding-with-validated">1. <strong>Safe Decoding with <code>Validated</code></strong></a></h3>
<p>The <code>Base64.getDecoder().decode()</code> can throw an <code>IllegalArgumentException</code>. Instead of an <code>Iso</code>, create an <code>AffineTraversal</code> (an optional <code>Prism</code>) that returns a <code>Validated&lt;String, byte[]&gt;</code>, separating successes from failures gracefully.</p>
<pre><code class="language-java">public static final Prism&lt;String, byte[]&gt; SAFE_BASE64_PRISM = Prism.of(
    encoded -&gt; {
        try {
            return Optional.of(Base64.getDecoder().decode(encoded));
        } catch (IllegalArgumentException e) {
            return Optional.empty();
        }
    },
    bytes -&gt; Base64.getEncoder().encodeToString(bytes)
);

// Use in a traversal that accumulates both successes and failures
public static AuditResult auditWithErrorReporting(AppConfig config) {
    var validatedApplicative = ValidatedMonad.instance(Semigroups.list());
  
    Traversal&lt;AppConfig, String&gt; base64Strings = /* ... path to base64 strings ... */;
  
    Validated&lt;List&lt;String&gt;, List&lt;byte[]&gt;&gt; result = VALIDATED.narrow(
        base64Strings.modifyF(
            encoded -&gt; SAFE_BASE64_PRISM.getOptional(encoded)
                .map(bytes -&gt; VALIDATED.widen(Validated.valid(bytes)))
                .orElse(VALIDATED.widen(Validated.invalid(List.of("Invalid base64: " + encoded)))),
            config,
            validatedApplicative
        )
    );
  
    return new AuditResult(result);
}
</code></pre>
<h3 id="2-data-migration-with-modify"><a class="header" href="#2-data-migration-with-modify">2. <strong>Data Migration with <code>modify</code></strong></a></h3>
<p>What if you need to re-encrypt all passwords with a new algorithm? The same <code>finalAuditor</code> optic can be used with a modify function from the <code>Traversals</code> utility class. You'd write a function <code>byte[] -&gt; byte[]</code> and apply it:</p>
<pre><code class="language-java">// A function that re-encrypts the raw password bytes
Function&lt;byte[], byte[]&gt; reEncryptFunction = oldBytes -&gt; newCipher.encrypt(oldBytes);

// Use the *exact same optic* to update the config in-place
AppConfig updatedConfig = Traversals.modify(finalAuditor, reEncryptFunction, originalConfig);
</code></pre>
<h3 id="3-profunctor-adaptations-for-legacy-systems"><a class="header" href="#3-profunctor-adaptations-for-legacy-systems">3. <strong>Profunctor Adaptations for Legacy Systems</strong></a></h3>
<p>Suppose your audit service expects a different data format: perhaps it works with <code>ConfigDto</code> objects instead of <code>AppConfig</code>. Rather than rewriting your carefully crafted optic, you can adapt it using profunctor operations:</p>
<pre><code class="language-java">// Adapt the auditor to work with legacy DTO format
Traversal&lt;ConfigDto, byte[]&gt; legacyAuditor = finalAuditor.contramap(dto -&gt; convertToAppConfig(dto));

// Or adapt both input and output formats simultaneously
Traversal&lt;ConfigDto, AuditRecord&gt; fullyAdaptedAuditor = finalAuditor.dimap(
    dto -&gt; convertToAppConfig(dto),           // Convert input format
    bytes -&gt; new AuditRecord(bytes, timestamp()) // Convert output format
);
</code></pre>
<p>This profunctor capability means your core business logic (the auditing path) remains unchanged whilst adapting to different system interfaces: a powerful example of the <a href="optics/profunctor_optics.html">Profunctor Optics</a> capabilities.</p>
<h3 id="4-more-complex-filters"><a class="header" href="#4-more-complex-filters">4. <strong>More Complex Filters</strong></a></h3>
<p>Create an optic that filters for deployments on <em>either</em><code>gcp</code> or <code>aws</code> but <em>only</em> in the <code>live</code> environment. The composable nature of optics makes building up these complex predicate queries straightforward.</p>
<pre><code class="language-java">// Multi-cloud live environment filter
Prism&lt;AppConfig, AppConfig&gt; cloudLiveOnlyPrism = Prism.of(
    config -&gt; {
        String rawTarget = DeploymentTarget.toRawString().get(config.target());
        boolean isLiveCloud = rawTarget.equals("gcp|live") || 
                             rawTarget.equals("aws|live") || 
                             rawTarget.equals("azure|live");
        return isLiveCloud ? Optional.of(config) : Optional.empty();
    },
    config -&gt; config
);

// Environment-specific processing
public static final Map&lt;String, Traversal&lt;AppConfig, byte[]&gt;&gt; ENVIRONMENT_AUDITORS = Map.of(
    "development", devEnvironmentPrism.asTraversal().andThen(auditTraversal),
    "staging", stagingEnvironmentPrism.asTraversal().andThen(auditTraversal),
    "production", cloudLiveOnlyPrism.asTraversal().andThen(auditTraversal)
);

public static List&lt;byte[]&gt; auditForEnvironment(String environment, AppConfig config) {
    return ENVIRONMENT_AUDITORS.getOrDefault(environment, Traversal.empty())
        .getAll(config);
}
</code></pre>
<h3 id="5-configuration-validation"><a class="header" href="#5-configuration-validation">5. <strong>Configuration Validation</strong></a></h3>
<p>Use the same optics to validate your configuration. You could compose a traversal that finds all <code>IntValue</code> settings with the key <code>"server.port"</code> and use <code>.getAll()</code> to check if their values are within a valid range (e.g., &gt; 1024).</p>
<pre><code class="language-java">public static final Traversal&lt;AppConfig, Integer&gt; SERVER_PORTS = 
    AppConfigTraversals.settings()
        .andThen(settingWithKey("server.port"))
        .andThen(SettingLenses.value().asTraversal())
        .andThen(SettingValuePrisms.intValue().asTraversal())
        .andThen(IntValueLenses.value().asTraversal());

public static List&lt;String&gt; validatePorts(AppConfig config) {
    return Traversals.getAll(SERVER_PORTS, config).stream()
        .filter(port -&gt; port &lt;= 1024 || port &gt; 65535)
        .map(port -&gt; "Invalid port: " + port + " (must be 1024-65535)")
        .collect(toList());
}
</code></pre>
<h3 id="6-audit-trail-generation"><a class="header" href="#6-audit-trail-generation">6. <strong>Audit Trail Generation</strong></a></h3>
<p>Extend the auditor to generate comprehensive audit trails:</p>
<pre><code class="language-java">public record AuditEntry(String configName, String settingKey, String encryptedValue, 
                        Instant auditTime, String auditorId) {}

public static final Traversal&lt;AppConfig, AuditEntry&gt; AUDIT_TRAIL_GENERATOR =
    gcpLiveOnlyPrism.asTraversal()
        .andThen(AppConfigTraversals.settings())
        .andThen(settingFilter)
        .andThen(auditEntryMapper);

// Generate complete audit report
public static AuditReport generateAuditReport(List&lt;AppConfig&gt; configs, String auditorId) {
    List&lt;AuditEntry&gt; entries = configs.stream()
        .flatMap(config -&gt; Traversals.getAll(AUDIT_TRAIL_GENERATOR, config).stream())
        .collect(toList());
  
    return new AuditReport(entries, Instant.now(), auditorId);
}
</code></pre>
<p>This combination of composability, type safety, and profunctor adaptability makes higher-kinded-j optics incredibly powerful for real-world data processing scenarios, particularly in enterprise environments where data formats, security requirements, and compliance needs are constantly evolving.</p>
<hr />
<p><strong>Previous:</strong> <a href="optics/cookbook.html">Cookbook</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="integration-guides"><a class="header" href="#integration-guides">Integration Guides</a></h1>
<blockquote>
<p><em>"If thought corrupts language, language can also corrupt thought."</em></p>
<p>– George Orwell, <em>Politics and the English Language</em></p>
</blockquote>
<hr />
<p>Exception-based error handling corrupts thought. When a method signature says <code>User getUser(String id)</code>, it lies by omission. The user might not exist. The database might be down. The ID might be malformed. None of this appears in the signature. The exceptions, when they come, arrive as surprises, handled in catch blocks scattered across the codebase, their semantics unclear, their taxonomy baroque.</p>
<p>Functional error handling clarifies thought. When a method returns <code>Either&lt;DomainError, User&gt;</code>, the signature tells the truth. Failure is possible. The error type is explicit. Callers must acknowledge this reality; the compiler ensures it. The code becomes honest.</p>
<p>This chapter bridges functional programming and enterprise Java. The <code>hkj-spring-boot-starter</code> allows Spring controllers to return <code>Either</code>, <code>Validated</code>, and <code>EitherT</code> directly. The framework handles the translation to HTTP responses: <code>Right</code> becomes 200 OK; <code>Left</code> becomes the appropriate error status. Validation errors accumulate properly. Async operations compose cleanly.</p>
<p>The integration is non-invasive. Existing exception-based endpoints continue to work. Migration can proceed incrementally. But as more of your codebase adopts functional error handling, a subtle shift occurs. Errors become data. Control flow becomes explicit. The language of your code begins to clarify your thought rather than corrupt it.</p>
<hr />
<h2 id="the-transformation"><a class="header" href="#the-transformation">The Transformation</a></h2>
<pre><code>    ┌─────────────────────────────────────────────────────────────┐
    │  EXCEPTION-BASED (Traditional)                              │
    │                                                             │
    │    User getUser(String id)    ← What can go wrong?         │
    │                                                             │
    │    @ExceptionHandler(UserNotFoundException.class)           │
    │    @ExceptionHandler(ValidationException.class)             │
    │    @ExceptionHandler(DatabaseException.class)               │
    │    ...scattered across the codebase                         │
    └─────────────────────────────────────────────────────────────┘

    ┌─────────────────────────────────────────────────────────────┐
    │  FUNCTIONAL (With hkj-spring)                               │
    │                                                             │
    │    Either&lt;DomainError, User&gt; getUser(String id)            │
    │           ↑                                                 │
    │    Errors visible in the type signature                     │
    │                                                             │
    │    → Right(user) automatically becomes HTTP 200             │
    │    → Left(NotFoundError) automatically becomes HTTP 404     │
    │    → Left(ValidationError) automatically becomes HTTP 400   │
    └─────────────────────────────────────────────────────────────┘
</code></pre>
<hr />
<h2 id="what-the-starter-provides"><a class="header" href="#what-the-starter-provides">What the Starter Provides</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Benefit</th></tr></thead><tbody>
<tr><td><code>Either</code> return types</td><td>Typed errors in controller signatures</td></tr>
<tr><td><code>Validated</code> return types</td><td>Accumulate all validation errors</td></tr>
<tr><td><code>EitherT</code> return types</td><td>Async operations with typed errors</td></tr>
<tr><td>Automatic status mapping</td><td>Error types → HTTP status codes</td></tr>
<tr><td>JSON serialisation</td><td>Configurable output formats</td></tr>
<tr><td>Actuator integration</td><td>Metrics for functional operations</td></tr>
<tr><td>Security integration</td><td>Functional authentication patterns</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="what-youll-learn-8"><a class="header" href="#what-youll-learn-8">What You'll Learn</a></h2>
<div id="admonition-in-this-chapter" class="admonition admonish-info" role="note" aria-labelledby="admonition-in-this-chapter-title">
<div class="admonition-title">
<div id="admonition-in-this-chapter-title">
<p>In This Chapter</p>
</div>
<a class="admonition-anchor-link" href="spring/ch_intro.html#admonition-in-this-chapter"></a>
</div>
<div>
<ul>
<li><strong>Spring Boot Integration</strong> – Configure Spring to accept Either, Validated, and EitherT as controller return types. The framework automatically maps Right to 200 OK and Left to appropriate error statuses.</li>
<li><strong>Migration Guide</strong> – A practical path from exception-based error handling to functional types. Start with one endpoint, prove the pattern, then expand incrementally.</li>
</ul>
</div>
</div>
<hr />
<h2 id="chapter-contents-8"><a class="header" href="#chapter-contents-8">Chapter Contents</a></h2>
<ol>
<li><a href="spring/spring_boot_integration.html">Spring Boot Integration</a> - Using Either, Validated, and EitherT in controllers</li>
<li><a href="spring/migrating_to_functional_errors.html">Migrating to Functional Errors</a> - Moving from exceptions to functional error handling</li>
</ol>
<hr />
<p><strong>Next:</strong> <a href="spring/spring_boot_integration.html">Spring Boot Integration</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="spring-boot-integration-functional-patterns-for-enterprise-applications"><a class="header" href="#spring-boot-integration-functional-patterns-for-enterprise-applications">Spring Boot Integration: Functional Patterns for Enterprise Applications</a></h1>
<h2 id="bringing-type-safe-error-handling-to-your-rest-apis"><a class="header" href="#bringing-type-safe-error-handling-to-your-rest-apis"><em>Bringing Type-Safe Error Handling to Your REST APIs</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="spring/spring_boot_integration.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to use Either, Validated, and EitherT as Spring controller return types</li>
<li>Zero-configuration setup with the hkj-spring-boot-starter</li>
<li>Automatic JSON serialisation with customisable formats</li>
<li>Monitoring functional operations with Spring Boot Actuator</li>
<li>Securing endpoints with functional error handling patterns</li>
<li>Building production-ready applications with explicit, typed errors</li>
<li>Testing functional controllers with MockMvc</li>
</ul>
</div>
</div>
<div id="admonition-example-application" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-application-title">
<div class="admonition-title">
<div id="admonition-example-application-title">
<p>Example Application</p>
</div>
<a class="admonition-anchor-link" href="spring/spring_boot_integration.html#admonition-example-application"></a>
</div>
<div>
<p>A complete working example is available in the <a href="https://github.com/higher-kinded-j/higher-kinded-j/tree/main/hkj-spring/example">hkj-spring example module</a>. Run it with:</p>
<pre><code class="language-bash">./gradlew :hkj-spring:example:bootRun
</code></pre>
</div>
</div>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Building REST APIs with Spring Boot is straightforward, but error handling often becomes a source of complexity and inconsistency. Traditional exception-based approaches scatter error handling logic across <code>@ExceptionHandler</code> methods, lose type safety, and make it difficult to reason about what errors a given endpoint can produce.</p>
<p>The <strong>hkj-spring-boot-starter</strong> solves these problems by bringing functional programming patterns seamlessly into Spring applications. Return <code>Either&lt;Error, Data&gt;</code>, <code>Validated&lt;Errors, Data&gt;</code>, or <code>EitherT</code> from your controllers, and the framework automatically handles the rest: converting functional types to appropriate HTTP responses whilst preserving type safety and composability.</p>
<p><strong>The key insight:</strong> Errors become explicit in your method signatures, not hidden in implementation details or exception hierarchies.</p>
<hr />
<h2 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h2>
<h3 id="step-1-add-the-dependency"><a class="header" href="#step-1-add-the-dependency">Step 1: Add the Dependency</a></h3>
<p>Add the starter to your Spring Boot project:</p>
<pre><code class="language-gradle">// build.gradle.kts
dependencies {
    implementation("io.github.higher-kinded-j:hkj-spring-boot-starter:LATEST_VERSION")
}
</code></pre>
<p>Or with Maven:</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;io.github.higher-kinded-j&lt;/groupId&gt;
    &lt;artifactId&gt;hkj-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;LATEST_VERSION&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="step-2-return-functional-types-from-controllers"><a class="header" href="#step-2-return-functional-types-from-controllers">Step 2: Return Functional Types from Controllers</a></h3>
<pre><code class="language-java">@RestController
@RequestMapping("/api/users")
public class UserController {

    @Autowired
    private UserService userService;

    @GetMapping("/{id}")
    public Either&lt;DomainError, User&gt; getUser(@PathVariable String id) {
        return userService.findById(id);
        // Right(user) → HTTP 200 with JSON body
        // Left(UserNotFoundError) → HTTP 404 with error details
    }

    @PostMapping
    public Validated&lt;List&lt;ValidationError&gt;, User&gt; createUser(@RequestBody UserRequest request) {
        return userService.validateAndCreate(request);
        // Valid(user) → HTTP 200 with user JSON
        // Invalid(errors) → HTTP 400 with all validation errors accumulated
    }
}
</code></pre>
<h3 id="step-3-run-your-application"><a class="header" href="#step-3-run-your-application">Step 3: Run Your Application</a></h3>
<p>That's it! The starter auto-configures everything:</p>
<ul>
<li>✅ Either → HTTP response conversion with automatic status code mapping</li>
<li>✅ Validated → HTTP response with error accumulation</li>
<li>✅ EitherT support for async operations with CompletableFuture</li>
<li>✅ JSON serialisation for functional types</li>
<li>✅ Customisable error type → HTTP status code mapping</li>
</ul>
<hr />
<h2 id="why-use-functional-error-handling"><a class="header" href="#why-use-functional-error-handling">Why Use Functional Error Handling?</a></h2>
<h3 id="the-problem-with-exceptions"><a class="header" href="#the-problem-with-exceptions">The Problem with Exceptions</a></h3>
<p>Traditional Spring Boot error handling relies on exceptions and <code>@ExceptionHandler</code> methods:</p>
<pre><code class="language-java">@GetMapping("/{id}")
public User getUser(@PathVariable String id) {
    return userService.findById(id);  // What errors can this throw?
}

@ExceptionHandler(UserNotFoundException.class)
public ResponseEntity&lt;ErrorResponse&gt; handleNotFound(UserNotFoundException ex) {
    return ResponseEntity.status(404).body(new ErrorResponse(ex.getMessage()));
}

@ExceptionHandler(ValidationException.class)
public ResponseEntity&lt;ErrorResponse&gt; handleValidation(ValidationException ex) {
    return ResponseEntity.status(400).body(new ErrorResponse(ex.getMessage()));
}
</code></pre>
<p><strong>Problems:</strong></p>
<ul>
<li>🔴 Errors are invisible in the method signature</li>
<li>🔴 No compile-time guarantee that all errors are handled</li>
<li>🔴 Exception handlers become a catch-all for unrelated errors</li>
<li>🔴 Difficult to compose operations whilst maintaining error information</li>
<li>🔴 Testing requires catching exceptions or using <code>@ExceptionHandler</code> integration</li>
</ul>
<h3 id="the-functional-solution"><a class="header" href="#the-functional-solution">The Functional Solution</a></h3>
<p>With functional error handling, errors become explicit and composable:</p>
<pre><code class="language-java">@GetMapping("/{id}")
public Either&lt;DomainError, User&gt; getUser(@PathVariable String id) {
    return userService.findById(id);  // Clear: returns User or DomainError
}

@GetMapping("/{id}/orders")
public Either&lt;DomainError, List&lt;Order&gt;&gt; getUserOrders(@PathVariable String id) {
    return userService.findById(id)
        .flatMap(orderService::getOrdersForUser);  // Compose operations naturally
}
</code></pre>
<p><strong>Benefits:</strong></p>
<ul>
<li>✅ Errors are explicit in the type signature</li>
<li>✅ Compiler ensures error handling at call sites</li>
<li>✅ Functional composition with <code>map</code>, <code>flatMap</code>, <code>fold</code></li>
<li>✅ Automatic HTTP response conversion</li>
<li>✅ Easy to test: no exception catching required</li>
</ul>
<hr />
<h2 id="core-features"><a class="header" href="#core-features">Core Features</a></h2>
<h3 id="1-either-success-or-typed-error"><a class="header" href="#1-either-success-or-typed-error">1. Either: Success or Typed Error</a></h3>
<p><code>Either&lt;L, R&gt;</code> represents a computation that can succeed with a <code>Right(value)</code> or fail with a <code>Left(error)</code>.</p>
<h4 id="basic-usage-4"><a class="header" href="#basic-usage-4">Basic Usage</a></h4>
<pre><code class="language-java">@RestController
@RequestMapping("/api/users")
public class UserController {

    @GetMapping("/{id}")
    public Either&lt;DomainError, User&gt; getUser(@PathVariable String id) {
        return userService.findById(id);
    }
}
</code></pre>
<p><strong>Response Mapping:</strong></p>
<ul>
<li><code>Right(user)</code> → HTTP 200 with JSON: <code>{"id": "1", "email": "alice@example.com", ...}</code></li>
<li><code>Left(UserNotFoundError)</code> → HTTP 404 with JSON: <code>{"success": false, "error": {"type": "UserNotFoundError", ...}}</code></li>
</ul>
<h4 id="error-type--http-status-mapping"><a class="header" href="#error-type--http-status-mapping">Error Type → HTTP Status Mapping</a></h4>
<p>The framework automatically maps error types to HTTP status codes by examining class names:</p>
<pre><code class="language-java">public sealed interface DomainError permits
    UserNotFoundError,      // Contains "NotFound" → 404
    ValidationError,        // Contains "Validation" → 400
    AuthorizationError,     // Contains "Authorization" → 403
    AuthenticationError {}  // Contains "Authentication" → 401

// Custom errors default to 400 Bad Request
</code></pre>
<h4 id="composing-operations"><a class="header" href="#composing-operations">Composing Operations</a></h4>
<pre><code class="language-java">@GetMapping("/{userId}/orders/{orderId}")
public Either&lt;DomainError, Order&gt; getUserOrder(
        @PathVariable String userId,
        @PathVariable String orderId) {

    return userService.findById(userId)
        .flatMap(user -&gt; orderService.findById(orderId))
        .flatMap(order -&gt; orderService.verifyOwnership(order, userId));

    // Short-circuits on first Left
}
</code></pre>
<p>See the <a href="spring/../monads/either_monad.html">Either Monad documentation</a> for comprehensive usage patterns.</p>
<hr />
<h3 id="2-validated-accumulating-multiple-errors"><a class="header" href="#2-validated-accumulating-multiple-errors">2. Validated: Accumulating Multiple Errors</a></h3>
<p><code>Validated&lt;E, A&gt;</code> is designed for validation scenarios where you want to accumulate <strong>all</strong> errors, not just the first one.</p>
<h4 id="basic-usage-5"><a class="header" href="#basic-usage-5">Basic Usage</a></h4>
<pre><code class="language-java">@PostMapping
public Validated&lt;List&lt;ValidationError&gt;, User&gt; createUser(@RequestBody UserRequest request) {
    return userService.validateAndCreate(request);
}
</code></pre>
<p><strong>Response Mapping:</strong></p>
<ul>
<li><code>Valid(user)</code> → HTTP 200 with JSON: <code>{"id": "1", "email": "alice@example.com", ...}</code></li>
<li><code>Invalid(errors)</code> → HTTP 400 with JSON: <code>{"success": false, "errors": [{"field": "email", "message": "Invalid format"}, ...]}</code></li>
</ul>
<h4 id="validation-example-1"><a class="header" href="#validation-example-1">Validation Example</a></h4>
<pre><code class="language-java">@Service
public class UserService {

    public Validated&lt;List&lt;ValidationError&gt;, User&gt; validateAndCreate(UserRequest request) {
        return Validated.validateAll(
            validateEmail(request.email()),
            validateName(request.firstName()),
            validateName(request.lastName())
        ).map(tuple -&gt; new User(
            UUID.randomUUID().toString(),
            tuple._1(),  // email
            tuple._2(),  // firstName
            tuple._3()   // lastName
        ));
    }

    private Validated&lt;ValidationError, String&gt; validateEmail(String email) {
        if (email == null || !email.contains("@")) {
            return Validated.invalid(new ValidationError("email", "Invalid email format"));
        }
        return Validated.valid(email);
    }

    private Validated&lt;ValidationError, String&gt; validateName(String name) {
        if (name == null || name.trim().isEmpty()) {
            return Validated.invalid(new ValidationError("name", "Name cannot be empty"));
        }
        return Validated.valid(name);
    }
}
</code></pre>
<p><strong>Key Difference from Either:</strong></p>
<ul>
<li><code>Either</code> short-circuits on first error (fail-fast)</li>
<li><code>Validated</code> accumulates all errors (fail-slow)</li>
</ul>
<p>See the <a href="spring/../monads/validated_monad.html">Validated Monad documentation</a> for detailed usage.</p>
<hr />
<h3 id="3-eithert-async-operations-with-typed-errors"><a class="header" href="#3-eithert-async-operations-with-typed-errors">3. EitherT: Async Operations with Typed Errors</a></h3>
<p><code>EitherT&lt;F, L, R&gt;</code> combines asynchronous computation (<code>CompletableFuture</code>) with typed errors (<code>Either</code>), allowing you to work with <code>CompletableFuture&lt;Either&lt;L, R&gt;&gt;</code> in a composable way.</p>
<h4 id="basic-usage-6"><a class="header" href="#basic-usage-6">Basic Usage</a></h4>
<pre><code class="language-java">@GetMapping("/{id}/async")
public EitherT&lt;CompletableFutureKind.Witness, DomainError, User&gt; getUserAsync(
        @PathVariable String id) {

    return asyncUserService.findByIdAsync(id);
    // Automatically handles async → sync HTTP response conversion
}
</code></pre>
<h4 id="async-composition"><a class="header" href="#async-composition">Async Composition</a></h4>
<pre><code class="language-java">@Service
public class AsyncOrderService {

    public EitherT&lt;CompletableFutureKind.Witness, DomainError, OrderSummary&gt;
    processOrderAsync(String userId, OrderRequest request) {

        return asyncUserService.findByIdAsync(userId)
            .flatMap(user -&gt; asyncInventoryService.checkAvailability(request.items()))
            .flatMap(availability -&gt; asyncPaymentService.processPayment(request.payment()))
            .map(payment -&gt; new OrderSummary(userId, request, payment));

        // Each step runs asynchronously
        // Short-circuits on first error
    }
}
</code></pre>
<p><strong>Response Handling:</strong>
The framework uses Spring's async request processing:</p>
<ol>
<li>Controller returns <code>EitherT</code></li>
<li>Framework extracts the <code>CompletableFuture&lt;Either&lt;L, R&gt;&gt;</code></li>
<li>Spring's async mechanism handles the future</li>
<li>When complete, Either is converted to HTTP response</li>
</ol>
<p>See the <a href="spring/../transformers/eithert_transformer.html">EitherT Transformer documentation</a> for comprehensive examples.</p>
<hr />
<h2 id="json-serialisation"><a class="header" href="#json-serialisation">JSON Serialisation</a></h2>
<p>The starter provides flexible JSON serialisation for functional types.</p>
<h3 id="configuration"><a class="header" href="#configuration">Configuration</a></h3>
<p>Configure serialisation format in <code>application.yml</code>:</p>
<pre><code class="language-yaml">hkj:
  jackson:
    custom-serializers-enabled: true  # Enable custom serialisers (default: true)
    either-format: TAGGED             # TAGGED, UNWRAPPED, or DIRECT
    validated-format: TAGGED          # TAGGED, UNWRAPPED, or DIRECT
    maybe-format: TAGGED              # TAGGED, UNWRAPPED, or DIRECT
</code></pre>
<h3 id="serialisation-formats"><a class="header" href="#serialisation-formats">Serialisation Formats</a></h3>
<h4 id="tagged-default"><a class="header" href="#tagged-default">TAGGED (Default)</a></h4>
<p>Wraps the value with metadata indicating success/failure:</p>
<pre><code class="language-json">// Right(user)
{
  "success": true,
  "value": {
    "id": "1",
    "email": "alice@example.com"
  }
}

// Left(error)
{
  "success": false,
  "error": {
    "type": "UserNotFoundError",
    "userId": "999"
  }
}
</code></pre>
<h4 id="unwrapped"><a class="header" href="#unwrapped">UNWRAPPED</a></h4>
<p>Returns just the value or error without wrapper:</p>
<pre><code class="language-json">// Right(user)
{
  "id": "1",
  "email": "alice@example.com"
}

// Left(error)
{
  "type": "UserNotFoundError",
  "userId": "999"
}
</code></pre>
<h4 id="direct"><a class="header" href="#direct">DIRECT</a></h4>
<p>Uses Either's default <code>toString()</code> representation (useful for debugging):</p>
<pre><code class="language-json">"Right(value=User[id=1, email=alice@example.com])"
</code></pre>
<p>For complete serialisation details, see <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-spring/JACKSON_SERIALIZATION.md">hkj-spring/JACKSON_SERIALIZATION.md</a>.</p>
<hr />
<h2 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h2>
<h3 id="web-configuration"><a class="header" href="#web-configuration">Web Configuration</a></h3>
<pre><code class="language-yaml">hkj:
  web:
    either-response-enabled: true      # Enable Either handler (default: true)
    validated-response-enabled: true   # Enable Validated handler (default: true)
    async-either-t-enabled: true       # Enable EitherT handler (default: true)
    default-error-status: 400          # Default HTTP status for unmapped errors
</code></pre>
<h3 id="async-executor-configuration"><a class="header" href="#async-executor-configuration">Async Executor Configuration</a></h3>
<p>For EitherT operations, configure the async thread pool:</p>
<pre><code class="language-yaml">hkj:
  async:
    core-pool-size: 10                 # Minimum threads
    max-pool-size: 20                  # Maximum threads
    queue-capacity: 100                # Queue size before rejection
    thread-name-prefix: "hkj-async-"   # Thread naming pattern
</code></pre>
<p>For complete configuration options, see <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-spring/CONFIGURATION.md">hkj-spring/CONFIGURATION.md</a>.</p>
<hr />
<h2 id="real-world-examples-1"><a class="header" href="#real-world-examples-1">Real-World Examples</a></h2>
<h3 id="example-1-user-management-api"><a class="header" href="#example-1-user-management-api">Example 1: User Management API</a></h3>
<p>A typical CRUD API with validation and error handling:</p>
<pre><code class="language-java">@RestController
@RequestMapping("/api/users")
public class UserController {

    @Autowired
    private UserService userService;

    // Get all users (always succeeds)
    @GetMapping
    public List&lt;User&gt; getAllUsers() {
        return userService.findAll();
    }

    // Get single user (may not exist)
    @GetMapping("/{id}")
    public Either&lt;DomainError, User&gt; getUser(@PathVariable String id) {
        return userService.findById(id);
        // Right(user) → 200 OK
        // Left(UserNotFoundError) → 404 Not Found
    }

    // Create user (validate all fields)
    @PostMapping
    public Validated&lt;List&lt;ValidationError&gt;, User&gt; createUser(@RequestBody UserRequest request) {
        return userService.validateAndCreate(request);
        // Valid(user) → 200 OK
        // Invalid([errors...]) → 400 Bad Request with all validation errors
    }

    // Update user (may not exist + validation)
    @PutMapping("/{id}")
    public Either&lt;DomainError, User&gt; updateUser(
            @PathVariable String id,
            @RequestBody UserRequest request) {

        return userService.findById(id)
            .flatMap(existingUser -&gt;
                userService.validateUpdate(request)
                    .toEither()  // Convert Validated to Either
                    .map(validRequest -&gt; userService.update(id, validRequest)));

        // Combines existence check + validation
    }

    // Delete user (may not exist)
    @DeleteMapping("/{id}")
    public Either&lt;DomainError, Void&gt; deleteUser(@PathVariable String id) {
        return userService.delete(id);
        // Right(null) → 200 OK
        // Left(UserNotFoundError) → 404 Not Found
    }

    // Get user's email (composition example)
    @GetMapping("/{id}/email")
    public Either&lt;DomainError, String&gt; getUserEmail(@PathVariable String id) {
        return userService.findById(id)
            .map(User::email);

        // Automatic error propagation
    }
}
</code></pre>
<h3 id="example-2-async-order-processing"><a class="header" href="#example-2-async-order-processing">Example 2: Async Order Processing</a></h3>
<p>Processing orders asynchronously with multiple external services:</p>
<pre><code class="language-java">@RestController
@RequestMapping("/api/orders")
public class OrderController {

    @Autowired
    private AsyncOrderService orderService;

    @PostMapping
    public EitherT&lt;CompletableFutureKind.Witness, DomainError, Order&gt; createOrder(
            @RequestBody OrderRequest request) {

        return orderService.processOrder(request);
        // Each step runs asynchronously:
        // 1. Validate user
        // 2. Check inventory
        // 3. Process payment
        // 4. Create order record

        // Short-circuits on first error
        // Returns 200 on success, appropriate error code on failure
    }

    @GetMapping("/{id}")
    public EitherT&lt;CompletableFutureKind.Witness, DomainError, Order&gt; getOrder(
            @PathVariable String id) {

        return orderService.findByIdAsync(id);
    }
}

@Service
public class AsyncOrderService {

    @Autowired
    private AsyncUserService userService;
    @Autowired
    private AsyncInventoryService inventoryService;
    @Autowired
    private AsyncPaymentService paymentService;
    @Autowired
    private OrderRepository orderRepository;

    public EitherT&lt;CompletableFutureKind.Witness, DomainError, Order&gt;
    processOrder(OrderRequest request) {

        return userService.findByIdAsync(request.userId())
            .flatMap(user -&gt; inventoryService.checkAvailabilityAsync(request.items()))
            .flatMap(availability -&gt; {
                if (!availability.allAvailable()) {
                    return EitherT.leftT(
                        CompletableFutureKindHelper.FUTURE,
                        new OutOfStockError(availability.unavailableItems())
                    );
                }
                return EitherT.rightT(
                    CompletableFutureKindHelper.FUTURE,
                    availability
                );
            })
            .flatMap(availability -&gt;
                paymentService.processPaymentAsync(request.payment()))
            .map(payment -&gt; createOrderRecord(request, payment));
    }
}
</code></pre>
<p>For complete working examples, see the <a href="https://github.com/higher-kinded-j/higher-kinded-j/tree/main/hkj-spring/example">hkj-spring example module</a>.</p>
<hr />
<h2 id="spring-security-integration"><a class="header" href="#spring-security-integration">Spring Security Integration</a></h2>
<p>The hkj-spring-boot-starter provides optional Spring Security integration with functional error handling patterns.</p>
<h3 id="enabling-security-integration"><a class="header" href="#enabling-security-integration">Enabling Security Integration</a></h3>
<pre><code class="language-yaml">hkj:
  security:
    enabled: true                       # Enable functional security (default: false)
    validated-user-details: true        # Use Validated for user loading
    either-authentication: true         # Use Either for authentication
    either-authorization: true          # Use Either for authorisation
</code></pre>
<h3 id="functional-user-details-service"><a class="header" href="#functional-user-details-service">Functional User Details Service</a></h3>
<p>Use <code>Validated</code> to accumulate authentication errors:</p>
<pre><code class="language-java">@Service
public class CustomUserDetailsService implements ValidatedUserDetailsService {

    @Override
    public Validated&lt;List&lt;SecurityError&gt;, UserDetails&gt; loadUserByUsername(String username) {
        return Validated.validateAll(
            validateUsername(username),
            validateAccountStatus(username),
            validateCredentials(username)
        ).map(tuple -&gt; new User(
            tuple._1(),  // username
            tuple._2(),  // password
            tuple._3()   // authorities
        ));

        // Returns ALL validation errors at once
        // e.g., "Username too short" + "Account locked"
    }
}
</code></pre>
<h3 id="functional-authentication"><a class="header" href="#functional-authentication">Functional Authentication</a></h3>
<p>Use <code>Either</code> for JWT authentication with typed errors:</p>
<pre><code class="language-java">@Component
public class JwtAuthenticationConverter {

    public Either&lt;AuthenticationError, Authentication&gt; convert(Jwt jwt) {
        return extractUsername(jwt)
            .flatMap(this::validateToken)
            .flatMap(this::extractAuthorities)
            .map(authorities -&gt; new JwtAuthenticationToken(jwt, authorities));

        // Short-circuits on first error
    }
}
</code></pre>
<p>For complete security integration details, see <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-spring/SECURITY.md">hkj-spring/SECURITY.md</a>.</p>
<hr />
<h2 id="monitoring-with-spring-boot-actuator"><a class="header" href="#monitoring-with-spring-boot-actuator">Monitoring with Spring Boot Actuator</a></h2>
<p>Track functional programming patterns in production with built-in Actuator integration.</p>
<h3 id="enabling-actuator-integration"><a class="header" href="#enabling-actuator-integration">Enabling Actuator Integration</a></h3>
<pre><code class="language-yaml">hkj:
  actuator:
    metrics:
      enabled: true                     # Enable metrics tracking
    health:
      async-executor:
        enabled: true                   # Monitor EitherT thread pool

management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,hkj
</code></pre>
<h3 id="available-metrics"><a class="header" href="#available-metrics">Available Metrics</a></h3>
<p>The starter automatically tracks:</p>
<ul>
<li><strong>Either metrics:</strong> Success/error counts and rates</li>
<li><strong>Validated metrics:</strong> Valid/invalid counts and error distributions</li>
<li><strong>EitherT metrics:</strong> Async operation durations and success rates</li>
<li><strong>Thread pool health:</strong> Active threads, queue size, saturation</li>
</ul>
<h3 id="custom-hkj-endpoint"><a class="header" href="#custom-hkj-endpoint">Custom HKJ Endpoint</a></h3>
<p>Access functional programming metrics via the custom actuator endpoint:</p>
<pre><code class="language-bash">curl http://localhost:8080/actuator/hkj
</code></pre>
<p>Response:</p>
<pre><code class="language-json">{
  "configuration": {
    "web": {
      "eitherResponseEnabled": true,
      "validatedResponseEnabled": true,
      "asyncEitherTEnabled": true
    },
    "jackson": {
      "eitherFormat": "TAGGED",
      "validatedFormat": "TAGGED"
    }
  },
  "metrics": {
    "either": {
      "successCount": 1547,
      "errorCount": 123,
      "totalCount": 1670,
      "successRate": 0.926
    },
    "validated": {
      "validCount": 892,
      "invalidCount": 45,
      "totalCount": 937,
      "validRate": 0.952
    },
    "eitherT": {
      "successCount": 234,
      "errorCount": 12,
      "totalCount": 246,
      "successRate": 0.951
    }
  }
}
</code></pre>
<h3 id="prometheus-integration"><a class="header" href="#prometheus-integration">Prometheus Integration</a></h3>
<p>Export metrics to Prometheus for monitoring and alerting:</p>
<pre><code class="language-yaml">management:
  metrics:
    export:
      prometheus:
        enabled: true
</code></pre>
<p>Example Prometheus queries:</p>
<pre><code class="language-promql"># Either error rate
rate(hkj_either_invocations_total{result="error"}[5m])

# EitherT p95 latency
histogram_quantile(0.95,
  rate(hkj_either_t_async_duration_seconds_bucket[5m]))

# Validated success rate
sum(rate(hkj_validated_invocations_total{result="valid"}[5m]))
  / sum(rate(hkj_validated_invocations_total[5m]))
</code></pre>
<p>For complete Actuator integration details, see <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-spring/ACTUATOR.md">hkj-spring/ACTUATOR.md</a>.</p>
<hr />
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<p>Testing functional controllers is straightforward with MockMvc.</p>
<h3 id="testing-either-responses"><a class="header" href="#testing-either-responses">Testing Either Responses</a></h3>
<pre><code class="language-java">@SpringBootTest
@AutoConfigureMockMvc
class UserControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    void shouldReturn200ForExistingUser() throws Exception {
        mockMvc.perform(get("/api/users/1"))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.success").value(true))
            .andExpect(jsonPath("$.value.id").value("1"))
            .andExpect(jsonPath("$.value.email").value("alice@example.com"));
    }

    @Test
    void shouldReturn404ForMissingUser() throws Exception {
        mockMvc.perform(get("/api/users/999"))
            .andExpect(status().isNotFound())
            .andExpect(jsonPath("$.success").value(false))
            .andExpect(jsonPath("$.error.type").value("UserNotFoundError"));
    }
}
</code></pre>
<h3 id="testing-validated-responses"><a class="header" href="#testing-validated-responses">Testing Validated Responses</a></h3>
<pre><code class="language-java">@Test
void shouldAccumulateValidationErrors() throws Exception {
    String invalidRequest = """
        {
          "email": "invalid",
          "firstName": "",
          "lastName": "x"
        }
        """;

    mockMvc.perform(post("/api/users")
            .contentType(MediaType.APPLICATION_JSON)
            .content(invalidRequest))
        .andExpect(status().isBadRequest())
        .andExpect(jsonPath("$.success").value(false))
        .andExpect(jsonPath("$.errors").isArray())
        .andExpect(jsonPath("$.errors.length()").value(3));  // All errors returned
}
</code></pre>
<h3 id="testing-eithert-async-responses"><a class="header" href="#testing-eithert-async-responses">Testing EitherT Async Responses</a></h3>
<pre><code class="language-java">@Test
void shouldHandleAsyncEitherTResponse() throws Exception {
    MvcResult result = mockMvc.perform(get("/api/users/1/async"))
        .andExpect(request().asyncStarted())  // Verify async started
        .andReturn();

    mockMvc.perform(asyncDispatch(result))   // Dispatch async result
        .andExpect(status().isOk())
        .andExpect(jsonPath("$.success").value(true))
        .andExpect(jsonPath("$.value.id").value("1"));
}
</code></pre>
<h3 id="unit-testing-services"><a class="header" href="#unit-testing-services">Unit Testing Services</a></h3>
<p>Services returning functional types are easy to test without mocking frameworks:</p>
<pre><code class="language-java">class UserServiceTest {

    private UserService service;

    @Test
    void shouldReturnRightWhenUserExists() {
        Either&lt;DomainError, User&gt; result = service.findById("1");

        assertThat(result.isRight()).isTrue();
        User user = result.getRight();
        assertThat(user.id()).isEqualTo("1");
    }

    @Test
    void shouldReturnLeftWhenUserNotFound() {
        Either&lt;DomainError, User&gt; result = service.findById("999");

        assertThat(result.isLeft()).isTrue();
        DomainError error = result.getLeft();
        assertThat(error).isInstanceOf(UserNotFoundError.class);
    }

    @Test
    void shouldAccumulateValidationErrors() {
        UserRequest invalid = new UserRequest("bad-email", "", "x");

        Validated&lt;List&lt;ValidationError&gt;, User&gt; result =
            service.validateAndCreate(invalid);

        assertThat(result.isInvalid()).isTrue();
        List&lt;ValidationError&gt; errors = result.getErrors();
        assertThat(errors).hasSize(3);
    }
}
</code></pre>
<p>For comprehensive testing examples, see <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-spring/example/TESTING.md">hkj-spring/example/TESTING.md</a>.</p>
<hr />
<h2 id="migration-guide"><a class="header" href="#migration-guide">Migration Guide</a></h2>
<p>Migrating from exception-based error handling to functional patterns is straightforward and can be done incrementally.</p>
<p>See the <a href="spring/./migrating_to_functional_errors.html">Migration Guide</a> for a complete step-by-step walkthrough of:</p>
<ul>
<li>Converting exception-throwing methods to Either</li>
<li>Replacing <code>@ExceptionHandler</code> methods with functional patterns</li>
<li>Migrating validation logic to Validated</li>
<li>Converting async operations to EitherT</li>
<li>Maintaining backwards compatibility during migration</li>
</ul>
<hr />
<h2 id="architecture-and-design"><a class="header" href="#architecture-and-design">Architecture and Design</a></h2>
<h3 id="auto-configuration"><a class="header" href="#auto-configuration">Auto-Configuration</a></h3>
<p>The starter uses Spring Boot 3.x auto-configuration:</p>
<pre><code class="language-java">@AutoConfiguration
@ConditionalOnClass({DispatcherServlet.class, Kind.class})
@ConditionalOnWebApplication(type = SERVLET)
public class HkjWebMvcAutoConfiguration implements WebMvcConfigurer {

    @Override
    public void addReturnValueHandlers(List&lt;HandlerMethodReturnValueHandler&gt; handlers) {
        handlers.add(new EitherReturnValueHandler(properties));
        handlers.add(new ValidatedReturnValueHandler(properties));
        handlers.add(new EitherTReturnValueHandler(properties));
    }
}
</code></pre>
<p>Auto-configuration activates when:</p>
<ul>
<li><code>higher-kinded-j-core</code> is on the classpath</li>
<li>Spring Web MVC is present</li>
<li>Application is a servlet web app</li>
</ul>
<h3 id="return-value-handlers"><a class="header" href="#return-value-handlers">Return Value Handlers</a></h3>
<p>Each functional type has a dedicated handler:</p>
<ol>
<li><strong>EitherReturnValueHandler:</strong> Converts <code>Either&lt;L, R&gt;</code> to HTTP responses</li>
<li><strong>ValidatedReturnValueHandler:</strong> Converts <code>Validated&lt;E, A&gt;</code> to HTTP responses</li>
<li><strong>EitherTReturnValueHandler:</strong> Unwraps <code>CompletableFuture&lt;Either&lt;L, R&gt;&gt;</code> for async processing</li>
</ol>
<p>Handlers are registered automatically and integrated seamlessly with Spring's request processing lifecycle.</p>
<h3 id="non-invasive-design"><a class="header" href="#non-invasive-design">Non-Invasive Design</a></h3>
<p>The integration doesn't modify existing Spring Boot behaviour:</p>
<ul>
<li>Standard Spring MVC types work unchanged</li>
<li>Exception handling still functions normally</li>
<li>Can be disabled via configuration</li>
<li>Coexists with traditional <code>ResponseEntity</code> endpoints</li>
</ul>
<hr />
<h2 id="frequently-asked-questions"><a class="header" href="#frequently-asked-questions">Frequently Asked Questions</a></h2>
<h3 id="can-i-mix-functional-and-traditional-exception-handling"><a class="header" href="#can-i-mix-functional-and-traditional-exception-handling">Can I mix functional and traditional exception handling?</a></h3>
<p>Yes! The integration is non-invasive. You can use <code>Either</code>, <code>Validated</code>, and <code>EitherT</code> alongside traditional <code>ResponseEntity</code> and exception-based endpoints in the same application.</p>
<h3 id="does-this-work-with-spring-webflux"><a class="header" href="#does-this-work-with-spring-webflux">Does this work with Spring WebFlux?</a></h3>
<p>Currently, the starter supports Spring Web MVC (servlet-based). WebFlux support is planned for a future release.</p>
<h3 id="can-i-customise-the-error--http-status-mapping"><a class="header" href="#can-i-customise-the-error--http-status-mapping">Can I customise the error → HTTP status mapping?</a></h3>
<p>Yes. Implement a custom return value handler or use the configuration properties to set default status codes. See <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-spring/CONFIGURATION.md">CONFIGURATION.md</a> for details.</p>
<h3 id="how-does-performance-compare-to-exceptions"><a class="header" href="#how-does-performance-compare-to-exceptions">How does performance compare to exceptions?</a></h3>
<p>Functional error handling is generally faster than exception-throwing for expected error cases, as it avoids stack trace generation and exception propagation overhead. For success cases, performance is equivalent.</p>
<h3 id="can-i-use-this-with-spring-data-repositories"><a class="header" href="#can-i-use-this-with-spring-data-repositories">Can I use this with Spring Data repositories?</a></h3>
<p>Yes. Wrap repository calls in your service layer:</p>
<pre><code class="language-java">@Service
public class UserService {

    @Autowired
    private UserRepository repository;

    public Either&lt;DomainError, User&gt; findById(String id) {
        return repository.findById(id)
            .map(Either::&lt;DomainError, User&gt;right)
            .orElseGet(() -&gt; Either.left(new UserNotFoundError(id)));
    }
}
</code></pre>
<h3 id="does-this-work-with-validation-annotations-valid"><a class="header" href="#does-this-work-with-validation-annotations-valid">Does this work with validation annotations (<code>@Valid</code>)?</a></h3>
<p>The integration focuses on functional validation patterns. For Spring's <code>@Valid</code> integration, you can convert <code>BindingResult</code> to <code>Validated</code> in your controllers.</p>
<hr />
<h2 id="related-documentation"><a class="header" href="#related-documentation">Related Documentation</a></h2>
<ul>
<li><a href="spring/../monads/either_monad.html">Either Monad</a> - Comprehensive Either usage</li>
<li><a href="spring/../monads/validated_monad.html">Validated Monad</a> - Validation patterns</li>
<li><a href="spring/../transformers/eithert_transformer.html">EitherT Transformer</a> - Async composition</li>
<li><a href="spring/./migrating_to_functional_errors.html">Migration Guide</a> - Step-by-step migration</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-spring/CONFIGURATION.md">Configuration Guide</a> - Complete configuration options</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-spring/JACKSON_SERIALIZATION.md">Jackson Serialisation</a> - JSON format details</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-spring/SECURITY.md">Security Integration</a> - Spring Security patterns</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-spring/ACTUATOR.md">Actuator Monitoring</a> - Metrics and health checks</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-spring/example/TESTING.md">Testing Guide</a> - Testing patterns</li>
</ul>
<hr />
<h2 id="summary-17"><a class="header" href="#summary-17">Summary</a></h2>
<p>The hkj-spring-boot-starter brings functional programming patterns seamlessly into Spring Boot applications:</p>
<ul>
<li>
<p>✅ <strong>Return functional types from controllers</strong> - Either, Validated, EitherT</p>
</li>
<li>
<p>✅ <strong>Automatic HTTP response conversion</strong> - No boilerplate required</p>
</li>
<li>
<p>✅ <strong>Explicit, type-safe error handling</strong> - Errors in method signatures</p>
</li>
<li>
<p>✅ <strong>Composable operations</strong> - Functional composition with map/flatMap</p>
</li>
<li>
<p>✅ <strong>Zero configuration</strong> - Auto-configuration handles everything</p>
</li>
<li>
<p>✅ <strong>Production-ready</strong> - Actuator metrics, security integration</p>
</li>
<li>
<p>✅ <strong>Easy to test</strong> - No exception mocking required</p>
</li>
</ul>
<p>Get started today by adding the dependency and returning functional types from your controllers. The framework handles the rest!</p>
<hr />
<p><strong>Previous:</strong> <a href="spring/ch_intro.html">Introduction</a>
<strong>Next:</strong> <a href="spring/migrating_to_functional_errors.html">Migrating to Functional Errors</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="migrating-from-exceptions-to-functional-error-handling"><a class="header" href="#migrating-from-exceptions-to-functional-error-handling">Migrating from Exceptions to Functional Error Handling</a></h1>
<h2 id="a-practical-step-by-step-guide"><a class="header" href="#a-practical-step-by-step-guide"><em>A Practical Step-by-Step Guide</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="spring/migrating_to_functional_errors.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to incrementally migrate exception-based code to functional patterns</li>
<li>Converting exception-throwing methods to Either</li>
<li>Replacing <code>@ExceptionHandler</code> methods with automatic response conversion</li>
<li>Migrating validation logic to Validated</li>
<li>Converting async operations to EitherT</li>
<li>Maintaining backwards compatibility during migration</li>
<li>Common migration patterns and pitfalls to avoid</li>
</ul>
</div>
</div>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>Migrating from exception-based error handling to functional patterns doesn't have to be all-or-nothing. This guide shows you how to migrate incrementally, maintaining backwards compatibility whilst gradually introducing type-safe error handling.</p>
<p><strong>Key Principle:</strong> Start with new endpoints or the most problematic areas, then expand as you see the benefits.</p>
<hr />
<h2 id="incremental-migration"><a class="header" href="#incremental-migration">Incremental Migration</a></h2>
<p>Start by using functional types for all <strong>new</strong> endpoints. This allows your team to learn the patterns without touching existing code.</p>
<p><strong>Approach:</strong></p>
<ul>
<li>Use Either/Validated for new controllers</li>
<li>Leave existing exception-based endpoints unchanged</li>
<li>Build confidence with the new patterns</li>
</ul>
<p>Identify endpoints with complex error handling or frequent bugs. These are prime candidates for migration:</p>
<ul>
<li>Endpoints with multiple <code>@ExceptionHandler</code> methods</li>
<li>Validation-heavy endpoints</li>
<li>Async operations with complicated error propagation</li>
</ul>
<p>Gradually migrate remaining endpoints as you touch them for other reasons (features, bug fixes, refactoring).</p>
<hr />
<h2 id="pattern-1-simple-exception-to-either"><a class="header" href="#pattern-1-simple-exception-to-either">Pattern 1: Simple Exception to Either</a></h2>
<h3 id="before-exception-throwing-method"><a class="header" href="#before-exception-throwing-method">Before: Exception-Throwing Method</a></h3>
<pre><code class="language-java">@Service
public class UserService {

    @Autowired
    private UserRepository repository;

    public User findById(String id) {
        return repository.findById(id)
            .orElseThrow(() -&gt; new UserNotFoundException(id));
    }
}

@RestController
@RequestMapping("/api/users")
public class UserController {

    @Autowired
    private UserService userService;

    @GetMapping("/{id}")
    public User getUser(@PathVariable String id) {
        return userService.findById(id);  // What exceptions can this throw?
    }

    @ExceptionHandler(UserNotFoundException.class)
    public ResponseEntity&lt;ErrorResponse&gt; handleNotFound(UserNotFoundException ex) {
        return ResponseEntity.status(404)
            .body(new ErrorResponse("USER_NOT_FOUND", ex.getMessage()));
    }
}
</code></pre>
<p><strong>Potential Problems:</strong></p>
<ul>
<li>Error types hidden in implementation</li>
<li>Requires reading method bodies to understand possible failures</li>
<li><code>@ExceptionHandler</code> catches exceptions from unrelated methods</li>
<li>Testing requires exception mocking</li>
</ul>
<h3 id="after-either-returning-method"><a class="header" href="#after-either-returning-method">After: Either-Returning Method</a></h3>
<pre><code class="language-java">@Service
public class UserService {

    @Autowired
    private UserRepository repository;

    public Either&lt;DomainError, User&gt; findById(String id) {
        return repository.findById(id)
            .map(Either::&lt;DomainError, User&gt;right)
            .orElseGet(() -&gt; Either.left(new UserNotFoundError(id)));
    }
}

// Domain error types
public sealed interface DomainError permits UserNotFoundError, ValidationError {
}

public record UserNotFoundError(String userId) implements DomainError {
}

@RestController
@RequestMapping("/api/users")
public class UserController {

    @Autowired
    private UserService userService;

    @GetMapping("/{id}")
    public Either&lt;DomainError, User&gt; getUser(@PathVariable String id) {
        return userService.findById(id);  // Clear: returns User or DomainError
    }

    // No @ExceptionHandler needed! Framework handles Either → HTTP conversion
}
</code></pre>
<p><strong>Some Benefits:</strong></p>
<ul>
<li>✅ Errors explicit in method signature</li>
<li>✅ Compiler enforces error handling at call sites</li>
<li>✅ No <code>@ExceptionHandler</code> boilerplate</li>
<li>✅ Easy to test: no exception mocking</li>
</ul>
<h3 id="migration-steps"><a class="header" href="#migration-steps">Migration Steps</a></h3>
<p><strong>Step 1:</strong> Define your error types as a sealed interface hierarchy</p>
<pre><code class="language-java">public sealed interface DomainError permits
    UserNotFoundError,
    ValidationError,
    AuthorizationError {
}

public record UserNotFoundError(String userId) implements DomainError {
}
</code></pre>
<p><strong>Step 2:</strong> Convert service methods one at a time</p>
<pre><code class="language-java">// Keep old method temporarily for backwards compatibility
@Deprecated
public User findById_OLD(String id) {
    return repository.findById(id)
        .orElseThrow(() -&gt; new UserNotFoundException(id));
}

// New method with functional return type
public Either&lt;DomainError, User&gt; findById(String id) {
    return repository.findById(id)
        .map(Either::&lt;DomainError, User&gt;right)
        .orElseGet(() -&gt; Either.left(new UserNotFoundError(id)));
}
</code></pre>
<p><strong>Step 3:</strong> Update controller methods</p>
<pre><code class="language-java">@GetMapping("/{id}")
public Either&lt;DomainError, User&gt; getUser(@PathVariable String id) {
    return userService.findById(id);
}
</code></pre>
<p><strong>Step 4:</strong> Remove <code>@ExceptionHandler</code> methods once all callers are migrated</p>
<pre><code class="language-java">// DELETE THIS - no longer needed!
// @ExceptionHandler(UserNotFoundException.class)
// public ResponseEntity&lt;ErrorResponse&gt; handleNotFound(...)
</code></pre>
<hr />
<h2 id="pattern-2-multiple-exceptions-to-either"><a class="header" href="#pattern-2-multiple-exceptions-to-either">Pattern 2: Multiple Exceptions to Either</a></h2>
<h3 id="before-multiple-exception-types"><a class="header" href="#before-multiple-exception-types">Before: Multiple Exception Types</a></h3>
<pre><code class="language-java">@Service
public class OrderService {

    public Order processOrder(OrderRequest request) throws
            UserNotFoundException,
            InsufficientStockException,
            PaymentFailedException {

        User user = userService.findById(request.userId());  // throws UserNotFoundException
        checkStock(request.items());                          // throws InsufficientStockException
        processPayment(request.payment());                    // throws PaymentFailedException

        return createOrder(request);
    }
}

@RestController
public class OrderController {

    @PostMapping("/orders")
    public Order createOrder(@RequestBody OrderRequest request) {
        return orderService.processOrder(request);
    }

    @ExceptionHandler(UserNotFoundException.class)
    public ResponseEntity&lt;?&gt; handleUserNotFound(UserNotFoundException ex) {
        return ResponseEntity.status(404).body(new ErrorResponse(ex.getMessage()));
    }

    @ExceptionHandler(InsufficientStockException.class)
    public ResponseEntity&lt;?&gt; handleOutOfStock(InsufficientStockException ex) {
        return ResponseEntity.status(400).body(new ErrorResponse(ex.getMessage()));
    }

    @ExceptionHandler(PaymentFailedException.class)
    public ResponseEntity&lt;?&gt; handlePaymentFailed(PaymentFailedException ex) {
        return ResponseEntity.status(402).body(new ErrorResponse(ex.getMessage()));
    }
}
</code></pre>
<h3 id="after-either-with-discriminated-errors"><a class="header" href="#after-either-with-discriminated-errors">After: Either with Discriminated Errors</a></h3>
<pre><code class="language-java">public sealed interface OrderError permits
    UserNotFoundError,
    OutOfStockError,
    PaymentFailedError {
}

@Service
public class OrderService {

    public Either&lt;OrderError, Order&gt; processOrder(OrderRequest request) {
        return userService.findById(request.userId())
            .mapLeft(this::toDomainError)  // Convert DomainError to OrderError
            .flatMap(user -&gt; checkStock(request.items()))
            .flatMap(stock -&gt; processPayment(request.payment()))
            .map(payment -&gt; createOrder(request, payment));

        // Short-circuits on first error
        // All error types explicit in OrderError sealed interface
    }

    private Either&lt;OrderError, Stock&gt; checkStock(List&lt;Item&gt; items) {
        // Check stock logic
        if (/* out of stock */) {
            return Either.left(new OutOfStockError(unavailableItems));
        }
        return Either.right(stock);
    }

    private Either&lt;OrderError, Payment&gt; processPayment(PaymentRequest payment) {
        // Payment logic
        if (/* payment failed */) {
            return Either.left(new PaymentFailedError(reason));
        }
        return Either.right(payment);
    }
}

@RestController
public class OrderController {

    @PostMapping("/orders")
    public Either&lt;OrderError, Order&gt; createOrder(@RequestBody OrderRequest request) {
        return orderService.processOrder(request);
    }

    // No @ExceptionHandler methods needed!
    // Framework maps error types to HTTP status:
    // - UserNotFoundError → 404
    // - OutOfStockError → 400
    // - PaymentFailedError → 402
}
</code></pre>
<p><strong>Key Improvement:</strong> All possible errors are visible in the <code>OrderError</code> sealed interface.</p>
<hr />
<h2 id="pattern-3-validation-exceptions-to-validated"><a class="header" href="#pattern-3-validation-exceptions-to-validated">Pattern 3: Validation Exceptions to Validated</a></h2>
<h3 id="before-validation-with-exceptions"><a class="header" href="#before-validation-with-exceptions">Before: Validation with Exceptions</a></h3>
<pre><code class="language-java">@PostMapping
public User createUser(@Valid @RequestBody UserRequest request, BindingResult bindingResult) {
    if (bindingResult.hasErrors()) {
        List&lt;String&gt; errors = bindingResult.getAllErrors()
            .stream()
            .map(ObjectError::getDefaultMessage)
            .toList();
        throw new ValidationException(errors);
    }

    // Additional custom validation
    if (!emailService.isValid(request.email())) {
        throw new ValidationException("Invalid email format");
    }

    if (userRepository.existsByEmail(request.email())) {
        throw new ValidationException("Email already exists");
    }

    return userService.create(request);
}

@ExceptionHandler(ValidationException.class)
public ResponseEntity&lt;?&gt; handleValidation(ValidationException ex) {
    return ResponseEntity.status(400)
        .body(new ErrorResponse(ex.getErrors()));
}
</code></pre>
<p><strong>Problem:</strong> Only the first validation error is thrown. To see all errors, user must fix one at a time.</p>
<h3 id="after-validated-with-error-accumulation"><a class="header" href="#after-validated-with-error-accumulation">After: Validated with Error Accumulation</a></h3>
<pre><code class="language-java">public record ValidationError(String field, String message) {
}

@Service
public class UserService {

    public Validated&lt;List&lt;ValidationError&gt;, User&gt; validateAndCreate(UserRequest request) {
        return Validated.validateAll(
            validateEmail(request.email()),
            validateFirstName(request.firstName()),
            validateLastName(request.lastName()),
            validateUniqueEmail(request.email())
        ).map(tuple -&gt; createUser(
            tuple._1(),  // validated email
            tuple._2(),  // validated firstName
            tuple._3(),  // validated lastName
            tuple._4()   // uniqueness confirmed
        ));
    }

    private Validated&lt;ValidationError, String&gt; validateEmail(String email) {
        if (email == null || !email.matches("^[A-Za-z0-9+_.-]+@(.+)$")) {
            return Validated.invalid(
                new ValidationError("email", "Invalid email format"));
        }
        return Validated.valid(email);
    }

    private Validated&lt;ValidationError, String&gt; validateFirstName(String name) {
        if (name == null || name.trim().length() &lt; 2) {
            return Validated.invalid(
                new ValidationError("firstName", "First name must be at least 2 characters"));
        }
        return Validated.valid(name);
    }

    private Validated&lt;ValidationError, String&gt; validateLastName(String name) {
        if (name == null || name.trim().length() &lt; 2) {
            return Validated.invalid(
                new ValidationError("lastName", "Last name must be at least 2 characters"));
        }
        return Validated.valid(name);
    }

    private Validated&lt;ValidationError, String&gt; validateUniqueEmail(String email) {
        if (userRepository.existsByEmail(email)) {
            return Validated.invalid(
                new ValidationError("email", "Email already exists"));
        }
        return Validated.valid(email);
    }
}

@RestController
@RequestMapping("/api/users")
public class UserController {

    @PostMapping
    public Validated&lt;List&lt;ValidationError&gt;, User&gt; createUser(@RequestBody UserRequest request) {
        return userService.validateAndCreate(request);
    }

    // No @ExceptionHandler needed!
    // Framework converts:
    // - Valid(user) → 200 OK with user JSON
    // - Invalid(errors) → 400 Bad Request with ALL validation errors
}
</code></pre>
<p><strong>Why it helps:</strong></p>
<ul>
<li>✅ Returns <strong>all</strong> validation errors at once</li>
<li>✅ Better user experience (fix all issues in one go)</li>
<li>✅ Validation logic is composable and testable</li>
<li>✅ No special exception types needed</li>
</ul>
<h3 id="migration-steps-1"><a class="header" href="#migration-steps-1">Migration Steps</a></h3>
<p><strong>Step 1:</strong> Extract validation logic into individual <code>Validated</code> functions</p>
<pre><code class="language-java">private Validated&lt;ValidationError, String&gt; validateEmail(String email) {
    // validation logic
}
</code></pre>
<p><strong>Step 2:</strong> Compose validations with <code>Validated.validateAll()</code></p>
<pre><code class="language-java">public Validated&lt;List&lt;ValidationError&gt;, User&gt; validateAndCreate(UserRequest request) {
    return Validated.validateAll(
        validateEmail(request.email()),
        validateName(request.name())
        // ... more validations
    ).map(tuple -&gt; createUser(...));
}
</code></pre>
<p><strong>Step 3:</strong> Return <code>Validated</code> from controller</p>
<pre><code class="language-java">@PostMapping
public Validated&lt;List&lt;ValidationError&gt;, User&gt; createUser(@RequestBody UserRequest request) {
    return userService.validateAndCreate(request);
}
</code></pre>
<hr />
<h2 id="pattern-4-async-exceptions-to-eithert"><a class="header" href="#pattern-4-async-exceptions-to-eithert">Pattern 4: Async Exceptions to EitherT</a></h2>
<h3 id="before-completablefuture-with-exception-handling"><a class="header" href="#before-completablefuture-with-exception-handling">Before: CompletableFuture with Exception Handling</a></h3>
<pre><code class="language-java">@Service
public class AsyncOrderService {

    public CompletableFuture&lt;Order&gt; processOrderAsync(OrderRequest request) {
        return userService.findByIdAsync(request.userId())
            .thenCompose(user -&gt; {
                if (user == null) {
                    throw new CompletionException(new UserNotFoundException(request.userId()));
                }
                return inventoryService.checkStockAsync(request.items());
            })
            .thenCompose(stock -&gt; {
                if (!stock.isAvailable()) {
                    throw new CompletionException(new OutOfStockException());
                }
                return paymentService.processPaymentAsync(request.payment());
            })
            .handle((payment, ex) -&gt; {
                if (ex != null) {
                    // Complex error handling logic
                    Throwable cause = ex.getCause();
                    if (cause instanceof UserNotFoundException) {
                        throw new CompletionException(cause);
                    } else if (cause instanceof OutOfStockException) {
                        throw new CompletionException(cause);
                    }
                    throw new CompletionException(ex);
                }
                return createOrder(request, payment);
            });
    }
}

@RestController
public class OrderController {

    @GetMapping("/{id}")
    public CompletableFuture&lt;Order&gt; getOrder(@PathVariable String id) {
        return asyncOrderService.getOrderAsync(id)
            .exceptionally(ex -&gt; {
                // More error handling...
                throw new CompletionException(ex);
            });
    }
}
</code></pre>
<p><strong>Potential Problems:</strong></p>
<ul>
<li>Wrapped exceptions in <code>CompletionException</code></li>
<li>Error handling scattered across <code>.handle()</code> and <code>.exceptionally()</code></li>
<li>Type safety lost</li>
</ul>
<h3 id="after-eithert-for-async--typed-errors"><a class="header" href="#after-eithert-for-async--typed-errors">After: EitherT for Async + Typed Errors</a></h3>
<pre><code class="language-java">@Service
public class AsyncOrderService {

    public EitherT&lt;CompletableFutureKind.Witness, OrderError, Order&gt;
    processOrderAsync(OrderRequest request) {

        return asyncUserService.findByIdAsync(request.userId())
            .flatMap(user -&gt; asyncInventoryService.checkStockAsync(request.items()))
            .flatMap(stock -&gt; {
                if (!stock.isAvailable()) {
                    return EitherT.leftT(
                        CompletableFutureKindHelper.FUTURE,
                        new OutOfStockError(stock.unavailableItems())
                    );
                }
                return EitherT.rightT(CompletableFutureKindHelper.FUTURE, stock);
            })
            .flatMap(stock -&gt; asyncPaymentService.processPaymentAsync(request.payment()))
            .map(payment -&gt; createOrder(request, payment));

        // Clean, composable, type-safe
        // Short-circuits on first error
    }
}

@RestController
public class OrderController {

    @GetMapping("/{id}/async")
    public EitherT&lt;CompletableFutureKind.Witness, OrderError, Order&gt;
    getOrder(@PathVariable String id) {

        return asyncOrderService.getOrderAsync(id);
        // Framework handles async → sync HTTP response conversion automatically
    }
}
</code></pre>
<p><strong>Improvements:</strong></p>
<ul>
<li>✅ Type-safe error handling in async context</li>
<li>✅ Clean composition with <code>flatMap</code></li>
<li>✅ Automatic short-circuiting on errors</li>
<li>✅ Framework handles async processing</li>
</ul>
<h3 id="migration-steps-2"><a class="header" href="#migration-steps-2">Migration Steps</a></h3>
<p><strong>Step 1:</strong> Convert async methods to return <code>EitherT</code></p>
<pre><code class="language-java">public EitherT&lt;CompletableFutureKind.Witness, DomainError, User&gt;
findByIdAsync(String id) {

    CompletableFuture&lt;Either&lt;DomainError, User&gt;&gt; future =
        CompletableFuture.supplyAsync(() -&gt; {
            return repository.findById(id)
                .map(Either::&lt;DomainError, User&gt;right)
                .orElseGet(() -&gt; Either.left(new UserNotFoundError(id)));
        });

    return EitherT.fromKind(CompletableFutureKindHelper.FUTURE.widen(future));
}
</code></pre>
<p><strong>Step 2:</strong> Compose operations with <code>flatMap</code></p>
<pre><code class="language-java">public EitherT&lt;CompletableFutureKind.Witness, OrderError, Order&gt;
processOrderAsync(OrderRequest request) {

    return asyncUserService.findByIdAsync(request.userId())
        .flatMap(user -&gt; asyncInventoryService.checkStockAsync(request.items()))
        .flatMap(stock -&gt; asyncPaymentService.processPaymentAsync(request.payment()))
        .map(payment -&gt; createOrder(request, payment));
}
</code></pre>
<p><strong>Step 3:</strong> Return <code>EitherT</code> from controller</p>
<pre><code class="language-java">@GetMapping("/{id}/async")
public EitherT&lt;CompletableFutureKind.Witness, OrderError, Order&gt;
getOrder(@PathVariable String id) {
    return asyncOrderService.getOrderAsync(id);
}
</code></pre>
<hr />
<h2 id="pattern-5-chained-operations"><a class="header" href="#pattern-5-chained-operations">Pattern 5: Chained Operations</a></h2>
<h3 id="before-nested-try-catch"><a class="header" href="#before-nested-try-catch">Before: Nested Try-Catch</a></h3>
<pre><code class="language-java">@GetMapping("/{userId}/orders/{orderId}/items/{itemId}")
public OrderItem getOrderItem(
        @PathVariable String userId,
        @PathVariable String orderId,
        @PathVariable String itemId) {

    try {
        User user = userService.findById(userId);

        try {
            Order order = orderService.findById(orderId);

            try {
                orderService.verifyOwnership(order, userId);

                try {
                    return orderService.findItem(order, itemId);
                } catch (ItemNotFoundException ex) {
                    throw new ResponseStatusException(HttpStatus.NOT_FOUND, "Item not found");
                }
            } catch (UnauthorizedException ex) {
                throw new ResponseStatusException(HttpStatus.FORBIDDEN, "Not your order");
            }
        } catch (OrderNotFoundException ex) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND, "Order not found");
        }
    } catch (UserNotFoundException ex) {
        throw new ResponseStatusException(HttpStatus.NOT_FOUND, "User not found");
    }
}
</code></pre>
<h3 id="after-flatmap-composition"><a class="header" href="#after-flatmap-composition">After: flatMap Composition</a></h3>
<pre><code class="language-java">@GetMapping("/{userId}/orders/{orderId}/items/{itemId}")
public Either&lt;DomainError, OrderItem&gt; getOrderItem(
        @PathVariable String userId,
        @PathVariable String orderId,
        @PathVariable String itemId) {

    return userService.findById(userId)
        .flatMap(user -&gt; orderService.findById(orderId))
        .flatMap(order -&gt; orderService.verifyOwnership(order, userId).map(_ -&gt; order))
        .flatMap(order -&gt; orderService.findItem(order, itemId));

    // Clean, linear, composable
    // Short-circuits on first error
}
</code></pre>
<p><strong>Major Improvement:</strong> Nested try-catch pyramid eliminated, replaced with clean functional composition.</p>
<hr />
<h2 id="pattern-6-maintaining-backwards-compatibility"><a class="header" href="#pattern-6-maintaining-backwards-compatibility">Pattern 6: Maintaining Backwards Compatibility</a></h2>
<p>During migration, you may need to support both old and new clients. Here are strategies:</p>
<h3 id="strategy-1-dual-endpoints"><a class="header" href="#strategy-1-dual-endpoints">Strategy 1: Dual Endpoints</a></h3>
<p>Expose both old and new versions:</p>
<pre><code class="language-java">@RestController
@RequestMapping("/api/users")
public class UserController {

    // Old endpoint (deprecated)
    @GetMapping("/{id}")
    @Deprecated
    public User getUserLegacy(@PathVariable String id) {
        Either&lt;DomainError, User&gt; result = userService.findById(id);

        return result.fold(
            error -&gt; { throw new UserNotFoundException(id); },  // Convert back to exception
            user -&gt; user
        );
    }

    // New endpoint (functional)
    @GetMapping("/v2/{id}")
    public Either&lt;DomainError, User&gt; getUser(@PathVariable String id) {
        return userService.findById(id);
    }
}
</code></pre>
<h3 id="strategy-2-content-negotiation"><a class="header" href="#strategy-2-content-negotiation">Strategy 2: Content Negotiation</a></h3>
<p>Use different response format based on <code>Accept</code> header:</p>
<pre><code class="language-java">@GetMapping("/{id}")
public ResponseEntity&lt;?&gt; getUser(@PathVariable String id,
                                  @RequestHeader("Accept") String accept) {

    Either&lt;DomainError, User&gt; result = userService.findById(id);

    if (accept.contains("application/vnd.myapp.v2+json")) {
        // New clients get Either JSON
        return ResponseEntity.ok(result);
    } else {
        // Old clients get traditional format
        return result.fold(
            error -&gt; ResponseEntity.status(404).build(),
            user -&gt; ResponseEntity.ok(user)
        );
    }
}
</code></pre>
<h3 id="strategy-3-convert-either-to-exception-temporarily"><a class="header" href="#strategy-3-convert-either-to-exception-temporarily">Strategy 3: Convert Either to Exception Temporarily</a></h3>
<p>If you must maintain existing exception-based behaviour:</p>
<pre><code class="language-java">@Service
public class UserService {

    // New internal method
    public Either&lt;DomainError, User&gt; findById(String id) {
        return repository.findById(id)
            .map(Either::&lt;DomainError, User&gt;right)
            .orElseGet(() -&gt; Either.left(new UserNotFoundError(id)));
    }

    // Old public method for legacy callers
    @Deprecated
    public User findById_LEGACY(String id) throws UserNotFoundException {
        return findById(id).fold(
            error -&gt; {
                throw new UserNotFoundException(id);  // Convert back to exception
            },
            user -&gt; user
        );
    }
}
</code></pre>
<hr />
<h2 id="potential-pitfalls-and-remedies"><a class="header" href="#potential-pitfalls-and-remedies">Potential Pitfalls and Remedies</a></h2>
<h3 id="pitfall-1-forgetting-to-handle-both-cases"><a class="header" href="#pitfall-1-forgetting-to-handle-both-cases">Pitfall 1: Forgetting to Handle Both Cases</a></h3>
<pre><code class="language-java">// ❌ BAD: Only handles Right case
@GetMapping("/{id}/email")
public String getUserEmail(@PathVariable String id) {
    return userService.findById(id)
        .map(User::email)
        .getRight();  // Throws NoSuchElementException if Left!
}

// ✅ GOOD: Return Either, let framework handle it
@GetMapping("/{id}/email")
public Either&lt;DomainError, String&gt; getUserEmail(@PathVariable String id) {
    return userService.findById(id)
        .map(User::email);
}
</code></pre>
<h3 id="pitfall-2-mixing-exceptions-and-either"><a class="header" href="#pitfall-2-mixing-exceptions-and-either">Pitfall 2: Mixing Exceptions and Either</a></h3>
<pre><code class="language-java">// ❌ BAD: Throwing exception inside Either
public Either&lt;DomainError, User&gt; findById(String id) {
    if (id == null) {
        throw new IllegalArgumentException("ID cannot be null");  // Don't do this!
    }
    return repository.findById(id)
        .map(Either::&lt;DomainError, User&gt;right)
        .orElseGet(() -&gt; Either.left(new UserNotFoundError(id)));
}

// ✅ GOOD: Return Left for all errors
public Either&lt;DomainError, User&gt; findById(String id) {
    if (id == null) {
        return Either.left(new ValidationError("id", "ID cannot be null"));
    }
    return repository.findById(id)
        .map(Either::&lt;DomainError, User&gt;right)
        .orElseGet(() -&gt; Either.left(new UserNotFoundError(id)));
}
</code></pre>
<h3 id="pitfall-3-not-using-validated-for-multiple-errors"><a class="header" href="#pitfall-3-not-using-validated-for-multiple-errors">Pitfall 3: Not Using Validated for Multiple Errors</a></h3>
<pre><code class="language-java">// ❌ BAD: Using Either for validation (only returns first error)
public Either&lt;ValidationError, User&gt; validateUser(UserRequest request) {
    return validateEmail(request.email())
        .flatMap(email -&gt; validateName(request.name()))
        .flatMap(name -&gt; validateAge(request.age()))
        .map(age -&gt; createUser(...));
    // Stops at first error!
}

// ✅ GOOD: Use Validated to accumulate all errors
public Validated&lt;List&lt;ValidationError&gt;, User&gt; validateUser(UserRequest request) {
    return Validated.validateAll(
        validateEmail(request.email()),
        validateName(request.name()),
        validateAge(request.age())
    ).map(tuple -&gt; createUser(...));
    // Returns ALL errors!
}
</code></pre>
<hr />
<h2 id="checklist"><a class="header" href="#checklist">Checklist</a></h2>
<p>When migrating an endpoint:</p>
<ul>
<li><input disabled="" type="checkbox"/>
Define domain error types as sealed interface</li>
<li><input disabled="" type="checkbox"/>
Convert service methods to return Either/Validated/EitherT</li>
<li><input disabled="" type="checkbox"/>
Update controller methods to return functional types</li>
<li><input disabled="" type="checkbox"/>
Remove corresponding <code>@ExceptionHandler</code> methods</li>
<li><input disabled="" type="checkbox"/>
Update unit tests (no more exception mocking!)</li>
<li><input disabled="" type="checkbox"/>
Update integration tests to verify HTTP responses</li>
<li><input disabled="" type="checkbox"/>
Document the new error types in API docs</li>
<li><input disabled="" type="checkbox"/>
Consider backwards compatibility strategy if needed</li>
<li><input disabled="" type="checkbox"/>
Monitor error rates with Spring Boot Actuator (optional)</li>
</ul>
<hr />
<h2 id="testing-1"><a class="header" href="#testing-1">Testing</a></h2>
<h3 id="before-testing-exception-throwing-code"><a class="header" href="#before-testing-exception-throwing-code">Before: Testing Exception-Throwing Code</a></h3>
<pre><code class="language-java">@Test
void shouldThrowWhenUserNotFound() {
    assertThrows(UserNotFoundException.class, () -&gt; {
        userService.findById("999");
    });
}
</code></pre>
<h3 id="after-testing-either"><a class="header" href="#after-testing-either">After: Testing Either</a></h3>
<pre><code class="language-java">@Test
void shouldReturnLeftWhenUserNotFound() {
    Either&lt;DomainError, User&gt; result = userService.findById("999");

    assertThat(result.isLeft()).isTrue();
    assertThat(result.getLeft()).isInstanceOf(UserNotFoundError.class);
}
</code></pre>
<p><strong>Much cleaner:</strong> No need to set up exception expectations or catch blocks.</p>
<hr />
<h2 id="performance-considerations-9"><a class="header" href="#performance-considerations-9">Performance Considerations</a></h2>
<p>Functional error handling is typically <strong>as fast or faster</strong> than exception-throwing:</p>
<p><strong>Exception Throwing:</strong></p>
<ul>
<li>Stack trace generation: ~1-10μs</li>
<li>Exception propagation: variable overhead</li>
<li>Expensive for expected errors</li>
</ul>
<p><strong>Either/Validated:</strong></p>
<ul>
<li>Object allocation: ~10-50ns</li>
<li>No stack traces</li>
<li>Predictable performance</li>
</ul>
<hr />
<h2 id="summing-it-all-up"><a class="header" href="#summing-it-all-up">Summing it all up</a></h2>
<p>When moving to a functional error handling approach:</p>
<ul>
<li>✅ <strong>Start small</strong> - New endpoints or high-value migrations first</li>
<li>✅ <strong>Incremental approach</strong> - No need to migrate everything at once</li>
<li>✅ <strong>Backwards compatible</strong> - Support legacy and functional endpoints simultaneously</li>
<li>✅ <strong>Better type safety</strong> - Errors explicit in signatures</li>
<li>✅ <strong>Easier testing</strong> - No exception mocking required</li>
<li>✅ <strong>Cleaner code</strong> - Functional composition replaces nested try-catch</li>
<li>✅ <strong>Better UX</strong> - Validated accumulates all errors</li>
</ul>
<p>The migration is straightforward and the benefits are immediate. Start with one endpoint and experience the difference!</p>
<hr />
<div id="admonition-see-also" class="admonition admonish-tip" role="note" aria-labelledby="admonition-see-also-title">
<div class="admonition-title">
<div id="admonition-see-also-title">
<p>See Also</p>
</div>
<a class="admonition-anchor-link" href="spring/migrating_to_functional_errors.html#admonition-see-also"></a>
</div>
<div>
<ul>
<li><a href="spring/./spring_boot_integration.html">Spring Boot Integration</a> - Complete integration guide</li>
<li><a href="spring/../monads/either_monad.html">Either Monad</a> - Either usage patterns</li>
<li><a href="spring/../monads/validated_monad.html">Validated Monad</a> - Validation patterns</li>
<li><a href="spring/../transformers/eithert_transformer.html">EitherT Transformer</a> - Async composition</li>
</ul>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="spring/spring_boot_integration.html">Spring Boot Integration</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="foundations-higher-kinded-types"><a class="header" href="#foundations-higher-kinded-types">Foundations: Higher-Kinded Types</a></h1>
<blockquote>
<p><em>"If they can get you asking the wrong questions, they don't have to worry about answers."</em></p>
<p>– Thomas Pynchon, <em>Gravity's Rainbow</em></p>
</blockquote>
<hr />
<div id="admonition-start-with-effect-paths" class="admonition admonish-tip" role="note" aria-labelledby="admonition-start-with-effect-paths-title">
<div class="admonition-title">
<div id="admonition-start-with-effect-paths-title">
<p>Start with Effect Paths</p>
</div>
<a class="admonition-anchor-link" href="hkts/ch_intro.html#admonition-start-with-effect-paths"></a>
</div>
<div>
<p>This chapter documents the machinery that powers Higher-Kinded-J. <strong>Most users can start with the <a href="hkts/../effect/ch_intro.html">Effect Path API</a> directly</strong> without understanding HKTs in detail. The Effect Path API provides a clean, fluent interface that hides this complexity.</p>
<p>Read this chapter when you want to:</p>
<ul>
<li>Understand how the library works internally</li>
<li>Write generic code that operates across multiple effect types</li>
<li>Extend the library with your own types</li>
</ul>
</div>
</div>
<hr />
<p>The right question is not "how do I map over this List?" or "how do I map over this Optional?" The right question is "how do I map over <em>any</em> container?"</p>
<p>Java's type system, for all its virtues, cannot express this directly. You can write a method that takes a <code>List&lt;A&gt;</code> and returns a <code>List&lt;B&gt;</code>. You can write another that takes an <code>Optional&lt;A&gt;</code> and returns an <code>Optional&lt;B&gt;</code>. But you cannot write a single method parameterised over the container type itself: a method that works with <code>F&lt;A&gt;</code> where <code>F</code> might be <code>List</code>, <code>Optional</code>, <code>CompletableFuture</code>, or any other type constructor.</p>
<p>Higher-Kinded-J provides a workaround. Through a technique called defunctionalisation, it simulates higher-kinded types in Java, allowing you to write generic code that operates across different container types. The mechanism involves phantom "witness" types and a <code>Kind&lt;F, A&gt;</code> interface that represents "some container F holding a value of type A."</p>
<p>This is admittedly more verbose than languages with native support. But the alternative (duplicating logic across every container type) scales poorly. Once you've written the same map-filter-flatMap chain for the fifth type, the appeal of abstraction becomes clear.</p>
<hr />
<h2 id="the-core-insight"><a class="header" href="#the-core-insight">The Core Insight</a></h2>
<p>Think of it as abstraction over <em>structure</em>, not just <em>values</em>:</p>
<pre><code>    ┌─────────────────────────────────────────────────────────────┐
    │  WITHOUT HKTs                                               │
    │                                                             │
    │    mapList(List&lt;A&gt;, fn)      → List&lt;B&gt;                     │
    │    mapOptional(Optional&lt;A&gt;, fn) → Optional&lt;B&gt;              │
    │    mapFuture(Future&lt;A&gt;, fn)  → Future&lt;B&gt;                   │
    │                                                             │
    │    Three methods. Same logic. Different types.              │
    └─────────────────────────────────────────────────────────────┘

    ┌─────────────────────────────────────────────────────────────┐
    │  WITH HKTs                                                  │
    │                                                             │
    │    map(Functor&lt;F&gt;, Kind&lt;F, A&gt;, fn) → Kind&lt;F, B&gt;            │
    │                                                             │
    │    One method. Works for List, Optional, Future, and more. │
    └─────────────────────────────────────────────────────────────┘
</code></pre>
<p>The <code>Functor&lt;F&gt;</code> parameter carries the implementation; <code>Kind&lt;F, A&gt;</code> carries the value.</p>
<hr />
<h2 id="what-youll-learn-9"><a class="header" href="#what-youll-learn-9">What You'll Learn</a></h2>
<div id="admonition-in-this-chapter" class="admonition admonish-info" role="note" aria-labelledby="admonition-in-this-chapter-title">
<div class="admonition-title">
<div id="admonition-in-this-chapter-title">
<p>In This Chapter</p>
</div>
<a class="admonition-anchor-link" href="hkts/ch_intro.html#admonition-in-this-chapter"></a>
</div>
<div>
<ul>
<li><strong>The Analogy</strong> – Just as higher-order functions take functions as arguments, higher-kinded types take types as arguments. Understanding this parallel unlocks the entire abstraction.</li>
<li><strong>Core Concepts</strong> – You'll learn how witness types and the <code>Kind&lt;F, A&gt;</code> interface work together to simulate HKTs in Java, and how the widen/narrow pattern bridges between concrete types and their Kind representations.</li>
<li><strong>Usage Guide</strong> – Practical patterns for working with <code>Kind</code> in real code, including how to write generic methods that work across multiple container types.</li>
<li><strong>Basic Examples</strong> – Step-by-step examples showing HKT simulation in action, from simple mappings to complex compositions.</li>
<li><strong>Quick Reference</strong> – A condensed reference of essential patterns you'll use repeatedly when working with the library.</li>
<li><strong>Extending</strong> – How to add HKT support to your own types, enabling them to participate in the type class hierarchy.</li>
</ul>
</div>
</div>
<hr />
<h2 id="chapter-contents-9"><a class="header" href="#chapter-contents-9">Chapter Contents</a></h2>
<ol>
<li><a href="hkts/hkt_introduction.html">HKT Introduction</a> - The analogy: higher-kinded types are to types what higher-order functions are to functions</li>
<li><a href="hkts/core-concepts.html">Concepts</a> - Witness types, Kind interfaces, and the widen/narrow pattern</li>
<li><a href="hkts/usage-guide.html">Usage Guide</a> - Working with Kind in practice</li>
<li><a href="hkts/hkt_basic_examples.html">Basic HKT Examples</a> - Seeing HKT simulation in action</li>
<li><a href="hkts/quick_reference.html">Quick Reference</a> - Essential patterns at a glance</li>
<li><a href="hkts/extending-simulation.html">Extending</a> - Adding HKT support to your own types</li>
</ol>
<hr />
<p><strong>Next:</strong> <a href="hkts/hkt_introduction.html">HKT Introduction</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="introduction-to-higher-kinded-types"><a class="header" href="#introduction-to-higher-kinded-types">Introduction to Higher-Kinded Types</a></h1>
<p><img src="hkts/../images/rubiks1932.jpg" alt="rubiks1932.jpg" /></p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="hkts/hkt_introduction.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>The analogy between higher-order functions and higher-kinded types</li>
<li>Why Java's type system limitations necessitate HKT simulation</li>
<li>How abstractions over "container" types enable more reusable code</li>
<li>The difference between first-order types, generic types, and higher-kinded types</li>
<li>Real-world benefits: less boilerplate, more abstraction, better composition</li>
</ul>
</div>
</div>
<div id="admonition-hands-on-learning" class="admonition admonish-tip" role="note" aria-labelledby="admonition-hands-on-learning-title">
<div class="admonition-title">
<div id="admonition-hands-on-learning-title">
<p>Hands-On Learning</p>
</div>
<a class="admonition-anchor-link" href="hkts/hkt_introduction.html#admonition-hands-on-learning"></a>
</div>
<div>
<p>Want to learn by doing? Try our <strong><a href="hkts/../tutorials/coretypes_track.html">Core Types Tutorial Track</a></strong> with 7 interactive exercises that take you from <code>Kind&lt;F, A&gt;</code> basics to production workflows in ~60 minutes.</p>
</div>
</div>
<p>We can think about Higher-Kinded Types (HKT) by making an analogy with Higher-Order Functions (HOF).</p>
<p><em>higher-kinded types are to types what higher-order functions are to functions.</em></p>
<p>They both represent a powerful form of abstraction, just at different levels.</p>
<h3 id="the-meaning-of-regular-and-higher-order"><a class="header" href="#the-meaning-of-regular-and-higher-order">The Meaning of "Regular" and "Higher-Order"</a></h3>
<p><strong>Functions</strong> model Behaviour</p>
<ul>
<li><strong>First-Order (Regular) Function:</strong> This kind of function operates on simple values. It takes a value(s) like a <code>int</code> and returns a value.</li>
</ul>
<pre><code class="language-java">// Take a value and return a value
int square(int num) {
    return num * num;
}    
</code></pre>
<ul>
<li><strong>Higher-Order Function:</strong> This kind of function operates on <em>other functions</em>.  It can take functions as arguments and or return a new function as the result.  It abstracts over the <strong>behaviour</strong>.</li>
</ul>
<pre><code class="language-java">// Takes a Set of type A and a function fn that maps types of A to B,
//  returns a new Set of type B
&lt;A, B&gt; Set&lt;B&gt; mapper(Set&lt;A&gt; list, Function&lt;A, B&gt; fn) {
    // ... applies fn to each element of the set
}
</code></pre>
<p><code>mapper</code> is a higher-order function because it takes the function <code>fn</code> as an argument.</p>
<p><strong>Types</strong> model Structure</p>
<ul>
<li><strong>First-Order (Regular) Type:</strong> A simple, concrete type like <code>int</code>, or <code>Set&lt;Double&gt;</code> represents a specific kind of data.</li>
<li><strong>Higher-Kinded Type (HKT):</strong> This is a "type that operates on types." More accurately, it's a generic type constructor that can itself be treated as a type parameter. It abstracts over structure or computational context.</li>
</ul>
<p>Let us consider <code>Set&lt;T&gt;</code>. <code>Set</code> itself without the <code>T</code>, is a type constructor.  Think of it as a "function" for types: Supply it a type (like <code>Integer</code>), and it produces a new concrete type <code>Set&lt;Integer&gt;</code>.</p>
<p>A higher-kinded type allows us to write code that is generic over <code>Set</code> itself, or <code>List</code>, or <code>CompletableFuture</code>.</p>
<h3 id="generic-code-in-practice"><a class="header" href="#generic-code-in-practice">Generic code in Practice</a></h3>
<p><strong>Functions</strong></p>
<p><em>Without Higher-Order Functions:</em></p>
<p>To apply different operations to a list, we would need to write separate loops for each one.</p>
<pre><code class="language-java">List&lt;String&gt; results = new ArrayList&lt;&gt;();
for (int i : numbers) {
    results.add(intToString(i)); // Behavior is hardcoded
}
</code></pre>
<p><em>With Higher-Order Functions:</em></p>
<p>We abstract the behaviour into a function and pass it in. This is much more flexible.</p>
<pre><code class="language-java">
// A map for List
&lt;A, B&gt; List&lt;B&gt; mapList(List&lt;A&gt; list, Function&lt;A, B&gt; f);

// A map for Optional
&lt;A, B&gt; Optional&lt;B&gt; mapOptional(Optional&lt;A&gt; opt, Function&lt;A, B&gt; f);

// A map for CompletableFuture
&lt;A, B&gt; CompletableFuture&lt;B&gt; mapFuture(CompletableFuture&lt;A&gt; future, Function&lt;A, B&gt; f);

</code></pre>
<p>Notice the repeated pattern: the core logic is the same, but the "container" is different.</p>
<p><em>With Higher-Kinded Types:</em></p>
<p>With Higher-Kinded-J we can abstract over the container <code>F</code> itself. This allows us to write one single, generic map function that works for any container structure or computational context that can be mapped over (i.e., any <code>Functor</code>). This is precisely what the <code>GenericExample.java</code> demonstrates.</p>
<pre><code class="language-java">// F is a "type variable" that stands for List, Optional, etc.
// This is a function generic over the container F.
public static &lt;F, A, B&gt; Kind&lt;F, B&gt; map(
    Functor&lt;F&gt; functorInstance, // The implementation for F
    Kind&lt;F, A&gt; kindBox,         // The container with a value
    Function&lt;A, B&gt; f) {         // The behaviour to apply
    return functorInstance.map(f, kindBox);
}

</code></pre>
<p>Here, <code>Kind&lt;F, A&gt;</code> is the higher-kinded type that represents "some container F holding a value of type A."</p>
<p>Both concepts allow you to write more generic and reusable code by parametrising things that are normally fixed. <strong>Higher-order functions parametrise behaviour, while higher-kinded types parametrise the structure that contains the behaviour.</strong></p>
<p>We will discuss the <code>GenericExample.java</code> in detail later, but you can take a peek at the code here</p>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/GenericExample.java">GenericExample.java</a></li>
</ul>
<h2 id="the-core-idea-abstraction-over-containers"><a class="header" href="#the-core-idea-abstraction-over-containers">The Core Idea: Abstraction over Containers</a></h2>
<p>In short: a higher-kinded type is a way to be generic over the container type itself.
Think about the different "container" types you use every day in Java: <code>List&lt;T&gt;</code>, <code>Optional&lt;T&gt;</code>, <code>Future&lt;T&gt;</code>, <code>Set&lt;T&gt;</code>. All of these are generic containers that hold a value of type <code>T</code>.
The problem is that you can't write a single method in Java that accepts any of these containers and performs an action, because <code>List</code>, <code>Optional</code>, and <code>Future</code> don't share a useful common interface. A higher-kinded type solves this by letting you write code that works with <code>F&lt;T&gt;</code>, where <code>F</code> itself is a variable representing the container type (<code>List</code>, <code>Optional</code>, etc.).</p>
<h2 id="building-up-from-java-generics"><a class="header" href="#building-up-from-java-generics">Building Up from Java Generics</a></h2>
<h3 id="level-1-concrete-types-like-values"><a class="header" href="#level-1-concrete-types-like-values">Level 1: Concrete Types (like values)</a></h3>
<p>A normal, complete type is like a value. It's a "thing".</p>
<pre><code class="language-java">String myString;          // A concrete type
List&lt;Integer&gt; myIntList;  // Also a concrete type (a List of Integers)
</code></pre>
<h3 id="level-2-generic-types-like-functions"><a class="header" href="#level-2-generic-types-like-functions">Level 2: Generic Types (like functions)</a></h3>
<p>A generic type definition like <code>List&lt;T&gt;</code> is not a complete type. It's a type constructor. It's like a function at the type level: you give it a type (e.g., <code>String</code>), and it produces a concrete type (<code>List&lt;String&gt;</code>).</p>
<pre><code class="language-java">// List&lt;T&gt; is a "type function" that takes one parameter, T.
// We can call it a type of kind: * -&gt; *
// (It takes one concrete type to produce one concrete type)
</code></pre>
<p>You can't declare a variable of type <code>List</code>. You must provide the type parameter <code>T</code>.</p>
<h3 id="level-3-higher-kinded-types-like-functions-that-take-other-functions"><a class="header" href="#level-3-higher-kinded-types-like-functions-that-take-other-functions">Level 3: Higher-Kinded Types (like functions that take other functions)</a></h3>
<p>This is the part Java doesn't support directly. A higher-kinded type is a construct that is generic over the type constructor itself.
Imagine you want to write a single map function that works on any container. You want to write code that says: <em>"Given any container F holding type A, and a function to turn an A into a B, I will give you back a container F holding type B."</em>
In imaginary Java syntax, it would look like this:</p>
<pre><code class="language-java">// THIS IS NOT REAL JAVA SYNTAX
public &lt;F&lt;?&gt;, A, B&gt; F&lt;B&gt; map(F&lt;A&gt; container, Function&lt;A, B&gt; func);
</code></pre>
<p>Here, <code>F </code>is the higher-kinded type parameter. It's a variable that can stand for <code>List</code>, <code>Optional</code>, <code>Future</code>, or any other <code>* -&gt; *</code> type constructor.</p>
<h2 id="a-practical-analogy-the-shipping-company"><a class="header" href="#a-practical-analogy-the-shipping-company">A Practical Analogy: The Shipping Company</a></h2>
<p><img src="hkts/../images/containers.png" alt="containers.png" /></p>
<p>Think of it like working at a shipping company.
A concrete type <code>List&lt;String&gt;</code> is a "Cardboard Box full of Apples".
A generic type <code>List&lt;T&gt;</code> is a blueprint for a "Cardboard Box" that can hold anything (<code>T</code>).
Now, you want to write a single set of instructions (a function) for your robotic arm called addInsuranceLabel. You want these instructions to work on any kind of container.
Without HKTs (The Java Way): You have to write separate instructions for each container type.</p>
<pre><code class="language-java">addInsuranceToCardboardBox(CardboardBox&lt;T&gt; box, ...)
addInsuranceToPlasticCrate(PlasticCrate&lt;T&gt; crate, ...)
addInsuranceToMetalCase(MetalCase&lt;T&gt; case, ...)
</code></pre>
<p>With HKTs (The Abstract Way): You write one generic set of instructions.</p>
<pre><code class="language-java">addInsuranceToContainer(Container&lt;T&gt; container, ...)
</code></pre>
<p>A higher-kinded type is the concept of being able to write code that refers to <code>Container&lt;T&gt;</code>: an abstraction over the container or "context" that holds the data.</p>
<p>Higher-Kinded-J <strong>simulates HKTs in Java</strong> using a technique inspired by defunctionalisation. It allows you to define and use common functional abstractions like <code>Functor</code>, <code>Applicative</code>, and <code>Monad</code> (including <code>MonadError</code>) in a way that works <em>generically</em> across different simulated type constructors.</p>
<p><strong>Why bother?</strong> Higher-Kinded-J unlocks several benefits:</p>
<ul>
<li><strong>Write Abstract Code:</strong> Define functions and logic that operate polymorphically over different computational contexts (e.g., handle optionality, asynchronous operations, error handling, side effects, or collections using the <em>same</em> core logic).</li>
<li><strong>Leverage Functional Patterns:</strong> Consistently apply powerful patterns like <code>map</code>, <code>flatMap</code>, <code>ap</code>, <code>sequence</code>, <code>traverse</code>, and monadic error handling (<code>raiseError</code>, <code>handleErrorWith</code>) across diverse data types.</li>
<li><strong>Build Composable Systems:</strong> Create complex workflows and abstractions by composing smaller, generic pieces, as demonstrated in the included <a href="hkts/order-walkthrough.html">Order Processing Example</a>.</li>
<li><strong>Understand HKT Concepts:</strong> Provides a practical, hands-on way to understand HKTs and type classes even within Java's limitations.</li>
<li><strong>Lay the Foundations:</strong> Building on HKTs unlocks the possibilities for advanced abstractions like <a href="hkts/../optics/optics_intro.html">Optics</a>, which provide composable ways to access and modify nested data structures.</li>
</ul>
<p>While Higher-Kinded-J introduces some boilerplate compared to languages with native HKT support, it offers a valuable way to explore these powerful functional programming concepts in Java.</p>
<hr />
<p><strong>Previous:</strong> <a href="hkts/ch_intro.html">Introduction</a>
<strong>Next:</strong> <a href="hkts/core-concepts.html">Concepts</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="core-concepts-of-higher-kinded-j"><a class="header" href="#core-concepts-of-higher-kinded-j">Core Concepts of Higher-Kinded-J</a></h1>
<p><img src="hkts/../images/concepts.png" alt="concepts.png" /></p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="hkts/core-concepts.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How the Kind&lt;F, A&gt; interface simulates higher-kinded types in Java</li>
<li>The role of witness types in representing type constructors</li>
<li>Understanding defunctionalisation and how it enables HKT simulation</li>
<li>The difference between internal library types and external Java types</li>
<li>How type classes provide generic operations across different container types</li>
</ul>
</div>
</div>
<div id="admonition-hands-on-practice" class="admonition admonish-note" role="note" aria-labelledby="admonition-hands-on-practice-title">
<div class="admonition-title">
<div id="admonition-hands-on-practice-title">
<p>Hands On Practice</p>
</div>
<a class="admonition-anchor-link" href="hkts/core-concepts.html#admonition-hands-on-practice"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/coretypes/Tutorial01_KindBasics.java">Tutorial01_KindBasics.java</a></p>
</div>
</div>
<p>Higher-Kinded-J employs several key components to emulate Higher-Kinded Types (HKTs) and associated functional type classes in Java. Understanding these is crucial for using and extending the library.</p>
<p><a href="hkts/hkt_basic_examples.html">Feel free to skip ahead to the examples and come back later for the theory</a></p>
<h2 id="1-the-hkt-problem-in-java"><a class="header" href="#1-the-hkt-problem-in-java">1. The HKT Problem in Java</a></h2>
<p>As we've already discussed, Java's type system lacks native support for Higher-Kinded Types. We can easily parametrise a type by another type (like <code>List&lt;String&gt;</code>), but we cannot easily parametrise a type or method by a <em>type constructor</em> itself (like <code>F&lt;_&gt;</code>). We can't write <code>void process&lt;F&lt;_&gt;&gt;(F&lt;Integer&gt; data)</code> to mean "process any container F of Integers".</p>
<div id="admonition-warning" class="admonition admonish-warning" role="note" aria-labelledby="admonition-warning-title">
<div class="admonition-title">
<div id="admonition-warning-title">
<p>Warning</p>
</div>
<a class="admonition-anchor-link" href="hkts/core-concepts.html#admonition-warning"></a>
</div>
<div>
<p>You'll often see Higher-Kinded Types represented with an underscore, such as <code>F&lt;_&gt;</code> (e.g., <code>List&lt;_&gt;</code>, <code>Optional&lt;_&gt;</code>). This notation, borrowed from languages like Scala, represents a "type constructor": a type that is waiting for a type parameter. It's important to note that this underscore is a conceptual placeholder and is not the same as Java's <code>?</code> wildcard, which is used for instantiated types. Our library provides a way to simulate this <code>F&lt;_&gt;</code> concept in Java.</p>
</div>
</div>
<h2 id="2-the-kindf-a-bridge"><a class="header" href="#2-the-kindf-a-bridge">2. The <code>Kind&lt;F, A&gt;</code> Bridge</a></h2>
<p>At the very centre of the library are the <code>Kind</code> interfaces, which make higher-kinded types possible in Java.</p>
<ul>
<li>
<p><strong><code>Kind&lt;F, A&gt;</code></strong>: This is the foundational interface that emulates a higher-kinded type. It represents a type <code>F</code> that is generic over a type <code>A</code>. For example, <code>Kind&lt;ListKind.Witness, String&gt;</code> represents a <code>List&lt;String&gt;</code>. You will see this interface used everywhere as the common currency for all our functional abstractions.</p>
</li>
<li>
<p><strong><code>Kind2&lt;F, A, B&gt;</code></strong>: This interface extends the concept to types that take two type parameters, such as <code>Function&lt;A, B&gt;</code> or <code>Either&lt;L, R&gt;</code>. For example, <code>Kind2&lt;FunctionKind.Witness, String, Integer&gt;</code> represents a <code>Function&lt;String, Integer&gt;</code>. This is essential for working with profunctors and other dual-parameter abstractions.</p>
</li>
</ul>
<p><img src="hkts/../images/puml/defunctionalisation_internal.svg" alt="defunctionalisation_internal.svg" /></p>
<ul>
<li><strong>Purpose:</strong> To simulate the application of a type constructor <code>F</code> (like <code>List</code>, <code>Optional</code>, <code>IO</code>) to a type argument <code>A</code> (like <code>String</code>, <code>Integer</code>), representing the concept of <code>F&lt;A&gt;</code>.</li>
<li><strong><code>F</code> (Witness Type):</strong> This is the crucial part of the simulation. Since <code>F&lt;_&gt;</code> isn't a real Java type parameter, we use a <em>marker type</em> (often an empty interface specific to the constructor) as a "witness" or stand-in for <code>F</code>. Examples:
<ul>
<li><code>ListKind&lt;ListKind.Witness&gt;</code> represents the <code>List</code> type constructor.</li>
<li><code>OptionalKind&lt;OptionalKind.Witness&gt;</code> represents the <code>Optional</code> type constructor.</li>
<li><code>EitherKind.Witness&lt;L&gt;</code> represents the <code>Either&lt;L, _&gt;</code> type constructor (where <code>L</code> is fixed).</li>
<li><code>IOKind&lt;IOKind.Witness&gt;</code> represents the <code>IO</code> type constructor.</li>
</ul>
</li>
<li><strong><code>A</code> (Type Argument):</strong> The concrete type contained within or parametrised by the constructor (e.g., <code>Integer</code> in <code>List&lt;Integer&gt;</code>).</li>
<li><strong>How it Works:</strong> The library provides a seamless bridge between a standard java type, like a <code>java.util.List&lt;Integer&gt;</code>and its <code>Kind</code> representation <code>Kind&lt;ListKind.Witness, Integer&gt;</code>. Instead of requiring you to manually wrap objects, this conversion is handled by static helper methods, typically <code>widen</code> and <code>narrow</code>.
<ul>
<li>To treat a <code>List&lt;Integer&gt;</code> as a <code>Kind</code>, you use a helper function like <code>LIST.widen()</code>.</li>
<li>This <code>Kind</code> object can then be passed to generic functions (such as <code>map</code> or <code>flatMap</code> from a <code>Functor</code> or <code>Monad</code> instance) that expect <code>Kind&lt;F, A&gt;</code>.</li>
</ul>
</li>
<li><strong>Reference:</strong> <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-api/src/main/java/org/higherkindedj/hkt/Kind.java"><code>Kind.java</code></a></li>
</ul>
<div id="admonition-tip" class="admonition admonish-tip" role="note" aria-labelledby="admonition-tip-title">
<div class="admonition-title">
<div id="admonition-tip-title">
<p>Tip</p>
</div>
<a class="admonition-anchor-link" href="hkts/core-concepts.html#admonition-tip"></a>
</div>
<div>
<p>For quick definitions of HKT concepts like Kind, Witness Types, and Defunctionalisation, see the <a href="hkts/../glossary.html">Glossary</a>.</p>
</div>
</div>
<h2 id="3-type-classes-functor-applicative-monad-monaderror"><a class="header" href="#3-type-classes-functor-applicative-monad-monaderror">3. Type Classes (<code>Functor</code>, <code>Applicative</code>, <code>Monad</code>, <code>MonadError</code>)</a></h2>
<p>These are interfaces that define standard functional operations that work <em>generically</em> over any simulated type constructor <code>F</code> (represented by its witness type) for which an instance of the type class exists. They operate on <code>Kind&lt;F, A&gt;</code> objects.</p>
<p><img src="hkts/../images/puml/core_typeclasses_high_level.svg" alt="core_typeclasses_high_level.svg" /></p>
<ul>
<li><strong><code>Functor&lt;F&gt;</code>:</strong>
<ul>
<li>Defines <code>map(Function&lt;A, B&gt; f, Kind&lt;F, A&gt; fa)</code>: Applies a function <code>f: A -&gt; B</code> to the value(s) inside the context <code>F</code> without changing the context's structure, resulting in a <code>Kind&lt;F, B&gt;</code>. Think <code>List.map</code>, <code>Optional.map</code>.</li>
<li>Laws: Identity (<code>map(id) == id</code>), Composition (<code>map(g.compose(f)) == map(g).compose(map(f))</code>).</li>
<li>Reference: <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-api/src/main/java/org/higherkindedj/hkt/Functor.java"><code>Functor.java</code></a></li>
</ul>
</li>
<li><strong><code>Applicative&lt;F&gt;</code>:</strong>
<ul>
<li>Extends <code>Functor&lt;F&gt;</code>.</li>
<li>Adds <code>of(A value)</code>: Lifts a pure value <code>A</code> into the context <code>F</code>, creating a <code>Kind&lt;F, A&gt;</code>. (e.g., <code>1</code> becomes <code>Optional.of(1)</code> wrapped in <code>Kind</code>).</li>
<li>Adds <code>ap(Kind&lt;F, Function&lt;A, B&gt;&gt; ff, Kind&lt;F, A&gt; fa)</code>: Applies a function wrapped in context <code>F</code> to a value wrapped in context <code>F</code>, returning a <code>Kind&lt;F, B&gt;</code>. This enables combining multiple independent values within the context.</li>
<li>Provides default <code>mapN</code> methods (e.g., <code>map2</code>, <code>map3</code>) built upon <code>ap</code> and <code>map</code>.</li>
<li>Laws: Identity, Homomorphism, Interchange, Composition.</li>
<li>Reference: <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-api/src/main/java/org/higherkindedj/hkt/Applicative.java"><code>Applicative.java</code></a></li>
</ul>
</li>
<li><strong><code>Monad&lt;F&gt;</code>:</strong>
<ul>
<li>Extends <code>Applicative&lt;F&gt;</code>.</li>
<li>Adds <code>flatMap(Function&lt;A, Kind&lt;F, B&gt;&gt; f, Kind&lt;F, A&gt; ma)</code>: Sequences operations within the context <code>F</code>. Takes a value <code>A</code> from context <code>F</code>, applies a function <code>f</code> that returns a <em>new context</em> <code>Kind&lt;F, B&gt;</code>, and returns the result flattened into a single <code>Kind&lt;F, B&gt;</code>. Essential for chaining dependent computations (e.g., chaining <code>Optional</code> calls, sequencing <code>CompletableFuture</code>s, combining <code>IO</code> actions). Also known in functional languages as <code>bind</code> or <code>&gt;&gt;=</code>.</li>
<li>Provides default <code>flatMapN</code> methods (e.g., <code>flatMap2</code>, <code>flatMap3</code>, <code>flatMap4</code>, <code>flatMap5</code>) for combining multiple monadic values with an effectful function. These methods sequence operations where the combining function itself returns a monadic value, unlike <code>mapN</code> which uses a pure function.</li>
<li>Laws: Left Identity, Right Identity, Associativity.</li>
<li>Reference: <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-api/src/main/java/org/higherkindedj/hkt/Monad.java"><code>Monad.java</code></a></li>
</ul>
</li>
<li><strong><code>MonadError&lt;F, E&gt;</code>:</strong>
<ul>
<li>Extends <code>Monad&lt;F&gt;</code>.</li>
<li>Adds error handling capabilities for contexts <code>F</code> that have a defined error type <code>E</code>.</li>
<li>Adds <code>raiseError(E error)</code>: Lifts an error <code>E</code> into the context <code>F</code>, creating a <code>Kind&lt;F, A&gt;</code> representing the error state (e.g., <code>Either.Left</code>, <code>Try.Failure</code> or failed <code>CompletableFuture</code>).</li>
<li>Adds <code>handleErrorWith(Kind&lt;F, A&gt; ma, Function&lt;E, Kind&lt;F, A&gt;&gt; handler)</code>: Allows recovering from an error state <code>E</code> by providing a function that takes the error and returns a <em>new context</em> <code>Kind&lt;F, A&gt;</code>.</li>
<li>Provides default recovery methods like <code>handleError</code>, <code>recover</code>, <code>recoverWith</code>.</li>
<li>Reference: <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-api/src/main/java/org/higherkindedj/hkt/MonadError.java"><code>MonadError.java</code></a></li>
</ul>
</li>
</ul>
<h2 id="4-defunctionalisation-per-type-constructor"><a class="header" href="#4-defunctionalisation-per-type-constructor">4. Defunctionalisation (Per Type Constructor)</a></h2>
<p>For each Java type constructor (like <code>List</code>, <code>Optional</code>, <code>IO</code>) you want to simulate as a Higher-Kinded Type, a specific pattern involving several components is used. The exact implementation differs slightly depending on whether the type is defined <em>within</em> the Higher-Kinded-J library (e.g., <code>Id</code>, <code>Maybe</code>, <code>IO</code>, monad transformers) or if it's an <em>external type</em> (e.g., <code>java.util.List</code>, <code>java.util.Optional</code>, <code>java.util.concurrent.CompletableFuture</code>).</p>
<p><strong>Common Components:</strong></p>
<ul>
<li>
<p><strong>The <code>XxxKind</code> Interface:</strong> A specific marker interface, for example, <code>OptionalKind&lt;A&gt;</code>. This interface extends <code>Kind&lt;F, A&gt;</code>, where <code>F</code> is the witness type representing the type constructor.</p>
<ul>
<li><strong>Example:</strong> <code>public interface OptionalKind&lt;A&gt; extends Kind&lt;OptionalKind.Witness, A&gt; { /* ... Witness class ... */ }</code></li>
<li>The <code>Witness</code> (e.g., <code>OptionalKind.Witness</code>) is a static nested final class (or a separate, accessible class) within <code>OptionalKind</code>. This <code>Witness</code> type is what's used as the <code>F</code> parameter in generic type classes like <code>Monad&lt;F&gt;</code>.</li>
</ul>
</li>
<li>
<p><strong>The <code>KindHelper</code> Class (e.g., <code>OptionalKindHelper</code>):</strong> A crucial utility <code>widen</code> and <code>narrow</code> methods:</p>
<ul>
<li><code>widen(...)</code>: Converts the standard Java type (e.g., <code>Optional&lt;String&gt;</code>) into its <code>Kind&lt;F, A&gt;</code> representation.</li>
<li><code>narrow(Kind&lt;F, A&gt; kind)</code>: Converts the <code>Kind&lt;F, A&gt;</code> representation back to the underlying Java type (e.g., <code>Optional&lt;String&gt;</code>).
<ul>
<li><strong>Crucially, this method throws <code>KindUnwrapException</code> if the input <code>kind</code> is structurally invalid</strong> (e.g., <code>null</code>, the wrong <code>Kind</code> type, or (<em>for holder-based types</em>) a <code>Holder</code> containing <code>null</code> where it shouldn't). This ensures robustness.</li>
</ul>
</li>
<li>May contain other convenience factory methods.</li>
</ul>
</li>
<li>
<p><strong>Type Class Instance(s):</strong> Concrete classes implementing <code>Functor&lt;F&gt;</code>, <code>Monad&lt;F&gt;</code>, etc., for the specific witness type <code>F</code> (e.g., <code>OptionalMonad implements Monad&lt;OptionalKind.Witness&gt;</code>). These instances use the <code>KindHelper</code>'s <code>widen</code> and <code>narrow</code> methods to operate on the underlying Java types.</p>
</li>
</ul>
<p><strong>External Types:</strong></p>
<p><img src="hkts/../images/puml/defunctionalisation_external.svg" alt="defunctionalisation_external.svg" /></p>
<ul>
<li><strong>For Types Defined Within Higher-Kinded-J (e.g., <code>Id</code>, <code>IO</code>, <code>Maybe</code>, <code>Either</code>, Monad Transformers like <code>EitherT</code>):</strong>
<ul>
<li>These types are designed to directly participate in the HKT simulation.</li>
<li>The type itself (e.g., <code>Id&lt;A&gt;</code>, <code>IO&lt;A&gt;</code>, <code>Just&lt;T&gt;</code>, <code>Either.Right&lt;L,R&gt;</code>) will directly implement its corresponding <code>XxxKind</code> interface (e.g., <code>Id&lt;A&gt; implements IdKind&lt;A&gt;</code>, <code>IO&lt;A&gt; extends IOKind&lt;A&gt;</code>, <code>Just&lt;T&gt; implements MaybeKind&lt;T&gt;</code>, <code>Either.Right&lt;L,R&gt; implements EitherKind&lt;L,R&gt;</code>).</li>
<li>In this case, a separate <code>Holder</code> record is <strong>not needed</strong> for the primary <code>widen</code>/<code>narrow</code> mechanism in the <code>KindHelper</code>.</li>
<li><code>XxxKindHelper.widen(IO&lt;A&gt; io)</code> would effectively be a type cast (after null checks) to <code>Kind&lt;IOKind.Witness, A&gt;</code> because <code>IO&lt;A&gt;</code> <em>is already</em> an <code>IOKind&lt;A&gt;</code>.</li>
<li><code>XxxKindHelper.narrow(Kind&lt;IOKind.Witness, A&gt; kind)</code> would check <code>instanceof IO</code> and perform a cast.</li>
<li>This approach provides <strong>zero runtime overhead</strong> for widen/narrow operations (no wrapper object allocation) and improved debugging experience (actual types visible in stack traces).</li>
</ul>
</li>
</ul>
<p>This distinction is important for understanding how <code>wrap</code> and <code>unwrap</code> function for different types. However, from the perspective of a user of a type class instance (like <code>OptionalMonad</code>), the interaction remains consistent: you provide a <code>Kind</code> object, and the type class instance handles the necessary operations.</p>
<h2 id="5-the-unit-type"><a class="header" href="#5-the-unit-type">5. The <code>Unit</code> Type</a></h2>
<p>In functional programming, it's common to have computations or functions that perform an action (often a side effect) but do not produce a specific, meaningful result value. In Java, methods that don't return a value use the <code>void</code> keyword. However, <code>void</code> is not a first-class type and cannot be used as a generic type parameter <code>A</code> in <code>Kind&lt;F, A&gt;</code>.</p>
<p>Higher-Kinded-J provides the <code>org.higherkindedj.hkt.Unit</code> type to address this.</p>
<ul>
<li><strong>Purpose:</strong> <code>Unit</code> is a type that has exactly one value, <code>Unit.INSTANCE</code>. It is used to represent the successful completion of an operation that doesn't yield any other specific information. Think of it as a functional equivalent of <code>void</code>, but usable as a generic type.</li>
<li><strong>Usage in HKT:</strong>
<ul>
<li>When a monadic action <code>Kind&lt;F, A&gt;</code> completes successfully but has no specific value to return (e.g., an <code>IO</code> action that prints to the console), <code>A</code> can be <code>Unit</code>. The action would then be <code>Kind&lt;F, Unit&gt;</code>, and its successful result would conceptually be <code>Unit.INSTANCE</code>. For example, <code>IO&lt;Unit&gt;</code> for a print operation.</li>
<li>In <code>MonadError&lt;F, E&gt;</code>, if the error state <code>E</code> simply represents an absence or a failure without specific details (like <code>Optional.empty()</code> or <code>Maybe.Nothing()</code>), <code>Unit</code> can be used as the type for <code>E</code>. The <code>raiseError</code> method would then be called with <code>Unit.INSTANCE</code>. For instance, <code>OptionalMonad</code> implements <code>MonadError&lt;OptionalKind.Witness, Unit&gt;</code>, and <code>MaybeMonad</code> implements <code>MonadError&lt;MaybeKind.Witness, Unit&gt;</code>.</li>
</ul>
</li>
<li><strong>Example:</strong>
<pre><code class="language-java">// An IO action that just performs a side effect (printing)
Kind&lt;IOKind.Witness, Unit&gt; printAction = IOKindHelper.delay(() -&gt; {
    System.out.println("Effect executed!");
    return Unit.INSTANCE; // Explicitly return Unit.INSTANCE
});
IOKindHelper.unsafeRunSync(printAction); // Executes the print

// Optional treated as MonadError&lt;..., Unit&gt;
OptionalMonad optionalMonad = OptionalMonad.INSTANCE;
Kind&lt;OptionalKind.Witness, String&gt; emptyOptional = optionalMonad.raiseError(Unit.INSTANCE); // Creates Optional.empty()
</code></pre>
</li>
<li><strong>Reference:</strong> <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/unit/Unit.java"><code>Unit.java</code></a></li>
</ul>
<h2 id="6-error-handling-philosophy"><a class="header" href="#6-error-handling-philosophy">6. Error Handling Philosophy</a></h2>
<ul>
<li><strong>Domain Errors:</strong> These are expected business-level errors or alternative outcomes. They are represented <em>within</em> the structure of the simulated type (e.g., <code>Either.Left</code>, <code>Maybe.Nothing</code>, <code>Try.Failure</code>, a failed <code>CompletableFuture</code>, potentially a specific result type within <code>IO</code>). These are handled using the type's specific methods or <code>MonadError</code> capabilities (<code>handleErrorWith</code>, <code>recover</code>, <code>fold</code>, <code>orElse</code>, etc.) <em>after</em> successfully unwrapping the <code>Kind</code>.</li>
<li><strong>Simulation Errors (<code>KindUnwrapException</code>):</strong> These indicate a problem with the HKT simulation <em>itself</em> – usually a programming error. Examples include passing <code>null</code> to <code>unwrap</code>, passing a <code>ListKind</code> to <code>OptionalKindHelper.unwrap</code>, or (if it were possible) having a <code>Holder</code> record contain a <code>null</code> reference to the underlying Java object it's supposed to hold. These are signalled by throwing the unchecked <code>KindUnwrapException</code> from <code>unwrap</code> methods to clearly distinguish infrastructure issues from domain errors. You typically shouldn't need to catch <code>KindUnwrapException</code> unless debugging the simulation usage itself.</li>
</ul>
<hr />
<div id="admonition-hands-on-learning" class="admonition admonish-info" role="note" aria-labelledby="admonition-hands-on-learning-title">
<div class="admonition-title">
<div id="admonition-hands-on-learning-title">
<p>Hands-On Learning</p>
</div>
<a class="admonition-anchor-link" href="hkts/core-concepts.html#admonition-hands-on-learning"></a>
</div>
<div>
<p>Practice Kind basics in <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/coretypes/Tutorial01_KindBasics.java">Tutorial 01: Kind Basics</a> (4 exercises, ~8 minutes).</p>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="hkts/hkt_introduction.html">HKT Introduction</a>
<strong>Next:</strong> <a href="hkts/usage-guide.html">Usage Guide</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="usage-guide-working-with-higher-kinded-j"><a class="header" href="#usage-guide-working-with-higher-kinded-j">Usage Guide: Working with Higher-Kinded-J</a></h1>
<p><img src="hkts/../images/oa-movements.png" alt="oa-movements.png" /></p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="hkts/usage-guide.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>The five-step workflow for using Higher-Kinded-J effectively</li>
<li>How to identify the right context (witness type) for your use case</li>
<li>Using widen() and narrow() to convert between Java types and Kind representations</li>
<li>When and how to handle KindUnwrapException safely</li>
<li>Writing generic functions that work with any Functor or Monad</li>
</ul>
</div>
</div>
<p>This guide explains the step-by-step process of using Higher-Kinded-J's simulated Higher-Kinded Types (HKTs) and associated type classes like <code>Functor</code>, <code>Applicative</code>, <code>Monad</code>, and <code>MonadError</code>.</p>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/GenericExample.java">GenericExample.java</a></li>
</ul>
<h2 id="core-workflow"><a class="header" href="#core-workflow">Core Workflow</a></h2>
<p>The general process involves these steps:</p>
<div id="admonition-step-1-identify-the-context-_f_witness_" class="admonition admonish-note" role="note" aria-labelledby="admonition-step-1-identify-the-context-_f_witness_-title">
<div class="admonition-title">
<div id="admonition-step-1-identify-the-context-_f_witness_-title">
<p>Step 1: Identify the Context (<em>F_WITNESS</em>)</p>
</div>
<a class="admonition-anchor-link" href="hkts/usage-guide.html#admonition-step-1-identify-the-context-_f_witness_"></a>
</div>
<div>
<p>Determine which type constructor (computational context) you want to work with abstractly. This context is represented by its <em>witness type</em>.</p>
<p>Examples:</p>
<ul>
<li><code>ListKind.Witness</code> for <code>java.util.List</code></li>
<li><code>OptionalKind.Witness</code> for <code>java.util.Optional</code></li>
<li><code>MaybeKind.Witness</code> for the custom <code>Maybe</code> type</li>
<li><code>EitherKind.Witness&lt;L&gt;</code> for the custom <code>Either&lt;L, R&gt;</code> type (where <code>L</code> is fixed)</li>
<li><code>TryKind.Witness</code> for the custom <code>Try</code> type</li>
<li><code>CompletableFutureKind.Witness</code> for <code>java.util.concurrent.CompletableFuture</code></li>
<li><code>IOKind.Witness</code> for the custom <code>IO</code> type</li>
<li><code>LazyKind.Witness</code> for the custom <code>Lazy</code> type</li>
<li><code>ReaderKind.Witness&lt;R_ENV&gt;</code> for the custom <code>Reader&lt;R_ENV, A&gt;</code> type</li>
<li><code>StateKind.Witness&lt;S&gt;</code> for the custom <code>State&lt;S, A&gt;</code> type</li>
<li><code>WriterKind.Witness&lt;W&gt;</code> for the custom <code>Writer&lt;W, A&gt;</code> type</li>
<li>For transformers, e.g., <code>EitherTKind.Witness&lt;F_OUTER_WITNESS, L_ERROR&gt;</code></li>
</ul>
</div>
</div>
<div id="admonition-step-2-find-the-type-class-instance" class="admonition admonish-note" role="note" aria-labelledby="admonition-step-2-find-the-type-class-instance-title">
<div class="admonition-title">
<div id="admonition-step-2-find-the-type-class-instance-title">
<p>Step 2: Find the Type Class Instance</p>
</div>
<a class="admonition-anchor-link" href="hkts/usage-guide.html#admonition-step-2-find-the-type-class-instance"></a>
</div>
<div>
<p>Obtain an instance of the required type class (<code>Functor&lt;F_WITNESS&gt;</code>, <code>Applicative&lt;F_WITNESS&gt;</code>, <code>Monad&lt;F_WITNESS&gt;</code>, <code>MonadError&lt;F_WITNESS, E&gt;</code>) for your chosen context's witness type <code>F_WITNESS</code>.</p>
<p>These are concrete classes provided in the corresponding package.</p>
<p>Examples:</p>
<ul>
<li><strong><code>Optional</code></strong>:
<code>OptionalMonad optionalMonad = OptionalMonad.INSTANCE;</code> (This implements <code>MonadError&lt;OptionalKind.Witness, Unit&gt;</code>)</li>
<li><strong><code>List</code></strong>: <code>ListMonad listMonad = ListMonad.INSTANCE;</code> (This implements <code>Monad&lt;ListKind.Witness&gt;</code>)</li>
<li><strong><code>CompletableFuture</code></strong>: <code>CompletableFutureMonad futureMonad = CompletableFutureMonad.INSTANCE;</code> (This implements <code>MonadError&lt;CompletableFutureKind.Witness, Throwable&gt;</code>)</li>
<li><strong><code>Either&lt;String, ?&gt;</code></strong>: <code>EitherMonad&lt;String&gt; eitherMonad =  EitherMonad.instance();</code> (This implements <code>MonadError&lt;EitherKind.Witness&lt;String&gt;, String&gt;</code>)</li>
<li><strong><code>IO</code></strong>: <code>IOMonad ioMonad = IOMonad.INSTANCE;</code> (This implements <code>Monad&lt;IOKind.Witness&gt;</code>)</li>
<li><strong><code>Writer&lt;String, ?&gt;</code></strong>: <code>WriterMonad&lt;String&gt; writerMonad = new WriterMonad&lt;&gt;(new StringMonoid());</code> (This implements <code>Monad&lt;WriterKind.Witness&lt;String&gt;&gt;</code>)</li>
</ul>
</div>
</div>
<div id="admonition-step-3-wrap-your-value-_javatype_---_kind_" class="admonition admonish-note" role="note" aria-labelledby="admonition-step-3-wrap-your-value-_javatype_---_kind_-title">
<div class="admonition-title">
<div id="admonition-step-3-wrap-your-value-_javatype_---_kind_-title">
<p>Step 3: Wrap Your Value (<em>JavaType<A></em> -&gt; <em>Kind&lt;F_WITNESS, A&gt;</em>)</p>
</div>
<a class="admonition-anchor-link" href="hkts/usage-guide.html#admonition-step-3-wrap-your-value-_javatype_---_kind_"></a>
</div>
<div>
<p>Convert your standard Java object (e.g., a <code>List&lt;Integer&gt;</code>, an <code>Optional&lt;String&gt;</code>, an <code>IO&lt;String&gt;</code>) into Higher-Kinded-J's <code>Kind</code> representation using the <code>widen</code> instance method from the corresponding <code>XxxKindHelper</code> enum's singleton instance. You'll typically use a static import for the singleton instance for brevity.</p>
<pre><code class="language-java"> import static org.higherkindedj.hkt.optional.OptionalKindHelper.OPTIONAL; 
 // ...
 Optional&lt;String&gt; myOptional = Optional.of("test");
 // Widen it into the Higher-Kinded-J Kind type
 // F_WITNESS here is OptionalKind.Witness
 Kind&lt;OptionalKind.Witness, String&gt; optionalKind = OPTIONAL.widen(myOptional);
</code></pre>
<ul>
<li>Helper enums provide convenience factory methods that also return <code>Kind</code> instances, e.g., <code>MAYBE.just("value")</code>, <code>TRY.failure(ex)</code>, <code>IO_OP.delay(() -&gt; ...)</code>, <code>LAZY.defer(() -&gt; ...)</code>. Remember to import thes statically from the XxxKindHelper classes.</li>
<li><strong>Note on Widening</strong>:
<ul>
<li>For JDK types (like <code>List</code>, <code>Optional</code>), <code>widen</code> typically creates an internal <code>Holder</code> object that wraps the JDK type and implements the necessary <code>XxxKind</code> interface.</li>
<li>For library-defined types (<code>Id</code>, <code>IO</code>, <code>Maybe</code>, <code>Either</code>, <code>Validated</code>, Transformers like <code>EitherT</code>) that directly implement their <code>XxxKind</code> interface (which in turn extends <code>Kind</code>), the <code>widen</code> method on the helper enum performs a null check and then a direct (and safe) cast to the <code>Kind</code> type. This provides zero runtime overhead: no wrapper object allocation needed.</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="admonition-step-4-apply-type-class-methods" class="admonition admonish-note" role="note" aria-labelledby="admonition-step-4-apply-type-class-methods-title">
<div class="admonition-title">
<div id="admonition-step-4-apply-type-class-methods-title">
<p>Step 4: Apply Type Class Methods</p>
</div>
<a class="admonition-anchor-link" href="hkts/usage-guide.html#admonition-step-4-apply-type-class-methods"></a>
</div>
<div>
<p>Use the methods defined by the type class interface (<code>map</code>, <code>flatMap</code>, <code>of</code>, <code>ap</code>, <code>raiseError</code>, <code>handleErrorWith</code>, etc.) by calling them on the <strong>type class instance</strong> obtained in <em>Step 2</em>, passing your <code>Kind</code> value(s) as arguments. <strong>Do not call <code>map</code>/<code>flatMap</code> directly on the <code>Kind</code> object itself if it's just the <code>Kind</code> interface.</strong> (Some concrete <code>Kind</code> implementations like <code>Id</code> or <code>Maybe</code> might offer direct methods, but for generic programming, use the type class instance).</p>
<pre><code class="language-java"> import static org.higherkindedj.hkt.optional.OptionalKindHelper.OPTIONAL;
 // ...
 OptionalMonad optionalMonad = OptionalMonad.INSTANCE;
 Kind&lt;OptionalKind.Witness, String&gt; optionalKind = OPTIONAL.widen(Optional.of("test")); // from previous step

 // --- Using map ---
 Function&lt;String, Integer&gt; lengthFunc = String::length;
 // Apply map using the monad instance
 Kind&lt;OptionalKind.Witness, Integer&gt; lengthKind = optionalMonad.map(lengthFunc, optionalKind);
 // lengthKind now represents Kind&lt;OptionalKind.Witness, Integer&gt; containing Optional.of(4)

 // --- Using flatMap ---
 // Function A -&gt; Kind&lt;F_WITNESS, B&gt;
 Function&lt;Integer, Kind&lt;OptionalKind.Witness, String&gt;&gt; checkLength =
     len -&gt; OPTIONAL.widen(len &gt; 3 ? Optional.of("Long enough") : Optional.empty());
 // Apply flatMap using the monad instance
 Kind&lt;OptionalKind.Witness, String&gt; checkedKind = optionalMonad.flatMap(checkLength, lengthKind);
 // checkedKind now represents Kind&lt;OptionalKind.Witness, String&gt; containing Optional.of("Long enough")

 // --- Using MonadError (for Optional, error type is Unit) ---
 Kind&lt;OptionalKind.Witness, String&gt; emptyKind = optionalMonad.raiseError(Unit.INSTANCE); // Represents Optional.empty()
 // Handle the empty case (error state) using handleErrorWith
 Kind&lt;OptionalKind.Witness, String&gt; handledKind = optionalMonad.handleErrorWith(
     emptyKind,
     ignoredError -&gt; OPTIONAL.widen(Optional.of("Default Value")) // Ensure recovery function also returns a Kind
 );

</code></pre>
<p><strong>Note</strong>: For complex chains of monadic operations, consider using <a href="hkts/../functional/for_comprehension.html">For Comprehensions</a> which provide more readable syntax than nested <code>flatMap</code> calls.</p>
</div>
</div>
<div id="admonition-step-5-unwrapnarrow-the-result-_kind---javatype_" class="admonition admonish-note" role="note" aria-labelledby="admonition-step-5-unwrapnarrow-the-result-_kind---javatype_-title">
<div class="admonition-title">
<div id="admonition-step-5-unwrapnarrow-the-result-_kind---javatype_-title">
<p>Step 5: Unwrap/Narrow the Result (<em>Kind&lt;F_WITNESS, A&gt; -&gt; JavaType<A></em>)</p>
</div>
<a class="admonition-anchor-link" href="hkts/usage-guide.html#admonition-step-5-unwrapnarrow-the-result-_kind---javatype_"></a>
</div>
<div>
<p>When you need the underlying Java value back (e.g., to return from a method boundary, perform side effects like printing or running <code>IO</code>), use the <code>narrow</code> instance method from the corresponding <code>XxxKindHelper</code> enum's singleton instance.</p>
<pre><code>```java
import static org.higherkindedj.hkt.optional.OptionalKindHelper.OPTIONAL; 
import static org.higherkindedj.hkt.io.IOKindHelper.IO_OP; 

// ...
// Continuing the Optional example:
 Kind&lt;OptionalKind.Witness, String&gt; checkedKind = /* from previous step */;
 Kind&lt;OptionalKind.Witness, String&gt; handledKind = /* from previous step */;

 Optional&lt;String&gt; finalOptional = OPTIONAL.narrow(checkedKind);
 System.out.println("Final Optional: " + finalOptional); 
 // Output: Optional[Long enough]

 Optional&lt;String&gt; handledOptional = OPTIONAL.narrow(handledKind);
 System.out.println("Handled Optional: " + handledOptional); 
 // Output: Optional[Default Value]

 // Example for IO:
  IOMonad ioMonad = IOMonad.INSTANCE;
  Kind&lt;IOKind.Witness, String&gt; ioKind = IO_OP.delay(() -&gt; "Hello from IO!"); 
  // Use IO_OP.delay
  // unsafeRunSync is an instance method on IOKindHelper.IO_OP
  String ioResult = IO_OP.unsafeRunSync(ioKind);
  System.out.println(ioResult);
```
</code></pre>
</div>
</div>
<hr />
<div id="admonition-handling-_kindunwrapexception_" class="admonition admonish-note" role="note" aria-labelledby="admonition-handling-_kindunwrapexception_-title">
<div class="admonition-title">
<div id="admonition-handling-_kindunwrapexception_-title">
<p>Handling <em>KindUnwrapException</em></p>
</div>
<a class="admonition-anchor-link" href="hkts/usage-guide.html#admonition-handling-_kindunwrapexception_"></a>
</div>
<div>
<p>The <code>narrow</code> instance methods in all <code>KindHelper</code> enums are designed to be robust against <em>structural</em> errors within the HKT simulation layer.</p>
<ul>
<li><strong>When it's thrown</strong>: If you pass <code>null</code> to <code>narrow</code>. For external types using a <code>Holder</code> (like <code>Optional</code> with <code>OptionalHolder</code>), if the <code>Kind</code> instance is not the expected <code>Holder</code> type, an exception is also thrown. For types that directly implement their <code>XxxKind</code> interface, <code>narrow</code> will throw if the <code>Kind</code> is not an instance of that specific concrete type.</li>
<li><strong>What it means</strong>: This exception signals a problem with how you are using Higher-Kinded-J itself – usually a programming error in creating or passing <code>Kind</code> objects.</li>
<li><strong>How to handle</strong>: You generally <strong>should not</strong> need to catch <code>KindUnwrapException</code> in typical application logic. Its occurrence points to a bug that needs fixing in the code using Higher-Kinded-J.</li>
</ul>
<pre><code class="language-java">  // import static org.higherkindedj.hkt.optional.OptionalKindHelper.OPTIONAL;
  public void handlingUnwrapExceptions() {
    try {
      // ERROR: Attempting to narrow null
      Optional&lt;String&gt; result = OPTIONAL.narrow(null);
    } catch(KindUnwrapException e) {
      System.err.println("Higher-Kinded-J Usage Error: " + e.getMessage());
      // Example Output (message from OptionalKindHelper.INVALID_KIND_NULL_MSG):
      // Usage Error: Cannot narrow null Kind for Optional
    }
  }
</code></pre>
<p><strong>Important Distinction:</strong></p>
<ul>
<li><strong><code>KindUnwrapException</code></strong>: Signals a problem with the Higher-Kinded-J structure itself (e.g., invalid <code>Kind</code> object passed to <code>narrow</code>). Fix the code using Higher-Kinded-J.</li>
<li><strong>Domain Errors / Absence</strong>: Represented <em>within</em> a valid <code>Kind</code> structure (e.g., <code>Optional.empty()</code> widened to <code>Kind&lt;OptionalKind.Witness, A&gt;</code>, <code>Either.Left</code> widened to <code>Kind&lt;EitherKind.Witness&lt;L&gt;, R&gt;</code>). These should be handled using the monad's specific methods (<code>orElse</code>, <code>fold</code>, <code>handleErrorWith</code>, etc.) or by using the <code>MonadError</code> methods <em>before</em> narrowing back to the final Java type.</li>
</ul>
</div>
</div>
<div id="admonition-example-generic-function" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-generic-function-title">
<div class="admonition-title">
<div id="admonition-example-generic-function-title">
<p>Example: Generic Function</p>
</div>
<a class="admonition-anchor-link" href="hkts/usage-guide.html#admonition-example-generic-function"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/GenericExample.java">GenericExample.java</a></li>
</ul>
<p>Higher-Kinded-J allows writing functions generic over the simulated type constructor (represented by its witness <code>F_WITNESS</code>).</p>
<pre><code class="language-java">// import static org.higherkindedj.hkt.list.ListKindHelper.LIST;
// import static org.higherkindedj.hkt.optional.OptionalKindHelper.OPTIONAL;
// ...

// Generic function: Applies a function within any Functor context F_WITNESS.
// Requires the specific Functor&lt;F_WITNESS&gt; instance to be passed in.
public static &lt;F_WITNESS, A, B&gt; Kind&lt;F_WITNESS, B&gt; mapWithFunctor(
    Functor&lt;F_WITNESS&gt; functorInstance, // Pass the type class instance for F_WITNESS
    Function&lt;A, B&gt; fn,
    Kind&lt;F_WITNESS, A&gt; kindABox) { 

  // Use the map method from the provided Functor instance
  return functorInstance.map(fn, kindABox);
}

public void genericExample() { 
  // Get instances of the type classes for the specific types (F_WITNESS) we want to use
  ListMonad listMonad = new ListMonad(); // Implements Functor&lt;ListKind.Witness&gt;
  OptionalMonad optionalMonad = OptionalMonad.INSTANCE; // Implements Functor&lt;OptionalKind.Witness&gt;

  Function&lt;Integer, Integer&gt; doubleFn = x -&gt; x * 2;

  // --- Use with List ---
  List&lt;Integer&gt; nums = List.of(1, 2, 3);
  // Widen the List. F_WITNESS is ListKind.Witness
  Kind&lt;ListKind.Witness, Integer&gt; listKind = LIST.widen(nums); 
  // Call the generic function, passing the ListMonad instance and the widened List
  Kind&lt;ListKind.Witness, Integer&gt; doubledListKind = mapWithFunctor(listMonad, doubleFn, listKind);
  System.out.println("Doubled List: " + LIST.narrow(doubledListKind)); // Output: [2, 4, 6]

  // --- Use with Optional (Present) ---
  Optional&lt;Integer&gt; optNum = Optional.of(10);
  // Widen the Optional. F_WITNESS is OptionalKind.Witness
  Kind&lt;OptionalKind.Witness, Integer&gt; optKind = OPTIONAL.widen(optNum); 
  // Call the generic function, passing the OptionalMonad instance and the widened Optional
  Kind&lt;OptionalKind.Witness, Integer&gt; doubledOptKind = mapWithFunctor(optionalMonad, doubleFn, optKind);
  System.out.println("Doubled Optional: " + OPTIONAL.narrow(doubledOptKind)); // Output: Optional[20]

  // --- Use with Optional (Empty) ---
  Optional&lt;Integer&gt; emptyOpt = Optional.empty();
  Kind&lt;OptionalKind.Witness, Integer&gt; emptyOptKind = OPTIONAL.widen(emptyOpt); 
  // Call the generic function, map does nothing on empty
  Kind&lt;OptionalKind.Witness, Integer&gt; doubledEmptyOptKind = mapWithFunctor(optionalMonad, doubleFn, emptyOptKind);
  System.out.println("Doubled Empty Optional: " + OPTIONAL.narrow(doubledEmptyOptKind)); // Output: Optional.empty
}

</code></pre>
<hr />
<p><strong>Previous:</strong> <a href="hkts/core-concepts.html">Concepts</a>
<strong>Next:</strong> [Basic HKT Examples](hkt_basic_examples.md</p>
</div>
</div><div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="higher-kinded-types---basic-usage-examples"><a class="header" href="#higher-kinded-types---basic-usage-examples">Higher-Kinded Types - Basic Usage Examples</a></h1>
<blockquote>
<p>This document provides a brief summary of the example classes found in the <code>org.higherkindedj.example.basic</code> package in the <a href="https://github.com/higher-kinded-j/higher-kinded-j/tree/main/hkj-examples/src/main/java/org/higherkindedj/example/basic">HKJ-Examples</a>.</p>
</blockquote>
<p>These examples showcase how to use various monads and monad transformers to handle common programming tasks like managing optional values, asynchronous operations, and state in a functional way.</p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="hkts/hkt_basic_examples.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>Practical examples of core monads including Either, Maybe, Optional, IO, and State</li>
<li>How to use monad transformers like EitherT, MaybeT, and StateT to combine effects</li>
<li>Working with specialized monads like Reader for dependency injection and Writer for logging</li>
<li>Using For comprehensions to compose complex monadic workflows</li>
<li>Writing generic functions that work across different Functor and Monad instances</li>
<li>Handling errors and exceptions functionally with Try, Either, and MonadError</li>
</ul>
</div>
</div>
<hr />
<h2 id="monads"><a class="header" href="#monads">Monads</a></h2>
<h3 id="eitherexamplejava"><a class="header" href="#eitherexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/either/EitherExample.java">EitherExample.java</a></a></h3>
<p>This example demonstrates the <strong>Either monad</strong>. <code>Either</code> is used to represent a value that can be one of two types, typically a success value (<code>Right</code>) or an error value (<code>Left</code>).</p>
<ul>
<li><strong>Key Concept</strong>: A <code>Either</code> provides a way to handle computations that can fail with a specific error type.</li>
<li><strong>Demonstrates</strong>:
<ul>
<li>Creating <code>Either</code> instances for success (<code>Right</code>) and failure (<code>Left</code>) cases.</li>
<li>Using <code>flatMap</code> to chain operations that return an <code>Either</code>, short-circuiting on failure.</li>
<li>Using <code>fold</code> to handle both the <code>Left</code> and <code>Right</code> cases.</li>
</ul>
</li>
</ul>
<pre><code class="language-java">// Chain operations that can fail
Either&lt;String, Integer&gt; result = input.flatMap(parse).flatMap(checkPositive);

// Fold to handle both outcomes
String message = result.fold(
    leftValue -&gt; "Operation failed with: " + leftValue,
    rightValue -&gt; "Operation succeeded with: " + rightValue
);
</code></pre>
<h3 id="forcomprehensionexamplejava"><a class="header" href="#forcomprehensionexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/expression/ForComprehensionExample.java">ForComprehensionExample.java</a></a></h3>
<p>This example demonstrates how to use the <code>For</code> comprehension, a feature that provides a more readable, sequential syntax for composing monadic operations (equivalent to <code>flatMap</code> chains).</p>
<ul>
<li><strong>Key Concept</strong>: A <code>For</code> comprehension offers syntactic sugar for <code>flatMap</code> and <code>map</code> calls, making complex monadic workflows easier to write and understand.</li>
<li><strong>Demonstrates</strong>:
<ul>
<li>Using <code>For.from()</code> to start and chain monadic operations.</li>
<li>Applying comprehensions to different monads like <code>List</code>, <code>Maybe</code>, and the <code>StateT</code> monad transformer.</li>
<li>Filtering intermediate results with <code>.when()</code>.</li>
<li>Introducing intermediate values with <code>.let()</code>.</li>
<li>Producing a final result with <code>.yield()</code>.</li>
</ul>
</li>
</ul>
<pre><code class="language-java">// A for-comprehension with List
final Kind&lt;ListKind.Witness, String&gt; result =
    For.from(listMonad, list1)
        .from(_ -&gt; list2)
        .when(t -&gt; (t._1() + t._2()) % 2 != 0) // Filter
        .let(t -&gt; "Sum: " + (t._1() + t._2())) // Introduce new value
        .yield((a, b, c) -&gt; a + " + " + b + " = " + c); // Final result
</code></pre>
<h3 id="completablefutureexamplejava"><a class="header" href="#completablefutureexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/future/CompletableFutureExample.java">CompletableFutureExample.java</a></a></h3>
<p>This example covers the <strong>CompletableFuture monad</strong>. It shows how to use <code>CompletableFuture</code> within the Higher-Kinded-J framework to manage asynchronous computations and handle potential errors.</p>
<ul>
<li><strong>Key Concept</strong>: The <code>CompletableFuture</code> monad is used to compose asynchronous operations in a non-blocking way.</li>
<li><strong>Demonstrates</strong>:
<ul>
<li>Creating <code>Kind</code>-wrapped <code>CompletableFuture</code> instances for success and failure.</li>
<li>Using <code>map</code> (which corresponds to <code>thenApply</code>).</li>
<li>Using <code>flatMap</code> (which corresponds to <code>thenCompose</code>) to chain dependent asynchronous steps.</li>
<li>Using <code>handleErrorWith</code> to recover from exceptions that occur within the future.</li>
</ul>
</li>
</ul>
<pre><code class="language-java">// Using handleErrorWith to recover from a failed future
Function&lt;Throwable, Kind&lt;CompletableFutureKind.Witness, String&gt;&gt; recoveryHandler =
    error -&gt; {
      System.out.println("Handling error: " + error.getMessage());
      return futureMonad.of("Recovered from Error");
    };

Kind&lt;CompletableFutureKind.Witness, String&gt; recoveredFuture =
    futureMonad.handleErrorWith(failedFutureKind, recoveryHandler);
</code></pre>
<h3 id="idexamplejava"><a class="header" href="#idexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/id/IdExample.java">IdExample.java</a></a></h3>
<p>This example introduces the <strong>Identity (Id) monad</strong>. The <code>Id</code> monad is the simplest monad; it wraps a value without adding any computational context. It is primarily used to make generic code that works with any monad also work with simple, synchronous values.</p>
<ul>
<li><strong>Key Concept</strong>: The <code>Id</code> monad represents a direct, synchronous computation. It wraps a value, and its <code>flatMap</code> operation simply applies the function to the value.</li>
<li><strong>Demonstrates</strong>:
<ul>
<li>Wrapping a plain value into an <code>Id</code>.</li>
<li>Using <code>map</code> and <code>flatMap</code> on an <code>Id</code> value.</li>
<li>Its use as the underlying monad in a monad transformer stack, effectively turning <code>StateT&lt;S, IdKind.Witness, A&gt;</code> into <code>State&lt;S, A&gt;</code>.</li>
</ul>
</li>
</ul>
<pre><code class="language-java">// flatMap on Id simply applies the function to the wrapped value.
Id&lt;String&gt; idFromOf = Id.of(42);
Id&lt;String&gt; directFlatMap = idFromOf.flatMap(i -&gt; Id.of("Direct FlatMap: " + i));
// directFlatMap.value() is "Direct FlatMap: 42"
</code></pre>
<h3 id="ioexamplejava"><a class="header" href="#ioexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/io/IOExample.java">IOExample.java</a></a></h3>
<p>This example introduces the <strong>IO monad</strong>, which is used to encapsulate side effects like reading from the console, writing to a file, or making a network request.</p>
<ul>
<li><strong>Key Concept</strong>: The <code>IO</code> monad describes a computation that can perform side effects. These effects are only executed when the <code>IO</code> action is explicitly run.</li>
<li><strong>Demonstrates</strong>:
<ul>
<li>Creating <code>IO</code> actions that describe side effects using <code>delay</code>.</li>
<li>Composing <code>IO</code> actions using <code>map</code> and <code>flatMap</code> to create more complex programs.</li>
<li>Executing <code>IO</code> actions to produce a result using <code>unsafeRunSync</code>.</li>
</ul>
</li>
</ul>
<pre><code class="language-java">// Create an IO action to read a line from the console
Kind&lt;IOKind.Witness, String&gt; readLine = IO_OP.delay(() -&gt; {
    System.out.print("Enter your name: ");
    try (Scanner scanner = new Scanner(System.in)) {
        return scanner.nextLine();
    }
});

// Execute the action to get the result
String name = IO_OP.unsafeRunSync(readLine);
</code></pre>
<h3 id="lazyexamplejava"><a class="header" href="#lazyexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/lazy/LazyExample.java">LazyExample.java</a></a></h3>
<p>This example covers the <strong>Lazy monad</strong>. It's used to defer a computation until its result is explicitly requested. The result is then memoized (cached) so the computation is only executed once.</p>
<ul>
<li><strong>Key Concept</strong>: A <code>Lazy</code> computation is not executed when it is created, but only when <code>force()</code> is called. The result (or exception) is then stored for subsequent calls.</li>
<li><strong>Demonstrates</strong>:
<ul>
<li>Creating a deferred computation with <code>LAZY.defer()</code>.</li>
<li>Forcing evaluation with <code>LAZY.force()</code>.</li>
<li>How results are memoized, preventing re-computation.</li>
<li>Using <code>map</code> and <code>flatMap</code> to build chains of lazy operations.</li>
</ul>
</li>
</ul>
<pre><code class="language-java">// Defer a computation
java.util.concurrent.atomic.AtomicInteger counter = new java.util.concurrent.atomic.AtomicInteger(0);
Kind&lt;LazyKind.Witness, String&gt; deferredLazy = LAZY.defer(() -&gt; {
    counter.incrementAndGet();
    return "Computed Value";
});

// The computation only runs when force() is called
System.out.println(LAZY.force(deferredLazy)); // counter becomes 1
System.out.println(LAZY.force(deferredLazy)); // result is from cache, counter remains 1
</code></pre>
<h3 id="listmonadexamplejava"><a class="header" href="#listmonadexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/list/ListMonadExample.java">ListMonadExample.java</a></a></h3>
<p>This example demonstrates the <strong>List monad</strong>. It shows how to perform monadic operations on a standard Java <code>List</code>, treating it as a context that can hold zero or more results.</p>
<ul>
<li><strong>Key Concept</strong>: The <code>List</code> monad represents non-deterministic computation, where an operation can produce multiple results.</li>
<li><strong>Demonstrates</strong>:
<ul>
<li>Wrapping a <code>List</code> into a <code>Kind&lt;ListKind.Witness, A&gt;</code>.</li>
<li>Using <code>map</code> to transform every element in the list.</li>
<li>Using <code>flatMap</code> to apply a function that returns a list to each element, and then flattening the result.</li>
</ul>
</li>
</ul>
<pre><code class="language-java">// A function that returns multiple results for even numbers
Function&lt;Integer, Kind&lt;ListKind.Witness, Integer&gt;&gt; duplicateIfEven =
    n -&gt; {
      if (n % 2 == 0) {
        return LIST.widen(Arrays.asList(n, n * 10));
      } else {
        return LIST.widen(List.of()); // Empty list for odd numbers
      }
    };

// flatMap applies the function and flattens the resulting lists
Kind&lt;ListKind.Witness, Integer&gt; flatMappedKind = listMonad.flatMap(duplicateIfEven, numbersKind);
</code></pre>
<h3 id="maybeexamplejava"><a class="header" href="#maybeexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/maybe/MaybeExample.java">MaybeExample.java</a></a></h3>
<p>This example covers the <strong>Maybe monad</strong>. <code>Maybe</code> is a type that represents an optional value, similar to Java's <code>Optional</code>, but designed to be used as a monad within the Higher-Kinded-J ecosystem. It has two cases: <code>Just&lt;A&gt;</code> (a value is present) and <code>Nothing</code> (a value is absent).</p>
<ul>
<li><strong>Key Concept</strong>: The <code>Maybe</code> monad provides a way to represent computations that may or may not return a value, explicitly handling the absence of a value.</li>
<li><strong>Demonstrates</strong>:
<ul>
<li>Creating <code>Just</code> and <code>Nothing</code> instances.</li>
<li>Using <code>map</code> to transform a <code>Just</code> value.</li>
<li>Using <code>flatMap</code> to chain operations that return a <code>Maybe</code>.</li>
<li>Handling the <code>Nothing</code> case using <code>handleErrorWith</code>.</li>
</ul>
</li>
</ul>
<pre><code class="language-java">// flatMap to parse a string, which can result in Nothing
Function&lt;String, Kind&lt;MaybeKind.Witness, Integer&gt;&gt; parseString =
    s -&gt; {
      try {
        return MAYBE.just(Integer.parseInt(s));
      } catch (NumberFormatException e) {
        return MAYBE.nothing();
      }
    };
</code></pre>
<h3 id="optionalexamplejava"><a class="header" href="#optionalexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/optional/OptionalExample.java">OptionalExample.java</a></a></h3>
<p>This example introduces the <strong>Optional monad</strong>. It demonstrates how to wrap Java's <code>Optional</code> in a <code>Kind</code> to work with it in a monadic way, allowing for chaining of operations and explicit error handling.</p>
<ul>
<li><strong>Key Concept</strong>: The <code>Optional</code> monad provides a way to represent computations that may or may not return a value.</li>
<li><strong>Demonstrates</strong>:
<ul>
<li>Wrapping <code>Optional</code> instances into a <code>Kind&lt;OptionalKind.Witness, A&gt;</code>.</li>
<li>Using <code>map</code> to transform the value inside a present <code>Optional</code>.</li>
<li>Using <code>flatMap</code> to chain operations that return <code>Optional</code>.</li>
<li>Using <code>handleErrorWith</code> to provide a default value when the <code>Optional</code> is empty.</li>
</ul>
</li>
</ul>
<pre><code class="language-java">// Using flatMap to parse a string to an integer, which may fail
Function&lt;String, Kind&lt;OptionalKind.Witness, Integer&gt;&gt; parseToIntKind =
    s -&gt; {
      try {
        return OPTIONAL.widen(Optional.of(Integer.parseInt(s)));
      } catch (NumberFormatException e) {
        return OPTIONAL.widen(Optional.empty());
      }
    };

Kind&lt;OptionalKind.Witness, Integer&gt; parsedPresent =
    optionalMonad.flatMap(parseToIntKind, presentInput);
</code></pre>
<h3 id="readerexamplejava"><a class="header" href="#readerexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/reader/ReaderExample.java">ReaderExample.java</a></a></h3>
<p>This example introduces the <strong>Reader monad</strong>. The <code>Reader</code> monad is a pattern used for dependency injection. It represents a computation that depends on some configuration or environment of type <code>R</code>.</p>
<ul>
<li><strong>Key Concept</strong>: A <code>Reader&lt;R, A&gt;</code> represents a function <code>R -&gt; A</code>. It allows you to "read" from a configuration <code>R</code> to produce a value <code>A</code>, without explicitly passing the configuration object everywhere.</li>
<li><strong>Demonstrates</strong>:
<ul>
<li>Creating <code>Reader</code> computations that access parts of a configuration object.</li>
<li>Using <code>flatMap</code> to chain computations where one step depends on the result of a previous step and the shared configuration.</li>
<li>Running the final <code>Reader</code> computation by providing a concrete configuration object.</li>
</ul>
</li>
</ul>
<pre><code class="language-java">// A Reader that depends on the AppConfig environment
Kind&lt;ReaderKind.Witness&lt;AppConfig&gt;, String&gt; connectionStringReader =
    readerMonad.flatMap(
        dbUrl -&gt; READER.reader(config -&gt; dbUrl + "?apiKey=" + config.apiKey()),
        getDbUrl // Another Reader that gets the DB URL
    );

// The computation is only run when a config is provided
String connectionString = READER.runReader(connectionStringReader, productionConfig);
</code></pre>
<h3 id="stateexample-bankaccountworkflowjava"><a class="header" href="#stateexample-bankaccountworkflowjava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/state/StateExample.java">StateExample</a>, <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/state/BankAccountWorkflow.java">BankAccountWorkflow.java</a></a></h3>
<p>These examples demonstrate the <strong>State monad</strong>. The <code>State</code> monad is used to manage state in a purely functional way, abstracting away the boilerplate of passing state from one function to the next.</p>
<ul>
<li><strong>Key Concept</strong>: A <code>State&lt;S, A&gt;</code> represents a function <code>S -&gt; (S, A)</code>, which takes an initial state and returns a new state and a computed value. The monad chains these functions together.</li>
<li><strong>Demonstrates</strong>:
<ul>
<li>Creating stateful actions like <code>push</code>, <code>pop</code>, <code>deposit</code>, and <code>withdraw</code>.</li>
<li>Using <code>State.modify</code> to update the state and <code>State.inspect</code> to read from it.</li>
<li>Composing these actions into a larger workflow using a <code>For</code> comprehension.</li>
<li>Running the final computation with an initial state to get the final state and result.</li>
</ul>
</li>
</ul>
<pre><code class="language-java">// A stateful action to withdraw money, returning a boolean success flag
public static Function&lt;BigDecimal, Kind&lt;StateKind.Witness&lt;AccountState&gt;, Boolean&gt;&gt; withdraw(String description) {
    return amount -&gt; STATE.widen(
        State.of(currentState -&gt; {
            if (currentState.balance().compareTo(amount) &gt;= 0) {
                // ... update state and return success
                return new StateTuple&lt;&gt;(true, updatedState);
            } else {
                // ... update state with rejection and return failure
                return new StateTuple&lt;&gt;(false, updatedState);
            }
        })
    );
}
</code></pre>
<h3 id="tryexamplejava"><a class="header" href="#tryexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/trymonad/TryExample.java">TryExample.java</a></a></h3>
<p>This example introduces the <strong>Try monad</strong>. It's designed to encapsulate computations that can throw exceptions, making error handling more explicit and functional.</p>
<ul>
<li><strong>Key Concept</strong>: A <code>Try</code> represents a computation that results in either a <code>Success</code> containing a value or a <code>Failure</code> containing an exception.</li>
<li><strong>Demonstrates</strong>:
<ul>
<li>Creating <code>Try</code> instances for successful and failed computations.</li>
<li>Using <code>map</code> and <code>flatMap</code> to chain operations, where exceptions are caught and wrapped in a <code>Failure</code>.</li>
<li>Using <code>recover</code> and <code>recoverWith</code> to handle failures and provide alternative values or computations.</li>
</ul>
</li>
</ul>
<pre><code class="language-java">// A function that returns a Try, succeeding or failing based on the input
Function&lt;Integer, Try&lt;Double&gt;&gt; safeDivide =
    value -&gt;
        (value == 0)
            ? Try.failure(new ArithmeticException("Div by zero"))
            : Try.success(10.0 / value);

// flatMap chains the operation, propagating failure
Try&lt;Double&gt; result = input.flatMap(safeDivide);
</code></pre>
<h3 id="validatedmonadexamplejava"><a class="header" href="#validatedmonadexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/validated/ValidatedMonadExample.java">ValidatedMonadExample.java</a></a></h3>
<p>This example showcases the <strong>Validated applicative functor</strong>. While it has a <code>Monad</code> instance, it's often used as an <code>Applicative</code> to accumulate errors. This example, however, focuses on its monadic (fail-fast) behaviour.</p>
<ul>
<li><strong>Key Concept</strong>: <code>Validated</code> is used for validation scenarios where you want either to get a valid result or to accumulate validation errors.</li>
<li><strong>Demonstrates</strong>:
<ul>
<li>Creating <code>Valid</code> and <code>Invalid</code> instances.</li>
<li>Using <code>flatMap</code> to chain validation steps, where the first <code>Invalid</code> result short-circuits the computation.</li>
<li>Using <code>handleErrorWith</code> to recover from a validation failure.</li>
</ul>
</li>
</ul>
<pre><code class="language-java">// A validation function that returns a Kind-wrapped Validated
Function&lt;String, Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Integer&gt;&gt; parseToIntKind =
    s -&gt; {
      try {
        return validatedMonad.of(Integer.parseInt(s)); // Lifts to Valid
      } catch (NumberFormatException e) {
        return validatedMonad.raiseError(Collections.singletonList("'" + s + "' is not a number."));
      }
    };
</code></pre>
<h3 id="writerexamplejava"><a class="header" href="#writerexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/writer/WriterExample.java">WriterExample.java</a></a></h3>
<p>This example introduces the <strong>Writer monad</strong>. The <code>Writer</code> monad is used for computations that need to produce a log or accumulate a secondary value alongside their primary result.</p>
<ul>
<li><strong>Key Concept</strong>: A <code>Writer&lt;W, A&gt;</code> represents a computation that returns a primary result <code>A</code> and an accumulated value <code>W</code> (like a log), where <code>W</code> must have a <code>Monoid</code> instance to define how values are combined.</li>
<li><strong>Demonstrates</strong>:
<ul>
<li>Using <code>tell</code> to append to the log.</li>
<li>Using <code>flatMap</code> to sequence computations, where both the results and logs are combined automatically.</li>
<li>Running the final <code>Writer</code> to extract both the final value and the fully accumulated log.</li>
</ul>
</li>
</ul>
<pre><code class="language-java">// An action that performs a calculation and logs what it did
Function&lt;Integer, Kind&lt;WriterKind.Witness&lt;String&gt;, Integer&gt;&gt; addAndLog =
    x -&gt; {
      int result = x + 10;
      String logMsg = "Added 10 to " + x + " -&gt; " + result + "; ";
      return WRITER.widen(new Writer&lt;&gt;(logMsg, result));
    };

// The monad combines the logs from each step automatically
Kind&lt;WriterKind.Witness&lt;String&gt;, String&gt; finalComputation = writerMonad.flatMap(
    intermediateValue -&gt; multiplyAndLogToString.apply(intermediateValue),
    addAndLog.apply(5)
);
</code></pre>
<h3 id="genericexamplejava"><a class="header" href="#genericexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/GenericExample.java">GenericExample.java</a></a></h3>
<p>This example showcases how to write <strong>generic functions</strong> that can operate on any <code>Functor</code> (or <code>Monad</code>) by accepting the type class instance as a parameter. This is a core concept of higher-kinded polymorphism.</p>
<ul>
<li><strong>Key Concept</strong>: By abstracting over the computational context (<code>F</code>), you can write code that works for <code>List</code>, <code>Optional</code>, <code>IO</code>, or any other type that has a <code>Functor</code> instance.</li>
<li><strong>Demonstrates</strong>:
<ul>
<li>Writing a generic <code>mapWithFunctor</code> function that takes a <code>Functor&lt;F&gt;</code> instance and a <code>Kind&lt;F, A&gt;</code>.</li>
<li>Calling this generic function with different monad instances (<code>ListMonad</code>, <code>OptionalMonad</code>) and their corresponding <code>Kind</code>-wrapped types.</li>
</ul>
</li>
</ul>
<pre><code class="language-java">// A generic function that works for any Functor F
public static &lt;F, A, B&gt; Kind&lt;F, B&gt; mapWithFunctor(
    Functor&lt;F&gt; functorInstance, // The type class instance
    Function&lt;A, B&gt; fn,
    Kind&lt;F, A&gt; kindBox) { // The value in its context
    return functorInstance.map(fn, kindBox);
}

// Calling it with a List
Kind&lt;ListKind.Witness, Integer&gt; doubledList = mapWithFunctor(listMonad, doubleFn, listKind);

// Calling it with an Optional
Kind&lt;OptionalKind.Witness, Integer&gt; doubledOpt = mapWithFunctor(optionalMonad, doubleFn, optKind);
</code></pre>
<h3 id="profunctorexamplejava"><a class="header" href="#profunctorexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/profunctor/ProfunctorExample.java">ProfunctorExample.java</a></a></h3>
<p>This example demonstrates the <strong>Profunctor</strong> type class using <code>FunctionProfunctor</code>, showing how to build flexible, adaptable data transformation pipelines.</p>
<ul>
<li><strong>Key Concept</strong>: A <code>Profunctor</code> is contravariant in its first parameter and covariant in its second, making it perfect for adapting both the input and output of functions.</li>
<li><strong>Demonstrates</strong>:
<ul>
<li>Using <code>lmap</code> to adapt function inputs (contravariant mapping)</li>
<li>Using <code>rmap</code> to adapt function outputs (covariant mapping)</li>
<li>Using <code>dimap</code> to adapt both input and output simultaneously</li>
<li>Building real-world API adapters and validation pipelines</li>
<li>Creating reusable transformation chains</li>
</ul>
</li>
</ul>
<pre><code class="language-java">// Original function: String length calculator
Function&lt;String, Integer&gt; stringLength = String::length;

// Adapt the input: now works with integers!
Kind2&lt;FunctionKind.Witness, Integer, Integer&gt; intToLength =
    profunctor.lmap(Object::toString, lengthFunction);

// Adapt the output: now returns formatted strings!
Kind2&lt;FunctionKind.Witness, String, String&gt; lengthToString =
    profunctor.rmap(len -&gt; "Length: " + len, lengthFunction);

// Adapt both input and output in one operation
Kind2&lt;FunctionKind.Witness, Integer, String&gt; fullTransform =
    profunctor.dimap(Object::toString, len -&gt; "Result: " + len, lengthFunction);
</code></pre>
<hr />
<h2 id="monad-transformers"><a class="header" href="#monad-transformers">Monad Transformers</a></h2>
<p>These examples show how to use <strong>monad transformers</strong> (<code>EitherT</code>, <code>MaybeT</code>, <code>OptionalT</code>, <code>ReaderT</code>, <code>StateT</code>) to combine the capabilities of different monads.</p>
<h3 id="eithertexamplejava"><a class="header" href="#eithertexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/either_t/EitherTExample.java">EitherTExample.java</a></a></h3>
<ul>
<li><strong>Key Concept</strong>: <code>EitherT</code> stacks the <code>Either</code> monad on top of another monad <code>F</code>, creating a new monad <code>EitherT&lt;F, L, R&gt;</code> that handles both the effects of <code>F</code> and the failure logic of <code>Either</code>.</li>
<li><strong>Scenario</strong>: Composing synchronous validation (<code>Either</code>) with an asynchronous operation (<code>CompletableFuture</code>) in a single, clean workflow.</li>
</ul>
<h3 id="maybetexamplejava"><a class="header" href="#maybetexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/maybe_t/MaybeTExample.java">MaybeTExample.java</a></a></h3>
<ul>
<li><strong>Key Concept</strong>: <code>MaybeT</code> stacks the <code>Maybe</code> monad on top of another monad <code>F</code>. This is useful for asynchronous operations that may not return a value.</li>
<li><strong>Scenario</strong>: Fetching a userLogin and their preferences from a database asynchronously, where each step might not find a result.</li>
</ul>
<h3 id="optionaltexamplejava"><a class="header" href="#optionaltexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/optional_t/OptionalTExample.java">OptionalTExample.java</a></a></h3>
<ul>
<li><strong>Key Concept</strong>: <code>OptionalT</code> stacks <code>Optional</code> on top of another monad <code>F</code>, creating <code>OptionalT&lt;F, A&gt;</code> to handle asynchronous operations that may return an empty result.</li>
<li><strong>Scenario</strong>: Fetching a userLogin and their preferences from a database asynchronously, where each step might not find a result.</li>
</ul>
<h3 id="readertexamplejava-readertunitexamplejava--readertasyncunitexamplejava"><a class="header" href="#readertexamplejava-readertunitexamplejava--readertasyncunitexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/reader_t/ReaderTExample.java">ReaderTExample.java</a>, <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/reader_t/ReaderTAsyncExample.java">ReaderTUnitExample.java</a>,  <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/reader_t/ReaderTAsyncUnitExample.java">ReaderTAsyncUnitExample.java</a></a></h3>
<ul>
<li><strong>Key Concept</strong>: <code>ReaderT</code> combines the <code>Reader</code> monad (for dependency injection) with an outer monad <code>F</code>. This allows for computations that both read from a shared environment and have effects of type <code>F</code>.</li>
<li><strong>Scenario</strong>: An asynchronous workflow that depends on a configuration object (<code>AppConfig</code>) to fetch and process data.</li>
</ul>
<h3 id="statetexamplejava-statetstackexample"><a class="header" href="#statetexamplejava-statetstackexample"><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/state_t/StateTExample.java">StateTExample.java</a>, <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/state_t/StateTStackExample.java">StateTStackExample</a></a></h3>
<ul>
<li><strong>Key Concept</strong>: <code>StateT</code> combines the <code>State</code> monad with an outer monad <code>F</code>. This is for stateful computations that also involve effects from <code>F</code>.</li>
<li><strong>Scenario</strong>: A stateful stack that can fail (using <code>Optional</code> as the outer monad), where popping from an empty stack results in <code>Optional.empty()</code>.</li>
</ul>
<hr />
<p>For more advanced patterns combining State with other monads, see the <a href="hkts/order-walkthrough.html">Order Processing Example</a> which demonstrates <code>StateT</code> with <code>EitherT</code>.</p>
<hr />
<p><strong>Previous:</strong> <a href="hkts/usage-guide.html">Usage Guide</a>
<strong>Next:</strong> <a href="hkts/quick_reference.html">Quick Reference</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="quick-reference-guide"><a class="header" href="#quick-reference-guide">Quick Reference Guide</a></h1>
<p>This section provides at-a-glance summaries of all type classes in Higher-Kinded-J. Use this as a quick lookup while coding or to compare different type classes.</p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="hkts/quick_reference.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>Quick reference summaries for all core type classes and their key methods</li>
<li>Decision guides for choosing the right type class for your use case</li>
<li>Common patterns and examples for Functor, Applicative, Monad, and MonadError</li>
<li>Understanding Semigroup, Monoid, Foldable, and Traverse for data operations</li>
<li>Type class hierarchy and inheritance relationships</li>
<li>Performance considerations and when to use HKT versus direct methods</li>
</ul>
</div>
</div>
<h2 id="core-type-classes"><a class="header" href="#core-type-classes">Core Type Classes</a></h2>
<h3 id="functor"><a class="header" href="#functor">Functor</a></h3>
<div id="admonition-functor-quick-reference" class="admonition admonish-tip" role="note" aria-labelledby="admonition-functor-quick-reference-title">
<div class="admonition-title">
<div id="admonition-functor-quick-reference-title">
<p>Functor Quick Reference</p>
</div>
<a class="admonition-anchor-link" href="hkts/quick_reference.html#admonition-functor-quick-reference"></a>
</div>
<div>
<p><strong>Core Method:</strong> <code>map(Function&lt;A,B&gt; f, Kind&lt;F,A&gt; fa) -&gt; Kind&lt;F,B&gt;</code></p>
<p><strong>Purpose:</strong> Transform values inside a context without changing the context structure</p>
<p><strong>Use When:</strong></p>
<ul>
<li>You have a simple transformation function <code>A -&gt; B</code></li>
<li>The context/container should remain unchanged</li>
<li>No dependency between input and output contexts</li>
</ul>
<p><strong>Laws:</strong></p>
<ul>
<li>Identity: <code>map(identity) == identity</code></li>
<li>Composition: <code>map(g ∘ f) == map(g) ∘ map(f)</code></li>
</ul>
<p><strong>Common Instances:</strong> List, Optional, Maybe, Either, IO, CompletableFuture</p>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Transform string to length, preserving Optional context
Kind&lt;OptionalKind.Witness, Integer&gt; lengths = 
    optionalFunctor.map(String::length, optionalString);
</code></pre>
<p><strong>Think Of It As:</strong> Applying a function "inside the box" without opening it</p>
</div>
</div>
<h3 id="applicative"><a class="header" href="#applicative">Applicative</a></h3>
<div id="admonition-applicative-quick-reference" class="admonition admonish-tip" role="note" aria-labelledby="admonition-applicative-quick-reference-title">
<div class="admonition-title">
<div id="admonition-applicative-quick-reference-title">
<p>Applicative Quick Reference</p>
</div>
<a class="admonition-anchor-link" href="hkts/quick_reference.html#admonition-applicative-quick-reference"></a>
</div>
<div>
<p><strong>Core Methods:</strong></p>
<ul>
<li><code>of(A value) -&gt; Kind&lt;F,A&gt;</code> (lift pure value)</li>
<li><code>ap(Kind&lt;F,Function&lt;A,B&gt;&gt; ff, Kind&lt;F,A&gt; fa) -&gt; Kind&lt;F,B&gt;</code> (apply wrapped function)</li>
</ul>
<p><strong>Purpose:</strong> Combine independent computations within a context</p>
<p><strong>Use When:</strong></p>
<ul>
<li>You need to combine multiple wrapped values</li>
<li>Operations are independent (don't depend on each other's results)</li>
<li>You want to accumulate errors from multiple validations</li>
</ul>
<p><strong>Key Insight:</strong> <code>map2</code>, <code>map3</code>, etc. are built on <code>ap</code> for combining 2, 3, or more values</p>
<p><strong>Laws:</strong> Identity, Composition, Homomorphism, Interchange</p>
<p><strong>Common Patterns:</strong></p>
<ul>
<li>Form validation (collect all errors)</li>
<li>Combining configuration values</li>
<li>Parallel computations</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Combine two independent validations
Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, User&gt; userLogin = 
    applicative.map2(
        validateUsername(input.username()),
        validatePassword(input.password()),
        User::new
    );
</code></pre>
<p><strong>Think Of It As:</strong> Combining multiple "boxes" when contents are independent</p>
</div>
</div>
<h3 id="monad"><a class="header" href="#monad">Monad</a></h3>
<div id="admonition-monad-quick-reference" class="admonition admonish-tip" role="note" aria-labelledby="admonition-monad-quick-reference-title">
<div class="admonition-title">
<div id="admonition-monad-quick-reference-title">
<p>Monad Quick Reference</p>
</div>
<a class="admonition-anchor-link" href="hkts/quick_reference.html#admonition-monad-quick-reference"></a>
</div>
<div>
<p><strong>Core Method:</strong> <code>flatMap(Function&lt;A,Kind&lt;F,B&gt;&gt; f, Kind&lt;F,A&gt; fa) -&gt; Kind&lt;F,B&gt;</code></p>
<p><strong>Purpose:</strong> Sequence dependent computations within a context</p>
<p><strong>Use When:</strong></p>
<ul>
<li>Each step depends on the result of the previous step</li>
<li>You need to chain operations that return wrapped values</li>
<li>You want short-circuiting behaviour on failure</li>
</ul>
<p><strong>Key Difference from Applicative:</strong> Operations are sequential and dependent</p>
<p><strong>Laws:</strong></p>
<ul>
<li>Left Identity: <code>flatMap(f, of(a)) == f(a)</code></li>
<li>Right Identity: <code>flatMap(of, m) == m</code></li>
<li>Associativity: <code>flatMap(g, flatMap(f, m)) == flatMap(x -&gt; flatMap(g, f(x)), m)</code></li>
</ul>
<p><strong>Utility Methods:</strong></p>
<ul>
<li><code>as(B value, Kind&lt;F,A&gt; fa)</code> - replace value, keep effect</li>
<li><code>peek(Consumer&lt;A&gt; action, Kind&lt;F,A&gt; fa)</code> - side effect without changing value</li>
<li><code>flatMap2/3/4/5(...)</code> - combine multiple monadic values where the combining function itself returns a monadic value (useful for dependent validations or operations)</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Chain database operations where each depends on the previous
Kind&lt;OptionalKind.Witness, Account&gt; account =
    monad.flatMap(userLogin -&gt;
        monad.flatMap(profile -&gt;
            findAccount(profile.accountId()),
            findProfile(userLogin.id())),
        findUser(userId));

// Combine multiple monadic values with effectful result
Kind&lt;OptionalKind.Witness, Order&gt; order =
    monad.flatMap2(
        findUser(userId),
        findProduct(productId),
        (user, product) -&gt; validateAndCreateOrder(user, product) // Returns Optional
    );
</code></pre>
<p><strong>Think Of It As:</strong> Chaining operations where each "opens the box" and "puts result in new box"</p>
</div>
</div>
<h3 id="monaderror"><a class="header" href="#monaderror">MonadError</a></h3>
<div id="admonition-monaderror-quick-reference" class="admonition admonish-tip" role="note" aria-labelledby="admonition-monaderror-quick-reference-title">
<div class="admonition-title">
<div id="admonition-monaderror-quick-reference-title">
<p>MonadError Quick Reference</p>
</div>
<a class="admonition-anchor-link" href="hkts/quick_reference.html#admonition-monaderror-quick-reference"></a>
</div>
<div>
<p><strong>Core Methods:</strong></p>
<ul>
<li><code>raiseError(E error) -&gt; Kind&lt;F,A&gt;</code> (create error state)</li>
<li><code>handleErrorWith(Kind&lt;F,A&gt; fa, Function&lt;E,Kind&lt;F,A&gt;&gt; handler) -&gt; Kind&lt;F,A&gt;</code> (recover from error)</li>
</ul>
<p><strong>Purpose:</strong> Add explicit error handling to monadic computations</p>
<p><strong>Use When:</strong></p>
<ul>
<li>You need to handle specific error types</li>
<li>You want to recover from failures in a workflow</li>
<li>You need to distinguish between different kinds of failures</li>
</ul>
<p><strong>Key Insight:</strong> Error type <code>E</code> is fixed for each MonadError instance</p>
<p><strong>Common Error Types:</strong></p>
<ul>
<li><code>Throwable</code> for CompletableFuture</li>
<li><code>Unit</code> for Optional/Maybe (absence as error)</li>
<li>Custom domain error types for Either/Validated</li>
</ul>
<p><strong>Recovery Methods:</strong></p>
<ul>
<li><code>handleError(fa, Function&lt;E,A&gt; handler)</code> - recover to pure value</li>
<li><code>recover(fa, A defaultValue)</code> - provide default value</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Handle division by zero gracefully
Kind&lt;EitherKind.Witness&lt;String&gt;, Double&gt; result = 
    monadError.handleErrorWith(
        divideOperation,
        error -&gt; monadError.of(0.0) // recover with default
    );
</code></pre>
<p><strong>Think Of It As:</strong> try-catch for functional programming</p>
</div>
</div>
<h3 id="selective"><a class="header" href="#selective">Selective</a></h3>
<div id="admonition-selective-quick-reference" class="admonition admonish-tip" role="note" aria-labelledby="admonition-selective-quick-reference-title">
<div class="admonition-title">
<div id="admonition-selective-quick-reference-title">
<p>Selective Quick Reference</p>
</div>
<a class="admonition-anchor-link" href="hkts/quick_reference.html#admonition-selective-quick-reference"></a>
</div>
<div>
<p><strong>Core Methods:</strong></p>
<ul>
<li><code>select(Kind&lt;F,Choice&lt;A,B&gt;&gt; fab, Kind&lt;F,Function&lt;A,B&gt;&gt; ff) -&gt; Kind&lt;F,B&gt;</code> (conditional function application)</li>
<li><code>whenS(Kind&lt;F,Boolean&gt; cond, Kind&lt;F,Unit&gt; effect) -&gt; Kind&lt;F,Unit&gt;</code> (conditional effect)</li>
<li><code>ifS(Kind&lt;F,Boolean&gt; cond, Kind&lt;F,A&gt; then, Kind&lt;F,A&gt; else) -&gt; Kind&lt;F,A&gt;</code> (if-then-else)</li>
</ul>
<p><strong>Purpose:</strong> Execute effects conditionally with static structure (all branches known upfront)</p>
<p><strong>Use When:</strong></p>
<ul>
<li>You need conditional effects but want static analysis</li>
<li>All possible branches should be visible at construction time (enabling static analysis)</li>
<li>You want more power than Applicative but less than Monad</li>
<li>Building feature flags, conditional logging, or validation with alternatives</li>
</ul>
<p><strong>Key Insight:</strong> Sits between Applicative and Monad - provides conditional effects without full dynamic choice</p>
<p><strong>Common Patterns:</strong></p>
<ul>
<li>Feature flag activation</li>
<li>Debug/production mode switching</li>
<li>Multi-source configuration fallback</li>
<li>Conditional validation</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Only log if debug flag is enabled
Selective&lt;IOKind.Witness&gt; selective = IOSelective.INSTANCE;

Kind&lt;IOKind.Witness, Boolean&gt; debugEnabled =
    IO_KIND.widen(IO.delay(() -&gt; config.isDebug()));
Kind&lt;IOKind.Witness, Unit&gt; logEffect =
    IO_KIND.widen(IO.fromRunnable(() -&gt; log.debug("Debug info")));

Kind&lt;IOKind.Witness, Unit&gt; conditionalLog = selective.whenS(debugEnabled, logEffect);
// Log effect only executes if debugEnabled is true
</code></pre>
<p><strong>Think Of It As:</strong> If-then-else for functional programming with compile-time visible branches</p>
</div>
</div>
<h2 id="data-combination-type-classes"><a class="header" href="#data-combination-type-classes">Data Combination Type Classes</a></h2>
<h3 id="semigroup"><a class="header" href="#semigroup">Semigroup</a></h3>
<div id="admonition-semigroup-quick-reference" class="admonition admonish-tip" role="note" aria-labelledby="admonition-semigroup-quick-reference-title">
<div class="admonition-title">
<div id="admonition-semigroup-quick-reference-title">
<p>Semigroup Quick Reference</p>
</div>
<a class="admonition-anchor-link" href="hkts/quick_reference.html#admonition-semigroup-quick-reference"></a>
</div>
<div>
<p><strong>Core Method:</strong> <code>combine(A a1, A a2) -&gt; A</code></p>
<p><strong>Purpose:</strong> Types that can be combined associatively</p>
<p><strong>Key Property:</strong> Associativity - <code>combine(a, combine(b, c)) == combine(combine(a, b), c)</code></p>
<p><strong>Use When:</strong></p>
<ul>
<li>You need to combine/merge two values of the same type</li>
<li>Order of combination doesn't matter (due to associativity)</li>
<li>Building blocks for parallel processing</li>
</ul>
<p><strong>Common Instances:</strong></p>
<ul>
<li>String concatenation: <code>"a" + "b" + "c"</code></li>
<li>Integer addition: <code>1 + 2 + 3</code></li>
<li>List concatenation: <code>[1,2] + [3,4] + [5,6]</code></li>
<li>Set union: <code>{1,2} ∪ {2,3} ∪ {3,4}</code></li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Combine error messages
Semigroup&lt;String&gt; stringConcat = Semigroups.string("; ");
String combined = stringConcat.combine("Error 1", "Error 2");
// Result: "Error 1; Error 2"
</code></pre>
<p><strong>Think Of It As:</strong> The <code>+</code> operator generalised to any type</p>
</div>
</div>
<h3 id="monoid"><a class="header" href="#monoid">Monoid</a></h3>
<div id="admonition-monoid-quick-reference" class="admonition admonish-tip" role="note" aria-labelledby="admonition-monoid-quick-reference-title">
<div class="admonition-title">
<div id="admonition-monoid-quick-reference-title">
<p>Monoid Quick Reference</p>
</div>
<a class="admonition-anchor-link" href="hkts/quick_reference.html#admonition-monoid-quick-reference"></a>
</div>
<div>
<p><strong>Core Methods:</strong></p>
<ul>
<li><code>combine(A a1, A a2) -&gt; A</code> (from Semigroup)</li>
<li><code>empty() -&gt; A</code> (identity element)</li>
</ul>
<p><strong>Purpose:</strong> Semigroups with an identity/neutral element</p>
<p><strong>Key Properties:</strong></p>
<ul>
<li>Associativity (from Semigroup)</li>
<li>Identity: <code>combine(a, empty()) == combine(empty(), a) == a</code></li>
</ul>
<p><strong>Use When:</strong></p>
<ul>
<li>You need a starting value for reductions/folds</li>
<li>Implementing fold operations over data structures</li>
<li>You might be combining zero elements</li>
</ul>
<p><strong>Common Instances:</strong></p>
<ul>
<li>String: empty = <code>""</code>, combine = concatenation</li>
<li>Integer addition: empty = <code>0</code>, combine = <code>+</code></li>
<li>Integer multiplication: empty = <code>1</code>, combine = <code>*</code></li>
<li>List: empty = <code>[]</code>, combine = concatenation</li>
<li>Boolean AND: empty = <code>true</code>, combine = <code>&amp;&amp;</code></li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Sum a list using integer addition monoid
Integer sum = listFoldable.foldMap(
    Monoids.integerAddition(),
    Function.identity(),
    numbersList
);
</code></pre>
<p><strong>Think Of It As:</strong> Semigroup + a "starting point" for combinations</p>
</div>
</div>
<h2 id="structure-iterating-type-classes"><a class="header" href="#structure-iterating-type-classes">Structure-Iterating Type Classes</a></h2>
<h3 id="foldable"><a class="header" href="#foldable">Foldable</a></h3>
<div id="admonition-foldable-quick-reference" class="admonition admonish-tip" role="note" aria-labelledby="admonition-foldable-quick-reference-title">
<div class="admonition-title">
<div id="admonition-foldable-quick-reference-title">
<p>Foldable Quick Reference</p>
</div>
<a class="admonition-anchor-link" href="hkts/quick_reference.html#admonition-foldable-quick-reference"></a>
</div>
<div>
<p><strong>Core Method:</strong> <code>foldMap(Monoid&lt;M&gt; monoid, Function&lt;A,M&gt; f, Kind&lt;F,A&gt; fa) -&gt; M</code></p>
<p><strong>Purpose:</strong> Reduce a data structure to a single summary value</p>
<p><strong>Use When:</strong></p>
<ul>
<li>You want to aggregate/summarise data in a structure</li>
<li>You need different types of reductions (sum, concat, any/all, etc.)</li>
<li>You want to count, find totals, or collapse collections</li>
</ul>
<p><strong>Key Insight:</strong> Different Monoids give different aggregations from same data</p>
<p><strong>Common Operations:</strong></p>
<ul>
<li>Sum numbers: use integer addition monoid</li>
<li>Concatenate strings: use string monoid</li>
<li>Check all conditions: use boolean AND monoid</li>
<li>Count elements: map to 1, use integer addition monoid</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Multiple aggregations of the same list
List&lt;Integer&gt; numbers = List.of(1, 2, 3, 4, 5);

// Sum
Integer sum = foldable.foldMap(Monoids.integerAddition(), 
    Function.identity(), numbers); // 15

// Concatenate as strings  
String concat = foldable.foldMap(Monoids.string(), 
    String::valueOf, numbers); // "12345"

// Check all positive
Boolean allPositive = foldable.foldMap(Monoids.booleanAnd(), 
    n -&gt; n &gt; 0, numbers); // true
</code></pre>
<p><strong>Think Of It As:</strong> Swiss Army knife for data aggregation</p>
</div>
</div>
<h3 id="traverse"><a class="header" href="#traverse">Traverse</a></h3>
<div id="admonition-traverse-quick-reference" class="admonition admonish-tip" role="note" aria-labelledby="admonition-traverse-quick-reference-title">
<div class="admonition-title">
<div id="admonition-traverse-quick-reference-title">
<p>Traverse Quick Reference</p>
</div>
<a class="admonition-anchor-link" href="hkts/quick_reference.html#admonition-traverse-quick-reference"></a>
</div>
<div>
<p><strong>Core Method:</strong> <code>traverse(Applicative&lt;G&gt; app, Function&lt;A,Kind&lt;G,B&gt;&gt; f, Kind&lt;F,A&gt; fa) -&gt; Kind&lt;G,Kind&lt;F,B&gt;&gt;</code></p>
<p><strong>Purpose:</strong> Apply an effectful function to each element and "flip" the contexts</p>
<p><strong>Use When:</strong></p>
<ul>
<li>You have a collection and want to apply an effect to each element</li>
<li>You want to validate every item and collect all errors</li>
<li>You need to "turn inside-out": <code>F&lt;G&lt;A&gt;&gt;</code> becomes <code>G&lt;F&lt;A&gt;&gt;</code></li>
</ul>
<p><strong>Key Operations:</strong></p>
<ul>
<li><code>traverse</code>: apply function then flip</li>
<li><code>sequence</code>: just flip contexts (when you already have <code>F&lt;G&lt;A&gt;&gt;</code>)</li>
</ul>
<p><strong>Common Patterns:</strong></p>
<ul>
<li>Validate every item in a list</li>
<li>Make async calls for each element</li>
<li>Parse/process each item, collecting all failures</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Validate every string in a list, collect all errors
List&lt;String&gt; inputs = List.of("123", "abc", "456");

Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Kind&lt;ListKind.Witness, Integer&gt;&gt; result =
    listTraverse.traverse(
        validatedApplicative,
        this::parseInteger, // String -&gt; Validated&lt;List&lt;String&gt;, Integer&gt;
        LIST.widen(inputs)
    );

// Result: either Valid(List[123, 456]) or Invalid(["abc is not a number"])
</code></pre>
<p><strong>Think Of It As:</strong> Applying effects to collections while flipping the "nesting order"</p>
</div>
</div>
<h2 id="dual-parameter-type-classes"><a class="header" href="#dual-parameter-type-classes">Dual-Parameter Type Classes</a></h2>
<h3 id="profunctor"><a class="header" href="#profunctor">Profunctor</a></h3>
<div id="admonition-profunctor-quick-reference" class="admonition admonish-tip" role="note" aria-labelledby="admonition-profunctor-quick-reference-title">
<div class="admonition-title">
<div id="admonition-profunctor-quick-reference-title">
<p>Profunctor Quick Reference</p>
</div>
<a class="admonition-anchor-link" href="hkts/quick_reference.html#admonition-profunctor-quick-reference"></a>
</div>
<div>
<p><strong>Core Methods:</strong></p>
<ul>
<li><code>lmap(Function&lt;C,A&gt; f, Kind2&lt;P,A,B&gt; pab) -&gt; Kind2&lt;P,C,B&gt;</code> (contravariant on input)</li>
<li><code>rmap(Function&lt;B,D&gt; g, Kind2&lt;P,A,B&gt; pab) -&gt; Kind2&lt;P,A,D&gt;</code> (covariant on output)</li>
<li><code>dimap(Function&lt;C,A&gt; f, Function&lt;B,D&gt; g, Kind2&lt;P,A,B&gt; pab) -&gt; Kind2&lt;P,C,D&gt;</code> (both)</li>
</ul>
<p><strong>Purpose:</strong> Adapt inputs and outputs of two-parameter types (especially functions)</p>
<p><strong>Use When:</strong></p>
<ul>
<li>Building flexible data transformation pipelines</li>
<li>Creating API adapters that convert between different formats</li>
<li>You need to preprocess inputs or postprocess outputs</li>
<li>Building reusable validation or transformation logic</li>
</ul>
<p><strong>Key Insight:</strong></p>
<ul>
<li><code>lmap</code> = preprocess the input (contravariant)</li>
<li><code>rmap</code> = postprocess the output (covariant)</li>
<li><code>dimap</code> = do both transformations</li>
</ul>
<p><strong>Common Instance:</strong> <code>Function&lt;A,B&gt;</code> is the canonical Profunctor</p>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Adapt a string length function to work with integers and return formatted strings
Function&lt;String, Integer&gt; stringLength = String::length;

// Input adaptation: Integer -&gt; String  
Kind2&lt;FunctionKind.Witness, Integer, Integer&gt; intToLength = 
    profunctor.lmap(Object::toString, FUNCTION.widen(stringLength));

// Output adaptation: Integer -&gt; String
Kind2&lt;FunctionKind.Witness, String, String&gt; lengthToString = 
    profunctor.rmap(len -&gt; "Length: " + len, FUNCTION.widen(stringLength));

// Both adaptations
Kind2&lt;FunctionKind.Witness, Integer, String&gt; fullAdaptation = 
    profunctor.dimap(Object::toString, len -&gt; "Result: " + len, 
        FUNCTION.widen(stringLength));
</code></pre>
<p><strong>Think Of It As:</strong> The adapter pattern for functional programming</p>
</div>
</div>
<h2 id="decision-guide-1"><a class="header" href="#decision-guide-1">Decision Guide</a></h2>
<div id="admonition-choosing-the-right-type-class" class="admonition admonish-warning" role="note" aria-labelledby="admonition-choosing-the-right-type-class-title">
<div class="admonition-title">
<div id="admonition-choosing-the-right-type-class-title">
<p>Choosing the Right Type Class</p>
</div>
<a class="admonition-anchor-link" href="hkts/quick_reference.html#admonition-choosing-the-right-type-class"></a>
</div>
<div>
<p><strong>Start Simple, Go Complex:</strong></p>
<ol>
<li><strong>Functor</strong> - Simple transformations, context unchanged</li>
<li><strong>Applicative</strong> - Combine independent computations</li>
<li><strong>Selective</strong> OR <strong>Monad</strong> - Choose based on needs:
<ul>
<li><strong>Selective</strong>: Conditional effects with all branches visible upfront (static analysis)</li>
<li><strong>Monad</strong>: Chain dependent computations with dynamic choice</li>
</ul>
</li>
<li><strong>MonadError</strong> - Add error handling to Monad</li>
<li><strong>Traverse</strong> - Apply effects to collections</li>
<li><strong>Profunctor</strong> - Adapt inputs/outputs of functions</li>
</ol>
<p><strong>Decision Tree:</strong></p>
<ul>
<li>Need to transform values? → <strong>Functor</strong></li>
<li>Need to combine independent operations? → <strong>Applicative</strong></li>
<li>Need conditional effects with static structure? → <strong>Selective</strong></li>
<li>Need sequential dependent operations? → <strong>Monad</strong> (chain dependent computations with dynamic choices based on previous results)</li>
<li>Need error recovery? → <strong>MonadError</strong></li>
<li>Need to process collections with effects? → <strong>Traverse</strong></li>
<li>Need to adapt function interfaces? → <strong>Profunctor</strong></li>
<li>Need to aggregate/summarise data? → <strong>Foldable</strong></li>
<li>Need to combine values? → <strong>Semigroup/Monoid</strong></li>
</ul>
<p><strong>Common Patterns:</strong></p>
<ul>
<li><strong>Form validation:</strong> Applicative (independent fields) or Traverse (list of fields)</li>
<li><strong>Database operations:</strong> Monad (dependent queries) + MonadError (failure handling)</li>
<li><strong>API integration:</strong> Profunctor (adapt formats) + Monad (chain calls)</li>
<li><strong>Configuration:</strong> Applicative (combine settings) + Reader (dependency injection)</li>
<li><strong>Conditional effects:</strong> Selective (feature flags, debug mode) or Monad (dynamic choice)</li>
<li><strong>Configuration fallback:</strong> Selective (try multiple sources with static branches)</li>
<li><strong>Logging:</strong> Writer (accumulate logs) + Monad (sequence operations)</li>
<li><strong>State management:</strong> State/StateT (thread state) + Monad (sequence updates)</li>
</ul>
</div>
</div>
<h2 id="type-hierarchy"><a class="header" href="#type-hierarchy">Type Hierarchy</a></h2>
<div id="admonition-type-class-relationships" class="admonition admonish-info" role="note" aria-labelledby="admonition-type-class-relationships-title">
<div class="admonition-title">
<div id="admonition-type-class-relationships-title">
<p>Type Class Relationships</p>
</div>
<a class="admonition-anchor-link" href="hkts/quick_reference.html#admonition-type-class-relationships"></a>
</div>
<div>
<pre><code>        Functor
            ↑
    Applicative ← Apply
       ↗    ↖
Selective   Monad
               ↑
          MonadError

Semigroup
    ↑
  Monoid

Functor + Foldable
    ↑
 Traverse

(Two-parameter types)
Profunctor
Bifunctor
</code></pre>
<p><strong>Inheritance Meaning:</strong></p>
<ul>
<li>Every <strong>Applicative</strong> is also a <strong>Functor</strong></li>
<li>Every <strong>Selective</strong> is also an <strong>Applicative</strong> (and therefore a <strong>Functor</strong>)</li>
<li>Every <strong>Monad</strong> is also an <strong>Applicative</strong> (and therefore a <strong>Functor</strong>)</li>
<li>Every <strong>MonadError</strong> is also a <strong>Monad</strong> (and therefore <strong>Applicative</strong> and <strong>Functor</strong>)</li>
<li><strong>Selective</strong> and <strong>Monad</strong> are siblings - both extend <strong>Applicative</strong> directly</li>
<li>Every <strong>Monoid</strong> is also a <strong>Semigroup</strong></li>
<li>Every <strong>Traverse</strong> provides both <strong>Functor</strong> and <strong>Foldable</strong> capabilities</li>
</ul>
<p><strong>Practical Implication:</strong> If you have a <code>Monad&lt;F&gt;</code> instance, you can also use it as an <code>Applicative&lt;F&gt;</code> or <code>Functor&lt;F&gt;</code>. Selective and Monad are alternative extensions of Applicative with different trade-offs.</p>
</div>
</div>
<h2 id="common-monoid-instances"><a class="header" href="#common-monoid-instances">Common Monoid Instances</a></h2>
<div id="admonition-ready-to-use-monoids" class="admonition admonish-note" role="note" aria-labelledby="admonition-ready-to-use-monoids-title">
<div class="admonition-title">
<div id="admonition-ready-to-use-monoids-title">
<p>Ready-to-Use Monoids</p>
</div>
<a class="admonition-anchor-link" href="hkts/quick_reference.html#admonition-ready-to-use-monoids"></a>
</div>
<div>
<p><strong>Numeric:</strong></p>
<ul>
<li><code>Monoids.integerAddition()</code> - sum integers (empty = 0)</li>
<li><code>Monoids.integerMultiplication()</code> - multiply integers (empty = 1)</li>
</ul>
<p><strong>Text:</strong></p>
<ul>
<li><code>Monoids.string()</code> - concatenate strings (empty = "")</li>
<li><code>Monoids.string(delimiter)</code> - join with delimiter</li>
</ul>
<p><strong>Boolean:</strong></p>
<ul>
<li><code>Monoids.booleanAnd()</code> - logical AND (empty = true)</li>
<li><code>Monoids.booleanOr()</code> - logical OR (empty = false)</li>
</ul>
<p><strong>Collections:</strong></p>
<ul>
<li><code>Monoids.list()</code> - concatenate lists (empty = [])</li>
</ul>
<p><strong>Custom:</strong></p>
<pre><code class="language-java">// Create your own monoid
Monoid&lt;MyType&gt; myMonoid = new Monoid&lt;MyType&gt;() {
    public MyType empty() { return MyType.defaultValue(); }
    public MyType combine(MyType a, MyType b) { return a.mergeWith(b); }
};
</code></pre>
</div>
</div>
<h2 id="performance-notes-14"><a class="header" href="#performance-notes-14">Performance Notes</a></h2>
<div id="admonition-performance-considerations" class="admonition admonish-warning" role="note" aria-labelledby="admonition-performance-considerations-title">
<div class="admonition-title">
<div id="admonition-performance-considerations-title">
<p>Performance Considerations</p>
</div>
<a class="admonition-anchor-link" href="hkts/quick_reference.html#admonition-performance-considerations"></a>
</div>
<div>
<p><strong>When to Use HKT vs Direct Methods:</strong></p>
<p><strong>Use HKT When:</strong></p>
<ul>
<li>Writing generic code that works with multiple container types</li>
<li>Building complex workflows with multiple type classes</li>
<li>You need the power of type class composition</li>
</ul>
<p><strong>Use Direct Methods When:</strong></p>
<ul>
<li>Simple, one-off transformations</li>
<li>Performance-critical hot paths</li>
<li>Working with a single, known container type</li>
</ul>
<p><strong>Examples:</strong></p>
<pre><code class="language-java">// Hot path - use direct method
Optional&lt;String&gt; result = optional.map(String::toUpperCase);

// Generic reusable code - use HKT
public static &lt;F&gt; Kind&lt;F, String&gt; normalise(Functor&lt;F&gt; functor, Kind&lt;F, String&gt; input) {
    return functor.map(String::toUpperCase, input);
}
</code></pre>
<p><strong>Memory:</strong> HKT simulation adds minimal overhead (single wrapper object per operation)
<strong>CPU:</strong> Direct method calls vs type class method calls are comparable in modern JVMs</p>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="hkts/hkt_basic_examples.html">Basic HKT Examples</a>
<strong>Next:</strong> <a href="hkts/extending-simulation.html">Extending</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="extending-higher-kinded-type-simulation"><a class="header" href="#extending-higher-kinded-type-simulation">Extending Higher Kinded Type Simulation</a></h1>
<p><img src="hkts/../images/extending-crane.png" alt="extending-crane.png" /></p>
<p>You can add support for new Java types (type constructors) to the Higher-Kinded-J simulation framework, allowing them to be used with type classes like <code>Functor</code>, <code>Monad</code>, etc.</p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="hkts/extending-simulation.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to integrate new types into the Higher-Kinded-J framework</li>
<li>The pattern for adapting external types you don't control using holder records</li>
<li>How to design custom library types that directly implement Kind interfaces</li>
<li>Creating Kind interfaces with Witness types for type-level programming</li>
<li>Building ConverterOps interfaces and KindHelper enums for type conversions</li>
<li>Best practices for implementing type class instances for custom types</li>
</ul>
</div>
</div>
<p>There are two main scenarios:</p>
<ol>
<li><strong>Adapting External Types</strong>: For types you don't own (e.g., JDK classes like <code>java.util.Set</code>, <code>java.util.Map</code>, or classes from other libraries).</li>
<li><strong>Integrating Custom Library Types</strong>: For types defined within your own project or a library you control, where you can modify the type itself.</li>
</ol>
<blockquote>
<p><strong>Note:</strong> Within Higher-Kinded-J, core library types like <code>IO</code>, <code>Maybe</code>, and <code>Either</code> follow Scenario 2: they directly implement their respective Kind interfaces (<code>IOKind</code>, <code>MaybeKind</code>, <code>EitherKind</code>). This provides zero runtime overhead for widen/narrow operations.</p>
</blockquote>
<p>The core pattern involves creating:</p>
<ul>
<li>An <code>XxxKind</code> interface with a nested <code>Witness</code> type (this remains the same).</li>
<li>An <code>XxxConverterOps</code> interface defining the <code>widen</code> and <code>narrow</code> operations for the specific type.</li>
<li>An <code>XxxKindHelper</code> <strong>enum</strong> that implements <code>XxxConverterOps</code> and provides a singleton instance (e.g., <code>SET</code>, <code>MY_TYPE</code>) for accessing these operations as instance methods.</li>
<li>Type class instances (e.g., for <code>Functor</code>, <code>Monad</code>).</li>
</ul>
<p>For external types, an additional <code>XxxHolder</code> record is typically used internally by the helper enum to wrap the external type.</p>
<h2 id="scenario-1-adapting-an-external-type-eg-javautilseta"><a class="header" href="#scenario-1-adapting-an-external-type-eg-javautilseta">Scenario 1: Adapting an External Type (e.g., <code>java.util.Set&lt;A&gt;</code>)</a></h2>
<p>Since we cannot modify <code>java.util.Set</code> to directly implement our <code>Kind</code> structure, we need a wrapper (a <code>Holder</code>).</p>
<p><strong>Goal:</strong> Simulate <code>java.util.Set&lt;A&gt;</code> as <code>Kind&lt;SetKind.Witness, A&gt;</code> and provide <code>Functor</code>, <code>Applicative</code>, and <code>Monad</code> instances for it.</p>
<p><strong>Note:</strong> This pattern is useful when integrating third-party libraries or JDK types that you cannot modify directly.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="hkts/extending-simulation.html#admonition-note"></a>
</div>
<div>
<ol>
<li>
<p><strong>Create the <code>Kind</code> Interface with Witness (<code>SetKind.java</code>)</strong>:</p>
<ul>
<li>Define a marker interface that extends <code>Kind&lt;SetKind.Witness, A&gt;</code>.</li>
<li>Inside this interface, define a <code>static final class Witness {}</code> which will serve as the phantom type <code>F</code> for <code>Set</code>.</li>
</ul>
<pre><code class="language-java">package org.higherkindedj.hkt.set; // Example package

import org.higherkindedj.hkt.Kind;
import org.jspecify.annotations.NullMarked;

/**
 * Kind interface marker for java.util.Set&lt;A&gt;.
 * The Witness type F = SetKind.Witness
 * The Value type A = A
 */
@NullMarked
public interface SetKind&lt;A&gt; extends Kind&lt;SetKind.Witness, A&gt; {
  /**
   * Witness type for {@link java.util.Set} to be used with {@link Kind}.
   */
  final class Witness {
    private Witness() {} 
  }
}
</code></pre>
</li>
<li>
<p><strong>Create the <code>ConverterOps</code> Interface (<code>SetConverterOps.java</code>)</strong>:</p>
<ul>
<li>Define an interface specifying the <code>widen</code> and <code>narrow</code> methods for <code>Set</code>.</li>
</ul>
<pre><code class="language-java">package org.higherkindedj.hkt.set;

import java.util.Set;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.exception.KindUnwrapException; // If narrow throws it
import org.jspecify.annotations.NonNull;
import org.jspecify.annotations.Nullable;

public interface SetConverterOps {
  &lt;A&gt; @NonNull Kind&lt;SetKind.Witness, A&gt; widen(@NonNull Set&lt;A&gt; set);
  &lt;A&gt; @NonNull Set&lt;A&gt; narrow(@Nullable Kind&lt;SetKind.Witness, A&gt; kind) throws KindUnwrapException;
}
</code></pre>
</li>
<li>
<p><strong>Create the <code>KindHelper</code> Enum with an Internal <code>Holder</code> (<code>SetKindHelper.java</code>)</strong>:</p>
<ul>
<li>Define an <code>enum</code> (e.g., <code>SetKindHelper</code>) that implements <code>SetConverterOps</code>.</li>
<li>Provide a singleton instance (e.g., <code>SET</code>).</li>
<li>Inside this helper, define a package-private <code>record SetHolder&lt;A&gt;(@NonNull Set&lt;A&gt; set) implements SetKind&lt;A&gt; {}</code>. This record wraps the actual <code>java.util.Set</code>.</li>
<li><strong><code>widen</code> method</strong>: Takes the Java type (e.g., <code>Set&lt;A&gt;</code>), performs null checks, and returns a new <code>SetHolder&lt;&gt;(set)</code> cast to <code>Kind&lt;SetKind.Witness, A&gt;</code>.</li>
<li><strong><code>narrow</code> method</strong>: Takes <code>Kind&lt;SetKind.Witness, A&gt; kind</code>, performs null checks, verifies <code>kind instanceof SetHolder</code>, extracts the underlying <code>Set&lt;A&gt;</code>, and returns it. It throws <code>KindUnwrapException</code> for any structural invalidity.</li>
</ul>
<pre><code class="language-java">package org.higherkindedj.hkt.set;

import java.util.Objects;
import java.util.Set;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.exception.KindUnwrapException;
import org.jspecify.annotations.NonNull;
import org.jspecify.annotations.Nullable;

public enum SetKindHelper implements SetConverterOps {
    SET; // Singleton instance

    // Error messages can be static final within the enum
    private static final String ERR_INVALID_KIND_NULL = "Cannot narrow null Kind for Set";
    private static final String ERR_INVALID_KIND_TYPE = "Kind instance is not a SetHolder: ";
    private static final String ERR_INVALID_KIND_TYPE_NULL = "Input Set cannot be null for widen";
  
    // Holder Record (package-private for testability if needed)
    record SetHolder&lt;AVal&gt;(@NonNull Set&lt;AVal&gt; set) implements SetKind&lt;AVal&gt; { }

    @Override
    public &lt;A&gt; @NonNull Kind&lt;SetKind.Witness, A&gt; widen(@NonNull Set&lt;A&gt; set) {
        Objects.requireNonNull(set, ERR_INVALID_KIND_TYPE_NULL);
        return  new SetHolder&lt;&gt;(set);
    }

    @Override
    public &lt;A&gt; @NonNull Set&lt;A&gt; narrow(@Nullable Kind&lt;SetKind.Witness, A&gt; kind) {
        if (kind == null) {
            throw new KindUnwrapException(ERR_INVALID_KIND_NULL);
        }
        if (kind instanceof SetHolder&lt;?&gt; holder) { 
            // SetHolder's 'set' component is @NonNull, so holder.set() is guaranteed non-null.
            return (Set&lt;A&gt;) holder.set();
        } else {
            throw new KindUnwrapException(ERR_INVALID_KIND_TYPE + kind.getClass().getName());
        }
    }
}
</code></pre>
</li>
</ol>
</div>
</div>
<h2 id="scenario-2-integrating-a-custom-library-type"><a class="header" href="#scenario-2-integrating-a-custom-library-type">Scenario 2: Integrating a Custom Library Type</a></h2>
<p>If you are defining a new type <em>within your library</em> (e.g., a custom <code>MyType&lt;A&gt;</code>), you can design it to directly participate in the HKT simulation. This approach typically doesn't require an explicit <code>Holder</code> record if your type can directly implement the <code>XxxKind</code> interface.</p>
<blockquote>
<p><strong>Examples in Higher-Kinded-J:</strong> <code>IO&lt;A&gt;</code>, <code>Maybe&lt;A&gt;</code> (via <code>Just&lt;T&gt;</code> and <code>Nothing&lt;T&gt;</code>), <code>Either&lt;L,R&gt;</code> (via <code>Left</code> and <code>Right</code>), <code>Validated&lt;E,A&gt;</code>, <code>Id&lt;A&gt;</code>, and monad transformers all use this pattern. Their widen/narrow operations are simple type-safe casts with no wrapper object allocation.</p>
</blockquote>
<div id="admonition-note-1" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-1-title">
<div class="admonition-title">
<div id="admonition-note-1-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="hkts/extending-simulation.html#admonition-note-1"></a>
</div>
<div>
<ol>
<li>
<p><strong>Define Your Type and its <code>Kind</code> Interface</strong>:</p>
<ul>
<li>Your custom type (e.g., <code>MyType&lt;A&gt;</code>) directly implements its corresponding <code>MyTypeKind&lt;A&gt;</code> interface.</li>
<li><code>MyTypeKind&lt;A&gt;</code> extends <code>Kind&lt;MyType.Witness, A&gt;</code> and defines the nested <code>Witness</code> class. (This part remains unchanged).</li>
</ul>
<pre><code class="language-java">package org.example.mytype;

import org.higherkindedj.hkt.Kind;
import org.jspecify.annotations.NullMarked;

// 1. The Kind Interface with Witness
@NullMarked
public interface MyTypeKind&lt;A&gt; extends Kind&lt;MyType.Witness, A&gt; {
  /** Witness type for MyType. */
  final class Witness { private Witness() {} }
}

// 2. Your Custom Type directly implements its Kind interface
public record MyType&lt;A&gt;(A value) implements MyTypeKind&lt;A&gt; {
    // ... constructors, methods for MyType ...
}
</code></pre>
</li>
<li>
<p><strong>Create the <code>ConverterOps</code> Interface (<code>MyTypeConverterOps.java</code>)</strong>:</p>
<ul>
<li>Define an interface specifying the <code>widen</code> and <code>narrow</code> methods for <code>MyType</code>.</li>
</ul>
<pre><code class="language-java">package org.example.mytype;

import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.exception.KindUnwrapException;
import org.jspecify.annotations.NonNull;
import org.jspecify.annotations.Nullable;

public interface MyTypeConverterOps {
    &lt;A&gt; @NonNull Kind&lt;MyType.Witness, A&gt; widen(@NonNull MyType&lt;A&gt; myTypeValue);
    &lt;A&gt; @NonNull MyType&lt;A&gt; narrow(@Nullable Kind&lt;MyType.Witness, A&gt; kind) throws KindUnwrapException;
}
</code></pre>
</li>
<li>
<p><strong>Create the <code>KindHelper</code> Enum (<code>MyTypeKindHelper.java</code>)</strong>:</p>
<ul>
<li>Define an <code>enum</code> (e.g., <code>MyTypeKindHelper</code>) that implements <code>MyTypeConverterOps</code>.</li>
<li>Provide a singleton instance (e.g., <code>MY_TYPE</code>).</li>
<li><strong><code>widen(MyType&lt;A&gt; myTypeValue)</code></strong>: Since <code>MyType&lt;A&gt;</code> <em>is</em> already a <code>MyTypeKind&lt;A&gt;</code> (and thus a <code>Kind</code>), this method performs a null check and then a direct cast.</li>
<li><strong><code>narrow(Kind&lt;MyType.Witness, A&gt; kind)</code></strong>: This method checks <code>if (kind instanceof MyType&lt;?&gt; myTypeInstance)</code> and then casts and returns <code>myTypeInstance</code>.</li>
</ul>
<pre><code class="language-java">package org.example.mytype;

import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.exception.KindUnwrapException;
import org.jspecify.annotations.NonNull;
import org.jspecify.annotations.Nullable;
import java.util.Objects;

public enum MyTypeKindHelper implements MyTypeConverterOps {
    MY_TYPE; // Singleton instance

    private static final String ERR_INVALID_KIND_NULL = "Cannot narrow null Kind for MyType";
    private static final String ERR_INVALID_KIND_TYPE = "Kind instance is not a MyType: ";

    @Override
    @SuppressWarnings("unchecked") // MyType&lt;A&gt; is MyTypeKind&lt;A&gt; is Kind&lt;MyType.Witness, A&gt;
    public &lt;A&gt; @NonNull Kind&lt;MyType.Witness, A&gt; widen(@NonNull MyType&lt;A&gt; myTypeValue) {
        Objects.requireNonNull(myTypeValue, "Input MyType cannot be null for widen");
        return (MyTypeKind&lt;A&gt;) myTypeValue; // Direct cast
    }

    @Override
    @SuppressWarnings("unchecked")
    public &lt;A&gt; @NonNull MyType&lt;A&gt; narrow(@Nullable Kind&lt;MyType.Witness, A&gt; kind) {
        if (kind == null) {
            throw new KindUnwrapException(ERR_INVALID_KIND_NULL);
        }
        // Check if it's an instance of your actual type
        if (kind instanceof MyType&lt;?&gt; myTypeInstance) { // Pattern match for MyType
            return (MyType&lt;A&gt;) myTypeInstance; // Direct cast
        } else {
            throw new KindUnwrapException(ERR_INVALID_KIND_TYPE + kind.getClass().getName());
        }
    }
}
</code></pre>
</li>
<li>
<p><strong>Implement Type Class Instances</strong>:</p>
<ul>
<li>These will be similar to the external type scenario (e.g., <code>MyTypeMonad implements Monad&lt;MyType.Witness&gt;</code>), using <code>MyTypeKindHelper.MY_TYPE.widen(...)</code> and <code>MyTypeKindHelper.MY_TYPE.narrow(...)</code> (or with static import <code>MY_TYPE.widen(...)</code>).</li>
</ul>
</li>
</ol>
</div>
</div>
<div id="admonition-note-2" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-2-title">
<div class="admonition-title">
<div id="admonition-note-2-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="hkts/extending-simulation.html#admonition-note-2"></a>
</div>
<div>
<ul>
<li><strong>Immutability</strong>: Favour immutable data structures for your <code>Holder</code> or custom type if possible, as this aligns well with functional programming principles.</li>
<li><strong>Null Handling</strong>: Be very clear about null handling. Can the wrapped Java type be null? Can the value <code>A</code> inside be null? <code>KindHelper</code>'s <code>widen</code> method should typically reject a null container itself. <code>Monad.of(null)</code> behaviour depends on the specific monad (e.g., <code>OptionalMonad.OPTIONAL_MONAD.of(null)</code> is empty via <code>OPTIONAL.widen(Optional.empty())</code>, <code>ListMonad.LIST_MONAD.of(null)</code> might be an empty list or a list with a null element based on its definition).</li>
<li><strong>Testing</strong>: Thoroughly test your <code>XxxKindHelper</code> enum (especially <code>narrow</code> with invalid inputs) and your type class instances (Functor, Applicative, Monad laws).</li>
</ul>
<p>By following these patterns, you can integrate new or existing types into the Higher-Kinded-J framework, enabling them to be used with generic functional abstractions. The <code>KindHelper</code> enums, along with their corresponding <code>ConverterOps</code> interfaces, provide a standardised way to handle the <code>widen</code> and <code>narrow</code> conversions.</p>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="hkts/quick_reference.html">Quick Reference</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="foundations-type-classes"><a class="header" href="#foundations-type-classes">Foundations: Type Classes</a></h1>
<blockquote>
<p><em>"Quality is not a thing. It is an event."</em></p>
<p>– Robert M. Pirsig, <em>Zen and the Art of Motorcycle Maintenance</em></p>
</blockquote>
<hr />
<div id="admonition-using-type-classes-through-effect-paths" class="admonition admonish-tip" role="note" aria-labelledby="admonition-using-type-classes-through-effect-paths-title">
<div class="admonition-title">
<div id="admonition-using-type-classes-through-effect-paths-title">
<p>Using Type Classes Through Effect Paths</p>
</div>
<a class="admonition-anchor-link" href="functional/ch_intro.html#admonition-using-type-classes-through-effect-paths"></a>
</div>
<div>
<p>While type classes power the library internally, <strong>you rarely interact with them directly</strong>. The <a href="functional/../effect/ch_intro.html">Effect Path API</a> exposes these capabilities through a unified interface:</p>
<div class="table-wrapper"><table><thead><tr><th>Type Class</th><th>Effect Path Method</th></tr></thead><tbody>
<tr><td><code>Functor.map</code></td><td><code>path.map(f)</code></td></tr>
<tr><td><code>Monad.flatMap</code></td><td><code>path.via(f)</code></td></tr>
<tr><td><code>MonadError.handleErrorWith</code></td><td><code>path.recover(f)</code></td></tr>
<tr><td><code>Applicative.ap</code></td><td><code>path.ap(otherPath)</code></td></tr>
</tbody></table>
</div>
<p>Read this chapter to understand the foundations. Use Effect Paths for everyday programming.</p>
</div>
</div>
<hr />
<p>A type class is not a thing you can point to. It is not an object in memory, nor a concrete class you instantiate. It is, rather, an event: the moment when a type demonstrates that it possesses certain capabilities.</p>
<p>When we say <code>Optional</code> is a <code>Functor</code>, we mean that mapping over an Optional is a meaningful operation. When we say it is also an <code>Applicative</code>, we add the ability to combine independent Optional values. When we say it is a <code>Monad</code>, we gain sequencing, the power to chain operations where each step depends on the previous result. The type hasn't changed. Our understanding of what we can do with it has.</p>
<p>This chapter presents the type class hierarchy that powers Higher-Kinded-J. At the foundation sits <code>Functor</code>, providing <code>map</code>. Above it, <code>Applicative</code> adds <code>of</code> and <code>ap</code>. <code>Monad</code> contributes <code>flatMap</code>. <code>MonadError</code> handles failure. Each builds on what came before, each unlocking new compositional possibilities.</p>
<p>The hierarchy is not arbitrary. It reflects mathematical structure (specifically, category theory), though you need not understand the mathematics to use the tools. Think of it as a ladder: each rung grants new capabilities, and the lower rungs remain available as you climb.</p>
<hr />
<h2 id="the-hierarchy-1"><a class="header" href="#the-hierarchy-1">The Hierarchy</a></h2>
<pre><code>                        ┌──────────┐
                        │  Functor │  map
                        └────┬─────┘
                             │
                        ┌────┴─────┐
                        │Applicative│  of, ap
                        └────┬─────┘
                             │
              ┌──────────────┼──────────────┐
              │              │              │
        ┌─────┴─────┐  ┌─────┴─────┐  ┌─────┴─────┐
        │   Monad   │  │Alternative│  │ Selective │
        │  flatMap  │  │ orElse    │  │  select   │
        └─────┬─────┘  └───────────┘  └───────────┘
              │
        ┌─────┴─────┐
        │MonadError │  raiseError, handleErrorWith
        └───────────┘
</code></pre>
<p>Each arrow represents "extends": Monad is an Applicative with additional power.</p>
<hr />
<h2 id="why-this-matters"><a class="header" href="#why-this-matters">Why This Matters</a></h2>
<p>The practical benefit is polymorphism over <em>behaviour</em>, not just data:</p>
<pre><code class="language-java">// This method works with ANY Monad: Optional, Either, List, IO, Future...
public static &lt;F, A, B&gt; Kind&lt;F, B&gt; transform(
    Monad&lt;F&gt; monad,
    Kind&lt;F, A&gt; value,
    Function&lt;A, Kind&lt;F, B&gt;&gt; operation) {

    return monad.flatMap(operation, value);
}
</code></pre>
<p>Write once. Use everywhere the capability exists.</p>
<hr />
<h2 id="what-youll-learn-10"><a class="header" href="#what-youll-learn-10">What You'll Learn</a></h2>
<div id="admonition-in-this-chapter" class="admonition admonish-info" role="note" aria-labelledby="admonition-in-this-chapter-title">
<div class="admonition-title">
<div id="admonition-in-this-chapter-title">
<p>In This Chapter</p>
</div>
<a class="admonition-anchor-link" href="functional/ch_intro.html#admonition-in-this-chapter"></a>
</div>
<div>
<ul>
<li><strong>Functor</strong> – The foundational type class that enables transformation of values inside containers without changing the container's structure. Every other abstraction builds on this.</li>
<li><strong>Applicative</strong> – When you have multiple independent computations and need to combine their results. Unlike Monad, Applicative allows parallel evaluation since results don't depend on each other.</li>
<li><strong>Alternative</strong> – Provides choice and fallback semantics: try one computation, and if it fails, try another. Essential for parsing and error recovery patterns.</li>
<li><strong>Monad</strong> – The power to sequence dependent computations where each step can use results from previous steps. The workhorse of functional programming.</li>
<li><strong>MonadError</strong> – Extends Monad with explicit error handling capabilities, allowing you to raise errors and recover from them within the monadic context.</li>
<li><strong>Semigroup and Monoid</strong> – Type classes for combining values associatively. Monoids add an identity element, enabling operations like folding empty collections.</li>
<li><strong>Foldable and Traverse</strong> – Foldable lets you reduce structures to single values; Traverse lets you transform structures while collecting effects.</li>
<li><strong>MonadZero</strong> – Adds filtering capabilities to monads, enabling guard conditions in for-comprehensions that can short-circuit computation.</li>
<li><strong>Selective</strong> – Sits between Applicative and Monad, providing conditional effects that can be statically analysed. Useful for build systems and optimisation.</li>
<li><strong>Profunctor</strong> – For types with both input and output, allowing you to transform both sides. The foundation for advanced optics.</li>
<li><strong>Bifunctor</strong> – Like Functor, but for types with two type parameters. Enables simultaneous transformation of both sides of types like Either or Tuple.</li>
<li><strong>For Comprehension</strong> – A fluent API for composing monadic operations, inspired by Scala's for-comprehensions and Haskell's do-notation.</li>
</ul>
</div>
</div>
<hr />
<h2 id="chapter-contents-10"><a class="header" href="#chapter-contents-10">Chapter Contents</a></h2>
<ol>
<li><a href="functional/functional_api.html">Functional API</a> - Overview of all type class interfaces</li>
<li><a href="functional/functor.html">Functor</a> - The foundation: mapping over wrapped values</li>
<li><a href="functional/applicative.html">Applicative</a> - Combining independent computations</li>
<li><a href="functional/alternative.html">Alternative</a> - Choice and fallback operations</li>
<li><a href="functional/monad.html">Monad</a> - Sequencing dependent computations</li>
<li><a href="functional/monad_error.html">MonadError</a> - Explicit error handling in monadic contexts</li>
<li><a href="functional/semigroup_and_monoid.html">Semigroup and Monoid</a> - Combining values associatively</li>
<li><a href="functional/foldable_and_traverse.html">Foldable and Traverse</a> - Iterating and transforming structures</li>
<li><a href="functional/monad_zero.html">MonadZero</a> - Filtering in comprehensions</li>
<li><a href="functional/selective.html">Selective</a> - Conditional effects with static analysis</li>
<li><a href="functional/profunctor.html">Profunctor</a> - Transforming both input and output</li>
<li><a href="functional/bifunctor.html">Bifunctor</a> - Mapping over two type parameters</li>
<li><a href="functional/natural_transformation.html">Natural Transformation</a> - Polymorphic functions between type constructors</li>
<li><a href="functional/for_comprehension.html">For Comprehension</a> - Readable monadic composition</li>
</ol>
<hr />
<p><strong>Next:</strong> <a href="functional/functional_api.html">Functional API</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="core-api-interfaces-the-building-blocks"><a class="header" href="#core-api-interfaces-the-building-blocks">Core API Interfaces: The Building Blocks</a></h1>
<p>The <code>hkj-api</code> module contains the heart of the <code>higher-kinded-j</code> library: a set of interfaces that define the core functional programming abstractions. These are the building blocks you will use to write powerful, generic, and type-safe code.</p>
<p>This document provides a high-level overview of the most important interfaces, which are often referred to as <strong>type classes</strong>.</p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="functional/functional_api.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How the <code>Kind&lt;F, A&gt;</code> interface enables higher-kinded types in Java and serves as the foundation for all functional abstractions</li>
<li>The monad hierarchy from <code>Functor</code> through <code>Applicative</code> to <code>Monad</code>, plus specialized variants like <code>MonadError</code>, <code>Alternative</code>, <code>Selective</code>, and <code>MonadZero</code></li>
<li>How to combine and aggregate data using <code>Semigroup</code> and <code>Monoid</code> type classes for operations like error accumulation</li>
<li>How to iterate over and transform data structures generically using <code>Foldable</code> and <code>Traverse</code> for tasks like validation and collection processing</li>
<li>How dual-parameter type classes like <code>Profunctor</code> and <code>Bifunctor</code> enable advanced data transformations and power optics</li>
</ul>
</div>
</div>
<hr />
<h2 id="core-hkt-abstraction"><a class="header" href="#core-hkt-abstraction">Core HKT Abstraction</a></h2>
<p>At the very centre of the library is the <code>Kind</code> interface, which makes higher-kinded types possible in Java.</p>
<ul>
<li><strong><code>Kind&lt;F, A&gt;</code></strong>: This is the foundational interface that emulates a higher-kinded type. It represents a type <code>F</code> that is generic over a type <code>A</code>. For example, <code>Kind&lt;ListKind.Witness, String&gt;</code> represents a <code>List&lt;String&gt;</code>. You will see this interface used everywhere as the common currency for all our functional abstractions.</li>
</ul>
<hr />
<h2 id="the-monad-hierarchy"><a class="header" href="#the-monad-hierarchy">The Monad Hierarchy</a></h2>
<p>The most commonly used type classes form a hierarchy of power and functionality, starting with <code>Functor</code> and building up to <code>Monad</code>.</p>
<h3 id="functorf"><a class="header" href="#functorf"><strong><code>Functor&lt;F&gt;</code></strong></a></h3>
<p>A <strong><code>Functor</code></strong> is a type class for any data structure that can be "mapped over". It provides a single operation, <code>map</code>, which applies a function to the value(s) inside the structure without changing the structure itself.</p>
<ul>
<li><strong>Key Method</strong>: <code>map(Function&lt;A, B&gt; f, Kind&lt;F, A&gt; fa)</code></li>
<li><strong>Intuition</strong>: If you have a <code>List&lt;A&gt;</code> and a function <code>A -&gt; B</code>, a <code>Functor</code> for <code>List</code> lets you produce a <code>List&lt;B&gt;</code>. The same logic applies to <code>Optional</code>, <code>Either</code>, <code>Try</code>, etc.</li>
</ul>
<h3 id="applicativef"><a class="header" href="#applicativef"><strong><code>Applicative&lt;F&gt;</code></strong></a></h3>
<p>An <strong><code>Applicative</code></strong> (or Applicative Functor) is a <code>Functor</code> with more power. It allows you to apply a function that is itself wrapped in the data structure. This is essential for combining multiple independent computations.</p>
<ul>
<li><strong>Key Methods</strong>:
<ul>
<li><code>of(A value)</code>: Lifts a normal value <code>A</code> into the applicative context <code>F&lt;A&gt;</code>.</li>
<li><code>ap(Kind&lt;F, Function&lt;A, B&gt;&gt; ff, Kind&lt;F, A&gt; fa)</code>: Applies a wrapped function to a wrapped value.</li>
</ul>
</li>
<li><strong>Intuition</strong>: If you have an <code>Optional&lt;Function&lt;A, B&gt;&gt;</code> and an <code>Optional&lt;A&gt;</code>, you can use the <code>Applicative</code> for <code>Optional</code> to get an <code>Optional&lt;B&gt;</code>. This is how <code>Validated</code> is able to accumulate errors from multiple independent validation steps.</li>
</ul>
<h3 id="monadf"><a class="header" href="#monadf"><strong><code>Monad&lt;F&gt;</code></strong></a></h3>
<p>A <strong><code>Monad</code></strong> is an <code>Applicative</code> that adds the power of sequencing dependent computations. It provides a way to chain operations together, where the result of one operation is fed into the next.</p>
<ul>
<li><strong>Key Method</strong>: <code>flatMap(Function&lt;A, Kind&lt;F, B&gt;&gt; f, Kind&lt;F, A&gt; fa)</code></li>
<li><strong>Intuition</strong>: <code>flatMap</code> is the powerhouse of monadic composition. It takes a value from a context (like an <code>Optional&lt;A&gt;</code>), applies a function that returns a <em>new</em> context (<code>A -&gt; Optional&lt;B&gt;</code>), and flattens the result into a single context (<code>Optional&lt;B&gt;</code>). This is what enables the elegant, chainable workflows you see in the examples.</li>
</ul>
<h3 id="monaderrorf-e"><a class="header" href="#monaderrorf-e"><strong><code>MonadError&lt;F, E&gt;</code></strong></a></h3>
<p>A <strong><code>MonadError</code></strong> is a specialised <code>Monad</code> that has a defined error type <code>E</code>. It provides explicit methods for raising and handling errors within a monadic workflow.</p>
<ul>
<li><strong>Key Methods</strong>:
<ul>
<li><code>raiseError(E error)</code>: Lifts an error <code>E</code> into the monadic context <code>F&lt;A&gt;</code>.</li>
<li><code>handleErrorWith(Kind&lt;F, A&gt; fa, Function&lt;E, Kind&lt;F, A&gt;&gt; f)</code>: Provides a way to recover from a failed computation.</li>
</ul>
</li>
</ul>
<h3 id="alternativef"><a class="header" href="#alternativef"><strong><code>Alternative&lt;F&gt;</code></strong></a></h3>
<p>An <strong><code>Alternative</code></strong> is an <code>Applicative</code> that adds the concept of choice and failure. It provides operations for combining alternatives and representing empty/failed computations. Alternative sits at the same level as <code>Applicative</code> in the type class hierarchy.</p>
<ul>
<li><strong>Key Methods</strong>:
<ul>
<li><code>empty()</code>: Returns the empty/failure element for the applicative.</li>
<li><code>orElse(Kind&lt;F, A&gt; fa, Supplier&lt;Kind&lt;F, A&gt;&gt; fb)</code>: Combines two alternatives, preferring the first if it succeeds, otherwise evaluating and returning the second.</li>
<li><code>guard(boolean condition)</code>: Returns success (<code>of(Unit.INSTANCE)</code>) if true, otherwise empty.</li>
</ul>
</li>
<li><strong>Use Case</strong>: Essential for parser combinators, fallback chains, non-deterministic computation, and trying multiple alternatives with lazy evaluation.</li>
</ul>
<h3 id="selectivef"><a class="header" href="#selectivef"><strong><code>Selective&lt;F&gt;</code></strong></a></h3>
<p>A <strong><code>Selective</code></strong> functor sits between <code>Applicative</code> and <code>Monad</code> in terms of power. It extends <code>Applicative</code> with the ability to conditionally apply effects based on the result of a previous computation, whilst maintaining a static structure where all possible branches are visible upfront.</p>
<ul>
<li><strong>Key Methods</strong>:
<ul>
<li><code>select(Kind&lt;F, Choice&lt;A, B&gt;&gt; fab, Kind&lt;F, Function&lt;A, B&gt;&gt; ff)</code>: Core operation that conditionally applies a function based on a <code>Choice</code>.</li>
<li><code>whenS(Kind&lt;F, Boolean&gt; fcond, Kind&lt;F, Unit&gt; fa)</code>: Conditionally executes an effect based on a boolean condition.</li>
<li><code>ifS(Kind&lt;F, Boolean&gt; fcond, Kind&lt;F, A&gt; fthen, Kind&lt;F, A&gt; felse)</code>: Provides if-then-else semantics with both branches visible upfront.</li>
</ul>
</li>
<li><strong>Use Case</strong>: Perfect for feature flags, conditional logging, configuration-based behaviour, and any scenario where you need conditional effects with static analysis capabilities.</li>
</ul>
<h3 id="monadzerof"><a class="header" href="#monadzerof"><strong><code>MonadZero&lt;F&gt;</code></strong></a></h3>
<p>A <strong><code>MonadZero</code></strong> is a <code>Monad</code> that also extends <code>Alternative</code>, combining monadic bind with choice operations. It adds the concept of a "zero" or "empty" element, allowing it to represent failure or absence.</p>
<ul>
<li><strong>Key Methods</strong>:
<ul>
<li><code>zero()</code>: Returns the zero/empty element for the monad (implements <code>empty()</code> from Alternative).</li>
<li>Inherits <code>orElse()</code> and <code>guard()</code> from <code>Alternative</code>.</li>
</ul>
</li>
<li><strong>Use Case</strong>: Primarily enables filtering in for-comprehensions via the <code>when()</code> clause. Also provides all Alternative operations for monadic contexts. Implemented by List, Maybe, Optional, and Stream.</li>
</ul>
<hr />
<h2 id="data-aggregation-type-classes"><a class="header" href="#data-aggregation-type-classes">Data Aggregation Type Classes</a></h2>
<p>These type classes define how data can be combined and reduced.</p>
<h3 id="semigroupa"><a class="header" href="#semigroupa"><strong><code>Semigroup&lt;A&gt;</code></strong></a></h3>
<p>A <strong><code>Semigroup</code></strong> is a simple type class for any type <code>A</code> that has an associative <code>combine</code> operation. It's the foundation for any kind of data aggregation.</p>
<ul>
<li><strong>Key Method</strong>: <code>combine(A a1, A a2)</code></li>
<li><strong>Use Case</strong>: Its primary use in this library is to tell a <code>Validated``Applicative</code> how to accumulate errors.</li>
</ul>
<h3 id="monoida"><a class="header" href="#monoida"><strong><code>Monoid&lt;A&gt;</code></strong></a></h3>
<p>A <strong><code>Monoid</code></strong> is a <code>Semigroup</code> that also has an "empty" or "identity" element. This is a value that, when combined with any other value, does nothing.</p>
<ul>
<li><strong>Key Methods</strong>:
<ul>
<li><code>combine(A a1, A a2)</code> (from <code>Semigroup</code>)</li>
<li><code>empty()</code></li>
</ul>
</li>
<li><strong>Use Case</strong>: Essential for folding data structures, where <code>empty()</code> provides the starting value for the reduction.</li>
</ul>
<hr />
<h2 id="structure-iterating-type-classes-1"><a class="header" href="#structure-iterating-type-classes-1">Structure-Iterating Type Classes</a></h2>
<p>These type classes define how to iterate over and manipulate the contents of a data structure in a generic way.</p>
<h3 id="foldablef"><a class="header" href="#foldablef"><strong><code>Foldable&lt;F&gt;</code></strong></a></h3>
<p>A <strong><code>Foldable</code></strong> is a type class for any data structure <code>F</code> that can be reduced to a single summary value. It uses a <code>Monoid</code> to combine the elements.</p>
<ul>
<li><strong>Key Method</strong>: <code>foldMap(Monoid&lt;M&gt; monoid, Function&lt;A, M&gt; f, Kind&lt;F, A&gt; fa)</code></li>
<li><strong>Intuition</strong>: It abstracts the process of iterating over a collection and aggregating the results.</li>
</ul>
<h3 id="traversef"><a class="header" href="#traversef"><strong><code>Traverse&lt;F&gt;</code></strong></a></h3>
<p>A <strong><code>Traverse</code></strong> is a powerful type class that extends both <code>Functor</code> and <code>Foldable</code>. It allows you to iterate over a data structure <code>F&lt;A&gt;</code> and apply an effectful function <code>A -&gt; G&lt;B&gt;</code> at each step, collecting the results into a single effect <code>G&lt;F&lt;B&gt;&gt;</code>.</p>
<ul>
<li><strong>Key Method</strong>: <code>traverse(Applicative&lt;G&gt; applicative, Function&lt;A, Kind&lt;G, B&gt;&gt; f, Kind&lt;F, A&gt; fa)</code></li>
<li><strong>Use Case</strong>: This is incredibly useful for tasks like validating every item in a <code>List</code>, where the validation returns a <code>Validated</code>. The result is a single <code>Validated</code> containing either a <code>List</code> of all successful results or an accumulation of all errors.</li>
</ul>
<hr />
<h2 id="dual-parameter-type-classes-1"><a class="header" href="#dual-parameter-type-classes-1">Dual-Parameter Type Classes</a></h2>
<p>These type classes work with types that take two type parameters, such as functions, profunctors, and bifunctors.</p>
<h3 id="profunctorp"><a class="header" href="#profunctorp"><strong><code>Profunctor&lt;P&gt;</code></strong></a></h3>
<p>A <strong><code>Profunctor</code></strong> is a type class for any type constructor <code>P&lt;A, B&gt;</code> that is contravariant in its first parameter and covariant in its second. This is the abstraction behind functions and many data transformation patterns.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="functional/functional_api.html#admonition-note"></a>
</div>
<div>
<p>New to variance terminology? See the <a href="functional/../glossary.html">Glossary</a> for detailed explanations of covariant, contravariant, and invariant with Java-focused examples.</p>
</div>
</div>
<ul>
<li><strong>Key Methods</strong>:
<ul>
<li><code>lmap(Function&lt;C, A&gt; f, Kind2&lt;P, A, B&gt; pab)</code>: Pre-process the input (contravariant mapping)</li>
<li><code>rmap(Function&lt;B, C&gt; g, Kind2&lt;P, A, B&gt; pab)</code>: Post-process the output (covariant mapping)</li>
<li><code>dimap(Function&lt;C, A&gt; f, Function&lt;B, D&gt; g, Kind2&lt;P, A, B&gt; pab)</code>: Transform both input and output simultaneously</li>
</ul>
</li>
<li><strong>Use Case</strong>: Essential for building flexible data transformation pipelines, API adapters, and validation frameworks that can adapt to different input and output formats without changing core business logic.</li>
</ul>
<h3 id="profunctors-in-optics"><a class="header" href="#profunctors-in-optics"><strong>Profunctors in Optics</strong></a></h3>
<p>Importantly, every optic in higher-kinded-j is fundamentally a profunctor. This means that <code>Lens</code>, <code>Prism</code>, <code>Iso</code>, and <code>Traversal</code> all support profunctor operations through their <code>contramap</code>, <code>map</code>, and <code>dimap</code> methods. This provides incredible flexibility for adapting optics to work with different data types and structures, making them highly reusable across different contexts and API boundaries.</p>
<h3 id="bifunctorf"><a class="header" href="#bifunctorf"><strong><code>Bifunctor&lt;F&gt;</code></strong></a></h3>
<p>A <strong><code>Bifunctor</code></strong> is a type class for any type constructor <code>F&lt;A, B&gt;</code> that is covariant in <em>both</em> its type parameters. Unlike <code>Profunctor</code>, which is contravariant in the first parameter, <code>Bifunctor</code> allows you to map over both sides independently or simultaneously.</p>
<div id="admonition-note-1" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-1-title">
<div class="admonition-title">
<div id="admonition-note-1-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="functional/functional_api.html#admonition-note-1"></a>
</div>
<div>
<p>New to variance terminology? See the <a href="functional/../glossary.html">Glossary</a> for detailed explanations of covariant, contravariant, and invariant with Java-focused examples.</p>
</div>
</div>
<ul>
<li><strong>Key Methods</strong>:
<ul>
<li><code>bimap(Function&lt;A, C&gt; f, Function&lt;B, D&gt; g, Kind2&lt;F, A, B&gt; fab)</code>: Transform both type parameters simultaneously</li>
<li><code>first(Function&lt;A, C&gt; f, Kind2&lt;F, A, B&gt; fab)</code>: Map over only the first type parameter</li>
<li><code>second(Function&lt;B, D&gt; g, Kind2&lt;F, A, B&gt; fab)</code>: Map over only the second type parameter</li>
</ul>
</li>
<li><strong>Use Case</strong>: Essential for transforming both channels of sum types (like <code>Either&lt;L, R&gt;</code> or <code>Validated&lt;E, A&gt;</code>) or product types (like <code>Tuple2&lt;A, B&gt;</code> or <code>Writer&lt;W, A&gt;</code>), where both parameters hold data rather than representing input/output relationships. Perfect for API response transformation, validation pipelines, data migration, and error handling scenarios.</li>
</ul>
<hr />
<p><strong>Previous:</strong> <a href="functional/ch_intro.html">Introduction</a>
<strong>Next:</strong> <a href="functional/functor.html">Functor</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="functor-the-mappable-type-class"><a class="header" href="#functor-the-mappable-type-class">Functor: The "Mappable" Type Class</a></h1>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="functional/functor.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to transform values inside containers without changing the container structure</li>
<li>The difference between regular functions and functorial mapping</li>
<li>Functor laws (identity and composition) and why they matter</li>
<li>How to use Functor instances with List, Optional, and other containers</li>
<li>When to choose Functor over direct method calls</li>
</ul>
</div>
</div>
<div id="admonition-hands-on-practice" class="admonition admonish-note" role="note" aria-labelledby="admonition-hands-on-practice-title">
<div class="admonition-title">
<div id="admonition-hands-on-practice-title">
<p>Hands On Practice</p>
</div>
<a class="admonition-anchor-link" href="functional/functor.html#admonition-hands-on-practice"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/coretypes/Tutorial02_FunctorMapping.java">Tutorial02_FunctorMapping.java</a></p>
</div>
</div>
<p>At the heart of functional programming is the ability to transform data within a container without having to open it. The <strong><code>Functor</code></strong> type class provides exactly this capability. It's the simplest and most common abstraction for any data structure that can be "mapped over."</p>
<p>If you've ever used <code>Optional.map()</code> or <code>Stream.map()</code>, you've already been using the Functor pattern! <code>higher-kinded-j</code> simply formalises this concept so you can apply it to any data structure.</p>
<hr />
<h2 id="what-is-it"><a class="header" href="#what-is-it">What is it?</a></h2>
<p>A <strong><code>Functor</code></strong> is a type class for any data structure <code>F</code> that supports a <code>map</code> operation. This operation takes a function from <code>A -&gt; B</code> and applies it to the value(s) inside a container <code>F&lt;A&gt;</code>, producing a new container <code>F&lt;B&gt;</code> of the same shape.</p>
<p>Think of a <code>Functor</code> as a generic "box" that holds a value. The <code>map</code> function lets you transform the contents of the box without ever taking the value out. Whether the box is an <code>Optional</code> that might be empty, a <code>List</code> with many items, or a <code>Try</code> that might hold an error, the mapping logic remains the same.</p>
<p>The interface for <code>Functor</code> in <code>hkj-api</code> is simple and elegant:</p>
<pre><code class="language-java">public interface Functor&lt;F&gt; {
  &lt;A, B&gt; @NonNull Kind&lt;F, B&gt; map(final Function&lt;? super A, ? extends B&gt; f, final Kind&lt;F, A&gt; fa);
}
</code></pre>
<ul>
<li><code>f</code>: The function to apply to the value inside the Functor.</li>
<li><code>fa</code>: The higher-kinded <code>Functor</code> instance (e.g., a <code>Kind&lt;Optional.Witness, String&gt;</code>).</li>
</ul>
<hr />
<h3 id="the-functor-laws-1"><a class="header" href="#the-functor-laws-1">The Functor Laws</a></h3>
<p>For a <code>Functor</code> implementation to be lawful, it must obey two simple rules. These ensure that the <code>map</code> operation is predictable and doesn't have unexpected side effects.</p>
<ol>
<li>
<p><strong>Identity Law</strong>: Mapping with the identity function (<code>x -&gt; x</code>) should change nothing.</p>
<pre><code class="language-java">functor.map(x -&gt; x, fa); // This must be equivalent to fa
</code></pre>
</li>
<li>
<p><strong>Composition Law</strong>: Mapping with two functions composed together is the same as mapping with each function one after the other.</p>
<pre><code class="language-java">Function&lt;A, B&gt; f = ...;
Function&lt;B, C&gt; g = ...;

// This...
functor.map(g.compose(f), fa);

// ...must be equivalent to this:
functor.map(g, functor.map(f, fa));
</code></pre>
</li>
</ol>
<p>These laws ensure that <code>map</code> is only about transformation and preserves the structure of the data type.</p>
<hr />
<h3 id="why-is-it-useful"><a class="header" href="#why-is-it-useful">Why is it useful?</a></h3>
<p><code>Functor</code> allows you to write generic, reusable code that transforms values inside any "mappable" data structure. This is the first step toward abstracting away the boilerplate of dealing with different container types.</p>
<p><strong>Example: Mapping over an <code>Optional</code> and a <code>List</code></strong></p>
<p>Let's see how we can use the <code>Functor</code> instances for <code>Optional</code> and <code>List</code> to apply the same logic to different data structures.</p>
<pre><code class="language-java">import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.list.ListFunctor;
import org.higherkindedj.hkt.list.ListKind;
import org.higherkindedj.hkt.optional.OptionalFunctor;
import org.higherkindedj.hkt.optional.OptionalKind;
import java.util.List;
import java.util.Optional;
import static org.higherkindedj.hkt.list.ListKindHelper.LIST;
import static org.higherkindedj.hkt.optional.OptionalKindHelper.OPTIONAL;


// Our function that we want to apply
Function&lt;String, Integer&gt; stringLength = String::length;

// --- Scenario 1: Mapping over an Optional ---
Functor&lt;OptionalKind.Witness&gt; optionalFunctor = OptionalFunctor.INSTANCE;

// The data
Kind&lt;OptionalKind.Witness, String&gt; optionalWithValue = OPTIONAL.widen(Optional.of("Hello"));
Kind&lt;OptionalKind.Witness, String&gt; optionalEmpty = OPTIONAL.widen(Optional.empty());

// Apply the map
Kind&lt;OptionalKind.Witness, Integer&gt; lengthWithValue = optionalFunctor.map(stringLength, optionalWithValue);
Kind&lt;OptionalKind.Witness, Integer&gt; lengthEmpty = optionalFunctor.map(stringLength, optionalEmpty);

// Result: Optional[5]
System.out.println(OPTIONAL.narrow(lengthWithValue));
// Result: Optional.empty
System.out.println(OPTIONAL.narrow(lengthEmpty));


// --- Scenario 2: Mapping over a List ---
Functor&lt;ListKind.Witness&gt; listFunctor = ListFunctor.INSTANCE;

// The data
Kind&lt;ListKind.Witness, String&gt; listOfStrings = LIST.widen(List.of("one", "two", "three"));

// Apply the map
Kind&lt;ListKind.Witness, Integer&gt; listOfLengths = listFunctor.map(stringLength, listOfStrings);

// Result: [3, 3, 5]
System.out.println(LIST.narrow(listOfLengths));
</code></pre>
<p>As you can see, the <code>Functor</code> provides a consistent API for transformation, regardless of the underlying data structure. This is the first and most essential step on the path to more powerful abstractions like <code>Applicative</code> and <code>Monad</code>.</p>
<hr />
<div id="admonition-further-reading" class="admonition admonish-tip" role="note" aria-labelledby="admonition-further-reading-title">
<div class="admonition-title">
<div id="admonition-further-reading-title">
<p>Further Reading</p>
</div>
<a class="admonition-anchor-link" href="functional/functor.html#admonition-further-reading"></a>
</div>
<div>
<ul>
<li><strong>Scott Logic</strong>: <a href="https://blog.scottlogic.com/2025/03/31/functors-monads-with-java-and-scala.html">Functors and Monads with Java and Scala</a> - Practical guide to functors and monads in Java</li>
<li><strong>Bartosz Milewski</strong>: <a href="https://bartoszmilewski.com/2015/01/20/functors/">Functors</a> - Comprehensive explanation of functors from category theory to code</li>
<li><strong>Cats Documentation</strong>: <a href="https://typelevel.org/cats/typeclasses/functor.html">Functor</a> - Scala implementation and examples</li>
</ul>
</div>
</div>
<div id="admonition-hands-on-learning" class="admonition admonish-info" role="note" aria-labelledby="admonition-hands-on-learning-title">
<div class="admonition-title">
<div id="admonition-hands-on-learning-title">
<p>Hands-On Learning</p>
</div>
<a class="admonition-anchor-link" href="functional/functor.html#admonition-hands-on-learning"></a>
</div>
<div>
<p>Practice Functor mapping in <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/coretypes/Tutorial02_FunctorMapping.java">Tutorial 02: Functor Mapping</a> (6 exercises, ~8 minutes).</p>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="functional/functional_api.html">Functional API</a>
<strong>Next:</strong> <a href="functional/applicative.html">Applicative</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="applicative-applying-wrapped-functions"><a class="header" href="#applicative-applying-wrapped-functions">Applicative: Applying Wrapped Functions</a></h1>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="functional/applicative.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to apply wrapped functions to wrapped values using <code>ap</code></li>
<li>The difference between independent computations (Applicative) and dependent ones (Monad)</li>
<li>How to combine multiple validation results and accumulate all errors</li>
<li>Using <code>map2</code>, <code>map3</code> and other convenience methods for combining values</li>
<li>Real-world validation scenarios with the Validated type</li>
</ul>
</div>
</div>
<div id="admonition-hands-on-practice" class="admonition admonish-note" role="note" aria-labelledby="admonition-hands-on-practice-title">
<div class="admonition-title">
<div id="admonition-hands-on-practice-title">
<p>Hands On Practice</p>
</div>
<a class="admonition-anchor-link" href="functional/applicative.html#admonition-hands-on-practice"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/coretypes/Tutorial03_ApplicativeCombining.java">Tutorial03_ApplicativeCombining.java</a></p>
</div>
</div>
<p>Whilst a <code>Functor</code> excels at applying a <em>pure</em> function to a value inside a context, what happens when the function you want to apply is <em>also</em> wrapped in a context? This is where the <strong><code>Applicative</code></strong> type class comes in. It's the next step up in power from a <code>Functor</code> and allows you to combine multiple computations within a context in a very powerful way.</p>
<hr />
<h2 id="what-is-it-1"><a class="header" href="#what-is-it-1">What is it?</a></h2>
<p>An <strong><code>Applicative</code></strong> (or Applicative Functor) is a <code>Functor</code> that also provides two key operations:</p>
<ol>
<li><strong><code>of</code></strong> (also known as <code>pure</code>): Lifts a regular value into the applicative context. For example, it can take a <code>String</code> and wrap it to become an <code>Optional&lt;String&gt;</code>.</li>
<li><strong><code>ap</code></strong>: Takes a function that is wrapped in the context (e.g., an <code>Optional&lt;Function&lt;A, B&gt;&gt;</code>) and applies it to a value that is also in the context (e.g., an <code>Optional&lt;A&gt;</code>).</li>
</ol>
<p>This ability to apply a <em>wrapped function</em> to a <em>wrapped value</em> is what makes <code>Applicative</code> so powerful. It's the foundation for combining independent computations.</p>
<p>The interface for <code>Applicative</code> in <code>hkj-api</code> extends <code>Functor</code>:</p>
<pre><code class="language-java">@NullMarked
public interface Applicative&lt;F&gt; extends Functor&lt;F&gt; {

  &lt;A&gt; @NonNull Kind&lt;F, A&gt; of(@Nullable A value);

  &lt;A, B&gt; @NonNull Kind&lt;F, B&gt; ap(
      Kind&lt;F, ? extends Function&lt;A, B&gt;&gt; ff,
      Kind&lt;F, A&gt; fa
  );

  // Default methods for map2, map3, etc. are also provided
  default &lt;A, B, C&gt; @NonNull Kind&lt;F, C&gt; map2(
      final Kind&lt;F, A&gt; fa,
      final Kind&lt;F, B&gt; fb,
      final BiFunction&lt;? super A, ? super B, ? extends C&gt; f) {
    return ap(map(a -&gt; b -&gt; f.apply(a, b), fa), fb);
  }
}
</code></pre>
<hr />
<h3 id="why-is-it-useful-1"><a class="header" href="#why-is-it-useful-1">Why is it useful?</a></h3>
<p>The primary use case for <code>Applicative</code> is to combine the results of several independent computations that are all inside the same context. The classic example is <strong>data validation</strong>, where you want to validate multiple fields and accumulate all the errors.</p>
<p>Whilst a <code>Monad</code> (using <code>flatMap</code>) can also combine computations, it cannot accumulate errors in the same way. When a monadic chain fails, it short-circuits, giving you only the <em>first</em> error. An <code>Applicative</code>, on the other hand, can process all computations independently and combine the results.</p>
<p><strong>Example: Validating a User Registration Form</strong></p>
<p>Imagine you have a registration form and you need to validate both the username and the password. Each validation can either succeed or return a list of error messages. We can use the <code>Applicative</code> for <code>Validated</code> to run both validations and get all the errors back at once.</p>
<pre><code class="language-java">import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.validated.Validated;
import org.higherkindedj.hkt.validated.ValidatedMonad;
import org.higherkindedj.hkt.Semigroups;

import java.util.List;
import static org.higherkindedj.hkt.validated.ValidatedKindHelper.VALIDATED;

// A simple User class
record User(String username, String password) {}

// Validation functions
public Validated&lt;List&lt;String&gt;, String&gt; validateUsername(String username) {
    if (username.length() &lt; 3) {
        return Validated.invalid(List.of("Username must be at least 3 characters"));
    }
    return Validated.valid(username);
}

public Validated&lt;List&lt;String&gt;, String&gt; validatePassword(String password) {
    if (!password.matches(".*\\d.*")) {
        return Validated.invalid(List.of("Password must contain a number"));
    }
    return Validated.valid(password);
}


// --- Get the Applicative instance for Validated ---
// We need a Semigroup to tell the Applicative how to combine errors (in this case, by concatenating lists)
Applicative&lt;Validated.Witness&lt;List&lt;String&gt;&gt;&gt; applicative =
    ValidatedMonad.instance(Semigroups.list());

// --- Scenario 1: All validations pass ---
Validated&lt;List&lt;String&gt;, String&gt; validUsername = validateUsername("test_user");
Validated&lt;List&lt;String&gt;, String&gt; validPassword = validatePassword("password123");

Kind&lt;Validated.Witness&lt;List&lt;String&gt;&gt;, User&gt; validResult =
    applicative.map2(
        VALIDATED.widen(validUsername),
        VALIDATED.widen(validPassword),
        User::new // If both are valid, create a new User
    );

// Result: Valid(User[username=test_user, password=password123])
System.out.println(VALIDATED.narrow(validResult));


// --- Scenario 2: Both validations fail ---
Validated&lt;List&lt;String&gt;, String&gt; invalidUsername = validateUsername("no");
Validated&lt;List&lt;String&gt;, String&gt; invalidPassword = validatePassword("bad");

Kind&lt;Validated.Witness&lt;List&lt;String&gt;&gt;, User&gt; invalidResult =
    applicative.map2(
        VALIDATED.widen(invalidUsername),
        VALIDATED.widen(invalidPassword),
        User::new
    );

// The errors from both validations are accumulated!
// Result: Invalid([Username must be at least 3 characters, Password must contain a number])
System.out.println(VALIDATED.narrow(invalidResult));
</code></pre>
<p>This error accumulation is impossible with <code>Functor</code> and is one of the key features that makes <code>Applicative</code> so indispensable for real-world functional programming.</p>
<hr />
<div id="admonition-further-reading" class="admonition admonish-tip" role="note" aria-labelledby="admonition-further-reading-title">
<div class="admonition-title">
<div id="admonition-further-reading-title">
<p>Further Reading</p>
</div>
<a class="admonition-anchor-link" href="functional/applicative.html#admonition-further-reading"></a>
</div>
<div>
<ul>
<li><strong>Cats Documentation</strong>: <a href="https://typelevel.org/cats/typeclasses/applicative.html">Applicative</a> - Comprehensive coverage of Applicative laws and practical examples</li>
</ul>
</div>
</div>
<div id="admonition-hands-on-learning" class="admonition admonish-info" role="note" aria-labelledby="admonition-hands-on-learning-title">
<div class="admonition-title">
<div id="admonition-hands-on-learning-title">
<p>Hands-On Learning</p>
</div>
<a class="admonition-anchor-link" href="functional/applicative.html#admonition-hands-on-learning"></a>
</div>
<div>
<p>Practice Applicative combining in <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/coretypes/Tutorial03_ApplicativeCombining.java">Tutorial 03: Applicative Combining</a> (7 exercises, ~10 minutes).</p>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="functional/functor.html">Functor</a>
<strong>Next:</strong> <a href="functional/alternative.html">Alternative</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="alternative"><a class="header" href="#alternative">Alternative</a></h1>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="functional/alternative.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How Alternative provides choice and failure operations for applicative functors</li>
<li>Using <code>empty()</code> and <code>orElse()</code> for fallback chains</li>
<li>The <code>guard()</code> helper for conditional computations</li>
<li>How Alternative relates to MonadZero</li>
<li>Practical examples with Maybe, Optional, and List</li>
<li>Building configuration loaders with fallback chains</li>
</ul>
</div>
</div>
<p>The <code>Alternative</code> type class represents applicative functors that support choice and failure. It extends the <code>Applicative</code> interface with operations for combining alternatives and representing empty/failed computations. Alternative sits at the same level as <code>Applicative</code> in the type class hierarchy, providing a more general abstraction than <code>MonadZero</code>.</p>
<p>The interface for Alternative in hkj-api extends Applicative:</p>
<pre><code class="language-java">public interface Alternative&lt;F&gt; extends Applicative&lt;F&gt; {
    &lt;A&gt; Kind&lt;F, A&gt; empty();
    &lt;A&gt; Kind&lt;F, A&gt; orElse(Kind&lt;F, A&gt; fa, Supplier&lt;Kind&lt;F, A&gt;&gt; fb);
    default Kind&lt;F, Unit&gt; guard(boolean condition);
}
</code></pre>
<h3 id="why-is-it-useful-2"><a class="header" href="#why-is-it-useful-2">Why is it useful?</a></h3>
<p>An <code>Applicative</code> provides a way to apply functions within a context and combine multiple values. An <code>Alternative</code> adds two critical operations to this structure:</p>
<ul>
<li><code>empty()</code>: Returns the "empty" or "failure" element for the applicative functor.</li>
<li><code>orElse(fa, fb)</code>: Combines two alternatives, preferring the first if it succeeds, otherwise evaluating and returning the second.</li>
</ul>
<p>These operations enable:</p>
<ul>
<li><strong>Choice and fallback mechanisms</strong>: Try one computation, if it fails, try another</li>
<li><strong>Non-deterministic computation</strong>: Represent multiple possible results (e.g., List concatenation)</li>
<li><strong>Parser combinators</strong>: Essential for building flexible parsers that try alternatives</li>
<li><strong>Conditional effects</strong>: Using the <code>guard()</code> helper for filtering</li>
</ul>
<h3 id="relationship-with-monadzero"><a class="header" href="#relationship-with-monadzero">Relationship with MonadZero</a></h3>
<p>In higher-kinded-j, <code>MonadZero</code> extends both <code>Monad</code> and <code>Alternative</code>:</p>
<pre><code class="language-java">public interface MonadZero&lt;F&gt; extends Monad&lt;F&gt;, Alternative&lt;F&gt; {
    &lt;A&gt; Kind&lt;F, A&gt; zero();

    @Override
    default &lt;A&gt; Kind&lt;F, A&gt; empty() {
        return zero();
    }
}
</code></pre>
<p>This means:</p>
<ul>
<li>Every <code>MonadZero</code> is also an <code>Alternative</code></li>
<li>The <code>zero()</code> method provides the implementation for <code>empty()</code></li>
<li>Types that are MonadZero (List, Maybe, Optional, Stream) automatically get Alternative operations</li>
</ul>
<h3 id="key-implementations-in-this-project"><a class="header" href="#key-implementations-in-this-project">Key Implementations in this Project</a></h3>
<p>For different types, Alternative has different semantics:</p>
<ul>
<li><strong>Maybe</strong>: <code>empty()</code> returns <code>Nothing</code>. <code>orElse()</code> returns the first <code>Just</code>, or the second if the first is <code>Nothing</code>.</li>
<li><strong>Optional</strong>: <code>empty()</code> returns <code>Optional.empty()</code>. <code>orElse()</code> returns the first present value, or the second if the first is empty.</li>
<li><strong>List</strong>: <code>empty()</code> returns an empty list <code>[]</code>. <code>orElse()</code> concatenates both lists (non-deterministic choice).</li>
<li><strong>Stream</strong>: <code>empty()</code> returns an empty stream. <code>orElse()</code> concatenates both streams lazily.</li>
</ul>
<h3 id="primary-uses"><a class="header" href="#primary-uses">Primary Uses</a></h3>
<h4 id="1-fallback-chains-with-maybeoptional"><a class="header" href="#1-fallback-chains-with-maybeoptional">1. Fallback Chains with Maybe/Optional</a></h4>
<p>Try multiple sources, using the first successful one:</p>
<pre><code class="language-java">import org.higherkindedj.hkt.Alternative;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.maybe.MaybeKind;
import org.higherkindedj.hkt.maybe.MaybeMonad;
import org.higherkindedj.hkt.maybe.Maybe;

import static org.higherkindedj.hkt.maybe.MaybeKindHelper.MAYBE;

// Get the Alternative instance for Maybe
final Alternative&lt;MaybeKind.Witness&gt; alt = MaybeMonad.INSTANCE;

// Simulate trying multiple configuration sources
Kind&lt;MaybeKind.Witness, String&gt; fromEnv = MAYBE.nothing();      // Not found
Kind&lt;MaybeKind.Witness, String&gt; fromFile = MAYBE.just("config.txt");  // Found!
Kind&lt;MaybeKind.Witness, String&gt; fromDefault = MAYBE.just("default");

// Try sources in order
Kind&lt;MaybeKind.Witness, String&gt; config = alt.orElse(
    fromEnv,
    () -&gt; alt.orElse(
        fromFile,
        () -&gt; fromDefault
    )
);

Maybe&lt;String&gt; result = MAYBE.narrow(config);
System.out.println("Config: " + result.get()); // "config.txt"
</code></pre>
<p><strong>Using <code>orElseAll()</code> for cleaner syntax:</strong></p>
<pre><code class="language-java">Kind&lt;MaybeKind.Witness, String&gt; config = alt.orElseAll(
    fromEnv,
    () -&gt; fromFile,
    () -&gt; fromDefault
);
</code></pre>
<h4 id="2-non-deterministic-computation-with-list"><a class="header" href="#2-non-deterministic-computation-with-list">2. Non-Deterministic Computation with List</a></h4>
<p>Represent all possible outcomes:</p>
<pre><code class="language-java">import org.higherkindedj.hkt.Alternative;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.list.ListKind;
import org.higherkindedj.hkt.list.ListMonad;

import java.util.Arrays;
import java.util.List;

import static org.higherkindedj.hkt.list.ListKindHelper.LIST;

// Get the Alternative instance for List
final Alternative&lt;ListKind.Witness&gt; alt = ListMonad.INSTANCE;

// Possible actions
Kind&lt;ListKind.Witness, String&gt; actions1 = LIST.widen(Arrays.asList("move_left", "move_right"));
Kind&lt;ListKind.Witness, String&gt; actions2 = LIST.widen(Arrays.asList("jump", "duck"));

// Combine all possibilities
Kind&lt;ListKind.Witness, String&gt; allActions = alt.orElse(actions1, () -&gt; actions2);

List&lt;String&gt; result = LIST.narrow(allActions);
System.out.println("All actions: " + result);
// Output: [move_left, move_right, jump, duck]
</code></pre>
<h4 id="3-conditional-success-with-guard"><a class="header" href="#3-conditional-success-with-guard">3. Conditional Success with guard()</a></h4>
<p>Filter based on conditions:</p>
<pre><code class="language-java">import org.higherkindedj.hkt.Alternative;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.Unit;
import org.higherkindedj.hkt.maybe.MaybeKind;
import org.higherkindedj.hkt.maybe.MaybeMonad;
import org.higherkindedj.hkt.maybe.Maybe;

import static org.higherkindedj.hkt.maybe.MaybeKindHelper.MAYBE;

final Alternative&lt;MaybeKind.Witness&gt; alt = MaybeMonad.INSTANCE;

// Check authentication
boolean isAuthenticated = true;
Kind&lt;MaybeKind.Witness, Unit&gt; authCheck = alt.guard(isAuthenticated);

Maybe&lt;Unit&gt; result = MAYBE.narrow(authCheck);
System.out.println("Authenticated: " + result.isJust()); // true

// guard(false) returns empty()
Kind&lt;MaybeKind.Witness, Unit&gt; failedCheck = alt.guard(false);
System.out.println("Failed: " + MAYBE.narrow(failedCheck).isNothing()); // true
</code></pre>
<h4 id="4-lazy-evaluation"><a class="header" href="#4-lazy-evaluation">4. Lazy Evaluation</a></h4>
<p>The second argument to <code>orElse()</code> is provided via <code>Supplier</code>, enabling lazy evaluation:</p>
<pre><code class="language-java">final Alternative&lt;MaybeKind.Witness&gt; alt = MaybeMonad.INSTANCE;

Kind&lt;MaybeKind.Witness, String&gt; primary = MAYBE.just("found");

Kind&lt;MaybeKind.Witness, String&gt; result = alt.orElse(
    primary,
    () -&gt; {
        System.out.println("Computing fallback...");
        return MAYBE.just("fallback");
    }
);

// "Computing fallback..." is never printed because primary succeeded
System.out.println("Result: " + MAYBE.narrow(result).get()); // "found"
</code></pre>
<p>For <strong>Maybe</strong> and <strong>Optional</strong>, the second alternative is only evaluated if the first is empty.</p>
<p>For <strong>List</strong> and <strong>Stream</strong>, both alternatives are always evaluated (to concatenate them), but the <code>Supplier</code> still provides control over when the second collection is created.</p>
<h3 id="alternative-laws"><a class="header" href="#alternative-laws">Alternative Laws</a></h3>
<p>Alternative instances must satisfy these laws:</p>
<ol>
<li>
<p><strong>Left Identity</strong>: <code>orElse(empty(), () -&gt; fa) ≡ fa</code></p>
<ul>
<li>empty is the left identity for orElse</li>
</ul>
</li>
<li>
<p><strong>Right Identity</strong>: <code>orElse(fa, () -&gt; empty()) ≡ fa</code></p>
<ul>
<li>empty is the right identity for orElse</li>
</ul>
</li>
<li>
<p><strong>Associativity</strong>: <code>orElse(fa, () -&gt; orElse(fb, () -&gt; fc)) ≡ orElse(orElse(fa, () -&gt; fb), () -&gt; fc)</code></p>
<ul>
<li>The order of combining alternatives doesn't matter</li>
</ul>
</li>
<li>
<p><strong>Left Absorption</strong>: <code>ap(empty(), fa) ≡ empty()</code></p>
<ul>
<li>Applying an empty function gives empty</li>
</ul>
</li>
<li>
<p><strong>Right Absorption</strong>: <code>ap(ff, empty()) ≡ empty()</code></p>
<ul>
<li>Applying any function to empty gives empty</li>
</ul>
</li>
</ol>
<h3 id="practical-example-configuration-loading"><a class="header" href="#practical-example-configuration-loading">Practical Example: Configuration Loading</a></h3>
<p>Here's a complete example showing how Alternative enables elegant fallback chains:</p>
<pre><code class="language-java">import org.higherkindedj.hkt.Alternative;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.maybe.MaybeKind;
import org.higherkindedj.hkt.maybe.MaybeMonad;
import org.higherkindedj.hkt.maybe.Maybe;

import static org.higherkindedj.hkt.maybe.MaybeKindHelper.MAYBE;

public class ConfigLoader {
    private final Alternative&lt;MaybeKind.Witness&gt; alt = MaybeMonad.INSTANCE;

    public Kind&lt;MaybeKind.Witness, String&gt; loadConfig(String key) {
        return alt.orElseAll(
            readFromEnvironment(key),
            () -&gt; readFromConfigFile(key),
            () -&gt; readFromDatabase(key),
            () -&gt; getDefaultValue(key)
        );
    }

    private Kind&lt;MaybeKind.Witness, String&gt; readFromEnvironment(String key) {
        String value = System.getenv(key);
        return value != null ? MAYBE.just(value) : MAYBE.nothing();
    }

    private Kind&lt;MaybeKind.Witness, String&gt; readFromConfigFile(String key) {
        // Simulate file reading
        return MAYBE.nothing(); // Not found
    }

    private Kind&lt;MaybeKind.Witness, String&gt; readFromDatabase(String key) {
        // Simulate database query
        return MAYBE.just("db-value-" + key);
    }

    private Kind&lt;MaybeKind.Witness, String&gt; getDefaultValue(String key) {
        return MAYBE.just("default-" + key);
    }
}

// Usage
ConfigLoader loader = new ConfigLoader();
Kind&lt;MaybeKind.Witness, String&gt; config = loader.loadConfig("APP_NAME");
Maybe&lt;String&gt; result = MAYBE.narrow(config);
System.out.println("Config value: " + result.get()); // "db-value-APP_NAME"
</code></pre>
<h3 id="comparison-alternative-vs-monadzero"><a class="header" href="#comparison-alternative-vs-monadzero">Comparison: Alternative vs MonadZero</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th>Alternative</th><th>MonadZero</th></tr></thead><tbody>
<tr><td>Extends</td><td>Applicative</td><td>Monad (and Alternative)</td></tr>
<tr><td>Power Level</td><td>Less powerful</td><td>More powerful</td></tr>
<tr><td>Core Methods</td><td><code>empty()</code>, <code>orElse()</code></td><td><code>zero()</code>, inherits <code>orElse()</code></td></tr>
<tr><td>Use Case</td><td>Choice, fallback, alternatives</td><td>Filtering, monadic zero</td></tr>
<tr><td>Examples</td><td>Parser combinators, fallback chains</td><td>For-comprehension filtering</td></tr>
</tbody></table>
</div>
<p>In practice, since <code>MonadZero</code> extends <code>Alternative</code> in higher-kinded-j, types like List, Maybe, Optional, and Stream have access to both sets of operations.</p>
<h3 id="when-to-use-alternative"><a class="header" href="#when-to-use-alternative">When to Use Alternative</a></h3>
<p>Use Alternative when you need to:</p>
<ul>
<li><strong>Try multiple alternatives</strong> with fallback behaviour</li>
<li><strong>Combine all possibilities</strong> (for List/Stream)</li>
<li><strong>Conditionally proceed</strong> based on boolean conditions (<code>guard()</code>)</li>
<li><strong>Build parser combinators</strong> or similar choice-based systems</li>
<li>Work at the <strong>Applicative level</strong> without requiring full Monad power</li>
</ul>
<p>Alternative provides a principled, composable way to handle choice and failure in functional programming.</p>
<h2 id="complete-working-example"><a class="header" href="#complete-working-example">Complete Working Example</a></h2>
<p>For a complete, runnable example demonstrating Alternative with configuration loading, see:</p>
<p><strong><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/alternative/AlternativeConfigExample.java">AlternativeConfigExample.java</a></strong></p>
<p>This example demonstrates:</p>
<ul>
<li>Basic <code>orElse()</code> fallback patterns</li>
<li><code>orElseAll()</code> for multiple fallback sources</li>
<li><code>guard()</code> for conditional validation</li>
<li>Lazy evaluation benefits</li>
<li>Parser combinator patterns using Alternative</li>
</ul>
<hr />
<div id="admonition-further-reading" class="admonition admonish-tip" role="note" aria-labelledby="admonition-further-reading-title">
<div class="admonition-title">
<div id="admonition-further-reading-title">
<p>Further Reading</p>
</div>
<a class="admonition-anchor-link" href="functional/alternative.html#admonition-further-reading"></a>
</div>
<div>
<ul>
<li><strong>Cats Documentation</strong>: <a href="https://typelevel.org/cats/typeclasses/alternative.html">Alternative</a> - Explains Alternative with practical examples including parsing and partitioning</li>
</ul>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="functional/applicative.html">Applicative</a>
<strong>Next:</strong> <a href="functional/monad.html">Monad</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="monad-sequencing-computations"><a class="header" href="#monad-sequencing-computations">Monad: Sequencing Computations</a></h1>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="functional/monad.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to sequence computations where each step depends on previous results</li>
<li>The power of <code>flatMap</code> for chaining operations that return wrapped values</li>
<li>When to use Monad vs Applicative (dependent vs independent computations)</li>
<li>Essential utility methods: <code>as</code>, <code>peek</code>, <code>flatMapIfOrElse</code>, and <code>flatMapN</code></li>
<li>How to combine multiple monadic values with <code>flatMap2</code>, <code>flatMap3</code>, etc.</li>
<li>How monadic short-circuiting works in practice</li>
</ul>
</div>
</div>
<div id="admonition-hands-on-practice" class="admonition admonish-note" role="note" aria-labelledby="admonition-hands-on-practice-title">
<div class="admonition-title">
<div id="admonition-hands-on-practice-title">
<p>Hands On Practice</p>
</div>
<a class="admonition-anchor-link" href="functional/monad.html#admonition-hands-on-practice"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/coretypes/Tutorial04_MonadChaining.java">Tutorial04_MonadChaining.java</a></p>
</div>
</div>
<p>You've seen how <code>Functor</code> lets you <code>map</code> over a value in a context and how <code>Applicative</code> lets you combine independent computations within a context. Now, we'll introduce the most powerful of the trio: <strong><code>Monad</code></strong>.</p>
<p>A <code>Monad</code> builds on <code>Applicative</code> by adding one crucial ability: sequencing computations that <strong>depend on each other</strong>. If the result of the first operation is needed to determine the second operation, you need a <code>Monad</code>.</p>
<hr />
<h2 id="what-is-it-2"><a class="header" href="#what-is-it-2">What is it?</a></h2>
<p>A <strong><code>Monad</code></strong> is an <code>Applicative</code> that provides a new function called <strong><code>flatMap</code></strong> (also known as <code>bind</code> in some languages). This is the powerhouse of monadic composition.</p>
<p>While <code>map</code> takes a simple function <code>A -&gt; B</code>, <code>flatMap</code> takes a function that returns a new value <em>already wrapped in the monadic context</em>, i.e., <code>A -&gt; Kind&lt;F, B&gt;</code>. <code>flatMap</code> then intelligently flattens the nested result <code>Kind&lt;F, Kind&lt;F, B&gt;&gt;</code> into a simple <code>Kind&lt;F, B&gt;</code>.</p>
<p>This flattening behaviour is what enables you to chain operations together in a clean, readable sequence without creating deeply nested structures.</p>
<hr />
<h2 id="the-monad-interface"><a class="header" href="#the-monad-interface">The <code>Monad</code> Interface</a></h2>
<p>The interface for <code>Monad</code> in <code>hkj-api</code> extends <code>Applicative</code> and adds <code>flatMap</code> along with several useful default methods for common patterns.</p>
<pre><code class="language-java">@NullMarked
public interface Monad&lt;M&gt; extends Applicative&lt;M&gt; {
  // Core sequencing method
  &lt;A, B&gt; @NonNull Kind&lt;M, B&gt; flatMap(
      final Function&lt;? super A, ? extends Kind&lt;M, B&gt;&gt; f, final Kind&lt;M, A&gt; ma);

  // Type-safe conditional branching
  default &lt;A, B&gt; @NonNull Kind&lt;M, B&gt; flatMapIfOrElse(
      final Predicate&lt;? super A&gt; predicate,
      final Function&lt;? super A, ? extends Kind&lt;M, B&gt;&gt; ifTrue,
      final Function&lt;? super A, ? extends Kind&lt;M, B&gt;&gt; ifFalse,
      final Kind&lt;M, A&gt; ma) {
    return flatMap(a -&gt; predicate.test(a) ? ifTrue.apply(a) : ifFalse.apply(a), ma);
  }

  // Replace the value while preserving the effect
  default &lt;A, B&gt; @NonNull Kind&lt;M, B&gt; as(final B b, final Kind&lt;M, A&gt; ma) {
    return map(_ -&gt; b, ma);
  }

  // Perform a side-effect without changing the value
  default &lt;A&gt; @NonNull Kind&lt;M, A&gt; peek(final Consumer&lt;? super A&gt; action, final Kind&lt;M, A&gt; ma) {
    return map(a -&gt; {
      action.accept(a);
      return a;
    }, ma);
  }

  // Combine multiple monadic values (flatMapN methods)
  default &lt;A, B, R&gt; @NonNull Kind&lt;M, R&gt; flatMap2(
      Kind&lt;M, A&gt; ma, Kind&lt;M, B&gt; mb,
      BiFunction&lt;? super A, ? super B, ? extends Kind&lt;M, R&gt;&gt; f) {
    return flatMap(a -&gt; flatMap(b -&gt; f.apply(a, b), mb), ma);
  }

  default &lt;A, B, C, R&gt; @NonNull Kind&lt;M, R&gt; flatMap3(
      Kind&lt;M, A&gt; ma, Kind&lt;M, B&gt; mb, Kind&lt;M, C&gt; mc,
      Function3&lt;? super A, ? super B, ? super C, ? extends Kind&lt;M, R&gt;&gt; f) {
    return flatMap(a -&gt; flatMap2(mb, mc, (b, c) -&gt; f.apply(a, b, c)), ma);
  }

  // flatMap4 and flatMap5 build on flatMap3 and flatMap4 respectively...
}
</code></pre>
<h3 id="monad-vs-applicative"><a class="header" href="#monad-vs-applicative">Monad vs. Applicative</a></h3>
<p>The key difference is simple but profound:</p>
<ul>
<li><strong><code>Applicative</code></strong> is for combining <strong>independent</strong> computations. The shape and structure of all the computations are known upfront. This is why it can accumulate errors from multiple validations, as it runs all of them.</li>
<li><strong><code>Monad</code></strong> is for sequencing <strong>dependent</strong> computations. The computation in the second step cannot be known until the first step has completed. This is why it short-circuits on failure: if the first step fails, there is no value to feed into the second step.</li>
</ul>
<hr />
<h3 id="why-is-it-useful-3"><a class="header" href="#why-is-it-useful-3">Why is it useful?</a></h3>
<p><code>Monad</code> is essential for building any kind of workflow where steps depend on the result of previous steps, especially when those steps might fail or be asynchronous. It allows you to write what looks like a simple sequence of operations while hiding the complexity of error handling, null checks, or concurrency.</p>
<p>This pattern is the foundation for the <strong>for-comprehension</strong> builder in <code>higher-kinded-j</code>, which transforms a chain of <code>flatMap</code> calls into clean, imperative-style code.</p>
<h4 id="core-method-flatmap"><a class="header" href="#core-method-flatmap">Core Method: <code>flatMap</code></a></h4>
<p>This is the primary method for chaining dependent operations.</p>
<p><strong>Example: A Safe Database Workflow</strong></p>
<p>Imagine a workflow where you need to fetch a user, then use their ID to fetch their account, and finally use the account details to get their balance. Any of these steps could fail (e.g., return an empty <code>Optional</code>). With <code>flatMap</code>, the chain becomes clean and safe.</p>
<pre><code class="language-java">import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.Monad;
import org.higherkindedj.hkt.optional.OptionalMonad;
import java.util.Optional;
import static org.higherkindedj.hkt.optional.OptionalKindHelper.OPTIONAL;

// Mock data records and repository functions from the previous example...
record User(int id, String name) {}
record Account(int userId, String accountId) {}

public Kind&lt;Optional.Witness, User&gt; findUser(int id) { /* ... */ }
public Kind&lt;Optional.Witness, Account&gt; findAccount(User user) { /* ... */ }
public Kind&lt;Optional.Witness, Double&gt; getBalance(Account account) { /* ... */ }

// --- Get the Monad instance for Optional ---
Monad&lt;Optional.Witness&gt; monad = OptionalMonad.INSTANCE;

// --- Scenario 1: Successful workflow ---
Kind&lt;Optional.Witness, Double&gt; balanceSuccess = monad.flatMap(user -&gt;
    monad.flatMap(account -&gt;
        getBalance(account),
        findAccount(user)),
    findUser(1));

// Result: Optional[1000.0]
System.out.println(OPTIONAL.narrow(balanceSuccess));

// --- Scenario 2: Failing workflow (user not found) ---
Kind&lt;Optional.Witness, Double&gt; balanceFailure = monad.flatMap(user -&gt;
    /* this part is never executed */
    monad.flatMap(account -&gt; getBalance(account), findAccount(user)),
    findUser(2)); // This returns Optional.empty()

// The chain short-circuits immediately.
// Result: Optional.empty
System.out.println(OPTIONAL.narrow(balanceFailure));
</code></pre>
<p>The <code>flatMap</code> chain elegantly handles the "happy path" while also providing robust, short-circuiting logic for the failure cases, all without a single null check.</p>
<hr />
<h2 id="utility-methods"><a class="header" href="#utility-methods">Utility Methods</a></h2>
<p><code>Monad</code> also provides default methods for common tasks like debugging, conditional logic, and transforming results.</p>
<h3 id="flatmapiforelse"><a class="header" href="#flatmapiforelse"><code>flatMapIfOrElse</code></a></h3>
<p>This is the type-safe way to perform conditional branching in a monadic chain. It applies one of two functions based on a predicate, ensuring that both paths result in the same final type and avoiding runtime errors.</p>
<p>Let's imagine we only want to fetch accounts for "standard" users (ID &lt; 100).</p>
<pre><code class="language-java">// --- Get the Monad instance for Optional ---
Monad&lt;Optional.Witness&gt; monad = OptionalMonad.INSTANCE;

// A user who meets the condition
Kind&lt;Optional.Witness, User&gt; standardUser = OPTIONAL.widen(Optional.of(new User(1, "Alice")));
// A user who does not
Kind&lt;Optional.Witness, User&gt; premiumUser = OPTIONAL.widen(Optional.of(new User(101, "Bob")));

// --- Scenario 1: Predicate is true ---
Kind&lt;Optional.Witness, Account&gt; resultSuccess = monad.flatMapIfOrElse(
    user -&gt; user.id() &lt; 100,      // Predicate: user is standard
    user -&gt; findAccount(user),    // Action if true: find their account
    user -&gt; OPTIONAL.widen(Optional.empty()), // Action if false: return empty
    standardUser
);
// Result: Optional[Account[userId=1, accountId=acc-123]]
System.out.println(OPTIONAL.narrow(resultSuccess));


// --- Scenario 2: Predicate is false ---
Kind&lt;Optional.Witness, Account&gt; resultFailure = monad.flatMapIfOrElse(
    user -&gt; user.id() &lt; 100,
    user -&gt; findAccount(user),
    user -&gt; OPTIONAL.widen(Optional.empty()), // This path is taken
    premiumUser
);
// Result: Optional.empty
System.out.println(OPTIONAL.narrow(resultFailure));
</code></pre>
<h3 id="as"><a class="header" href="#as"><code>as</code></a></h3>
<p>Replaces the value inside a monad while preserving its effect (e.g., success or failure). This is useful when you only care <em>that</em> an operation succeeded, not what its result was.</p>
<pre><code class="language-java">// After finding a user, we just want a confirmation message.
Kind&lt;Optional.Witness, String&gt; successMessage = monad.as("User found successfully", findUser(1));

// Result: Optional["User found successfully"]
System.out.println(OPTIONAL.narrow(successMessage));

// If the user isn't found, the effect (empty Optional) is preserved.
Kind&lt;Optional.Witness, String&gt; failureMessage = monad.as("User found successfully", findUser(99));

// Result: Optional.empty
System.out.println(OPTIONAL.narrow(failureMessage));
</code></pre>
<h3 id="peek"><a class="header" href="#peek"><code>peek</code></a></h3>
<p>Allows you to perform a side-effect (like logging) on the value inside a monad without altering the flow. The original monadic value is always returned.</p>
<pre><code class="language-java">// Log the user's name if they are found
Kind&lt;Optional.Witness, User&gt; peekSuccess = monad.peek(
    user -&gt; System.out.println("LOG: Found user -&gt; " + user.name()),
    findUser(1)
);
// Console output: LOG: Found user -&gt; Alice
// Result: Optional[User[id=1, name=Alice]] (The original value is unchanged)
System.out.println("Return value: " + OPTIONAL.narrow(peekSuccess));


// If the user isn't found, the action is never executed.
Kind&lt;Optional.Witness, User&gt; peekFailure = monad.peek(
    user -&gt; System.out.println("LOG: Found user -&gt; " + user.name()),
    findUser(99)
);
// Console output: (nothing)
// Result: Optional.empty
System.out.println("Return value: " + OPTIONAL.narrow(peekFailure));
</code></pre>
<hr />
<h2 id="combining-multiple-monadic-values-flatmapn-"><a class="header" href="#combining-multiple-monadic-values-flatmapn-">Combining Multiple Monadic Values: <code>flatMapN</code> 🔄</a></h2>
<p>Just as <code>Applicative</code> provides <code>map2</code>, <code>map3</code>, etc. for combining independent computations with a pure function, <code>Monad</code> provides <code>flatMap2</code>, <code>flatMap3</code>, <code>flatMap4</code>, and <code>flatMap5</code> for combining multiple monadic values where the combining function itself returns a monadic value.</p>
<p>These methods are perfect when you need to:</p>
<ul>
<li>Sequence multiple independent computations and then perform a final effectful operation</li>
<li>Validate multiple pieces of data together with an operation that may fail</li>
<li>Combine results from multiple sources with additional logic that may produce effects</li>
</ul>
<h3 id="flatmap2"><a class="header" href="#flatmap2"><code>flatMap2</code></a></h3>
<p>Combines two monadic values and applies a function that returns a new monadic value.</p>
<p><strong>Example: Validating and Combining Two Database Results</strong></p>
<pre><code class="language-java">import java.util.Optional;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.Monad;
import org.higherkindedj.hkt.optional.OptionalMonad;
import static org.higherkindedj.hkt.optional.OptionalKindHelper.OPTIONAL;

record User(int id, String name) {}
record Order(int userId, String item) {}
record UserOrder(User user, Order order) {}

// Mock repository functions
public Kind&lt;Optional.Witness, User&gt; findUser(int id) { /* ... */ }
public Kind&lt;Optional.Witness, Order&gt; findOrder(int orderId) { /* ... */ }

// Validation function that might fail
public Kind&lt;Optional.Witness, UserOrder&gt; validateAndCombine(User user, Order order) {
    if (order.userId() != user.id()) {
        return OPTIONAL.widen(Optional.empty()); // Validation failed
    }
    return OPTIONAL.widen(Optional.of(new UserOrder(user, order)));
}

Monad&lt;Optional.Witness&gt; monad = OptionalMonad.INSTANCE;

// Combine user and order, then validate
Kind&lt;Optional.Witness, UserOrder&gt; result = monad.flatMap2(
    findUser(1),
    findOrder(100),
    (user, order) -&gt; validateAndCombine(user, order)
);

// Result: Optional[UserOrder[...]] if valid, Optional.empty if any step fails
System.out.println(OPTIONAL.narrow(result));
</code></pre>
<h3 id="flatmap3-and-higher-arities"><a class="header" href="#flatmap3-and-higher-arities"><code>flatMap3</code> and Higher Arities</a></h3>
<p>For more complex scenarios, you can combine three, four, or five monadic values:</p>
<pre><code class="language-java">record Product(int id, String name, double price) {}
record Inventory(int productId, int quantity) {}

public Kind&lt;Optional.Witness, Product&gt; findProduct(int id) { /* ... */ }
public Kind&lt;Optional.Witness, Inventory&gt; checkInventory(int productId) { /* ... */ }

// Process an order with user, product, and inventory check
Kind&lt;Optional.Witness, String&gt; orderResult = monad.flatMap3(
    findUser(1),
    findProduct(100),
    checkInventory(100),
    (user, product, inventory) -&gt; {
        if (inventory.quantity() &lt;= 0) {
            return OPTIONAL.widen(Optional.empty()); // Out of stock
        }
        String confirmation = String.format(
            "Order confirmed for %s: %s (qty: %d)",
            user.name(), product.name(), inventory.quantity()
        );
        return OPTIONAL.widen(Optional.of(confirmation));
    }
);
</code></pre>
<h3 id="flatmapn-vs-mapn"><a class="header" href="#flatmapn-vs-mapn"><code>flatMapN</code> vs <code>mapN</code></a></h3>
<p>The key difference between <code>flatMapN</code> and <code>mapN</code> is:</p>
<ul>
<li><strong><code>mapN</code></strong> (from Applicative): The combining function returns a <strong>pure value</strong> (<code>(A, B) -&gt; C</code>)</li>
<li><strong><code>flatMapN</code></strong> (from Monad): The combining function returns a <strong>monadic value</strong> (<code>(A, B) -&gt; Kind&lt;M, C&gt;</code>)</li>
</ul>
<p>This makes <code>flatMapN</code> methods ideal when the combination of values needs to perform additional effects, such as:</p>
<ul>
<li>Additional validation that might fail</li>
<li>Database lookups based on combined criteria</li>
<li>Computations that may produce side effects</li>
<li>Operations that need to maintain monadic context</li>
</ul>
<pre><code class="language-java">// mapN: Pure combination
Kind&lt;Optional.Witness, String&gt; mapResult = monad.map2(
    findUser(1),
    findOrder(100),
    (user, order) -&gt; user.name() + " ordered " + order.item() // Pure function
);

// flatMapN: Effectful combination
Kind&lt;Optional.Witness, String&gt; flatMapResult = monad.flatMap2(
    findUser(1),
    findOrder(100),
    (user, order) -&gt; validateAndProcess(user, order) // Returns Optional
);
</code></pre>
<p>This pattern is especially powerful when combined with error-handling monads like <code>Either</code> or <code>Try</code>, where the combining function can itself fail with a meaningful error.</p>
<hr />
<div id="admonition-further-reading" class="admonition admonish-tip" role="note" aria-labelledby="admonition-further-reading-title">
<div class="admonition-title">
<div id="admonition-further-reading-title">
<p>Further Reading</p>
</div>
<a class="admonition-anchor-link" href="functional/monad.html#admonition-further-reading"></a>
</div>
<div>
<ul>
<li><strong>Scott Logic</strong>: <a href="https://blog.scottlogic.com/2025/03/31/functors-monads-with-java-and-scala.html">Functors and Monads with Java and Scala</a> - Practical guide to functors and monads in Java</li>
<li><strong>Bartosz Milewski</strong>: <a href="https://bartoszmilewski.com/2016/11/21/monads-programmers-definition/">Monads: Programmer's Definition</a> - Practical explanation of monads for programmers</li>
<li><strong>Cats Documentation</strong>: <a href="https://typelevel.org/cats/typeclasses/monad.html">Monad</a> - Scala implementation and examples</li>
</ul>
</div>
</div>
<div id="admonition-hands-on-learning" class="admonition admonish-info" role="note" aria-labelledby="admonition-hands-on-learning-title">
<div class="admonition-title">
<div id="admonition-hands-on-learning-title">
<p>Hands-On Learning</p>
</div>
<a class="admonition-anchor-link" href="functional/monad.html#admonition-hands-on-learning"></a>
</div>
<div>
<p>Practice Monad chaining in <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/coretypes/Tutorial04_MonadChaining.java">Tutorial 04: Monad Chaining</a> (7 exercises, ~10 minutes).</p>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="functional/alternative.html">Alternative</a>
<strong>Next:</strong> <a href="functional/monad_error.html">MonadError</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="monaderror-handling-errors-gracefully"><a class="header" href="#monaderror-handling-errors-gracefully">MonadError: Handling Errors Gracefully</a></h1>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="functional/monad_error.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How MonadError extends Monad with explicit error handling capabilities</li>
<li>Using <code>raiseError</code> to create failed computations</li>
<li>Recovering from errors with <code>handleErrorWith</code> and <code>handleError</code></li>
<li>Writing generic, resilient code that works with any error-capable monad</li>
<li>Practical examples with Either and Try</li>
</ul>
</div>
</div>
<div id="admonition-hands-on-practice" class="admonition admonish-note" role="note" aria-labelledby="admonition-hands-on-practice-title">
<div class="admonition-title">
<div id="admonition-hands-on-practice-title">
<p>Hands On Practice</p>
</div>
<a class="admonition-anchor-link" href="functional/monad_error.html#admonition-hands-on-practice"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/coretypes/Tutorial05_MonadErrorHandling.java">Tutorial05_MonadErrorHandling.java</a></p>
</div>
</div>
<p>While a <code>Monad</code> is excellent for sequencing operations that might fail (like with <code>Optional</code> or <code>Either</code>), it doesn't provide a standardised way to <em>inspect</em> or <em>recover</em> from those failures. The <strong><code>MonadError</code></strong> type class fills this gap.</p>
<p>It's a specialised <code>Monad</code> that has a defined error type <code>E</code>, giving you a powerful and abstract API for raising and handling errors within any monadic workflow.</p>
<hr />
<h2 id="what-is-it-3"><a class="header" href="#what-is-it-3">What is it?</a></h2>
<p>A <strong><code>MonadError</code></strong> is a <code>Monad</code> that provides two additional, fundamental operations for working with failures:</p>
<ol>
<li><strong><code>raiseError(E error)</code></strong>: This allows you to construct a failed computation by lifting an error value <code>E</code> directly into the monadic context.</li>
<li><strong><code>handleErrorWith(Kind&lt;F, A&gt; fa, ...)</code></strong>: This is the recovery mechanism. It allows you to inspect a potential failure and provide a fallback computation to rescue the workflow.</li>
</ol>
<p>By abstracting over a specific error type <code>E</code>, <code>MonadError</code> allows you to write generic, resilient code that can work with any data structure capable of representing failure, such as <code>Either&lt;E, A&gt;</code>, <code>Try&lt;A&gt;</code> (where <code>E</code> is <code>Throwable</code>), or even custom error-handling monads.</p>
<p>The interface for <code>MonadError</code> in <code>hkj-api</code> extends <code>Monad</code>:</p>
<pre><code class="language-java">@NullMarked
public interface MonadError&lt;F, E&gt; extends Monad&lt;F&gt; {

  &lt;A&gt; @NonNull Kind&lt;F, A&gt; raiseError(@Nullable final E error);

  &lt;A&gt; @NonNull Kind&lt;F, A&gt; handleErrorWith(
      final Kind&lt;F, A&gt; ma,
      final Function&lt;? super E, ? extends Kind&lt;F, A&gt;&gt; handler);

  // Default recovery methods like handleError, recover, etc. are also provided
  default &lt;A&gt; @NonNull Kind&lt;F, A&gt; handleError(
      final Kind&lt;F, A&gt; ma,
      final Function&lt;? super E, ? extends A&gt; handler) {
    return handleErrorWith(ma, error -&gt; of(handler.apply(error)));
  }
}
</code></pre>
<hr />
<h3 id="why-is-it-useful-4"><a class="header" href="#why-is-it-useful-4">Why is it useful?</a></h3>
<p><code>MonadError</code> formalises the pattern of "try-catch" in a purely functional way. It lets you build complex workflows that need to handle specific types of errors without coupling your logic to a concrete implementation like <code>Either</code> or <code>Try</code>. You can write a function once, and it will work seamlessly with any data type that has a <code>MonadError</code> instance.</p>
<p>This is incredibly useful for building robust applications, separating business logic from error-handling logic, and providing sensible fallbacks when operations fail.</p>
<p><strong>Example: A Resilient Division Workflow</strong></p>
<p>Let's model a division operation that can fail with a specific error message. We'll use <code>Either&lt;String, A&gt;</code> as our data type, which is a perfect fit for <code>MonadError</code>.</p>
<pre><code class="language-java">import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.either.Either;
import org.higherkindedj.hkt.either.EitherMonad;
import static org.higherkindedj.hkt.either.EitherKindHelper.EITHER;

// --- Get the MonadError instance for Either&lt;String, ?&gt; ---
MonadError&lt;Either.Witness&lt;String&gt;, String&gt; monadError = EitherMonad.instance();

// A function that performs division, raising a specific error on failure
public Kind&lt;Either.Witness&lt;String&gt;, Integer&gt; safeDivide(int a, int b) {
    if (b == 0) {
        return monadError.raiseError("Cannot divide by zero!");
    }
    return monadError.of(a / b);
}

// --- Scenario 1: A successful division ---
Kind&lt;Either.Witness&lt;String&gt;, Integer&gt; success = safeDivide(10, 2);

// Result: Right(5)
System.out.println(EITHER.narrow(success));


// --- Scenario 2: A failed division ---
Kind&lt;Either.Witness&lt;String&gt;, Integer&gt; failure = safeDivide(10, 0);

// Result: Left(Cannot divide by zero!)
System.out.println(EITHER.narrow(failure));


// --- Scenario 3: Recovering from the failure ---
// We can use handleErrorWith to catch the error and return a fallback value.
Kind&lt;Either.Witness&lt;String&gt;, Integer&gt; recovered = monadError.handleErrorWith(
    failure,
    errorMessage -&gt; {
        System.out.println("Caught an error: " + errorMessage);
        return monadError.of(0); // Recover with a default value of 0
    }
);

// Result: Right(0)
System.out.println(EITHER.narrow(recovered));
</code></pre>
<p>In this example, <code>raiseError</code> allows us to create the failure case in a clean, declarative way, while <code>handleErrorWith</code> provides a powerful mechanism for recovery, making our code more resilient and predictable.</p>
<hr />
<div id="admonition-further-reading" class="admonition admonish-tip" role="note" aria-labelledby="admonition-further-reading-title">
<div class="admonition-title">
<div id="admonition-further-reading-title">
<p>Further Reading</p>
</div>
<a class="admonition-anchor-link" href="functional/monad_error.html#admonition-further-reading"></a>
</div>
<div>
<ul>
<li><strong>Cats Documentation</strong>: <a href="https://typelevel.org/cats/typeclasses/applicativeerror.html">ApplicativeError</a> - The foundation that MonadError builds upon</li>
</ul>
</div>
</div>
<div id="admonition-hands-on-learning" class="admonition admonish-info" role="note" aria-labelledby="admonition-hands-on-learning-title">
<div class="admonition-title">
<div id="admonition-hands-on-learning-title">
<p>Hands-On Learning</p>
</div>
<a class="admonition-anchor-link" href="functional/monad_error.html#admonition-hands-on-learning"></a>
</div>
<div>
<p>Practice error handling in <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/coretypes/Tutorial05_MonadErrorHandling.java">Tutorial 05: Monad Error Handling</a> (7 exercises, ~10 minutes).</p>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="functional/monad.html">Monad</a>
<strong>Next:</strong> <a href="functional/semigroup_and_monoid.html">Semigroup and Monoid</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="semigroup-and-monoid-foundational-type-classes"><a class="header" href="#semigroup-and-monoid-foundational-type-classes">Semigroup and Monoid: Foundational Type Classes</a></h1>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="functional/semigroup_and_monoid.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>The fundamental building blocks for combining data: Semigroup and Monoid</li>
<li>How associative operations enable parallel and sequential data processing</li>
<li>Using Monoids for error accumulation in validation scenarios</li>
<li>Practical applications with String concatenation, integer addition, and boolean operations</li>
<li>Advanced Monoid operations: combining collections, repeated application, and identity testing</li>
<li>Working with numeric types: Long and Double monoid instances</li>
<li>Optional-based monoids for data aggregation: first, last, maximum, and minimum</li>
<li>How these abstractions power Foldable operations and validation workflows</li>
</ul>
</div>
</div>
<p>In functional programming, we often use <strong>type classes</strong> to define common behaviours that can be applied to a wide range of data types. These act as interfaces that allow us to write more abstract and reusable code. In <code>higher-kinded-j</code>, we provide a number of these type classes to enable powerful functional patterns.</p>
<p>Here we will cover two foundational type classes: <code>Semigroup</code> and <code>Monoid</code>. Understanding these will give you a solid foundation for many of the more advanced concepts in the library.</p>
<hr />
<h2 id="semigroupa-1"><a class="header" href="#semigroupa-1"><strong><code>Semigroup&lt;A&gt;</code></strong></a></h2>
<p>A <strong><code>Semigroup</code></strong> is one of the simplest and most fundamental type classes. It provides a blueprint for types that have a single, associative way of being combined.</p>
<h3 id="what-is-it-4"><a class="header" href="#what-is-it-4">What is it?</a></h3>
<p>A <code>Semigroup</code> is a type class for any data type that has a <code>combine</code> operation. This operation takes two values of the same type and merges them into a single value of that type. The only rule is that this operation must be <strong>associative</strong>.</p>
<p>This means that for any values <code>a</code>, <code>b</code>, and <code>c</code>:</p>
<p><code>(a.combine(b)).combine(c)</code> must be equal to <code>a.combine(b.combine(c))</code></p>
<p>The interface for <code>Semigroup</code> in <code>hkj-api</code> is as follows:</p>
<pre><code class="language-java">public interface Semigroup&lt;A&gt; {
    A combine(A a1, A a2);
}
</code></pre>
<h3 id="common-instances-the-semigroups-utility"><a class="header" href="#common-instances-the-semigroups-utility">Common Instances: The <code>Semigroups</code> Utility</a></h3>
<p>To make working with <code>Semigroup</code> easier, <code>higher-kinded-j</code> provides a <code>Semigroups</code> utility interface with static factory methods for common instances.</p>
<pre><code class="language-java">// Get a Semigroup for concatenating Strings
Semigroup&lt;String&gt; stringConcat = Semigroups.string();

// Get a Semigroup for concatenating Strings with a delimiter
Semigroup&lt;String&gt; stringConcatDelimited = Semigroups.string(", ");

// Get a Semigroup for concatenating Lists
Semigroup&lt;List&lt;Integer&gt;&gt; listConcat = Semigroups.list();
</code></pre>
<h3 id="where-is-it-used-in-higher-kinded-j"><a class="header" href="#where-is-it-used-in-higher-kinded-j">Where is it used in <code>higher-kinded-j</code>?</a></h3>
<p>The primary and most powerful use case for <code>Semigroup</code> in this library is to enable <strong>error accumulation</strong> with the <strong><code>Validated</code></strong> data type.</p>
<p>When you use the <code>Applicative</code> instance for <code>Validated</code>, you must provide a <code>Semigroup</code> for the error type. This tells the applicative how to combine errors when multiple invalid computations occur.</p>
<p><strong>Example: Accumulating Validation Errors</strong></p>
<pre><code class="language-java">// Create an applicative for Validated that accumulates String errors by joining them.
Applicative&lt;Validated.Witness&lt;String&gt;&gt; applicative =
    ValidatedMonad.instance(Semigroups.string("; "));

// Two invalid results
Validated&lt;String, Integer&gt; invalid1 = Validated.invalid("Field A is empty");
Validated&lt;String, Integer&gt; invalid2 = Validated.invalid("Field B is not a number");

// Combine them using the applicative's map2 method
Kind&lt;Validated.Witness&lt;String&gt;, Integer&gt; result =
    applicative.map2(
        VALIDATED.widen(invalid1),
        VALIDATED.widen(invalid2),
        (val1, val2) -&gt; val1 + val2
    );

// The errors are combined using our Semigroup
// Result: Invalid("Field A is empty; Field B is not a number")
System.out.println(VALIDATED.narrow(result));
</code></pre>
<hr />
<h2 id="monoida-1"><a class="header" href="#monoida-1"><strong><code>Monoid&lt;A&gt;</code></strong></a></h2>
<p>A <strong><code>Monoid</code></strong> is a <code>Semigroup</code> with a special "identity" or "empty" element. This makes it even more powerful, as it provides a way to have a "starting" or "default" value.</p>
<h3 id="what-is-it-5"><a class="header" href="#what-is-it-5">What is it?</a></h3>
<p>A <code>Monoid</code> is a type class for any data type that has an associative <code>combine</code> operation (from <code>Semigroup</code>) and an <code>empty</code> value. This <code>empty</code> value is a special element that, when combined with any other value, returns that other value.</p>
<p>This is known as the <strong>identity law</strong>. For any value <code>a</code>:</p>
<p><code>a.combine(empty())</code> must be equal to <code>a``empty().combine(a)</code> must be equal to <code>a</code></p>
<p>The interface for <code>Monoid</code> in <code>hkj-api</code> extends <code>Semigroup</code>:</p>
<pre><code class="language-java">public interface Monoid&lt;A&gt; extends Semigroup&lt;A&gt; {
    A empty();
}
</code></pre>
<h3 id="common-instances-the-monoids-utility"><a class="header" href="#common-instances-the-monoids-utility">Common Instances: The <code>Monoids</code> Utility</a></h3>
<p>Similar to <code>Semigroups</code>, the library provides a <code>Monoids</code> utility interface for creating common instances.</p>
<pre><code class="language-java">// Get a Monoid for integer addition (empty = 0)
Monoid&lt;Integer&gt; intAddition = Monoids.integerAddition();

// Get a Monoid for String concatenation (empty = "")
Monoid&lt;String&gt; stringMonoid = Monoids.string();

// Get a Monoid for boolean AND (empty = true)
Monoid&lt;Boolean&gt; booleanAnd = Monoids.booleanAnd();
</code></pre>
<h3 id="where-it-is-used-in-higher-kinded-j"><a class="header" href="#where-it-is-used-in-higher-kinded-j">Where it is used in <code>higher-kinded-j</code></a></h3>
<p>A <code>Monoid</code> is essential for <strong>folding</strong> (or reducing) a data structure. The <code>empty</code> element provides a safe starting value, which means you can correctly fold a collection that might be empty.</p>
<p>This is formalised in the <strong><code>Foldable</code></strong> typeclass, which has a <code>foldMap</code> method. This method maps every element in a structure to a monoidal type and then combines all the results.</p>
<p><strong>Example: Using <code>foldMap</code> with different Monoids</strong></p>
<pre><code class="language-java">List&lt;Integer&gt; numbers = List.of(1, 2, 3, 4, 5);
Kind&lt;ListKind.Witness, Integer&gt; numbersKind = LIST.widen(numbers);

// 1. Sum the list using the integer addition monoid
Integer sum = ListTraverse.INSTANCE.foldMap(
    Monoids.integerAddition(),
    Function.identity(),
    numbersKind
); // Result: 15

// 2. Concatenate the numbers as strings
String concatenated = ListTraverse.INSTANCE.foldMap(
    Monoids.string(),
    String::valueOf,
    numbersKind
); // Result: "12345"
</code></pre>
<hr />
<h2 id="advanced-monoid-operations"><a class="header" href="#advanced-monoid-operations"><strong>Advanced Monoid Operations</strong></a></h2>
<p>The <code>Monoid</code> interface provides several powerful default methods that build upon the basic <code>combine</code> and <code>empty</code> operations. These methods handle common aggregation patterns and make working with collections much more convenient.</p>
<h3 id="combineall-aggregating-collections"><a class="header" href="#combineall-aggregating-collections"><code>combineAll</code>: Aggregating Collections</a></h3>
<p>The <code>combineAll</code> method takes an iterable collection and combines all its elements using the monoid's operation. If the collection is empty, it returns the identity element.</p>
<pre><code class="language-java">Monoid&lt;Integer&gt; sum = Monoids.integerAddition();
List&lt;Integer&gt; salesData = List.of(120, 450, 380, 290);

Integer totalSales = sum.combineAll(salesData);
// Result: 1240

// Works safely with empty collections
Integer emptyTotal = sum.combineAll(Collections.emptyList());
// Result: 0 (the empty value)
</code></pre>
<p>This is particularly useful for batch processing scenarios where you need to aggregate data from multiple sources:</p>
<pre><code class="language-java">// Combining log messages
Monoid&lt;String&gt; logMonoid = Monoids.string();
List&lt;String&gt; logMessages = loadLogMessages();
String combinedLog = logMonoid.combineAll(logMessages);

// Merging configuration sets
Monoid&lt;Set&lt;String&gt;&gt; configMonoid = Monoids.set();
List&lt;Set&lt;String&gt;&gt; featureFlags = List.of(
    Set.of("feature-a", "feature-b"),
    Set.of("feature-b", "feature-c"),
    Set.of("feature-d")
);
Set&lt;String&gt; allFlags = configMonoid.combineAll(featureFlags);
// Result: ["feature-a", "feature-b", "feature-c", "feature-d"]
</code></pre>
<h3 id="combinen-repeated-application"><a class="header" href="#combinen-repeated-application"><code>combineN</code>: Repeated Application</a></h3>
<p>The <code>combineN</code> method combines a value with itself <code>n</code> times. This is useful for scenarios where you need to apply the same value repeatedly:</p>
<pre><code class="language-java">Monoid&lt;Integer&gt; product = Monoids.integerMultiplication();

// Calculate 2^5 using multiplication monoid
Integer result = product.combineN(2, 5);
// Result: 32 (2 * 2 * 2 * 2 * 2)

// Repeat a string pattern
Monoid&lt;String&gt; stringMonoid = Monoids.string();
String border = stringMonoid.combineN("=", 50);
// Result: "=================================================="

// Build a list with repeated elements
Monoid&lt;List&lt;String&gt;&gt; listMonoid = Monoids.list();
List&lt;String&gt; repeated = listMonoid.combineN(List.of("item"), 3);
// Result: ["item", "item", "item"]
</code></pre>
<p><strong>Special cases:</strong></p>
<ul>
<li>When <code>n = 0</code>, returns the empty value</li>
<li>When <code>n = 1</code>, returns the value unchanged</li>
<li>When <code>n &lt; 0</code>, throws <code>IllegalArgumentException</code></li>
</ul>
<h3 id="isempty-identity-testing"><a class="header" href="#isempty-identity-testing"><code>isEmpty</code>: Identity Testing</a></h3>
<p>The <code>isEmpty</code> method tests whether a given value equals the identity element of the monoid:</p>
<pre><code class="language-java">Monoid&lt;Integer&gt; sum = Monoids.integerAddition();
Monoid&lt;Integer&gt; product = Monoids.integerMultiplication();

sum.isEmpty(0);      // true (0 is the identity for addition)
sum.isEmpty(5);      // false

product.isEmpty(1);  // true (1 is the identity for multiplication)
product.isEmpty(0);  // false

Monoid&lt;String&gt; stringMonoid = Monoids.string();
stringMonoid.isEmpty("");     // true
stringMonoid.isEmpty("text"); // false
</code></pre>
<p>This is particularly useful for optimisation and conditional logic:</p>
<pre><code class="language-java">public void processIfNotEmpty(Monoid&lt;String&gt; monoid, String value) {
    if (!monoid.isEmpty(value)) {
        // Only process non-empty values
        performExpensiveOperation(value);
    }
}
</code></pre>
<hr />
<h2 id="working-with-numeric-types"><a class="header" href="#working-with-numeric-types"><strong>Working with Numeric Types</strong></a></h2>
<p>The <code>Monoids</code> utility provides comprehensive support for numeric operations beyond just <code>Integer</code>. This is particularly valuable for financial calculations, statistical operations, and scientific computing.</p>
<h3 id="long-monoids"><a class="header" href="#long-monoids">Long Monoids</a></h3>
<p>For working with large numeric values or high-precision calculations:</p>
<pre><code class="language-java">// Long addition for counting large quantities
Monoid&lt;Long&gt; longSum = Monoids.longAddition();
List&lt;Long&gt; userCounts = List.of(1_500_000L, 2_300_000L, 890_000L);
Long totalUsers = longSum.combineAll(userCounts);
// Result: 4,690,000

// Long multiplication for compound calculations
Monoid&lt;Long&gt; longProduct = Monoids.longMultiplication();
Long compound = longProduct.combineN(2L, 20);
// Result: 1,048,576 (2^20)
</code></pre>
<h3 id="double-monoids"><a class="header" href="#double-monoids">Double Monoids</a></h3>
<p>For floating-point arithmetic and statistical computations:</p>
<pre><code class="language-java">// Double addition for financial calculations
Monoid&lt;Double&gt; dollarSum = Monoids.doubleAddition();
List&lt;Double&gt; expenses = List.of(49.99, 129.50, 89.99);
Double totalExpenses = dollarSum.combineAll(expenses);
// Result: 269.48

// Double multiplication for compound interest
Monoid&lt;Double&gt; growth = Monoids.doubleMultiplication();
Double interestRate = 1.05; // 5% per year
Double compoundGrowth = growth.combineN(interestRate, 10);
// Result: ≈1.629 (after 10 years)
</code></pre>
<p><strong>Practical Example: Statistical Calculations</strong></p>
<pre><code class="language-java">public class Statistics {

    public static double calculateMean(List&lt;Double&gt; values) {
        if (values.isEmpty()) {
            throw new IllegalArgumentException("Cannot calculate mean of an empty list.");
        }

        Monoid&lt;Double&gt; sum = Monoids.doubleAddition();
        Double total = sum.combineAll(values);
        return total / values.size();
    }

    public static double calculateProduct(List&lt;Double&gt; factors) {
        Monoid&lt;Double&gt; product = Monoids.doubleMultiplication();
        return product.combineAll(factors);
    }
}

// Usage
List&lt;Double&gt; measurements = List.of(23.5, 24.1, 23.8, 24.3);
double average = Statistics.calculateMean(measurements);
// Result: 23.925
</code></pre>
<hr />
<h2 id="optional-monoids-for-data-aggregation"><a class="header" href="#optional-monoids-for-data-aggregation"><strong>Optional Monoids for Data Aggregation</strong></a></h2>
<p>One of the most powerful features of the <code>Monoids</code> utility is its support for <code>Optional</code>-based aggregation. These monoids elegantly handle the common pattern of finding the "best" value from a collection of optional results.</p>
<h3 id="firstoptional-and-lastoptional"><a class="header" href="#firstoptional-and-lastoptional"><code>firstOptional</code> and <code>lastOptional</code></a></h3>
<p>These monoids select the first or last non-empty optional value, making them perfect for fallback chains and priority-based selection:</p>
<pre><code class="language-java">Monoid&lt;Optional&lt;String&gt;&gt; first = Monoids.firstOptional();
Monoid&lt;Optional&lt;String&gt;&gt; last = Monoids.lastOptional();

List&lt;Optional&lt;String&gt;&gt; configs = List.of(
    Optional.empty(),           // Missing config
    Optional.of("default.conf"), // Found!
    Optional.of("user.conf")    // Also found
);

// Get first available configuration
Optional&lt;String&gt; primaryConfig = first.combineAll(configs);
// Result: Optional["default.conf"]

// Get last available configuration
Optional&lt;String&gt; latestConfig = last.combineAll(configs);
// Result: Optional["user.conf"]
</code></pre>
<p><strong>Practical Example: Configuration Fallback Chain</strong></p>
<pre><code class="language-java">public class ConfigLoader {

    public Optional&lt;Config&gt; loadConfig() {
        Monoid&lt;Optional&lt;Config&gt;&gt; firstAvailable = Monoids.firstOptional();

        return firstAvailable.combineAll(List.of(
            loadFromEnvironment(),     // Try environment variables first
            loadFromUserHome(),        // Then user's home directory
            loadFromWorkingDir(),      // Then current directory
            loadDefaultConfig()        // Finally, use defaults
        ));
    }

    private Optional&lt;Config&gt; loadFromEnvironment() {
        return Optional.ofNullable(System.getenv("APP_CONFIG"))
            .map(this::parseConfig);
    }

    private Optional&lt;Config&gt; loadFromUserHome() {
        Path userConfig = Paths.get(System.getProperty("user.home"), ".apprc");
        return Files.exists(userConfig)
            ? Optional.of(parseConfigFile(userConfig))
            : Optional.empty();
    }

    // ... other loaders
}
</code></pre>
<h3 id="maximum-and-minimum"><a class="header" href="#maximum-and-minimum"><code>maximum</code> and <code>minimum</code></a></h3>
<p>These monoids find the maximum or minimum value from a collection of optional values. They work with any <code>Comparable</code> type or accept a custom <code>Comparator</code>:</p>
<pre><code class="language-java">Monoid&lt;Optional&lt;Integer&gt;&gt; max = Monoids.maximum();
Monoid&lt;Optional&lt;Integer&gt;&gt; min = Monoids.minimum();

List&lt;Optional&lt;Integer&gt;&gt; scores = List.of(
    Optional.of(85),
    Optional.empty(),      // Missing data
    Optional.of(92),
    Optional.of(78),
    Optional.empty()
);

Optional&lt;Integer&gt; highestScore = max.combineAll(scores);
// Result: Optional[92]

Optional&lt;Integer&gt; lowestScore = min.combineAll(scores);
// Result: Optional[78]
</code></pre>
<p><strong>Using Custom Comparators</strong></p>
<p>For more complex types, you can provide a custom comparator:</p>
<pre><code class="language-java">public record Product(String name, double price) {}

// Find most expensive product
Monoid&lt;Optional&lt;Product&gt;&gt; mostExpensive =
    Monoids.maximum(Comparator.comparing(Product::price));

List&lt;Optional&lt;Product&gt;&gt; products = List.of(
    Optional.of(new Product("Widget", 29.99)),
    Optional.empty(),
    Optional.of(new Product("Gadget", 49.99)),
    Optional.of(new Product("Gizmo", 19.99))
);

Optional&lt;Product&gt; priciest = mostExpensive.combineAll(products);
// Result: Optional[Product("Gadget", 49.99)]

// Find product with shortest name
Monoid&lt;Optional&lt;Product&gt;&gt; shortestName =
    Monoids.minimum(Comparator.comparing(p -&gt; p.name().length()));

Optional&lt;Product&gt; shortest = shortestName.combineAll(products);
// Result: Optional[Product("Gizmo", 19.99)]
</code></pre>
<p><strong>Practical Example: Finding Best Offers</strong></p>
<pre><code class="language-java">public class PriceComparison {

    public record Offer(String vendor, BigDecimal price, boolean inStock)
        implements Comparable&lt;Offer&gt; {

        @Override
        public int compareTo(Offer other) {
            return this.price.compareTo(other.price);
        }
    }

    public Optional&lt;Offer&gt; findBestOffer(List&lt;String&gt; vendors, String productId) {
        Monoid&lt;Optional&lt;Offer&gt;&gt; cheapest = Monoids.minimum();

        List&lt;Optional&lt;Offer&gt;&gt; offers = vendors.stream()
            .map(vendor -&gt; fetchOffer(vendor, productId))
            .filter(opt -&gt; opt.map(Offer::inStock).orElse(false)) // Only in-stock items
            .collect(Collectors.toList());

        return cheapest.combineAll(offers);
    }

    private Optional&lt;Offer&gt; fetchOffer(String vendor, String productId) {
        // API call to get offer from vendor
        // Returns Optional.empty() if unavailable
    }
}
</code></pre>
<p><strong>When Both Optionals are Empty</strong></p>
<p>It's worth noting that these monoids handle empty collections gracefully:</p>
<pre><code class="language-java">Monoid&lt;Optional&lt;Integer&gt;&gt; max = Monoids.maximum();

List&lt;Optional&lt;Integer&gt;&gt; allEmpty = List.of(
    Optional.empty(),
    Optional.empty()
);

Optional&lt;Integer&gt; result = max.combineAll(allEmpty);
// Result: Optional.empty()

// Also works with empty list
Optional&lt;Integer&gt; emptyResult = max.combineAll(Collections.emptyList());
// Result: Optional.empty()
</code></pre>
<p>This makes them perfect for aggregation pipelines where you're not certain data will be present, but you want to find the best available value if any exists.</p>
<hr />
<h2 id="conclusion"><a class="header" href="#conclusion"><strong>Conclusion</strong></a></h2>
<p>Semigroups and Monoids are deceptively simple abstractions that unlock powerful patterns for data combination and aggregation. By understanding these type classes, you gain:</p>
<ul>
<li><strong>Composability</strong>: Build complex aggregations from simple, reusable pieces</li>
<li><strong>Type Safety</strong>: Let the compiler ensure your combinations are valid</li>
<li><strong>Flexibility</strong>: Swap monoids to get different behaviours from the same code</li>
<li><strong>Elegance</strong>: Express data aggregation intent clearly and concisely</li>
</ul>
<p>The new utility methods (<code>combineAll</code>, <code>combineN</code>, <code>isEmpty</code>) and expanded instance library (numeric types, Optional-based aggregations) make these abstractions even more practical for everyday Java development.</p>
<hr />
<div id="admonition-see-also" class="admonition admonish-tip" role="note" aria-labelledby="admonition-see-also-title">
<div class="admonition-title">
<div id="admonition-see-also-title">
<p>See Also</p>
</div>
<a class="admonition-anchor-link" href="functional/semigroup_and_monoid.html#admonition-see-also"></a>
</div>
<div>
<ul>
<li><a href="functional/foldable_and_traverse.html">Foldable and Traverse</a> - See how Monoids power folding operations</li>
<li><a href="functional/applicative.html">Applicative</a> - Learn how Semigroups enable error accumulation with Validated</li>
</ul>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="functional/monad_error.html">MonadError</a>
<strong>Next:</strong> <a href="functional/foldable_and_traverse.html">Foldable and Traverse</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="foldable--traverse-reducing-a-structure-to-a-summary"><a class="header" href="#foldable--traverse-reducing-a-structure-to-a-summary">Foldable &amp; Traverse: Reducing a Structure to a Summary</a></h1>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="functional/foldable_and_traverse.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to reduce any data structure to a summary value using <code>foldMap</code></li>
<li>The power of swapping Monoids to get different aggregations from the same data</li>
<li>Turning effects "inside-out" with <code>traverse</code> operations</li>
<li>Validating entire collections and collecting all errors at once</li>
<li>The relationship between <code>sequence</code> and <code>traverse</code> for effectful operations</li>
</ul>
</div>
</div>
<p>The <strong><code>Foldable</code></strong> typeclass represents one of the most common and powerful patterns in functional programming: <strong>reducing a data structure to a single summary value</strong>. If you've ever calculated the sum of a list of numbers or concatenated a list of strings, you've performed a fold.</p>
<p><code>Foldable</code> abstracts this pattern, allowing you to write generic code that can aggregate any data structure that knows how to be folded.</p>
<hr />
<h2 id="what-is-it-6"><a class="header" href="#what-is-it-6">What is it?</a></h2>
<p>A typeclass is <code>Foldable</code> if it can be "folded up" from left to right into a summary value. The key to this process is the <strong><code>Monoid</code></strong>, which provides two essential things:</p>
<ol>
<li>An <strong><code>empty</code></strong> value to start with (e.g., <code>0</code> for addition).</li>
<li>A <strong><code>combine</code></strong> operation to accumulate the results (e.g., <code>+</code>).</li>
</ol>
<p>The core method of the <code>Foldable</code> typeclass is <strong><code>foldMap</code></strong>.</p>
<h3 id="the-foldmap-method"><a class="header" href="#the-foldmap-method">The <code>foldMap</code> Method</a></h3>
<p><code>foldMap</code> is a powerful operation that does two things in one step:</p>
<ol>
<li>It <strong>maps</strong> each element in the data structure to a value of a monoidal type.</li>
<li>It <strong>folds</strong> (combines) all of those monoidal values into a final result.</li>
</ol>
<p>The interface for <code>Foldable</code> in <code>hkj-api</code> is as follows:</p>
<pre><code class="language-java">public interface Foldable&lt;F&gt; {
  &lt;A, M&gt; M foldMap(
      Monoid&lt;M&gt; monoid,
      Function&lt;? super A, ? extends M&gt; f,
      Kind&lt;F, A&gt; fa
  );
}
</code></pre>
<hr />
<h3 id="why-is-it-useful-5"><a class="header" href="#why-is-it-useful-5">Why is it useful?</a></h3>
<p><code>Foldable</code> allows you to perform powerful aggregations on any data structure without needing to know its internal representation. By simply swapping out the <code>Monoid</code>, you can get completely different summaries from the same data.</p>
<p>Let's see this in action with <code>List</code>, which has a <code>Foldable</code> instance provided by <code>ListTraverse</code>.</p>
<p><strong>Example: Aggregating a List with Different Monoids</strong></p>
<pre><code class="language-java">// Our data
List&lt;Integer&gt; numbers = List.of(1, 2, 3, 4, 5);
Kind&lt;ListKind.Witness, Integer&gt; numbersKind = LIST.widen(numbers);

// Our Foldable instance for List
Foldable&lt;ListKind.Witness&gt; listFoldable = ListTraverse.INSTANCE;

// --- Scenario 1: Sum the numbers ---
// We use the integer addition monoid (empty = 0, combine = +)
Integer sum = listFoldable.foldMap(
    Monoids.integerAddition(),
    Function.identity(), // Map each number to itself
    numbersKind
);
// Result: 15

// --- Scenario 2: Check if all numbers are positive ---
// We map each number to a boolean and use the "AND" monoid (empty = true, combine = &amp;&amp;)
Boolean allPositive = listFoldable.foldMap(
    Monoids.booleanAnd(),
    num -&gt; num &gt; 0,
    numbersKind
);
// Result: true

// --- Scenario 3: Convert to strings and concatenate ---
// We map each number to a string and use the string monoid (empty = "", combine = +)
String asString = listFoldable.foldMap(
    Monoids.string(),
    String::valueOf,
    numbersKind
);
// Result: "12345"
</code></pre>
<p>As you can see, <code>foldMap</code> provides a single, abstract way to perform a wide variety of aggregations, making your code more declarative and reusable.</p>
<hr />
<h1 id="traverse-effectful-folding"><a class="header" href="#traverse-effectful-folding">Traverse: Effectful Folding</a></h1>
<p>The <strong><code>Traverse</code></strong> typeclass is a powerful extension of <code>Foldable</code> and <code>Functor</code>. It allows you to iterate over a data structure, but with a twist: at each step, you can perform an <strong>effectful</strong> action and then collect all the results back into a single effect.</p>
<p>This is one of the most useful typeclasses for real-world applications, as it elegantly handles scenarios like validating all items in a list, fetching data for each ID in a collection, and much more.</p>
<hr />
<h2 id="what-is-it-7"><a class="header" href="#what-is-it-7">What is it?</a></h2>
<p>A typeclass is <code>Traverse</code> if it can be "traversed" from left to right. The key to this process is the <strong><code>Applicative</code></strong>, which defines how to sequence the effects at each step.</p>
<p>The core method of the <code>Traverse</code> typeclass is <strong><code>traverse</code></strong>.</p>
<h3 id="the-traverse-method"><a class="header" href="#the-traverse-method">The <code>traverse</code> Method</a></h3>
<p>The <code>traverse</code> method takes a data structure and a function that maps each element to an effectful computation (wrapped in an <code>Applicative</code> like <code>Validated</code>, <code>Optional</code>, or <code>Either</code>). It then runs these effects in sequence and collects the results.</p>
<p>The true power of <code>traverse</code> is that it can turn a structure of effects "inside-out". For example, it can transform a <code>List&lt;Validated&lt;E, A&gt;&gt;</code> into a single <code>Validated&lt;E, List&lt;A&gt;&gt;</code>.</p>
<p>The interface for <code>Traverse</code> in <code>hkj-api</code> extends <code>Functor</code> and <code>Foldable</code>:</p>
<p><strong>Java</strong></p>
<pre><code>public interface Traverse&lt;T&gt; extends Functor&lt;T&gt;, Foldable&lt;T&gt; {
  &lt;F, A, B&gt; Kind&lt;F, Kind&lt;T, B&gt;&gt; traverse(
      Applicative&lt;F&gt; applicative,
      Function&lt;A, Kind&lt;F, B&gt;&gt; f,
      Kind&lt;T, A&gt; ta
  );
  //... sequenceA method also available
}
</code></pre>
<hr />
<h3 id="why-is-it-useful-6"><a class="header" href="#why-is-it-useful-6">Why is it useful?</a></h3>
<p><code>Traverse</code> abstracts away the boilerplate of iterating over a collection, performing a failable action on each element, and then correctly aggregating the results.</p>
<p><strong>Example: Validating a List of Promo Codes</strong></p>
<p>Imagine you have a list of promo codes, and you want to validate each one. Your validation function returns a <code>Validated&lt;String, PromoCode&gt;</code>. Without <code>traverse</code>, you'd have to write a manual loop, collect all the errors, and handle the logic yourself.</p>
<p>With <code>traverse</code>, this becomes a single, elegant expression.</p>
<p><strong>Java</strong></p>
<pre><code>// Our validation function
public Kind&lt;Validated.Witness&lt;String&gt;, String&gt; validateCode(String code) {
    if (code.startsWith("VALID")) {
        return VALIDATED.widen(Validated.valid(code));
    }
    return VALIDATED.widen(Validated.invalid("'" + code + "' is not a valid code"));
}

// Our data
List&lt;String&gt; codes = List.of("VALID-A", "EXPIRED", "VALID-B", "INVALID");
Kind&lt;ListKind.Witness, String&gt; codesKind = LIST.widen(codes);

// The Applicative for Validated, using a Semigroup to join errors
Applicative&lt;Validated.Witness&lt;String&gt;&gt; validatedApplicative =
    ValidatedMonad.instance(Semigroups.string("; "));

// --- Traverse the list ---
Kind&lt;Validated.Witness&lt;String&gt;, Kind&lt;ListKind.Witness, String&gt;&gt; result =
    ListTraverse.INSTANCE.traverse(
        validatedApplicative,
        this::validateCode,
        codesKind
    );

// The result is a single Validated instance with accumulated errors.
// Result: Invalid("'EXPIRED' is not a valid code; 'INVALID' is not a valid code")
System.out.println(VALIDATED.narrow(result));
</code></pre>
<h3 id="sequencea"><a class="header" href="#sequencea"><code>sequenceA</code></a></h3>
<p><code>Traverse</code> also provides <code>sequenceA</code>, which is a specialised version of <code>traverse</code>. It's used when you already have a data structure containing effects (e.g., a <code>List&lt;Optional&lt;A&gt;&gt;</code>) and you want to flip it into a single effect containing the data structure (<code>Optional&lt;List&lt;A&gt;&gt;</code>).</p>
<hr />
<div id="admonition-further-reading" class="admonition admonish-tip" role="note" aria-labelledby="admonition-further-reading-title">
<div class="admonition-title">
<div id="admonition-further-reading-title">
<p>Further Reading</p>
</div>
<a class="admonition-anchor-link" href="functional/foldable_and_traverse.html#admonition-further-reading"></a>
</div>
<div>
<ul>
<li><strong>Cats Documentation</strong>: <a href="https://typelevel.org/cats/typeclasses/foldable.html">Foldable</a> - Lazy folding with Foldable</li>
<li><strong>Cats Documentation</strong>: <a href="https://typelevel.org/cats/typeclasses/traverse.html">Traverse</a> - Traversing data structures with effects</li>
</ul>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="functional/semigroup_and_monoid.html">Semigroup and Monoid</a>
<strong>Next:</strong> <a href="functional/monad_zero.html">MonadZero</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="monadzero"><a class="header" href="#monadzero">MonadZero</a></h1>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="functional/monad_zero.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How MonadZero combines Monad and Alternative capabilities</li>
<li>The role of <code>zero()</code> as an absorbing element in monadic sequences</li>
<li>Enabling filtering in for-comprehensions with <code>when()</code></li>
<li>Practical examples using List, Maybe, and Optional</li>
<li>Writing generic functions for monads with failure semantics</li>
</ul>
</div>
</div>
<p>The <code>MonadZero</code> is a more advanced type class that extends both <code>Monad</code> and <code>Alternative</code> to combine the power of monadic bind with choice operations. It includes the concept of a "zero" or "empty" element and is designed for monads that can represent failure, absence, or emptiness, allowing them to be used in filtering operations and alternative chains.</p>
<p>The interface for MonadZero in hkj-api extends Monad and Alternative:</p>
<pre><code class="language-java">public interface MonadZero&lt;F&gt; extends Monad&lt;F&gt;, Alternative&lt;F&gt; {
    &lt;A&gt; Kind&lt;F, A&gt; zero();

    @Override
    default &lt;A&gt; Kind&lt;F, A&gt; empty() {
        return zero();
    }
}
</code></pre>
<h3 id="why-is-it-useful-7"><a class="header" href="#why-is-it-useful-7">Why is it useful?</a></h3>
<p>A <code>Monad</code> provides a way to sequence computations within a context (<code>flatMap</code>, <code>map</code>, <code>of</code>). An <code>Alternative</code> provides choice and failure operations (<code>empty()</code>, <code>orElse()</code>). A <code>MonadZero</code> combines both:</p>
<ul>
<li><code>zero()</code>: Returns the "empty" or "zero" element for the monad (implements <code>empty()</code> from Alternative).</li>
<li><code>orElse()</code>: Combines two alternatives (inherited from Alternative).</li>
<li><code>guard()</code>: Conditional success helper (inherited from Alternative).</li>
</ul>
<p>This <code>zero</code> element acts as an absorbing element in a monadic sequence, similar to how multiplying by zero results in zero. If a computation results in a <code>zero</code>, subsequent operations in the chain are typically skipped.</p>
<p><code>MonadZero</code> is particularly useful for making for-comprehensions more powerful. When you are working with a monad that has a <code>MonadZero</code> instance, you can use a <code>when()</code> clause to filter results within the comprehension.</p>
<p><strong>Key Implementations in this Project:</strong></p>
<ul>
<li>For <strong>List</strong>, <code>zero()</code> returns an empty list <code>[]</code>.</li>
<li>For <strong>Maybe</strong>, <code>zero()</code> returns <code>Nothing</code>.</li>
<li>For <strong>Optional</strong>, <code>zero()</code> returns <code>Optional.empty()</code>.</li>
</ul>
<h3 id="primary-uses-1"><a class="header" href="#primary-uses-1">Primary Uses</a></h3>
<p>The main purpose of <code>MonadZero</code> is to enable filtering within monadic comprehensions. It allows you to discard results that don't meet a certain criterion.</p>
<h4 id="1-filtering-in-for-comprehensions"><a class="header" href="#1-filtering-in-for-comprehensions">1. Filtering in For-Comprehensions</a></h4>
<p>As already mentioned the most powerful application in this codebase is within the <strong><code>For</code> comprehension builder</strong>. The builder has two entry points:</p>
<ul>
<li><code>For.from(monad, ...)</code>: For any standard <code>Monad</code>.</li>
<li><code>For.from(monadZero, ...)</code>: An overloaded version specifically for a <code>MonadZero</code>.</li>
</ul>
<p>Only the version that accepts a <code>MonadZero</code> provides the <code>.when(predicate)</code> filtering step. When the predicate in a <code>.when()</code> clause evaluates to <code>false</code>, the builder internally calls <code>monad.zero()</code> to terminate that specific computational path.</p>
<h4 id="2-generic-functions"><a class="header" href="#2-generic-functions">2. Generic Functions</a></h4>
<p>It allows you to write generic functions that can operate over any monad that has a concept of "failure" or "emptiness," such as <code>List</code>, <code>Maybe</code>, or <code>Optional</code>.</p>
<h3 id="code-example-for-comprehension-with-listmonad"><a class="header" href="#code-example-for-comprehension-with-listmonad">Code Example: <code>For</code> Comprehension with <code>ListMonad</code></a></h3>
<p>The following example demonstrates how <code>MonadZero</code> enables filtering.</p>
<pre><code class="language-java">import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.expression.For;
import org.higherkindedj.hkt.list.ListKind;
import org.higherkindedj.hkt.list.ListMonad;
import java.util.Arrays;
import java.util.List;

import static org.higherkindedj.hkt.list.ListKindHelper.LIST;

// 1. Get the MonadZero instance for List
final ListMonad listMonad = ListMonad.INSTANCE;

// 2. Define the initial data sources
final Kind&lt;ListKind.Witness, Integer&gt; list1 = LIST.widen(Arrays.asList(1, 2, 3));
final Kind&lt;ListKind.Witness, Integer&gt; list2 = LIST.widen(Arrays.asList(10, 20));

// 3. Build the comprehension using the filterable 'For'
final Kind&lt;ListKind.Witness, String&gt; result =
    For.from(listMonad, list1)                       // Start with a MonadZero
        .from(a -&gt; list2)                            // Generator (flatMap)
        .when(t -&gt; (t._1() + t._2()) % 2 != 0)        // Filter: if the sum is odd
        .let(t -&gt; "Sum: " + (t._1() + t._2()))        // Binding (map)
        .yield((a, b, c) -&gt; a + " + " + b + " = " + c); // Final projection

// 4. Unwrap the result
final List&lt;String&gt; narrow = LIST.narrow(result);
System.out.println("Result of List comprehension: " + narrow);
</code></pre>
<p><strong>Explanation:</strong></p>
<ul>
<li>The comprehension iterates through all pairs of <code>(a, b)</code> from <code>list1</code> and <code>list2</code>.</li>
<li>The <code>.when(...)</code> clause checks if the sum <code>a + b</code> is odd.</li>
<li>If the sum is even, the <code>monad.zero()</code> method (which returns an empty list) is invoked for that path, effectively discarding it.</li>
<li>If the sum is odd, the computation continues to the <code>.let()</code> and <code>.yield()</code> steps.</li>
</ul>
<p><strong>Output:</strong></p>
<p><code>Result of List comprehension: [1 + 10 = Sum: 11, 1 + 20 = Sum: 21, 3 + 10 = Sum: 13, 3 + 20 = Sum: 23]</code></p>
<hr />
<div id="admonition-see-also" class="admonition admonish-tip" role="note" aria-labelledby="admonition-see-also-title">
<div class="admonition-title">
<div id="admonition-see-also-title">
<p>See Also</p>
</div>
<a class="admonition-anchor-link" href="functional/monad_zero.html#admonition-see-also"></a>
</div>
<div>
<ul>
<li><a href="functional/alternative.html">Alternative</a> - The type class that MonadZero extends alongside Monad</li>
<li><a href="functional/for_comprehension.html">For Comprehension</a> - Using MonadZero's filtering capabilities in comprehensions</li>
</ul>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="functional/foldable_and_traverse.html">Foldable and Traverse</a>
<strong>Next:</strong> <a href="functional/selective.html">Selective</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="selective-conditional-effects"><a class="header" href="#selective-conditional-effects">Selective: Conditional Effects</a></h1>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="functional/selective.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How Selective bridges the gap between Applicative and Monad</li>
<li>Conditional effect execution without full monadic power</li>
<li>Using <code>select</code>, <code>whenS</code>, and <code>ifS</code> for static branching</li>
<li>Building robust workflows with compile-time visible alternatives</li>
<li>Combining multiple alternatives with <code>orElse</code></li>
<li>Real-world examples of conditional effect execution</li>
</ul>
</div>
</div>
<p>You've seen how <code>Applicative</code> lets you combine independent computations and how <code>Monad</code> lets you chain dependent computations. The <strong><code>Selective</code></strong> type class sits precisely between them, providing a powerful middle ground: <strong>conditional effects with static structure</strong>.</p>
<hr />
<h2 id="what-is-it-8"><a class="header" href="#what-is-it-8">What is it?</a></h2>
<p>A <strong><code>Selective</code></strong> functor extends <code>Applicative</code> with the ability to conditionally apply effects based on the result of a previous computation. Unlike <code>Monad</code>, which allows arbitrary dynamic choice of effects, Selective provides a more restricted form of conditional execution where all possible branches must be provided upfront.</p>
<p>This static structure enables:</p>
<ul>
<li><strong>Static analysis</strong>: All possible execution paths are visible at construction time</li>
<li><strong>Optimisation</strong>: Compilers and runtimes can analyse and potentially parallelise branches</li>
<li><strong>Conditional effects</strong>: Execute operations only when needed, without full monadic power</li>
<li><strong>Type-safe branching</strong>: All branches must produce the same result type</li>
</ul>
<p>The interface for <code>Selective</code> in <code>hkj-api</code> extends <code>Applicative</code>:</p>
<pre><code class="language-java">@NullMarked
public interface Selective&lt;F&gt; extends Applicative&lt;F&gt; {
  // Core operation
  &lt;A, B&gt; Kind&lt;F, B&gt; select(Kind&lt;F, Choice&lt;A, B&gt;&gt; fab, Kind&lt;F, Function&lt;A, B&gt;&gt; ff);

  // Derived operations
  default &lt;A&gt; Kind&lt;F, Unit&gt; whenS(Kind&lt;F, Boolean&gt; fcond, Kind&lt;F, Unit&gt; fa) { ... }
  default &lt;A&gt; Kind&lt;F, A&gt; ifS(Kind&lt;F, Boolean&gt; fcond, Kind&lt;F, A&gt; fthen, Kind&lt;F, A&gt; felse) { ... }
  default &lt;A, B, C&gt; Kind&lt;F, C&gt; branch(Kind&lt;F, Choice&lt;A, B&gt;&gt; fab,
                                       Kind&lt;F, Function&lt;A, C&gt;&gt; fl,
                                       Kind&lt;F, Function&lt;B, C&gt;&gt; fr) { ... }
  // ... and more
}
</code></pre>
<hr />
<h2 id="the-core-operation-select"><a class="header" href="#the-core-operation-select">The Core Operation: <code>select</code></a></h2>
<p>The fundamental operation is <code>select</code>, which takes a <code>Choice&lt;A, B&gt;</code> (similar to <code>Either</code>) and a function:</p>
<ul>
<li>If the choice is <code>Left(a)</code>, the function is applied to <code>a</code> to produce <code>B</code></li>
<li>If the choice is <code>Right(b)</code>, the function is ignored and <code>b</code> is returned</li>
</ul>
<p><strong>Example: Conditional Validation</strong></p>
<pre><code class="language-java">import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.Selective;
import org.higherkindedj.hkt.maybe.MaybeSelective;
import org.higherkindedj.hkt.maybe.Maybe;
import static org.higherkindedj.hkt.maybe.MaybeKindHelper.MAYBE;

Selective&lt;MaybeKind.Witness&gt; selective = MaybeSelective.INSTANCE;

// A value that might need validation
Kind&lt;MaybeKind.Witness, Choice&lt;String, Integer&gt;&gt; input =
    MAYBE.widen(Maybe.just(Selective.left("42"))); // Left: needs parsing

// Parser function (only applied if Choice is Left)
Kind&lt;MaybeKind.Witness, Function&lt;String, Integer&gt;&gt; parser =
    MAYBE.widen(Maybe.just(s -&gt; Integer.parseInt(s)));

Kind&lt;MaybeKind.Witness, Integer&gt; result = selective.select(input, parser);
// Result: Just(42)

// If input was already Right(42), parser would not be used
Kind&lt;MaybeKind.Witness, Choice&lt;String, Integer&gt;&gt; alreadyParsed =
    MAYBE.widen(Maybe.just(Selective.right(42)));

Kind&lt;MaybeKind.Witness, Integer&gt; result2 = selective.select(alreadyParsed, parser);
// Result: Just(42) - parser was not applied
</code></pre>
<hr />
<h2 id="conditional-effect-execution-whens"><a class="header" href="#conditional-effect-execution-whens">Conditional Effect Execution: <code>whenS</code></a></h2>
<p>The <code>whenS</code> operation is the primary way to conditionally execute effects. It takes an effectful boolean condition and an effect that returns <code>Unit</code>, executing the effect only if the condition is <code>true</code>.</p>
<p><strong>Example: Conditional Logging</strong></p>
<pre><code class="language-java">import org.higherkindedj.hkt.io.IOSelective;
import org.higherkindedj.hkt.io.IO;
import org.higherkindedj.hkt.Unit;
import static org.higherkindedj.hkt.io.IOKindHelper.IO_KIND;

Selective&lt;IOKind.Witness&gt; selective = IOSelective.INSTANCE;

// Check if debug mode is enabled
Kind&lt;IOKind.Witness, Boolean&gt; debugEnabled =
    IO_KIND.widen(IO.delay(() -&gt; Config.isDebugMode()));

// The logging effect (only executed if debug is enabled)
Kind&lt;IOKind.Witness, Unit&gt; logEffect =
    IO_KIND.widen(IO.fromRunnable(() -&gt; log.debug("Debug information")));

// Conditional execution
Kind&lt;IOKind.Witness, Unit&gt; maybeLog = selective.whenS(debugEnabled, logEffect);

// Run the IO
IO.narrow(maybeLog).unsafeRunSync();
// Only logs if Config.isDebugMode() returns true
</code></pre>
<h3 id="whens_-discarding-results"><a class="header" href="#whens_-discarding-results"><code>whenS_</code>: Discarding Results</a></h3>
<p>When you have an effect that returns a value but you want to treat it as a <code>Unit</code>-returning operation, use <code>whenS_</code>:</p>
<pre><code class="language-java">// Database write returns row count, but we don't care about the value
Kind&lt;IOKind.Witness, Integer&gt; writeEffect =
    IO_KIND.widen(IO.delay(() -&gt; database.write(data)));

Kind&lt;IOKind.Witness, Boolean&gt; shouldPersist =
    IO_KIND.widen(IO.delay(() -&gt; config.shouldPersist()));

// Discard the Integer result, treat as Unit
Kind&lt;IOKind.Witness, Unit&gt; maybeWrite = selective.whenS_(shouldPersist, writeEffect);
</code></pre>
<hr />
<h2 id="branching-ifs"><a class="header" href="#branching-ifs">Branching: <code>ifS</code></a></h2>
<p>The <code>ifS</code> operation provides if-then-else semantics for selective functors. Unlike monadic branching, both branches must be provided upfront.</p>
<p><strong>Example: Configuration-Based Behaviour</strong></p>
<pre><code class="language-java">import org.higherkindedj.hkt.either.EitherSelective;
import org.higherkindedj.hkt.either.Either;
import static org.higherkindedj.hkt.either.EitherKindHelper.EITHER;

Selective&lt;EitherKind.Witness&lt;String&gt;&gt; selective = EitherSelective.instance();

// Check environment
Kind&lt;EitherKind.Witness&lt;String&gt;, Boolean&gt; isProd =
    EITHER.widen(Either.right(System.getenv("ENV").equals("production")));

// Production configuration
Kind&lt;EitherKind.Witness&lt;String&gt;, Config&gt; prodConfig =
    EITHER.widen(Either.right(new Config("prod", 443, true)));

// Development configuration
Kind&lt;EitherKind.Witness&lt;String&gt;, Config&gt; devConfig =
    EITHER.widen(Either.right(new Config("dev", 8080, false)));

// Select configuration based on environment
Kind&lt;EitherKind.Witness&lt;String&gt;, Config&gt; config =
    selective.ifS(isProd, prodConfig, devConfig);

// Result: Either.right(Config("prod", 443, true)) if ENV=production
//         Either.right(Config("dev", 8080, false)) otherwise
</code></pre>
<hr />
<h2 id="trying-alternatives-orelse"><a class="header" href="#trying-alternatives-orelse">Trying Alternatives: <code>orElse</code></a></h2>
<p>The <code>orElse</code> operation tries multiple alternatives in sequence, returning the first successful result.</p>
<p><strong>Example: Fallback Configuration Sources</strong></p>
<pre><code class="language-java">import java.util.List;

Selective&lt;OptionalKind.Witness&gt; selective = OptionalSelective.INSTANCE;

// Try multiple configuration sources
List&lt;Kind&lt;OptionalKind.Witness, Choice&lt;String, Config&gt;&gt;&gt; sources = List.of(
    // Try environment variables
    OPTIONAL.widen(tryEnvConfig()),
    // Try config file
    OPTIONAL.widen(tryFileConfig()),
    // Try default config
    OPTIONAL.widen(Optional.of(Selective.right(defaultConfig())))
);

Kind&lt;OptionalKind.Witness, Choice&lt;String, Config&gt;&gt; result =
    selective.orElse(sources);

// Returns the first successful Config, or the last error
</code></pre>
<hr />
<h2 id="selective-vs-applicative-vs-monad"><a class="header" href="#selective-vs-applicative-vs-monad">Selective vs Applicative vs Monad</a></h2>
<p>Understanding the differences helps you choose the right abstraction:</p>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Applicative</th><th>Selective</th><th>Monad</th></tr></thead><tbody>
<tr><td><strong>Combine independent effects</strong></td><td>✅</td><td>✅</td><td>✅</td></tr>
<tr><td><strong>Conditional effects</strong></td><td>❌</td><td>✅</td><td>✅</td></tr>
<tr><td><strong>Dynamic effect choice</strong></td><td>❌</td><td>❌</td><td>✅</td></tr>
<tr><td><strong>Static structure</strong></td><td>✅</td><td>✅</td><td>❌</td></tr>
<tr><td><strong>Error accumulation</strong></td><td>✅ (with Validated)</td><td>✅ (with Validated)</td><td>❌</td></tr>
<tr><td><strong>Analyse all branches</strong></td><td>✅</td><td>✅</td><td>❌</td></tr>
</tbody></table>
</div>
<p><strong>When to use Selective:</strong></p>
<ul>
<li>You need conditional effects but want static analysis</li>
<li>All branches should be known at construction time</li>
<li>You want optimisation opportunities from visible alternatives</li>
<li>You need something more powerful than Applicative but less than Monad</li>
</ul>
<p><strong>Example: Static vs Dynamic Choice</strong></p>
<pre><code class="language-java">// Selective: Both branches visible at construction
Kind&lt;F, A&gt; selectiveChoice = selective.ifS(
    condition,
    branchA,  // Known upfront
    branchB   // Known upfront
);

// Monad: Second computation depends on first result (dynamic)
Kind&lt;M, B&gt; monadicChoice = monad.flatMap(a -&gt; {
    if (a &gt; 10) return computeX(a);  // Not known until 'a' is available
    else return computeY(a);
}, source);
</code></pre>
<hr />
<h2 id="multi-way-branching-branch"><a class="header" href="#multi-way-branching-branch">Multi-Way Branching: <code>branch</code></a></h2>
<p>For more complex branching, <code>branch</code> handles both sides of a <code>Choice</code> with different handlers:</p>
<pre><code class="language-java">Kind&lt;F, Choice&lt;ErrorA, ErrorB&gt;&gt; input = ...; // Could be either error type

Kind&lt;F, Function&lt;ErrorA, String&gt;&gt; handleA =
    selective.of(a -&gt; "Error type A: " + a);

Kind&lt;F, Function&lt;ErrorB, String&gt;&gt; handleB =
    selective.of(b -&gt; "Error type B: " + b);

Kind&lt;F, String&gt; result = selective.branch(input, handleA, handleB);
// Applies the appropriate handler based on which error type
</code></pre>
<h2 id="chaining-conditional-functions-aps"><a class="header" href="#chaining-conditional-functions-aps">Chaining Conditional Functions: <code>apS</code></a></h2>
<p>For chaining multiple conditional functions, <code>apS</code> applies a list of functions sequentially to a value, propagating either the successful result or the first error. It's useful for building a pipeline of validation or transformation steps.</p>
<p><strong>Example: Multi-Step Validation</strong></p>
<pre><code class="language-java">Kind&lt;F, Choice&lt;Error, Data&gt;&gt; initialData = ...;

List&lt;Kind&lt;F, Function&lt;Data, Choice&lt;Error, Data&gt;&gt;&gt;&gt; validationSteps = List.of(
    validateStep1,
    validateStep2,
    validateStep3
);

// Applies each validation step in order, short-circuiting on the first error.
Kind&lt;F, Choice&lt;Error, Data&gt;&gt; finalResult = selective.apS(initialData, validationSteps);
</code></pre>
<hr />
<hr />
<h2 id="real-world-example-feature-flags"><a class="header" href="#real-world-example-feature-flags">Real-World Example: Feature Flags</a></h2>
<p><strong>Scenario:</strong> Execute analytics tracking only if the feature flag is enabled.</p>
<pre><code class="language-java">import org.higherkindedj.hkt.io.IOSelective;
import org.higherkindedj.hkt.io.IO;
import static org.higherkindedj.hkt.io.IOKindHelper.IO_KIND;

public class AnalyticsService {
    private final Selective&lt;IOKind.Witness&gt; selective = IOSelective.INSTANCE;

    public Kind&lt;IOKind.Witness, Unit&gt; trackEvent(String eventName, User user) {
        // Check feature flag (effectful)
        Kind&lt;IOKind.Witness, Boolean&gt; flagEnabled =
            IO_KIND.widen(IO.delay(() -&gt; featureFlags.isEnabled("analytics")));

        // The tracking effect (potentially expensive)
        Kind&lt;IOKind.Witness, Unit&gt; trackingEffect =
            IO_KIND.widen(IO.fromRunnable(() -&gt; {
                analytics.track(eventName, user.id(), user.properties());
                log.info("Tracked event: " + eventName);
            }));

        // Only track if flag is enabled
        return selective.whenS(flagEnabled, trackingEffect);
    }
}

// Usage
AnalyticsService analytics = new AnalyticsService();
Kind&lt;IOKind.Witness, Unit&gt; trackingOperation =
    analytics.trackEvent("user_signup", currentUser);

// Execute the IO
IO.narrow(trackingOperation).unsafeRunSync();
// Only sends analytics if feature flag is enabled
</code></pre>
<hr />
<h2 id="implementations"><a class="header" href="#implementations">Implementations</a></h2>
<p>Higher-Kinded-J provides Selective instances for:</p>
<ul>
<li><strong><code>Either&lt;E, *&gt;</code></strong> - <code>EitherSelective</code></li>
<li><strong><code>Maybe</code></strong> - <code>MaybeSelective</code></li>
<li><strong><code>Optional</code></strong> - <code>OptionalSelective</code></li>
<li><strong><code>List</code></strong> - <code>ListSelective</code></li>
<li><strong><code>IO</code></strong> - <code>IOSelective</code></li>
<li><strong><code>Reader&lt;R, *&gt;</code></strong> - <code>ReaderSelective</code></li>
<li><strong><code>Id</code></strong> - <code>IdSelective</code></li>
<li><strong><code>Validated&lt;E, *&gt;</code></strong> - <code>ValidatedSelective</code></li>
</ul>
<hr />
<div id="admonition-key-takeaways" class="admonition admonish-info" role="note" aria-labelledby="admonition-key-takeaways-title">
<div class="admonition-title">
<div id="admonition-key-takeaways-title">
<p>Key Takeaways</p>
</div>
<a class="admonition-anchor-link" href="functional/selective.html#admonition-key-takeaways"></a>
</div>
<div>
<ul>
<li><strong>Selective sits between Applicative and Monad</strong>, providing conditional effects with static structure</li>
<li><strong><code>select</code> is the core operation</strong>, conditionally applying a function based on a <code>Choice</code></li>
<li><strong><code>whenS</code> enables conditional effect execution</strong>, perfect for feature flags and debug logging</li>
<li><strong><code>ifS</code> provides if-then-else semantics</strong> with both branches visible upfront</li>
<li><strong>All branches are known at construction time</strong>, enabling static analysis and optimisation</li>
<li><strong>Use Selective when you need conditional effects but want to avoid full monadic power</strong></li>
</ul>
</div>
</div>
<hr />
<div id="admonition-further-reading" class="admonition admonish-tip" role="note" aria-labelledby="admonition-further-reading-title">
<div class="admonition-title">
<div id="admonition-further-reading-title">
<p>Further Reading</p>
</div>
<a class="admonition-anchor-link" href="functional/selective.html#admonition-further-reading"></a>
</div>
<div>
<ul>
<li><strong>Selective Applicative Functors</strong>: <a href="https://dl.acm.org/doi/10.1145/3341694">Original Paper</a> - The academic paper introducing Selective functors</li>
<li><strong>Haskell Selective Library</strong>: <a href="https://hackage.haskell.org/package/selective">Hackage</a> - Reference implementation with additional examples</li>
</ul>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="functional/monad_zero.html">MonadZero</a>
<strong>Next:</strong> <a href="functional/profunctor.html">Profunctor</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="profunctor-building-adaptable-data-pipelines"><a class="header" href="#profunctor-building-adaptable-data-pipelines">Profunctor: Building Adaptable Data Pipelines</a></h1>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="functional/profunctor.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to build adaptable data transformation pipelines</li>
<li>The dual nature of Profunctors: contravariant inputs and covariant outputs</li>
<li>Using <code>lmap</code>, <code>rmap</code>, and <code>dimap</code> to adapt functions for different contexts</li>
<li>Creating flexible API adapters and validation pipelines</li>
<li>Real-world applications in data format transformation and system integration</li>
</ul>
</div>
</div>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="functional/profunctor.html#admonition-note"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/profunctor/ProfunctorExample.java">ProfunctorExample.java</a></p>
</div>
</div>
<p>So far, we've explored type classes that work with single type parameters: <code>Functor</code>, <code>Applicative</code>, and <code>Monad</code> all operate on types like <code>F&lt;A&gt;</code>. But what about types that take <em>two</em> parameters, like <code>Function&lt;A, B&gt;</code> or <code>Either&lt;L, R&gt;</code>? This is where <strong>Profunctors</strong> come in.</p>
<p>A <strong>Profunctor</strong> is a powerful abstraction for working with types that are <strong>contravariant</strong> in their first type parameter and <strong>covariant</strong> in their second. Think of it as a generalisation of how functions work: you can pre-process the input (contravariant) and post-process the output (covariant).</p>
<div id="admonition-note-1" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-1-title">
<div class="admonition-title">
<div id="admonition-note-1-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="functional/profunctor.html#admonition-note-1"></a>
</div>
<div>
<p>New to variance terminology? See the <a href="functional/../glossary.html">Glossary</a> for detailed explanations of covariant, contravariant, and invariant with Java-focused examples.</p>
</div>
</div>
<hr />
<h2 id="what-is-a-profunctor"><a class="header" href="#what-is-a-profunctor">What is a Profunctor?</a></h2>
<p>A <code>Profunctor</code> is a type class for any type constructor <code>P&lt;A, B&gt;</code> that supports three key operations:</p>
<ul>
<li><strong><code>lmap</code></strong>: Map over the first (input) type parameter contravariantly</li>
<li><strong><code>rmap</code></strong>: Map over the second (output) type parameter covariantly</li>
<li><strong><code>dimap</code></strong>: Map over both parameters simultaneously</li>
</ul>
<p>The interface for <code>Profunctor</code> in <code>hkj-api</code> works with <code>Kind2&lt;P, A, B&gt;</code>:</p>
<pre><code class="language-java">@NullMarked
public interface Profunctor&lt;P&gt; {
  
    // Map over the input (contravariant)
    default &lt;A, B, C&gt; Kind2&lt;P, C, B&gt; lmap(
        Function&lt;? super C, ? extends A&gt; f, 
        Kind2&lt;P, A, B&gt; pab) {
        return dimap(f, Function.identity(), pab);
    }

    // Map over the output (covariant)
    default &lt;A, B, C&gt; Kind2&lt;P, A, C&gt; rmap(
        Function&lt;? super B, ? extends C&gt; g, 
        Kind2&lt;P, A, B&gt; pab) {
        return dimap(Function.identity(), g, pab);
    }

    // Map over both input and output
    &lt;A, B, C, D&gt; Kind2&lt;P, C, D&gt; dimap(
        Function&lt;? super C, ? extends A&gt; f,
        Function&lt;? super B, ? extends D&gt; g,
        Kind2&lt;P, A, B&gt; pab);
}
</code></pre>
<hr />
<h2 id="the-canonical-example-functions"><a class="header" href="#the-canonical-example-functions">The Canonical Example: Functions</a></h2>
<p>The most intuitive example of a profunctor is the humble <code>Function&lt;A, B&gt;</code>. Functions are naturally:</p>
<ul>
<li><strong>Contravariant in their input</strong>: If you have a function <code>String -&gt; Integer</code>, you can adapt it to work with any type that can be converted <em>to</em> a <code>String</code></li>
<li><strong>Covariant in their output</strong>: You can adapt the same function to produce any type that an <code>Integer</code> can be converted <em>to</em></li>
</ul>
<p>Let's see this in action with <code>FunctionProfunctor</code>:</p>
<pre><code class="language-java">import static org.higherkindedj.hkt.func.FunctionKindHelper.FUNCTION;
import org.higherkindedj.hkt.func.FunctionProfunctor;

// Our original function: calculate string length
Function&lt;String, Integer&gt; stringLength = String::length;
Kind2&lt;FunctionKind.Witness, String, Integer&gt; lengthFunction = FUNCTION.widen(stringLength);

FunctionProfunctor profunctor = FunctionProfunctor.INSTANCE;

// LMAP: Adapt the input - now we can use integers!
Kind2&lt;FunctionKind.Witness, Integer, Integer&gt; intToLength =
    profunctor.lmap(Object::toString, lengthFunction);

Function&lt;Integer, Integer&gt; intLengthFunc = FUNCTION.getFunction(intToLength);
System.out.println(intLengthFunc.apply(12345)); // Output: 5

// RMAP: Adapt the output - now we get formatted strings!
Kind2&lt;FunctionKind.Witness, String, String&gt; lengthToString =
    profunctor.rmap(len -&gt; "Length: " + len, lengthFunction);

Function&lt;String, String&gt; lengthStringFunc = FUNCTION.getFunction(lengthToString);
System.out.println(lengthStringFunc.apply("Hello")); // Output: "Length: 5"

// DIMAP: Adapt both sides simultaneously
Kind2&lt;FunctionKind.Witness, Integer, String&gt; fullTransform =
    profunctor.dimap(
        Object::toString,           // int -&gt; string
        len -&gt; "Result: " + len,    // int -&gt; string
        lengthFunction);

Function&lt;Integer, String&gt; fullFunc = FUNCTION.getFunction(fullTransform);
System.out.println(fullFunc.apply(42)); // Output: "Result: 2"
</code></pre>
<hr />
<h2 id="why-profunctors-matter"><a class="header" href="#why-profunctors-matter">Why Profunctors Matter</a></h2>
<p>Profunctors excel at creating <strong>adaptable data transformation pipelines</strong>. They're particularly powerful for:</p>
<h3 id="1-api-adapters"><a class="header" href="#1-api-adapters">1. <strong>API Adapters</strong></a></h3>
<p>When you need to integrate with external systems that expect different data formats:</p>
<pre><code class="language-java">// Core business logic: validate a userLogin
Function&lt;User, ValidationResult&gt; validateUser = userLogin -&gt; {
    boolean isValid = userLogin.email().contains("@") &amp;&amp; !userLogin.name().isEmpty();
    return new ValidationResult(isValid, isValid ? "Valid userLogin" : "Invalid userLogin data");
};

// The API expects UserDto input and ApiResponse output
Kind2&lt;FunctionKind.Witness, UserDto, ApiResponse&lt;ValidationResult&gt;&gt; apiValidator =
    profunctor.dimap(
        // Convert UserDto -&gt; User (contravariant)
        dto -&gt; new User(dto.fullName(), dto.emailAddress(), 
                        LocalDate.parse(dto.birthDateString())),
        // Convert ValidationResult -&gt; ApiResponse (covariant)  
        result -&gt; new ApiResponse&lt;&gt;(result, "OK", result.isValid() ? 200 : 400),
        FUNCTION.widen(validateUser));

// Now our core logic works seamlessly with the external API format!
Function&lt;UserDto, ApiResponse&lt;ValidationResult&gt;&gt; apiFunc = FUNCTION.getFunction(apiValidator);
</code></pre>
<h3 id="2-validation-pipelines"><a class="header" href="#2-validation-pipelines">2. <strong>Validation Pipelines</strong></a></h3>
<p>Build reusable validation logic that adapts to different input and output formats:</p>
<pre><code class="language-java">// Core validation: check if a number is positive
Function&lt;Double, Boolean&gt; isPositive = x -&gt; x &gt; 0;

// Adapt for string input with detailed error messages
Kind2&lt;FunctionKind.Witness, String, String&gt; stringValidator =
    profunctor.dimap(
        // Parse string to double
        str -&gt; {
            try {
                return Double.parseDouble(str);
            } catch (NumberFormatException e) {
                return -1.0; // Invalid marker
            }
        },
        // Convert boolean to message
        isValid -&gt; isValid ? "✓ Valid positive number" : "✗ Not a positive number",
        FUNCTION.widen(isPositive));

Function&lt;String, String&gt; validator = FUNCTION.getFunction(stringValidator);
System.out.println(validator.apply("42.5"));  // "✓ Valid positive number"
System.out.println(validator.apply("-10"));   // "✗ Not a positive number"
</code></pre>
<h3 id="3-data-transformation-chains"><a class="header" href="#3-data-transformation-chains">3. <strong>Data Transformation Chains</strong></a></h3>
<p>Chain multiple adaptations to build complex data processing pipelines:</p>
<pre><code class="language-java">// Core transformation: User -&gt; UserDto  
Function&lt;User, UserDto&gt; userToDto = userLogin -&gt;
    new UserDto(userLogin.name(), userLogin.email(), 
                userLogin.birthDate().format(DateTimeFormatter.ISO_LOCAL_DATE));

// Build a CSV-to-JSON pipeline
Kind2&lt;FunctionKind.Witness, String, String&gt; csvToJsonTransform =
    profunctor.dimap(
        csvParser,    // String -&gt; User (parse CSV)
        dtoToJson,    // UserDto -&gt; String (serialise to JSON)
        FUNCTION.widen(userToDto));

// Add error handling with another rmap
Kind2&lt;FunctionKind.Witness, String, ApiResponse&lt;String&gt;&gt; safeTransform =
    profunctor.rmap(
        jsonString -&gt; {
            if (jsonString.contains("INVALID")) {
                return new ApiResponse&lt;&gt;("", "ERROR: Invalid input data", 400);
            }
            return new ApiResponse&lt;&gt;(jsonString, "SUCCESS", 200);
        },
        csvToJsonTransform);
</code></pre>
<hr />
<h2 id="profunctor-laws"><a class="header" href="#profunctor-laws">Profunctor Laws</a></h2>
<p>For a <code>Profunctor</code> to be lawful, it must satisfy two key properties:</p>
<ol>
<li><strong>Identity</strong>: <code>dimap(identity, identity, p) == p</code></li>
<li><strong>Composition</strong>: <code>dimap(f1 ∘ f2, g1 ∘ g2, p) == dimap(f2, g1, dimap(f1, g2, p))</code></li>
</ol>
<p>These laws ensure that profunctor operations are predictable and composable; you can build complex transformations by combining simpler ones without unexpected behaviour.</p>
<hr />
<h2 id="when-to-use-profunctors"><a class="header" href="#when-to-use-profunctors">When to Use Profunctors</a></h2>
<p>Profunctors are ideal when you need to:</p>
<ul>
<li><strong>Adapt existing functions</strong> to work with different input/output types</li>
<li><strong>Build flexible APIs</strong> that can handle multiple data formats</li>
<li><strong>Create reusable transformation pipelines</strong> that can be configured for different use cases</li>
<li><strong>Integrate with external systems</strong> without changing your core business logic</li>
<li><strong>Handle both sides of a computation</strong> (input preprocessing and output postprocessing)</li>
</ul>
<p>The next time you find yourself writing similar functions that differ only in their input parsing or output formatting, consider whether a profunctor could help you write the logic once and adapt it as needed!</p>
<hr />
<div id="admonition-further-reading" class="admonition admonish-tip" role="note" aria-labelledby="admonition-further-reading-title">
<div class="admonition-title">
<div id="admonition-further-reading-title">
<p>Further Reading</p>
</div>
<a class="admonition-anchor-link" href="functional/profunctor.html#admonition-further-reading"></a>
</div>
<div>
<ul>
<li><strong>Don't Fear the Profunctor Optics</strong>: <a href="https://github.com/hablapps/DontFearTheProfunctorOptics/blob/master/ProfunctorOptics.md">Tutorial</a> - Accessible introduction with practical examples</li>
<li><strong>Mojang/DataFixerUpper</strong>: <a href="https://github.com/Mojang/DataFixerUpper">Profunctor implementation</a> - Minecraft's profunctor optics library in Java, used for data transformation between game versions</li>
<li><strong>Community Documentation</strong>: <a href="https://github.com/kvverti/Documented-DataFixerUpper">Documented-DataFixerUpper</a> - Detailed explanations of Mojang's DFU library</li>
</ul>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="functional/selective.html">Selective</a>
<strong>Next:</strong> <a href="functional/bifunctor.html">Bifunctor</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="bifunctor-mapping-over-both-sides"><a class="header" href="#bifunctor-mapping-over-both-sides">Bifunctor: Mapping Over Both Sides</a></h1>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="functional/bifunctor.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to transform types with two covariant parameters independently or simultaneously</li>
<li>The difference between sum types (Either, Validated) and product types (Tuple2, Writer)</li>
<li>Using <code>bimap</code>, <code>first</code>, and <code>second</code> operations effectively</li>
<li>Transforming both error and success channels in validation scenarios</li>
<li>Real-world applications in API design, data migration, and error handling</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code:</p>
</div>
<a class="admonition-anchor-link" href="functional/bifunctor.html#admonition-see-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/bifunctor/BifunctorExample.java">BifunctorExample.java</a></p>
</div>
</div>
<p>Whilst <code>Functor</code> lets us map over types with a single parameter like <code>F&lt;A&gt;</code>, many useful types have <em>two</em> parameters. <code>Either&lt;L, R&gt;</code>, <code>Tuple2&lt;A, B&gt;</code>, <code>Validated&lt;E, A&gt;</code>, and <code>Writer&lt;W, A&gt;</code> all carry two distinct types. The <strong><code>Bifunctor</code></strong> type class provides a uniform interface for transforming both parameters.</p>
<p>Unlike <code>Profunctor</code>, which is contravariant in the first parameter and covariant in the second (representing input/output relationships), <code>Bifunctor</code> is <strong>covariant in both parameters</strong>. This makes it perfect for types where both sides hold data that can be independently transformed.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="functional/bifunctor.html#admonition-note"></a>
</div>
<div>
<p>New to variance terminology? See the <a href="functional/../glossary.html">Glossary</a> for detailed explanations of covariant, contravariant, and invariant with Java-focused examples.</p>
</div>
</div>
<hr />
<h2 id="what-is-a-bifunctor"><a class="header" href="#what-is-a-bifunctor">What is a Bifunctor?</a></h2>
<p>A <strong><code>Bifunctor</code></strong> is a type class for any type constructor <code>F&lt;A, B&gt;</code> that supports mapping over both its type parameters. It provides three core operations:</p>
<ul>
<li><strong><code>bimap</code></strong>: Transform both type parameters simultaneously</li>
<li><strong><code>first</code></strong>: Transform only the first type parameter</li>
<li><strong><code>second</code></strong>: Transform only the second type parameter</li>
</ul>
<p>The interface for <code>Bifunctor</code> in <code>hkj-api</code> works with <code>Kind2&lt;F, A, B&gt;</code>:</p>
<pre><code class="language-java">@NullMarked
public interface Bifunctor&lt;F&gt; {

    // Transform only the first parameter
    default &lt;A, B, C&gt; Kind2&lt;F, C, B&gt; first(
        Function&lt;? super A, ? extends C&gt; f,
        Kind2&lt;F, A, B&gt; fab) {
        return bimap(f, Function.identity(), fab);
    }

    // Transform only the second parameter
    default &lt;A, B, D&gt; Kind2&lt;F, A, D&gt; second(
        Function&lt;? super B, ? extends D&gt; g,
        Kind2&lt;F, A, B&gt; fab) {
        return bimap(Function.identity(), g, fab);
    }

    // Transform both parameters simultaneously
    &lt;A, B, C, D&gt; Kind2&lt;F, C, D&gt; bimap(
        Function&lt;? super A, ? extends C&gt; f,
        Function&lt;? super B, ? extends D&gt; g,
        Kind2&lt;F, A, B&gt; fab);
}
</code></pre>
<hr />
<h2 id="sum-types-vs-product-types"><a class="header" href="#sum-types-vs-product-types">Sum Types vs Product Types</a></h2>
<p>Understanding the distinction between <strong>sum types</strong> and <strong>product types</strong> is crucial to using bifunctors effectively.</p>
<h3 id="sum-types-exclusive-or"><a class="header" href="#sum-types-exclusive-or">Sum Types (Exclusive OR)</a></h3>
<p>A <strong>sum type</strong> represents a choice between alternatives: you have <em>either</em> one value <em>or</em> another, but never both. In type theory, if type <code>A</code> has <code>n</code> possible values and type <code>B</code> has <code>m</code> possible values, then <code>Either&lt;A, B&gt;</code> has <code>n + m</code> possible values (hence "sum").</p>
<p>Examples in higher-kinded-j:</p>
<ul>
<li><strong><code>Either&lt;L, R&gt;</code></strong>: Holds <em>either</em> a <code>Left</code> value (conventionally an error) <em>or</em> a <code>Right</code> value (conventionally a success)</li>
<li><strong><code>Validated&lt;E, A&gt;</code></strong>: Holds <em>either</em> an <code>Invalid</code> error <em>or</em> a <code>Valid</code> result</li>
</ul>
<p>When you use <code>bimap</code> on a sum type, only <em>one</em> of the two functions will actually execute, depending on which variant is present.</p>
<h3 id="product-types-both-and"><a class="header" href="#product-types-both-and">Product Types (Both AND)</a></h3>
<p>A <strong>product type</strong> contains multiple values simultaneously: you have <em>both</em> the first value <em>and</em> the second value. In type theory, if type <code>A</code> has <code>n</code> possible values and type <code>B</code> has <code>m</code> possible values, then <code>Tuple2&lt;A, B&gt;</code> has <code>n × m</code> possible values (hence "product").</p>
<p>Examples in higher-kinded-j:</p>
<ul>
<li><strong><code>Tuple2&lt;A, B&gt;</code></strong>: Holds <em>both</em> a first value <em>and</em> a second value</li>
<li><strong><code>Writer&lt;W, A&gt;</code></strong>: Holds <em>both</em> a log/output value <em>and</em> a computation result</li>
</ul>
<p>When you use <code>bimap</code> on a product type, <em>both</em> functions execute because both values are always present.</p>
<hr />
<h2 id="the-bifunctor-laws"><a class="header" href="#the-bifunctor-laws">The Bifunctor Laws</a></h2>
<p>For a <code>Bifunctor</code> to be lawful, it must satisfy two fundamental properties:</p>
<ol>
<li>
<p><strong>Identity Law</strong>: Mapping with identity functions changes nothing</p>
<pre><code class="language-java">bifunctor.bimap(x -&gt; x, y -&gt; y, fab); // Must be equivalent to fab
</code></pre>
</li>
<li>
<p><strong>Composition Law</strong>: Mapping with composed functions is equivalent to mapping in sequence</p>
<pre><code class="language-java">Function&lt;A, B&gt; f1 = ...;
Function&lt;B, C&gt; f2 = ...;
Function&lt;D, E&gt; g1 = ...;
Function&lt;E, F&gt; g2 = ...;

// These must be equivalent:
bifunctor.bimap(f2.compose(f1), g2.compose(g1), fab);
bifunctor.bimap(f2, g2, bifunctor.bimap(f1, g1, fab));
</code></pre>
</li>
</ol>
<p>These laws ensure that bifunctor operations are predictable, composable, and preserve the structure of your data.</p>
<hr />
<h2 id="why-is-it-useful-8"><a class="header" href="#why-is-it-useful-8">Why is it useful?</a></h2>
<p>Bifunctors provide a uniform interface for transforming dual-parameter types, which arise frequently in functional programming. Rather than learning different APIs for transforming <code>Either</code>, <code>Tuple2</code>, <code>Validated</code>, and <code>Writer</code>, you use the same operations everywhere.</p>
<h3 id="key-use-cases"><a class="header" href="#key-use-cases">Key Use Cases</a></h3>
<ul>
<li><strong>Error Handling</strong>: Transform both error and success channels simultaneously</li>
<li><strong>API Design</strong>: Normalise internal representations to external formats</li>
<li><strong>Data Migration</strong>: Convert both fields of legacy data structures</li>
<li><strong>Validation</strong>: Format both error messages and valid results</li>
<li><strong>Logging</strong>: Transform both the log output and the computation result</li>
</ul>
<hr />
<h2 id="example-1-either--a-sum-type"><a class="header" href="#example-1-either--a-sum-type">Example 1: Either – A Sum Type</a></h2>
<p><code>Either&lt;L, R&gt;</code> is the quintessential sum type. It holds <em>either</em> a <code>Left</code> (conventionally an error) <em>or</em> a <code>Right</code> (conventionally a success).</p>
<pre><code class="language-java">import static org.higherkindedj.hkt.either.EitherKindHelper.EITHER;
import org.higherkindedj.hkt.Bifunctor;
import org.higherkindedj.hkt.either.Either;
import org.higherkindedj.hkt.either.EitherBifunctor;
import org.higherkindedj.hkt.Kind2;

Bifunctor&lt;EitherKind2.Witness&gt; bifunctor = EitherBifunctor.INSTANCE;

// Success case: transform the Right channel
Either&lt;String, Integer&gt; success = Either.right(42);
Kind2&lt;EitherKind2.Witness, String, String&gt; formatted =
    bifunctor.second(
        n -&gt; "Success: " + n,
        EITHER.widen2(success));

System.out.println(EITHER.narrow2(formatted));
// Output: Right(Success: 42)

// Error case: transform the Left channel
Either&lt;String, Integer&gt; error = Either.left("FILE_NOT_FOUND");
Kind2&lt;EitherKind2.Witness, String, Integer&gt; enhanced =
    bifunctor.first(
        err -&gt; "Error Code: " + err,
        EITHER.widen2(error));

System.out.println(EITHER.narrow2(enhanced));
// Output: Left(Error Code: FILE_NOT_FOUND)

// Transform both channels with bimap
Either&lt;String, Integer&gt; either = Either.right(100);
Kind2&lt;EitherKind2.Witness, Integer, String&gt; both =
    bifunctor.bimap(
        String::length,        // Left: string -&gt; int (not executed here)
        n -&gt; "Value: " + n,    // Right: int -&gt; string (executed)
        EITHER.widen2(either));

System.out.println(EITHER.narrow2(both));
// Output: Right(Value: 100)
</code></pre>
<p><strong>Note:</strong> With <code>Either</code>, only one function in <code>bimap</code> executes because <code>Either</code> is a <em>sum type</em>: you have either Left <em>or</em> Right, never both.</p>
<hr />
<h2 id="example-2-tuple2--a-product-type"><a class="header" href="#example-2-tuple2--a-product-type">Example 2: Tuple2 – A Product Type</a></h2>
<p><code>Tuple2&lt;A, B&gt;</code> is a product type that holds <em>both</em> a first value <em>and</em> a second value simultaneously.</p>
<pre><code class="language-java">import static org.higherkindedj.hkt.tuple.Tuple2KindHelper.TUPLE2;
import org.higherkindedj.hkt.Bifunctor;
import org.higherkindedj.hkt.tuple.Tuple2;
import org.higherkindedj.hkt.tuple.Tuple2Bifunctor;

Bifunctor&lt;Tuple2Kind2.Witness&gt; bifunctor = Tuple2Bifunctor.INSTANCE;

// A tuple representing (name, age)
Tuple2&lt;String, Integer&gt; person = new Tuple2&lt;&gt;("Alice", 30);

// Transform only the first element
Kind2&lt;Tuple2Kind2.Witness, Integer, Integer&gt; nameLength =
    bifunctor.first(String::length, TUPLE2.widen2(person));

System.out.println(TUPLE2.narrow2(nameLength));
// Output: Tuple2(5, 30)

// Transform only the second element
Kind2&lt;Tuple2Kind2.Witness, String, String&gt; ageFormatted =
    bifunctor.second(age -&gt; age + " years", TUPLE2.widen2(person));

System.out.println(TUPLE2.narrow2(ageFormatted));
// Output: Tuple2(Alice, 30 years)

// Transform both simultaneously with bimap
Kind2&lt;Tuple2Kind2.Witness, String, String&gt; formatted =
    bifunctor.bimap(
        name -&gt; "Name: " + name,  // First: executed
        age -&gt; "Age: " + age,      // Second: executed
        TUPLE2.widen2(person));

System.out.println(TUPLE2.narrow2(formatted));
// Output: Tuple2(Name: Alice, Age: 30)
</code></pre>
<p><strong>Note:</strong> With <code>Tuple2</code>, both functions in <code>bimap</code> execute because <code>Tuple2</code> is a <em>product type</em>: both values are always present.</p>
<hr />
<h2 id="example-3-validated--error-accumulation"><a class="header" href="#example-3-validated--error-accumulation">Example 3: Validated – Error Accumulation</a></h2>
<p><code>Validated&lt;E, A&gt;</code> is a sum type designed for validation scenarios where you need to accumulate errors.</p>
<pre><code class="language-java">import static org.higherkindedj.hkt.validated.ValidatedKindHelper.VALIDATED;
import org.higherkindedj.hkt.Bifunctor;
import org.higherkindedj.hkt.validated.Validated;
import org.higherkindedj.hkt.validated.ValidatedBifunctor;
import java.util.List;

Bifunctor&lt;ValidatedKind2.Witness&gt; bifunctor = ValidatedBifunctor.INSTANCE;

// Valid case
Validated&lt;List&lt;String&gt;, Integer&gt; valid = Validated.valid(100);
Kind2&lt;ValidatedKind2.Witness, List&lt;String&gt;, String&gt; transformedValid =
    bifunctor.second(n -&gt; "Score: " + n, VALIDATED.widen2(valid));

System.out.println(VALIDATED.narrow2(transformedValid));
// Output: Valid(Score: 100)

// Invalid case with multiple errors
Validated&lt;List&lt;String&gt;, Integer&gt; invalid =
    Validated.invalid(List.of("TOO_SMALL", "OUT_OF_RANGE"));

// Transform errors to be more user-friendly
Kind2&lt;ValidatedKind2.Witness, String, Integer&gt; userFriendly =
    bifunctor.first(
        errors -&gt; "Validation failed: " + String.join(", ", errors),
        VALIDATED.widen2(invalid));

System.out.println(VALIDATED.narrow2(userFriendly));
// Output: Invalid(Validation failed: TOO_SMALL, OUT_OF_RANGE)
</code></pre>
<hr />
<h2 id="example-4-writer--logging-with-computation"><a class="header" href="#example-4-writer--logging-with-computation">Example 4: Writer – Logging with Computation</a></h2>
<p><code>Writer&lt;W, A&gt;</code> is a product type that holds <em>both</em> a log value <em>and</em> a computation result.</p>
<pre><code class="language-java">import static org.higherkindedj.hkt.writer.WriterKindHelper.WRITER;
import org.higherkindedj.hkt.Bifunctor;
import org.higherkindedj.hkt.writer.Writer;
import org.higherkindedj.hkt.writer.WriterBifunctor;

Bifunctor&lt;WriterKind2.Witness&gt; bifunctor = WriterBifunctor.INSTANCE;

// A Writer with a log and a result
Writer&lt;String, Integer&gt; computation = new Writer&lt;&gt;("Calculated: ", 42);

// Transform the log channel
Kind2&lt;WriterKind2.Witness, String, Integer&gt; uppercaseLog =
    bifunctor.first(String::toUpperCase, WRITER.widen2(computation));

System.out.println(WRITER.narrow2(uppercaseLog));
// Output: Writer(CALCULATED: , 42)

// Transform both log and result
Kind2&lt;WriterKind2.Witness, List&lt;String&gt;, String&gt; structured =
    bifunctor.bimap(
        log -&gt; List.of("[LOG]", log),   // Wrap log in structured format
        value -&gt; "Result: " + value,     // Format the result
        WRITER.widen2(computation));

System.out.println(WRITER.narrow2(structured));
// Output: Writer([LOG], Calculated: , Result: 42)
</code></pre>
<hr />
<h2 id="example-5-const--a-phantom-type-bifunctor"><a class="header" href="#example-5-const--a-phantom-type-bifunctor">Example 5: Const – A Phantom Type Bifunctor</a></h2>
<p><code>Const&lt;C, A&gt;</code> is a unique bifunctor where the second type parameter is <strong>phantom</strong> (not stored at runtime), making it perfect for fold operations, getters in lens libraries, and data extraction patterns.</p>
<pre><code class="language-java">import static org.higherkindedj.hkt.constant.ConstKindHelper.CONST;
import org.higherkindedj.hkt.Bifunctor;
import org.higherkindedj.hkt.constant.Const;
import org.higherkindedj.hkt.constant.ConstBifunctor;

Bifunctor&lt;ConstKind2.Witness&gt; bifunctor = ConstBifunctor.INSTANCE;

// A Const holding a count, with String as the phantom type
Const&lt;Integer, String&gt; count = new Const&lt;&gt;(42);
System.out.println("Original: " + count.value());
// Output: 42

// Transform the constant value with first()
Kind2&lt;ConstKind2.Witness, String, String&gt; transformed =
    bifunctor.first(
        n -&gt; "Count: " + n,  // Transforms the constant: 42 -&gt; "Count: 42"
        CONST.widen2(count));

System.out.println(CONST.narrow2(transformed).value());
// Output: "Count: 42"

// Transform ONLY the phantom type with second()
Kind2&lt;ConstKind2.Witness, Integer, Double&gt; phantomChanged =
    bifunctor.second(
        s -&gt; s.length() * 2.0,  // This defines the phantom type transformation
        CONST.widen2(count));

System.out.println(CONST.narrow2(phantomChanged).value());
// Output: 42 (UNCHANGED!)

// Use bimap() - but only first() affects the constant
Kind2&lt;ConstKind2.Witness, String, Boolean&gt; both =
    bifunctor.bimap(
        n -&gt; "#" + n,          // Transforms constant: 42 -&gt; "#42"
        s -&gt; s.isEmpty(),      // Phantom type transformation only
        CONST.widen2(count));

System.out.println(CONST.narrow2(both).value());
// Output: "#42"
</code></pre>
<p><strong>Note:</strong> With <code>Const</code>, the <code>second</code> function in <code>bimap</code> never affects the constant value because the second type parameter is phantom. This property makes <code>Const</code> ideal for folds that accumulate a single value whilst traversing a structure, and for implementing getters in van Laarhoven lens patterns.</p>
<p>For more on <code>Const</code> and its applications in folds and lens patterns, see the <a href="functional/../monads/const_type.html">Const Type documentation</a>.</p>
<hr />
<h2 id="real-world-scenario-api-response-transformation"><a class="header" href="#real-world-scenario-api-response-transformation">Real-World Scenario: API Response Transformation</a></h2>
<p>One of the most common uses of bifunctors is transforming internal data representations to external API formats.</p>
<pre><code class="language-java">// Internal representation uses simple error codes and domain objects
Either&lt;String, UserData&gt; internalResult = Either.left("USER_NOT_FOUND");

// External API requires structured error objects and formatted responses
Function&lt;String, ApiError&gt; toApiError =
    code -&gt; new ApiError(code, "Error occurred", 404);

Function&lt;UserData, ApiResponse&gt; toApiResponse =
    user -&gt; new ApiResponse(user.name(), user.email(), 200);

Bifunctor&lt;EitherKind2.Witness&gt; bifunctor = EitherBifunctor.INSTANCE;

Kind2&lt;EitherKind2.Witness, ApiError, ApiResponse&gt; apiResult =
    bifunctor.bimap(
        toApiError,     // Transform internal error to API error format
        toApiResponse,  // Transform internal data to API response format
        EITHER.widen2(internalResult));

// Result: Left(ApiError(USER_NOT_FOUND, Error occurred, 404))
</code></pre>
<p>This approach keeps your domain logic clean whilst providing flexible adaptation to external requirements.</p>
<hr />
<h2 id="bifunctor-vs-profunctor"><a class="header" href="#bifunctor-vs-profunctor">Bifunctor vs Profunctor</a></h2>
<p>Whilst both type classes work with dual-parameter types, they serve different purposes:</p>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Bifunctor</th><th>Profunctor</th></tr></thead><tbody>
<tr><td>First parameter</td><td>Covariant (output)</td><td>Contravariant (input)</td></tr>
<tr><td>Second parameter</td><td>Covariant (output)</td><td>Covariant (output)</td></tr>
<tr><td>Typical use</td><td>Data structures with two outputs</td><td>Functions and transformations</td></tr>
<tr><td>Examples</td><td><code>Either&lt;L, R&gt;</code>, <code>Tuple2&lt;A, B&gt;</code></td><td><code>Function&lt;A, B&gt;</code>, optics</td></tr>
<tr><td>Use case</td><td>Transform both "sides" of data</td><td>Adapt input and output of pipelines</td></tr>
</tbody></table>
</div>
<p><strong>Use Bifunctor when:</strong> Both parameters represent data you want to transform (errors and results, first and second elements).</p>
<p><strong>Use Profunctor when:</strong> The first parameter represents input (contravariant) and the second represents output (covariant), like in functions.</p>
<hr />
<h2 id="when-to-use-bifunctor"><a class="header" href="#when-to-use-bifunctor">When to Use Bifunctor</a></h2>
<p>Bifunctors are ideal when you need to:</p>
<ul>
<li><strong>Normalise API responses</strong> by transforming both error and success formats</li>
<li><strong>Migrate data schemas</strong> by transforming both fields of legacy structures</li>
<li><strong>Format validation results</strong> by enhancing both error messages and valid values</li>
<li><strong>Process paired data</strong> like tuples, logs with results, or any product type</li>
<li><strong>Handle sum types uniformly</strong> by providing transformations for all variants</li>
</ul>
<p>The power of bifunctors lies in their ability to abstract over the dual-parameter structure whilst preserving the semantics (sum vs product) of the underlying type.</p>
<hr />
<h2 id="summary-18"><a class="header" href="#summary-18">Summary</a></h2>
<ul>
<li><strong>Bifunctor</strong> provides <code>bimap</code>, <code>first</code>, and <code>second</code> for transforming dual-parameter types</li>
<li><strong>Sum types</strong> (Either, Validated) execute only one function based on which variant is present</li>
<li><strong>Product types</strong> (Tuple2, Writer) execute both functions since both values are present</li>
<li><strong>Use cases</strong> include API design, validation, data migration, and error handling</li>
<li><strong>Differs from Profunctor</strong> by being covariant in both parameters rather than contravariant/covariant</li>
</ul>
<p>Understanding bifunctors empowers you to write generic, reusable transformation logic that works uniformly across diverse dual-parameter types.</p>
<hr />
<div id="admonition-further-reading" class="admonition admonish-tip" role="note" aria-labelledby="admonition-further-reading-title">
<div class="admonition-title">
<div id="admonition-further-reading-title">
<p>Further Reading</p>
</div>
<a class="admonition-anchor-link" href="functional/bifunctor.html#admonition-further-reading"></a>
</div>
<div>
<ul>
<li><strong>Mark Seemann</strong>: <a href="https://blog.ploeh.dk/2018/12/24/bifunctors/">Bifunctors</a> - Excellent article explaining bifunctors with Either and Tuple examples</li>
<li><strong>The F-words</strong>: <a href="https://kubuszok.com/2018/the-f-words-functors-and-friends/">Functor and Friends</a> - Comprehensive overview including bifunctors</li>
<li><strong>Cats Documentation</strong>: <a href="https://typelevel.org/cats/typeclasses/bifunctor.html">Bifunctor</a> - Scala implementation and examples</li>
</ul>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="functional/profunctor.html">Profunctor</a>
<strong>Next:</strong> <a href="functional/natural_transformation.html">Natural Transformation</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="natural-transformation-1"><a class="header" href="#natural-transformation-1">Natural Transformation</a></h1>
<h2 id="polymorphic-functions-between-type-constructors"><a class="header" href="#polymorphic-functions-between-type-constructors"><em>Polymorphic Functions Between Type Constructors</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="functional/natural_transformation.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>What natural transformations are and why they matter</li>
<li>How to transform between different computational contexts</li>
<li>The naturality law and why it ensures correctness</li>
<li>Composing natural transformations</li>
<li>Using natural transformations with Free monads</li>
<li>Converting between types like Maybe, List, and Either</li>
</ul>
</div>
</div>
<div id="admonition-hands-on-practice" class="admonition admonish-note" role="note" aria-labelledby="admonition-hands-on-practice-title">
<div class="admonition-title">
<div id="admonition-hands-on-practice-title">
<p>Hands On Practice</p>
</div>
<a class="admonition-anchor-link" href="functional/natural_transformation.html#admonition-hands-on-practice"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/coretypes/Tutorial08_NaturalTransformation.java">Tutorial08_NaturalTransformation.java</a></p>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code</p>
</div>
<a class="admonition-anchor-link" href="functional/natural_transformation.html#admonition-see-example-code"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/test/java/org/higherkindedj/hkt/NaturalTest.java">NaturalTest.java</a> - Comprehensive test suite</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/natural/NaturalTransformationExample.java">NaturalTransformationExample.java</a> - Practical examples</li>
</ul>
</div>
</div>
<h2 id="purpose"><a class="header" href="#purpose">Purpose</a></h2>
<p>In functional programming, we often work with values wrapped in different contexts: <code>Maybe&lt;A&gt;</code>, <code>List&lt;A&gt;</code>, <code>Either&lt;E, A&gt;</code>, <code>IO&lt;A&gt;</code>, and so on. Sometimes we need to convert between these contexts whilst preserving the value inside.</p>
<p>A <strong>natural transformation</strong> is a polymorphic function that converts from one type constructor to another:</p>
<pre><code>F[A] ────Natural&lt;F, G&gt;────&gt; G[A]
</code></pre>
<p>The key insight is that this transformation works for <strong>any</strong> type <code>A</code>. It transforms the "container" without knowing or caring about what's inside.</p>
<h3 id="everyday-examples"><a class="header" href="#everyday-examples">Everyday Examples</a></h3>
<p>You've likely encountered natural transformations without realising it:</p>
<div class="table-wrapper"><table><thead><tr><th>From</th><th>To</th><th>Transformation</th></tr></thead><tbody>
<tr><td><code>Maybe&lt;A&gt;</code></td><td><code>List&lt;A&gt;</code></td><td>Nothing becomes <code>[]</code>, Just(x) becomes <code>[x]</code></td></tr>
<tr><td><code>List&lt;A&gt;</code></td><td><code>Maybe&lt;A&gt;</code></td><td>Take the head element (if any)</td></tr>
<tr><td><code>Either&lt;E, A&gt;</code></td><td><code>Maybe&lt;A&gt;</code></td><td>Left becomes Nothing, Right(x) becomes Just(x)</td></tr>
<tr><td><code>Try&lt;A&gt;</code></td><td><code>Either&lt;Throwable, A&gt;</code></td><td>Success/Failure maps to Right/Left</td></tr>
</tbody></table>
</div>
<h2 id="core-interface"><a class="header" href="#core-interface">Core Interface</a></h2>
<p>The <code>Natural&lt;F, G&gt;</code> interface in Higher-Kinded-J is straightforward:</p>
<pre><code class="language-java">@FunctionalInterface
public interface Natural&lt;F, G&gt; {

    /**
     * Applies this natural transformation to convert a value in context F to context G.
     */
    &lt;A&gt; Kind&lt;G, A&gt; apply(Kind&lt;F, A&gt; fa);

    /**
     * Composes this transformation with another: F ~&gt; G ~&gt; H becomes F ~&gt; H
     */
    default &lt;H&gt; Natural&lt;F, H&gt; andThen(Natural&lt;G, H&gt; after);

    /**
     * Composes another transformation before this one: E ~&gt; F ~&gt; G becomes E ~&gt; G
     */
    default &lt;E&gt; Natural&lt;E, G&gt; compose(Natural&lt;E, F&gt; before);

    /**
     * Returns the identity transformation: F ~&gt; F
     */
    static &lt;F&gt; Natural&lt;F, F&gt; identity();
}
</code></pre>
<p>The <code>@FunctionalInterface</code> annotation means you can implement natural transformations using lambda expressions.</p>
<h2 id="basic-usage-7"><a class="header" href="#basic-usage-7">Basic Usage</a></h2>
<h3 id="example-1-maybe-to-list"><a class="header" href="#example-1-maybe-to-list">Example 1: Maybe to List</a></h3>
<p>Converting a <code>Maybe</code> to a <code>List</code> is a classic natural transformation:</p>
<pre><code class="language-java">import static org.higherkindedj.hkt.maybe.MaybeKindHelper.MAYBE;
import static org.higherkindedj.hkt.list.ListKindHelper.LIST;

Natural&lt;MaybeKind.Witness, ListKind.Witness&gt; maybeToList = new Natural&lt;&gt;() {
    @Override
    public &lt;A&gt; Kind&lt;ListKind.Witness, A&gt; apply(Kind&lt;MaybeKind.Witness, A&gt; fa) {
        Maybe&lt;A&gt; maybe = MAYBE.narrow(fa);
        List&lt;A&gt; list = maybe.fold(
            () -&gt; List.of(),           // Nothing -&gt; empty list
            value -&gt; List.of(value)    // Just(x) -&gt; singleton list
        );
        return LIST.widen(list);
    }
};

// Usage
Kind&lt;MaybeKind.Witness, String&gt; maybeValue = MAYBE.widen(Maybe.just("hello"));
Kind&lt;ListKind.Witness, String&gt; listValue = maybeToList.apply(maybeValue);
// Result: List containing "hello"
</code></pre>
<h3 id="example-2-either-to-maybe"><a class="header" href="#example-2-either-to-maybe">Example 2: Either to Maybe</a></h3>
<p>Discarding the error information from an <code>Either</code>:</p>
<pre><code class="language-java">Natural&lt;EitherKind.Witness&lt;String&gt;, MaybeKind.Witness&gt; eitherToMaybe = new Natural&lt;&gt;() {
    @Override
    public &lt;A&gt; Kind&lt;MaybeKind.Witness, A&gt; apply(Kind&lt;EitherKind.Witness&lt;String&gt;, A&gt; fa) {
        Either&lt;String, A&gt; either = EITHER.&lt;String, A&gt;narrow(fa);
        return MAYBE.widen(
            either.fold(
                left -&gt; Maybe.nothing(),
                Maybe::just
            )
        );
    }
};
</code></pre>
<h3 id="example-3-list-head"><a class="header" href="#example-3-list-head">Example 3: List Head</a></h3>
<p>Getting the first element of a list (if any):</p>
<pre><code class="language-java">Natural&lt;ListKind.Witness, MaybeKind.Witness&gt; listHead = new Natural&lt;&gt;() {
    @Override
    public &lt;A&gt; Kind&lt;MaybeKind.Witness, A&gt; apply(Kind&lt;ListKind.Witness, A&gt; fa) {
        List&lt;A&gt; list = LIST.narrow(fa);
        return MAYBE.widen(
            list.isEmpty()
                ? Maybe.nothing()
                : Maybe.just(list.get(0))
        );
    }
};
</code></pre>
<h2 id="the-naturality-law"><a class="header" href="#the-naturality-law">The Naturality Law</a></h2>
<p>For a transformation to be truly "natural", it must satisfy the <strong>naturality law</strong>:</p>
<pre><code>For any function f: A -&gt; B and any value fa: F[A]
nat.apply(functor.map(f, fa)) == functor.map(f, nat.apply(fa))
</code></pre>
<p>In plain terms: it doesn't matter whether you map first then transform, or transform first then map. The diagram commutes:</p>
<pre><code>         map(f)
  F[A] ─────────&gt; F[B]
    │               │
nat │               │ nat
    ↓               ↓
  G[A] ─────────&gt; G[B]
         map(f)
</code></pre>
<h3 id="why-this-matters-1"><a class="header" href="#why-this-matters-1">Why This Matters</a></h3>
<p>The naturality law ensures that your transformation is <strong>structure-preserving</strong>. It doesn't peek inside the values or behave differently based on what type <code>A</code> is. This makes natural transformations predictable and composable.</p>
<div id="admonition-violating-the-naturality-law" class="admonition admonish-warning" role="note" aria-labelledby="admonition-violating-the-naturality-law-title">
<div class="admonition-title">
<div id="admonition-violating-the-naturality-law-title">
<p>Violating the Naturality Law</p>
</div>
<a class="admonition-anchor-link" href="functional/natural_transformation.html#admonition-violating-the-naturality-law"></a>
</div>
<div>
<p>A transformation that inspects the type of <code>A</code> or behaves inconsistently would violate naturality. For example, a "transformation" that converts <code>List&lt;Integer&gt;</code> differently from <code>List&lt;String&gt;</code> is not a natural transformation.</p>
</div>
</div>
<h2 id="composition"><a class="header" href="#composition">Composition</a></h2>
<p>Natural transformations compose beautifully. Given:</p>
<ul>
<li><code>nat1: F ~&gt; G</code></li>
<li><code>nat2: G ~&gt; H</code></li>
</ul>
<p>You can create <code>F ~&gt; H</code>:</p>
<pre><code class="language-java">Natural&lt;F, G&gt; maybeToEither = ...;
Natural&lt;G, H&gt; eitherToIO = ...;

// Compose to get Maybe ~&gt; IO
Natural&lt;F, H&gt; maybeToIO = maybeToEither.andThen(eitherToIO);
</code></pre>
<p>Composition is <strong>associative</strong>:</p>
<pre><code class="language-java">// These are equivalent:
(f.andThen(g)).andThen(h)
f.andThen(g.andThen(h))
</code></pre>
<h2 id="use-with-free-monads"><a class="header" href="#use-with-free-monads">Use with Free Monads</a></h2>
<p>The most common use case for natural transformations is <strong>interpreting Free monads</strong>. A Free monad program is built from an instruction set <code>F</code>, and a natural transformation <code>F ~&gt; M</code> interprets those instructions into a target monad <code>M</code>.</p>
<pre><code class="language-java">// Define DSL instructions
sealed interface ConsoleOp&lt;A&gt; {
    record PrintLine(String text) implements ConsoleOp&lt;Unit&gt; {}
    record ReadLine() implements ConsoleOp&lt;String&gt; {}
}

// Interpreter as natural transformation: ConsoleOp ~&gt; IO
Natural&lt;ConsoleOpKind.Witness, IOKind.Witness&gt; interpreter = new Natural&lt;&gt;() {
    @Override
    public &lt;A&gt; Kind&lt;IOKind.Witness, A&gt; apply(Kind&lt;ConsoleOpKind.Witness, A&gt; fa) {
        ConsoleOp&lt;A&gt; op = CONSOLE_OP.narrow(fa);
        return switch (op) {
            case ConsoleOp.PrintLine p -&gt; IO.widen(IO.of(() -&gt; {
                System.out.println(p.text());
                return (A) Unit.INSTANCE;
            }));
            case ConsoleOp.ReadLine r -&gt; IO.widen(IO.of(() -&gt; {
                return (A) scanner.nextLine();
            }));
        };
    }
};

// Use with Free monad's foldMap
Free&lt;ConsoleOpKind.Witness, String&gt; program = ...;
Kind&lt;IOKind.Witness, String&gt; executable = program.foldMap(interpreter, ioMonad);
</code></pre>
<div id="admonition-see-also" class="admonition admonish-tip" role="note" aria-labelledby="admonition-see-also-title">
<div class="admonition-title">
<div id="admonition-see-also-title">
<p>See Also</p>
</div>
<a class="admonition-anchor-link" href="functional/natural_transformation.html#admonition-see-also"></a>
</div>
<div>
<p>For a complete guide to building DSLs with Free monads and natural transformations, see the <a href="functional/../monads/free_monad.html">Free Monad</a> documentation.</p>
</div>
</div>
<h2 id="identity-transformation"><a class="header" href="#identity-transformation">Identity Transformation</a></h2>
<p>The identity natural transformation returns its input unchanged:</p>
<pre><code class="language-java">Natural&lt;F, F&gt; id = Natural.identity();
// id.apply(fa) == fa for all fa
</code></pre>
<p>This satisfies the identity laws for composition:</p>
<pre><code class="language-java">// Left identity
Natural.identity().andThen(nat) == nat

// Right identity
nat.andThen(Natural.identity()) == nat
</code></pre>
<h2 id="relationship-to-other-concepts"><a class="header" href="#relationship-to-other-concepts">Relationship to Other Concepts</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Concept</th><th>Relationship</th></tr></thead><tbody>
<tr><td><strong>Functor</strong></td><td>Natural transformations operate on Functors; the naturality law involves <code>map</code></td></tr>
<tr><td><strong>Free Monad</strong></td><td>Interpretation via <code>foldMap</code> uses natural transformations</td></tr>
<tr><td><strong>Free Applicative</strong></td><td>Interpretation via <code>foldMap</code> also uses natural transformations</td></tr>
<tr><td><strong>Monad Transformers</strong></td><td><code>lift</code> operations are natural transformations</td></tr>
<tr><td><strong>Coyoneda</strong></td><td>Lowering from Coyoneda uses a natural transformation internally</td></tr>
</tbody></table>
</div>
<h2 id="when-to-use-natural-transformations"><a class="header" href="#when-to-use-natural-transformations">When to Use Natural Transformations</a></h2>
<h3 id="good-use-cases"><a class="header" href="#good-use-cases">Good Use Cases</a></h3>
<ol>
<li><strong>Free monad/applicative interpretation</strong> - The primary use case</li>
<li><strong>Type conversions</strong> - Converting between similar container types</li>
<li><strong>Abstracting over interpreters</strong> - Swapping implementations at runtime</li>
<li><strong>Monad transformer lifting</strong> - Moving values up the transformer stack</li>
</ol>
<h3 id="when-you-might-not-need-them"><a class="header" href="#when-you-might-not-need-them">When You Might Not Need Them</a></h3>
<p>If you're simply converting a single concrete value (e.g., one specific <code>Maybe&lt;String&gt;</code> to <code>List&lt;String&gt;</code>), you can use regular methods. Natural transformations shine when you need the <strong>polymorphic</strong> behaviour, working uniformly across all types <code>A</code>.</p>
<h2 id="summary-19"><a class="header" href="#summary-19">Summary</a></h2>
<p>Natural transformations are polymorphic functions between type constructors that:</p>
<ul>
<li>Transform <code>F[A]</code> to <code>G[A]</code> for <strong>any</strong> type <code>A</code></li>
<li>Preserve structure (satisfy the naturality law)</li>
<li>Compose associatively</li>
<li>Form the basis for Free monad interpretation</li>
<li>Enable clean separation between program description and execution</li>
</ul>
<p>They are a fundamental building block in functional programming, particularly when working with effect systems and domain-specific languages.</p>
<hr />
<div id="admonition-further-reading" class="admonition admonish-tip" role="note" aria-labelledby="admonition-further-reading-title">
<div class="admonition-title">
<div id="admonition-further-reading-title">
<p>Further Reading</p>
</div>
<a class="admonition-anchor-link" href="functional/natural_transformation.html#admonition-further-reading"></a>
</div>
<div>
<ul>
<li><strong>Bartosz Milewski</strong>: <a href="https://bartoszmilewski.com/2015/04/07/natural-transformations/">Natural Transformations</a> - Accessible introduction with diagrams</li>
<li><strong>Cats Documentation</strong>: <a href="https://typelevel.org/cats/datatypes/functionk.html">FunctionK</a> - Scala's equivalent (called <code>~&gt;</code> or <code>FunctionK</code>)</li>
<li><strong>Functional Programming in Scala</strong>: Chapter 11 covers natural transformations in the context of Free monads</li>
</ul>
</div>
</div>
<div id="admonition-hands-on-learning" class="admonition admonish-info" role="note" aria-labelledby="admonition-hands-on-learning-title">
<div class="admonition-title">
<div id="admonition-hands-on-learning-title">
<p>Hands-On Learning</p>
</div>
<a class="admonition-anchor-link" href="functional/natural_transformation.html#admonition-hands-on-learning"></a>
</div>
<div>
<p>Practice natural transformations in <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/coretypes/Tutorial08_NaturalTransformation.java">Tutorial 08: Natural Transformation</a> (5 exercises, ~10 minutes).</p>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="functional/bifunctor.html">Bifunctor</a>
<strong>Next:</strong> <a href="functional/for_comprehension.html">For Comprehension</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="for-comprehensions"><a class="header" href="#for-comprehensions">For-Comprehensions</a></h1>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="functional/for_comprehension.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to transform nested <code>flatMap</code> chains into readable, sequential code</li>
<li>The four types of operations: generators (<code>.from()</code>), bindings (<code>.let()</code>), guards (<code>.when()</code>), and projections (<code>.yield()</code>)</li>
<li>Building complex workflows with StateT and other monad transformers</li>
<li>Converting "pyramid of doom" code into clean, imperative-style scripts</li>
<li>Real-world examples from simple Maybe operations to complex state management</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code:</p>
</div>
<a class="admonition-anchor-link" href="functional/for_comprehension.html#admonition-see-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/expression/ForComprehensionExample.java">ForComprehensionExample.java</a></p>
</div>
</div>
<p>Endless nested callbacks and unreadable chains of flatMap calls can be tiresome. The <code>higher-kinded-j</code> library brings the elegance and power of Scala-style for-comprehensions to Java, allowing you to write complex asynchronous and sequential logic in a way that is clean, declarative, and easy to follow.</p>
<p>Let's see how to transform "callback hell" into a readable, sequential script.</p>
<h2 id="the-pyramid-of-doom-problem"><a class="header" href="#the-pyramid-of-doom-problem">The "Pyramid of Doom" Problem</a></h2>
<p>In functional programming, monads are a powerful tool for sequencing operations, especially those with a context like <code>Optional</code>, <code>List</code>, or <code>CompletableFuture</code>. However, chaining these operations with <code>flatMap</code> can quickly become hard to read.</p>
<p>Consider combining three <code>Maybe</code> values:</p>
<pre><code class="language-java">// The "nested" way
Kind&lt;MaybeKind.Witness, Integer&gt; result = maybeMonad.flatMap(a -&gt;
    maybeMonad.flatMap(b -&gt;
        maybeMonad.map(c -&gt; a + b + c, maybeC),
    maybeB),
maybeA);
</code></pre>
<p>This code works, but the logic is buried inside nested lambdas. The intent (to simply get values from <code>maybeA</code>, <code>maybeB</code>, and <code>maybeC</code> and add them) is obscured. This is often called the "pyramid of doom."</p>
<h2 id="for-a-fluent-sequential-builder"><a class="header" href="#for-a-fluent-sequential-builder"><em>For</em> A Fluent, Sequential Builder</a></h2>
<p>The <code>For</code> comprehension builder provides a much more intuitive way to write the same logic. It lets you express the sequence of operations as if they were simple, imperative steps.</p>
<p>Here’s the same example rewritten with the <code>For</code> builder:</p>
<pre><code class="language-java">import static org.higherkindedj.hkt.maybe.MaybeKindHelper.MAYBE;
import org.higherkindedj.hkt.expression.For;
// ... other imports

var maybeMonad = MaybeMonad.INSTANCE;
var maybeA = MAYBE.just(5);
var maybeB = MAYBE.just(10);
var maybeC = MAYBE.just(20);

// The clean, sequential way
var result = For.from(maybeMonad, maybeA)    // Get a from maybeA
    .from(a -&gt; maybeB)                       // Then, get b from maybeB
    .from(t -&gt; maybeC)                       // Then, get c from maybeC
    .yield((a, b, c) -&gt; a + b + c);          // Finally, combine them

System.out.println(MAYBE.narrow(result)); // Prints: Just(35)
</code></pre>
<p>This version is flat, readable, and directly expresses the intended sequence of operations. The <code>For</code> builder automatically handles the <code>flatMap</code> and <code>map</code> calls behind the scenes.</p>
<h2 id="core-operations-of-the-for-builder"><a class="header" href="#core-operations-of-the-for-builder">Core Operations of the <code>For</code> Builder</a></h2>
<p>A for-comprehension is built by chaining four types of operations:</p>
<h3 id="1-generators-from"><a class="header" href="#1-generators-from">1. Generators: <code>.from()</code></a></h3>
<p>A generator is the workhorse of the comprehension. It takes a value from a previous step, uses it to produce a new monadic value (like another <code>Maybe</code> or <code>List</code>), and extracts the result for the next step. This is a direct equivalent of <strong><code>flatMap</code></strong>.</p>
<p>Each <code>.from()</code> adds a new variable to the scope of the comprehension.</p>
<pre><code class="language-java">// Generates all combinations of userLogin IDs and roles
var userRoles = For.from(listMonad, LIST.widen(List.of("userLogin-1", "userLogin-2"))) // a: "userLogin-1", "userLogin-2"
    .from(a -&gt; LIST.widen(List.of("viewer", "editor")))       // b: "viewer", "editor"
    .yield((a, b) -&gt; a + " is a " + b);

// Result: ["userLogin-1 is a viewer", "userLogin-1 is a editor", "userLogin-2 is a viewer", "userLogin-2 is a editor"]
</code></pre>
<h3 id="2-value-bindings-let"><a class="header" href="#2-value-bindings-let">2. Value Bindings: <code>.let()</code></a></h3>
<p>A <code>.let()</code> binding allows you to compute a pure, simple value from the results you've gathered so far and add it to the scope. It does <em>not</em> involve a monad. This is equivalent to a <strong><code>map</code></strong> operation that carries the new value forward.</p>
<pre><code class="language-java">var idMonad = IdMonad.instance();

var result = For.from(idMonad, Id.of(10))        // a = 10
    .let(a -&gt; a * 2)                          // b = 20 (a pure calculation)
    .yield((a, b) -&gt; "Value: " + a + ", Doubled: " + b);

// Result: "Value: 10, Doubled: 20"
System.out.println(ID.unwrap(result));
</code></pre>
<h3 id="3-guards-when"><a class="header" href="#3-guards-when">3. Guards: <code>.when()</code></a></h3>
<p>For monads that can represent failure or emptiness (like <code>List</code>, <code>Maybe</code>, or <code>Optional</code>), you can use <code>.when()</code> to <strong>filter</strong> results. If the condition is false, the current computational path is stopped by returning the monad's "zero" value (e.g., an empty list or <code>Maybe.nothing()</code>).</p>
<blockquote>
<p>This feature requires a <code>MonadZero</code> instance. See the <code>MonadZero</code> documentation for more details.</p>
</blockquote>
<pre><code class="language-java">var evens = For.from(listMonad, LIST.widen(List.of(1, 2, 3, 4, 5, 6)))
    .when(i -&gt; i % 2 == 0) // Guard: only keep even numbers
    .yield(i -&gt; i);

// Result: [2, 4, 6]
</code></pre>
<h3 id="4-projection-yield"><a class="header" href="#4-projection-yield">4. Projection: <code>.yield()</code></a></h3>
<p>Every comprehension ends with <code>.yield()</code>. This is the final <strong><code>map</code></strong> operation where you take all the values you've gathered from the generators and bindings and produce your final result. You can access the bound values as individual lambda parameters or as a single <code>Tuple</code>.</p>
<h2 id="turn-the-power-up-statet-example"><a class="header" href="#turn-the-power-up-statet-example">Turn the power up: <code>StateT</code> Example</a></h2>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/expression/ForComprehensionExample.java">ForComprehensionExample.java</a></li>
</ul>
<p>The true power of for-comprehensions becomes apparent when working with complex structures like monad transformers. A <code>StateT</code> over <code>Optional</code> represents a <strong>stateful computation that can fail</strong>. Writing this with nested <code>flatMap</code> calls would be extremely complex. With the <code>For</code> builder, it becomes a simple, readable script.</p>
<pre><code class="language-java">import static org.higherkindedj.hkt.optional.OptionalKindHelper.OPTIONAL;
import static org.higherkindedj.hkt.state_t.StateTKindHelper.STATE_T;
// ... other imports

private static void stateTExample() {
    final var optionalMonad = OptionalMonad.INSTANCE;
    final var stateTMonad = StateTMonad.&lt;Integer, OptionalKind.Witness&gt;instance(optionalMonad);

    // Helper: adds a value to the state (an integer)
    final Function&lt;Integer, Kind&lt;StateTKind.Witness&lt;Integer, OptionalKind.Witness&gt;, Unit&gt;&gt; add =
        n -&gt; StateT.create(s -&gt; optionalMonad.of(StateTuple.of(s + n, Unit.INSTANCE)), optionalMonad);

    // Helper: gets the current state as the value
    final var get = StateT.&lt;Integer, OptionalKind.Witness, Integer&gt;create(s -&gt; optionalMonad.of(StateTuple.of(s, s)), optionalMonad);

    // This workflow looks like a simple script, but it's a fully-typed, purely functional composition!
    final var statefulComputation =
        For.from(stateTMonad, add.apply(10))      // Add 10 to state
            .from(a -&gt; add.apply(5))              // Then, add 5 more
            .from(b -&gt; get)                       // Then, get the current state (15)
            .let(t -&gt; "The state is " + t._3())   // Compute a string from it
            .yield((a, b, c, d) -&gt; d + ", original value was " + c); // Produce the final string

    // Run the computation with an initial state of 0
    final var resultOptional = STATE_T.runStateT(statefulComputation, 0);
    final Optional&lt;StateTuple&lt;Integer, String&gt;&gt; result = OPTIONAL.narrow(resultOptional);

    result.ifPresent(res -&gt; {
        System.out.println("Final value: " + res.value());
        System.out.println("Final state: " + res.state());
    });
    // Expected Output:
    // Final value: The state is 15, original value was 15
    // Final state: 15
}
</code></pre>
<p>In this example, Using the <code>For</code> comprehension really helps hide the complexity of threading the state (<code>Integer</code>) and handling potential failures (<code>Optional</code>), making the logic clear and maintainable.</p>
<p>For a more extensive example of using the full power of the For comprehension head over to the <a href="functional/../hkts/order-walkthrough.html">Order Workflow</a></p>
<h2 id="similarities-to-scala"><a class="header" href="#similarities-to-scala">Similarities to Scala</a></h2>
<p>If you're familiar with Scala, you'll recognise the pattern. In Scala, a for-comprehension looks like this:</p>
<pre><code class="language-scala">for {
 a &lt;- maybeA
 b &lt;- maybeB
 if (a + b &gt; 10)
 c = a + b
} yield c * 2
</code></pre>
<p>This is built in syntactic sugar that the compiler translates into a series of <code>flatMap</code>, <code>map</code>, and <code>withFilter</code> calls.
The <code>For</code> builder in <code>higher-kinded-j</code> provides the same expressive power through a method-chaining API.</p>
<hr />
<h2 id="working-with-optics"><a class="header" href="#working-with-optics">Working with Optics</a></h2>
<div id="admonition-for-optics-integration" class="admonition admonish-info" role="note" aria-labelledby="admonition-for-optics-integration-title">
<div class="admonition-title">
<div id="admonition-for-optics-integration-title">
<p>For-Optics Integration</p>
</div>
<a class="admonition-anchor-link" href="functional/for_comprehension.html#admonition-for-optics-integration"></a>
</div>
<div>
<p>The For comprehension integrates natively with the <a href="functional/../optics/optics_intro.html">Optics</a> library, providing first-class support for lens-based extraction, prism-based pattern matching, and traversal-based iteration within monadic comprehensions.</p>
</div>
</div>
<p>The <code>For</code> builder provides two optic-aware operations that extend the comprehension capabilities:</p>
<h3 id="extracting-values-with-focus"><a class="header" href="#extracting-values-with-focus">Extracting Values with <code>focus()</code></a></h3>
<p>The <code>focus()</code> method extracts a value using a function and adds it to the accumulated tuple. This is particularly useful when working with nested data structures.</p>
<pre><code class="language-java">record User(String name, Address address) {}
record Address(String city, String street) {}

var users = List.of(
    new User("Alice", new Address("London", "Baker St")),
    new User("Bob", new Address("Paris", "Champs-Élysées"))
);

Kind&lt;ListKind.Witness, String&gt; result =
    For.from(listMonad, LIST.widen(users))
        .focus(user -&gt; user.address().city())
        .yield((user, city) -&gt; user.name() + " lives in " + city);

// Result: ["Alice lives in London", "Bob lives in Paris"]
</code></pre>
<p>The extracted value is accumulated alongside the original value, making both available in subsequent steps and in the final <code>yield()</code>.</p>
<h3 id="pattern-matching-with-match-1"><a class="header" href="#pattern-matching-with-match-1">Pattern Matching with <code>match()</code></a></h3>
<p>The <code>match()</code> method provides prism-like pattern matching within comprehensions. When used with a <code>MonadZero</code> (such as <code>List</code> or <code>Maybe</code>), it short-circuits the computation if the match fails.</p>
<pre><code class="language-java">sealed interface Result permits Success, Failure {}
record Success(String value) implements Result {}
record Failure(String error) implements Result {}

Prism&lt;Result, Success&gt; successPrism = Prism.of(
    r -&gt; r instanceof Success s ? Optional.of(s) : Optional.empty(),
    s -&gt; s
);

List&lt;Result&gt; results = List.of(
    new Success("data1"),
    new Failure("error"),
    new Success("data2")
);

Kind&lt;ListKind.Witness, String&gt; successes =
    For.from(listMonad, LIST.widen(results))
        .match(successPrism)
        .yield((result, success) -&gt; success.value().toUpperCase());

// Result: ["DATA1", "DATA2"] - failures are filtered out
</code></pre>
<p>With <code>Maybe</code>, failed matches short-circuit to <code>Nothing</code>:</p>
<pre><code class="language-java">Kind&lt;MaybeKind.Witness, String&gt; result =
    For.from(maybeMonad, MAYBE.just((Result) new Failure("error")))
        .match(successPrism)
        .yield((r, s) -&gt; s.value());

// Result: Nothing - the match failed
</code></pre>
<div id="admonition-combining-focus-and-match" class="admonition admonish-tip" role="note" aria-labelledby="admonition-combining-focus-and-match-title">
<div class="admonition-title">
<div id="admonition-combining-focus-and-match-title">
<p>Combining focus() and match()</p>
</div>
<a class="admonition-anchor-link" href="functional/for_comprehension.html#admonition-combining-focus-and-match"></a>
</div>
<div>
<p>Both operations can be chained to build complex extraction and filtering pipelines:</p>
<pre><code class="language-java">For.from(listMonad, LIST.widen(items))
    .focus(item -&gt; item.category())
    .match(premiumCategoryPrism)
    .when(t -&gt; t._3().discount() &gt; 0.1)
    .yield((item, category, premium) -&gt; item.name());
</code></pre>
</div>
</div>
<hr />
<h2 id="bulk-operations-with-fortraversal"><a class="header" href="#bulk-operations-with-fortraversal">Bulk Operations with ForTraversal</a></h2>
<p>For operations over multiple elements within a structure, use <code>ForTraversal</code>. This provides a fluent API for applying transformations to all elements focused by a <a href="functional/../optics/traversals.html">Traversal</a>.</p>
<pre><code class="language-java">record Player(String name, int score) {}

List&lt;Player&gt; players = List.of(
    new Player("Alice", 100),
    new Player("Bob", 200)
);

Traversal&lt;List&lt;Player&gt;, Player&gt; playersTraversal = Traversals.forList();
Lens&lt;Player, Integer&gt; scoreLens = Lens.of(
    Player::score,
    (p, s) -&gt; new Player(p.name(), s)
);

// Add bonus points to all players
Kind&lt;IdKind.Witness, List&lt;Player&gt;&gt; result =
    ForTraversal.over(playersTraversal, players, IdMonad.instance())
        .modify(scoreLens, score -&gt; score + 50)
        .run();

List&lt;Player&gt; updated = IdKindHelper.ID.unwrap(result);
// Result: [Player("Alice", 150), Player("Bob", 250)]
</code></pre>
<h3 id="filtering-within-traversals"><a class="header" href="#filtering-within-traversals">Filtering Within Traversals</a></h3>
<p>The <code>filter()</code> method preserves non-matching elements unchanged whilst applying transformations only to matching elements:</p>
<pre><code class="language-java">Kind&lt;IdKind.Witness, List&lt;Player&gt;&gt; result =
    ForTraversal.over(playersTraversal, players, IdMonad.instance())
        .filter(p -&gt; p.score() &gt;= 150)
        .modify(scoreLens, score -&gt; score * 2)
        .run();

// Alice (100) unchanged, Bob (200) doubled to 400
</code></pre>
<h3 id="collecting-results"><a class="header" href="#collecting-results">Collecting Results</a></h3>
<p>Use <code>toList()</code> to collect all focused elements:</p>
<pre><code class="language-java">Kind&lt;IdKind.Witness, List&lt;Player&gt;&gt; allPlayers =
    ForTraversal.over(playersTraversal, players, IdMonad.instance())
        .toList();
</code></pre>
<hr />
<h2 id="stateful-updates-with-forstate"><a class="header" href="#stateful-updates-with-forstate">Stateful Updates with ForState</a></h2>
<p><code>ForState</code> provides a fluent API for threading state updates through a workflow using lenses. This is particularly useful for building up complex state transformations step by step.</p>
<pre><code class="language-java">record WorkflowContext(
    String orderId,
    boolean validated,
    boolean inventoryChecked,
    String confirmationId
) {}

Lens&lt;WorkflowContext, Boolean&gt; validatedLens = Lens.of(
    WorkflowContext::validated,
    (ctx, v) -&gt; new WorkflowContext(ctx.orderId(), v, ctx.inventoryChecked(), ctx.confirmationId())
);

Lens&lt;WorkflowContext, Boolean&gt; inventoryLens = Lens.of(
    WorkflowContext::inventoryChecked,
    (ctx, c) -&gt; new WorkflowContext(ctx.orderId(), ctx.validated(), c, ctx.confirmationId())
);

Lens&lt;WorkflowContext, String&gt; confirmationLens = Lens.of(
    WorkflowContext::confirmationId,
    (ctx, id) -&gt; new WorkflowContext(ctx.orderId(), ctx.validated(), ctx.inventoryChecked(), id)
);

var initialContext = new WorkflowContext("ORD-123", false, false, null);

Kind&lt;IdKind.Witness, WorkflowContext&gt; result =
    ForState.withState(idMonad, Id.of(initialContext))
        .update(validatedLens, true)
        .update(inventoryLens, true)
        .update(confirmationLens, "CONF-456")
        .yield();

WorkflowContext finalCtx = IdKindHelper.ID.unwrap(result);
// finalCtx: validated=true, inventoryChecked=true, confirmationId="CONF-456"
</code></pre>
<h3 id="modifying-state-based-on-current-values"><a class="header" href="#modifying-state-based-on-current-values">Modifying State Based on Current Values</a></h3>
<p>Use <code>modify()</code> to update state based on the current value:</p>
<pre><code class="language-java">ForState.withState(idMonad, Id.of(context))
    .modify(scoreLens, score -&gt; score + bonus)
    .yield();
</code></pre>
<hr />
<h2 id="position-aware-traversals-with-forindexed"><a class="header" href="#position-aware-traversals-with-forindexed">Position-Aware Traversals with ForIndexed</a></h2>
<p><code>ForIndexed</code> extends traversal comprehensions to include index/position awareness, enabling transformations that depend on element position within the structure.</p>
<pre><code class="language-java">IndexedTraversal&lt;Integer, List&lt;Player&gt;, Player&gt; indexedPlayers =
    IndexedTraversals.forList();

List&lt;Player&gt; players = List.of(
    new Player("Alice", 100),
    new Player("Bob", 200),
    new Player("Charlie", 150)
);

// Add position-based bonus (first place gets more)
Kind&lt;IdKind.Witness, List&lt;Player&gt;&gt; result =
    ForIndexed.overIndexed(indexedPlayers, players, IdMonad.instance())
        .modify(scoreLens, (index, score) -&gt; score + (100 - index * 10))
        .run();

// Alice: 100 + 100 = 200
// Bob: 200 + 90 = 290
// Charlie: 150 + 80 = 230
</code></pre>
<h3 id="filtering-by-position"><a class="header" href="#filtering-by-position">Filtering by Position</a></h3>
<p>Use <code>filterIndex()</code> to focus only on specific positions:</p>
<pre><code class="language-java">// Only modify top 3 players
ForIndexed.overIndexed(indexedPlayers, players, idApplicative)
    .filterIndex(i -&gt; i &lt; 3)
    .modify(scoreLens, (i, s) -&gt; s * 2)
    .run();
</code></pre>
<h3 id="combined-index-and-value-filtering"><a class="header" href="#combined-index-and-value-filtering">Combined Index and Value Filtering</a></h3>
<p>Use <code>filter()</code> with a <code>BiPredicate</code> to filter based on both position and value:</p>
<pre><code class="language-java">ForIndexed.overIndexed(indexedPlayers, players, idApplicative)
    .filter((index, player) -&gt; index &lt; 5 &amp;&amp; player.score() &gt; 100)
    .modify(scoreLens, (i, s) -&gt; s + 50)
    .run();
</code></pre>
<h3 id="collecting-with-indices"><a class="header" href="#collecting-with-indices">Collecting with Indices</a></h3>
<p>Use <code>toIndexedList()</code> to collect elements along with their indices:</p>
<pre><code class="language-java">Kind&lt;IdKind.Witness, List&lt;Pair&lt;Integer, Player&gt;&gt;&gt; indexed =
    ForIndexed.overIndexed(indexedPlayers, players, idApplicative)
        .toIndexedList();

// Result: [Pair(0, Player("Alice", 100)), Pair(1, Player("Bob", 200)), ...]
</code></pre>
<div id="admonition-see-also" class="admonition admonish-tip" role="note" aria-labelledby="admonition-see-also-title">
<div class="admonition-title">
<div id="admonition-see-also-title">
<p>See Also</p>
</div>
<a class="admonition-anchor-link" href="functional/for_comprehension.html#admonition-see-also"></a>
</div>
<div>
<p>For more details on indexed optics, see <a href="functional/../optics/indexed_optics.html">Indexed Optics</a>.</p>
</div>
</div>
<div id="admonition-see-also-1" class="admonition admonish-tip" role="note" aria-labelledby="admonition-see-also-1-title">
<div class="admonition-title">
<div id="admonition-see-also-1-title">
<p>See Also</p>
</div>
<a class="admonition-anchor-link" href="functional/for_comprehension.html#admonition-see-also-1"></a>
</div>
<div>
<ul>
<li><a href="functional/../effect/forpath_comprehension.html">ForPath Comprehension</a> - For-comprehensions that work directly with Effect Path types</li>
</ul>
</div>
</div>
<hr />
<div id="admonition-further-reading" class="admonition admonish-tip" role="note" aria-labelledby="admonition-further-reading-title">
<div class="admonition-title">
<div id="admonition-further-reading-title">
<p>Further Reading</p>
</div>
<a class="admonition-anchor-link" href="functional/for_comprehension.html#admonition-further-reading"></a>
</div>
<div>
<ul>
<li><strong>Scala For-Comprehensions</strong>: <a href="https://docs.scala-lang.org/tour/for-comprehensions.html">Tour of Scala</a> - The inspiration for this API</li>
</ul>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="functional/natural_transformation.html">Natural Transformation</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="foundations-core-types"><a class="header" href="#foundations-core-types">Foundations: Core Types</a></h1>
<blockquote>
<p><em>"Everything was beautiful and nothing hurt."</em></p>
<p>– Kurt Vonnegut, <em>Slaughterhouse-Five</em></p>
</blockquote>
<hr />
<div id="admonition-prefer-effect-paths-for-everyday-use" class="admonition admonish-tip" role="note" aria-labelledby="admonition-prefer-effect-paths-for-everyday-use-title">
<div class="admonition-title">
<div id="admonition-prefer-effect-paths-for-everyday-use-title">
<p>Prefer Effect Paths for Everyday Use</p>
</div>
<a class="admonition-anchor-link" href="monads/ch_intro.html#admonition-prefer-effect-paths-for-everyday-use"></a>
</div>
<div>
<p>While this chapter documents the underlying core types, <strong>most applications should use the <a href="monads/../effect/ch_intro.html">Effect Path API</a></strong> for cleaner composition and unified error handling. Effect Paths like <code>EitherPath</code>, <code>MaybePath</code>, and <code>TryPath</code> wrap these types and provide:</p>
<ul>
<li>A consistent API across all effect types (<code>map</code>, <code>via</code>, <code>recover</code>)</li>
<li>Seamless integration with the <a href="monads/../optics/focus_dsl.html">Focus DSL</a></li>
<li>Railway-oriented programming for flat, readable pipelines</li>
</ul>
<p>Use this chapter as a <strong>reference</strong> for understanding the foundations that power the Effect Path API.</p>
</div>
</div>
<hr />
<p>Within a monadic context, certain complexities simply vanish. Null checks disappear inside <code>Maybe</code>. Error propagation becomes implicit within <code>Either</code>. Asynchronous callbacks flatten into sequential steps with <code>CompletableFuture</code>. The mess remains (it must), but the monad contains it, and within that containment, everything is beautiful and nothing hurts.</p>
<p>This chapter surveys the types that Higher-Kinded-J supports: seventeen distinct monads, each representing a different computational context. Some wrap standard Java types (<code>Optional</code>, <code>List</code>, <code>CompletableFuture</code>). Others are library-defined (<code>Maybe</code>, <code>Either</code>, <code>IO</code>, <code>Validated</code>). Still others handle advanced concerns like state management (<code>State</code>, <code>Reader</code>, <code>Writer</code>) or stack-safe recursion (<code>Trampoline</code>, <code>Free</code>).</p>
<p>Each type has its purpose. <code>Id</code> does nothing, which makes it useful as a baseline. <code>Maybe</code> and <code>Optional</code> handle absence. <code>Either</code> and <code>Try</code> handle failure with information. <code>IO</code> defers side effects. <code>Lazy</code> memoises computations. <code>Reader</code> threads configuration. <code>State</code> manages mutable state purely. <code>Writer</code> accumulates logs. <code>Validated</code> gathers all errors rather than stopping at the first.</p>
<p>The art lies in choosing the right context for the problem at hand. Sometimes you need fail-fast semantics; sometimes you need error accumulation. Sometimes laziness helps; sometimes it hinders. This chapter provides the vocabulary. Experience provides the judgement.</p>
<div id="admonition-hands-on-practice" class="admonition admonish-note" role="note" aria-labelledby="admonition-hands-on-practice-title">
<div class="admonition-title">
<div id="admonition-hands-on-practice-title">
<p>Hands On Practice</p>
</div>
<a class="admonition-anchor-link" href="monads/ch_intro.html#admonition-hands-on-practice"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/coretypes/Tutorial07_RealWorld.java">Tutorial07_RealWorld.java</a></p>
</div>
</div>
<hr />
<h2 id="the-landscape"><a class="header" href="#the-landscape">The Landscape</a></h2>
<pre><code>    ┌─────────────────────────────────────────────────────────────┐
    │  ABSENCE                                                    │
    │    Maybe         Optional         (value or nothing)        │
    └─────────────────────────────────────────────────────────────┘

    ┌─────────────────────────────────────────────────────────────┐
    │  FAILURE                                                    │
    │    Either        Try         Validated   (error handling)   │
    └─────────────────────────────────────────────────────────────┘

    ┌─────────────────────────────────────────────────────────────┐
    │  EFFECTS                                                    │
    │    IO       CompletableFuture    (deferred/async execution) │
    └─────────────────────────────────────────────────────────────┘

    ┌─────────────────────────────────────────────────────────────┐
    │  COLLECTIONS                                                │
    │    List          Stream           (multiple values)         │
    └─────────────────────────────────────────────────────────────┘

    ┌─────────────────────────────────────────────────────────────┐
    │  ENVIRONMENT                                                │
    │    Reader       State       Writer   (contextual computation)│
    └─────────────────────────────────────────────────────────────┘

    ┌─────────────────────────────────────────────────────────────┐
    │  CONTROL                                                    │
    │    Lazy      Trampoline      Free    (evaluation strategy)  │
    └─────────────────────────────────────────────────────────────┘
</code></pre>
<hr />
<h2 id="choosing-the-right-type"><a class="header" href="#choosing-the-right-type">Choosing the Right Type</a></h2>
<p>A rough decision guide:</p>
<div class="table-wrapper"><table><thead><tr><th>Need</th><th>Type</th><th>Why</th></tr></thead><tbody>
<tr><td>Value might be absent</td><td><code>Maybe</code> or <code>Optional</code></td><td>Explicit absence handling</td></tr>
<tr><td>Operation might fail</td><td><code>Either&lt;E, A&gt;</code></td><td>Typed error with information</td></tr>
<tr><td>Might throw exceptions</td><td><code>Try&lt;A&gt;</code></td><td>Captures Throwable</td></tr>
<tr><td>Accumulate all errors</td><td><code>Validated&lt;E, A&gt;</code></td><td>Fail-slow validation</td></tr>
<tr><td>Defer side effects</td><td><code>IO&lt;A&gt;</code></td><td>Referential transparency</td></tr>
<tr><td>Run asynchronously</td><td><code>CompletableFuture&lt;A&gt;</code></td><td>Non-blocking execution</td></tr>
<tr><td>Multiple results</td><td><code>List&lt;A&gt;</code> or <code>Stream&lt;A&gt;</code></td><td>Non-determinism</td></tr>
<tr><td>Read configuration</td><td><code>Reader&lt;R, A&gt;</code></td><td>Dependency injection</td></tr>
<tr><td>Track state changes</td><td><code>State&lt;S, A&gt;</code></td><td>Pure state management</td></tr>
<tr><td>Log operations</td><td><code>Writer&lt;W, A&gt;</code></td><td>Accumulate output</td></tr>
<tr><td>Deep recursion</td><td><code>Trampoline&lt;A&gt;</code></td><td>Stack safety</td></tr>
<tr><td>Build DSLs</td><td><code>Free&lt;F, A&gt;</code></td><td>Separate description from execution</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="what-youll-learn-11"><a class="header" href="#what-youll-learn-11">What You'll Learn</a></h2>
<div id="admonition-in-this-chapter" class="admonition admonish-info" role="note" aria-labelledby="admonition-in-this-chapter-title">
<div class="admonition-title">
<div id="admonition-in-this-chapter-title">
<p>In This Chapter</p>
</div>
<a class="admonition-anchor-link" href="monads/ch_intro.html#admonition-in-this-chapter"></a>
</div>
<div>
<ul>
<li><strong>Identity</strong> – The trivial monad that simply wraps a value unchanged. Useful as a baseline for testing and as a placeholder in generic code.</li>
<li><strong>Maybe and Optional</strong> – Two approaches to representing absent values. Maybe is the library's own implementation; Optional wraps Java's <code>java.util.Optional</code>.</li>
<li><strong>Either</strong> – Represents computations that can fail with typed error information. Unlike exceptions, the error type is explicit in the signature.</li>
<li><strong>Try</strong> – Captures exceptions as values, converting thrown errors into a failed Try. Bridges imperative exception handling with functional composition.</li>
<li><strong>Validated</strong> – Like Either, but accumulates all errors rather than stopping at the first. Essential for form validation and batch processing.</li>
<li><strong>List and Stream</strong> – Model non-deterministic computation where operations can produce multiple results. Stream adds laziness for infinite or large sequences.</li>
<li><strong>CompletableFuture</strong> – Wraps Java's CompletableFuture for asynchronous computation, enabling monadic composition of async operations.</li>
<li><strong>IO</strong> – Defers side effects until explicitly run, maintaining referential transparency. Effects are described, not executed, until interpretation.</li>
<li><strong>Lazy</strong> – Delays computation until the value is needed, then memoises the result. Useful for expensive computations that may never be required.</li>
<li><strong>Reader</strong> – Threads a read-only environment through computations. A functional approach to dependency injection.</li>
<li><strong>State</strong> – Threads mutable state through a computation while maintaining purity. Each step receives state and produces new state alongside its result.</li>
<li><strong>Writer</strong> – Accumulates output (typically logs) alongside computation results. The output type must be a Monoid for combining.</li>
<li><strong>Trampoline</strong> – Enables stack-safe recursion by converting recursive calls into a heap-allocated data structure.</li>
<li><strong>Free</strong> – Represents programs as data structures that can be interpreted in multiple ways. The foundation for building embedded DSLs.</li>
<li><strong>Const</strong> – Ignores its second type parameter, carrying only the first. Useful for accumulating values during traversals.</li>
</ul>
</div>
</div>
<hr />
<h2 id="chapter-contents-11"><a class="header" href="#chapter-contents-11">Chapter Contents</a></h2>
<ol>
<li><a href="monads/supported-types.html">Supported Types</a> - Overview of all seventeen monadic types</li>
<li><a href="monads/cf_monad.html">CompletableFuture</a> - Asynchronous computation</li>
<li><a href="monads/either_monad.html">Either</a> - Typed, informative failure</li>
<li><a href="monads/identity.html">Identity</a> - The simplest monad, doing nothing</li>
<li><a href="monads/io_monad.html">IO</a> - Deferred side effects</li>
<li><a href="monads/lazy_monad.html">Lazy</a> - Memoised computation</li>
<li><a href="monads/list_monad.html">List</a> - Multiple values (non-determinism)</li>
<li><a href="monads/maybe_monad.html">Maybe</a> - Handling absence</li>
<li><a href="monads/optional_monad.html">Optional</a> - Java's Optional as a monad</li>
<li><a href="monads/reader_monad.html">Reader</a> - Environment access</li>
<li><a href="monads/state_monad.html">State</a> - Pure state threading</li>
<li><a href="monads/stream_monad.html">Stream</a> - Lazy sequences</li>
<li><a href="monads/trampoline_monad.html">Trampoline</a> - Stack-safe recursion</li>
<li><a href="monads/free_monad.html">Free</a> - Programs as data</li>
<li><a href="monads/free_applicative.html">Free Applicative</a> - Static analysis of programs</li>
<li><a href="monads/coyoneda.html">Coyoneda</a> - Free functor for any type</li>
<li><a href="monads/try_monad.html">Try</a> - Exception capture</li>
<li><a href="monads/validated_monad.html">Validated</a> - Error accumulation</li>
<li><a href="monads/writer_monad.html">Writer</a> - Output accumulation</li>
<li><a href="monads/const_type.html">Const</a> - Phantom-typed constants</li>
</ol>
<div id="admonition-hands-on-learning" class="admonition admonish-info" role="note" aria-labelledby="admonition-hands-on-learning-title">
<div class="admonition-title">
<div id="admonition-hands-on-learning-title">
<p>Hands-On Learning</p>
</div>
<a class="admonition-anchor-link" href="monads/ch_intro.html#admonition-hands-on-learning"></a>
</div>
<div>
<p>Practice real-world monad patterns in <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/coretypes/Tutorial07_RealWorld.java">Tutorial 07: Real World</a> (6 exercises, ~12 minutes).</p>
</div>
</div>
<hr />
<p><strong>Next:</strong> <a href="monads/supported-types.html">Supported Types</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="supported-types"><a class="header" href="#supported-types">Supported Types</a></h1>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="monads/supported-types.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How Higher-Kinded-J simulates higher-kinded types in Java using the Kind pattern</li>
<li>The unified pattern used across all types: Kind interfaces, Witness types, and Helper classes</li>
<li>The complete catalog of 17 supported types, from basic types like Id and List to advanced types like Free and monad transformers</li>
<li>The difference between external Java types (Optional, List) and library-defined types (Maybe, Either, IO)</li>
<li>Where to find detailed documentation and examples for each supported type</li>
</ul>
</div>
</div>
<div id="admonition-hands-on-practice" class="admonition admonish-note" role="note" aria-labelledby="admonition-hands-on-practice-title">
<div class="admonition-title">
<div id="admonition-hands-on-practice-title">
<p>Hands On Practice</p>
</div>
<a class="admonition-anchor-link" href="monads/supported-types.html#admonition-hands-on-practice"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/coretypes/Tutorial06_ConcreteTypes.java">Tutorial06_ConcreteTypes.java</a></p>
</div>
</div>
<p><img src="monads/../images/monads_everywhere.webp" alt="monads_everywhere.webp" /></p>
<p>Higher-Kinded-J provides Higher-Kinded Type (HKT) simulation capabilities, allowing various Java types and custom types to be used with generic functional type classes like <code>Functor</code>, <code>Applicative</code>, <code>Monad</code>, and <code>MonadError</code>.</p>
<p>This is achieved by representing the application of a type constructor <code>F</code> to a type <code>A</code> as <code>Kind&lt;F_WITNESS, A&gt;</code>, where <code>F_WITNESS</code> is a special "witness" or phantom type unique to the type constructor <code>F</code>.</p>
<p><img src="monads/../images/puml/supported_types.svg" alt="supported_types.svg" /></p>
<hr />
<p><strong>Key for Understanding Entries:</strong></p>
<ul>
<li><strong>Type:</strong> The Java type or custom type being simulated.</li>
<li><strong><code>XxxKind&lt;A&gt;</code> Interface:</strong> The specific <code>Kind</code> interface for this type (e.g., <code>OptionalKind&lt;A&gt;</code>). It extends <code>Kind&lt;XxxKind.Witness, A&gt;</code> and usually contains the nested <code>final class Witness {}</code>.</li>
<li><strong>Witness Type <code>F_WITNESS</code>:</strong> The phantom type used as the first parameter to <code>Kind</code> (e.g., <code>OptionalKind.Witness</code>). This is what parameterizes the type classes (e.g., <code>Monad&lt;OptionalKind.Witness&gt;</code>).</li>
<li><strong><code>XxxKindHelper</code> Class:</strong> Provides <code>widen</code> and <code>narrow</code> methods.
<ul>
<li>For <strong>external types</strong> (like <code>java.util.List</code>, <code>java.util.Optional</code>), <code>widen</code> typically creates an internal <code>XxxHolder</code> record which implements <code>XxxKind&lt;A&gt;</code>, and <code>narrow</code> extracts the Java type from this holder.</li>
<li>For <strong>library-defined types</strong> (<code>Id</code>, <code>IO</code>, <code>Maybe</code>, <code>Either</code>, <code>Validated</code>, <code>Try</code>, monad transformers), the type itself directly implements <code>XxxKind&lt;A&gt;</code>. This means <code>widen</code> performs a null check and direct cast (zero overhead), and <code>narrow</code> checks <code>instanceof</code> the actual type and casts.</li>
</ul>
</li>
<li><strong>Type Class Instances:</strong> Concrete implementations of <code>Functor&lt;F_WITNESS&gt;</code>, <code>Monad&lt;F_WITNESS&gt;</code>, etc.</li>
</ul>
<hr />
<h3 id="1-ida-identity"><a class="header" href="#1-ida-identity">1. <code>Id&lt;A&gt;</code> (Identity)</a></h3>
<ul>
<li><strong>Type Definition</strong>: A custom record (<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/id/Id.java"><code>Id</code></a>) that directly wraps a value <code>A</code>. It's the simplest monad.</li>
<li><strong><code>IdKind&lt;A&gt;</code> Interface</strong>: <code>Id&lt;A&gt;</code> itself implements <code>IdKind&lt;A&gt;</code>, and <code>IdKind&lt;A&gt; extends Kind&lt;IdKind.Witness, A&gt;</code>.</li>
<li><strong>Witness Type <code>F_WITNESS</code></strong>: <code>IdKind.Witness</code></li>
<li><strong><code>IdKindHelper</code></strong>: <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/id/IdKindHelper.java"><code>IdKindHelper</code></a> (<code>wrap</code> casts <code>Id</code> to <code>Kind</code>, <code>unwrap</code> casts <code>Kind</code> to <code>Id</code>; <code>narrow</code> is a convenience for unwrap).</li>
<li><strong>Type Class Instances</strong>:
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/id/IdMonad.java"><code>IdMonad</code></a> (<code>Monad&lt;IdKind.Witness&gt;</code>)</li>
</ul>
</li>
<li><strong>Notes</strong>: <code>Id.of(a)</code> creates <code>Id(a)</code>. <code>map</code> and <code>flatMap</code> operate directly. Useful as a base for monad transformers and generic programming with no extra effects. <code>Id&lt;A&gt;</code> directly implements <code>IdKind&lt;A&gt;</code>.</li>
<li><strong>Usage</strong>: <a href="monads/./identity.html">How to use the Identity Monad</a></li>
</ul>
<hr />
<h3 id="2-javautillista"><a class="header" href="#2-javautillista">2. <code>java.util.List&lt;A&gt;</code></a></h3>
<ul>
<li><strong>Type Definition</strong>: Standard Java <code>java.util.List&lt;A&gt;</code>.</li>
<li><strong><code>ListKind&lt;A&gt;</code> Interface</strong>: <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/list/ListKind.java"><code>ListKind&lt;A&gt;</code></a> extends <code>Kind&lt;ListKind.Witness, A&gt;</code>.</li>
<li><strong>Witness Type <code>F_WITNESS</code></strong>: <code>ListKind.Witness</code></li>
<li><strong><code>ListKindHelper</code></strong>: Uses an internal <code>ListHolder&lt;A&gt;</code> record that implements <code>ListKind&lt;A&gt;</code> to wrap <code>java.util.List&lt;A&gt;</code>.</li>
<li><strong>Type Class Instances</strong>:
<ul>
<li><code>ListFunctor</code> (<code>Functor&lt;ListKind.Witness&gt;</code>)</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/list/ListMonad.java"><code>ListMonad</code></a> (<code>Monad&lt;ListKind.Witness&gt;</code>)</li>
</ul>
</li>
<li><strong>Notes</strong>: Standard list monad behaviour. <code>of(a)</code> creates a singleton list <code>List.of(a)</code>; <code>of(null)</code> results in an empty list.</li>
<li><strong>Usage</strong>: <a href="monads/./list_monad.html">How to use the List Monad</a></li>
</ul>
<hr />
<h3 id="3-javautilstreamstreama"><a class="header" href="#3-javautilstreamstreama">3. <code>java.util.stream.Stream&lt;A&gt;</code></a></h3>
<ul>
<li><strong>Type Definition</strong>: Standard Java <code>java.util.stream.Stream&lt;A&gt;</code>.</li>
<li><strong><code>StreamKind&lt;A&gt;</code> Interface</strong>: <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/stream/StreamKind.java"><code>StreamKind&lt;A&gt;</code></a> extends <code>Kind&lt;StreamKind.Witness, A&gt;</code>.</li>
<li><strong>Witness Type <code>F_WITNESS</code></strong>: <code>StreamKind.Witness</code></li>
<li><strong><code>StreamKindHelper</code></strong>: Uses an internal <code>StreamHolder&lt;A&gt;</code> record that implements <code>StreamKind&lt;A&gt;</code> to wrap <code>java.util.stream.Stream&lt;A&gt;</code>. Provides <code>widen</code>, <code>narrow</code>.</li>
<li><strong>Type Class Instances</strong>:
<ul>
<li><code>StreamFunctor</code> (<code>Functor&lt;StreamKind.Witness&gt;</code>)</li>
<li><code>StreamApplicative</code> (<code>Applicative&lt;StreamKind.Witness&gt;</code>)</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/stream/StreamMonad.java"><code>StreamMonad</code></a> (<code>MonadZero&lt;StreamKind.Witness&gt;</code>)</li>
<li><code>StreamTraverse</code> (<code>Traverse&lt;StreamKind.Witness&gt;</code>, <code>Foldable&lt;StreamKind.Witness&gt;</code>)</li>
</ul>
</li>
<li><strong>Notes</strong>: Lazy, potentially infinite sequences with <strong>single-use semantics</strong> - each Stream can only be consumed once. Attempting to reuse a consumed stream throws <code>IllegalStateException</code>. <code>of(a)</code> creates singleton stream; <code>of(null)</code> creates empty stream. <code>zero()</code> returns empty stream. Use <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/stream/StreamOps.java"><code>StreamOps</code></a> for additional utility operations.</li>
<li><strong>Usage</strong>: <a href="monads/./stream_monad.html">How to use the Stream Monad</a></li>
</ul>
<hr />
<h3 id="4-trampolinea"><a class="header" href="#4-trampolinea">4. <code>Trampoline&lt;A&gt;</code></a></h3>
<ul>
<li><strong>Type Definition</strong>: Custom sealed interface (<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/trampoline/Trampoline.java"><code>Trampoline</code></a>) implementing stack-safe recursion through trampolining. Provides three constructors: <code>Done&lt;A&gt;</code> (completed computation), <code>More&lt;A&gt;</code> (deferred computation), and <code>FlatMap&lt;A, B&gt;</code> (monadic sequencing).</li>
<li><strong><code>TrampolineKind&lt;A&gt;</code> Interface</strong>: <code>Trampoline&lt;A&gt;</code> itself implements <code>TrampolineKind&lt;A&gt;</code>, and <code>TrampolineKind&lt;A&gt; extends Kind&lt;TrampolineKind.Witness, A&gt;</code>.</li>
<li><strong>Witness Type <code>F_WITNESS</code></strong>: <code>TrampolineKind.Witness</code></li>
<li><strong><code>TrampolineKindHelper</code></strong>: <code>widen</code> casts <code>Trampoline</code> to <code>Kind</code>; <code>narrow</code> casts <code>Kind</code> to <code>Trampoline</code>. Provides <code>done(value)</code> for completed computations and <code>defer(supplier)</code> for deferred evaluation.</li>
<li><strong>Type Class Instances</strong>:
<ul>
<li><code>TrampolineFunctor</code> (<code>Functor&lt;TrampolineKind.Witness&gt;</code>)</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/trampoline/TrampolineMonad.java"><code>TrampolineMonad</code></a> (<code>Monad&lt;TrampolineKind.Witness&gt;</code>)</li>
</ul>
</li>
<li><strong>Notes</strong>: Enables stack-safe tail recursion by converting recursive calls into iterative data structure processing, preventing <code>StackOverflowError</code> in deeply recursive computations (verified with 100,000+ iterations). <code>done(value)</code> creates an already evaluated result; <code>defer(supplier)</code> defers computation. The <code>run()</code> method executes the trampoline iteratively using an explicit stack. Essential for recursive algorithms (factorial, Fibonacci, tree traversals) and provides <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/trampoline/TrampolineUtils.java"><code>TrampolineUtils</code></a> for guaranteed stack-safe applicative operations.</li>
<li><strong>Usage</strong>: <a href="monads/./trampoline_monad.html">How to use the Trampoline Monad</a></li>
</ul>
<hr />
<h3 id="5-freef-a"><a class="header" href="#5-freef-a">5. <code>Free&lt;F, A&gt;</code></a></h3>
<ul>
<li><strong>Type Definition</strong>: Custom sealed interface (<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/free/Free.java"><code>Free</code></a>) representing programs as data structures that can be interpreted in different ways. Provides three constructors: <code>Pure&lt;F,A&gt;</code> (terminal value), <code>Suspend&lt;F,A&gt;</code> (suspended computation), and <code>FlatMapped&lt;F,X,A&gt;</code> (monadic sequencing).</li>
<li><strong><code>FreeKind&lt;F, A&gt;</code> Interface</strong>: <code>Free&lt;F,A&gt;</code> itself implements <code>FreeKind&lt;F,A&gt;</code>, and <code>FreeKind&lt;F,A&gt; extends Kind&lt;FreeKind.Witness&lt;F&gt;, A&gt;</code>.</li>
<li><strong>Witness Type <code>F_WITNESS</code></strong>: <code>FreeKind.Witness&lt;F&gt;</code> (where <code>F</code> is the instruction set functor)</li>
<li><strong><code>FreeKindHelper</code></strong>: <code>widen</code> casts <code>Free</code> to <code>Kind</code>; <code>narrow</code> casts <code>Kind</code> to <code>Free</code>. Provides <code>pure(value)</code>, <code>suspend(computation)</code>, <code>liftF(fa, functor)</code>.</li>
<li><strong>Type Class Instances</strong>:
<ul>
<li><code>FreeFunctor&lt;F&gt;</code> (<code>Functor&lt;FreeKind.Witness&lt;F&gt;&gt;</code>)</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/free/FreeMonad.java"><code>FreeMonad&lt;F&gt;</code></a> (<code>Monad&lt;FreeKind.Witness&lt;F&gt;&gt;</code>)</li>
</ul>
</li>
<li><strong>Notes</strong>: Enables building domain-specific languages (DSLs) as composable data structures. programs are interpreted via <code>foldMap</code> with natural transformations, allowing multiple interpreters (IO, Test, Optimisation, etc.). Stack-safe execution using Higher-Kinded-J's <code>Trampoline</code> monad internally, demonstrating library composability (verified with 10,000+ operations). Essential for separating program description from execution, enabling testability and alternative interpretations. Provides <code>liftF</code> to lift functor values into Free, <code>map</code> and <code>flatMap</code> for composition, and <code>foldMap</code> for interpretation. Useful for building testable workflows, query languages, and effect systems where the same program needs different execution strategies.</li>
<li><strong>Usage</strong>: <a href="monads/./free_monad.html">How to use the Free Monad</a></li>
</ul>
<hr />
<h3 id="6-javautiloptionala"><a class="header" href="#6-javautiloptionala">6. <code>java.util.Optional&lt;A&gt;</code></a></h3>
<ul>
<li><strong>Type Definition</strong>: Standard Java <code>java.util.Optional&lt;A&gt;</code>.</li>
<li><strong><code>OptionalKind&lt;A&gt;</code> Interface</strong>: <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/optional/OptionalKind.java"><code>OptionalKind&lt;A&gt;</code></a> extends <code>Kind&lt;OptionalKind.Witness, A&gt;</code>.</li>
<li><strong>Witness Type <code>F_WITNESS</code></strong>: <code>OptionalKind.Witness</code></li>
<li><strong><code>OptionalKindHelper</code></strong>: Uses an internal <code>OptionalHolder&lt;A&gt;</code> record that implements <code>OptionalKind&lt;A&gt;</code> to wrap <code>java.util.Optional&lt;A&gt;</code>.</li>
<li><strong>Type Class Instances</strong>:
<ul>
<li><code>OptionalFunctor</code> (<code>Functor&lt;OptionalKind.Witness&gt;</code>)</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/optional/OptionalMonad.java"><code>OptionalMonad</code></a> (<code>MonadError&lt;OptionalKind.Witness, Unit&gt;</code>)</li>
</ul>
</li>
<li><strong>Notes</strong>: <code>Optional.empty()</code> is the error state. <code>raiseError(Unit.INSTANCE)</code> creates <code>Optional.empty()</code>. <code>of(value)</code> uses <code>Optional.ofNullable(value)</code>.</li>
<li><strong>Usage</strong>: <a href="monads/./optional_monad.html">How to use the Optional Monad</a></li>
</ul>
<hr />
<h3 id="7-maybea"><a class="header" href="#7-maybea">7. <code>Maybe&lt;A&gt;</code></a></h3>
<ul>
<li><strong>Type Definition</strong>: Custom sealed interface (<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/maybe/Maybe.java"><code>Maybe</code></a>) with <code>Just&lt;A&gt;</code> (non-null) and <code>Nothing&lt;A&gt;</code> implementations.</li>
<li><strong><code>MaybeKind&lt;A&gt;</code> Interface</strong>: <code>Just&lt;T&gt;</code> and <code>Nothing&lt;T&gt;</code> directly implement <code>MaybeKind&lt;T&gt;</code>, which extends <code>Kind&lt;MaybeKind.Witness, T&gt;</code>.</li>
<li><strong>Witness Type <code>F_WITNESS</code></strong>: <code>MaybeKind.Witness</code></li>
<li><strong><code>MaybeKindHelper</code></strong>: <code>widen</code> performs null check and casts <code>Maybe</code> to <code>Kind</code> (zero overhead); <code>narrow</code> checks <code>instanceof Maybe</code> and casts. Provides <code>just(value)</code>, <code>nothing()</code>, <code>fromNullable(value)</code>.</li>
<li><strong>Type Class Instances</strong>:
<ul>
<li><code>MaybeFunctor</code> (<code>Functor&lt;MaybeKind.Witness&gt;</code>)</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/maybe/MaybeMonad.java"><code>MaybeMonad</code></a> (<code>MonadError&lt;MaybeKind.Witness, Unit&gt;</code>)</li>
</ul>
</li>
<li><strong>Notes</strong>: <code>Nothing</code> is the error state; <code>raiseError(Unit.INSTANCE</code>) creates <code>Nothing</code>. <code>Maybe.just(value)</code> requires non-null. <code>MaybeMonad.of(value)</code> uses <code>Maybe.fromNullable()</code>.</li>
<li><strong>Usage</strong>: <a href="monads/./maybe_monad.html">How to use the Maybe Monad</a></li>
</ul>
<hr />
<h3 id="8-eitherl-r"><a class="header" href="#8-eitherl-r">8. <code>Either&lt;L, R&gt;</code></a></h3>
<ul>
<li><strong>Type Definition</strong>: Custom sealed interface (<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/either/Either.java"><code>Either</code></a>) with <code>Left&lt;L,R&gt;</code> and <code>Right&lt;L,R&gt;</code> records.</li>
<li><strong><code>EitherKind&lt;L, R&gt;</code> Interface</strong>: <code>Either.Left&lt;L,R&gt;</code> and <code>Either.Right&lt;L,R&gt;</code> directly implement <code>EitherKind&lt;L,R&gt;</code> (and <code>EitherKind2&lt;L,R&gt;</code> for bifunctor operations), which extends <code>Kind&lt;EitherKind.Witness&lt;L&gt;, R&gt;</code>.</li>
<li><strong>Witness Type <code>F_WITNESS</code></strong>: <code>EitherKind.Witness&lt;L&gt;</code> (Error type <code>L</code> is fixed for the witness).</li>
<li><strong><code>EitherKindHelper</code></strong>: <code>widen</code> performs null check and casts <code>Either</code> to <code>Kind</code> (zero overhead); <code>narrow</code> checks <code>instanceof Either</code> and casts. Provides <code>left(l)</code>, <code>right(r)</code>.</li>
<li><strong>Type Class Instances</strong>:
<ul>
<li><code>EitherFunctor&lt;L&gt;</code> (<code>Functor&lt;EitherKind.Witness&lt;L&gt;&gt;</code>)</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/either/EitherMonad.java"><code>EitherMonad&lt;L&gt;</code></a> (<code>MonadError&lt;EitherKind.Witness&lt;L&gt;, L&gt;</code>)</li>
</ul>
</li>
<li><strong>Notes</strong>: Right-biased. <code>Left(l)</code> is the error state. <code>of(r)</code> creates <code>Right(r)</code>.</li>
<li><strong>Usage</strong>: <a href="monads/./either_monad.html">How to use the Either Monad</a></li>
</ul>
<hr />
<h3 id="9-trya"><a class="header" href="#9-trya">9. <code>Try&lt;A&gt;</code></a></h3>
<ul>
<li><strong>Type Definition</strong>: Custom sealed interface (<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/trymonad/Try.java"><code>Try</code></a>) with <code>Success&lt;A&gt;</code> and <code>Failure&lt;A&gt;</code> (wrapping <code>Throwable</code>).</li>
<li><strong><code>TryKind&lt;A&gt;</code> Interface</strong>: <code>Try&lt;A&gt;</code> itself implements <code>TryKind&lt;A&gt;</code>, and <code>TryKind&lt;A&gt; extends Kind&lt;TryKind.Witness, A&gt;</code>.</li>
<li><strong>Witness Type <code>F_WITNESS</code></strong>: <code>TryKind.Witness</code></li>
<li><strong><code>TryKindHelper</code></strong>: <code>wrap</code> casts <code>Try</code> to <code>Kind</code>; <code>unwrap</code> casts <code>Kind</code> to <code>Try</code>. Provides <code>success(value)</code>, <code>failure(throwable)</code>, <code>tryOf(supplier)</code>.</li>
<li><strong>Type Class Instances</strong>:
<ul>
<li><code>TryFunctor</code> (<code>Functor&lt;TryKind.Witness&gt;</code>)</li>
<li><code>TryApplicative</code> (<code>Applicative&lt;TryKind.Witness&gt;</code>)</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/trymonad/TryMonad.java"><code>TryMonad</code></a> (<code>MonadError&lt;TryKind.Witness, Throwable&gt;</code>)</li>
</ul>
</li>
<li><strong>Notes</strong>: <code>Failure(t)</code> is the error state. <code>of(v)</code> creates <code>Success(v)</code>.</li>
<li><strong>Usage</strong>: <a href="monads/./try_monad.html">How to use the Try Monad</a></li>
</ul>
<hr />
<h3 id="10-javautilconcurrentcompletablefuturea"><a class="header" href="#10-javautilconcurrentcompletablefuturea">10. <code>java.util.concurrent.CompletableFuture&lt;A&gt;</code></a></h3>
<ul>
<li><strong>Type Definition</strong>: Standard Java <code>java.util.concurrent.CompletableFuture&lt;A&gt;</code>.</li>
<li><strong><code>CompletableFutureKind&lt;A&gt;</code> Interface</strong>: <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/future/CompletableFutureKind.java"><code>CompletableFutureKind&lt;A&gt;</code></a> extends <code>Kind&lt;CompletableFutureKind.Witness, A&gt;</code>.</li>
<li><strong>Witness Type <code>F_WITNESS</code></strong>: <code>CompletableFutureKind.Witness</code></li>
<li><strong><code>CompletableFutureKindHelper</code></strong>: Uses an internal <code>CompletableFutureHolder&lt;A&gt;</code> record. Provides <code>wrap</code>, <code>unwrap</code>, <code>join</code>.</li>
<li><strong>Type Class Instances</strong>:
<ul>
<li><code>CompletableFutureFunctor</code> (<code>Functor&lt;CompletableFutureKind.Witness&gt;</code>)</li>
<li><code>CompletableFutureApplicative</code> (<code>Applicative&lt;CompletableFutureKind.Witness&gt;</code>)</li>
<li><code>CompletableFutureMonad</code> (<code>Monad&lt;CompletableFutureKind.Witness&gt;</code>)</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/future/CompletableFutureMonad.java"><code>CompletableFutureMonad</code></a> (<code>MonadError&lt;CompletableFutureKind.Witness, Throwable&gt;</code>)</li>
</ul>
</li>
<li><strong>Notes</strong>: Represents asynchronous computations. A failed future is the error state. <code>of(v)</code> creates <code>CompletableFuture.completedFuture(v)</code>.</li>
<li><strong>Usage</strong>: <a href="monads/./cf_monad.html">How to use the CompletableFuture Monad</a></li>
</ul>
<hr />
<h3 id="11-ioa"><a class="header" href="#11-ioa">11. <code>IO&lt;A&gt;</code></a></h3>
<ul>
<li><strong>Type Definition</strong>: Custom interface (<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/io/IO.java"><code>IO</code></a>) representing a deferred, potentially side-effecting computation.</li>
<li><strong><code>IOKind&lt;A&gt;</code> Interface</strong>: <code>IO&lt;A&gt;</code> directly extends <code>IOKind&lt;A&gt;</code>, which extends <code>Kind&lt;IOKind.Witness, A&gt;</code>.</li>
<li><strong>Witness Type <code>F_WITNESS</code></strong>: <code>IOKind.Witness</code></li>
<li><strong><code>IOKindHelper</code></strong>: <code>widen</code> performs null check and returns the <code>IO</code> directly as <code>Kind</code> (zero overhead); <code>narrow</code> checks <code>instanceof IO</code> and casts. Provides <code>delay(supplier)</code>, <code>unsafeRunSync(kind)</code>.</li>
<li><strong>Type Class Instances</strong>:
<ul>
<li><code>IOFunctor</code> (<code>Functor&lt;IOKind.Witness&gt;</code>)</li>
<li><code>IOApplicative</code> (<code>Applicative&lt;IOKind.Witness&gt;</code>)</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/io/IOMonad.java"><code>IOMonad</code></a> (<code>Monad&lt;IOKind.Witness&gt;</code>)</li>
</ul>
</li>
<li><strong>Notes</strong>: Evaluation is deferred until <code>unsafeRunSync</code>. Exceptions during execution are generally unhandled by <code>IOMonad</code> itself unless caught within the IO's definition.</li>
<li><strong>Usage</strong>: <a href="monads/./io_monad.html">How to use the IO Monad</a></li>
</ul>
<hr />
<h3 id="12-lazya"><a class="header" href="#12-lazya">12. <code>Lazy&lt;A&gt;</code></a></h3>
<ul>
<li><strong>Type Definition</strong>: Custom class (<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/lazy/Lazy.java"><code>Lazy</code></a>) for deferred computation with memoization.</li>
<li><strong><code>LazyKind&lt;A&gt;</code> Interface</strong>: <code>Lazy&lt;A&gt;</code> itself implements <code>LazyKind&lt;A&gt;</code>, and <code>LazyKind&lt;A&gt; extends Kind&lt;LazyKind.Witness, A&gt;</code>.</li>
<li><strong>Witness Type <code>F_WITNESS</code></strong>: <code>LazyKind.Witness</code></li>
<li><strong><code>LazyKindHelper</code></strong>: <code>wrap</code> casts <code>Lazy</code> to <code>Kind</code>; <code>unwrap</code> casts <code>Kind</code> to <code>Lazy</code>. Provides <code>defer(supplier)</code>, <code>now(value)</code>, <code>force(kind)</code>.</li>
<li><strong>Type Class Instances</strong>:
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/lazy/LazyMonad.java"><code>LazyMonad</code></a> (<code>Monad&lt;LazyKind.Witness&gt;</code>)</li>
</ul>
</li>
<li><strong>Notes</strong>: Result or exception is memoized. <code>of(a)</code> creates an already evaluated <code>Lazy.now(a)</code>.</li>
<li><strong>Usage</strong>: <a href="monads/./lazy_monad.html">How to use the Lazy Monad</a></li>
</ul>
<hr />
<h3 id="13-readerr_env-a"><a class="header" href="#13-readerr_env-a">13. <code>Reader&lt;R_ENV, A&gt;</code></a></h3>
<ul>
<li><strong>Type Definition</strong>: Custom functional interface (<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/reader/Reader.java"><code>Reader</code></a>) wrapping <code>Function&lt;R_ENV, A&gt;</code>.</li>
<li><strong><code>ReaderKind&lt;R_ENV, A&gt;</code> Interface</strong>: <code>Reader&lt;R_ENV,A&gt;</code> itself implements <code>ReaderKind&lt;R_ENV,A&gt;</code>, and <code>ReaderKind&lt;R_ENV,A&gt; extends Kind&lt;ReaderKind.Witness&lt;R_ENV&gt;, A&gt;</code>.</li>
<li><strong>Witness Type <code>F_WITNESS</code></strong>: <code>ReaderKind.Witness&lt;R_ENV&gt;</code> (Environment type <code>R_ENV</code> is fixed).</li>
<li><strong><code>ReaderKindHelper</code></strong>: <code>wrap</code> casts <code>Reader</code> to <code>Kind</code>; <code>unwrap</code> casts <code>Kind</code> to <code>Reader</code>. Provides <code>reader(func)</code>, <code>ask()</code>, <code>constant(value)</code>, <code>runReader(kind, env)</code>.</li>
<li><strong>Type Class Instances</strong>:
<ul>
<li><code>ReaderFunctor&lt;R_ENV&gt;</code> (<code>Functor&lt;ReaderKind.Witness&lt;R_ENV&gt;&gt;</code>)</li>
<li><code>ReaderApplicative&lt;R_ENV&gt;</code> (<code>Applicative&lt;ReaderKind.Witness&lt;R_ENV&gt;&gt;</code>)</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/reader/ReaderMonad.java"><code>ReaderMonad&lt;R_ENV&gt;</code></a> (<code>Monad&lt;ReaderKind.Witness&lt;R_ENV&gt;&gt;</code>)</li>
</ul>
</li>
<li><strong>Notes</strong>: <code>of(a)</code> creates a <code>Reader</code> that ignores the environment and returns <code>a</code>.</li>
<li><strong>Usage</strong>: <a href="monads/./reader_monad.html">How to use the Reader Monad</a></li>
</ul>
<hr />
<h3 id="14-states-a"><a class="header" href="#14-states-a">14. <code>State&lt;S, A&gt;</code></a></h3>
<ul>
<li><strong>Type Definition</strong>: Custom functional interface (<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/state/State.java"><code>State</code></a>) wrapping <code>Function&lt;S, StateTuple&lt;S, A&gt;&gt;</code>.</li>
<li><strong><code>StateKind&lt;S,A&gt;</code> Interface</strong>: <code>State&lt;S,A&gt;</code> itself implements <code>StateKind&lt;S,A&gt;</code>, and <code>StateKind&lt;S,A&gt; extends Kind&lt;StateKind.Witness&lt;S&gt;, A&gt;</code>.</li>
<li><strong>Witness Type <code>F_WITNESS</code></strong>: <code>StateKind.Witness&lt;S&gt;</code> (State type <code>S</code> is fixed).</li>
<li><strong><code>StateKindHelper</code></strong>: <code>wrap</code> casts <code>State</code> to <code>Kind</code>; <code>unwrap</code> casts <code>Kind</code> to <code>State</code>. Provides <code>pure(value)</code>, <code>get()</code>, <code>set(state)</code>, <code>modify(func)</code>, <code>inspect(func)</code>, <code>runState(kind, initialState)</code>, etc.</li>
<li><strong>Type Class Instances</strong>:
<ul>
<li><code>StateFunctor&lt;S&gt;</code> (<code>Functor&lt;StateKind.Witness&lt;S&gt;&gt;</code>)</li>
<li><code>StateApplicative&lt;S&gt;</code> (<code>Applicative&lt;StateKind.Witness&lt;S&gt;&gt;</code>)</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/state/StateMonad.java"><code>StateMonad&lt;S&gt;</code></a> (<code>Monad&lt;StateKind.Witness&lt;S&gt;&gt;</code>)</li>
</ul>
</li>
<li><strong>Notes</strong>: <code>of(a)</code> (<code>pure</code>) returns <code>a</code> without changing state.</li>
<li><strong>Usage</strong>: <a href="monads/./state_monad.html">How to use the State Monad</a></li>
</ul>
<hr />
<h3 id="15-writerw-a"><a class="header" href="#15-writerw-a">15. <code>Writer&lt;W, A&gt;</code></a></h3>
<ul>
<li><strong>Type Definition</strong>: Custom record (<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/writer/Writer.java"><code>Writer</code></a>) holding <code>(W log, A value)</code>. Requires <code>Monoid&lt;W&gt;</code>.</li>
<li><strong><code>WriterKind&lt;W, A&gt;</code> Interface</strong>: <code>Writer&lt;W,A&gt;</code> itself implements <code>WriterKind&lt;W,A&gt;</code>, and <code>WriterKind&lt;W,A&gt; extends Kind&lt;WriterKind.Witness&lt;W&gt;, A&gt;</code>.</li>
<li><strong>Witness Type <code>F_WITNESS</code></strong>: <code>WriterKind.Witness&lt;W&gt;</code> (Log type <code>W</code> and its <code>Monoid</code> are fixed).</li>
<li><strong><code>WriterKindHelper</code></strong>: <code>wrap</code> casts <code>Writer</code> to <code>Kind</code>; <code>unwrap</code> casts <code>Kind</code> to <code>Writer</code>. Provides <code>value(monoid, val)</code>, <code>tell(monoid, log)</code>, <code>runWriter(kind)</code>, etc.</li>
<li><strong>Type Class Instances</strong>: (Requires <code>Monoid&lt;W&gt;</code> for Applicative/Monad)
<ul>
<li><code>WriterFunctor&lt;W&gt;</code> (<code>Functor&lt;WriterKind.Witness&lt;W&gt;&gt;</code>)</li>
<li><code>WriterApplicative&lt;W&gt;</code> (<code>Applicative&lt;WriterKind.Witness&lt;W&gt;&gt;</code>)</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/writer/WriterMonad.java"><code>WriterMonad&lt;W&gt;</code></a> (<code>Monad&lt;WriterKind.Witness&lt;W&gt;&gt;</code>)</li>
</ul>
</li>
<li><strong>Notes</strong>: <code>of(a)</code> (<code>value</code>) produces <code>a</code> with an empty log (from <code>Monoid.empty()</code>).</li>
<li><strong>Usage</strong>: <a href="monads/./writer_monad.html">How to use the Writer Monad</a></li>
</ul>
<hr />
<h3 id="16-validatede-a"><a class="header" href="#16-validatede-a">16. <code>Validated&lt;E, A&gt;</code></a></h3>
<ul>
<li><strong>Type Definition</strong>: Custom sealed interface (<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/validated/Validated.java"><code>Validated</code></a>) with <code>Valid&lt;E, A&gt;</code> (holding <code>A</code>) and <code>Invalid&lt;E, A&gt;</code> (holding <code>E</code>) implementations.</li>
<li><strong><code>ValidatedKind&lt;E, A&gt;</code> Interface</strong>: Defines the HKT structure (<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/validated/ValidatedKind.java"><code>ValidatedKind</code></a>) for <code>Validated&lt;E,A&gt;</code>. It extends <code>Kind&lt;ValidatedKind.Witness&lt;E&gt;, A&gt;</code>. Concrete <code>Valid&lt;E,A&gt;</code> and <code>Invalid&lt;E,A&gt;</code> instances are cast to this kind by <code>ValidatedKindHelper</code>.</li>
<li><strong>Witness Type <code>F_WITNESS</code></strong>: <code>ValidatedKind.Witness&lt;E&gt;</code> (Error type <code>E</code> is fixed for the HKT witness).</li>
<li><strong><code>ValidatedKindHelper</code> Class</strong>: (<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/validated/ValidatedKindHelper.java"><code>ValidatedKindHelper</code></a>). <code>widen</code> casts <code>Validated&lt;E,A&gt;</code> (specifically <code>Valid</code> or <code>Invalid</code> instances) to <code>Kind&lt;ValidatedKind.Witness&lt;E&gt;, A&gt;</code>. <code>narrow</code> casts <code>Kind</code> back to <code>Validated&lt;E,A&gt;</code>. Provides static factory methods <code>valid(value)</code> and <code>invalid(error)</code> that return the Kind-wrapped type.</li>
<li><strong>Type Class Instances</strong>: (Error type <code>E</code> is fixed for the monad instance)
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/validated/ValidatedMonad.java"><code>ValidatedMonad&lt;E&gt;</code></a> (<code>MonadError&lt;ValidatedKind.Witness&lt;E&gt;, E&gt;</code>). This also provides <code>Monad</code>, <code>Functor</code>, and <code>Applicative</code> behaviour.</li>
</ul>
</li>
<li><strong>Notes</strong>: <code>Validated</code> is right-biased, meaning operations like <code>map</code> and <code>flatMap</code> apply to the <code>Valid</code> case and propagate <code>Invalid</code> untouched. <code>ValidatedMonad.of(a)</code> creates a <code>Valid(a)</code>. As a <code>MonadError</code>, <code>ValidatedMonad</code> provides <code>raiseError(error)</code> to create an <code>Invalid(error)</code> and <code>handleErrorWith(kind, handler)</code> for standardised error recovery. The <code>ap</code> method is also right-biased and does not accumulate errors from multiple <code>Invalid</code>s in the typical applicative sense; it propagates the first <code>Invalid</code> encountered or an <code>Invalid</code> function.</li>
<li><strong>Usage</strong>: <a href="monads/./validated_monad.html">How to use the Validated Monad</a></li>
</ul>
<hr />
<h3 id="17-constc-a"><a class="header" href="#17-constc-a">17. <code>Const&lt;C, A&gt;</code></a></h3>
<ul>
<li><strong>Type Definition</strong>: Custom record (<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/constant/Const.java"><code>Const</code></a>) holding a constant value of type <code>C</code> whilst treating <code>A</code> as a phantom type parameter (present in the type signature but not stored).</li>
<li><strong><code>ConstKind2&lt;C, A&gt;</code> Interface</strong>: (<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/constant/ConstKind2.java"><code>ConstKind2&lt;C, A&gt;</code></a>) extends <code>Kind2&lt;ConstKind2.Witness, C, A&gt;</code>. This interface allows <code>Const</code> to be used with bifunctor operations.</li>
<li><strong>Witness Type <code>F_WITNESS</code></strong>: <code>ConstKind2.Witness</code> (used for bifunctor type class instances).</li>
<li><strong><code>ConstKindHelper</code> Class</strong>: (<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/constant/ConstKindHelper.java"><code>ConstKindHelper</code></a>). Provides <code>widen2</code> to cast <code>Const&lt;C, A&gt;</code> to <code>Kind2&lt;ConstKind2.Witness, C, A&gt;</code> and <code>narrow2</code> to cast back. Uses an internal <code>ConstKind2Holder&lt;C, A&gt;</code> record that implements <code>ConstKind2&lt;C, A&gt;</code>.</li>
<li><strong>Type Class Instances</strong>: (Only bifunctor, no monad instance as mapping the phantom type has no computational effect)
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/constant/ConstBifunctor.java"><code>ConstBifunctor</code></a> (<code>Bifunctor&lt;ConstKind2.Witness&gt;</code>). This instance provides <code>first</code> (transforms the constant value), <code>second</code> (changes only the phantom type), and <code>bimap</code> (combines both, though only <code>first</code> affects the constant value).</li>
</ul>
</li>
<li><strong>Notes</strong>: The second type parameter <code>A</code> is <strong>phantom</strong>: it exists only in the type signature and has no runtime representation. Calling <code>mapSecond</code> or <code>second</code> preserves the constant value whilst changing the phantom type in the signature. This makes <code>Const</code> particularly useful for fold implementations (accumulating a single value), getter patterns in lens libraries (van Laarhoven lenses), and data extraction from structures without transformation. The mapper function in <code>second</code> is applied to <code>null</code> for exception propagation, so use null-safe mappers. Similar to <code>Const</code> in Scala's Cats and Scalaz libraries.</li>
<li><strong>Usage</strong>: <a href="monads/./const_type.html">How to use the Const Type</a></li>
</ul>
<hr />
<div id="admonition-hands-on-learning" class="admonition admonish-info" role="note" aria-labelledby="admonition-hands-on-learning-title">
<div class="admonition-title">
<div id="admonition-hands-on-learning-title">
<p>Hands-On Learning</p>
</div>
<a class="admonition-anchor-link" href="monads/supported-types.html#admonition-hands-on-learning"></a>
</div>
<div>
<p>Practice with concrete types in <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/coretypes/Tutorial06_ConcreteTypes.java">Tutorial 06: Concrete Types</a> (7 exercises, ~10 minutes).</p>
</div>
</div>
<hr />
<p><strong>Next:</strong> <a href="monads/cf_monad.html">CompletableFuture</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="the-completablefuturemonad"><a class="header" href="#the-completablefuturemonad">The CompletableFutureMonad:</a></h1>
<h2 id="asynchronous-computations-with-completablefuture"><a class="header" href="#asynchronous-computations-with-completablefuture"><em>Asynchronous Computations with <code>CompletableFuture</code></em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="monads/cf_monad.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to compose asynchronous operations functionally</li>
<li>Using MonadError capabilities for async error handling and recovery</li>
<li>Building non-blocking workflows with <code>map</code>, <code>flatMap</code>, and <code>handleErrorWith</code></li>
<li>Integration with EitherT for combining async operations with typed errors</li>
<li>Real-world patterns for resilient microservice communication</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code:</p>
</div>
<a class="admonition-anchor-link" href="monads/cf_monad.html#admonition-see-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/future/CompletableFutureExample.java">CompletableFutureExample.java</a></p>
</div>
</div>
<p>Java's <code>java.util.concurrent.CompletableFuture&lt;T&gt;</code> is a powerful tool for asynchronous programming. The <code>higher-kinded-j</code> library provides a way to treat <code>CompletableFuture</code> as a monadic context using the HKT simulation. This allows developers to compose asynchronous operations and handle their potential failures (<code>Throwable</code>) in a more functional and generic style, leveraging type classes like <code>Functor</code>, <code>Applicative</code>, <code>Monad</code>, and crucially, <code>MonadError</code>.</p>
<p><strong>Higher-Kinded Bridge for CompletableFuture</strong></p>
<p><img src="monads/../images/puml/cf_kind.svg" alt="cf_kind.svg" /></p>
<p><strong>TypeClasses</strong></p>
<p><img src="monads/../images/puml/cf_monad.svg" alt="cf_monad.svg" /></p>
<p>The simulation for <code>CompletableFuture</code> involves these components:</p>
<ol>
<li><strong><code>CompletableFuture&lt;A&gt;</code></strong>: The standard Java class representing an asynchronous computation that will eventually result in a value of type <code>A</code> or fail with an exception (a <code>Throwable</code>).</li>
<li><strong><code>CompletableFutureKind&lt;A&gt;</code></strong>: The HKT marker interface (<code>Kind&lt;CompletableFutureKind.Witness, A&gt;</code>) for <code>CompletableFuture</code>. This allows <code>CompletableFuture</code> to be used generically with type classes. The witness type is <code>CompletableFutureKind.Witness</code>.</li>
<li><strong><code>CompletableFutureKindHelper</code></strong>: The utility class for bridging between <code>CompletableFuture&lt;A&gt;</code> and <code>CompletableFutureKind&lt;A&gt;</code>. Key methods:
<ul>
<li><code>widen(CompletableFuture&lt;A&gt;)</code>: Wraps a standard <code>CompletableFuture</code> into its <code>Kind</code> representation.</li>
<li><code>narrow(Kind&lt;CompletableFutureKind.Witness, A&gt;)</code>: Unwraps the <code>Kind</code> back to the concrete <code>CompletableFuture</code>. Throws <code>KindUnwrapException</code> if the input Kind is invalid.</li>
<li><code>join(Kind&lt;CompletableFutureKind.Witness, A&gt;)</code>: A convenience method to unwrap the <code>Kind</code> and then block (<code>join()</code>) on the underlying <code>CompletableFuture</code> to get its result. It re-throws runtime exceptions and errors directly but wraps checked exceptions in <code>CompletionException</code>. <em>Use primarily for testing or at the very end of an application where blocking is acceptable.</em></li>
</ul>
</li>
<li><strong><code>CompletableFutureFunctor</code></strong>: Implements <code>Functor&lt;CompletableFutureKind.Witness&gt;</code>. Provides <code>map</code>, which corresponds to <code>CompletableFuture.thenApply()</code>.</li>
<li><strong><code>CompletableFutureApplicative</code></strong>: Extends <code>Functor</code>, implements <code>Applicative&lt;CompletableFutureKind.Witness&gt;</code>.
<ul>
<li><code>of(A value)</code>: Creates an already successfully completed <code>CompletableFutureKind</code> using <code>CompletableFuture.completedFuture(value)</code>.</li>
<li><code>ap(Kind&lt;F, Function&lt;A,B&gt;&gt;, Kind&lt;F, A&gt;)</code>: Corresponds to <code>CompletableFuture.thenCombine()</code>, applying a function from one future to the value of another when both complete.</li>
</ul>
</li>
<li><strong><code>CompletableFutureMonad</code></strong>: Extends <code>Applicative</code>, implements <code>Monad&lt;CompletableFutureKind.Witness&gt;</code>.
<ul>
<li><code>flatMap(Function&lt;A, Kind&lt;F, B&gt;&gt;, Kind&lt;F, A&gt;)</code>: Corresponds to <code>CompletableFuture.thenCompose()</code>, sequencing asynchronous operations where one depends on the result of the previous one.</li>
</ul>
</li>
<li><strong><code>CompletableFutureMonad</code></strong>: Extends <code>Monad</code>, implements <code>MonadError&lt;CompletableFutureKind.Witness, Throwable&gt;</code>. This is often the most useful instance to work with.
<ul>
<li><code>raiseError(Throwable error)</code>: Creates an already exceptionally completed <code>CompletableFutureKind</code> using <code>CompletableFuture.failedFuture(error)</code>.</li>
<li><code>handleErrorWith(Kind&lt;F, A&gt;, Function&lt;Throwable, Kind&lt;F, A&gt;&gt;)</code>: Corresponds to <code>CompletableFuture.exceptionallyCompose()</code>, allowing asynchronous recovery from failures.</li>
</ul>
</li>
</ol>
<h2 id="purpose-and-usage"><a class="header" href="#purpose-and-usage">Purpose and Usage</a></h2>
<ul>
<li><strong>Functional Composition of Async Ops</strong>: Use <code>map</code>, <code>ap</code>, and <code>flatMap</code> (via the type class instances) to build complex asynchronous workflows in a declarative style, similar to how you'd compose synchronous operations with <code>Optional</code> or <code>List</code>.</li>
<li><strong>Unified Error Handling</strong>: Treat asynchronous failures (<code>Throwable</code>) consistently using <code>MonadError</code> operations (<code>raiseError</code>, <code>handleErrorWith</code>). This allows integrating error handling directly into the composition chain.</li>
<li><strong>HKT Integration</strong>: Enables writing generic code that can operate on <code>CompletableFuture</code> alongside other simulated monadic types (like <code>Optional</code>, <code>Either</code>, <code>IO</code>) by programming against the <code>Kind&lt;F, A&gt;</code> interface and type classes. This is powerfully demonstrated when using <code>CompletableFutureKind</code> as the outer monad <code>F</code> in the <code>EitherT</code> transformer (see <a href="monads/../hkts/order-walkthrough.html">Order Example Walkthrough</a>).</li>
</ul>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<div id="admonition-example-1-creating-_completablefuturekind_-instances" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-1-creating-_completablefuturekind_-instances-title">
<div class="admonition-title">
<div id="admonition-example-1-creating-_completablefuturekind_-instances-title">
<p>Example 1: Creating <em>CompletableFutureKind</em> Instances</p>
</div>
<a class="admonition-anchor-link" href="monads/cf_monad.html#admonition-example-1-creating-_completablefuturekind_-instances"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/future/CompletableFutureExample.java">CompletableFutureExample.java</a></li>
</ul>
<pre><code class="language-java">public void createExample() {
   // Get the MonadError instance
   CompletableFutureMonad futureMonad = CompletableFutureMonad.INSTANCE;

   // --- Using of() ---
   // Creates a Kind wrapping an already completed future
   Kind&lt;CompletableFutureKind.Witness, String&gt; successKind = futureMonad.of("Success!");

   // --- Using raiseError() ---
   // Creates a Kind wrapping an already failed future
   RuntimeException error = new RuntimeException("Something went wrong");
   Kind&lt;CompletableFutureKind.Witness, String&gt; failureKind = futureMonad.raiseError(error);

   // --- Wrapping existing CompletableFutures ---
   CompletableFuture&lt;Integer&gt; existingFuture = CompletableFuture.supplyAsync(() -&gt; {
      try {
         TimeUnit.MILLISECONDS.sleep(20);
      } catch (InterruptedException e) { /* ignore */ }
      return 123;
   });
   Kind&lt;CompletableFutureKind.Witness, Integer&gt; wrappedExisting = FUTURE.widen(existingFuture);

   CompletableFuture&lt;Integer&gt; failedExisting = new CompletableFuture&lt;&gt;();
   failedExisting.completeExceptionally(new IllegalArgumentException("Bad input"));
   Kind&lt;CompletableFutureKind.Witness, Integer&gt; wrappedFailed = FUTURE.widen(failedExisting);

   // You typically don't interact with 'unwrap' unless needed at boundaries or for helper methods like 'join'.
   CompletableFuture&lt;String&gt; unwrappedSuccess = FUTURE.narrow(successKind);
   CompletableFuture&lt;String&gt; unwrappedFailure = FUTURE.narrow(failureKind);
}
</code></pre>
</div>
</div>
<div id="admonition-example-2-using-_map_-_flatmap_-_ap_" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-2-using-_map_-_flatmap_-_ap_-title">
<div class="admonition-title">
<div id="admonition-example-2-using-_map_-_flatmap_-_ap_-title">
<p>Example 2: Using <em>map</em>, <em>flatMap</em>, <em>ap</em></p>
</div>
<a class="admonition-anchor-link" href="monads/cf_monad.html#admonition-example-2-using-_map_-_flatmap_-_ap_"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/future/CompletableFutureExample.java">CompletableFutureExample.java</a></li>
</ul>
<p>These examples show how to use the type class instance (<code>futureMonad</code>) to apply operations.</p>
<pre><code class="language-java">public void monadExample() {
   // Get the MonadError instance
   CompletableFutureMonad futureMonad = CompletableFutureMonad.INSTANCE;

   // --- map (thenApply) ---
   Kind&lt;CompletableFutureKind.Witness, Integer&gt; initialValueKind = futureMonad.of(10);
   Kind&lt;CompletableFutureKind.Witness, String&gt; mappedKind = futureMonad.map(
           value -&gt; "Result: " + value,
           initialValueKind
   );
   // Join for testing/demonstration
   System.out.println("Map Result: " + FUTURE.join(mappedKind)); // Output: Result: 10

   // --- flatMap (thenCompose) ---
   // Function A -&gt; Kind&lt;F, B&gt;
   Function&lt;String, Kind&lt;CompletableFutureKind.Witness, String&gt;&gt; asyncStep2 =
           input -&gt; FUTURE.widen(
                   CompletableFuture.supplyAsync(() -&gt; input + " -&gt; Step2 Done")
           );

   Kind&lt;CompletableFutureKind.Witness, String&gt; flatMappedKind = futureMonad.flatMap(
           asyncStep2,
           mappedKind // Result from previous map step ("Result: 10")
   );
   System.out.println("FlatMap Result: " + FUTURE.join(flatMappedKind)); // Output: Result: 10 -&gt; Step2 Done

   // --- ap (thenCombine) ---
   Kind&lt;CompletableFutureKind.Witness, Function&lt;Integer, String&gt;&gt; funcKind = futureMonad.of(i -&gt; "FuncResult:" + i);
   Kind&lt;CompletableFutureKind.Witness, Integer&gt; valKind = futureMonad.of(25);

   Kind&lt;CompletableFutureKind.Witness, String&gt; apResult = futureMonad.ap(funcKind, valKind);
   System.out.println("Ap Result: " + FUTURE.join(apResult)); // Output: FuncResult:25

   // --- mapN ---
   Kind&lt;CompletableFutureKind.Witness, Integer&gt; f1 = futureMonad.of(5);
   Kind&lt;CompletableFutureKind.Witness, String&gt; f2 = futureMonad.of("abc");

   BiFunction&lt;Integer, String, String&gt; combine = (i, s) -&gt; s + i;
   Kind&lt;CompletableFutureKind.Witness, String&gt; map2Result = futureMonad.map2(f1, f2, combine);
   System.out.println("Map2 Result: " + FUTURE.join(map2Result)); // Output: abc5

}
</code></pre>
</div>
</div>
<div id="admonition-example-3-handling-errors-with-_handleerrorwith_" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-3-handling-errors-with-_handleerrorwith_-title">
<div class="admonition-title">
<div id="admonition-example-3-handling-errors-with-_handleerrorwith_-title">
<p>Example 3: Handling Errors with <em>handleErrorWith</em></p>
</div>
<a class="admonition-anchor-link" href="monads/cf_monad.html#admonition-example-3-handling-errors-with-_handleerrorwith_"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/future/CompletableFutureExample.java">CompletableFutureExample.java</a></li>
</ul>
<p>This is where <code>CompletableFutureMonad</code> shines, providing functional error recovery.</p>
<pre><code class="language-java"> public void errorHandlingExample(){
   // Get the MonadError instance
   CompletableFutureMonad futureMonad = CompletableFutureMonad.INSTANCE;
   RuntimeException runtimeEx = new IllegalStateException("Processing Failed");
   IOException checkedEx = new IOException("File Not Found");

   Kind&lt;CompletableFutureKind.Witness, String&gt; failedRuntimeKind = futureMonad.raiseError(runtimeEx);
   Kind&lt;CompletableFutureKind.Witness, String&gt; failedCheckedKind = futureMonad.raiseError(checkedEx);
   Kind&lt;CompletableFutureKind.Witness, String&gt; successKind = futureMonad.of("Original Success");

   // --- Handler Function ---
   // Function&lt;Throwable, Kind&lt;CompletableFutureKind.Witness, String&gt;&gt;
   Function&lt;Throwable, Kind&lt;CompletableFutureKind.Witness, String&gt;&gt; recoveryHandler =
           error -&gt; {
              System.out.println("Handling error: " + error.getMessage());
              if (error instanceof IOException) {
                 // Recover from specific checked exceptions
                 return futureMonad.of("Recovered from IO Error");
              } else if (error instanceof IllegalStateException) {
                 // Recover from specific runtime exceptions
                 return FUTURE.widen(CompletableFuture.supplyAsync(()-&gt;{
                    System.out.println("Async recovery..."); // Recovery can be async too!
                    return "Recovered from State Error (async)";
                 }));
              } else if (error instanceof ArithmeticException) { 
                 // Recover from ArithmeticException
                 return futureMonad.of("Recovered from Arithmetic Error: " + error.getMessage());
              }
              else {
                 // Re-raise unhandled errors
                 System.out.println("Unhandled error type: " + error.getClass().getSimpleName());
                 return futureMonad.raiseError(new RuntimeException("Recovery failed", error));
              }
           };

   // --- Applying Handler ---

   // Handle RuntimeException
   Kind&lt;CompletableFutureKind.Witness, String&gt; recoveredRuntime = futureMonad.handleErrorWith(
           failedRuntimeKind,
           recoveryHandler
   );
   System.out.println("Recovered (Runtime): " + FUTURE.join(recoveredRuntime));
   // Output:
   // Handling error: Processing Failed
   // Async recovery...
   // Recovered (Runtime): Recovered from State Error (async)


   // Handle CheckedException
   Kind&lt;CompletableFutureKind.Witness, String&gt; recoveredChecked = futureMonad.handleErrorWith(
           failedCheckedKind,
           recoveryHandler
   );
   System.out.println("Recovered (Checked): " + FUTURE.join(recoveredChecked));
   // Output:
   // Handling error: File Not Found
   // Recovered (Checked): Recovered from IO Error


   // Handler is ignored for success
   Kind&lt;CompletableFutureKind.Witness, String&gt; handledSuccess = futureMonad.handleErrorWith(
           successKind,
           recoveryHandler // This handler is never called
   );
   System.out.println("Handled (Success): " + FUTURE.join(handledSuccess));
   // Output: Handled (Success): Original Success


   // Example of re-raising an unhandled error
   ArithmeticException unhandledEx = new ArithmeticException("Bad Maths");
   Kind&lt;CompletableFutureKind.Witness, String&gt; failedUnhandledKind = futureMonad.raiseError(unhandledEx);
   Kind&lt;CompletableFutureKind.Witness, String&gt; failedRecovery = futureMonad.handleErrorWith(
           failedUnhandledKind,
           recoveryHandler
   );

   try {
      FUTURE.join(failedRecovery);
   } catch (CompletionException e) { // join wraps the "Recovery failed" exception
      System.err.println("Caught re-raised error: " + e.getCause());
      System.err.println("  Original cause: " + e.getCause().getCause());
   }
   // Output:
   // Handling error: Bad Maths
}
</code></pre>
<ul>
<li><code>handleErrorWith</code> allows you to inspect the <code>Throwable</code> and return a <em>new</em><code>CompletableFutureKind</code>, potentially recovering the flow.</li>
<li>The handler receives the <em>cause</em> of the failure (unwrapped from <code>CompletionException</code> if necessary).</li>
</ul>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="monads/supported-types.html">Supported Types</a>
<strong>Next:</strong> <a href="monads/either_monad.html">Either</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="the-eithermonad"><a class="header" href="#the-eithermonad">The EitherMonad:</a></h1>
<h2 id="typed-error-handling"><a class="header" href="#typed-error-handling"><em>Typed Error Handling</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="monads/either_monad.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to represent computations that can succeed (Right) or fail (Left) with specific error types</li>
<li>Building type-safe error handling without exceptions</li>
<li>Chaining operations with automatic Left propagation</li>
<li>Using fold to handle both success and failure cases</li>
<li>Integration with EitherT for combining with other effects</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code:</p>
</div>
<a class="admonition-anchor-link" href="monads/either_monad.html#admonition-see-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/either/EitherExample.java">EitherExample.java</a></p>
</div>
</div>
<h2 id="purpose-1"><a class="header" href="#purpose-1">Purpose</a></h2>
<p>The <code>Either&lt;L, R&gt;</code> type represents a value that can be one of two possible types, conventionally denoted as <code>Left</code> and <code>Right</code>. Its primary purpose in functional programming and this library is to provide an explicit, type-safe way to handle computations that can result in either a successful outcome or a specific kind of failure.</p>
<ul>
<li><strong><code>Right&lt;L, R&gt;</code></strong>: By convention, represents the <strong>success</strong> case, holding a value of type <code>R</code>.</li>
<li><strong><code>Left&lt;L, R&gt;</code></strong>: By convention, represents the <strong>failure</strong> or alternative case, holding a value of type <code>L</code> (often an error type).</li>
</ul>
<p>Unlike throwing exceptions, <code>Either</code> makes the possibility of failure explicit in the return type of a function. Unlike <code>Optional</code> or <code>Maybe</code>, which simply signal the absence of a value, <code>Either</code> allows carrying specific information about <em>why</em> a computation failed in the <code>Left</code> value.</p>
<p>We can think of <code>Either</code> as an extension of <code>Maybe</code>. The <code>Right</code> is equivalent to <code>Maybe.Just</code>, and the <code>Left</code> is the equivalent of <code>Maybe.Nothing</code> <strong>but now we can allow it to carry a value.</strong></p>
<p>The implementation in this library is a <code>sealed interface Either&lt;L, R&gt;</code> with two <code>record</code> implementations: <code>Left&lt;L, R&gt;</code> and <code>Right&lt;L, R&gt;</code>. Both <code>Left</code> and <code>Right</code> directly implement <code>EitherKind&lt;L, R&gt;</code> (and <code>EitherKind2&lt;L, R&gt;</code> for bifunctor operations), which extend <code>Kind&lt;EitherKind.Witness&lt;L&gt;, R&gt;</code>. This means widen/narrow operations have zero runtime overhead (no wrapper object allocation needed).</p>
<h2 id="structure-2"><a class="header" href="#structure-2">Structure</a></h2>
<p><img src="monads/../images/puml/either_type.svg" alt="either_type.svg" /></p>
<div id="admonition-related-types" class="admonition admonish-note" role="note" aria-labelledby="admonition-related-types-title">
<div class="admonition-title">
<div id="admonition-related-types-title">
<p>Related Types</p>
</div>
<a class="admonition-anchor-link" href="monads/either_monad.html#admonition-related-types"></a>
</div>
<div>
<p>For handling exceptions specifically, see <a href="monads/./try_monad.html">Try Monad</a>, which is an <code>Either</code> specialised with <code>Throwable</code> as the error type. For fail-fast validation with error accumulation in applicative context, see <a href="monads/./validated_monad.html">Validated Monad</a>.</p>
</div>
</div>
<h2 id="creating-instances"><a class="header" href="#creating-instances">Creating Instances</a></h2>
<p>You create <code>Either</code> instances using the static factory methods:</p>
<div id="admonition-creating-instances" class="admonition admonish-note" role="note" aria-labelledby="admonition-creating-instances-title">
<div class="admonition-title">
<div id="admonition-creating-instances-title">
<p>Creating Instances</p>
</div>
<a class="admonition-anchor-link" href="monads/either_monad.html#admonition-creating-instances"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/either/EitherExample.java">EitherExample.java</a></li>
</ul>
<pre><code class="language-java">
// Success case
Either&lt;String, Integer&gt; success = Either.right(123);

// Failure case
Either&lt;String, Integer&gt; failure = Either.left("File not found");

// Null values are permitted in Left or Right by default in this implementation
Either&lt;String, Integer&gt; rightNull = Either.right(null);
Either&lt;String, Integer&gt; leftNull = Either.left(null);
</code></pre>
</div>
</div>
<h2 id="working-with-either"><a class="header" href="#working-with-either">Working with <code>Either</code></a></h2>
<p>Several methods are available to interact with <code>Either</code> values:</p>
<div id="admonition-checking-state" class="admonition admonish-note" role="note" aria-labelledby="admonition-checking-state-title">
<div class="admonition-title">
<div id="admonition-checking-state-title">
<p>Checking State</p>
</div>
<a class="admonition-anchor-link" href="monads/either_monad.html#admonition-checking-state"></a>
</div>
<div>
<ul>
<li>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/either/EitherExample.java">EitherExample.java</a></p>
<ul>
<li><code>isLeft()</code>: Returns <code>true</code> if it's a <code>Left</code>, <code>false</code> otherwise.</li>
<li><code>isRight()</code>: Returns <code>true</code> if it's a <code>Right</code>, <code>false</code> otherwise.</li>
</ul>
<pre><code class="language-java">if (success.isRight()) {
    System.out.println("It's Right!");
}
if (failure.isLeft()) {
    System.out.println("It's Left!");
}
</code></pre>
</li>
</ul>
</div>
</div>
<div id="admonition-extracting-values-_use-with-caution_" class="admonition admonish-note" role="note" aria-labelledby="admonition-extracting-values-_use-with-caution_-title">
<div class="admonition-title">
<div id="admonition-extracting-values-_use-with-caution_-title">
<p>Extracting Values (<em>Use with Caution</em>)</p>
</div>
<a class="admonition-anchor-link" href="monads/either_monad.html#admonition-extracting-values-_use-with-caution_"></a>
</div>
<div>
<ul>
<li>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/either/EitherExample.java">EitherExample.java</a></p>
<ul>
<li><code>getLeft()</code>: Returns the <code>value</code> if it's a <code>Left</code>, otherwise throws <code>NoSuchElementException</code>.</li>
<li><code>getRight()</code>: Returns the <code>value</code> if it's a <code>Right</code>, otherwise throws <code>NoSuchElementException</code>.</li>
</ul>
<pre><code class="language-java">  try {
    Integer value = success.getRight(); // Returns 123
    String error = failure.getLeft();  // Returns "File not found"
    // String errorFromSuccess = success.getLeft(); // Throws NoSuchElementException
  } catch (NoSuchElementException e) {
    System.err.println("Attempted to get the wrong side: " + e.getMessage());
  }
</code></pre>
</li>
</ul>
</div>
</div>
<p><em>Note: Prefer <code>fold</code> or pattern matching over direct <code>getLeft</code>/<code>getRight</code> calls.</em></p>
<div id="admonition-pattern-matching--folding" class="admonition admonish-note" role="note" aria-labelledby="admonition-pattern-matching--folding-title">
<div class="admonition-title">
<div id="admonition-pattern-matching--folding-title">
<p>Pattern Matching / Folding</p>
</div>
<a class="admonition-anchor-link" href="monads/either_monad.html#admonition-pattern-matching--folding"></a>
</div>
<div>
<ul>
<li>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/either/EitherExample.java">EitherExample.java</a></p>
</li>
<li>
<p>The <code>fold</code> method is the safest way to handle both cases by providing two functions: one for the <code>Left</code> case and one for the <code>Right</code> case. It returns the result of whichever function is applied.</p>
<pre><code class="language-java">String resultMessage = failure.fold(
    leftValue -&gt; "Operation failed with: " + leftValue,  // Function for Left
    rightValue -&gt; "Operation succeeded with: " + rightValue // Function for Right
);
// resultMessage will be "Operation failed with: File not found"

String successMessage = success.fold(
    leftValue -&gt; "Error: " + leftValue,
    rightValue -&gt; "Success: " + rightValue
);
// successMessage will be "Success: 123"
</code></pre>
</li>
</ul>
</div>
</div>
<div id="admonition-_map_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_map_-title">
<div class="admonition-title">
<div id="admonition-_map_-title">
<p><em>Map</em></p>
</div>
<a class="admonition-anchor-link" href="monads/either_monad.html#admonition-_map_"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/either/EitherExample.java">EitherExample.java</a></li>
</ul>
<p>Applies a function only to the <code>Right</code> value, leaving a <code>Left</code> unchanged. This is known as being "right-biased".</p>
<pre><code class="language-java">  Function&lt;Integer, String&gt; intToString = Object::toString;

  Either&lt;String, String&gt; mappedSuccess = success.map(intToString); // Right(123) -&gt; Right("123")
  Either&lt;String, String&gt; mappedFailure = failure.map(intToString); // Left(...) -&gt; Left(...) unchanged

  System.out.println(mappedSuccess); // Output: Right(value=123)
  System.out.println(mappedFailure); // Output: Left(value=File not found)
</code></pre>
</div>
</div>
<div id="admonition-_flatmap_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_flatmap_-title">
<div class="admonition-title">
<div id="admonition-_flatmap_-title">
<p><em>flatMap</em></p>
</div>
<a class="admonition-anchor-link" href="monads/either_monad.html#admonition-_flatmap_"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/either/EitherExample.java">EitherExample.java</a></li>
</ul>
<p>Applies a function that <em>itself returns an <code>Either</code></em> to a <code>Right</code> value. If the initial <code>Either</code> is <code>Left</code>, it's returned unchanged. If the function applied to the <code>Right</code> value returns a <code>Left</code>, that <code>Left</code> becomes the result. This allows sequencing operations where each step can fail. The <code>Left</code> type acts as a functor that dismisses the mapped function <code>f</code> and returns itself (<code>map(f) -&gt; Left(Value)</code>). It preserves the value it holds. After a <code>Left</code> is encountered, subsequent transformations via <code>map</code> or <code>flatMap</code> are typically short-circuited.</p>
<pre><code class="language-java">public void basicFlatMap(){

  // Example: Parse string, then check if positive
  Function&lt;String, Either&lt;String, Integer&gt;&gt; parse = s -&gt; {
    try { return Either.right(Integer.parseInt(s.trim())); }
    catch (NumberFormatException e) { return Either.left("Invalid number"); }
  };
  Function&lt;Integer, Either&lt;String, Integer&gt;&gt; checkPositive = i -&gt;
      (i &gt; 0) ? Either.right(i) : Either.left("Number not positive");

  Either&lt;String, String&gt; input1 = Either.right(" 10 ");
  Either&lt;String, String&gt; input2 = Either.right(" -5 ");
  Either&lt;String, String&gt; input3 = Either.right(" abc ");
  Either&lt;String, String&gt; input4 = Either.left("Initial error");

  // Chain parse then checkPositive
  Either&lt;String, Integer&gt; result1 = input1.flatMap(parse).flatMap(checkPositive); // Right(10)
  Either&lt;String, Integer&gt; result2 = input2.flatMap(parse).flatMap(checkPositive); // Left("Number not positive")
  Either&lt;String, Integer&gt; result3 = input3.flatMap(parse).flatMap(checkPositive); // Left("Invalid number")
  Either&lt;String, Integer&gt; result4 = input4.flatMap(parse).flatMap(checkPositive); // Left("Initial error")

  System.out.println(result1);
  System.out.println(result2);
  System.out.println(result3);
  System.out.println(result4);
}
</code></pre>
</div>
</div>
<div id="admonition-using-_eithermonad_" class="admonition admonish-example" role="note" aria-labelledby="admonition-using-_eithermonad_-title">
<div class="admonition-title">
<div id="admonition-using-_eithermonad_-title">
<p>Using <em>EitherMonad</em></p>
</div>
<a class="admonition-anchor-link" href="monads/either_monad.html#admonition-using-_eithermonad_"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/either/EitherExample.java">EitherExample.java</a></li>
</ul>
<p>To use <code>Either</code> within Higher-Kinded-J framework:</p>
<ol>
<li>
<p><strong>Identify Context:</strong> You are working with <code>Either&lt;L, R&gt;</code> where <code>L</code> is your chosen error type. The HKT witness will be <code>EitherKind.Witness&lt;L&gt;</code>.</p>
</li>
<li>
<p><strong>Get Type Class Instance:</strong> Obtain an instance of <code>EitherMonad&lt;L&gt;</code> for your specific error type <code>L</code>. This instance implements <code>MonadError&lt;EitherKind.Witness&lt;L&gt;, L&gt;</code>.</p>
<pre><code class="language-java">// Assuming TestError is your error type
EitherMonad&lt;TestError&gt; eitherMonad = EitherMonad.instance()
// Now 'eitherMonad' can be used for operations on Kind&lt;EitherKind.Witness&lt;String&gt;, A&gt;
</code></pre>
</li>
<li>
<p><strong>Wrap</strong>: Convert your <code>Either&lt;L, R&gt;</code> instances to <code>Kind&lt;EitherKind.Witness&lt;L&gt;, R&gt;</code> using <code>EITHER.widen()</code>. Since <code>Either&lt;L,R&gt;</code> directly implements <code>EitherKind&lt;L,R&gt;</code>.</p>
<pre><code class="language-java"> EitherMonad&lt;String&gt; eitherMonad = EitherMonad.instance()

 Either&lt;String, Integer&gt; myEither = Either.right(10);
 // F_WITNESS is EitherKind.Witness&lt;String&gt;, A is Integer
 Kind&lt;EitherKind.Witness&lt;String&gt;, Integer&gt; eitherKind = EITHER.widen(myEither);
</code></pre>
</li>
<li>
<p><strong>Apply Operations:</strong>  Use the methods on the <code>eitherMonad</code> instance (<code>map</code>, <code>flatMap</code>, <code>ap</code>, <code>raiseError</code>, <code>handleErrorWith</code>, etc.).</p>
<pre><code class="language-java">// Using map via the Monad instance
 Kind&lt;EitherKind.Witness&lt;String&gt;, String&gt; mappedKind = eitherMonad.map(Object::toString, eitherKind);
 System.out.println("mappedKind: " + EITHER.narrow(mappedKind)); // Output: Right[value = 10]

 // Using flatMap via the Monad instance
 Function&lt;Integer, Kind&lt;EitherKind.Witness&lt;String&gt;, Double&gt;&gt; nextStep =
     i -&gt; EITHER.widen( (i &gt; 5) ? Either.right(i/2.0) : Either.left("TooSmall"));
 Kind&lt;EitherKind.Witness&lt;String&gt;, Double&gt; flatMappedKind = eitherMonad.flatMap(nextStep, eitherKind);

 // Creating a Left Kind using raiseError
 Kind&lt;EitherKind.Witness&lt;String&gt;, Integer&gt; errorKind = eitherMonad.raiseError("E101"); // L is String here

 // Handling an error
 Kind&lt;EitherKind.Witness&lt;String&gt;, Integer&gt; handledKind =
     eitherMonad.handleErrorWith(errorKind, error -&gt; { 
       System.out.println("Handling error: " + error);
       return eitherMonad.of(0); // Recover with Right(0)
     });
</code></pre>
</li>
<li>
<p><strong>Unwrap:</strong> Get the final <code>Either&lt;L, R&gt;</code> back using <code>EITHER.narrow()</code> when needed.</p>
<pre><code class="language-java"> Either&lt;String, Integer&gt; finalEither = EITHER.narrow(handledKind);
 System.out.println("Final unwrapped Either: " + finalEither); // Output: Right(0)
</code></pre>
</li>
</ol>
</div>
</div>
<div id="admonition-key-points" class="admonition admonish-tip" role="note" aria-labelledby="admonition-key-points-title">
<div class="admonition-title">
<div id="admonition-key-points-title">
<p>Key Points:</p>
</div>
<a class="admonition-anchor-link" href="monads/either_monad.html#admonition-key-points"></a>
</div>
<div>
<ul>
<li>Explicitly modelling and handling domain-specific errors (e.g., validation failures, resource not found, business rule violations).</li>
<li>Sequencing operations where any step might fail with a typed error, short-circuiting the remaining steps.</li>
<li>Serving as the inner type for monad transformers like <code>EitherT</code> to combine typed errors with other effects like asynchronicity (see the <a href="monads/../hkts/order-walkthrough.html">Order Example Walkthrough</a>).</li>
<li>Providing a more informative alternative to returning <code>null</code> or relying solely on exceptions for expected failure conditions.</li>
</ul>
</div>
</div>
<hr />
<div id="admonition-effect-path-alternative" class="admonition admonish-tip" role="note" aria-labelledby="admonition-effect-path-alternative-title">
<div class="admonition-title">
<div id="admonition-effect-path-alternative-title">
<p>Effect Path Alternative</p>
</div>
<a class="admonition-anchor-link" href="monads/either_monad.html#admonition-effect-path-alternative"></a>
</div>
<div>
<p>For most use cases, prefer <strong><a href="monads/../effect/path_either.html">EitherPath</a></strong> which wraps <code>Either</code> and provides:</p>
<ul>
<li>Fluent composition with <code>map</code>, <code>via</code>, <code>recover</code></li>
<li>Seamless integration with the <a href="monads/../optics/focus_dsl.html">Focus DSL</a> for structural navigation</li>
<li>A consistent API shared across all effect types</li>
</ul>
<pre><code class="language-java">// Instead of manual Either chaining:
Either&lt;Error, User&gt; user = findUser(id);
Either&lt;Error, Order&gt; order = user.flatMap(u -&gt; createOrder(u));

// Use EitherPath for cleaner composition:
EitherPath&lt;Error, Order&gt; order = Path.either(findUser(id))
    .via(u -&gt; createOrder(u));
</code></pre>
<p>See <a href="monads/../effect/effect_path_overview.html">Effect Path Overview</a> for the complete guide.</p>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="monads/cf_monad.html">CompletableFuture</a>
<strong>Next:</strong> <a href="monads/identity.html">Identity</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="identity-monad-id"><a class="header" href="#identity-monad-id">Identity Monad (Id)</a></h1>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code:</p>
</div>
<a class="admonition-anchor-link" href="monads/identity.html#admonition-see-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/id/IdExample.java">IdExample.java</a></p>
</div>
</div>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="monads/identity.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>What the Identity Monad is and why it's the simplest monad</li>
<li>How Id serves as a base case for monad transformers</li>
<li>The key classes and concepts: Id, IdKind, IdKind.Witness, IdKindHelper, and IdMonad</li>
<li>How to create and use Id instances with monadic operations</li>
<li>How to use Id with monad transformers like StateT</li>
</ul>
</div>
</div>
<p>The Identity Monad, often referred to as <code>IdMonad</code>, is the simplest possible monad. It represents a computation that doesn't add any additional context or effect beyond simply holding a value. It's a direct wrapper around a value.</p>
<p>While it might seem trivial on its own, the Identity Monad plays a crucial role in a higher-kinded type library for several reasons:</p>
<ol>
<li>
<p><strong>Base Case for Monad Transformers</strong>: Many monad transformers (like <code>StateT</code>, <code>ReaderT</code>, <code>MaybeT</code>, etc.) can be specialised to their simpler, non-transformed monad counterparts by using <code>Id</code> as the underlying monad. For example:</p>
<ul>
<li><code>StateT&lt;S, IdKind.Witness, A&gt;</code> is conceptually equivalent to <code>State&lt;S, A&gt;</code>.</li>
<li><code>MaybeT&lt;IdKind.Witness, A&gt;</code> is conceptually equivalent to <code>Maybe&lt;A&gt;</code>.
This allows for a unified way to define transformers and derive base monads.</li>
</ul>
</li>
<li>
<p><strong>Generic Programming</strong>: When writing functions that are generic over any <code>Monad&lt;F&gt;</code>, <code>Id</code> can serve as the "no-effect" monad, allowing you to use these generic functions with pure values without introducing unnecessary complexity.</p>
</li>
<li>
<p><strong>Understanding Monads</strong>: It provides a clear example of the monadic structure (<code>of</code>, <code>flatMap</code>, <code>map</code>) without any distracting side effects or additional computational context.</p>
</li>
</ol>
<h2 id="what-is-id"><a class="header" href="#what-is-id">What is Id?</a></h2>
<p>An <code>Id&lt;A&gt;</code> is simply a container that holds a value of type <code>A</code>.</p>
<ul>
<li><code>Id.of(value)</code> creates an <code>Id</code> instance holding <code>value</code>.</li>
<li><code>idInstance.value()</code> retrieves the value from the <code>Id</code> instance.</li>
</ul>
<h2 id="key-classes-and-concepts-1"><a class="header" href="#key-classes-and-concepts-1">Key Classes and Concepts</a></h2>
<p><img src="monads/../images/puml/id_monad.svg" alt="id_monad.svg" /></p>
<ul>
<li><strong><code>Id&lt;A&gt;</code></strong>: The data type itself. It's a record that wraps a value of type <code>A</code>. It implements <code>IdKind&lt;A&gt;</code>, which extends <code>Kind&lt;IdKind.Witness, A&gt;</code>.</li>
<li><strong><code>IdKind&lt;A&gt;</code></strong>: The Kind interface marker for the <code>Id</code> type. It extends <code>Kind&lt;IdKind.Witness, A&gt;</code>, following the standard Higher-Kinded-J pattern used by other types like <code>TrampolineKind</code> and <code>FreeKind</code>.</li>
<li><strong><code>IdKind.Witness</code></strong>: A static nested class within <code>IdKind</code> used as the phantom type marker (the <code>F</code> in <code>Kind&lt;F, A&gt;</code>) to represent the <code>Id</code> type constructor at the type level. This is part of the HKT emulation pattern.</li>
<li><strong><code>IdKindHelper</code></strong>: A utility class providing static helper methods:
<ul>
<li><code>narrow(Kind&lt;IdKind.Witness, A&gt; kind)</code>: Safely casts a <code>Kind</code> back to a concrete <code>Id&lt;A&gt;</code>.</li>
<li><code>widen(Id&lt;A&gt; id)</code>: widens an <code>Id&lt;A&gt;</code> to <code>Kind&lt;IdKind.Witness, A&gt;</code>. (Often an identity cast since <code>Id</code> implements <code>Kind</code>).</li>
<li><code>narrows(Kind&lt;IdKind.Witness, A&gt; kind)</code>: A convenience to narrow and then get the value.</li>
</ul>
</li>
<li><strong><code>IdMonad</code></strong>: The singleton class that implements <code>Monad&lt;IdKind.Witness&gt;</code>, providing the monadic operations for <code>Id</code>.</li>
</ul>
<h2 id="using-id-and-idmonad"><a class="header" href="#using-id-and-idmonad">Using <code>Id</code> and <code>IdMonad</code></a></h2>
<div id="admonition-example-1-creating-id-instances" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-1-creating-id-instances-title">
<div class="admonition-title">
<div id="admonition-example-1-creating-id-instances-title">
<p>Example 1: Creating Id Instances</p>
</div>
<a class="admonition-anchor-link" href="monads/identity.html#admonition-example-1-creating-id-instances"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/id/IdExample.java">IdExample.java</a></li>
</ul>
<pre><code class="language-java">public void createExample(){
  // Direct creation
  Id&lt;String&gt; idString = Id.of("Hello, Identity!");
  Id&lt;Integer&gt; idInt = Id.of(123);
  Id&lt;String&gt; idNull = Id.of(null); // Id can wrap null

  // Accessing the value
  String value = idString.value(); // "Hello, Identity!"
  Integer intValue = idInt.value();   // 123
  String nullValue = idNull.value(); // null
}
</code></pre>
</div>
</div>
<div id="admonition-example-2-using-with-idmonad" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-2-using-with-idmonad-title">
<div class="admonition-title">
<div id="admonition-example-2-using-with-idmonad-title">
<p>Example 2: Using with IdMonad</p>
</div>
<a class="admonition-anchor-link" href="monads/identity.html#admonition-example-2-using-with-idmonad"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/id/IdExample.java">IdExample.java</a></li>
</ul>
<p>The <code>IdMonad</code> provides the standard monadic operations.</p>
<pre><code class="language-java">public void monadExample(){
  IdMonad idMonad = IdMonad.instance();

  // 1. 'of' (lifting a value)
  Kind&lt;IdKind.Witness, Integer&gt; kindInt = idMonad.of(42);
  Id&lt;Integer&gt; idFromOf = ID.narrow(kindInt);
  System.out.println("From of: " + idFromOf.value()); // Output: From of: 42

  // 2. 'map' (applying a function to the wrapped value)
  Kind&lt;IdKind.Witness, String&gt; kindStringMapped = idMonad.map(
      i -&gt; "Value is " + i,
      kindInt
  );
  Id&lt;String&gt; idMapped = ID.narrow(kindStringMapped);
  System.out.println("Mapped: " + idMapped.value()); // Output: Mapped: Value is 42

  // 3. 'flatMap' (applying a function that returns an Id)
  Kind&lt;IdKind.Witness, String&gt; kindStringFlatMapped = idMonad.flatMap(
      i -&gt; Id.of("FlatMapped: " + (i * 2)), // Function returns Id&lt;String&gt;
      kindInt
  );
  Id&lt;String&gt; idFlatMapped = ID.narrow(kindStringFlatMapped);
  System.out.println("FlatMapped: " + idFlatMapped.value()); // Output: FlatMapped: 84

  // flatMap can also be called directly on Id if the function returns Id
  Id&lt;String&gt; directFlatMap = idFromOf.flatMap(i -&gt; Id.of("Direct FlatMap: " + i));
  System.out.println(directFlatMap.value()); // Output: Direct FlatMap: 42

  // 4. 'ap' (applicative apply)
  Kind&lt;IdKind.Witness, Function&lt;Integer, String&gt;&gt; kindFunction = idMonad.of(i -&gt; "Applied: " + i);
  Kind&lt;IdKind.Witness, String&gt; kindApplied = idMonad.ap(kindFunction, kindInt);
  Id&lt;String&gt; idApplied = ID.narrow(kindApplied);
  System.out.println("Applied: " + idApplied.value()); // Output: Applied: 42
}
</code></pre>
</div>
</div>
<div id="admonition-example-3-using-id-with-monad-transformers" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-3-using-id-with-monad-transformers-title">
<div class="admonition-title">
<div id="admonition-example-3-using-id-with-monad-transformers-title">
<p>Example 3: Using Id with Monad Transformers</p>
</div>
<a class="admonition-anchor-link" href="monads/identity.html#admonition-example-3-using-id-with-monad-transformers"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/id/IdExample.java">IdExample.java</a></li>
</ul>
<p>As mentioned in the <a href="monads/../transformers/statet_transformer.html">StateT Monad Transformer</a> documentation, <code>State&lt;S,A&gt;</code> can be thought of as <code>StateT&lt;S, IdKind.Witness, A&gt;</code>.</p>
<p>Let's illustrate how you might define a <code>State</code> monad type alias or use <code>StateT</code> with <code>IdMonad</code>:</p>
<pre><code class="language-java">  public void transformerExample(){
  // Conceptually, State&lt;S, A&gt; is StateT&lt;S, IdKind.Witness, A&gt;
  // We can create a StateTMonad instance using IdMonad as the underlying monad.
  StateTMonad&lt;Integer, IdKind.Witness&gt; stateMonadOverId =
      StateTMonad.instance(IdMonad.instance());

  // Example: A "State" computation that increments the state and returns the old state
  Function&lt;Integer, Kind&lt;IdKind.Witness, StateTuple&lt;Integer, Integer&gt;&gt;&gt; runStateFn =
      currentState -&gt; Id.of(StateTuple.of(currentState + 1, currentState));

  // Create the StateT (acting as State)
  Kind&lt;StateTKind.Witness&lt;Integer, IdKind.Witness&gt;, Integer&gt; incrementAndGet =
      StateTKindHelper.stateT(runStateFn, IdMonad.instance());

  // Run it
  Integer initialState = 10;
  Kind&lt;IdKind.Witness, StateTuple&lt;Integer, Integer&gt;&gt; resultIdTuple =
      StateTKindHelper.runStateT(incrementAndGet, initialState);

  // Unwrap the Id and then the StateTuple
  Id&lt;StateTuple&lt;Integer, Integer&gt;&gt; idTuple = ID.narrow(resultIdTuple);
  StateTuple&lt;Integer, Integer&gt; tuple = idTuple.value();

  System.out.println("Initial State: " + initialState);       // Output: Initial State: 10
  System.out.println("Returned Value (Old State): " + tuple.value()); // Output: Returned Value (Old State): 10
  System.out.println("Final State: " + tuple.state());         // Output: Final State: 11
}
</code></pre>
<p>This example shows that <code>StateT</code> with <code>Id</code> behaves just like a standard <code>State</code> monad, where the "effect" of the underlying monad is simply identity (no additional effect).</p>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="monads/either_monad.html">Either</a>
<strong>Next:</strong> <a href="monads/io_monad.html">IO</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="the-iomonad"><a class="header" href="#the-iomonad">The IOMonad:</a></h1>
<h2 id="managing-side-effects-with-io"><a class="header" href="#managing-side-effects-with-io"><em>Managing Side Effects with <code>IO</code></em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="monads/io_monad.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to describe side effects without performing them immediately</li>
<li>Building pure functional programs with deferred execution</li>
<li>Composing complex side-effecting operations using <code>map</code> and <code>flatMap</code></li>
<li>The difference between describing effects and running them with <code>unsafeRunSync</code></li>
<li>Creating testable, composable programs that separate logic from execution</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code:</p>
</div>
<a class="admonition-anchor-link" href="monads/io_monad.html#admonition-see-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/io/IOExample.java">IOExample.java</a></p>
</div>
</div>
<p>In functional programming, managing side effects (like printing to the console, reading files, making network calls, generating random numbers, or getting the current time) while maintaining purity is a common challenge.</p>
<p>The <code>IO&lt;A&gt;</code> monad in <code>higher-kinded-j</code> provides a way to encapsulate these side-effecting computations, making them first-class values that can be composed and manipulated functionally.</p>
<p>The key idea is that an <code>IO&lt;A&gt;</code> value doesn't <em>perform</em> the side effect immediately upon creation. Instead, it represents a <em>description</em> or <em>recipe</em> for a computation that, when executed, will perform the effect and potentially produce a value of type <code>A</code>. The actual execution is deferred until explicitly requested.</p>
<h2 id="core-components"><a class="header" href="#core-components">Core Components</a></h2>
<p><strong>The IO Type</strong></p>
<p><img src="monads/../images/puml/io_detail.svg" alt="io_detail.svg" /></p>
<p><strong>The HKT Bridge for IO</strong></p>
<p><img src="monads/../images/puml/io_kind.svg" alt="io_kind.svg" /></p>
<p><strong>Typeclasses for IO</strong></p>
<p><img src="monads/../images/puml/io_monad.svg" alt="io_monad.svg" /></p>
<p>The <code>IO</code> functionality is built upon several related components:</p>
<ol>
<li><strong><code>IO&lt;A&gt;</code></strong>: The core functional interface. An <code>IO&lt;A&gt;</code> instance essentially wraps a <code>Supplier&lt;A&gt;</code> (or similar function) that performs the side effect and returns a value <code>A</code>. The crucial method is <code>unsafeRunSync()</code>, which executes the encapsulated computation. <code>IO&lt;A&gt;</code> directly extends <code>IOKind&lt;A&gt;</code>, making it a first-class participant in the HKT simulation.</li>
<li><strong><code>IOKind&lt;A&gt;</code></strong>: The HKT marker interface (<code>Kind&lt;IOKind.Witness, A&gt;</code>) for <code>IO</code>. This allows <code>IO</code> to be treated as a generic type constructor <code>F</code> in type classes like <code>Functor</code>, <code>Applicative</code>, and <code>Monad</code>. The witness type is <code>IOKind.Witness</code>. Since <code>IO&lt;A&gt;</code> directly extends this interface, no wrapper types are needed.</li>
<li><strong><code>IOKindHelper</code></strong>: The essential utility class for working with <code>IO</code> in the HKT simulation. It provides:
<ul>
<li><code>widen(IO&lt;A&gt;)</code>: Converts a concrete <code>IO&lt;A&gt;</code> instance into its HKT representation <code>Kind&lt;IOKind.Witness, A&gt;</code>. Since <code>IO</code> directly implements <code>IOKind</code>, this is a null-checked cast with zero runtime overhead.</li>
<li><code>narrow(Kind&lt;IOKind.Witness, A&gt;)</code>: Converts back to the concrete <code>IO&lt;A&gt;</code>. Performs an <code>instanceof IO</code> check and cast. Throws <code>KindUnwrapException</code> if the input Kind is invalid.</li>
<li><code>delay(Supplier&lt;A&gt;)</code>: The primary factory method to create an <code>IOKind&lt;A&gt;</code> by wrapping a side-effecting computation described by a <code>Supplier</code>.</li>
<li><code>unsafeRunSync(Kind&lt;IOKind.Witness, A&gt;)</code>: The method to <em>execute</em> the computation described by an <code>IOKind</code>. This is typically called at the "end of the world" in your application (e.g., in the <code>main</code> method) to run the composed IO program.</li>
</ul>
</li>
<li><strong><code>IOFunctor</code></strong>: Implements <code>Functor&lt;IOKind.Witness&gt;</code>. Provides the <code>map</code> operation to transform the result value <code>A</code> of an <code>IO</code> computation <em>without</em> executing the effect.</li>
<li><strong><code>IOApplicative</code></strong>: Extends <code>IOFunctor</code> and implements <code>Applicative&lt;IOKind.Witness&gt;</code>. Provides <code>of</code> (to lift a pure value into <code>IO</code> without side effects) and <code>ap</code> (to apply a function within <code>IO</code> to a value within <code>IO</code>).</li>
<li><strong><code>IOMonad</code></strong>: Extends <code>IOApplicative</code> and implements <code>Monad&lt;IOKind.Witness&gt;</code>. Provides <code>flatMap</code> to sequence <code>IO</code> computations, ensuring effects happen in the intended order.</li>
</ol>
<h2 id="purpose-and-usage-1"><a class="header" href="#purpose-and-usage-1">Purpose and Usage</a></h2>
<ul>
<li><strong>Encapsulating Side Effects</strong>: Describe effects (like printing, reading files, network calls) as <code>IO</code> values without executing them immediately.</li>
<li><strong>Maintaining Purity</strong>: Functions that create or combine <code>IO</code> values remain pure. They don't perform the effects themselves, they just build up a description of the effects to be performed later.</li>
<li><strong>Composition</strong>: Use <code>map</code> and <code>flatMap</code> (via <code>IOMonad</code>) to build complex sequences of side-effecting operations from smaller, reusable <code>IO</code> actions.</li>
<li><strong>Deferred Execution</strong>: Effects are only performed when <code>unsafeRunSync</code> is called on the final, composed <code>IO</code> value. This separates the description of the program from its execution.</li>
</ul>
<p><strong>Important Note:</strong> <code>IO</code> in this library primarily deals with <em>deferring</em> execution. It does <em>not</em> automatically provide sophisticated error handling like <code>Either</code> or <code>Try</code>, nor does it manage asynchronicity like <code>CompletableFuture</code>. Exceptions thrown during <code>unsafeRunSync</code> will typically propagate unless explicitly handled <em>within</em> the <code>Supplier</code> provided to <code>IOKindHelper.delay</code>. For combining IO with typed error handling, consider using <code>EitherT&lt;IOKind.Witness, E, A&gt;</code> (monad transformer) or wrapping IO operations with <code>Try</code> for exception handling.</p>
<div id="admonition-example-1-creating-basic-io-actions" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-1-creating-basic-io-actions-title">
<div class="admonition-title">
<div id="admonition-example-1-creating-basic-io-actions-title">
<p>Example 1: Creating Basic IO Actions</p>
</div>
<a class="admonition-anchor-link" href="monads/io_monad.html#admonition-example-1-creating-basic-io-actions"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/io/IOExample.java">IOExample.java</a></li>
</ul>
<p>Use <code>IOKindHelper.delay</code> to capture side effects. Use <code>IOMonad.of</code> for pure values within IO.</p>
<pre><code class="language-java">import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.io.*; 
import org.higherkindedj.hkt.Unit;
import java.util.function.Supplier;
import java.util.Scanner;

// Get the IOMonad instance
IOMonad ioMonad = IOMonad.INSTANCE;

// IO action to print a message
Kind&lt;IOKind.Witness, Unit&gt; printHello = IOKindHelper.delay(() -&gt; {
    System.out.println("Hello from IO!");
    return Unit.INSTANCE;
});

// IO action to read a line from the console
Kind&lt;IOKind.Witness, String&gt; readLine = IOKindHelper.delay(() -&gt; {
    System.out.print("Enter your name: ");
    // Scanner should ideally be managed more robustly in real apps
    try (Scanner scanner = new Scanner(System.in)) {
         return scanner.nextLine();
    }
});

// IO action that returns a pure value (no side effect description here)
Kind&lt;IOKind.Witness, Integer&gt; pureValueIO = ioMonad.of(42);

// IO action that simulates getting the current time (a side effect)
Kind&lt;IOKind.Witness, Long&gt; currentTime = IOKindHelper.delay(System::currentTimeMillis);

// Creating an IO action that might fail internally
Kind&lt;IOKind.Witness, String&gt; potentiallyFailingIO = IOKindHelper.delay(() -&gt; {
   if (Math.random() &lt; 0.5) {
       throw new RuntimeException("Simulated failure!");
   }
   return "Success!";
});


</code></pre>
</div>
</div>
<p><em>Nothing happens when you create these <code>IOKind</code> values. The <code>Supplier</code> inside <code>delay</code> is not executed.</em></p>
<div id="admonition-example-2-executing-io-actions" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-2-executing-io-actions-title">
<div class="admonition-title">
<div id="admonition-example-2-executing-io-actions-title">
<p>Example 2. Executing IO Actions</p>
</div>
<a class="admonition-anchor-link" href="monads/io_monad.html#admonition-example-2-executing-io-actions"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/io/IOExample.java">IOExample.java</a></li>
</ul>
<p>Use <code>IOKindHelper.unsafeRunSync</code> to run the computation.</p>
<pre><code class="language-java">// (Continuing from above examples)

// Execute printHello
System.out.println("Running printHello:");
IOKindHelper.unsafeRunSync(printHello); // Actually prints "Hello from IO!"

// Execute readLine (will block for user input)
// System.out.println("\nRunning readLine:");
// String name = IOKindHelper.unsafeRunSync(readLine);
// System.out.println("User entered: " + name);

// Execute pureValueIO
System.out.println("\nRunning pureValueIO:");
Integer fetchedValue = IOKindHelper.unsafeRunSync(pureValueIO);
System.out.println("Fetched pure value: " + fetchedValue); // Output: 42

// Execute potentiallyFailingIO
System.out.println("\nRunning potentiallyFailingIO:");
try {
String result = IOKindHelper.unsafeRunSync(potentiallyFailingIO);
   System.out.println("Succeeded: " + result);
} catch (RuntimeException e) {
   System.err.println("Caught expected failure: " + e.getMessage());
   }

// Notice that running the same IO action again executes the effect again
   System.out.println("\nRunning printHello again:");
IOKindHelper.unsafeRunSync(printHello); // Prints "Hello from IO!" again
</code></pre>
</div>
</div>
<div id="admonition-example-3-composing-io-actions-with-map-and-flatmap" class="admonition admonish-note" role="note" aria-labelledby="admonition-example-3-composing-io-actions-with-map-and-flatmap-title">
<div class="admonition-title">
<div id="admonition-example-3-composing-io-actions-with-map-and-flatmap-title">
<p>Example 3: Composing IO Actions with <code>map</code> and <code>flatMap</code></p>
</div>
<a class="admonition-anchor-link" href="monads/io_monad.html#admonition-example-3-composing-io-actions-with-map-and-flatmap"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/io/IOExample.java">IOExample.java</a></li>
</ul>
<p>Use <code>IOMonad</code> instance methods.</p>
<pre><code class="language-java">import org.higherkindedj.hkt.io.IOMonad;
import org.higherkindedj.hkt.Unit;
import java.util.function.Function;

IOMonad ioMonad = IOMonad.INSTANCE;

// --- map example ---
Kind&lt;IOKind.Witness, String&gt; readLineAction = IOKindHelper.delay(() -&gt; "Test Input"); // Simulate input

// Map the result of readLineAction without executing readLine yet
Kind&lt;IOKind.Witness, String&gt; greetAction = ioMonad.map(
    name -&gt; "Hello, " + name + "!", // Function to apply to the result
    readLineAction
);

System.out.println("Greet action created, not executed yet.");
// Now execute the mapped action
String greeting = IOKindHelper.unsafeRunSync(greetAction);
System.out.println("Result of map: " + greeting); // Output: Hello, Test Input!

// --- flatMap example ---
// Action 1: Get name
Kind&lt;IOKind.Witness, String&gt; getName = IOKindHelper.delay(() -&gt; {
    System.out.println("Effect: Getting name...");
    return "Alice";
});

// Action 2 (depends on name): Print greeting
Function&lt;String, Kind&lt;IOKind.Witness, Unit&gt;&gt; printGreeting = name -&gt;
    IOKindHelper.delay(() -&gt; {
        System.out.println("Effect: Printing greeting for " + name);
        System.out.println("Welcome, " + name + "!");
        return Unit.INSTANCE;
    });

// Combine using flatMap
Kind&lt;IOKind.Witness, Void&gt; combinedAction = ioMonad.flatMap(printGreeting, getName);

System.out.println("\nCombined action created, not executed yet.");
// Execute the combined action
IOKindHelper.unsafeRunSync(combinedAction);
// Output:
// Effect: Getting name...
// Effect: Printing greeting for Alice
// Welcome, Alice!

// --- Full Program Example ---
Kind&lt;IOKind.Witness, Unit&gt; program = ioMonad.flatMap(
    ignored -&gt; ioMonad.flatMap( // Chain after printing hello
        name -&gt; ioMonad.map( // Map the result of printing the greeting
            ignored2 -&gt; { System.out.println("Program finished");
              return Unit.INSTANCE; },
              printGreeting.apply(name) // Action 3: Print greeting based on name
        ),
        readLine // Action 2: Read line
    ),
    printHello // Action 1: Print Hello
);

System.out.println("\nComplete IO Program defined. Executing...");
// IOKindHelper.unsafeRunSync(program); // Uncomment to run the full program
</code></pre>
<p><em>Notes:</em></p>
<ul>
<li><code>map</code> transforms the <em>result</em> of an <code>IO</code> action without changing the effect itself (though the transformation happens <em>after</em> the effect runs).</li>
<li><code>flatMap</code> sequences <code>IO</code> actions, ensuring the effect of the first action completes before the second action (which might depend on the first action's result) begins.</li>
</ul>
<hr />
<pre><code class="language-admonish tip title=&quot;Effect Path Alternative&quot;">For most use cases, prefer **[IOPath](../effect/path_io.md)** which wraps `IO` and provides:

- Fluent composition with `map`, `via`, `recover`
- Seamless integration with the [Focus DSL](../optics/focus_dsl.md) for structural navigation
- A consistent API shared across all effect types

```java
// Instead of manual IO chaining:
Kind&lt;IOKind.Witness, Config&gt; config = IOKindHelper.delay(() -&gt; loadConfig());
Kind&lt;IOKind.Witness, String&gt; value = ioMonad.flatMap(
    c -&gt; IOKindHelper.delay(() -&gt; c.getValue("key")), config);

// Use IOPath for cleaner composition:
IOPath&lt;String&gt; value = Path.io(() -&gt; loadConfig())
    .via(c -&gt; Path.io(() -&gt; c.getValue("key")));
```

See [Effect Path Overview](../effect/effect_path_overview.md) for the complete guide.

&lt;/div&gt;
&lt;/div&gt;

---

**Previous:** [Identity](identity.md)
**Next:** [Lazy](lazy_monad.md)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="the-lazy-monad"><a class="header" href="#the-lazy-monad">The Lazy Monad:</a></h1>
<h2 id="lazy-evaluation-with-lazy"><a class="header" href="#lazy-evaluation-with-lazy"><em>Lazy Evaluation with <code>Lazy</code></em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="monads/lazy_monad.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to defer expensive computations until their results are actually needed</li>
<li>Understanding memoisation and how results are cached after first evaluation</li>
<li>Handling exceptions in lazy computations with ThrowableSupplier</li>
<li>Composing lazy operations while preserving laziness</li>
<li>Building efficient pipelines that avoid unnecessary work</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code:</p>
</div>
<a class="admonition-anchor-link" href="monads/lazy_monad.html#admonition-see-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/lazy/LazyExample.java">LazyExample.java</a></p>
</div>
</div>
<p>This article introduces the <code>Lazy&lt;A&gt;</code> type and its associated components within the <code>higher-kinded-j</code> library. <code>Lazy</code> provides a mechanism for deferred computation, where a value is calculated only when needed and the result (or any exception thrown during calculation) is memoised (cached).</p>
<h2 id="core-components-1"><a class="header" href="#core-components-1">Core Components</a></h2>
<p><strong>The Lazy Type</strong></p>
<p><img src="monads/../images/puml/lazy_class.svg" alt="lazy_class.svg" /></p>
<p><strong>The HKT Bridge for Lazy</strong></p>
<p><img src="monads/../images/puml/lazy_kind.svg" alt="lazy_kind.svg" /></p>
<p><strong>Typeclasses for Lazy</strong></p>
<p><img src="monads/../images/puml/lazy_monad.svg" alt="lazy_monad.svg" /></p>
<p>The lazy evaluation feature revolves around these key types:</p>
<ol>
<li><strong><code>ThrowableSupplier&lt;T&gt;</code></strong>: A functional interface similar to <code>java.util.function.Supplier</code>, but its <code>get()</code> method is allowed to throw any <code>Throwable</code> (including checked exceptions). This is used as the underlying computation for <code>Lazy</code>.</li>
<li><strong><code>Lazy&lt;A&gt;</code></strong>: The core class representing a computation that produces a value of type <code>A</code> lazily. It takes a <code>ThrowableSupplier&lt;? extends A&gt;</code> during construction (<code>Lazy.defer</code>). Evaluation is triggered only by the <code>force()</code> method, and the result or exception is cached. <code>Lazy.now(value)</code> creates an already evaluated instance.</li>
<li><strong><code>LazyKind&lt;A&gt;</code></strong>: The HKT marker interface (<code>Kind&lt;LazyKind.Witness, A&gt;</code>) for <code>Lazy</code>, allowing it to be used generically with type classes like <code>Functor</code> and <code>Monad</code>.</li>
<li><strong><code>LazyKindHelper</code></strong>: A utility class providing static methods to bridge between the concrete <code>Lazy&lt;A&gt;</code> type and its HKT representation <code>LazyKind&lt;A&gt;</code>. It includes:
<ul>
<li><code>widen(Lazy&lt;A&gt;)</code>: Wraps a <code>Lazy</code> instance into <code>LazyKind</code>.</li>
<li><code>narrow(Kind&lt;LazyKind.Witness, A&gt;)</code>: Unwraps <code>LazyKind</code> back to <code>Lazy</code>. Throws <code>KindUnwrapException</code> if the input Kind is invalid.</li>
<li><code>defer(ThrowableSupplier&lt;A&gt;)</code>: Factory to create a <code>LazyKind</code> from a computation.</li>
<li><code>now(A value)</code>: Factory to create an already evaluated <code>LazyKind</code>.</li>
<li><code>force(Kind&lt;LazyKind.Witness, A&gt;)</code>: Convenience method to unwrap and force evaluation.</li>
</ul>
</li>
<li><strong><code>LazyMonad</code></strong>: The type class instance implementing <code>Monad&lt;LazyKind.Witness&gt;</code>, <code>Applicative&lt;LazyKind.Witness&gt;</code>, and <code>Functor&lt;LazyKind.Witness&gt;</code>. It provides standard monadic operations (<code>map</code>, <code>flatMap</code>, <code>of</code>, <code>ap</code>) for <code>LazyKind</code>, ensuring laziness is maintained during composition.</li>
</ol>
<h2 id="purpose-and-usage-2"><a class="header" href="#purpose-and-usage-2">Purpose and Usage</a></h2>
<ul>
<li><strong>Deferred Computation</strong>: Use <code>Lazy</code> when you have potentially expensive computations that should only execute if their result is actually needed.</li>
<li><strong>Memoization</strong>: The result (or exception) of the computation is stored after the first call to <code>force()</code>, subsequent calls return the cached result without re-computation.</li>
<li><strong>Exception Handling</strong>: Computations wrapped in <code>Lazy.defer</code> can throw any <code>Throwable</code>. This exception is caught, memoised, and re-thrown by <code>force()</code>.</li>
<li><strong>Functional Composition</strong>: <code>LazyMonad</code> allows chaining lazy computations using <code>map</code> and <code>flatMap</code> while preserving laziness. The composition itself doesn't trigger evaluation; only forcing the final <code>LazyKind</code> does.</li>
<li><strong>HKT Integration</strong>: <code>LazyKind</code> and <code>LazyMonad</code> enable using lazy computations within generic functional code expecting <code>Kind&lt;F, A&gt;</code> and <code>Monad&lt;F&gt;</code>.</li>
</ul>
<div id="admonition-example-creating-lazy-instances" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-creating-lazy-instances-title">
<div class="admonition-title">
<div id="admonition-example-creating-lazy-instances-title">
<p>Example: Creating Lazy Instances</p>
</div>
<a class="admonition-anchor-link" href="monads/lazy_monad.html#admonition-example-creating-lazy-instances"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/lazy/LazyExample.java">LazyExample.java</a></li>
</ul>
<pre><code class="language-java">
// 1. Deferring a computation (that might throw checked exception)
java.util.concurrent.atomic.AtomicInteger counter = new java.util.concurrent.atomic.AtomicInteger(0);
Kind&lt;LazyKind.Witness, String&gt; deferredLazy = LAZY.defer(() -&gt; {
    System.out.println("Executing expensive computation...");
    counter.incrementAndGet();
    // Simulate potential failure
    if (System.currentTimeMillis() % 2 == 0) {
         // Throwing a checked exception is allowed by ThrowableSupplier
         throw new java.io.IOException("Simulated IO failure");
    }
    Thread.sleep(50); // Simulate work
    return "Computed Value";
});

// 2. Creating an already evaluated Lazy
Kind&lt;LazyKind.Witness, String&gt; nowLazy = LAZY.now("Precomputed Value");

// 3. Using the underlying Lazy type directly (less common when using HKT)
Lazy&lt;String&gt; directLazy = Lazy.defer(() -&gt; { counter.incrementAndGet(); return "Direct Lazy"; });
</code></pre>
</div>
</div>
<div id="admonition-example-forcing-evaluation" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-forcing-evaluation-title">
<div class="admonition-title">
<div id="admonition-example-forcing-evaluation-title">
<p>Example: Forcing Evaluation</p>
</div>
<a class="admonition-anchor-link" href="monads/lazy_monad.html#admonition-example-forcing-evaluation"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/lazy/LazyExample.java">LazyExample.java</a></li>
</ul>
<p>Evaluation only happens when <code>force()</code> is called (directly or via the helper).</p>
<pre><code class="language-java">// (Continuing from above)
System.out.println("Lazy instances created. Counter: " + counter.get()); // Output: 0

try {
    // Force the deferred computation
    String result1 = LAZY.force(deferredLazy); // force() throws Throwable
    System.out.println("Result 1: " + result1);
    System.out.println("Counter after first force: " + counter.get()); // Output: 1

    // Force again - uses memoised result
    String result2 = LAZY.force(deferredLazy);
    System.out.println("Result 2: " + result2);
    System.out.println("Counter after second force: " + counter.get()); // Output: 1 (not re-computed)

    // Force the 'now' instance
    String resultNow = LAZY.force(nowLazy);
    System.out.println("Result Now: " + resultNow);
    System.out.println("Counter after forcing 'now': " + counter.get()); // Output: 1 (no computation ran for 'now')

} catch (Throwable t) { // Catch Throwable because force() can re-throw anything
    System.err.println("Caught exception during force: " + t);
    // Exception is also memoised:
    try {
        LAZY.force(deferredLazy);
    } catch (Throwable t2) {
        System.err.println("Caught memoised exception: " + t2);
        System.out.println("Counter after failed force: " + counter.get()); // Output: 1
    }
}
</code></pre>
</div>
</div>
<div id="admonition-example-using-_lazymonad_-_map_-and-_flatmap_" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-using-_lazymonad_-_map_-and-_flatmap_-title">
<div class="admonition-title">
<div id="admonition-example-using-_lazymonad_-_map_-and-_flatmap_-title">
<p>Example: Using <em>LazyMonad</em> (<em>map</em> and <em>flatMap</em>)</p>
</div>
<a class="admonition-anchor-link" href="monads/lazy_monad.html#admonition-example-using-_lazymonad_-_map_-and-_flatmap_"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/lazy/LazyExample.java">LazyExample.java</a></li>
</ul>
<pre><code class="language-java">
LazyMonad lazyMonad = LazyMonad.INSTANCE;
counter.set(0); // Reset counter for this example

Kind&lt;LazyKind.Witness, Integer&gt; initialLazy = LAZY.defer(() -&gt; { counter.incrementAndGet(); return 10; });

// --- map ---
// Apply a function lazily
Function&lt;Integer, String&gt; toStringMapper = i -&gt; "Value: " + i;
Kind&lt;LazyKind.Witness, String&gt; mappedLazy = lazyMonad.map(toStringMapper, initialLazy);

System.out.println("Mapped Lazy created. Counter: " + counter.get()); // Output: 0

try {
    System.out.println("Mapped Result: " + LAZY.force(mappedLazy)); // Triggers evaluation of initialLazy &amp; map
    // Output: Mapped Result: Value: 10
    System.out.println("Counter after forcing mapped: " + counter.get()); // Output: 1
} catch (Throwable t) { /* ... */ }


// --- flatMap ---
// Sequence lazy computations
Function&lt;Integer, Kind&lt;LazyKind.Witness, String&gt;&gt; multiplyAndStringifyLazy =
    i -&gt; LAZY.defer(() -&gt; { // Inner computation is also lazy
        int result = i * 5;
        return "Multiplied: " + result;
    });

Kind&lt;LazyKind.Witness, String&gt; flatMappedLazy = lazyMonad.flatMap(multiplyAndStringifyLazy, initialLazy);

System.out.println("FlatMapped Lazy created. Counter: " + counter.get()); // Output: 1 (map already forced initialLazy)

try {
    System.out.println("FlatMapped Result: " + force(flatMappedLazy)); // Triggers evaluation of inner lazy
    // Output: FlatMapped Result: Multiplied: 50
} catch (Throwable t) { /* ... */ }

// --- Chaining ---
Kind&lt;LazyKind.Witness, String&gt; chainedLazy = lazyMonad.flatMap(
    value1 -&gt; lazyMonad.map(
        value2 -&gt; "Combined: " + value1 + " &amp; " + value2, // Combine results
        LAZY.defer(()-&gt;value1 * 2) // Second lazy step, depends on result of first
    ),
    LAZY.defer(()-&gt;5) // First lazy step
);

try{
    System.out.println("Chained Result: "+force(chainedLazy)); // Output: Combined: 5 &amp; 10
}catch(Throwable t){/* ... */}
</code></pre>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="monads/io_monad.html">IO</a>
<strong>Next:</strong> <a href="monads/list_monad.html">List</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="the-listmonad"><a class="header" href="#the-listmonad">The ListMonad:</a></h1>
<h2 id="monadic-operations-on-java-lists"><a class="header" href="#monadic-operations-on-java-lists"><em>Monadic Operations on Java Lists</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="monads/list_monad.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to work with Lists as contexts representing multiple possible values</li>
<li>Using <code>flatMap</code> for non-deterministic computations and combinations</li>
<li>Generating Cartesian products and filtering results</li>
<li>Understanding how List models choice and branching computations</li>
<li>Building search algorithms and combinatorial problems with monadic operations</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code:</p>
</div>
<a class="admonition-anchor-link" href="monads/list_monad.html#admonition-see-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/list/ListMonadExample.java">ListMonadExample.java</a></p>
</div>
</div>
<h2 id="purpose-2"><a class="header" href="#purpose-2">Purpose</a></h2>
<p>The <code>ListMonad</code> in the <code>Higher-Kinded-J</code> library provides a monadic interface for Java's standard <code>java.util.List</code>. It allows developers to work with lists in a more functional style, enabling operations like <code>map</code>, <code>flatMap</code>, and <code>ap</code> (apply) within the higher-kinded type system. This is particularly useful for sequencing operations that produce lists, transforming list elements, and applying functions within a list context, all while integrating with the generic <code>Kind&lt;F, A&gt;</code> abstractions.</p>
<p>Key benefits include:</p>
<ul>
<li><strong>Functional Composition:</strong> Easily chain operations on lists, where each operation might return a list itself.</li>
<li><strong>HKT Integration:</strong> <code>ListKind</code> (the higher-kinded wrapper for <code>List</code>) and <code>ListMonad</code> allow <code>List</code> to be used with generic functions and type classes expecting <code>Kind&lt;F, A&gt;</code>, <code>Functor&lt;F&gt;</code>, <code>Applicative&lt;F&gt;</code>, or <code>Monad&lt;F&gt;</code>.</li>
<li><strong>Standard List Behavior:</strong> Leverages the familiar behaviour of Java lists, such as non-uniqueness of elements and order preservation. <code>flatMap</code> corresponds to applying a function that returns a list to each element and then concatenating the results.</li>
</ul>
<p>It implements <code>Monad&lt;ListKind&lt;A&gt;&gt;</code>, inheriting from <code>Functor&lt;ListKind&lt;A&gt;&gt;</code> and <code>Applicative&lt;ListKind&lt;A&gt;&gt;</code>.</p>
<h2 id="structure-3"><a class="header" href="#structure-3">Structure</a></h2>
<p><img src="monads/../images/puml/list_monad.svg" alt="list_monad.svg" /></p>
<h2 id="how-to-use-listmonad-and-listkind"><a class="header" href="#how-to-use-listmonad-and-listkind">How to Use <code>ListMonad</code> and <code>ListKind</code></a></h2>
<h3 id="creating-instances-1"><a class="header" href="#creating-instances-1">Creating Instances</a></h3>
<p><code>ListKind&lt;A&gt;</code> is the higher-kinded type representation for <code>java.util.List&lt;A&gt;</code>. You typically create <code>ListKind</code> instances using the <code>ListKindHelper</code> utility class or the <code>of</code> method from <code>ListMonad</code>.</p>
<div id="admonition-_listwidenlist_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_listwidenlist_-title">
<div class="admonition-title">
<div id="admonition-_listwidenlist_-title">
<p><em>LIST.widen(List<A>)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/list_monad.html#admonition-_listwidenlist_"></a>
</div>
<div>
<p>Converts a standard <code>java.util.List&lt;A&gt;</code> into a <code>Kind&lt;ListKind.Witness, A&gt;</code>.</p>
<pre><code class="language-java">List&lt;String&gt; stringList = Arrays.asList("a", "b", "c");
Kind&lt;ListKind.Witness, String&gt; listKind1 = LIST.widen(stringList);

List&lt;Integer&gt; intList = Collections.singletonList(10);
Kind&lt;ListKind.Witness, Integer&gt; listKind2 = LIST.widen(intList);

List&lt;Object&gt; emptyList = Collections.emptyList();
Kind&lt;ListKind.Witness, Object&gt; listKindEmpty = LIST.widen(emptyList);

</code></pre>
</div>
</div>
<div id="admonition-_listmonadofa-value_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_listmonadofa-value_-title">
<div class="admonition-title">
<div id="admonition-_listmonadofa-value_-title">
<p><em>listMonad.of(A value)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/list_monad.html#admonition-_listmonadofa-value_"></a>
</div>
<div>
<p>Lifts a single value into the <code>ListKind</code> context, creating a singleton list. A <code>null</code> input value results in an empty <code>ListKind</code>.</p>
<pre><code class="language-java">ListMonad listMonad = ListMonad.INSTANCE;

Kind&lt;ListKind.Witness, String&gt; listKindOneItem = listMonad.of("hello"); // Contains a list with one element: "hello"
Kind&lt;ListKind.Witness, Integer&gt; listKindAnotherItem = listMonad.of(42);  // Contains a list with one element: 42
Kind&lt;ListKind.Witness, Object&gt; listKindFromNull = listMonad.of(null); // Contains an empty list
</code></pre>
</div>
</div>
<div id="admonition-_listnarrow_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_listnarrow_-title">
<div class="admonition-title">
<div id="admonition-_listnarrow_-title">
<p><em>LIST.narrow()</em></p>
</div>
<a class="admonition-anchor-link" href="monads/list_monad.html#admonition-_listnarrow_"></a>
</div>
<div>
<p>To get the underlying <code>java.util.List&lt;A&gt;</code> from a <code>Kind&lt;ListKind.Witness, A&gt;</code>, use <code>LIST.narrow()</code>:</p>
<pre><code class="language-java">Kind&lt;ListKind.Witness, A&gt; listKind = LIST.widen(List.of("example"));
List&lt;String&gt; unwrappedList = LIST.narrow(listKind); // Returns Arrays.asList("example")
System.out.println(unwrappedList);
</code></pre>
</div>
</div>
<h3 id="key-operations-1"><a class="header" href="#key-operations-1">Key Operations</a></h3>
<p>The <code>ListMonad</code> provides standard monadic operations:</p>
<div id="admonition-_mapfunction-f-kind-fa_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_mapfunction-f-kind-fa_-title">
<div class="admonition-title">
<div id="admonition-_mapfunction-f-kind-fa_-title">
<p><em>map(Function&lt;A, B&gt; f, Kind&lt;ListKind.Witness, A&gt; fa)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/list_monad.html#admonition-_mapfunction-f-kind-fa_"></a>
</div>
<div>
<p><strong><code>map(Function&lt;A, B&gt; f, Kind&lt;ListKind.Witness, A&gt; fa)</code>:</strong></p>
<p>Applies a function <code>f</code> to each element of the list within <code>fa</code>, returning a new <code>ListKind</code> containing the transformed elements.</p>
<pre><code class="language-java">
ListMonad listMonad = ListMonad.INSTANCE;
ListKind&lt;Integer&gt; numbers = LIST.widen(Arrays.asList(1, 2, 3));

Function&lt;Integer, String&gt; intToString = i -&gt; "Number: " + i;
ListKind&lt;String&gt; strings = listMonad.map(intToString, numbers);

// LIST.narrow(strings) would be: ["Number: 1", "Number: 2", "Number: 3"]
System.out.println(LIST.narrow(strings));
</code></pre>
</div>
</div>
<div id="admonition-_flatmapfunction-f-kind-ma_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_flatmapfunction-f-kind-ma_-title">
<div class="admonition-title">
<div id="admonition-_flatmapfunction-f-kind-ma_-title">
<p><em>flatMap(Function&lt;A, Kind&lt;ListKind.Witness, B&gt;&gt; f, Kind&lt;ListKind.Witness, A&gt; ma)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/list_monad.html#admonition-_flatmapfunction-f-kind-ma_"></a>
</div>
<div>
<p><strong><code>flatMap(Function&lt;A, Kind&lt;ListKind.Witness, B&gt;&gt; f, Kind&lt;ListKind.Witness, A&gt; ma)</code>:</strong></p>
<p>Applies a function <code>f</code> to each element of the list within <code>ma</code>. The function <code>f</code> itself returns a <code>ListKind&lt;B&gt;</code>. <code>flatMap</code> then concatenates (flattens) all these resulting lists into a single <code>ListKind&lt;B&gt;</code>.</p>
<pre><code class="language-java">
ListMonad listMonad = ListMonad.INSTANCE;
Kind&lt;ListKind.Witness, Integer&gt; initialValues = LIST.widen(Arrays.asList(1, 2, 3));

// Function that takes an integer and returns a list of itself and itself + 10
Function&lt;Integer, Kind&lt;ListKind.Witness, Integer&gt;&gt; replicateAndAddTen =
    i -&gt; LIST.widen(Arrays.asList(i, i + 10));

Kind&lt;ListKind.Witness, Integer&gt; flattenedList = listMonad.flatMap(replicateAndAddTen, initialValues);

// LIST.narrow(flattenedList) would be: [1, 11, 2, 12, 3, 13]
System.out.println(LIST.narrow(flattenedList));

// Example with empty list results
Function&lt;Integer, Kind&lt;ListKind.Witness, String&gt;&gt; toWordsIfEven =
    i -&gt; (i % 2 == 0) ?
         LIST.widen(Arrays.asList("even", String.valueOf(i))) :
         LIST.widen(new ArrayList&lt;&gt;()); // empty list for odd numbers

Kind&lt;ListKind.Witness, String&gt; wordsList = listMonad.flatMap(toWordsIfEven, initialValues);
// LIST.narrow(wordsList) would be: ["even", "2"]
 System.out.println(LIST.narrow(wordsList));
</code></pre>
</div>
</div>
<div id="admonition-_apkind-ff-kind-fa_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_apkind-ff-kind-fa_-title">
<div class="admonition-title">
<div id="admonition-_apkind-ff-kind-fa_-title">
<p><em>ap(Kind&lt;ListKind.Witness, Function&lt;A, B&gt;&gt; ff, Kind&lt;ListKind.Witness, A&gt; fa)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/list_monad.html#admonition-_apkind-ff-kind-fa_"></a>
</div>
<div>
<p><strong><code>ap(Kind&lt;ListKind.Witness, Function&lt;A, B&gt;&gt; ff, Kind&lt;ListKind.Witness, A&gt; fa)</code>:</strong></p>
<p>Applies a list of functions <code>ff</code> to a list of values <code>fa</code>. This results in a new list where each function from <code>ff</code> is applied to each value in <code>fa</code> (Cartesian product style).</p>
<pre><code class="language-java">
ListMonad listMonad = ListMonad.INSTANCE;

Function&lt;Integer, String&gt; addPrefix = i -&gt; "Val: " + i;
Function&lt;Integer, String&gt; multiplyAndString = i -&gt; "Mul: " + (i * 2);

Kind&lt;ListKind.Witness, Function&lt;Integer, String&gt;&gt; functions =
    LIST.widen(Arrays.asList(addPrefix, multiplyAndString));
Kind&lt;ListKind.Witness, Integer&gt; values = LIST.widen(Arrays.asList(10, 20));

Kind&lt;ListKind.Witness, String&gt; appliedResults = listMonad.ap(functions, values);

// LIST.narrow(appliedResults) would be:
// ["Val: 10", "Val: 20", "Mul: 20", "Mul: 40"]
System.out.println(LIST.narrow(appliedResults));
</code></pre>
</div>
</div>
<div id="admonition-example-using-listmonad" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-using-listmonad-title">
<div class="admonition-title">
<div id="admonition-example-using-listmonad-title">
<p>Example: Using ListMonad</p>
</div>
<a class="admonition-anchor-link" href="monads/list_monad.html#admonition-example-using-listmonad"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/list/ListMonadExample.java">ListMonadExample.java</a></li>
</ul>
<p>To use <code>ListMonad</code> in generic contexts that operate over <code>Kind&lt;F, A&gt;</code>:</p>
<ol>
<li><strong>Get an instance of <code>ListMonad</code>:</strong></li>
</ol>
<pre><code class="language-java">ListMonad listMonad = ListMonad.INSTANCE;
</code></pre>
<ol start="2">
<li><strong>Wrap your List into <code>Kind</code>:</strong></li>
</ol>
<pre><code class="language-java">List&lt;Integer&gt; myList = Arrays.asList(10, 20, 30);
Kind&lt;ListKind.Witness, Integer&gt; listKind = LIST.widen(myList);
</code></pre>
<ol start="3">
<li><strong>Use <code>ListMonad</code> methods:</strong></li>
</ol>
<pre><code class="language-java">import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.list.ListKind;
import org.higherkindedj.hkt.list.ListKindHelper;
import org.higherkindedj.hkt.list.ListMonad;

import java.util.Arrays;
import java.util.List;
import java.util.function.Function;
import java.util.stream.Collectors;

public class ListMonadExample {
   public static void main(String[] args) {
      ListMonad listMonad = ListMonad.INSTANCE;

      // 1. Create a ListKind
      Kind&lt;ListKind.Witness, Integer&gt; numbersKind = LIST.widen(Arrays.asList(1, 2, 3, 4));

      // 2. Use map
      Function&lt;Integer, String&gt; numberToDecoratedString = n -&gt; "*" + n + "*";
      Kind&lt;ListKind.Witness, String&gt; stringsKind = listMonad.map(numberToDecoratedString, numbersKind);
      System.out.println("Mapped: " + LIST.narrow(stringsKind));
      // Expected: Mapped: [*1*, *2*, *3*, *4*]

      // 3. Use flatMap
      // Function: integer -&gt; ListKind of [integer, integer*10] if even, else empty ListKind
      Function&lt;Integer, Kind&lt;ListKind.Witness, Integer&gt;&gt; duplicateIfEven = n -&gt; {
         if (n % 2 == 0) {
            return LIST.widen(Arrays.asList(n, n * 10));
         } else {
            return LIST.widen(List.of()); // Empty list
         }
      };
      Kind&lt;ListKind.Witness, Integer&gt; flatMappedKind = listMonad.flatMap(duplicateIfEven, numbersKind);
      System.out.println("FlatMapped: " + LIST.narrow(flatMappedKind));
      // Expected: FlatMapped: [2, 20, 4, 40]

      // 4. Use of
      Kind&lt;ListKind.Witness, String&gt; singleValueKind = listMonad.of("hello world");
      System.out.println("From 'of': " + LIST.narrow(singleValueKind));
      // Expected: From 'of': [hello world]

      Kind&lt;ListKind.Witness, String&gt; fromNullOf = listMonad.of(null);
      System.out.println("From 'of' with null: " + LIST.narrow(fromNullOf));
      // Expected: From 'of' with null: []


      // 5. Use ap
      Kind&lt;ListKind.Witness, Function&lt;Integer, String&gt;&gt; listOfFunctions =
              LIST.widen(Arrays.asList(
                      i -&gt; "F1:" + i,
                      i -&gt; "F2:" + (i * i)
              ));
      Kind&lt;ListKind.Witness, Integer&gt; inputNumbersForAp = LIST.widen(Arrays.asList(5, 6));

      Kind&lt;ListKind.Witness, String&gt; apResult = listMonad.ap(listOfFunctions, inputNumbersForAp);
      System.out.println("Ap result: " + LIST.narrow(apResult));
      // Expected: Ap result: [F1:5, F1:6, F2:25, F2:36]


      // Unwrap to get back the standard List
      List&lt;Integer&gt; finalFlatMappedList = LIST.narrow(flatMappedKind);
      System.out.println("Final unwrapped flatMapped list: " + finalFlatMappedList);
   }
}
</code></pre>
<p>This example demonstrates how to wrap Java Lists into <code>ListKind</code>, apply monadic operations using <code>ListMonad</code>, and then unwrap them back to standard Lists.</p>
<hr />
<p><strong>Previous:</strong> <a href="monads/lazy_monad.html">Lazy</a>
<strong>Next:</strong> <a href="monads/maybe_monad.html">Maybe</a></p>
</div>
</div><div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="the-maybemonad"><a class="header" href="#the-maybemonad">The MaybeMonad:</a></h1>
<h2 id="handling-optional-values-with-non-null-guarantee"><a class="header" href="#handling-optional-values-with-non-null-guarantee"><em>Handling Optional Values with Non-Null Guarantee</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="monads/maybe_monad.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How Maybe provides null-safe optional values with guaranteed non-null contents</li>
<li>The difference between Maybe and Optional (non-null guarantee in Just)</li>
<li>Using Maybe as a MonadError with Unit as the error type</li>
<li>Chaining operations with automatic Nothing propagation</li>
<li>Building robust pipelines that handle absence gracefully</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code:</p>
</div>
<a class="admonition-anchor-link" href="monads/maybe_monad.html#admonition-see-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/maybe/MaybeExample.java">MaybeExample.java</a></p>
</div>
</div>
<h2 id="purpose-3"><a class="header" href="#purpose-3">Purpose</a></h2>
<p>How do you handle optional values in Java without falling into the null pointer trap? The <code>Maybe&lt;T&gt;</code> type in Higher-Kinded-J provides an elegant solution: representing a value that might be present (<code>Just&lt;T&gt;</code>) or absent (<code>Nothing&lt;T&gt;</code>), with one crucial guarantee: a <code>Just&lt;T&gt;</code> will never hold null.</p>
<p>The <code>Maybe&lt;T&gt;</code> type is conceptually similar to <code>java.util.Optional&lt;T&gt;</code> but with a key distinction: a <code>Just&lt;T&gt;</code> is guaranteed to hold a <strong>non-null</strong> value. This strictness helps prevent <code>NullPointerExceptions</code> when a value is asserted to be present. <code>Maybe.fromNullable(T value)</code> or <code>MaybeMonad.of(T value)</code> should be used if the input value could be null, as these will correctly produce a <code>Nothing</code> in such cases.</p>
<p>The <code>MaybeMonad</code> provides a monadic interface for <code>Maybe</code>, allowing for functional composition and integration with the Higher-Kinded Type (HKT) system. This facilitates chaining operations that may or may not yield a value, propagating the <code>Nothing</code> state automatically.</p>
<div id="admonition-key-benefits-include" class="admonition admonish-info" role="note" aria-labelledby="admonition-key-benefits-include-title">
<div class="admonition-title">
<div id="admonition-key-benefits-include-title">
<p>Key benefits include:</p>
</div>
<a class="admonition-anchor-link" href="monads/maybe_monad.html#admonition-key-benefits-include"></a>
</div>
<div>
<ul>
<li><strong>Explicit Optionality with Non-Null Safety:</strong> <code>Just&lt;T&gt;</code> guarantees its contained value is not null. <code>Nothing&lt;T&gt;</code> clearly indicates absence.</li>
<li><strong>Functional Composition:</strong> Enables elegant chaining of operations using <code>map</code>, <code>flatMap</code>, and <code>ap</code>, where <code>Nothing</code> short-circuits computations.</li>
<li><strong>HKT Integration:</strong> <code>MaybeKind&lt;A&gt;</code> (the HKT wrapper for <code>Maybe&lt;A&gt;</code>) and <code>MaybeMonad</code> allow <code>Maybe</code> to be used with generic functions and type classes that expect <code>Kind&lt;F, A&gt;</code>, <code>Functor&lt;F&gt;</code>, <code>Applicative&lt;F&gt;</code>, <code>Monad&lt;M&gt;</code>, or <code>MonadError&lt;M, E&gt;</code>.</li>
<li><strong>Error Handling for Absence:</strong> <code>MaybeMonad</code> implements <code>MonadError&lt;MaybeKind.Witness, Unit&gt;</code>. <code>Nothing</code> is treated as the "error" state, with <code>Unit</code> as the phantom error type, signifying absence.</li>
</ul>
</div>
</div>
<p>It implements <code>MonadError&lt;MaybeKind.Witness, Unit&gt;</code>, which transitively includes <code>Monad&lt;MaybeKind.Witness&gt;</code>, <code>Applicative&lt;MaybeKind.Witness&gt;</code>, and <code>Functor&lt;MaybeKind.Witness&gt;</code>.</p>
<h2 id="structure-4"><a class="header" href="#structure-4">Structure</a></h2>
<p><img src="monads/../images/puml/maybe_monad.svg" alt="maybe_monad.svg" /></p>
<div id="admonition-related-types" class="admonition admonish-note" role="note" aria-labelledby="admonition-related-types-title">
<div class="admonition-title">
<div id="admonition-related-types-title">
<p>Related Types</p>
</div>
<a class="admonition-anchor-link" href="monads/maybe_monad.html#admonition-related-types"></a>
</div>
<div>
<p>For working with Java's standard <code>Optional</code> type in the HKT system, see <a href="monads/./optional_monad.html">Optional Monad</a>. For error handling with typed error values, see <a href="monads/./either_monad.html">Either Monad</a>.</p>
</div>
</div>
<h2 id="how-to-use-maybemonad-and-maybe"><a class="header" href="#how-to-use-maybemonad-and-maybe">How to Use <code>MaybeMonad</code> and <code>Maybe</code></a></h2>
<h3 id="creating-instances-2"><a class="header" href="#creating-instances-2">Creating Instances</a></h3>
<p><code>Maybe&lt;A&gt;</code> instances can be created directly using static factory methods on <code>Maybe</code>, or via <code>MaybeMonad</code> for HKT integration. Since <code>Just&lt;T&gt;</code> and <code>Nothing&lt;T&gt;</code> directly implement <code>MaybeKind&lt;T&gt;</code>, they are first-class participants in the HKT simulation with zero runtime overhead for widen/narrow operations.</p>
<p><strong>Direct <code>Maybe</code> Creation:</strong></p>
 <div id="admonition-_maybejustnonnull-t-value_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_maybejustnonnull-t-value_-title">
 <div class="admonition-title">
 <div id="admonition-_maybejustnonnull-t-value_-title">
<p><em>Maybe.just(@NonNull T value)</em></p>
 </div>
 <a class="admonition-anchor-link" href="monads/maybe_monad.html#admonition-_maybejustnonnull-t-value_"></a>
 </div>
 <div>
<p>Creates a <code>Just</code> holding a <strong>non-null</strong> value. Throws <code>NullPointerException</code> if <code>value</code> is null.</p>
<pre><code class="language-java">Maybe&lt;String&gt; justHello = Maybe.just("Hello"); // Just("Hello")
Maybe&lt;String&gt; illegalJust = Maybe.just(null); // Throws NullPointerException
</code></pre>
 </div>
 </div>
  <div id="admonition-_maybenothing_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_maybenothing_-title">
  <div class="admonition-title">
  <div id="admonition-_maybenothing_-title">
<p><em>Maybe.nothing()</em></p>
  </div>
  <a class="admonition-anchor-link" href="monads/maybe_monad.html#admonition-_maybenothing_"></a>
  </div>
  <div>
<p>Returns a singleton <code>Nothing</code> instance.</p>
<pre><code class="language-java">Maybe&lt;Integer&gt; noInt = Maybe.nothing(); // Nothing
</code></pre>
  </div>
  </div>
  <div id="admonition-_maybefromnullablenullable-t-value_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_maybefromnullablenullable-t-value_-title">
  <div class="admonition-title">
  <div id="admonition-_maybefromnullablenullable-t-value_-title">
<p><em>Maybe.fromNullable(@Nullable T value)</em></p>
  </div>
  <a class="admonition-anchor-link" href="monads/maybe_monad.html#admonition-_maybefromnullablenullable-t-value_"></a>
  </div>
  <div>
<p>Creates <code>Just(value)</code> if <code>value</code> is non-null, otherwise <code>Nothing</code>.</p>
<pre><code class="language-java">Maybe&lt;String&gt; fromPresent = Maybe.fromNullable("Present"); // Just("Present")
Maybe&lt;String&gt; fromNull = Maybe.fromNullable(null);     // Nothing
</code></pre>
  </div>
  </div>
<p><strong><code>MaybeKindHelper</code> (for HKT wrapping):</strong></p>
<div id="admonition-_maybekindhelperwidenmaybe-maybe_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_maybekindhelperwidenmaybe-maybe_-title">
<div class="admonition-title">
<div id="admonition-_maybekindhelperwidenmaybe-maybe_-title">
<p><em>MaybeKindHelper.widen(Maybe<A> maybe)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/maybe_monad.html#admonition-_maybekindhelperwidenmaybe-maybe_"></a>
</div>
<div>
<p>Converts a <code>Maybe&lt;A&gt;</code> to <code>Kind&lt;MaybeKind.Witness, A&gt;</code>. Since <code>Just</code> and <code>Nothing</code> directly implement <code>MaybeKind</code>, this performs a null check and type-safe cast (zero overhead, no wrapper object allocation).</p>
<pre><code class="language-java">Kind&lt;MaybeKind.Witness, String&gt; kindJust = MAYBE.widen(Maybe.just("Wrapped"));
Kind&lt;MaybeKind.Witness,Integer&gt; kindNothing = MAYBE.widen(Maybe.nothing());
</code></pre>
</div>
</div>
<div id="admonition-_maybejustnonnull-a-value_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_maybejustnonnull-a-value_-title">
<div class="admonition-title">
<div id="admonition-_maybejustnonnull-a-value_-title">
<p><em>MAYBE.just(@NonNull A value)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/maybe_monad.html#admonition-_maybejustnonnull-a-value_"></a>
</div>
<div>
<p>Convenience for <code>widen(Maybe.just(value))</code>.</p>
</div>
</div>
<div id="admonition-_maybenothing_-1" class="admonition admonish-note" role="note" aria-labelledby="admonition-_maybenothing_-1-title">
<div class="admonition-title">
<div id="admonition-_maybenothing_-1-title">
<p><em>MAYBE.nothing()</em></p>
</div>
<a class="admonition-anchor-link" href="monads/maybe_monad.html#admonition-_maybenothing_-1"></a>
</div>
<div>
<p>Convenience for <code>widen(Maybe.nothing())</code>.</p>
</div>
</div>
<p><strong><code>MaybeMonad</code> Instance Methods:</strong></p>
<div id="admonition-_maybemonadofnullable-a-value_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_maybemonadofnullable-a-value_-title">
<div class="admonition-title">
<div id="admonition-_maybemonadofnullable-a-value_-title">
<p><em>maybeMonad.of(@Nullable A value)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/maybe_monad.html#admonition-_maybemonadofnullable-a-value_"></a>
</div>
<div>
<p>Lifts a value into <code>Kind&lt;MaybeKind.Witness, A&gt;</code>. Uses <code>Maybe.fromNullable()</code> internally.</p>
<pre><code class="language-java">MaybeMonad maybeMonad = MaybeMonad.INSTANCE;
Kind&lt;MaybeKind.Witness, String&gt; kindFromMonad = maybeMonad.of("Monadic"); // Just("Monadic")
Kind&lt;MaybeKind.Witness, String&gt; kindNullFromMonad = maybeMonad.of(null);   // Nothing
</code></pre>
</div>
</div>
<div id="admonition-_maybemonadraiseerrornullable-unit-error_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_maybemonadraiseerrornullable-unit-error_-title">
<div class="admonition-title">
<div id="admonition-_maybemonadraiseerrornullable-unit-error_-title">
<p><em>maybeMonad.raiseError(@Nullable Unit error)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/maybe_monad.html#admonition-_maybemonadraiseerrornullable-unit-error_"></a>
</div>
<div>
<p>Creates a <code>Kind&lt;MaybeKind.Witness, E&gt;</code> representing <code>Nothing</code>. The <code>error</code> (Unit) argument is ignored.</p>
<pre><code class="language-java">Kind&lt;MaybeKind.Witness, Double&gt; errorKind = maybeMonad.raiseError(Unit.INSTANCE); // Nothing
</code></pre>
</div>
</div>
<div id="admonition-unwrapping-_maybekind_" class="admonition admonish-note" role="note" aria-labelledby="admonition-unwrapping-_maybekind_-title">
<div class="admonition-title">
<div id="admonition-unwrapping-_maybekind_-title">
<p>Unwrapping <em>MaybeKind</em></p>
</div>
<a class="admonition-anchor-link" href="monads/maybe_monad.html#admonition-unwrapping-_maybekind_"></a>
</div>
<div>
<p>To get the underlying <code>Maybe&lt;A&gt;</code> from a <code>MaybeKind&lt;A&gt;</code>, use <code>MAYBE.narrow()</code>:</p>
<pre><code class="language-java">MaybeKind&lt;String&gt; kindJust = MAYBE.just("Example");
Maybe&lt;String&gt; unwrappedMaybe = MAYBE.narrow(kindJust); // Just("Example")
System.out.println("Unwrapped: " + unwrappedMaybe);

MaybeKind&lt;Integer&gt; kindNothing = MAYBE.nothing();
Maybe&lt;Integer&gt; unwrappedNothing = MAYBE.narrow(kindNothing); // Nothing
System.out.println("Unwrapped Nothing: " + unwrappedNothing);
</code></pre>
</div>
</div>
<h3 id="interacting-with-maybe-values"><a class="header" href="#interacting-with-maybe-values">Interacting with <code>Maybe</code> values</a></h3>
<p>The <code>Maybe</code> interface itself provides useful methods:</p>
<ul>
<li><code>isJust()</code>: Returns <code>true</code> if it's a <code>Just</code>.</li>
<li><code>isNothing()</code>: Returns <code>true</code> if it's a <code>Nothing</code>.</li>
<li><code>get()</code>: Returns the value if <code>Just</code>, otherwise throws <code>NoSuchElementException</code>. <strong>Use with caution.</strong></li>
<li><code>orElse(@NonNull T other)</code>: Returns the value if <code>Just</code>, otherwise returns <code>other</code>.</li>
<li><code>orElseGet(@NonNull Supplier&lt;? extends @NonNull T&gt; other)</code>: Returns the value if <code>Just</code>, otherwise invokes <code>other.get()</code>.</li>
<li>The <code>Maybe</code> interface also has its own <code>map</code> and <code>flatMap</code> methods, which are similar in behaviour to those on <code>MaybeMonad</code> but operate directly on <code>Maybe</code> instances.</li>
</ul>
<h3 id="key-operations-via-maybemonad"><a class="header" href="#key-operations-via-maybemonad">Key Operations (via <code>MaybeMonad</code>)</a></h3>
<div id="admonition-example-_mapfunction-f-kind-ma_" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-_mapfunction-f-kind-ma_-title">
<div class="admonition-title">
<div id="admonition-example-_mapfunction-f-kind-ma_-title">
<p>Example: <em>map(Function&lt;A, B&gt; f, Kind&lt;MaybeKind.Witness, A&gt; ma)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/maybe_monad.html#admonition-example-_mapfunction-f-kind-ma_"></a>
</div>
<div>
<p>Applies <code>f</code> to the value inside <code>ma</code> if it's <code>Just</code>. If <code>ma</code> is <code>Nothing</code>, or if <code>f</code> returns <code>null</code> (which <code>Maybe.fromNullable</code> then converts to <code>Nothing</code>), the result is <code>Nothing</code>.</p>
<pre><code class="language-java">void mapExample() {
  MaybeMonad maybeMonad = MaybeMonad.INSTANCE;
  Kind&lt;MaybeKind.Witness, Integer&gt; justNum = MAYBE.just(10);
  Kind&lt;MaybeKind.Witness, Integer&gt; nothingNum = MAYBE.nothing();

  Function&lt;Integer, String&gt; numToString = n -&gt; "Val: " + n;
  Kind&lt;MaybeKind.Witness, String&gt; justStr = maybeMonad.map(numToString, justNum); // Just("Val: 10")
  Kind&lt;MaybeKind.Witness, String&gt; nothingStr = maybeMonad.map(numToString, nothingNum); // Nothing

  Function&lt;Integer, String&gt; numToNull = n -&gt; null;
  Kind&lt;MaybeKind.Witness, String&gt; mappedToNull = maybeMonad.map(numToNull, justNum); // Nothing

  System.out.println("Map (Just): " + MAYBE.narrow(justStr));
  System.out.println("Map (Nothing): " + MAYBE.narrow(nothingStr));
  System.out.println("Map (To Null): " + MAYBE.narrow(mappedToNull));
}
</code></pre>
</div>
</div>
<div id="admonition-example-_flatmapfunction-f-kind-ma_" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-_flatmapfunction-f-kind-ma_-title">
<div class="admonition-title">
<div id="admonition-example-_flatmapfunction-f-kind-ma_-title">
<p>Example: <em>flatMap(Function&lt;A, Kind&lt;MaybeKind.Witness, B&gt;&gt; f, Kind&lt;MaybeKind.Witness, A&gt; ma)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/maybe_monad.html#admonition-example-_flatmapfunction-f-kind-ma_"></a>
</div>
<div>
<p>If <code>ma</code> is <code>Just(a)</code>, applies <code>f</code> to <code>a</code>. <code>f</code> must return a <code>Kind&lt;MaybeKind.Witness, B&gt;</code>. If <code>ma</code> is <code>Nothing</code>, or <code>f</code> returns <code>Nothing</code>, the result is <code>Nothing</code>.</p>
<pre><code class="language-java">void flatMapExample() {
  MaybeMonad maybeMonad = MaybeMonad.INSTANCE;
  Function&lt;String, Kind&lt;MaybeKind.Witness, Integer&gt;&gt; parseString = s -&gt; {
    try {
      return MAYBE.just(Integer.parseInt(s));
    } catch (NumberFormatException e) {
      return MAYBE.nothing();
    }
  };

  Kind&lt;MaybeKind.Witness, String&gt; justFiveStr = MAYBE.just("5");
  Kind&lt;MaybeKind.Witness, Integer&gt; parsedJust = maybeMonad.flatMap(parseString, justFiveStr); // Just(5)

  Kind&lt;MaybeKind.Witness, String&gt; justNonNumStr = MAYBE.just("abc");
  Kind&lt;MaybeKind.Witness, Integer&gt; parsedNonNum = maybeMonad.flatMap(parseString, justNonNumStr); // Nothing

  System.out.println("FlatMap (Just): " + MAYBE.narrow(parsedJust));
  System.out.println("FlatMap (NonNum): " + MAYBE.narrow(parsedNonNum));
}
</code></pre>
</div>
</div>
<div id="admonition-example-_apkind-ff-kind-fa_" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-_apkind-ff-kind-fa_-title">
<div class="admonition-title">
<div id="admonition-example-_apkind-ff-kind-fa_-title">
<p>Example: <em>ap(Kind&lt;MaybeKind.Witness, Function&lt;A, B&gt;&gt; ff, Kind&lt;MaybeKind.Witness, A&gt; fa)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/maybe_monad.html#admonition-example-_apkind-ff-kind-fa_"></a>
</div>
<div>
<p>If <code>ff</code> is <code>Just(f)</code> and <code>fa</code> is <code>Just(a)</code>, applies <code>f</code> to <code>a</code>. Otherwise, <code>Nothing</code>.</p>
<pre><code class="language-java">void apExample() {
  MaybeMonad maybeMonad = MaybeMonad.INSTANCE;
  Kind&lt;MaybeKind.Witness, Integer&gt; justNum = MAYBE.just(10);
  Kind&lt;MaybeKind.Witness, Integer&gt; nothingNum = MAYBE.nothing();
  Kind&lt;MaybeKind.Witness, Function&lt;Integer, String&gt;&gt; justFunc = MAYBE.just(i -&gt; "Result: " + i);
  Kind&lt;MaybeKind.Witness, Function&lt;Integer, String&gt;&gt; nothingFunc = MAYBE.nothing();

  Kind&lt;MaybeKind.Witness, String&gt; apApplied = maybeMonad.ap(justFunc, justNum); // Just("Result: 10")
  Kind&lt;MaybeKind.Witness, String&gt; apNothingFunc = maybeMonad.ap(nothingFunc, justNum); // Nothing
  Kind&lt;MaybeKind.Witness, String&gt; apNothingVal = maybeMonad.ap(justFunc, nothingNum); // Nothing

  System.out.println("Ap (Applied): " + MAYBE.narrow(apApplied));
  System.out.println("Ap (Nothing Func): " + MAYBE.narrow(apNothingFunc));
  System.out.println("Ap (Nothing Val): " + MAYBE.narrow(apNothingVal));
}
</code></pre>
</div>
</div>
<div id="admonition-example-_handleerrorwithkind-ma-function-handler_" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-_handleerrorwithkind-ma-function-handler_-title">
<div class="admonition-title">
<div id="admonition-example-_handleerrorwithkind-ma-function-handler_-title">
<p>Example: <em>handleErrorWith(Kind&lt;MaybeKind.Witness, A&gt; ma, Function&lt;Void, Kind&lt;MaybeKind.Witness, A&gt;&gt; handler)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/maybe_monad.html#admonition-example-_handleerrorwithkind-ma-function-handler_"></a>
</div>
<div>
<p>If <code>ma</code> is <code>Just</code>, it's returned. If <code>ma</code> is <code>Nothing</code> (the "error" state), <code>handler</code> is invoked (with <code>Unit.INSTANCE</code> for <code>Unit</code>) to provide a recovery <code>MaybeKind</code>.</p>
<pre><code class="language-java">void handleErrorWithExample() {
  MaybeMonad maybeMonad = MaybeMonad.INSTANCE;
  Function&lt;Unit, Kind&lt;MaybeKind.Witness, String&gt;&gt; recover = v -&gt; MAYBE.just("Recovered");

  Kind&lt;MaybeKind.Witness, String&gt; handledJust = maybeMonad.handleErrorWith(MAYBE.just("Original"), recover); // Just("Original")
  Kind&lt;MaybeKind.Witness, String&gt; handledNothing = maybeMonad.handleErrorWith(MAYBE.nothing(), recover);    // Just("Recovered")

  System.out.println("HandleError (Just): " + MAYBE.narrow(handledJust));
  System.out.println("HandleError (Nothing): " + MAYBE.narrow(handledNothing));
}
</code></pre>
</div>
</div>
<div id="admonition-example-using-_maybemonad_" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-using-_maybemonad_-title">
<div class="admonition-title">
<div id="admonition-example-using-_maybemonad_-title">
<p>Example: Using <em>MaybeMonad</em></p>
</div>
<a class="admonition-anchor-link" href="monads/maybe_monad.html#admonition-example-using-_maybemonad_"></a>
</div>
<div>
<p>A complete example demonstrating generic usage:</p>
<pre><code class="language-java">public void monadExample() {
  MaybeMonad maybeMonad = MaybeMonad.INSTANCE;

  // 1. Create MaybeKind instances
  Kind&lt;MaybeKind.Witness, Integer&gt; presentIntKind = MAYBE.just(100);
  Kind&lt;MaybeKind.Witness, Integer&gt; absentIntKind = MAYBE.nothing();
  Kind&lt;MaybeKind.Witness, String&gt; nullInputStringKind = maybeMonad.of(null); // Becomes Nothing

  // 2. Use map
  Function&lt;Integer, String&gt; intToStatus = n -&gt; "Status: " + n;
  Kind&lt;MaybeKind.Witness, String&gt; mappedPresent = maybeMonad.map(intToStatus, presentIntKind);
  Kind&lt;MaybeKind.Witness, String&gt; mappedAbsent = maybeMonad.map(intToStatus, absentIntKind);

  System.out.println("Mapped (Present): " + MAYBE.narrow(mappedPresent)); // Just(Status: 100)
  System.out.println("Mapped (Absent): " + MAYBE.narrow(mappedAbsent));   // Nothing

  // 3. Use flatMap
  Function&lt;Integer, Kind&lt;MaybeKind.Witness, String&gt;&gt; intToPositiveStatusKind = n -&gt;
      (n &gt; 0) ? maybeMonad.of("Positive: " + n) : MAYBE.nothing();

  Kind&lt;MaybeKind.Witness, String&gt; flatMappedPresent = maybeMonad.flatMap(intToPositiveStatusKind, presentIntKind);
  Kind&lt;MaybeKind.Witness, String&gt; flatMappedZero = maybeMonad.flatMap(intToPositiveStatusKind, maybeMonad.of(0)); // 0 is not &gt; 0

  System.out.println("FlatMapped (Present Positive): " + MAYBE.narrow(flatMappedPresent)); // Just(Positive: 100)
  System.out.println("FlatMapped (Zero): " + MAYBE.narrow(flatMappedZero)); // Nothing

  // 4. Use 'of' and 'raiseError'
  Kind&lt;MaybeKind.Witness, String&gt; fromOf = maybeMonad.of("Direct Value");
  Kind&lt;MaybeKind.Witness, String&gt; fromRaiseError = maybeMonad.raiseError(Unit.INSTANCE); // Creates Nothing
  System.out.println("From 'of': " + MAYBE.narrow(fromOf)); // Just(Direct Value)
  System.out.println("From 'raiseError': " + MAYBE.narrow(fromRaiseError)); // Nothing
  System.out.println("From 'of(null)': " + MAYBE.narrow(nullInputStringKind)); // Nothing


  // 5. Use handleErrorWith
  Function&lt;Void, Kind&lt;MaybeKind.Witness, Integer&gt;&gt; recoverWithDefault =
      v -&gt; maybeMonad.of(-1); // Default value if absent

  Kind&lt;MaybeKind.Witness, Integer&gt; recoveredFromAbsent =
      maybeMonad.handleErrorWith(absentIntKind, recoverWithDefault);
  Kind&lt;MaybeKind.Witness, Integer&gt; notRecoveredFromPresent =
      maybeMonad.handleErrorWith(presentIntKind, recoverWithDefault);

  System.out.println("Recovered (from Absent): " + MAYBE.narrow(recoveredFromAbsent)); // Just(-1)
  System.out.println("Recovered (from Present): " + MAYBE.narrow(notRecoveredFromPresent)); // Just(100)

  // Using the generic processData function
  Kind&lt;MaybeKind.Witness, String&gt; processedPresent = processData(presentIntKind, x -&gt; "Processed: " + x, "N/A", maybeMonad);
  Kind&lt;MaybeKind.Witness, String&gt; processedAbsent = processData(absentIntKind, x -&gt; "Processed: " + x, "N/A", maybeMonad);

  System.out.println("Generic Process (Present): " + MAYBE.narrow(processedPresent)); // Just(Processed: 100)
  System.out.println("Generic Process (Absent): " + MAYBE.narrow(processedAbsent));   // Just(N/A)

  // Unwrap to get back the standard Maybe
  Maybe&lt;String&gt; finalMappedMaybe = MAYBE.narrow(mappedPresent);
  System.out.println("Final unwrapped mapped maybe: " + finalMappedMaybe); // Just(Status: 100)
}

public static &lt;A, B&gt; Kind&lt;MaybeKind.Witness, B&gt; processData(
    Kind&lt;MaybeKind.Witness, A&gt; inputKind,
    Function&lt;A, B&gt; mapper,
    B defaultValueOnAbsence,
    MaybeMonad monad
) {
  // inputKind is now Kind&lt;MaybeKind.Witness, A&gt;, which is compatible with monad.map
  Kind&lt;MaybeKind.Witness, B&gt; mappedKind = monad.map(mapper, inputKind);

  // The result of monad.map is Kind&lt;MaybeKind.Witness, B&gt;.
  // The handler (Unit v) -&gt; monad.of(defaultValueOnAbsence) also produces Kind&lt;MaybeKind.Witness, B&gt;.
  return monad.handleErrorWith(mappedKind, (Unit v) -&gt; monad.of(defaultValueOnAbsence));
}
</code></pre>
<p>This example highlights how <code>MaybeMonad</code> facilitates working with optional values in a functional, type-safe manner, especially when dealing with the HKT abstractions and requiring non-null guarantees for present values.</p>
</div>
</div>
<hr />
<div id="admonition-effect-path-alternative" class="admonition admonish-tip" role="note" aria-labelledby="admonition-effect-path-alternative-title">
<div class="admonition-title">
<div id="admonition-effect-path-alternative-title">
<p>Effect Path Alternative</p>
</div>
<a class="admonition-anchor-link" href="monads/maybe_monad.html#admonition-effect-path-alternative"></a>
</div>
<div>
<p>For most use cases, prefer <strong><a href="monads/../effect/path_maybe.html">MaybePath</a></strong> which wraps <code>Maybe</code> and provides:</p>
<ul>
<li>Fluent composition with <code>map</code>, <code>via</code>, <code>recover</code></li>
<li>Seamless integration with the <a href="monads/../optics/focus_dsl.html">Focus DSL</a> for structural navigation</li>
<li>A consistent API shared across all effect types</li>
</ul>
<pre><code class="language-java">// Instead of manual Maybe chaining:
Maybe&lt;User&gt; user = findUser(id);
Maybe&lt;String&gt; name = user.flatMap(u -&gt; Maybe.fromNullable(u.name()));

// Use MaybePath for cleaner composition:
MaybePath&lt;String&gt; name = Path.maybe(findUser(id))
    .via(u -&gt; Path.maybe(u.name()));
</code></pre>
<p>See <a href="monads/../effect/effect_path_overview.html">Effect Path Overview</a> for the complete guide.</p>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="monads/list_monad.html">List</a>
<strong>Next:</strong> <a href="monads/optional_monad.html">Optional</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="the-optionalmonad"><a class="header" href="#the-optionalmonad">The OptionalMonad:</a></h1>
<h2 id="monadic-operations-for-java-optional"><a class="header" href="#monadic-operations-for-java-optional"><em>Monadic Operations for Java Optional</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="monads/optional_monad.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to integrate Java's Optional with Higher-Kinded-J's type class system</li>
<li>Using MonadError with Unit to represent absence as an error state</li>
<li>Chaining optional operations with automatic empty propagation</li>
<li>Building safe database and service call pipelines</li>
<li>When to choose Optional vs Maybe for your use case</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code:</p>
</div>
<a class="admonition-anchor-link" href="monads/optional_monad.html#admonition-see-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/optional/OptionalExample.java">OptionalExample.java</a></p>
</div>
</div>
<h2 id="purpose-4"><a class="header" href="#purpose-4">Purpose</a></h2>
<p>The <code>OptionalMonad</code> in the <code>Higher-Kinded-J</code> library provides a monadic interface for Java's standard <code>java.util.Optional&lt;T&gt;</code>. It allows developers to work with <code>Optional</code> values in a more functional and composable style, enabling operations like <code>map</code>, <code>flatMap</code>, and <code>ap</code> (apply) within the higher-kinded type (HKT) system. This is particularly useful for sequencing operations that may or may not produce a value, handling the presence or absence of values gracefully.</p>
<p>Key benefits include:</p>
<ul>
<li><strong>Functional Composition:</strong> Easily chain operations on <code>Optional</code>s, where each operation might return an <code>Optional</code> itself. If any step results in an <code>Optional.empty()</code>, subsequent operations are typically short-circuited, propagating the empty state.</li>
<li><strong>HKT Integration:</strong> <code>OptionalKind&lt;A&gt;</code> (the higher-kinded wrapper for <code>Optional&lt;A&gt;</code>) and <code>OptionalMonad</code> allow <code>Optional</code> to be used with generic functions and type classes expecting <code>Kind&lt;F, A&gt;</code>, <code>Functor&lt;F&gt;</code>, <code>Applicative&lt;F&gt;</code>, <code>Monad&lt;M&gt;</code>, or even <code>MonadError&lt;M, E&gt;</code>.</li>
<li><strong>Error Handling for Absence:</strong> <code>OptionalMonad</code> implements <code>MonadError&lt;OptionalKind.Witness, Unit&gt;</code>. In this context, <code>Optional.empty()</code> is treated as the "error" state, and <code>Unit</code> is used as the phantom error type, signifying absence rather than a traditional exception.</li>
</ul>
<p>It implements <code>MonadError&lt;OptionalKind.Witness, Unit&gt;</code>, which means it also transitively implements <code>Monad&lt;OptionalKind.Witness&gt;</code>, <code>Applicative&lt;OptionalKind.Witness&gt;</code>, and <code>Functor&lt;OptionalKind.Witness&gt;</code>.</p>
<h2 id="structure-5"><a class="header" href="#structure-5">Structure</a></h2>
<p><img src="monads/../images/puml/optional_monad.svg" alt="optional_monad.svg" /></p>
<h2 id="how-to-use-optionalmonad-and-optionalkind"><a class="header" href="#how-to-use-optionalmonad-and-optionalkind">How to Use <code>OptionalMonad</code> and <code>OptionalKind</code></a></h2>
<h3 id="creating-instances-3"><a class="header" href="#creating-instances-3">Creating Instances</a></h3>
<p><code>OptionalKind&lt;A&gt;</code> is the higher-kinded type representation for <code>java.util.Optional&lt;A&gt;</code>. You typically create <code>OptionalKind</code> instances using the <code>OptionalKindHelper</code> utility class or the <code>of</code> and <code>raiseError</code> methods from <code>OptionalMonad</code>.</p>
<div id="admonition-_optionalwidenoptional_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_optionalwidenoptional_-title">
<div class="admonition-title">
<div id="admonition-_optionalwidenoptional_-title">
<p><em>OPTIONAL.widen(Optional<A>)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/optional_monad.html#admonition-_optionalwidenoptional_"></a>
</div>
<div>
<p>Converts a standard <code>java.util.Optional&lt;A&gt;</code> into an <code>OptionalKind&lt;A&gt;</code>.</p>
<pre><code class="language-java">// Wrapping a present Optional
Optional&lt;String&gt; presentOptional = Optional.of("Hello");
OptionalKind&lt;String&gt; kindPresent = OPTIONAL.widen(presentOptional);

// Wrapping an empty Optional
Optional&lt;Integer&gt; emptyOptional = Optional.empty();
OptionalKind&lt;Integer&gt; kindEmpty = OPTIONAL.widen(emptyOptional);

// Wrapping an Optional that might be null (though Optional itself won't be null)
String possiblyNullValue = null;
Optional&lt;String&gt; nullableOptional = Optional.ofNullable(possiblyNullValue); // Results in Optional.empty()
OptionalKind&lt;String&gt; kindFromNullable = OPTIONAL.widen(nullableOptional);
</code></pre>
</div>
</div>
<div id="admonition-_optionalmonadofa-value_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_optionalmonadofa-value_-title">
<div class="admonition-title">
<div id="admonition-_optionalmonadofa-value_-title">
<p><em>optionalMonad.of(A value)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/optional_monad.html#admonition-_optionalmonadofa-value_"></a>
</div>
<div>
<p>Lifts a single value (which can be <code>null</code>) into the <code>OptionalKind</code> context. It uses <code>Optional.ofNullable(value)</code> internally.</p>
<pre><code class="language-java">OptionalMonad optionalMonad = OptionalMonad.INSTANCE;

Kind&lt;OptionalKind.Witness, String&gt; kindFromValue = optionalMonad.of("World"); // Wraps Optional.of("World")
Kind&lt;OptionalKind.Witness, Integer&gt; kindFromNullValue = optionalMonad.of(null); // Wraps Optional.empty()
</code></pre>
</div>
</div>
<div id="admonition-_optionalmonadraiseerrorunit-error_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_optionalmonadraiseerrorunit-error_-title">
<div class="admonition-title">
<div id="admonition-_optionalmonadraiseerrorunit-error_-title">
<p><em>optionalMonad.raiseError(Unit error)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/optional_monad.html#admonition-_optionalmonadraiseerrorunit-error_"></a>
</div>
<div>
<p>Creates an empty <code>OptionalKind</code>. Since <code>Unit</code> is the error type, this method effectively represents the "error" state of an <code>Optional</code>, which is <code>Optional.empty()</code>. The <code>error</code> argument (which would be <code>Unit.INSTANCE</code> for <code>Unit</code>) is ignored.</p>
<pre><code class="language-java">
OptionalMonad optionalMonad = OptionalMonad.INSTANCE;
Kind&lt;OptionalKind.Witness, String&gt; emptyKindFromError = optionalMonad.raiseError(Unit.INSTANCE); // Represents Optional.empty()
</code></pre>
</div>
</div>
<div id="admonition-_optionalnarrow_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_optionalnarrow_-title">
<div class="admonition-title">
<div id="admonition-_optionalnarrow_-title">
<p><em>OPTIONAL.narrow()</em></p>
</div>
<a class="admonition-anchor-link" href="monads/optional_monad.html#admonition-_optionalnarrow_"></a>
</div>
<div>
<p>To get the underlying <code>java.util.Optional&lt;A&gt;</code> from an <code>OptionalKind&lt;A&gt;</code>, use <code>OPTIONAL.narrow()</code>:</p>
<pre><code class="language-java">
OptionalKind&lt;String&gt; kindPresent = OPTIONAL.widen(Optional.of("Example"));
Optional&lt;String&gt; unwrappedOptional = OPTIONAL.narrow(kindPresent); // Returns Optional.of("Example")
System.out.println("Unwrapped: " + unwrappedOptional);

OptionalKind&lt;Integer&gt; kindEmpty = OPTIONAL.widen(Optional.empty());
Optional&lt;Integer&gt; unwrappedEmpty = OPTIONAL.narrow(kindEmpty); // Returns Optional.empty()
System.out.println("Unwrapped Empty: " + unwrappedEmpty);
</code></pre>
</div>
</div>
<h3 id="key-operations-2"><a class="header" href="#key-operations-2">Key Operations</a></h3>
<p>The <code>OptionalMonad</code> provides standard monadic and error-handling operations:</p>
<div id="admonition-example-_mapfunction-f-kind-fa_" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-_mapfunction-f-kind-fa_-title">
<div class="admonition-title">
<div id="admonition-example-_mapfunction-f-kind-fa_-title">
<p>Example: <em>map(Function&lt;A, B&gt; f, Kind&lt;OptionalKind.Witness, A&gt; fa)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/optional_monad.html#admonition-example-_mapfunction-f-kind-fa_"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/optional/OptionalExample.java">OptionalExample.java</a></li>
</ul>
<p>Applies a function <code>f</code> to the value inside <code>fa</code> if it's present. If <code>fa</code> is empty, it remains empty. The function <code>f</code> can return <code>null</code>, which <code>Optional.map</code> will turn into an <code>Optional.empty()</code>.</p>
<pre><code class="language-java">
public void mapExample() {
   OptionalMonad optionalMonad = OptionalMonad.INSTANCE;
   OptionalKind&lt;Integer&gt; presentNumber = OPTIONAL.widen(Optional.of(10));
   OptionalKind&lt;Integer&gt; emptyNumber = OPTIONAL.widen(Optional.empty());

   Function&lt;Integer, String&gt; intToString = i -&gt; "Number: " + i;
   Kind&lt;OptionalKind.Witness, String&gt; presentString = optionalMonad.map(intToString, presentNumber);
   // OPTIONAL.narrow(presentString) would be Optional.of("Number: 10")

   Kind&lt;OptionalKind.Witness, String&gt; emptyString = optionalMonad.map(intToString, emptyNumber);
   // OPTIONAL.narrow(emptyString) would be Optional.empty()

   Function&lt;Integer, String&gt; intToNull = i -&gt; null;
   Kind&lt;OptionalKind.Witness, String&gt; mappedToNull = optionalMonad.map(intToNull, presentNumber);
   // OPTIONAL.narrow(mappedToNull) would be Optional.empty()

   System.out.println("Map (Present): " + OPTIONAL.narrow(presentString));
   System.out.println("Map (Empty): " + OPTIONAL.narrow(emptyString));
   System.out.println("Map (To Null): " + OPTIONAL.narrow(mappedToNull));
}
</code></pre>
</div>
</div>
<div id="admonition-example-_flatmapfunction-f-kind-ma_" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-_flatmapfunction-f-kind-ma_-title">
<div class="admonition-title">
<div id="admonition-example-_flatmapfunction-f-kind-ma_-title">
<p>Example: <em>flatMap(Function&lt;A, Kind&lt;OptionalKind.Witness, B&gt;&gt; f, Kind&lt;OptionalKind.Witness, A&gt; ma)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/optional_monad.html#admonition-example-_flatmapfunction-f-kind-ma_"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/optional/OptionalExample.java">OptionalExample.java</a></li>
</ul>
<p>Applies a function <code>f</code> to the value inside <code>ma</code> if it's present. The function <code>f</code> itself returns an <code>OptionalKind&lt;B&gt;</code>. If <code>ma</code> is empty, or if <code>f</code> returns an empty <code>OptionalKind</code>, the result is an empty <code>OptionalKind</code>.</p>
<pre><code class="language-java">public void flatMapExample() {
   OptionalMonad optionalMonad = OptionalMonad.INSTANCE;
   OptionalKind&lt;String&gt; presentInput = OPTIONAL.widen(Optional.of("5"));
   OptionalKind&lt;String&gt; emptyInput = OPTIONAL.widen(Optional.empty());

   Function&lt;String, Kind&lt;OptionalKind.Witness, Integer&gt;&gt; parseToIntKind = s -&gt; {
      try {
         return OPTIONAL.widen(Optional.of(Integer.parseInt(s)));
      } catch (NumberFormatException e) {
         return OPTIONAL.widen(Optional.empty());
      }
   };

   Kind&lt;OptionalKind.Witness, Integer&gt; parsedPresent = optionalMonad.flatMap(parseToIntKind, presentInput);
   // OPTIONAL.narrow(parsedPresent) would be Optional.of(5)

   Kind&lt;OptionalKind.Witness, Integer&gt; parsedEmpty = optionalMonad.flatMap(parseToIntKind, emptyInput);
   // OPTIONAL.narrow(parsedEmpty) would be Optional.empty()

   OptionalKind&lt;String&gt; nonNumericInput = OPTIONAL.widen(Optional.of("abc"));
   Kind&lt;OptionalKind.Witness, Integer&gt; parsedNonNumeric = optionalMonad.flatMap(parseToIntKind, nonNumericInput);
   // OPTIONAL.narrow(parsedNonNumeric) would be Optional.empty()

   System.out.println("FlatMap (Present): " + OPTIONAL.narrow(parsedPresent));
   System.out.println("FlatMap (Empty Input): " + OPTIONAL.narrow(parsedEmpty));
   System.out.println("FlatMap (Non-numeric): " + OPTIONAL.narrow(parsedNonNumeric));
}
</code></pre>
</div>
</div>
<div id="admonition-example-_apkind-ff-kind-fa_" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-_apkind-ff-kind-fa_-title">
<div class="admonition-title">
<div id="admonition-example-_apkind-ff-kind-fa_-title">
<p>Example: <em>ap(Kind&lt;OptionalKind.Witness, Function&lt;A, B&gt;&gt; ff, Kind&lt;OptionalKind.Witness, A&gt; fa)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/optional_monad.html#admonition-example-_apkind-ff-kind-fa_"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/optional/OptionalExample.java">OptionalExample.java</a></li>
</ul>
<p>Applies an <code>OptionalKind</code> containing a function <code>ff</code> to an <code>OptionalKind</code> containing a value <code>fa</code>. If both are present, the function is applied. Otherwise, the result is empty.</p>
<pre><code class="language-java"> public void apExample() {
   OptionalMonad optionalMonad = OptionalMonad.INSTANCE;

   OptionalKind&lt;Function&lt;Integer, String&gt;&gt; presentFuncKind =
           OPTIONAL.widen(Optional.of(i -&gt; "Value: " + i));
   OptionalKind&lt;Function&lt;Integer, String&gt;&gt; emptyFuncKind =
           OPTIONAL.widen(Optional.empty());

   OptionalKind&lt;Integer&gt; presentValueKind = OPTIONAL.widen(Optional.of(100));
   OptionalKind&lt;Integer&gt; emptyValueKind = OPTIONAL.widen(Optional.empty());

   // Both present
   Kind&lt;OptionalKind.Witness, String&gt; result1 = optionalMonad.ap(presentFuncKind, presentValueKind);
   // OPTIONAL.narrow(result1) is Optional.of("Value: 100")

   // Function empty
   Kind&lt;OptionalKind.Witness, String&gt; result2 = optionalMonad.ap(emptyFuncKind, presentValueKind);
   // OPTIONAL.narrow(result2) is Optional.empty()

   // Value empty
   Kind&lt;OptionalKind.Witness, String&gt; result3 = optionalMonad.ap(presentFuncKind, emptyValueKind);
   // OPTIONAL.narrow(result3) is Optional.empty()

   System.out.println("Ap (Both Present): " + OPTIONAL.narrow(result1));
   System.out.println("Ap (Function Empty): " + OPTIONAL.narrow(result2));
   System.out.println("Ap (Value Empty): " + OPTIONAL.narrow(result3));
}

</code></pre>
</div>
</div>
<div id="admonition-example-handleerrorwithkind-ma-function-handler" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-handleerrorwithkind-ma-function-handler-title">
<div class="admonition-title">
<div id="admonition-example-handleerrorwithkind-ma-function-handler-title">
<p>Example: handleErrorWith(Kind&lt;OptionalKind.Witness, A&gt; ma, Function&lt;Unit, Kind&lt;OptionalKind.Witness, A&gt;&gt; handler)</p>
</div>
<a class="admonition-anchor-link" href="monads/optional_monad.html#admonition-example-handleerrorwithkind-ma-function-handler"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/optional/OptionalExample.java">OptionalExample.java</a></li>
</ul>
<p>If <code>ma</code> is present, it's returned. If <code>ma</code> is empty (the "error" state), the <code>handler</code> function is invoked (with <code>Unit.INSTANCE</code> as the <code>Unit</code> argument) to provide a recovery <code>OptionalKind</code>.</p>
<pre><code class="language-java">public void handleErrorWithExample() {
   OptionalMonad optionalMonad = OptionalMonad.INSTANCE;

   Kind&lt;OptionalKind.Witness, String&gt; presentKind = OPTIONAL.widen(Optional.of("Exists"));
   OptionalKind&lt;String&gt; emptyKind = OPTIONAL.widen(Optional.empty());

   Function&lt;Unit, Kind&lt;OptionalKind.Witness, String&gt;&gt; recoveryFunction =
           (Unit unitInstance) -&gt; OPTIONAL.widen(Optional.of("Recovered Value"));

   // Handling error on a present OptionalKind
   Kind&lt;OptionalKind.Witness, String&gt; handledPresent =
           optionalMonad.handleErrorWith(presentKind, recoveryFunction);
   // OPTIONAL.narrow(handledPresent) is Optional.of("Exists")

   // Handling error on an empty OptionalKind
   Kind&lt;OptionalKind.Witness, String&gt; handledEmpty =
           optionalMonad.handleErrorWith(emptyKind, recoveryFunction);

   // OPTIONAL.narrow(handledEmpty) is Optional.of("Recovered Value")
   System.out.println("HandleError (Present): " + OPTIONAL.narrow(handledPresent));
   System.out.println("HandleError (Empty): " + OPTIONAL.narrow(handledEmpty));
}
</code></pre>
</div>
</div>
<div id="admonition-example-using-_optionalmonad_" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-using-_optionalmonad_-title">
<div class="admonition-title">
<div id="admonition-example-using-_optionalmonad_-title">
<p>Example: Using <em>OptionalMonad</em></p>
</div>
<a class="admonition-anchor-link" href="monads/optional_monad.html#admonition-example-using-_optionalmonad_"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/optional/OptionalExample.java">OptionalExample.java</a></li>
</ul>
<p>To use <code>OptionalMonad</code> in generic contexts that operate over <code>Kind&lt;F, A&gt;</code>:</p>
<pre><code class="language-java">public void monadExample() {
    OptionalMonad optionalMonad = OptionalMonad.INSTANCE;

    // 1. Create OptionalKind instances
    OptionalKind&lt;Integer&gt; presentIntKind = OPTIONAL.widen(Optional.of(10));
    Kind&lt;OptionalKind.Witness, Integer&gt; emptyIntKind = optionalMonad.raiseError(null); // Creates empty
    
    // 2. Use map
    Function&lt;Integer, String&gt; intToMessage = n -&gt; "Value is " + n;
    Kind&lt;OptionalKind.Witness, String&gt; mappedPresent = optionalMonad.map(intToMessage, presentIntKind);
    Kind&lt;OptionalKind.Witness, String&gt; mappedEmpty = optionalMonad.map(intToMessage, emptyIntKind);
    
    System.out.println("Mapped (Present): " + OPTIONAL.narrow(mappedPresent)); // Optional[Value is 10]
    System.out.println("Mapped (Empty): " + OPTIONAL.narrow(mappedEmpty));   // Optional.empty
    
    // 3. Use flatMap
    Function&lt;Integer, Kind&lt;OptionalKind.Witness, Double&gt;&gt; intToOptionalDouble = n -&gt;
        (n &gt; 0) ? optionalMonad.of(n / 2.0) : optionalMonad.raiseError(null);
    
    Kind&lt;OptionalKind.Witness, Double&gt; flatMappedPresent = optionalMonad.flatMap(intToOptionalDouble, presentIntKind);
    Kind&lt;OptionalKind.Witness, Double&gt; flatMappedEmpty = optionalMonad.flatMap(intToOptionalDouble, emptyIntKind);
    Kind&lt;OptionalKind.Witness, Integer&gt; zeroIntKind = optionalMonad.of(0);
    Kind&lt;OptionalKind.Witness, Double&gt; flatMappedZero = optionalMonad.flatMap(intToOptionalDouble, zeroIntKind);
    
    
    System.out.println("FlatMapped (Present): " + OPTIONAL.narrow(flatMappedPresent)); // Optional[5.0]
    System.out.println("FlatMapped (Empty): " + OPTIONAL.narrow(flatMappedEmpty));     // Optional.empty
    System.out.println("FlatMapped (Zero): " + OPTIONAL.narrow(flatMappedZero));       // Optional.empty
    
    // 4. Use 'of' and 'raiseError' (already shown in creation)
    
    // 5. Use handleErrorWith
    Function&lt;Unit, Kind&lt;OptionalKind.Witness, Integer&gt;&gt; recoverWithDefault =
        v -&gt; optionalMonad.of(-1); // Default value if empty
    
    Kind&lt;OptionalKind.Witness, Integer&gt; recoveredFromEmpty =
        optionalMonad.handleErrorWith(emptyIntKind, recoverWithDefault);
    Kind&lt;OptionalKind.Witness, Integer&gt; notRecoveredFromPresent =
        optionalMonad.handleErrorWith(presentIntKind, recoverWithDefault);
    
    System.out.println("Recovered (from Empty): " + OPTIONAL.narrow(recoveredFromEmpty)); // Optional[-1]
    System.out.println("Recovered (from Present): " + OPTIONAL.narrow(notRecoveredFromPresent)); // Optional[10]
    
    // Unwrap to get back the standard Optional
    Optional&lt;String&gt; finalMappedOptional = OPTIONAL.narrow(mappedPresent);
    System.out.println("Final unwrapped mapped optional: " + finalMappedOptional);
}
</code></pre>
<p>This example demonstrates wrapping <code>Optional</code>s, applying monadic and error-handling operations via <code>OptionalMonad</code>, and unwrapping back to standard <code>Optional</code>s. The <code>MonadError</code> capabilities allow treating absence (<code>Optional.empty</code>) as a recoverable "error" state.</p>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="monads/maybe_monad.html">Maybe</a>
<strong>Next:</strong> <a href="monads/reader_monad.html">Reader</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="the-reader-monad"><a class="header" href="#the-reader-monad">The Reader Monad:</a></h1>
<h2 id="managed-dependencies-and-configuration"><a class="header" href="#managed-dependencies-and-configuration"><em>Managed Dependencies and Configuration</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="monads/reader_monad.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to inject dependencies functionally without passing them everywhere</li>
<li>Building computations that depend on shared configuration or context</li>
<li>Using <code>ask</code> to access the environment and <code>local</code> to modify it</li>
<li>Creating testable code with explicit dependency management</li>
<li>Real-world examples with database connections and API configurations</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code:</p>
</div>
<a class="admonition-anchor-link" href="monads/reader_monad.html#admonition-see-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/reader/ReaderExample.java">ReaderExample.java</a></p>
</div>
</div>
<h2 id="purpose-5"><a class="header" href="#purpose-5">Purpose</a></h2>
<p>The <strong>Reader monad</strong> is a functional programming pattern primarily used for managing dependencies and context propagation in a clean and composable way. Imagine you have multiple functions or components that all need access to some shared, read-only environment, such as:</p>
<ul>
<li>Configuration settings (database URLs, API keys, feature flags).</li>
<li>Shared resources (thread pools, connection managers).</li>
<li>User context (userLogin ID, permissions).</li>
</ul>
<p>Instead of explicitly passing this environment object as an argument to every single function (which can become cumbersome and clutter signatures), the Reader monad encapsulates computations that <em>depend</em> on such an environment.</p>
<p>A <code>Reader&lt;R, A&gt;</code> represents a computation that, when provided with an environment of type <code>R</code>, will produce a value of type <code>A</code>. It essentially wraps a function <code>R -&gt; A</code>.</p>
<p>The benefits of using the Reader monad include:</p>
<ol>
<li><strong>Implicit Dependency Injection:</strong> The environment (<code>R</code>) is implicitly passed along the computation chain. Functions defined within the Reader context automatically get access to the environment when needed, without needing it explicitly in their signature.</li>
<li><strong>Composability:</strong> Reader computations can be easily chained together using standard monadic operations like <code>map</code> and <code>flatMap</code>.</li>
<li><strong>Testability:</strong> Dependencies are managed explicitly when the final Reader computation is run, making it easier to provide mock environments or configurations during testing.</li>
<li><strong>Code Clarity:</strong> Reduces the need to pass configuration objects through multiple layers of functions.</li>
</ol>
<p>In <code>Higher-Kinded-J</code>, the Reader monad pattern is implemented via the <code>Reader&lt;R, A&gt;</code> interface and its corresponding HKT simulation types (<code>ReaderKind</code>, <code>ReaderKindHelper</code>) and type class instances (<code>ReaderMonad</code>, <code>ReaderApplicative</code>, <code>ReaderFunctor</code>).</p>
<h2 id="structure-6"><a class="header" href="#structure-6">Structure</a></h2>
<p><img src="monads/../images/puml/reader_monad.svg" alt="reader_monad.svg" /></p>
<h2 id="the-readerr-a-type"><a class="header" href="#the-readerr-a-type">The <code>Reader&lt;R, A&gt;</code> Type</a></h2>
<p>The core type is the <code>Reader&lt;R, A&gt;</code> functional interface:</p>
<pre><code class="language-java">@FunctionalInterface
public interface Reader&lt;R, A&gt; {
  @Nullable A run(@NonNull R r); // The core function: Environment -&gt; Value

  // Static factories
  static &lt;R, A&gt; @NonNull Reader&lt;R, A&gt; of(@NonNull Function&lt;R, A&gt; runFunction);
  static &lt;R, A&gt; @NonNull Reader&lt;R, A&gt; constant(@Nullable A value);
  static &lt;R&gt; @NonNull Reader&lt;R, R&gt; ask();

  // Instance methods (for composition)
  default &lt;B&gt; @NonNull Reader&lt;R, B&gt; map(@NonNull Function&lt;? super A, ? extends B&gt; f);
  default &lt;B&gt; @NonNull Reader&lt;R, B&gt; flatMap(@NonNull Function&lt;? super A, ? extends Reader&lt;R, ? extends B&gt;&gt; f);
}
</code></pre>
<ul>
<li><code>run(R r)</code>: Executes the computation by providing the environment <code>r</code> and returning the result <code>A</code>.</li>
<li><code>of(Function&lt;R, A&gt;)</code>: Creates a <code>Reader</code> from a given function.</li>
<li><code>constant(A value)</code>: Creates a <code>Reader</code> that ignores the environment and always returns the provided value.</li>
<li><code>ask()</code>: Creates a <code>Reader</code> that simply returns the environment itself as the result.</li>
<li><code>map(Function&lt;A, B&gt;)</code>: Transforms the result <code>A</code> to <code>B</code><em>after</em> the reader is run, without affecting the required environment <code>R</code>.</li>
<li><code>flatMap(Function&lt;A, Reader&lt;R, B&gt;&gt;)</code>: Sequences computations. It runs the first reader, uses its result <code>A</code> to create a <em>second</em> reader (<code>Reader&lt;R, B&gt;</code>), and then runs that second reader with the <em>original</em> environment <code>R</code>.</li>
</ul>
<h2 id="reader-components"><a class="header" href="#reader-components">Reader Components</a></h2>
<p>To integrate <code>Reader</code> with Higher-Kinded-J:</p>
<ul>
<li><strong><code>ReaderKind&lt;R, A&gt;</code>:</strong> The marker interface extending <code>Kind&lt;ReaderKind.Witness&lt;R&gt;, A&gt;</code>. The witness type <code>F</code> is <code>ReaderKind.Witness&lt;R&gt;</code> (where <code>R</code> is fixed for a given monad instance), and the value type <code>A</code> is the result type of the reader.</li>
<li><strong><code>ReaderKindHelper</code>:</strong> The utility class with static methods:
<ul>
<li><code>widen(Reader&lt;R, A&gt;)</code>: Converts a <code>Reader</code> to <code>ReaderKind&lt;R, A&gt;</code>.</li>
<li><code>narrow(Kind&lt;ReaderKind.Witness&lt;R&gt;, A&gt;)</code>: Converts <code>ReaderKind</code> back to <code>Reader</code>. Throws <code>KindUnwrapException</code> if the input is invalid.</li>
<li><code>reader(Function&lt;R, A&gt;)</code>: Factory method to create a <code>ReaderKind</code> from a function.</li>
<li><code>constant(A value)</code>: Factory method for a <code>ReaderKind</code> returning a constant value.</li>
<li><code>ask()</code>: Factory method for a <code>ReaderKind</code> that returns the environment.</li>
<li><code>runReader(Kind&lt;ReaderKind.Witness&lt;R&gt;, A&gt; kind, R environment)</code>: The primary way to execute a <code>ReaderKind</code> computation by providing the environment.</li>
</ul>
</li>
</ul>
<h2 id="type-class-instances-readerfunctor-readerapplicative-readermonad"><a class="header" href="#type-class-instances-readerfunctor-readerapplicative-readermonad">Type Class Instances (<code>ReaderFunctor</code>, <code>ReaderApplicative</code>, <code>ReaderMonad</code>)</a></h2>
<p>These classes provide the standard functional operations for <code>ReaderKind.Witness&lt;R&gt;</code>, allowing you to treat <code>Reader</code> computations generically within Higher-Kinded-J:</p>
<ul>
<li><strong><code>ReaderFunctor&lt;R&gt;</code>:</strong> Implements <code>Functor&lt;ReaderKind.Witness&lt;R&gt;&gt;</code>. Provides the <code>map</code> operation.</li>
<li><strong><code>ReaderApplicative&lt;R&gt;</code>:</strong> Extends <code>ReaderFunctor&lt;R&gt;</code> and implements <code>Applicative&lt;ReaderKind.Witness&lt;R&gt;&gt;</code>. Provides <code>of</code> (lifting a value) and <code>ap</code> (applying a wrapped function to a wrapped value).</li>
<li><strong><code>ReaderMonad&lt;R&gt;</code>:</strong> Extends <code>ReaderApplicative&lt;R&gt;</code> and implements <code>Monad&lt;ReaderKind.Witness&lt;R&gt;&gt;</code>. Provides <code>flatMap</code> for sequencing computations that depend on previous results while implicitly carrying the environment <code>R</code>.</li>
</ul>
<p>You typically instantiate <code>ReaderMonad&lt;R&gt;</code> for the specific environment type <code>R</code> you are working with.</p>
<div id="admonition-example-managing-configuration" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-managing-configuration-title">
<div class="admonition-title">
<div id="admonition-example-managing-configuration-title">
<p>Example: Managing Configuration</p>
</div>
<a class="admonition-anchor-link" href="monads/reader_monad.html#admonition-example-managing-configuration"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/reader/ReaderExample.java">ReaderExample.java</a></li>
</ul>
<h3 id="1-define-your-environment"><a class="header" href="#1-define-your-environment">1. Define Your Environment</a></h3>
<pre><code class="language-java">// Example Environment: Application Configuration
record AppConfig(String databaseUrl, int timeoutMillis, String apiKey) {}
</code></pre>
<h3 id="2-create-reader-computations"><a class="header" href="#2-create-reader-computations">2. Create Reader Computations</a></h3>
<p>Use <code>ReaderKindHelper</code> factory methods:</p>
<pre><code class="language-java">import static org.higherkindedj.hkt.reader.ReaderKindHelper.*;

import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.reader.ReaderKind;

// Reader that retrieves the database URL from the config
Kind&lt;ReaderKind.Witness&lt;AppConfig&gt;, String&gt; getDbUrl = reader(AppConfig::databaseUrl);

// Reader that retrieves the timeout
Kind&lt;ReaderKind.Witness&lt;AppConfig&gt;, Integer&gt; getTimeout = reader(AppConfig::timeoutMillis);

// Reader that returns a constant value, ignoring the environment
Kind&lt;ReaderKind.Witness&lt;AppConfig&gt;, String&gt; getDefaultUser = constant("guest");

// Reader that returns the entire configuration environment
Kind&lt;ReaderKind.Witness&lt;AppConfig&gt;, AppConfig&gt; getConfig = ask();
</code></pre>
<h3 id="3-get-the-readermonad-instance"><a class="header" href="#3-get-the-readermonad-instance">3. Get the <code>ReaderMonad</code> Instance</a></h3>
<p>Instantiate the monad for your specific environment type <code>R</code>.</p>
<pre><code class="language-java">import org.higherkindedj.hkt.reader.ReaderMonad;

// Monad instance for computations depending on AppConfig
ReaderMonad&lt;AppConfig&gt; readerMonad = new ReaderMonad&lt;&gt;();
</code></pre>
<h3 id="4-compose-computations-using-map-and-flatmap"><a class="header" href="#4-compose-computations-using-map-and-flatmap">4. Compose Computations using <code>map</code> and <code>flatMap</code></a></h3>
<p>Use the methods on the <code>readerMonad</code> instance.</p>
<pre><code class="language-java">// Example 1: Map the timeout value
Kind&lt;ReaderKind.Witness&lt;AppConfig&gt;, String&gt; timeoutMessage = readerMonad.map(
    timeout -&gt; "Timeout is: " + timeout + "ms",
    getTimeout // Input: Kind&lt;ReaderKind.Witness&lt;AppConfig&gt;, Integer&gt;
);

// Example 2: Use flatMap to get DB URL and then construct a connection string (depends on URL)
Function&lt;String, Kind&lt;ReaderKind.Witness&lt;AppConfig&gt;, String&gt;&gt; buildConnectionString =
    dbUrl -&gt; reader( // &lt;- We return a new Reader computation
        config -&gt; dbUrl + "?apiKey=" + config.apiKey() // Access apiKey via the 'config' env
    );

Kind&lt;ReaderKind.Witness&lt;AppConfig&gt;, String&gt; connectionStringReader = readerMonad.flatMap(
    buildConnectionString, // Function: String -&gt; Kind&lt;ReaderKind.Witness&lt;AppConfig&gt;, String&gt;
    getDbUrl               // Input: Kind&lt;ReaderKind.Witness&lt;AppConfig&gt;, String&gt;
);

// Example 3: Combine multiple values using mapN (from Applicative)
Kind&lt;ReaderKind.Witness&lt;AppConfig&gt;, String&gt; dbInfo = readerMonad.map2(
    getDbUrl,
    getTimeout,
    (url, timeout) -&gt; "DB: " + url + " (Timeout: " + timeout + ")"
);
</code></pre>
<h3 id="5-run-the-computation"><a class="header" href="#5-run-the-computation">5. Run the Computation</a></h3>
<p>Provide the actual environment using <code>ReaderKindHelper.runReader</code>:</p>
<pre><code class="language-java">AppConfig productionConfig = new AppConfig("prod-db.example.com", 5000, "prod-key-123");
AppConfig stagingConfig = new AppConfig("stage-db.example.com", 10000, "stage-key-456");

// Run the composed computations with different environments
String prodTimeoutMsg = runReader(timeoutMessage, productionConfig);
String stageTimeoutMsg = runReader(timeoutMessage, stagingConfig);

String prodConnectionString = runReader(connectionStringReader, productionConfig);
String stageConnectionString = runReader(connectionStringReader, stagingConfig);

String prodDbInfo = runReader(dbInfo, productionConfig);
String stageDbInfo = runReader(dbInfo, stagingConfig);

// Get the raw config using ask()
AppConfig retrievedProdConfig = runReader(getConfig, productionConfig);


System.out.println("Prod Timeout: " + prodTimeoutMsg);           // Output: Timeout is: 5000ms
System.out.println("Stage Timeout: " + stageTimeoutMsg);         // Output: Timeout is: 10000ms
System.out.println("Prod Connection: " + prodConnectionString); // Output: prod-db.example.com?apiKey=prod-key-123
System.out.println("Stage Connection: " + stageConnectionString);// Output: stage-db.example.com?apiKey=stage-key-456
System.out.println("Prod DB Info: " + prodDbInfo);               // Output: DB: prod-db.example.com (Timeout: 5000)
System.out.println("Stage DB Info: " + stageDbInfo);             // Output: DB: stage-db.example.com (Timeout: 10000)
System.out.println("Retrieved Prod Config: " + retrievedProdConfig); // Output: AppConfig[databaseUrl=prod-db.example.com, timeoutMillis=5000, apiKey=prod-key-123]
</code></pre>
<p>Notice how the functions (<code>buildConnectionString</code>, the lambda in <code>map2</code>) don't need <code>AppConfig</code> as a parameter, but they can access it when needed within the <code>reader(...)</code> factory or implicitly via <code>flatMap</code> composition. The configuration is only provided once at the end when <code>runReader</code> is called.</p>
</div>
</div>
<div id="admonition-example-reader-for-side-effects-returning-unit" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-reader-for-side-effects-returning-unit-title">
<div class="admonition-title">
<div id="admonition-example-reader-for-side-effects-returning-unit-title">
<p>Example: Reader for Side-Effects (Returning Unit)</p>
</div>
<a class="admonition-anchor-link" href="monads/reader_monad.html#admonition-example-reader-for-side-effects-returning-unit"></a>
</div>
<div>
<p>Sometimes, a computation depending on an environment <code>R</code> might perform an action (like logging or initialising a component based on <code>R</code>) but doesn't produce a specific value other than signaling its completion. In such cases, the result type <code>A</code> of the <code>Reader&lt;R, A&gt;</code> can be <code>org.higherkindedj.hkt.Unit</code>.</p>
<pre><code class="language-java">import static org.higherkindedj.hkt.reader.ReaderKindHelper.*;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.reader.ReaderKind;
import org.higherkindedj.hkt.reader.ReaderMonad;
import org.higherkindedj.hkt.Unit; // Import Unit

// Assume AppConfig is defined as before
// record AppConfig(String databaseUrl, int timeoutMillis, String apiKey) {}

// ReaderMonad instance (can be the same as before)
// ReaderMonad&lt;AppConfig&gt; readerMonad = new ReaderMonad&lt;&gt;();

// A Reader computation that performs a side-effect (printing to console)
// using the config and returns Unit.
Kind&lt;ReaderKind.Witness&lt;AppConfig&gt;, Unit&gt; logApiKey = reader(
    config -&gt; {
        System.out.println("Accessed API Key: " + config.apiKey().substring(0, Math.min(config.apiKey().length(), 4)) + "...");
        return Unit.INSTANCE; // Explicitly return Unit.INSTANCE
    }
);

// You can compose this with other Reader computations.
// For example, get the DB URL and then log the API key.
Kind&lt;ReaderKind.Witness&lt;AppConfig&gt;, Unit&gt; getUrlAndLogKey = readerMonad.flatMap(
    dbUrl -&gt; {
        System.out.println("Database URL for logging context: " + dbUrl);
        // After processing dbUrl (here, just printing), return the next action
        return logApiKey;
    },
    getDbUrl // Assuming getDbUrl: Kind&lt;ReaderKind.Witness&lt;AppConfig&gt;, String&gt;
);


// To run it:
// AppConfig currentConfig = new AppConfig("prod-db.example.com", 5000, "prod-key-123");
// Unit result = runReader(logApiKey, currentConfig);
// System.out.println("Log API Key result: " + result); // Output: Log API Key result: ()

// Unit resultChained = runReader(getUrlAndLogKey, currentConfig);
// System.out.println("Get URL and Log Key result: " + resultChained);
// Output:
// Database URL for logging context: prod-db.example.com
// Accessed API Key: prod...
// Get URL and Log Key result: ()
</code></pre>
<p>In this example:</p>
<ul>
<li><code>logApiKey</code> is a <code>Reader&lt;AppConfig, Unit&gt;</code>. Its purpose is to perform an action (logging) using the <code>AppConfig</code>.</li>
<li>It returns <code>Unit.INSTANCE</code> to signify that the action completed successfully but yields no other specific data.</li>
<li>When composing, flatMap can be used to sequence such an action. If logApiKey were the last step in a sequence, the overall <code>flatMap</code> chain would also result in <code>Kind&lt;ReaderKind.Witness&lt;AppConfig&gt;, Unit&gt;</code>.</li>
</ul>
</div>
</div>
<div id="admonition-key-points" class="admonition admonish-tip" role="note" aria-labelledby="admonition-key-points-title">
<div class="admonition-title">
<div id="admonition-key-points-title">
<p>Key Points:</p>
</div>
<a class="admonition-anchor-link" href="monads/reader_monad.html#admonition-key-points"></a>
</div>
<div>
<p>The Reader monad (<code>Reader&lt;R, A&gt;</code>, <code>ReaderKind</code>, <code>ReaderMonad</code>) in <code>Higher-Kinded-J</code> provides a functional approach to dependency injection and configuration management.</p>
<p>It allows you to define computations that depend on a read-only environment <code>R</code> without explicitly passing <code>R</code> everywhere. By using Higher-Kinded-J and the <code>ReaderMonad</code>, you can compose these dependent functions cleanly using <code>map</code> and <code>flatMap</code>, providing the actual environment only once when the final computation is executed via <code>runReader</code>.</p>
<p>This leads to more modular, testable, and less cluttered code when dealing with shared context.</p>
</div>
</div>
<div id="admonition-further-reading" class="admonition admonish-tip" role="note" aria-labelledby="admonition-further-reading-title">
<div class="admonition-title">
<div id="admonition-further-reading-title">
<p>Further Reading</p>
</div>
<a class="admonition-anchor-link" href="monads/reader_monad.html#admonition-further-reading"></a>
</div>
<div>
<p>For deeper exploration of the Reader monad and dependency injection patterns:</p>
<p><strong>Foundational Resources:</strong></p>
<ul>
<li><strong>Cats Documentation</strong>: <a href="https://typelevel.org/cats/datatypes/reader.html">Reader Monad</a> - Scala implementation with practical examples</li>
<li><strong>Haskell Wiki</strong>: <a href="https://wiki.haskell.org/All_About_Monads#The_Reader_monad">Reader Monad</a> - Theoretical foundation and use cases</li>
<li><strong>Mark Seemann</strong>: <a href="https://blog.ploeh.dk/2017/01/27/from-dependency-injection-to-dependency-rejection/">Dependency Injection Revisited</a> - Functional alternatives to traditional DI</li>
</ul>
<p><strong>Java-Focused Resources:</strong></p>
<ul>
<li><strong>Functional Java</strong>: <a href="https://github.com/functionaljava/functionaljava">GitHub repository</a> - Pure functional library for Java with Reader monad</li>
<li><strong>Richard Warburton</strong>: "Java 8 Lambdas" (O'Reilly, 2014) - Functional programming fundamentals in Java</li>
<li><strong>Pierre-Yves Saumont</strong>: "Functional Programming in Java" (Manning, 2017) - Chapter on handling dependencies functionally</li>
</ul>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="monads/optional_monad.html">Optional</a>
<strong>Next:</strong> <a href="monads/state_monad.html">State</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="the-state-monad-1"><a class="header" href="#the-state-monad-1">The State Monad:</a></h1>
<h2 id="managing-state-functionally"><a class="header" href="#managing-state-functionally"><em>Managing State Functionally</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="monads/state_monad.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to manage state functionally without mutable variables</li>
<li>Using <code>get</code>, <code>set</code>, <code>modify</code>, and <code>inspect</code> for state operations</li>
<li>Building complex stateful workflows with automatic state threading</li>
<li>Creating a bank account simulation with transaction history</li>
<li>Why pure state management leads to more testable and maintainable code</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code:</p>
</div>
<a class="admonition-anchor-link" href="monads/state_monad.html#admonition-see-example-code"></a>
</div>
<div>
<ul>
<li>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/state/StateExample.java">StateExample</a></p>
</li>
<li>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/state/BankAccountWorkflow.java">BankAccountWorkflow.java</a></p>
</li>
</ul>
</div>
</div>
<h2 id="purpose-6"><a class="header" href="#purpose-6">Purpose</a></h2>
<p>State is everywhere in programming: counters increment, configurations update, game characters level up. Yet managing state functionally, without mutation, often feels like fighting the paradigm. The State monad resolves this tension elegantly.</p>
<p>In many applications, we need to manage computations that involve <strong>state</strong> that changes over time.</p>
<p>Examples include:</p>
<ul>
<li>A counter being incremented.</li>
<li>A configuration object being updated.</li>
<li>The state of a game character.</li>
<li>Parsing input where the current position needs to be tracked.</li>
</ul>
<p>While imperative programming uses mutable variables, functional programming prefers immutability. The <strong>State monad</strong> provides a purely functional way to handle stateful computations without relying on mutable variables.</p>
<p>A <code>State&lt;S, A&gt;</code> represents a computation that takes an initial state <code>S</code> and produces a result value <code>A</code> along with a <strong>new, updated state</strong> <code>S</code>. It essentially wraps a function of the type <code>S -&gt; (A, S)</code>.</p>
<h3 id="key-benefits"><a class="header" href="#key-benefits">Key Benefits</a></h3>
<ol>
<li><strong>Explicit State:</strong> The state manipulation is explicitly encoded within the type <code>State&lt;S, A&gt;</code>.</li>
<li><strong>Purity:</strong> Functions using the State monad remain pure; they don't cause side effects by mutating external state. Instead, they describe how the state <em>should</em> transform.</li>
<li><strong>Composability:</strong> State computations can be easily sequenced using standard monadic operations (<code>map</code>, <code>flatMap</code>), where the state is automatically threaded through the sequence without explicitly threading state everywhere.</li>
<li><strong>Decoupling</strong>: Logic is decoupled from state handling mechanics.</li>
<li><strong>Testability:</strong> Pure state transitions are easier to test and reason about than code relying on mutable side effects.</li>
</ol>
<p>In <code>Higher-Kinded-J</code>, the State monad pattern is implemented via the <code>State&lt;S, A&gt;</code> interface, its associated <code>StateTuple&lt;S, A&gt;</code> record, the HKT simulation types (<code>StateKind</code>, <code>StateKindHelper</code>), and the type class instances (<code>StateMonad</code>, <code>StateApplicative</code>, <code>StateFunctor</code>).</p>
<h2 id="structure-7"><a class="header" href="#structure-7">Structure</a></h2>
<p><img src="monads/../images/puml/state_monad.svg" alt="state_monad.svg" /></p>
<h2 id="the-states-a-type-and-statetuples-a"><a class="header" href="#the-states-a-type-and-statetuples-a">The <code>State&lt;S, A&gt;</code> Type and <code>StateTuple&lt;S, A&gt;</code></a></h2>
<p>The core type is the <code>State&lt;S, A&gt;</code> functional interface:</p>
<pre><code class="language-java">@FunctionalInterface
public interface State&lt;S, A&gt; {

  // Represents the result: final value A and final state S
  record StateTuple&lt;S, A&gt;(@Nullable A value, @NonNull S state) { /* ... */ }

  // The core function: Initial State -&gt; (Result Value, Final State)
  @NonNull StateTuple&lt;S, A&gt; run(@NonNull S initialState);

  // Static factories
  static &lt;S, A&gt; @NonNull State&lt;S, A&gt; of(@NonNull Function&lt;@NonNull S, @NonNull StateTuple&lt;S, A&gt;&gt; runFunction);
  static &lt;S, A&gt; @NonNull State&lt;S, A&gt; pure(@Nullable A value); // Creates State(s -&gt; (value, s))
  static &lt;S&gt; @NonNull State&lt;S, S&gt; get();                      // Creates State(s -&gt; (s, s))
  static &lt;S&gt; @NonNull State&lt;S, Unit&gt; set(@NonNull S newState); // Creates State(s -&gt; (Unit.INSTANCE, newState))
  static &lt;S&gt; @NonNull State&lt;S, Unit&gt; modify(@NonNull Function&lt;@NonNull S, @NonNull S&gt; f); // Creates State(s -&gt; (Unit.INSTANCE, f(s)))
  static &lt;S, A&gt; @NonNull State&lt;S, A&gt; inspect(@NonNull Function&lt;@NonNull S, @Nullable A&gt; f); // Creates State(s -&gt; (f(s), s))

  // Instance methods for composition
  default &lt;B&gt; @NonNull State&lt;S, B&gt; map(@NonNull Function&lt;? super A, ? extends B&gt; f);
  default &lt;B&gt; @NonNull State&lt;S, B&gt; flatMap(@NonNull Function&lt;? super A, ? extends State&lt;S, ? extends B&gt;&gt; f);
}
</code></pre>
<ul>
<li><code>StateTuple&lt;S, A&gt;</code>: A simple record holding the pair <code>(value: A, state: S)</code> returned by running a <code>State</code> computation.</li>
<li><code>run(S initialState)</code>: Executes the stateful computation by providing the starting state.</li>
<li><code>of(...)</code>: The basic factory method taking the underlying function <code>S -&gt; StateTuple&lt;S, A&gt;</code>.</li>
<li><code>pure(A value)</code>: Creates a computation that returns the given value <code>A</code><em>without changing</em> the state.</li>
<li><code>get()</code>: Creates a computation that returns the <em>current</em> state <code>S</code> as its value, leaving the state unchanged.</li>
<li><code>set(S newState)</code>: Creates a computation that <em>replaces</em> the current state with <code>newState</code> and returns <code>Unit.INSTANCE</code> as its result value.</li>
<li><code>modify(Function&lt;S, S&gt; f)</code>: Creates a computation that applies a function <code>f</code> to the current state to get the <em>new</em> state, returning Unit.INSTANCE as its result value.</li>
<li><code>inspect(Function&lt;S, A&gt; f)</code>: Creates a computation that applies a function <code>f</code> to the current state to calculate a <em>result value</em><code>A</code>, leaving the state unchanged.</li>
<li><code>map(...)</code>: Transforms the <em>result value</em><code>A</code> to <code>B</code> after the computation runs, leaving the state transition logic untouched.</li>
<li><code>flatMap(...)</code>: The core sequencing operation. It runs the first <code>State</code> computation, takes its result value <code>A</code>, uses it to create a <em>second</em><code>State</code> computation, and runs that second computation using the state produced by the first one. The final result and state are those from the second computation.</li>
</ul>
<h2 id="state-components"><a class="header" href="#state-components">State Components</a></h2>
<p>To integrate <code>State</code> with Higher-Kinded-J:</p>
<ul>
<li><strong><code>StateKind&lt;S, A&gt;</code>:</strong> The marker interface extending <code>Kind&lt;StateKind.Witness&lt;S&gt;, A&gt;</code>. The witness type <code>F</code> is <code>StateKind.Witness&lt;S&gt;</code> (where <code>S</code> is fixed for a given monad instance), and the value type <code>A</code> is the result type <code>A</code> from <code>StateTuple</code>.</li>
<li><strong><code>StateKindHelper</code>:</strong> The utility class with static methods:
<ul>
<li><code>widen(State&lt;S, A&gt;)</code>: Converts a <code>State</code> to <code>Kind&lt;StateKind.Witness&lt;S&gt;, A&gt;</code>.</li>
<li><code>narrow(Kind&lt;StateKind.Witness&lt;S&gt;, A&gt;)</code>: Converts <code>StateKind</code> back to <code>State</code>. Throws <code>KindUnwrapException</code> if the input is invalid.</li>
<li><code>pure(A value)</code>: Factory for <code>Kind</code> equivalent to <code>State.pure</code>.</li>
<li><code>get()</code>: Factory for <code>Kind</code> equivalent to <code>State.get</code>.</li>
<li><code>set(S newState)</code>: Factory for <code>Kind</code> equivalent to <code>State.set</code>.</li>
<li><code>modify(Function&lt;S, S&gt; f)</code>: Factory for <code>Kind</code> equivalent to <code>State.modify</code>.</li>
<li><code>inspect(Function&lt;S, A&gt; f)</code>: Factory for <code>Kind</code> equivalent to <code>State.inspect</code>.</li>
<li><code>runState(Kind&lt;StateKind.Witness&lt;S&gt;, A&gt; kind, S initialState)</code>: Runs the computation and returns the <code>StateTuple&lt;S, A&gt;</code>.</li>
<li><code>evalState(Kind&lt;StateKind.Witness&lt;S&gt;, A&gt; kind, S initialState)</code>: Runs the computation and returns only the final value <code>A</code>.</li>
<li><code>execState(Kind&lt;StateKind.Witness&lt;S&gt;, A&gt; kind, S initialState)</code>: Runs the computation and returns only the final state <code>S</code>.</li>
</ul>
</li>
</ul>
<h2 id="type-class-instances-statefunctor-stateapplicative-statemonad"><a class="header" href="#type-class-instances-statefunctor-stateapplicative-statemonad">Type Class Instances (<code>StateFunctor</code>, <code>StateApplicative</code>, <code>StateMonad</code>)</a></h2>
<p>These classes provide the standard functional operations for <code>StateKind.Witness&lt;S&gt;</code>:</p>
<ul>
<li><strong><code>StateFunctor&lt;S&gt;</code>:</strong> Implements <code>Functor&lt;StateKind.Witness&lt;S&gt;&gt;</code>. Provides <code>map</code>.</li>
<li><strong><code>StateApplicative&lt;S&gt;</code>:</strong> Extends <code>StateFunctor&lt;S&gt;</code>, implements <code>Applicative&lt;StateKind.Witness&lt;S&gt;&gt;</code>. Provides <code>of</code> (same as <code>pure</code>) and <code>ap</code>.</li>
<li><strong><code>StateMonad&lt;S&gt;</code>:</strong> Extends <code>StateApplicative&lt;S&gt;</code>, implements <code>Monad&lt;StateKind.Witness&lt;S&gt;&gt;</code>. Provides <code>flatMap</code> for sequencing stateful computations.</li>
</ul>
<p>You instantiate <code>StateMonad&lt;S&gt;</code> for the specific state type <code>S</code> you are working with.</p>
<div id="admonition-example-managing-bank-account-transactions" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-managing-bank-account-transactions-title">
<div class="admonition-title">
<div id="admonition-example-managing-bank-account-transactions-title">
<p>Example: Managing Bank Account Transactions</p>
</div>
<a class="admonition-anchor-link" href="monads/state_monad.html#admonition-example-managing-bank-account-transactions"></a>
</div>
<div>
<p>We want to model a bank account where we can:</p>
<ul>
<li>Deposit funds.</li>
<li>Withdraw funds (if sufficient balance).</li>
<li>Get the current balance.</li>
<li>Get the transaction history.</li>
</ul>
<p>All these operations will affect or depend on the account's state (balance and history).</p>
<h2 id="1-define-the-state"><a class="header" href="#1-define-the-state">1. Define the State</a></h2>
<p>First, we define a record to represent the state of our bank account.</p>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/state/AccountState.java">AccountState.java</a></li>
</ul>
<pre><code class="language-java">public record AccountState(BigDecimal balance, List&lt;Transaction&gt; history) {
  public AccountState {
    requireNonNull(balance, "Balance cannot be null.");
    requireNonNull(history, "History cannot be null.");
    // Ensure history is unmodifiable and a defensive copy is made.
    history = Collections.unmodifiableList(new ArrayList&lt;&gt;(history));
  }

  // Convenience constructor for initial state
  public static AccountState initial(BigDecimal initialBalance) {
    requireNonNull(initialBalance, "Initial balance cannot be null");
    if (initialBalance.compareTo(BigDecimal.ZERO) &lt; 0) {
      throw new IllegalArgumentException("Initial balance cannot be negative.");
    }
    Transaction initialTx = new Transaction(
            TransactionType.INITIAL_BALANCE,
            initialBalance,
            LocalDateTime.now(),
            "Initial account balance"
    );
    // The history now starts with this initial transaction
    return new AccountState(initialBalance, Collections.singletonList(initialTx));
  }

  public AccountState addTransaction(Transaction transaction) {
    requireNonNull(transaction, "Transaction cannot be null");
    List&lt;Transaction&gt; newHistory = new ArrayList&lt;&gt;(history); // Takes current history
    newHistory.add(transaction);                             // Adds new one
    return new AccountState(this.balance, Collections.unmodifiableList(newHistory));
  }

  public AccountState withBalance(BigDecimal newBalance) {
    requireNonNull(newBalance, "New balance cannot be null");
    return new AccountState(newBalance, this.history);
  }
}
</code></pre>
<h3 id="2-define-transaction-types"><a class="header" href="#2-define-transaction-types">2. Define Transaction Types</a></h3>
<p>We'll also need a way to represent transactions.</p>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/state/TransactionType.java">TransactionType.java</a></li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/state/Transaction.java">Transaction.java</a></li>
</ul>
<pre><code class="language-java">public enum TransactionType {
  INITIAL_BALANCE,
  DEPOSIT,
  WITHDRAWAL,
  REJECTED_WITHDRAWAL,
  REJECTED_DEPOSIT
}

public record Transaction(
        TransactionType type, BigDecimal amount, LocalDateTime timestamp, String description) {
  public Transaction {
    requireNonNull(type, "Transaction type cannot be null");
    requireNonNull(amount, "Transaction amount cannot be null");
    requireNonNull(timestamp, "Transaction timestamp cannot be null");
    requireNonNull(description, "Transaction description cannot be null");
    if (type != INITIAL_BALANCE &amp;&amp; amount.compareTo(BigDecimal.ZERO) &lt;= 0) {
      if (!(type == REJECTED_DEPOSIT &amp;&amp; amount.compareTo(BigDecimal.ZERO) &lt;= 0)
              &amp;&amp; !(type == REJECTED_WITHDRAWAL &amp;&amp; amount.compareTo(BigDecimal.ZERO) &lt;= 0)) {
        throw new IllegalArgumentException(
                "Transaction amount must be positive for actual operations.");
      }
    }
  }
}
</code></pre>
<h3 id="3-define-state-actions"><a class="header" href="#3-define-state-actions">3. Define State Actions</a></h3>
<p>Now, we define our bank operations as functions that return <code>Kind&lt;StateKind.Witness&lt;AccountState&gt;, YourResultType&gt;</code>.
These actions describe how the state should change and what value they produce.</p>
<p>We'll put these in a <code>BankAccountWorkflow.java class</code>.</p>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/state/BankAccountWorkflow.java">BankAccountWorkflow.java</a></li>
</ul>
<pre><code class="language-java">public class BankAccountWorkflow {

  private static final StateMonad&lt;AccountState&gt; accountStateMonad = new StateMonad&lt;&gt;();

  public static Function&lt;BigDecimal, Kind&lt;StateKind.Witness&lt;AccountState&gt;, Unit&gt;&gt; deposit(
          String description) {
    return amount -&gt;
        STATE.widen(
          State.modify(
            currentState -&gt; {
              if (amount.compareTo(BigDecimal.ZERO) &lt;= 0) {
                // For rejected deposit, log the problematic amount
                Transaction rejected =
                        new Transaction(
                                TransactionType.REJECTED_DEPOSIT,
                                amount,
                                LocalDateTime.now(),
                                "Rejected Deposit: " + description + " - Invalid Amount " + amount);
                return currentState.addTransaction(rejected);
              }
              BigDecimal newBalance = currentState.balance().add(amount);
              Transaction tx =
                      new Transaction(
                              TransactionType.DEPOSIT, amount, LocalDateTime.now(), description);
              return currentState.withBalance(newBalance).addTransaction(tx);
        }));
  }

  public static Function&lt;BigDecimal, Kind&lt;StateKind.Witness&lt;AccountState&gt;, Boolean&gt;&gt; withdraw(
          String description) {
    return amount -&gt;
        STATE.widen(
                State.of(
                    currentState -&gt; {
                      if (amount.compareTo(BigDecimal.ZERO) &lt;= 0) {
                        // For rejected withdrawal due to invalid amount, log the problematic amount
                        Transaction rejected =
                            new Transaction(
                                    TransactionType.REJECTED_WITHDRAWAL,
                                    amount,
                                    LocalDateTime.now(),
                                    "Rejected Withdrawal: " + description + " - Invalid Amount " + amount);
                        return new StateTuple&lt;&gt;(false, currentState.addTransaction(rejected));
                      }
                      if (currentState.balance().compareTo(amount) &gt;= 0) {
                        BigDecimal newBalance = currentState.balance().subtract(amount);
                        Transaction tx =
                                new Transaction(
                                        TransactionType.WITHDRAWAL, amount, LocalDateTime.now(), description);
                        AccountState updatedState =
                                currentState.withBalance(newBalance).addTransaction(tx);
                        return new StateTuple&lt;&gt;(true, updatedState);
                      } else {
                        // For rejected withdrawal due to insufficient funds, log the amount that was
                        // attempted
                        Transaction tx =
                            new Transaction(
                                    TransactionType.REJECTED_WITHDRAWAL,
                                    amount,
                                    LocalDateTime.now(),
                                    "Rejected Withdrawal: "
                                            + description
                                            + " - Insufficient Funds. Balance: "
                                            + currentState.balance());
                        AccountState updatedState = currentState.addTransaction(tx);
                        return new StateTuple&lt;&gt;(false, updatedState);
                      }
                  }));
  }

  public static Kind&lt;StateKind.Witness&lt;AccountState&gt;, BigDecimal&gt; getBalance() {
    return STATE.widen(State.inspect(AccountState::balance));
  }

  public static Kind&lt;StateKind.Witness&lt;AccountState&gt;, List&lt;Transaction&gt;&gt; getHistory() {
    return STATE.widen(State.inspect(AccountState::history));
  }

  // ... main method will be added

}
</code></pre>
<h3 id="4-compose-computations-using-map-and-flatmap-1"><a class="header" href="#4-compose-computations-using-map-and-flatmap-1">4. Compose Computations using <code>map</code> and <code>flatMap</code></a></h3>
<p>We use <code>flatMap</code> and <code>map</code> from  <code>accountStateMonad</code> to sequence these actions. The state is threaded automatically.</p>
<pre><code class="language-java">public class BankAccountWorkflow {
  // ... (monad instance and previous actions)
  public static void main(String[] args) {
    // Initial state: Account with £100 balance.
    AccountState initialState = AccountState.initial(new BigDecimal("100.00"));
   var workflow =
           For.from(accountStateMonad, deposit("Salary").apply(new BigDecimal("20.00")))
               .from(a -&gt; withdraw("Bill Payment").apply(new BigDecimal("50.00")))
               .from(b -&gt; withdraw("Groceries").apply(new BigDecimal("70.00")))
               .from(c -&gt; getBalance())
               .from(t -&gt; getHistory())
               .yield((deposit, w1, w2, bal, history) -&gt; {
                 var report = new StringBuilder();
                 history.forEach(tx -&gt; report.append("  - %s\n".formatted(tx)));
                 return report.toString();
               });

    StateTuple&lt;AccountState, String&gt; finalResultTuple =
        StateKindHelper.runState(workflow, initialState);

    System.out.println(finalResultTuple.value());

    System.out.println("\nDirect Final Account State:");
    System.out.println("Balance: £" + finalResultTuple.state().balance());
    System.out.println(
        "History contains " + finalResultTuple.state().history().size() + " transaction(s):");
    finalResultTuple.state().history().forEach(tx -&gt; System.out.println("  - " + tx));
  }
}
</code></pre>
<h3 id="5-run-the-computation-1"><a class="header" href="#5-run-the-computation-1">5. Run the Computation</a></h3>
<p>The <code>StateKindHelper.runState(workflow, initialState)</code> call executes the entire sequence of operations, starting with <code>initialState</code>.
It returns a StateTuple containing the final result of the <em>entire workflow</em> (in this case, the <code>String</code> report) and the final state of the <code>AccountState</code>.</p>
<pre><code>
Direct Final Account State:
Balance: £0.00
History contains 4 transaction(s):
  - Transaction[type=INITIAL_BALANCE, amount=100.00, timestamp=2025-05-18T17:35:53.564874439, description=Initial account balance]
  - Transaction[type=DEPOSIT, amount=20.00, timestamp=2025-05-18T17:35:53.578424630, description=Salary]
  - Transaction[type=WITHDRAWAL, amount=50.00, timestamp=2025-05-18T17:35:53.579196349, description=Bill Payment]
  - Transaction[type=WITHDRAWAL, amount=70.00, timestamp=2025-05-18T17:35:53.579453984, description=Groceries]
</code></pre>
</div>
</div>
<div id="admonition-key-points" class="admonition admonish-tip" role="note" aria-labelledby="admonition-key-points-title">
<div class="admonition-title">
<div id="admonition-key-points-title">
<p>Key Points:</p>
</div>
<a class="admonition-anchor-link" href="monads/state_monad.html#admonition-key-points"></a>
</div>
<div>
<p>The State monad (<code>State&lt;S, A&gt;</code>, <code>StateKind</code>, <code>StateMonad</code>) , as provided by higher-kinded-j, offers an elegant and functional way to manage state transformations.</p>
<p>By defining atomic state operations and composing them with map and flatMap, you can build complex stateful workflows that are easier to reason about, test, and maintain, as the state is explicitly managed by the monad's structure rather than through mutable side effects. The For comprehension helps simplify the workflow.</p>
<p>Key operations like <code>get</code>, <code>set</code>, <code>modify</code>, and <code>inspect</code> provide convenient ways to interact with the state within the monadic context.</p>
</div>
</div>
<div id="admonition-further-reading" class="admonition admonish-tip" role="note" aria-labelledby="admonition-further-reading-title">
<div class="admonition-title">
<div id="admonition-further-reading-title">
<p>Further Reading</p>
</div>
<a class="admonition-anchor-link" href="monads/state_monad.html#admonition-further-reading"></a>
</div>
<div>
<p>For deeper exploration of the State monad and its applications:</p>
<p><strong>Foundational Resources:</strong></p>
<ul>
<li><strong>Philip Wadler</strong>: <a href="https://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf">Monads for functional programming</a> - Classic paper introducing monads including State</li>
<li><strong>Cats Documentation</strong>: <a href="https://typelevel.org/cats/datatypes/state.html">State Monad</a> - Scala implementation with comprehensive examples</li>
<li><strong>Haskell Wiki</strong>: <a href="https://wiki.haskell.org/State_Monad">State Monad</a> - Conceptual foundation and theory</li>
</ul>
<p><strong>Java-Focused Resources:</strong></p>
<ul>
<li><strong>Pierre-Yves Saumont</strong>: "Functional Programming in Java" (Manning, 2017) - Deep dive into functional techniques including state management</li>
<li><strong>Venkat Subramaniam</strong>: "Functional Programming in Java" (O'Reilly, 2014) - Practical guide to FP patterns in modern Java</li>
</ul>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="monads/reader_monad.html">Reader</a>
<strong>Next:</strong> <a href="monads/stream_monad.html">Stream</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="the-streammonad"><a class="header" href="#the-streammonad">The StreamMonad:</a></h1>
<h2 id="lazy-potentially-infinite-sequences-with-functional-operations"><a class="header" href="#lazy-potentially-infinite-sequences-with-functional-operations"><em>Lazy, Potentially Infinite Sequences with Functional Operations</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="monads/stream_monad.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to work with Streams as contexts for lazy, potentially infinite sequences</li>
<li>Understanding Stream's <strong>single-use semantics</strong> and how to work with them</li>
<li>Using <code>map</code>, <code>flatMap</code>, and <code>ap</code> for lazy functional composition</li>
<li>Leveraging StreamOps utilities for common stream operations</li>
<li>Building efficient data processing pipelines with monadic operations</li>
<li>When to choose Stream over List for sequential processing</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code:</p>
</div>
<a class="admonition-anchor-link" href="monads/stream_monad.html#admonition-see-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/StreamExample.java">StreamExample.java</a></p>
</div>
</div>
<h2 id="purpose-7"><a class="header" href="#purpose-7">Purpose</a></h2>
<p>The <code>StreamMonad</code> in the <code>Higher-Kinded-J</code> library provides a monadic interface for Java's standard <code>java.util.stream.Stream</code>. It allows developers to work with streams in a functional style, enabling operations like <code>map</code>, <code>flatMap</code>, and <code>ap</code> within the higher-kinded type system. This is particularly useful for processing sequences of data lazily, handling potentially infinite sequences, and composing stream operations in a type-safe manner.</p>
<p>Key benefits include:</p>
<ul>
<li><strong>Lazy Evaluation:</strong> Operations are not performed until a terminal operation is invoked, allowing for efficient processing of large or infinite sequences.</li>
<li><strong>HKT Integration:</strong> <code>StreamKind</code> (the higher-kinded wrapper for <code>Stream</code>) and <code>StreamMonad</code> allow <code>Stream</code> to be used with generic functions and type classes expecting <code>Kind&lt;F, A&gt;</code>, <code>Functor&lt;F&gt;</code>, <code>Applicative&lt;F&gt;</code>, or <code>Monad&lt;F&gt;</code>.</li>
<li><strong>MonadZero Instance:</strong> Provides an empty stream via <code>zero()</code>, useful for filtering and conditional logic.</li>
<li><strong>Functional Composition:</strong> Easily chain operations on streams where each operation maintains laziness and allows composition of complex data transformations.</li>
</ul>
<p>It implements <code>MonadZero&lt;StreamKind.Witness&gt;</code>, inheriting from <code>Monad</code>, <code>Applicative</code>, and <code>Functor</code>.</p>
<div id="admonition-important-single-use-semantics" class="admonition admonish-warning" role="note" aria-labelledby="admonition-important-single-use-semantics-title">
<div class="admonition-title">
<div id="admonition-important-single-use-semantics-title">
<p>Important: Single-Use Semantics</p>
</div>
<a class="admonition-anchor-link" href="monads/stream_monad.html#admonition-important-single-use-semantics"></a>
</div>
<div>
<p>Java Streams have <strong>single-use semantics</strong>. Once a terminal operation has been performed on a stream (including operations that narrow and inspect the stream), that stream cannot be reused. Attempting to operate on a consumed stream throws <code>IllegalStateException</code>.</p>
<p><strong>Best Practice:</strong> Create fresh stream instances for each operation sequence. Don't store and reuse <code>Kind&lt;StreamKind.Witness, A&gt;</code> instances after they've been consumed.</p>
</div>
</div>
<h2 id="structure-8"><a class="header" href="#structure-8">Structure</a></h2>
<p><img src="monads/../images/puml/stream_monad.svg" alt="stream_monad.svg" /></p>
<h2 id="how-to-use-streammonad-and-streamkind"><a class="header" href="#how-to-use-streammonad-and-streamkind">How to Use <code>StreamMonad</code> and <code>StreamKind</code></a></h2>
<h3 id="creating-instances-4"><a class="header" href="#creating-instances-4">Creating Instances</a></h3>
<p><code>StreamKind&lt;A&gt;</code> is the higher-kinded type representation for <code>java.util.stream.Stream&lt;A&gt;</code>. You create <code>StreamKind</code> instances using the <code>StreamKindHelper</code> utility class, the <code>of</code> method from <code>StreamMonad</code>, or the convenient factory methods in <code>StreamOps</code>.</p>
<div id="admonition-_streamwidenstream_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_streamwidenstream_-title">
<div class="admonition-title">
<div id="admonition-_streamwidenstream_-title">
<p><em>STREAM.widen(Stream<A>)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/stream_monad.html#admonition-_streamwidenstream_"></a>
</div>
<div>
<p>Converts a standard <code>java.util.stream.Stream&lt;A&gt;</code> into a <code>Kind&lt;StreamKind.Witness, A&gt;</code>.</p>
<pre><code class="language-java">Stream&lt;String&gt; stringStream = Stream.of("a", "b", "c");
Kind&lt;StreamKind.Witness, String&gt; streamKind1 = STREAM.widen(stringStream);

Stream&lt;Integer&gt; intStream = Stream.of(1, 2, 3);
Kind&lt;StreamKind.Witness, Integer&gt; streamKind2 = STREAM.widen(intStream);

Stream&lt;Object&gt; emptyStream = Stream.empty();
Kind&lt;StreamKind.Witness, Object&gt; streamKindEmpty = STREAM.widen(emptyStream);
</code></pre>
</div>
</div>
<div id="admonition-_streammonadofa-value_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_streammonadofa-value_-title">
<div class="admonition-title">
<div id="admonition-_streammonadofa-value_-title">
<p><em>streamMonad.of(A value)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/stream_monad.html#admonition-_streammonadofa-value_"></a>
</div>
<div>
<p>Lifts a single value into the <code>StreamKind</code> context, creating a singleton stream. A <code>null</code> input value results in an empty <code>StreamKind</code>.</p>
<pre><code class="language-java">StreamMonad streamMonad = StreamMonad.INSTANCE;

Kind&lt;StreamKind.Witness, String&gt; streamKindOneItem = streamMonad.of("hello"); // Contains a stream with one element: "hello"
Kind&lt;StreamKind.Witness, Integer&gt; streamKindAnotherItem = streamMonad.of(42);  // Contains a stream with one element: 42
Kind&lt;StreamKind.Witness, Object&gt; streamKindFromNull = streamMonad.of(null); // Contains an empty stream
</code></pre>
</div>
</div>
<div id="admonition-_streammonadzero_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_streammonadzero_-title">
<div class="admonition-title">
<div id="admonition-_streammonadzero_-title">
<p><em>streamMonad.zero()</em></p>
</div>
<a class="admonition-anchor-link" href="monads/stream_monad.html#admonition-_streammonadzero_"></a>
</div>
<div>
<p>Creates an empty <code>StreamKind</code>, useful for filtering operations or providing a "nothing" value in monadic computations.</p>
<pre><code class="language-java">StreamMonad streamMonad = StreamMonad.INSTANCE;

Kind&lt;StreamKind.Witness, String&gt; emptyStreamKind = streamMonad.zero(); // Empty stream
</code></pre>
</div>
</div>
<div id="admonition-_streamnarrow_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_streamnarrow_-title">
<div class="admonition-title">
<div id="admonition-_streamnarrow_-title">
<p><em>STREAM.narrow()</em></p>
</div>
<a class="admonition-anchor-link" href="monads/stream_monad.html#admonition-_streamnarrow_"></a>
</div>
<div>
<p>To get the underlying <code>java.util.stream.Stream&lt;A&gt;</code> from a <code>Kind&lt;StreamKind.Witness, A&gt;</code>, use <code>STREAM.narrow()</code>:</p>
<pre><code class="language-java">Kind&lt;StreamKind.Witness, String&gt; streamKind = STREAM.widen(Stream.of("example"));
Stream&lt;String&gt; unwrappedStream = STREAM.narrow(streamKind); // Returns Stream containing "example"

// You can then perform terminal operations on the unwrapped stream
List&lt;String&gt; result = unwrappedStream.collect(Collectors.toList());
System.out.println(result); // [example]
</code></pre>
</div>
</div>
<div id="admonition-_streamops-factory-methods_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_streamops-factory-methods_-title">
<div class="admonition-title">
<div id="admonition-_streamops-factory-methods_-title">
<p><em>StreamOps Factory Methods</em></p>
</div>
<a class="admonition-anchor-link" href="monads/stream_monad.html#admonition-_streamops-factory-methods_"></a>
</div>
<div>
<p>The <code>StreamOps</code> utility class provides convenient factory methods for creating <code>StreamKind</code> instances:</p>
<pre><code class="language-java">// Create from varargs
Kind&lt;StreamKind.Witness, Integer&gt; numbers = fromArray(1, 2, 3, 4, 5);

// Create a range (exclusive end)
Kind&lt;StreamKind.Witness, Integer&gt; range = range(1, 11); // 1 through 10

// Create from collection
List&lt;String&gt; names = Arrays.asList("Alice", "Bob", "Charlie");
Kind&lt;StreamKind.Witness, String&gt; nameStream = fromIterable(names);

// Create empty stream
Kind&lt;StreamKind.Witness, String&gt; empty = empty();
</code></pre>
</div>
</div>
<h3 id="key-operations-3"><a class="header" href="#key-operations-3">Key Operations</a></h3>
<p>The <code>StreamMonad</code> provides standard monadic operations, all maintaining lazy evaluation:</p>
<div id="admonition-_mapfunction-f-kind-fa_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_mapfunction-f-kind-fa_-title">
<div class="admonition-title">
<div id="admonition-_mapfunction-f-kind-fa_-title">
<p><em>map(Function&lt;A, B&gt; f, Kind&lt;StreamKind.Witness, A&gt; fa)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/stream_monad.html#admonition-_mapfunction-f-kind-fa_"></a>
</div>
<div>
<p><strong><code>map(Function&lt;A, B&gt; f, Kind&lt;StreamKind.Witness, A&gt; fa)</code>:</strong></p>
<p>Applies a function <code>f</code> to each element of the stream within <code>fa</code>, returning a new <code>StreamKind</code> containing the transformed elements. The transformation is <strong>lazy</strong> and won't execute until a terminal operation is performed.</p>
<pre><code class="language-java">StreamMonad streamMonad = StreamMonad.INSTANCE;
Kind&lt;StreamKind.Witness, Integer&gt; numbers = STREAM.widen(Stream.of(1, 2, 3));

Function&lt;Integer, String&gt; intToString = i -&gt; "Number: " + i;
Kind&lt;StreamKind.Witness, String&gt; strings = streamMonad.map(intToString, numbers);

// At this point, no transformation has occurred yet (lazy)
// Terminal operation triggers execution:
List&lt;String&gt; result = STREAM.narrow(strings).collect(Collectors.toList());
System.out.println(result);
// Output: [Number: 1, Number: 2, Number: 3]
</code></pre>
</div>
</div>
<div id="admonition-_flatmapfunction-f-kind-ma_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_flatmapfunction-f-kind-ma_-title">
<div class="admonition-title">
<div id="admonition-_flatmapfunction-f-kind-ma_-title">
<p><em>flatMap(Function&lt;A, Kind&lt;StreamKind.Witness, B&gt;&gt; f, Kind&lt;StreamKind.Witness, A&gt; ma)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/stream_monad.html#admonition-_flatmapfunction-f-kind-ma_"></a>
</div>
<div>
<p><strong><code>flatMap(Function&lt;A, Kind&lt;StreamKind.Witness, B&gt;&gt; f, Kind&lt;StreamKind.Witness, A&gt; ma)</code>:</strong></p>
<p>Applies a function <code>f</code> to each element of the stream within <code>ma</code>. The function <code>f</code> itself returns a <code>StreamKind&lt;B&gt;</code>. <code>flatMap</code> then flattens all these resulting streams into a single <code>StreamKind&lt;B&gt;</code>. Evaluation remains lazy.</p>
<pre><code class="language-java">StreamMonad streamMonad = StreamMonad.INSTANCE;
Kind&lt;StreamKind.Witness, Integer&gt; initialValues = STREAM.widen(Stream.of(1, 2, 3));

// Function that takes an integer and returns a stream of itself and itself + 10
Function&lt;Integer, Kind&lt;StreamKind.Witness, Integer&gt;&gt; replicateAndAddTen =
    i -&gt; STREAM.widen(Stream.of(i, i + 10));

Kind&lt;StreamKind.Witness, Integer&gt; flattenedStream = streamMonad.flatMap(replicateAndAddTen, initialValues);

// Lazy - evaluation happens at terminal operation
List&lt;Integer&gt; result = STREAM.narrow(flattenedStream).collect(Collectors.toList());
System.out.println(result);
// Output: [1, 11, 2, 12, 3, 13]

// Example with conditional logic
Function&lt;Integer, Kind&lt;StreamKind.Witness, String&gt;&gt; toWordsIfEven =
    i -&gt; (i % 2 == 0) ?
         STREAM.widen(Stream.of("even", String.valueOf(i))) :
         streamMonad.zero(); // Empty stream for odd numbers

Kind&lt;StreamKind.Witness, String&gt; wordStream = streamMonad.flatMap(toWordsIfEven, initialValues);
List&lt;String&gt; words = STREAM.narrow(wordStream).collect(Collectors.toList());
System.out.println(words);
// Output: [even, 2]
</code></pre>
</div>
</div>
<div id="admonition-_apkind-ff-kind-fa_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_apkind-ff-kind-fa_-title">
<div class="admonition-title">
<div id="admonition-_apkind-ff-kind-fa_-title">
<p><em>ap(Kind&lt;StreamKind.Witness, Function&lt;A, B&gt;&gt; ff, Kind&lt;StreamKind.Witness, A&gt; fa)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/stream_monad.html#admonition-_apkind-ff-kind-fa_"></a>
</div>
<div>
<p><strong><code>ap(Kind&lt;StreamKind.Witness, Function&lt;A, B&gt;&gt; ff, Kind&lt;StreamKind.Witness, A&gt; fa)</code>:</strong></p>
<p>Applies a stream of functions <code>ff</code> to a stream of values <code>fa</code>. This results in a new stream where each function from <code>ff</code> is applied to each value in <code>fa</code> (Cartesian product style). Evaluation remains lazy.</p>
<pre><code class="language-java">StreamMonad streamMonad = StreamMonad.INSTANCE;

Function&lt;Integer, String&gt; addPrefix = i -&gt; "Val: " + i;
Function&lt;Integer, String&gt; multiplyAndString = i -&gt; "Mul: " + (i * 2);

Kind&lt;StreamKind.Witness, Function&lt;Integer, String&gt;&gt; functions =
    STREAM.widen(Stream.of(addPrefix, multiplyAndString));
Kind&lt;StreamKind.Witness, Integer&gt; values = STREAM.widen(Stream.of(10, 20));

Kind&lt;StreamKind.Witness, String&gt; appliedResults = streamMonad.ap(functions, values);

// Lazy - collects when terminal operation is performed
List&lt;String&gt; result = STREAM.narrow(appliedResults).collect(Collectors.toList());
System.out.println(result);
// Output: [Val: 10, Val: 20, Mul: 20, Mul: 40]
</code></pre>
</div>
</div>
<h2 id="streamops-utility-documentation"><a class="header" href="#streamops-utility-documentation">StreamOps Utility Documentation</a></h2>
<p>The <code>StreamOps</code> class provides a rich set of static utility methods for working with <code>StreamKind</code> instances. These operations complement the monadic interface with practical stream manipulation functions.</p>
<h3 id="creation-operations"><a class="header" href="#creation-operations">Creation Operations</a></h3>
<div id="admonition-factory-methods" class="admonition admonish-note" role="note" aria-labelledby="admonition-factory-methods-title">
<div class="admonition-title">
<div id="admonition-factory-methods-title">
<p>Factory Methods</p>
</div>
<a class="admonition-anchor-link" href="monads/stream_monad.html#admonition-factory-methods"></a>
</div>
<div>
<pre><code class="language-java">// Create from varargs
Kind&lt;StreamKind.Witness, T&gt; fromArray(T... elements)

// Create from Iterable
Kind&lt;StreamKind.Witness, T&gt; fromIterable(Iterable&lt;T&gt; iterable)

// Create a range [start, end)
Kind&lt;StreamKind.Witness, Integer&gt; range(int start, int end)

// Create empty stream
Kind&lt;StreamKind.Witness, T&gt; empty()
</code></pre>
<p><strong>Examples:</strong></p>
<pre><code class="language-java">Kind&lt;StreamKind.Witness, String&gt; names = fromArray("Alice", "Bob", "Charlie");
Kind&lt;StreamKind.Witness, Integer&gt; numbers = range(1, 101); // 1 to 100
Kind&lt;StreamKind.Witness, String&gt; emptyStream = empty();
</code></pre>
</div>
</div>
<h3 id="filtering-and-selection"><a class="header" href="#filtering-and-selection">Filtering and Selection</a></h3>
<div id="admonition-filtering-operations" class="admonition admonish-note" role="note" aria-labelledby="admonition-filtering-operations-title">
<div class="admonition-title">
<div id="admonition-filtering-operations-title">
<p>Filtering Operations</p>
</div>
<a class="admonition-anchor-link" href="monads/stream_monad.html#admonition-filtering-operations"></a>
</div>
<div>
<pre><code class="language-java">// Keep only elements matching predicate
Kind&lt;StreamKind.Witness, A&gt; filter(Predicate&lt;A&gt; predicate, Kind&lt;StreamKind.Witness, A&gt; stream)

// Take first n elements
Kind&lt;StreamKind.Witness, A&gt; take(long n, Kind&lt;StreamKind.Witness, A&gt; stream)

// Skip first n elements
Kind&lt;StreamKind.Witness, A&gt; drop(long n, Kind&lt;StreamKind.Witness, A&gt; stream)
</code></pre>
<p><strong>Examples:</strong></p>
<pre><code class="language-java">Kind&lt;StreamKind.Witness, Integer&gt; numbers = range(1, 101);

// Get only even numbers
Kind&lt;StreamKind.Witness, Integer&gt; evens = filter(n -&gt; n % 2 == 0, numbers);

// Get first 10 elements
Kind&lt;StreamKind.Witness, Integer&gt; first10 = take(10, range(1, 1000));

// Skip first 5 elements
Kind&lt;StreamKind.Witness, Integer&gt; afterFirst5 = drop(5, range(1, 20));
</code></pre>
</div>
</div>
<h3 id="combination-operations"><a class="header" href="#combination-operations">Combination Operations</a></h3>
<div id="admonition-combining-streams" class="admonition admonish-note" role="note" aria-labelledby="admonition-combining-streams-title">
<div class="admonition-title">
<div id="admonition-combining-streams-title">
<p>Combining Streams</p>
</div>
<a class="admonition-anchor-link" href="monads/stream_monad.html#admonition-combining-streams"></a>
</div>
<div>
<pre><code class="language-java">// Concatenate two streams sequentially
Kind&lt;StreamKind.Witness, A&gt; concat(Kind&lt;StreamKind.Witness, A&gt; stream1, Kind&lt;StreamKind.Witness, A&gt; stream2)

// Zip two streams element-wise with combiner function
Kind&lt;StreamKind.Witness, C&gt; zip(Kind&lt;StreamKind.Witness, A&gt; stream1, Kind&lt;StreamKind.Witness, B&gt; stream2, BiFunction&lt;A, B, C&gt; combiner)

// Pair each element with its index (starting from 0)
Kind&lt;StreamKind.Witness, Tuple2&lt;Integer, A&gt;&gt; zipWithIndex(Kind&lt;StreamKind.Witness, A&gt; stream)
</code></pre>
<p><strong>Examples:</strong></p>
<pre><code class="language-java">Kind&lt;StreamKind.Witness, Integer&gt; first = range(1, 4);   // 1, 2, 3
Kind&lt;StreamKind.Witness, Integer&gt; second = range(10, 13); // 10, 11, 12

// Sequential concatenation
Kind&lt;StreamKind.Witness, Integer&gt; combined = concat(first, second);
// Result: 1, 2, 3, 10, 11, 12

// Element-wise combination
Kind&lt;StreamKind.Witness, String&gt; names = fromArray("Alice", "Bob", "Charlie");
Kind&lt;StreamKind.Witness, Integer&gt; ages = fromArray(25, 30, 35);
Kind&lt;StreamKind.Witness, String&gt; profiles = zip(names, ages,
    (name, age) -&gt; name + " is " + age);
// Result: "Alice is 25", "Bob is 30", "Charlie is 35"

// Index pairing
Kind&lt;StreamKind.Witness, String&gt; items = fromArray("apple", "banana", "cherry");
Kind&lt;StreamKind.Witness, Tuple2&lt;Integer, String&gt;&gt; indexed = zipWithIndex(items);
// Result: (0, "apple"), (1, "banana"), (2, "cherry")
</code></pre>
</div>
</div>
<h3 id="terminal-operations-1"><a class="header" href="#terminal-operations-1">Terminal Operations</a></h3>
<div id="admonition-consuming-streams" class="admonition admonish-note" role="note" aria-labelledby="admonition-consuming-streams-title">
<div class="admonition-title">
<div id="admonition-consuming-streams-title">
<p>Consuming Streams</p>
</div>
<a class="admonition-anchor-link" href="monads/stream_monad.html#admonition-consuming-streams"></a>
</div>
<div>
<pre><code class="language-java">// Collect to List
List&lt;A&gt; toList(Kind&lt;StreamKind.Witness, A&gt; stream)

// Collect to Set
Set&lt;A&gt; toSet(Kind&lt;StreamKind.Witness, A&gt; stream)

// Execute side effect for each element
void forEach(Consumer&lt;A&gt; action, Kind&lt;StreamKind.Witness, A&gt; stream)
</code></pre>
<p><strong>Examples:</strong></p>
<pre><code class="language-java">Kind&lt;StreamKind.Witness, Integer&gt; numbers = range(1, 6);

// Collect to List
List&lt;Integer&gt; numberList = toList(numbers); // [1, 2, 3, 4, 5]

// Collect to Set (removes duplicates)
Kind&lt;StreamKind.Witness, String&gt; words = fromArray("a", "b", "a", "c");
Set&lt;String&gt; uniqueWords = toSet(words); // {"a", "b", "c"}

// Execute side effects
Kind&lt;StreamKind.Witness, String&gt; messages = fromArray("Hello", "World");
forEach(System.out::println, messages);
// Prints:
// Hello
// World
</code></pre>
</div>
</div>
<h3 id="side-effects-and-debugging"><a class="header" href="#side-effects-and-debugging">Side Effects and Debugging</a></h3>
<div id="admonition-observation-operations" class="admonition admonish-note" role="note" aria-labelledby="admonition-observation-operations-title">
<div class="admonition-title">
<div id="admonition-observation-operations-title">
<p>Observation Operations</p>
</div>
<a class="admonition-anchor-link" href="monads/stream_monad.html#admonition-observation-operations"></a>
</div>
<div>
<pre><code class="language-java">// Execute side effect for each element while passing through
Kind&lt;StreamKind.Witness, A&gt; tap(Consumer&lt;A&gt; action, Kind&lt;StreamKind.Witness, A&gt; stream)
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-java">List&lt;String&gt; log = new ArrayList&lt;&gt;();

Kind&lt;StreamKind.Witness, Integer&gt; pipeline = tap(
    n -&gt; log.add("Processing: " + n),
    StreamMonad.INSTANCE.map(n -&gt; n * 2, range(1, 4))
);

// Side effects haven't executed yet (lazy)
System.out.println("Log size: " + log.size()); // 0

// Terminal operation triggers execution
List&lt;Integer&gt; result = toList(pipeline);
System.out.println("Log size: " + log.size()); // 3
System.out.println("Log: " + log); // [Processing: 2, Processing: 4, Processing: 6]
System.out.println("Result: " + result); // [2, 4, 6]
</code></pre>
</div>
</div>
<h2 id="important-constraints-single-use-semantics"><a class="header" href="#important-constraints-single-use-semantics">Important Constraints: Single-Use Semantics</a></h2>
<div id="admonition-critical-stream-single-use-limitation" class="admonition admonish-danger" role="note" aria-labelledby="admonition-critical-stream-single-use-limitation-title">
<div class="admonition-title">
<div id="admonition-critical-stream-single-use-limitation-title">
<p>Critical: Stream Single-Use Limitation</p>
</div>
<a class="admonition-anchor-link" href="monads/stream_monad.html#admonition-critical-stream-single-use-limitation"></a>
</div>
<div>
<p>Unlike <code>List</code> or <code>Optional</code>, Java Streams can only be consumed <strong>once</strong>. This is a fundamental characteristic of <code>java.util.stream.Stream</code> that is preserved in the HKT representation.</p>
<p><strong>What This Means:</strong></p>
<ul>
<li>Once you perform a terminal operation on a stream (including <code>narrow()</code> followed by collection), that stream is consumed</li>
<li>Attempting to reuse a consumed stream throws <code>IllegalStateException</code></li>
<li>Each <code>Kind&lt;StreamKind.Witness, A&gt;</code> instance can only flow through one pipeline to completion</li>
</ul>
<p><strong>Correct Approach:</strong></p>
<pre><code class="language-java">// Create fresh stream for each independent operation
Kind&lt;StreamKind.Witness, Integer&gt; stream1 = range(1, 4);
List&lt;Integer&gt; result1 = toList(stream1); // ✓ First use

Kind&lt;StreamKind.Witness, Integer&gt; stream2 = range(1, 4); // Create new stream
List&lt;Integer&gt; result2 = toList(stream2); // ✓ Second use with fresh stream
</code></pre>
<p><strong>Incorrect Approach:</strong></p>
<pre><code class="language-java">// DON'T DO THIS - Will throw IllegalStateException
Kind&lt;StreamKind.Witness, Integer&gt; stream = range(1, 4);
List&lt;Integer&gt; result1 = toList(stream);  // ✓ First use
List&lt;Integer&gt; result2 = toList(stream);  // ✗ ERROR: stream already consumed!
</code></pre>
<p><strong>Design Implications:</strong></p>
<ul>
<li>Don't store <code>StreamKind</code> instances in fields for reuse</li>
<li>Create streams on-demand when needed</li>
<li>Use factory methods or suppliers to generate fresh streams</li>
<li>Consider using <code>List</code> if you need to process data multiple times</li>
</ul>
</div>
</div>
<h2 id="practical-example-complete-usage"><a class="header" href="#practical-example-complete-usage">Practical Example: Complete Usage</a></h2>
<div id="admonition-comprehensive-stream-example" class="admonition admonish-example" role="note" aria-labelledby="admonition-comprehensive-stream-example-title">
<div class="admonition-title">
<div id="admonition-comprehensive-stream-example-title">
<p>Comprehensive Stream Example</p>
</div>
<a class="admonition-anchor-link" href="monads/stream_monad.html#admonition-comprehensive-stream-example"></a>
</div>
<div>
<p>Here's a complete example demonstrating various Stream operations:</p>
<pre><code class="language-java">import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.stream.StreamKind;
import org.higherkindedj.hkt.stream.StreamMonad;
import static org.higherkindedj.hkt.stream.StreamKindHelper.STREAM;
import static org.higherkindedj.hkt.stream.StreamOps.*;

import java.util.List;
import java.util.function.Function;

public class StreamUsageExample {
   public static void main(String[] args) {
      StreamMonad streamMonad = StreamMonad.INSTANCE;

      // 1. Create a StreamKind using range
      Kind&lt;StreamKind.Witness, Integer&gt; numbersKind = range(1, 11); // 1 through 10

      // 2. Use map to transform (lazy)
      Function&lt;Integer, String&gt; numberToString = n -&gt; "Item-" + n;
      Kind&lt;StreamKind.Witness, String&gt; stringsKind = streamMonad.map(numberToString, numbersKind);

      System.out.println("Mapped: " + toList(stringsKind));
      // Expected: [Item-1, Item-2, Item-3, ..., Item-10]

      // 3. Create fresh stream for flatMap example
      Kind&lt;StreamKind.Witness, Integer&gt; numbersKind2 = range(1, 6);

      // flatMap: duplicate even numbers, skip odd numbers
      Function&lt;Integer, Kind&lt;StreamKind.Witness, Integer&gt;&gt; duplicateIfEven = n -&gt; {
         if (n % 2 == 0) {
            return fromArray(n, n); // Duplicate even numbers
         } else {
            return streamMonad.zero(); // Skip odd numbers
         }
      };

      Kind&lt;StreamKind.Witness, Integer&gt; flatMappedKind = streamMonad.flatMap(duplicateIfEven, numbersKind2);
      System.out.println("FlatMapped: " + toList(flatMappedKind));
      // Expected: [2, 2, 4, 4]

      // 4. Use of to create singleton
      Kind&lt;StreamKind.Witness, String&gt; singleValueKind = streamMonad.of("hello world");
      System.out.println("From 'of': " + toList(singleValueKind));
      // Expected: [hello world]

      // 5. Use zero to create empty stream
      Kind&lt;StreamKind.Witness, String&gt; emptyKind = streamMonad.zero();
      System.out.println("From 'zero': " + toList(emptyKind));
      // Expected: []

      // 6. StreamOps: filter and take
      Kind&lt;StreamKind.Witness, Integer&gt; largeRange = range(1, 101);
      Kind&lt;StreamKind.Witness, Integer&gt; evensFirst10 = take(10, filter(n -&gt; n % 2 == 0, largeRange));
      System.out.println("First 10 evens: " + toList(evensFirst10));
      // Expected: [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]

      // 7. Zip two streams
      Kind&lt;StreamKind.Witness, String&gt; names = fromArray("Alice", "Bob", "Charlie");
      Kind&lt;StreamKind.Witness, Integer&gt; scores = fromArray(95, 87, 92);
      Kind&lt;StreamKind.Witness, String&gt; results = zip(names, scores,
          (name, score) -&gt; name + ": " + score);

      System.out.println("Results: " + toList(results));
      // Expected: [Alice: 95, Bob: 87, Charlie: 92]

      // 8. Demonstrating single-use constraint
      Kind&lt;StreamKind.Witness, Integer&gt; streamOnce = range(1, 4);
      List&lt;Integer&gt; firstUse = toList(streamOnce);
      System.out.println("First use: " + firstUse);
      // Expected: [1, 2, 3]

      // Must create new stream for second use
      Kind&lt;StreamKind.Witness, Integer&gt; streamTwice = range(1, 4);
      List&lt;Integer&gt; secondUse = toList(streamTwice);
      System.out.println("Second use (new stream): " + secondUse);
      // Expected: [1, 2, 3]
   }
}
</code></pre>
</div>
</div>
<h2 id="when-to-use-streammonad"><a class="header" href="#when-to-use-streammonad">When to Use StreamMonad</a></h2>
<p><strong>Choose <code>StreamMonad</code> when:</strong></p>
<ul>
<li>Processing large datasets where lazy evaluation provides memory efficiency</li>
<li>Working with potentially infinite sequences</li>
<li>Building complex data transformation pipelines</li>
<li>You need intermediate laziness and only want to materialise results at the end</li>
<li>Single-pass processing is sufficient for your use case</li>
</ul>
<p><strong>Choose <code>ListMonad</code> instead when:</strong></p>
<ul>
<li>You need to process the same data multiple times</li>
<li>Random access to elements is required</li>
<li>The entire dataset fits comfortably in memory</li>
<li>You need to store the result for later reuse</li>
</ul>
<p><strong>Key Difference:</strong> <code>List</code> is eager and reusable; <code>Stream</code> is lazy and single-use.</p>
<hr />
<p><strong>Previous:</strong> <a href="monads/state_monad.html">State</a>
<strong>Next:</strong> <a href="monads/trampoline_monad.html">Trampoline</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="the-trampoline-monad"><a class="header" href="#the-trampoline-monad">The Trampoline Monad:</a></h1>
<h2 id="stack-safe-recursion-in-java"><a class="header" href="#stack-safe-recursion-in-java"><em>Stack-Safe Recursion in Java</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="monads/trampoline_monad.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to convert deeply recursive algorithms to stack-safe iterative ones</li>
<li>Implementing mutually recursive functions without stack overflow</li>
<li>Using <code>Trampoline.done</code> and <code>Trampoline.defer</code> to build trampolined computations</li>
<li>Composing recursive operations using <code>map</code> and <code>flatMap</code></li>
<li>When to use Trampoline vs. traditional recursion</li>
<li>Leveraging <code>TrampolineUtils</code> for stack-safe applicative operations</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code:</p>
</div>
<a class="admonition-anchor-link" href="monads/trampoline_monad.html#admonition-see-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/trampoline/TrampolineExample.java">TrampolineExample.java</a></p>
</div>
</div>
<p>In functional programming, recursion is a natural way to express iterative algorithms. However, the JVM's call stack has a limited depth, and deeply recursive computations can cause <code>StackOverflowError</code>. The JVM lacks tail-call optimisation, which means even tail-recursive functions will consume stack space.</p>
<p>The <code>Trampoline&lt;A&gt;</code> type in <code>higher-kinded-j</code> solves this problem by converting recursive calls into data structures that are evaluated iteratively. Instead of making recursive calls directly (which grow the call stack), you return a <code>Trampoline</code> value that describes the next step of the computation. The <code>run()</code> method then processes these steps in a loop, using constant stack space regardless of recursion depth.</p>
<h2 id="core-components-2"><a class="header" href="#core-components-2">Core Components</a></h2>
<p><strong>The Trampoline Structure</strong></p>
<p><img src="monads/../images/puml/trampoline_structure.svg" alt="trampoline_structure.svg" /></p>
<p><strong>The HKT Bridge for Trampoline</strong></p>
<p><img src="monads/../images/puml/trampoline_kind.svg" alt="trampoline_kind.svg" /></p>
<p><strong>Typeclasses for Trampoline</strong></p>
<p><img src="monads/../images/puml/trampoline_monad.svg" alt="trampoline_monad.svg" /></p>
<p>The <code>Trampoline</code> functionality is built upon several related components:</p>
<ol>
<li>
<p><strong><code>Trampoline&lt;A&gt;</code></strong>: The core sealed interface representing a stack-safe computation. It has three constructors:</p>
<ul>
<li><code>Done&lt;A&gt;</code>: Represents a completed computation holding a final value.</li>
<li><code>More&lt;A&gt;</code>: Represents a suspended computation (deferred thunk) that will be evaluated later.</li>
<li><code>FlatMap&lt;A, B&gt;</code>: Represents a sequenced computation resulting from monadic bind operations.</li>
</ul>
</li>
<li>
<p><strong><code>TrampolineKind&lt;A&gt;</code></strong>: The HKT marker interface (<code>Kind&lt;TrampolineKind.Witness, A&gt;</code>) for <code>Trampoline</code>. This allows <code>Trampoline</code> to be treated as a generic type constructor <code>F</code> in type classes like <code>Functor</code> and <code>Monad</code>. The witness type is <code>TrampolineKind.Witness</code>.</p>
</li>
<li>
<p><strong><code>TrampolineKindHelper</code></strong>: The essential utility class for working with <code>Trampoline</code> in the HKT simulation. It provides:</p>
<ul>
<li><code>widen(Trampoline&lt;A&gt;)</code>: Wraps a concrete <code>Trampoline&lt;A&gt;</code> instance into its HKT representation <code>TrampolineKind&lt;A&gt;</code>.</li>
<li><code>narrow(Kind&lt;TrampolineKind.Witness, A&gt;)</code>: Unwraps a <code>TrampolineKind&lt;A&gt;</code> back to the concrete <code>Trampoline&lt;A&gt;</code>. Throws <code>KindUnwrapException</code> if the input Kind is invalid.</li>
<li><code>done(A value)</code>: Creates a <code>TrampolineKind&lt;A&gt;</code> representing a completed computation.</li>
<li><code>defer(Supplier&lt;Trampoline&lt;A&gt;&gt; next)</code>: Creates a <code>TrampolineKind&lt;A&gt;</code> representing a deferred computation.</li>
<li><code>run(Kind&lt;TrampolineKind.Witness, A&gt;)</code>: Executes the trampoline and returns the final result.</li>
</ul>
</li>
<li>
<p><strong><code>TrampolineFunctor</code></strong>: Implements <code>Functor&lt;TrampolineKind.Witness&gt;</code>. Provides the <code>map</code> operation to transform the result value of a trampoline computation.</p>
</li>
<li>
<p><strong><code>TrampolineMonad</code></strong>: Extends <code>TrampolineFunctor</code> and implements <code>Monad&lt;TrampolineKind.Witness&gt;</code>. Provides <code>of</code> (to lift a pure value into <code>Trampoline</code>) and <code>flatMap</code> (to sequence trampoline computations).</p>
</li>
<li>
<p><strong><code>TrampolineUtils</code></strong>: Utility class providing guaranteed stack-safe applicative operations:</p>
<ul>
<li><code>traverseListStackSafe</code>: Stack-safe list traversal for any applicative.</li>
<li><code>map2StackSafe</code>: Stack-safe map2 for chaining many operations.</li>
<li><code>sequenceStackSafe</code>: Stack-safe sequence operation.</li>
</ul>
</li>
</ol>
<h2 id="purpose-and-usage-3"><a class="header" href="#purpose-and-usage-3">Purpose and Usage</a></h2>
<ul>
<li><strong>Stack Safety</strong>: Converts recursive calls into data structures processed iteratively, preventing <code>StackOverflowError</code> on deep recursion (verified with 100,000+ iterations).</li>
<li><strong>Tail Call Optimisation</strong>: Effectively provides tail-call optimisation for Java, which lacks native support for it.</li>
<li><strong>Lazy Evaluation</strong>: Computations are not executed until <code>run()</code> is explicitly called.</li>
<li><strong>Composability</strong>: Trampolined computations can be chained using <code>map</code> and <code>flatMap</code>.</li>
</ul>
<p><strong>Key Methods:</strong></p>
<ul>
<li><code>Trampoline.done(value)</code>: Creates a completed computation with a final value.</li>
<li><code>Trampoline.defer(supplier)</code>: Defers a computation by wrapping it in a supplier.</li>
<li><code>trampoline.run()</code>: Executes the trampoline iteratively and returns the final result.</li>
<li><code>trampoline.map(f)</code>: Transforms the result without executing the trampoline.</li>
<li><code>trampoline.flatMap(f)</code>: Sequences trampolines whilst maintaining stack safety.</li>
</ul>
<div id="admonition-example-1-stack-safe-factorial" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-1-stack-safe-factorial-title">
<div class="admonition-title">
<div id="admonition-example-1-stack-safe-factorial-title">
<p>Example 1: Stack-Safe Factorial</p>
</div>
<a class="admonition-anchor-link" href="monads/trampoline_monad.html#admonition-example-1-stack-safe-factorial"></a>
</div>
<div>
<p>The classic factorial function is a simple example of recursion. For large numbers, naive recursion will cause stack overflow:</p>
<pre><code class="language-java">import org.higherkindedj.hkt.trampoline.Trampoline;
import java.math.BigInteger;

public class FactorialExample {
    // Naive recursive factorial - WILL OVERFLOW for large n
    static BigInteger factorialNaive(BigInteger n) {
        if (n.compareTo(BigInteger.ZERO) &lt;= 0) {
            return BigInteger.ONE;
        }
        return n.multiply(factorialNaive(n.subtract(BigInteger.ONE)));
    }

    // Stack-safe trampolined factorial - safe for very large n
    static Trampoline&lt;BigInteger&gt; factorial(BigInteger n, BigInteger acc) {
        if (n.compareTo(BigInteger.ZERO) &lt;= 0) {
            return Trampoline.done(acc);
        }
        // Instead of recursive call, return a deferred computation
        return Trampoline.defer(() -&gt;
            factorial(n.subtract(BigInteger.ONE), n.multiply(acc))
        );
    }

    public static void main(String[] args) {
        // This would overflow: factorialNaive(BigInteger.valueOf(10000));

        // This is stack-safe
        BigInteger result = factorial(
            BigInteger.valueOf(10000),
            BigInteger.ONE
        ).run();

        System.out.println("Factorial computed safely!");
        System.out.println("Result has " + result.toString().length() + " digits");
    }
}
</code></pre>
</div>
</div>
<p><strong>Key Insight:</strong> Instead of making a direct recursive call (which pushes a new frame onto the call stack), we return <code>Trampoline.defer(() -&gt; ...)</code> which creates a data structure. The <code>run()</code> method then evaluates these structures iteratively.</p>
<div id="admonition-example-2-mutual-recursion---isevenisodd" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-2-mutual-recursion---isevenisodd-title">
<div class="admonition-title">
<div id="admonition-example-2-mutual-recursion---isevenisodd-title">
<p>Example 2: Mutual Recursion - isEven/isOdd</p>
</div>
<a class="admonition-anchor-link" href="monads/trampoline_monad.html#admonition-example-2-mutual-recursion---isevenisodd"></a>
</div>
<div>
<p>Mutually recursive functions are another classic case where stack overflow occurs easily:</p>
<pre><code class="language-java">import org.higherkindedj.hkt.trampoline.Trampoline;

public class MutualRecursionExample {
    // Naive mutual recursion - WILL OVERFLOW for large n
    static boolean isEvenNaive(int n) {
        if (n == 0) return true;
        return isOddNaive(n - 1);
    }

    static boolean isOddNaive(int n) {
        if (n == 0) return false;
        return isEvenNaive(n - 1);
    }

    // Stack-safe trampolined versions
    static Trampoline&lt;Boolean&gt; isEven(int n) {
        if (n == 0) return Trampoline.done(true);
        return Trampoline.defer(() -&gt; isOdd(n - 1));
    }

    static Trampoline&lt;Boolean&gt; isOdd(int n) {
        if (n == 0) return Trampoline.done(false);
        return Trampoline.defer(() -&gt; isEven(n - 1));
    }

    public static void main(String[] args) {
        // This would overflow: isEvenNaive(1000000);

        // This is stack-safe
        boolean result = isEven(1000000).run();
        System.out.println("1000000 is even: " + result); // true

        boolean result2 = isOdd(999999).run();
        System.out.println("999999 is odd: " + result2); // true
    }
}
</code></pre>
</div>
</div>
<div id="admonition-example-3-fibonacci-with-trampoline" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-3-fibonacci-with-trampoline-title">
<div class="admonition-title">
<div id="admonition-example-3-fibonacci-with-trampoline-title">
<p>Example 3: Fibonacci with Trampoline</p>
</div>
<a class="admonition-anchor-link" href="monads/trampoline_monad.html#admonition-example-3-fibonacci-with-trampoline"></a>
</div>
<div>
<p>Computing Fibonacci numbers recursively is inefficient and stack-unsafe. With trampolining, we achieve stack safety (though we'd still want memoisation for efficiency):</p>
<pre><code class="language-java">import org.higherkindedj.hkt.trampoline.Trampoline;
import java.math.BigInteger;

public class FibonacciExample {
    // Stack-safe Fibonacci using tail recursion with accumulator
    static Trampoline&lt;BigInteger&gt; fibonacci(int n, BigInteger a, BigInteger b) {
        if (n == 0) return Trampoline.done(a);
        if (n == 1) return Trampoline.done(b);

        return Trampoline.defer(() -&gt;
            fibonacci(n - 1, b, a.add(b))
        );
    }

    public static void main(String[] args) {
        // Compute the 10,000th Fibonacci number - stack-safe!
        BigInteger fib10000 = fibonacci(
            10000,
            BigInteger.ZERO,
            BigInteger.ONE
        ).run();

        System.out.println("Fibonacci(10000) has " +
            fib10000.toString().length() + " digits");
    }
}
</code></pre>
</div>
</div>
<div id="admonition-example-4-using-map-and-flatmap" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-4-using-map-and-flatmap-title">
<div class="admonition-title">
<div id="admonition-example-4-using-map-and-flatmap-title">
<p>Example 4: Using map and flatMap</p>
</div>
<a class="admonition-anchor-link" href="monads/trampoline_monad.html#admonition-example-4-using-map-and-flatmap"></a>
</div>
<div>
<p>Trampoline is a monad, so you can compose computations using <code>map</code> and <code>flatMap</code>:</p>
<pre><code class="language-java">import org.higherkindedj.hkt.trampoline.Trampoline;

public class TrampolineCompositionExample {
    static Trampoline&lt;Integer&gt; countDown(int n) {
        if (n &lt;= 0) return Trampoline.done(0);
        return Trampoline.defer(() -&gt; countDown(n - 1));
    }

    public static void main(String[] args) {
        // Use map to transform the result
        Trampoline&lt;String&gt; countWithMessage = countDown(100000)
            .map(result -&gt; "Countdown complete! Final: " + result);

        System.out.println(countWithMessage.run());

        // Use flatMap to sequence trampolines
        Trampoline&lt;Integer&gt; sequenced = countDown(50000)
            .flatMap(first -&gt; countDown(50000)
                .map(second -&gt; first + second));

        System.out.println("Sequenced result: " + sequenced.run());
    }
}
</code></pre>
</div>
</div>
<div id="admonition-example-5-integration-with-trampolineutils" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-5-integration-with-trampolineutils-title">
<div class="admonition-title">
<div id="admonition-example-5-integration-with-trampolineutils-title">
<p>Example 5: Integration with TrampolineUtils</p>
</div>
<a class="admonition-anchor-link" href="monads/trampoline_monad.html#admonition-example-5-integration-with-trampolineutils"></a>
</div>
<div>
<p>When traversing large collections with custom applicatives, use <code>TrampolineUtils</code> for guaranteed stack safety:</p>
<pre><code class="language-java">import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.trampoline.TrampolineUtils;
import org.higherkindedj.hkt.id.*;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class TrampolineUtilsExample {
    public static void main(String[] args) {
        // Create a large list
        List&lt;Integer&gt; largeList = IntStream.range(0, 100000)
            .boxed()
            .collect(Collectors.toList());

        // Traverse it safely
        Kind&lt;IdKind.Witness, List&lt;String&gt;&gt; result =
            TrampolineUtils.traverseListStackSafe(
                largeList,
                i -&gt; Id.of("item-" + i),
                IdMonad.instance()
            );

        List&lt;String&gt; unwrapped = IdKindHelper.ID.narrow(result).value();
        System.out.println("Traversed " + unwrapped.size() + " elements safely");
    }
}
</code></pre>
<p>See <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/trampoline/TrampolineUtils.java"><code>TrampolineUtils</code> documentation</a> for more details on stack-safe applicative operations.</p>
</div>
</div>
<h2 id="when-to-use-trampoline"><a class="header" href="#when-to-use-trampoline">When to Use Trampoline</a></h2>
<p><strong>Use Trampoline when:</strong></p>
<ol>
<li><strong>Deep Recursion</strong>: Processing data structures or algorithms that recurse deeply (&gt;1,000 levels).</li>
<li><strong>Tail Recursion</strong>: Converting tail-recursive algorithms that would otherwise overflow.</li>
<li><strong>Mutual Recursion</strong>: Implementing mutually recursive functions.</li>
<li><strong>Stack Safety Guarantee</strong>: When you absolutely must prevent <code>StackOverflowError</code>.</li>
<li><strong>Large Collections</strong>: When using <code>TrampolineUtils</code> to traverse large collections (&gt;10,000 elements) with custom applicatives.</li>
</ol>
<p><strong>Avoid Trampoline when:</strong></p>
<ol>
<li><strong>Shallow Recursion</strong>: For recursion depth &lt;1,000, the overhead isn't justified.</li>
<li><strong>Performance Critical</strong>: Trampoline adds overhead compared to direct recursion or iteration.</li>
<li><strong>Simple Iteration</strong>: If you can write a simple loop, that's usually clearer and faster.</li>
<li><strong>Standard Collections</strong>: For standard applicatives (Id, Optional, Either, etc.) on moderate-sized lists (&lt;10,000 elements), regular traverse is sufficient.</li>
</ol>
<h2 id="performance-characteristics"><a class="header" href="#performance-characteristics">Performance Characteristics</a></h2>
<ul>
<li><strong>Stack Space</strong>: O(1) - constant stack space regardless of recursion depth</li>
<li><strong>Heap Space</strong>: O(n) - creates data structures for deferred computations</li>
<li><strong>Time Overhead</strong>: Small constant overhead per recursive step compared to direct recursion</li>
<li><strong>Throughput</strong>: Slower than native tail-call optimisation (if it existed in Java) but faster than stack overflow recovery</li>
</ul>
<p><strong>Benchmarks</strong>: The implementation has been verified to handle:</p>
<ul>
<li>100,000+ iterations in factorial computations</li>
<li>1,000,000+ iterations in mutual recursion (isEven/isOdd)</li>
<li>100,000+ element list traversals (via <code>TrampolineUtils</code>)</li>
</ul>
<h2 id="implementation-notes"><a class="header" href="#implementation-notes">Implementation Notes</a></h2>
<p>The <code>run()</code> method uses an iterative algorithm with an explicit continuation stack (implemented with <code>ArrayDeque</code>) to process the trampoline structure. This algorithm:</p>
<ol>
<li>Starts with the current trampoline</li>
<li>If it's <code>More</code>, unwraps it and continues</li>
<li>If it's <code>FlatMap</code>, pushes the function onto the stack and processes the sub-computation</li>
<li>If it's <code>Done</code>, applies any pending continuations from the stack</li>
<li>Repeats until there are no more continuations and we have a final <code>Done</code> value</li>
</ol>
<p>This design ensures that regardless of how deeply nested the recursive calls were in the original algorithm, the execution happens in constant stack space.</p>
<h2 id="type-safety-considerations"><a class="header" href="#type-safety-considerations">Type Safety Considerations</a></h2>
<p>The implementation uses a <code>Continuation</code> wrapper to safely handle heterogeneous types on the continuation stack. This design confines the necessary unsafe cast to a single, controlled location in the code, making the type erasure explicit, documented, and verified to be safe.</p>
<h2 id="summary-20"><a class="header" href="#summary-20">Summary</a></h2>
<p>The <code>Trampoline</code> monad provides a practical solution to Java's lack of tail-call optimisation. By converting recursive algorithms into trampolined form, you can:</p>
<ul>
<li>Write naturally recursive code that's guaranteed stack-safe</li>
<li>Compose recursive computations functionally using <code>map</code> and <code>flatMap</code></li>
<li>Leverage <code>TrampolineUtils</code> for stack-safe applicative operations on large collections</li>
<li>Maintain clarity and correctness whilst preventing <code>StackOverflowError</code></li>
</ul>
<p>For detailed implementation examples and more advanced use cases, see the <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/trampoline/TrampolineExample.java">TrampolineExample.java</a> in the examples module.</p>
<hr />
<div id="admonition-further-reading" class="admonition admonish-tip" role="note" aria-labelledby="admonition-further-reading-title">
<div class="admonition-title">
<div id="admonition-further-reading-title">
<p>Further Reading</p>
</div>
<a class="admonition-anchor-link" href="monads/trampoline_monad.html#admonition-further-reading"></a>
</div>
<div>
<p>For a comprehensive exploration of recursion, thunks, and trampolines in Java and Scala, see Scott Logic's blog post: <a href="https://blog.scottlogic.com/2025/05/02/recursion-thunks-trampolines-with-java-and-scala.html">Recursion, Thunks and Trampolines with Java and Scala</a>.</p>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="monads/stream_monad.html">Stream</a>
<strong>Next:</strong> <a href="monads/free_monad.html">Free</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="the-free-monad"><a class="header" href="#the-free-monad">The Free Monad:</a></h1>
<h2 id="building-composable-dsls-and-interpreters"><a class="header" href="#building-composable-dsls-and-interpreters"><em>Building Composable DSLs and Interpreters</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="monads/free_monad.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to build domain-specific languages (DSLs) as data structures</li>
<li>Separating program description from execution</li>
<li>Creating multiple interpreters for the same program</li>
<li>Using <code>pure</code>, <code>suspend</code>, and <code>liftF</code> to construct Free programs</li>
<li>Implementing stack-safe interpreters with <code>foldMap</code></li>
<li>When Free monads solve real architectural problems</li>
<li>Comparing Free monads with traditional Java patterns</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code:</p>
</div>
<a class="admonition-anchor-link" href="monads/free_monad.html#admonition-see-example-code"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/free/ConsoleProgram.java">ConsoleProgram.java</a></li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/test/java/org/higherkindedj/hkt/free/FreeMonadTest.java">FreeMonadTest.java</a></li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/test/java/org/higherkindedj/hkt/free/FreeFactoryTest.java">FreeFactoryTest.java</a> - Demonstrates improved type inference with FreeFactory</li>
</ul>
</div>
</div>
<h2 id="purpose-8"><a class="header" href="#purpose-8">Purpose</a></h2>
<p>In traditional Java programming, when you want to execute side effects (like printing to the console, reading files, or making database queries), you directly execute them:</p>
<pre><code class="language-java">// Traditional imperative approach
System.out.println("What is your name?");
String name = scanner.nextLine();
System.out.println("Hello, " + name + "!");
</code></pre>
<p>This approach tightly couples <strong>what</strong> you want to do with <strong>how</strong> it's done. The <strong>Free monad</strong> provides a fundamentally different approach: instead of executing effects immediately, you build programs as <strong>data structures</strong> that can be interpreted in different ways.</p>
<p>Think of it like writing a recipe (the data structure) versus actually cooking the meal (the execution). The recipe can be:</p>
<ul>
<li>Executed in a real kitchen (production)</li>
<li>Simulated for testing</li>
<li>Optimised before cooking</li>
<li>Translated to different cuisines</li>
</ul>
<p>The Free monad enables this separation in functional programming. A <code>Free&lt;F, A&gt;</code> represents a program built from instructions of type <code>F</code> that, when interpreted, will produce a value of type <code>A</code>.</p>
<h3 id="key-benefits-1"><a class="header" href="#key-benefits-1">Key Benefits</a></h3>
<ol>
<li><strong>Testability</strong>: Write pure tests without actual side effects. Test database code without a database.</li>
<li><strong>Multiple Interpretations</strong>: One program, many interpreters (production, testing, logging, optimisation).</li>
<li><strong>Composability</strong>: Build complex programs from simple, reusable building blocks.</li>
<li><strong>Inspection</strong>: Programs are data, so you can analyse, optimise, or transform them before execution.</li>
<li><strong>Stack Safety</strong>: Interpretation uses constant stack space, preventing <code>StackOverflowError</code>.</li>
</ol>
<h3 id="comparison-with-traditional-java-patterns"><a class="header" href="#comparison-with-traditional-java-patterns">Comparison with Traditional Java Patterns</a></h3>
<p>If you're familiar with the <strong>Strategy pattern</strong>, Free monads extend this concept:</p>
<p><strong>Strategy Pattern</strong>: Choose algorithm at runtime</p>
<pre><code class="language-java">interface PaymentStrategy {
    void pay(int amount);
}
// Pick one: creditCardStrategy, payPalStrategy, etc.
</code></pre>
<p><strong>Free Monad</strong>: Build an <strong>entire program</strong> as data, then pick how to execute it</p>
<pre><code class="language-java">Free&lt;PaymentOp, Receipt&gt; program = ...;
// Pick interpreter: realPayment, testPayment, loggingPayment, etc.
</code></pre>
<p>Similarly, the <strong>Command pattern</strong> encapsulates actions as objects:</p>
<p><strong>Command Pattern</strong>: Single action as object</p>
<pre><code class="language-java">interface Command {
    void execute();
}
</code></pre>
<p><strong>Free Monad</strong>: Entire workflows with sequencing, branching, and composition</p>
<pre><code class="language-java">Free&lt;Command, Result&gt; workflow =
    sendEmail(...)
        .flatMap(receipt -&gt; saveToDatabase(...))
        .flatMap(id -&gt; sendNotification(...));
// Interpret with real execution or test mock
</code></pre>
<h2 id="core-components-3"><a class="header" href="#core-components-3">Core Components</a></h2>
<p><strong>The Free Structure</strong></p>
<p><img src="monads/../images/puml/free_structure.svg" alt="free_structure.svg" /></p>
<p><strong>The HKT Bridge for Free</strong></p>
<p><img src="monads/../images/puml/free_kind.svg" alt="free_kind.svg" /></p>
<p><strong>Type Classes for Free</strong></p>
<p><img src="monads/../images/puml/free_monad.svg" alt="free_monad.svg" /></p>
<p>The <code>Free</code> functionality is built upon several related components:</p>
<ol>
<li>
<p><strong><code>Free&lt;F, A&gt;</code></strong>: The core sealed interface representing a program. It has three constructors:</p>
<ul>
<li><code>Pure&lt;F, A&gt;</code>: Represents a terminal value: the final result.</li>
<li><code>Suspend&lt;F, A&gt;</code>: Represents a suspended computation: an instruction <code>Kind&lt;F, Free&lt;F, A&gt;&gt;</code> to be interpreted later.</li>
<li><code>FlatMapped&lt;F, X, A&gt;</code>: Represents monadic sequencing: chains computations together in a stack-safe manner.</li>
</ul>
</li>
<li>
<p><strong><code>FreeKind&lt;F, A&gt;</code></strong>: The HKT marker interface (<code>Kind&lt;FreeKind.Witness&lt;F&gt;, A&gt;</code>) for <code>Free</code>. This allows <code>Free</code> to be treated as a generic type constructor in type classes. The witness type is <code>FreeKind.Witness&lt;F&gt;</code>, where <code>F</code> is the instruction set functor.</p>
</li>
<li>
<p><strong><code>FreeKindHelper</code></strong>: The essential utility class for working with <code>Free</code> in the HKT simulation. It provides:</p>
<ul>
<li><code>widen(Free&lt;F, A&gt;)</code>: Wraps a concrete <code>Free&lt;F, A&gt;</code> instance into its HKT representation.</li>
<li><code>narrow(Kind&lt;FreeKind.Witness&lt;F&gt;, A&gt;)</code>: Unwraps a <code>FreeKind&lt;F, A&gt;</code> back to the concrete <code>Free&lt;F, A&gt;</code>.</li>
</ul>
</li>
<li>
<p><strong><code>FreeFunctor&lt;F&gt;</code></strong>: Implements <code>Functor&lt;FreeKind.Witness&lt;F&gt;&gt;</code>. Provides the <code>map</code> operation to transform result values.</p>
</li>
<li>
<p><strong><code>FreeMonad&lt;F&gt;</code></strong>: Extends <code>FreeFunctor&lt;F&gt;</code> and implements <code>Monad&lt;FreeKind.Witness&lt;F&gt;&gt;</code>. Provides <code>of</code> (to lift a pure value) and <code>flatMap</code> (to sequence Free computations).</p>
</li>
</ol>
<h2 id="purpose-and-usage-4"><a class="header" href="#purpose-and-usage-4">Purpose and Usage</a></h2>
<ul>
<li><strong>Building DSLs</strong>: Create domain-specific languages as composable data structures.</li>
<li><strong>Natural Transformations</strong>: Write interpreters as transformations from your instruction set <code>F</code> to a target monad <code>M</code>.</li>
<li><strong>Stack-Safe Execution</strong>: The <code>foldMap</code> method uses Higher-Kinded-J's own <code>Trampoline</code> monad internally, demonstrating the library's composability whilst preventing stack overflow.</li>
<li><strong>Multiple Interpreters</strong>: Execute the same program with different interpreters (production vs. testing vs. logging).</li>
<li><strong>Program Inspection</strong>: Since programs are data, you can analyse, optimise, or transform them before execution.</li>
</ul>
<p><strong>Key Methods:</strong></p>
<ul>
<li><code>Free.pure(value)</code>: Creates a terminal computation holding a final value.</li>
<li><code>Free.suspend(computation)</code>: Suspends a computation for later interpretation.</li>
<li><code>Free.liftF(fa, functor)</code>: Lifts a functor value into a Free monad.</li>
<li><code>free.map(f)</code>: Transforms the result value without executing.</li>
<li><code>free.flatMap(f)</code>: Sequences Free computations whilst maintaining stack safety.</li>
<li><code>free.foldMap(transform, monad)</code>: Interprets the Free program using a natural transformation.</li>
</ul>
<p><strong>FreeFactory for Improved Type Inference:</strong></p>
<p>Java's type inference can struggle when chaining operations directly on <code>Free.pure()</code>:</p>
<pre><code class="language-java">// This fails to compile - Java can't infer F
Free&lt;IdKind.Witness, Integer&gt; result = Free.pure(2).map(x -&gt; x * 2); // ERROR

// Workaround: explicit type parameters (verbose)
Free&lt;IdKind.Witness, Integer&gt; result = Free.&lt;IdKind.Witness, Integer&gt;pure(2).map(x -&gt; x * 2);
</code></pre>
<p>The <code>FreeFactory&lt;F&gt;</code> class solves this by capturing the functor type parameter once:</p>
<pre><code class="language-java">// Create a factory with your functor type
FreeFactory&lt;IdKind.Witness&gt; FREE = FreeFactory.of();
// or with a monad instance for clarity:
FreeFactory&lt;IdKind.Witness&gt; FREE = FreeFactory.withMonad(IdMonad.instance());

// Now type inference works perfectly
Free&lt;IdKind.Witness, Integer&gt; result = FREE.pure(2).map(x -&gt; x * 2); // Works!

// Chain operations fluently
Free&lt;IdKind.Witness, Integer&gt; program = FREE.pure(10)
    .map(x -&gt; x + 1)
    .flatMap(x -&gt; FREE.pure(x * 2))
    .map(x -&gt; x - 5);

// Other factory methods
Free&lt;F, A&gt; pure = FREE.pure(value);
Free&lt;F, A&gt; suspended = FREE.suspend(computation);
Free&lt;F, A&gt; lifted = FREE.liftF(fa, functor);
</code></pre>
<p><code>FreeFactory</code> is particularly useful in:</p>
<ul>
<li>Test code where you build many Free programs</li>
<li>DSL implementations where type inference is important</li>
<li>Any code that chains <code>map</code>/<code>flatMap</code> operations on <code>Free.pure()</code></li>
</ul>
<div id="admonition-example-1-building-a-console-dsl" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-1-building-a-console-dsl-title">
<div class="admonition-title">
<div id="admonition-example-1-building-a-console-dsl-title">
<p>Example 1: Building a Console DSL</p>
</div>
<a class="admonition-anchor-link" href="monads/free_monad.html#admonition-example-1-building-a-console-dsl"></a>
</div>
<div>
<p>Let's build a simple DSL for console interactions. We'll define instructions, build programs, and create multiple interpreters.</p>
<h3 id="step-1-define-your-instruction-set"><a class="header" href="#step-1-define-your-instruction-set">Step 1: Define Your Instruction Set</a></h3>
<p>First, create a sealed interface representing all possible operations in your DSL:</p>
<pre><code class="language-java">public sealed interface ConsoleOp&lt;A&gt; {
    record PrintLine(String text) implements ConsoleOp&lt;Unit&gt; {}
    record ReadLine() implements ConsoleOp&lt;String&gt; {}
}

public record Unit() {
    public static final Unit INSTANCE = new Unit();
}
</code></pre>
<p>This is your vocabulary. <code>PrintLine</code> returns <code>Unit</code> (like <code>void</code>), <code>ReadLine</code> returns <code>String</code>.</p>
<h3 id="step-2-create-hkt-bridge-for-your-dsl"><a class="header" href="#step-2-create-hkt-bridge-for-your-dsl">Step 2: Create HKT Bridge for Your DSL</a></h3>
<p>To use your DSL with the Free monad, you need the HKT simulation components:</p>
<pre><code class="language-java">public interface ConsoleOpKind&lt;A&gt; extends Kind&lt;ConsoleOpKind.Witness, A&gt; {
    final class Witness {
        private Witness() {}
    }
}

public enum ConsoleOpKindHelper {
    CONSOLE;

    record ConsoleOpHolder&lt;A&gt;(ConsoleOp&lt;A&gt; op) implements ConsoleOpKind&lt;A&gt; {}

    public &lt;A&gt; Kind&lt;ConsoleOpKind.Witness, A&gt; widen(ConsoleOp&lt;A&gt; op) {
        return new ConsoleOpHolder&lt;&gt;(op);
    }

    public &lt;A&gt; ConsoleOp&lt;A&gt; narrow(Kind&lt;ConsoleOpKind.Witness, A&gt; kind) {
        return ((ConsoleOpHolder&lt;A&gt;) kind).op();
    }
}
</code></pre>
<h3 id="step-3-create-a-functor-for-your-dsl"><a class="header" href="#step-3-create-a-functor-for-your-dsl">Step 3: Create a Functor for Your DSL</a></h3>
<p>The Free monad requires a <code>Functor</code> for your instruction set:</p>
<pre><code class="language-java">public class ConsoleOpFunctor implements Functor&lt;ConsoleOpKind.Witness&gt; {
    private static final ConsoleOpKindHelper CONSOLE = ConsoleOpKindHelper.CONSOLE;

    @Override
    public &lt;A, B&gt; Kind&lt;ConsoleOpKind.Witness, B&gt; map(
            Function&lt;? super A, ? extends B&gt; f,
            Kind&lt;ConsoleOpKind.Witness, A&gt; fa) {
        ConsoleOp&lt;A&gt; op = CONSOLE.narrow(fa);
        // For immutable operations, mapping is identity
        // (actual mapping happens during interpretation)
        return (Kind&lt;ConsoleOpKind.Witness, B&gt;) fa;
    }
}
</code></pre>
<h3 id="step-4-create-dsl-helper-functions"><a class="header" href="#step-4-create-dsl-helper-functions">Step 4: Create DSL Helper Functions</a></h3>
<p>Provide convenient methods for building Free programs:</p>
<pre><code class="language-java">public class ConsoleOps {
    /** Prints a line to the console. */
    public static Free&lt;ConsoleOpKind.Witness, Unit&gt; printLine(String text) {
        ConsoleOp&lt;Unit&gt; op = new ConsoleOp.PrintLine(text);
        Kind&lt;ConsoleOpKind.Witness, Unit&gt; kindOp =
            ConsoleOpKindHelper.CONSOLE.widen(op);
        return Free.liftF(kindOp, new ConsoleOpFunctor());
    }

    /** Reads a line from the console. */
    public static Free&lt;ConsoleOpKind.Witness, String&gt; readLine() {
        ConsoleOp&lt;String&gt; op = new ConsoleOp.ReadLine();
        Kind&lt;ConsoleOpKind.Witness, String&gt; kindOp =
            ConsoleOpKindHelper.CONSOLE.widen(op);
        return Free.liftF(kindOp, new ConsoleOpFunctor());
    }

    /** Pure value in the Free monad. */
    public static &lt;A&gt; Free&lt;ConsoleOpKind.Witness, A&gt; pure(A value) {
        return Free.pure(value);
    }
}
</code></pre>
<p>Now you can build programs using familiar Java syntax:</p>
<pre><code class="language-java">Free&lt;ConsoleOpKind.Witness, Unit&gt; program =
    ConsoleOps.printLine("What is your name?")
        .flatMap(ignored -&gt;
            ConsoleOps.readLine()
                .flatMap(name -&gt;
                    ConsoleOps.printLine("Hello, " + name + "!")));
</code></pre>
<p><strong>Key Insight</strong>: At this point, <strong>nothing has executed</strong>. You've built a data structure describing what should happen.</p>
</div>
</div>
<div id="admonition-example-2-building-programs-with-map-and-flatmap" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-2-building-programs-with-map-and-flatmap-title">
<div class="admonition-title">
<div id="admonition-example-2-building-programs-with-map-and-flatmap-title">
<p>Example 2: Building Programs with map and flatMap</p>
</div>
<a class="admonition-anchor-link" href="monads/free_monad.html#admonition-example-2-building-programs-with-map-and-flatmap"></a>
</div>
<div>
<p>The Free monad supports <code>map</code> and <code>flatMap</code>, making it easy to compose programs:</p>
<pre><code class="language-java">import static org.higherkindedj.example.free.ConsoleProgram.ConsoleOps.*;

// Simple sequence
Free&lt;ConsoleOpKind.Witness, String&gt; getName =
    printLine("Enter your name:")
        .flatMap(ignored -&gt; readLine());

// Using map to transform results
Free&lt;ConsoleOpKind.Witness, String&gt; getUpperName =
    getName.map(String::toUpperCase);

// Building complex workflows
Free&lt;ConsoleOpKind.Witness, Unit&gt; greetingWorkflow =
    printLine("Welcome to the application!")
        .flatMap(ignored -&gt; getName)
        .flatMap(name -&gt; printLine("Hello, " + name + "!"))
        .flatMap(ignored -&gt; printLine("Have a great day!"));

// Calculator example with error handling
Free&lt;ConsoleOpKind.Witness, Unit&gt; calculator =
    printLine("Enter first number:")
        .flatMap(ignored1 -&gt; readLine())
        .flatMap(num1 -&gt;
            printLine("Enter second number:")
                .flatMap(ignored2 -&gt; readLine())
                .flatMap(num2 -&gt; {
                    try {
                        int sum = Integer.parseInt(num1) + Integer.parseInt(num2);
                        return printLine("Sum: " + sum);
                    } catch (NumberFormatException e) {
                        return printLine("Invalid numbers!");
                    }
                }));
</code></pre>
<p><strong>Composability</strong>: Notice how we can build <code>getName</code> once and reuse it in multiple programs. This promotes code reuse and testability.</p>
</div>
</div>
<div id="admonition-example-3-io-interpreter-for-real-execution" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-3-io-interpreter-for-real-execution-title">
<div class="admonition-title">
<div id="admonition-example-3-io-interpreter-for-real-execution-title">
<p>Example 3: IO Interpreter for Real Execution</p>
</div>
<a class="admonition-anchor-link" href="monads/free_monad.html#admonition-example-3-io-interpreter-for-real-execution"></a>
</div>
<div>
<p>Now let's create an interpreter that actually executes console operations:</p>
<pre><code class="language-java">public class IOInterpreter {
    private final Scanner scanner = new Scanner(System.in);

    public &lt;A&gt; A run(Free&lt;ConsoleOpKind.Witness, A&gt; program) {
        // Create a natural transformation from ConsoleOp to IO
        Function&lt;Kind&lt;ConsoleOpKind.Witness, ?&gt;, Kind&lt;IOKind.Witness, ?&gt;&gt; transform =
            kind -&gt; {
                ConsoleOp&lt;?&gt; op = ConsoleOpKindHelper.CONSOLE.narrow(
                    (Kind&lt;ConsoleOpKind.Witness, Object&gt;) kind);

                // Execute the instruction and wrap result in Free.pure
                Free&lt;ConsoleOpKind.Witness, ?&gt; freeResult = switch (op) {
                    case ConsoleOp.PrintLine print -&gt; {
                        System.out.println(print.text());
                        yield Free.pure(Unit.INSTANCE);
                    }
                    case ConsoleOp.ReadLine read -&gt; {
                        String line = scanner.nextLine();
                        yield Free.pure(line);
                    }
                };

                // Wrap the Free result in the target monad (IO)
                return IOKindHelper.IO.widen(new IO&lt;&gt;(freeResult));
            };

        // Interpret the program using foldMap
        Kind&lt;IOKind.Witness, A&gt; result = program.foldMap(transform, new IOMonad());
        return IOKindHelper.IO.narrow(result).value();
    }
}

// Simple IO type for the interpreter
record IO&lt;A&gt;(A value) {}

// Run the program
IOInterpreter interpreter = new IOInterpreter();
interpreter.run(greetingProgram());
// Actual console interaction happens here!
</code></pre>
<p><strong>Natural Transformation</strong>: The <code>transform</code> function is a natural transformation; it converts each <code>ConsoleOp</code> instruction into an <code>IO</code> operation whilst preserving structure.</p>
<p><strong>Critical Detail</strong>: Notice we wrap instruction results in <code>Free.pure()</code>. This is essential: the natural transformation receives <code>Kind&lt;F, Free&lt;F, A&gt;&gt;</code> and must return <code>Kind&lt;M, Free&lt;F, A&gt;&gt;</code>, not just the raw result.</p>
</div>
</div>
<div id="admonition-example-4-test-interpreter-for-pure-testing" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-4-test-interpreter-for-pure-testing-title">
<div class="admonition-title">
<div id="admonition-example-4-test-interpreter-for-pure-testing-title">
<p>Example 4: Test Interpreter for Pure Testing</p>
</div>
<a class="admonition-anchor-link" href="monads/free_monad.html#admonition-example-4-test-interpreter-for-pure-testing"></a>
</div>
<div>
<p>One of the most powerful aspects of Free monads is testability. Create a test interpreter that doesn't perform real I/O:</p>
<pre><code class="language-java">public class TestInterpreter {
    private final List&lt;String&gt; input;
    private final List&lt;String&gt; output = new ArrayList&lt;&gt;();
    private int inputIndex = 0;

    public TestInterpreter(List&lt;String&gt; input) {
        this.input = input;
    }

    public &lt;A&gt; A run(Free&lt;ConsoleOpKind.Witness, A&gt; program) {
        // Create natural transformation to TestResult
        Function&lt;Kind&lt;ConsoleOpKind.Witness, ?&gt;, Kind&lt;TestResultKind.Witness, ?&gt;&gt; transform =
            kind -&gt; {
                ConsoleOp&lt;?&gt; op = ConsoleOpKindHelper.CONSOLE.narrow(
                    (Kind&lt;ConsoleOpKind.Witness, Object&gt;) kind);

                // Simulate the instruction
                Free&lt;ConsoleOpKind.Witness, ?&gt; freeResult = switch (op) {
                    case ConsoleOp.PrintLine print -&gt; {
                        output.add(print.text());
                        yield Free.pure(Unit.INSTANCE);
                    }
                    case ConsoleOp.ReadLine read -&gt; {
                        String line = inputIndex &lt; input.size()
                            ? input.get(inputIndex++)
                            : "";
                        yield Free.pure(line);
                    }
                };

                return TestResultKindHelper.TEST.widen(new TestResult&lt;&gt;(freeResult));
            };

        Kind&lt;TestResultKind.Witness, A&gt; result =
            program.foldMap(transform, new TestResultMonad());
        return TestResultKindHelper.TEST.narrow(result).value();
    }

    public List&lt;String&gt; getOutput() {
        return output;
    }
}

// Pure test - no actual I/O!
@Test
void testGreetingProgram() {
    TestInterpreter interpreter = new TestInterpreter(List.of("Alice"));
    interpreter.run(Programs.greetingProgram());

    List&lt;String&gt; output = interpreter.getOutput();
    assertEquals(2, output.size());
    assertEquals("What is your name?", output.get(0));
    assertEquals("Hello, Alice!", output.get(1));
}
</code></pre>
<p><strong>Testability</strong>: The same <code>greetingProgram()</code> can be tested without any actual console I/O. You control inputs and verify outputs deterministically.</p>
</div>
</div>
<div id="admonition-example-5-composing-larger-programs-from-smaller-ones" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-5-composing-larger-programs-from-smaller-ones-title">
<div class="admonition-title">
<div id="admonition-example-5-composing-larger-programs-from-smaller-ones-title">
<p>Example 5: Composing Larger programs from Smaller Ones</p>
</div>
<a class="admonition-anchor-link" href="monads/free_monad.html#admonition-example-5-composing-larger-programs-from-smaller-ones"></a>
</div>
<div>
<p>The real power emerges when building complex programs from simple, reusable pieces:</p>
<pre><code class="language-java">// Reusable building blocks
Free&lt;ConsoleOpKind.Witness, String&gt; askQuestion(String question) {
    return printLine(question)
        .flatMap(ignored -&gt; readLine());
}

Free&lt;ConsoleOpKind.Witness, Unit&gt; confirmAction(String action) {
    return printLine(action + " - Are you sure? (yes/no)")
        .flatMap(ignored -&gt; readLine())
        .flatMap(response -&gt;
            response.equalsIgnoreCase("yes")
                ? printLine("Confirmed!")
                : printLine("Cancelled."));
}

// Composed program
Free&lt;ConsoleOpKind.Witness, Unit&gt; userRegistration() {
    return askQuestion("Enter username:")
        .flatMap(username -&gt;
            askQuestion("Enter email:")
                .flatMap(email -&gt;
                    confirmAction("Register user " + username)
                        .flatMap(ignored -&gt;
                            printLine("Registration complete for " + username))));
}

// Even more complex composition
Free&lt;ConsoleOpKind.Witness, List&lt;String&gt;&gt; gatherMultipleInputs(int count) {
    Free&lt;ConsoleOpKind.Witness, List&lt;String&gt;&gt; start = Free.pure(new ArrayList&lt;&gt;());

    for (int i = 0; i &lt; count; i++) {
        final int index = i;
        start = start.flatMap(list -&gt;
            askQuestion("Enter item " + (index + 1) + ":")
                .map(item -&gt; {
                    list.add(item);
                    return list;
                }));
    }

    return start;
}
</code></pre>
<p><strong>Modularity</strong>: Each function returns a <code>Free</code> program that can be:</p>
<ul>
<li>Tested independently</li>
<li>Composed with others</li>
<li>Interpreted in different ways</li>
<li>Reused across your application</li>
</ul>
</div>
</div>
<div id="admonition-example-6-using-freeliftf-for-single-operations" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-6-using-freeliftf-for-single-operations-title">
<div class="admonition-title">
<div id="admonition-example-6-using-freeliftf-for-single-operations-title">
<p>Example 6: Using Free.liftF for Single Operations</p>
</div>
<a class="admonition-anchor-link" href="monads/free_monad.html#admonition-example-6-using-freeliftf-for-single-operations"></a>
</div>
<div>
<p>The <code>liftF</code> method provides a convenient way to lift single functor operations into Free:</p>
<pre><code class="language-java">// Instead of manually creating Suspend
Free&lt;ConsoleOpKind.Witness, String&gt; createManualReadLine() {
    ConsoleOp&lt;String&gt; op = new ConsoleOp.ReadLine();
    Kind&lt;ConsoleOpKind.Witness, String&gt; kindOp =
        ConsoleOpKindHelper.CONSOLE.widen(op);
    return Free.suspend(
        new ConsoleOpFunctor().map(Free::pure, kindOp)
    );
}

// Using liftF (simpler!)
Free&lt;ConsoleOpKind.Witness, String&gt; createLiftedReadLine() {
    ConsoleOp&lt;String&gt; op = new ConsoleOp.ReadLine();
    Kind&lt;ConsoleOpKind.Witness, String&gt; kindOp =
        ConsoleOpKindHelper.CONSOLE.widen(op);
    return Free.liftF(kindOp, new ConsoleOpFunctor());
}

// Even simpler with helper method
Free&lt;ConsoleOpKind.Witness, String&gt; simpleReadLine =
    ConsoleOps.readLine();
</code></pre>
<p><strong>Best Practice</strong>: Create helper methods (like <code>ConsoleOps.readLine()</code>) that use <code>liftF</code> internally. This provides a clean API for building programs.</p>
</div>
</div>
<h2 id="when-to-use-free-monad"><a class="header" href="#when-to-use-free-monad">When to Use Free Monad</a></h2>
<h3 id="use-free-monad-when"><a class="header" href="#use-free-monad-when">Use Free Monad When:</a></h3>
<ol>
<li>
<p><strong>Building DSLs</strong>: You need a domain-specific language for your problem domain (financial calculations, workflow orchestration, build systems, etc.).</p>
</li>
<li>
<p><strong>Multiple Interpretations</strong>: The same logic needs different execution modes:</p>
<ul>
<li>Production (real database, real network)</li>
<li>Testing (mocked, pure)</li>
<li>Logging (record all operations)</li>
<li>Optimisation (analyse before execution)</li>
<li>Dry-run (validate without executing)</li>
</ul>
</li>
<li>
<p><strong>Testability is Critical</strong>: You need to test complex logic without actual side effects. Example: testing database transactions without a database.</p>
</li>
<li>
<p><strong>Program Analysis</strong>: You need to inspect, optimise, or transform programs before execution:</p>
<ul>
<li>Query optimisation</li>
<li>Batch operations</li>
<li>Caching strategies</li>
<li>Cost analysis</li>
</ul>
</li>
<li>
<p><strong>Separation of Concerns</strong>: Business logic must be decoupled from execution details. Example: workflow definition separate from workflow engine.</p>
</li>
<li>
<p><strong>Stack Safety Required</strong>: Your DSL involves deep recursion or many sequential operations (verified with 10,000+ operations).</p>
</li>
</ol>
<h3 id="avoid-free-monad-when"><a class="header" href="#avoid-free-monad-when">Avoid Free Monad When:</a></h3>
<ol>
<li>
<p><strong>Simple Effects</strong>: For straightforward side effects, use <code>IO</code>, <code>Reader</code>, or <code>State</code> directly. Free adds unnecessary complexity.</p>
</li>
<li>
<p><strong>Performance Critical</strong>: Free monads have overhead:</p>
<ul>
<li>Heap allocation for program structure</li>
<li>Interpretation overhead</li>
<li>Not suitable for hot paths or tight loops</li>
</ul>
</li>
<li>
<p><strong>Single Interpretation</strong>: If you only ever need one way to execute your program, traditional imperative code or simpler monads are clearer.</p>
</li>
<li>
<p><strong>Team Unfamiliarity</strong>: Free monads require understanding of:</p>
<ul>
<li>Algebraic data types</li>
<li>Natural transformations</li>
<li>Monadic composition</li>
</ul>
<p>If your team isn't comfortable with these concepts, simpler patterns might be more maintainable.</p>
</li>
<li>
<p><strong>Small Scale</strong>: For small scripts or simple applications, the architectural benefits don't justify the complexity.</p>
</li>
</ol>
<h3 id="comparison-with-alternatives"><a class="header" href="#comparison-with-alternatives">Comparison with Alternatives</a></h3>
<p><strong>Free Monad vs. Direct Effects</strong>:</p>
<ul>
<li>Free: Testable, multiple interpreters, program inspection</li>
<li>Direct: Simpler, better performance, easier to understand</li>
</ul>
<p><strong>Free Monad vs. Tagless Final</strong>:</p>
<ul>
<li>Free: programs are data structures, can be inspected</li>
<li>Tagless Final: Better performance, less boilerplate, but programs aren't inspectable</li>
</ul>
<p><strong>Free Monad vs. Effect Systems (like ZIO/Cats Effect)</strong>:</p>
<ul>
<li>Free: Simpler concept, custom DSLs</li>
<li>Effect Systems: More powerful, better performance, ecosystem support</li>
</ul>
<h2 id="advanced-topics"><a class="header" href="#advanced-topics">Advanced Topics</a></h2>
<h3 id="free-applicative-vs-free-monad"><a class="header" href="#free-applicative-vs-free-monad">Free Applicative vs. Free Monad</a></h3>
<div id="admonition-see-also" class="admonition admonish-tip" role="note" aria-labelledby="admonition-see-also-title">
<div class="admonition-title">
<div id="admonition-see-also-title">
<p>See Also</p>
</div>
<a class="admonition-anchor-link" href="monads/free_monad.html#admonition-see-also"></a>
</div>
<div>
<p>For comprehensive coverage of Free Applicative, see the dedicated <a href="monads/free_applicative.html">Free Applicative</a> documentation.</p>
</div>
</div>
<p>The <strong>Free Applicative</strong> is a related but distinct structure:</p>
<pre><code class="language-java">// Free Monad: Sequential, dependent operations
Free&lt;F, C&gt; sequential =
    operationA()                           // A
        .flatMap(a -&gt;                      // depends on A
            operationB(a)                  // B
                .flatMap(b -&gt;              // depends on B
                    operationC(a, b)));    // C

// Free Applicative: Independent, parallel operations
Applicative&lt;F, C&gt; parallel =
    map3(
        operationA(),                      // A (independent)
        operationB(),                      // B (independent)
        operationC(),                      // C (independent)
        (a, b, c) -&gt; combine(a, b, c)
    );
</code></pre>
<p><strong>When to use Free Applicative</strong>:</p>
<ul>
<li>Operations are <strong>independent</strong> and can run in parallel</li>
<li>You want to <strong>analyse</strong> all operations upfront (batch database queries, parallel API calls)</li>
<li><strong>Optimisation</strong>: Can reorder, batch, or parallelise operations</li>
</ul>
<p><strong>When to use Free Monad</strong>:</p>
<ul>
<li>Operations are <strong>dependent</strong> on previous results</li>
<li>Need full monadic <strong>sequencing</strong> power</li>
<li>Building workflows with conditional logic</li>
</ul>
<p><strong>Example</strong>: Fetching data from multiple independent sources</p>
<pre><code class="language-java">// Free Applicative can batch these into a single round-trip
Applicative&lt;DatabaseQuery, Report&gt; report =
    map3(
        fetchUsers(),           // Independent
        fetchOrders(),          // Independent
        fetchProducts(),        // Independent
        (users, orders, products) -&gt; generateReport(users, orders, products)
    );

// Interpreter can optimise: "SELECT * FROM users, orders, products"
</code></pre>
<h3 id="coyoneda-optimisation"><a class="header" href="#coyoneda-optimisation">Coyoneda Optimisation</a></h3>
<div id="admonition-see-also-1" class="admonition admonish-tip" role="note" aria-labelledby="admonition-see-also-1-title">
<div class="admonition-title">
<div id="admonition-see-also-1-title">
<p>See Also</p>
</div>
<a class="admonition-anchor-link" href="monads/free_monad.html#admonition-see-also-1"></a>
</div>
<div>
<p>For comprehensive coverage of Coyoneda, see the dedicated <a href="monads/coyoneda.html">Coyoneda</a> documentation.</p>
</div>
</div>
<p>The <strong>Coyoneda lemma</strong> states that every type constructor can be made into a Functor. This allows Free monads to work with non-functor instruction sets:</p>
<pre><code class="language-java">// Without Coyoneda: instruction set must be a Functor
public sealed interface DatabaseOp&lt;A&gt; {
    record Query(String sql) implements DatabaseOp&lt;ResultSet&gt; {}
    record Update(String sql) implements DatabaseOp&lt;Integer&gt; {}
}

// Must implement Functor&lt;DatabaseOp&gt; - can be tedious!

// With Coyoneda: automatic functor lifting
class Coyoneda&lt;F, A&gt; {
    Kind&lt;F, Object&gt; fa;
    Function&lt;Object, A&gt; f;

    static &lt;F, A&gt; Coyoneda&lt;F, A&gt; lift(Kind&lt;F, A&gt; fa) {
        return new Coyoneda&lt;&gt;(fa, Function.identity());
    }
}

// Now you can use any F without writing a Functor instance!
Free&lt;Coyoneda&lt;DatabaseOp, ?&gt;, Result&gt; program = ...;
</code></pre>
<p><strong>Benefits</strong>:</p>
<ul>
<li>Less boilerplate (no manual Functor implementation)</li>
<li>Works with any instruction set</li>
<li><strong>Trade-off</strong>: Slightly more complex interpretation</li>
</ul>
<p><strong>When to use</strong>: Large DSLs where writing Functor instances for every instruction type is burdensome.</p>
<h3 id="tagless-final-style-alternative-approach"><a class="header" href="#tagless-final-style-alternative-approach">Tagless Final Style (Alternative Approach)</a></h3>
<p>An alternative to Free monads is the <strong>Tagless Final</strong> encoding:</p>
<pre><code class="language-java">// Free Monad approach
sealed interface ConsoleOp&lt;A&gt; { ... }
Free&lt;ConsoleOp, Result&gt; program = ...;

// Tagless Final approach
interface Console&lt;F&gt; {
    Kind&lt;F, Unit&gt; printLine(String text);
    Kind&lt;F, String&gt; readLine();
}

&lt;F&gt; Kind&lt;F, Unit&gt; program(Console&lt;F&gt; console, Monad&lt;F&gt; monad) {
    Kind&lt;F, Unit&gt; printName = console.printLine("What is your name?");
    Kind&lt;F, String&gt; readName = monad.flatMap(ignored -&gt; console.readLine(), printName);
    return monad.flatMap(name -&gt; console.printLine("Hello, " + name + "!"), readName);
}

// Different interpreters
Kind&lt;IO.Witness, Unit&gt; prod = program(ioConsole, ioMonad);
Kind&lt;Test.Witness, Unit&gt; test = program(testConsole, testMonad);
</code></pre>
<p><strong>Tagless Final vs. Free Monad</strong>:</p>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th>Free Monad</th><th>Tagless Final</th></tr></thead><tbody>
<tr><td><strong>programs</strong></td><td>Data structures</td><td>Abstract functions</td></tr>
<tr><td><strong>Inspection</strong></td><td>✅ Can analyse before execution</td><td>❌ Cannot inspect</td></tr>
<tr><td><strong>Performance</strong></td><td>Slower (interpretation overhead)</td><td>Faster (direct execution)</td></tr>
<tr><td><strong>Boilerplate</strong></td><td>More (HKT bridges, helpers)</td><td>Less (just interfaces)</td></tr>
<tr><td><strong>Flexibility</strong></td><td>✅ Multiple interpreters, transformations</td><td>✅ Multiple interpreters</td></tr>
<tr><td><strong>Learning Curve</strong></td><td>Steeper</td><td>Moderate</td></tr>
</tbody></table>
</div>
<p><strong>When to use Tagless Final</strong>:</p>
<ul>
<li>Performance matters</li>
<li>Don't need program inspection</li>
<li>Prefer less boilerplate</li>
</ul>
<p><strong>When to use Free Monad</strong>:</p>
<ul>
<li>Need to analyse/optimise programs before execution</li>
<li>Want programs as first-class values</li>
<li>Building complex DSLs with transformations</li>
</ul>
<h2 id="performance-characteristics-1"><a class="header" href="#performance-characteristics-1">Performance Characteristics</a></h2>
<p>Understanding the performance trade-offs of Free monads is crucial for production use:</p>
<p><strong>Stack Safety</strong>: O(1) stack space regardless of program depth</p>
<ul>
<li>Uses Higher-Kinded-J's <code>Trampoline</code> monad internally for <code>foldMap</code></li>
<li>Demonstrates library composability: Free uses Trampoline for stack safety</li>
<li>Verified with 10,000+ sequential operations without stack overflow</li>
</ul>
<p><strong>Heap Allocation</strong>: O(n) where n is program size</p>
<ul>
<li>Each <code>flatMap</code> creates a <code>FlatMapped</code> node</li>
<li>Each <code>suspend</code> creates a <code>Suspend</code> node</li>
<li><strong>Consideration</strong>: For very large programs (millions of operations), this could be significant</li>
</ul>
<p><strong>Interpretation Time</strong>: O(n) where n is program size</p>
<ul>
<li>Each operation must be pattern-matched and interpreted</li>
<li>Additional indirection compared to direct execution</li>
<li><strong>Rough estimate</strong>: 2-10x slower than direct imperative code (depends on interpreter complexity)</li>
</ul>
<p><strong>Optimisation Strategies</strong>:</p>
<ol>
<li>
<p><strong>Batch Operations</strong>: Accumulate independent operations and execute in bulk</p>
<pre><code class="language-java">// Instead of 1000 individual database inserts
Free&lt;DB, Unit&gt; manyInserts = ...;

// Batch into single multi-row insert
interpreter.optimise(program); // Detects pattern, batches
</code></pre>
</li>
<li>
<p><strong>Fusion</strong>: Combine consecutive <code>map</code> operations</p>
<pre><code class="language-java">program.map(f).map(g).map(h)
// Optimiser fuses to: program.map(f.andThen(g).andThen(h))
</code></pre>
</li>
<li>
<p><strong>Short-Circuiting</strong>: Detect early termination</p>
<pre><code class="language-java">// If program returns early, skip remaining operations
</code></pre>
</li>
<li>
<p><strong>Caching</strong>: Memoize pure computations</p>
<pre><code class="language-java">// Cache results of expensive pure operations
</code></pre>
</li>
</ol>
<p><strong>Benchmarks</strong> (relative to direct imperative code):</p>
<ul>
<li>Simple programs (&lt; 100 operations): 2-3x slower</li>
<li>Complex programs (1000+ operations): 3-5x slower</li>
<li>With optimisation: Can approach parity for batch operations</li>
</ul>
<h2 id="implementation-notes-1"><a class="header" href="#implementation-notes-1">Implementation Notes</a></h2>
<p>The <code>foldMap</code> method leverages Higher-Kinded-J's own <code>Trampoline</code> monad to ensure stack-safe execution. This elegant design demonstrates that the library's abstractions are practical and composable:</p>
<pre><code class="language-java">public &lt;M&gt; Kind&lt;M, A&gt; foldMap(
        Function&lt;Kind&lt;F, ?&gt;, Kind&lt;M, ?&gt;&gt; transform,
        Monad&lt;M&gt; monad) {
    // Delegate to Trampoline for stack-safe execution
    return interpretFree(this, transform, monad).run();
}

private static &lt;F, M, A&gt; Trampoline&lt;Kind&lt;M, A&gt;&gt; interpretFree(
        Free&lt;F, A&gt; free,
        Function&lt;Kind&lt;F, ?&gt;, Kind&lt;M, ?&gt;&gt; transform,
        Monad&lt;M&gt; monad) {

    return switch (free) {
        case Pure&lt;F, A&gt; pure -&gt;
            // Terminal case: lift the pure value into the target monad
            Trampoline.done(monad.of(pure.value()));

        case Suspend&lt;F, A&gt; suspend -&gt; {
            // Transform the suspended computation and recursively interpret
            Kind&lt;M, Free&lt;F, A&gt;&gt; transformed =
                (Kind&lt;M, Free&lt;F, A&gt;&gt;) transform.apply(suspend.computation());

            yield Trampoline.done(
                monad.flatMap(
                    innerFree -&gt; interpretFree(innerFree, transform, monad).run(),
                    transformed));
        }

        case FlatMapped&lt;F, ?, A&gt; flatMapped -&gt; {
            // Handle FlatMapped by deferring the interpretation
            FlatMapped&lt;F, Object, A&gt; fm = (FlatMapped&lt;F, Object, A&gt;) flatMapped;

            yield Trampoline.defer(() -&gt;
                interpretFree(fm.sub(), transform, monad)
                    .map(kindOfX -&gt;
                        monad.flatMap(
                            x -&gt; {
                                Free&lt;F, A&gt; next = fm.continuation().apply(x);
                                return interpretFree(next, transform, monad).run();
                            },
                            kindOfX)));
        }
    };
}
</code></pre>
<p><strong>Key Design Decisions</strong>:</p>
<ol>
<li>
<p><strong>Trampoline Integration</strong>: Uses <code>Trampoline.done()</code> for terminal cases and <code>Trampoline.defer()</code> for recursive cases, ensuring stack safety.</p>
</li>
<li>
<p><strong>Library Composability</strong>: Demonstrates that Higher-Kinded-J's abstractions are practical; Free monad uses Trampoline internally.</p>
</li>
<li>
<p><strong>Pattern Matching</strong>: Uses sealed interface with switch expressions for type-safe case handling.</p>
</li>
<li>
<p><strong>Separation of Concerns</strong>: Trampoline handles stack safety; Free handles DSL interpretation.</p>
</li>
<li>
<p><strong>Type Safety</strong>: Uses careful casting to maintain type safety whilst leveraging Trampoline's proven stack-safe execution.</p>
</li>
</ol>
<p><strong>Benefits of Using Trampoline</strong>:</p>
<ul>
<li>Single source of truth for stack-safe recursion</li>
<li>Proven implementation with 100% test coverage</li>
<li>Elegant demonstration of library cohesion</li>
<li>Improvements to Trampoline automatically benefit Free monad</li>
</ul>
<h2 id="comparison-with-traditional-java-patterns-1"><a class="header" href="#comparison-with-traditional-java-patterns-1">Comparison with Traditional Java Patterns</a></h2>
<p>Let's see how Free monads compare to familiar Java patterns:</p>
<h3 id="strategy-pattern"><a class="header" href="#strategy-pattern">Strategy Pattern</a></h3>
<p><strong>Traditional Strategy</strong>:</p>
<pre><code class="language-java">interface SortStrategy {
    void sort(List&lt;Integer&gt; list);
}

class QuickSort implements SortStrategy { ... }
class MergeSort implements SortStrategy { ... }

// Choose algorithm at runtime
SortStrategy strategy = useQuickSort ? new QuickSort() : new MergeSort();
strategy.sort(myList);
</code></pre>
<p><strong>Free Monad Equivalent</strong>:</p>
<pre><code class="language-java">sealed interface SortOp&lt;A&gt; {
    record Compare(int i, int j) implements SortOp&lt;Boolean&gt; {}
    record Swap(int i, int j) implements SortOp&lt;Unit&gt; {}
}

Free&lt;SortOp, Unit&gt; quickSort(List&lt;Integer&gt; list) {
    // Build program as data
    return ...;
}

// Multiple interpreters
interpreter1.run(program); // In-memory sort
interpreter2.run(program); // Log operations
interpreter3.run(program); // Visualise algorithm
</code></pre>
<p><strong>Advantage of Free</strong>: The <strong>entire algorithm</strong> is a data structure that can be inspected, optimised, or visualised.</p>
<h3 id="command-pattern"><a class="header" href="#command-pattern">Command Pattern</a></h3>
<p><strong>Traditional Command</strong>:</p>
<pre><code class="language-java">interface Command {
    void execute();
}

class SendEmailCommand implements Command { ... }
class SaveToDBCommand implements Command { ... }

List&lt;Command&gt; commands = List.of(
    new SendEmailCommand(...),
    new SaveToDBCommand(...)
);

commands.forEach(Command::execute);
</code></pre>
<p><strong>Free Monad Equivalent</strong>:</p>
<pre><code class="language-java">sealed interface AppOp&lt;A&gt; {
    record SendEmail(String to, String body) implements AppOp&lt;Receipt&gt; {}
    record SaveToDB(Data data) implements AppOp&lt;Id&gt; {}
}

Free&lt;AppOp, Result&gt; workflow =
    sendEmail("user@example.com", "Welcome!")
        .flatMap(receipt -&gt; saveToDatabase(receipt))
        .flatMap(id -&gt; sendNotification(id));

// One program, many interpreters
productionInterpreter.run(workflow); // Real execution
testInterpreter.run(workflow);       // Pure testing
loggingInterpreter.run(workflow);    // Audit trail
</code></pre>
<p><strong>Advantage of Free</strong>: Commands compose with <code>flatMap</code>, results flow between commands, and you get multiple interpreters for free.</p>
<h3 id="observer-pattern"><a class="header" href="#observer-pattern">Observer Pattern</a></h3>
<p><strong>Traditional Observer</strong>:</p>
<pre><code class="language-java">interface Observer {
    void update(Event event);
}

class Logger implements Observer { ... }
class Notifier implements Observer { ... }

subject.registerObserver(logger);
subject.registerObserver(notifier);
subject.notifyObservers(event);
</code></pre>
<p><strong>Free Monad Equivalent</strong>:</p>
<pre><code class="language-java">sealed interface EventOp&lt;A&gt; {
    record Emit(Event event) implements EventOp&lt;Unit&gt; {}
    record React(Event event) implements EventOp&lt;Unit&gt; {}
}

Free&lt;EventOp, Unit&gt; eventStream =
    emit(userLoggedIn)
        .flatMap(ignored -&gt; emit(pageViewed))
        .flatMap(ignored -&gt; emit(itemPurchased));

// Different observation strategies
loggingInterpreter.run(eventStream);     // Log to file
analyticsInterpreter.run(eventStream);   // Send to analytics
testInterpreter.run(eventStream);        // Collect for assertions
</code></pre>
<p><strong>Advantage of Free</strong>: Event streams are first-class values that can be composed, transformed, and replayed.</p>
<h2 id="summary-21"><a class="header" href="#summary-21">Summary</a></h2>
<p>The Free monad provides a powerful abstraction for building domain-specific languages in Java:</p>
<ul>
<li><strong>Separation of Concerns</strong>: Program description (data) vs. execution (interpreters)</li>
<li><strong>Testability</strong>: Pure testing without actual side effects</li>
<li><strong>Flexibility</strong>: Multiple interpreters for the same program</li>
<li><strong>Stack Safety</strong>: Handles deep recursion without stack overflow (verified with 10,000+ operations)</li>
<li><strong>Composability</strong>: Build complex programs from simple building blocks</li>
</ul>
<p><strong>When to use</strong>:</p>
<ul>
<li>Building DSLs</li>
<li>Need multiple interpretations</li>
<li>Testability is critical</li>
<li>Program analysis/optimisation required</li>
</ul>
<p><strong>When to avoid</strong>:</p>
<ul>
<li>Performance-critical code</li>
<li>Simple, single-interpretation effects</li>
<li>Team unfamiliar with advanced functional programming</li>
</ul>
<p>For detailed implementation examples and complete working code, see:</p>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/free/ConsoleProgram.java">ConsoleProgram.java</a> - Complete DSL with multiple interpreters</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/test/java/org/higherkindedj/hkt/free/FreeMonadTest.java">FreeMonadTest.java</a> - Comprehensive test suite including monad laws and stack safety</li>
</ul>
<p>The Free monad represents a sophisticated approach to building composable, testable, and maintainable programs in Java. Whilst it requires understanding of advanced functional programming concepts, it pays dividends in large-scale applications where flexibility and testability are paramount.</p>
<hr />
<div id="admonition-further-reading" class="admonition admonish-tip" role="note" aria-labelledby="admonition-further-reading-title">
<div class="admonition-title">
<div id="admonition-further-reading-title">
<p>Further Reading</p>
</div>
<a class="admonition-anchor-link" href="monads/free_monad.html#admonition-further-reading"></a>
</div>
<div>
<p>For deeper exploration of Free monads and their applications:</p>
<ul>
<li><strong>Gabriel Gonzalez</strong>: <a href="https://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html">Why free monads matter</a> - An intuitive introduction to the concept</li>
<li><strong>Runar Bjarnason</strong>: <a href="https://blog.higher-order.com/assets/trampolines.pdf">Stackless Scala With Free Monads</a> - Stack-safe execution patterns</li>
<li><strong>Cats Documentation</strong>: <a href="https://typelevel.org/cats/datatypes/freemonad.html">Free Monad</a> - Scala implementation and examples</li>
<li><strong>John A De Goes</strong>: <a href="https://degoes.net/articles/modern-fp-part-2">Modern Functional Programming (Part 2)</a> - Practical applications in real systems</li>
</ul>
<p><strong>Related Higher-Kinded-J Documentation:</strong></p>
<ul>
<li><a href="monads/../functional/natural_transformation.html">Natural Transformation</a> - Polymorphic functions used for Free monad interpretation</li>
<li><a href="monads/free_applicative.html">Free Applicative</a> - For independent computations that can run in parallel</li>
<li><a href="monads/coyoneda.html">Coyoneda</a> - Automatic Functor instances and map fusion</li>
</ul>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="monads/trampoline_monad.html">Trampoline</a>
<strong>Next:</strong> <a href="monads/free_applicative.html">Free Applicative</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="free-applicative-1"><a class="header" href="#free-applicative-1">Free Applicative</a></h1>
<h2 id="independent-computations-and-parallel-composition"><a class="header" href="#independent-computations-and-parallel-composition"><em>Independent Computations and Parallel Composition</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="monads/free_applicative.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>The difference between Free Monad (sequential) and Free Applicative (independent)</li>
<li>When to choose Free Applicative over Free Monad</li>
<li>Building programs with independent computations</li>
<li>Interpreting Free Applicative programs with natural transformations</li>
<li>Enabling parallel execution, batching, and static analysis</li>
<li>Validation patterns that accumulate all errors</li>
</ul>
</div>
</div>
<div id="admonition-hands-on-practice" class="admonition admonish-note" role="note" aria-labelledby="admonition-hands-on-practice-title">
<div class="admonition-title">
<div id="admonition-hands-on-practice-title">
<p>Hands On Practice</p>
</div>
<a class="admonition-anchor-link" href="monads/free_applicative.html#admonition-hands-on-practice"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/coretypes/Tutorial10_FreeApplicative.java">Tutorial10_FreeApplicative.java</a></p>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code</p>
</div>
<a class="admonition-anchor-link" href="monads/free_applicative.html#admonition-see-example-code"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/test/java/org/higherkindedj/hkt/free_ap/FreeApTest.java">FreeApTest.java</a> - Comprehensive test suite</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/test/java/org/higherkindedj/hkt/free_ap/FreeApApplicativeTest.java">FreeApApplicativeTest.java</a> - Applicative law verification</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/free_ap/FreeApplicativeExample.java">FreeApplicativeExample.java</a> - Practical examples</li>
</ul>
</div>
</div>
<h2 id="purpose-9"><a class="header" href="#purpose-9">Purpose</a></h2>
<p>The <strong>Free Applicative</strong> (<code>FreeAp</code>) is the applicative counterpart to the <a href="monads/free_monad.html">Free Monad</a>. Whilst the Free Monad captures <strong>sequential, dependent</strong> computations, Free Applicative captures <strong>independent</strong> computations that can potentially run in parallel.</p>
<h3 id="the-key-distinction"><a class="header" href="#the-key-distinction">The Key Distinction</a></h3>
<p>Consider fetching a user and their posts:</p>
<p><strong>With Free Monad (sequential, dependent):</strong></p>
<pre><code class="language-java">// Each step depends on the previous result
Free&lt;DbOp, UserProfile&gt; program =
    getUser(userId)
        .flatMap(user -&gt;              // Must wait for user
            getPosts(user.id())       // Uses user.id() from previous step
                .flatMap(posts -&gt;
                    Free.pure(new UserProfile(user, posts))));
</code></pre>
<p><strong>With Free Applicative (independent):</strong></p>
<pre><code class="language-java">// Both fetches are independent - neither needs the other's result
FreeAp&lt;DbOp, UserProfile&gt; program =
    FreeAp.lift(getUser(userId))
        .map2(
            FreeAp.lift(getPosts(userId)),  // Doesn't depend on getUser result
            UserProfile::new
        );
</code></pre>
<p>The Free Applicative version makes it explicit that the two fetches are <strong>independent</strong>. A smart interpreter can execute them in parallel or batch them into a single database query.</p>
<h2 id="free-monad-vs-free-applicative"><a class="header" href="#free-monad-vs-free-applicative">Free Monad vs Free Applicative</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th>Free Monad</th><th>Free Applicative</th></tr></thead><tbody>
<tr><td><strong>Composition</strong></td><td>Sequential, dependent</td><td>Independent, parallel</td></tr>
<tr><td><strong>Core operation</strong></td><td><code>flatMap: A -&gt; Free[F, B]</code></td><td><code>ap: FreeAp[F, A-&gt;B] x FreeAp[F, A]</code></td></tr>
<tr><td><strong>Structure</strong></td><td>Tree (one branch at a time)</td><td>DAG (multiple independent branches)</td></tr>
<tr><td><strong>Static analysis</strong></td><td>Cannot see full structure ahead</td><td>Full structure visible before interpretation</td></tr>
<tr><td><strong>Parallelism</strong></td><td>Not possible (each step depends on previous)</td><td>Natural fit (independent computations)</td></tr>
<tr><td><strong>Use case</strong></td><td>Workflows with conditional logic</td><td>Validation, parallel fetches, batching</td></tr>
</tbody></table>
</div><div id="admonition-choosing-between-them" class="admonition admonish-note" role="note" aria-labelledby="admonition-choosing-between-them-title">
<div class="admonition-title">
<div id="admonition-choosing-between-them-title">
<p>Choosing Between Them</p>
</div>
<a class="admonition-anchor-link" href="monads/free_applicative.html#admonition-choosing-between-them"></a>
</div>
<div>
<p>Ask yourself: "Does step B need the <strong>result</strong> of step A?"</p>
<ul>
<li><strong>Yes</strong> -&gt; Use Free Monad (<code>flatMap</code>)</li>
<li><strong>No</strong> -&gt; Use Free Applicative (<code>map2</code>, <code>map3</code>, etc.)</li>
</ul>
</div>
</div>
<h2 id="core-structure"><a class="header" href="#core-structure">Core Structure</a></h2>
<p><code>FreeAp&lt;F, A&gt;</code> is a sealed interface with three constructors:</p>
<pre><code class="language-java">public sealed interface FreeAp&lt;F, A&gt; permits FreeAp.Pure, FreeAp.Lift, FreeAp.Ap {

    // A completed computation with a value
    record Pure&lt;F, A&gt;(A value) implements FreeAp&lt;F, A&gt; {}

    // A suspended single operation in F
    record Lift&lt;F, A&gt;(Kind&lt;F, A&gt; fa) implements FreeAp&lt;F, A&gt; {}

    // Application: independent function and argument computations
    record Ap&lt;F, X, A&gt;(
        FreeAp&lt;F, Function&lt;X, A&gt;&gt; ff,  // Computation producing a function
        FreeAp&lt;F, X&gt; fa                 // Computation producing a value
    ) implements FreeAp&lt;F, A&gt; {}
}
</code></pre>
<p>The crucial insight is in <code>Ap</code>: both <code>ff</code> and <code>fa</code> are <strong>independent</strong>. Neither depends on the other's result, which is what enables parallelism and static analysis.</p>
<h2 id="basic-usage-8"><a class="header" href="#basic-usage-8">Basic Usage</a></h2>
<h3 id="creating-freeap-values"><a class="header" href="#creating-freeap-values">Creating FreeAp Values</a></h3>
<pre><code class="language-java">// Pure value (no effects)
FreeAp&lt;MyOp, Integer&gt; pure = FreeAp.pure(42);

// Lift a single instruction
FreeAp&lt;MyOp, User&gt; userFetch = FreeAp.lift(new GetUser(userId));

// Map over a FreeAp
FreeAp&lt;MyOp, String&gt; userName = userFetch.map(User::name);
</code></pre>
<h3 id="combining-independent-computations"><a class="header" href="#combining-independent-computations">Combining Independent Computations</a></h3>
<p>The <code>map2</code> method combines two independent computations:</p>
<pre><code class="language-java">FreeAp&lt;DbOp, User&gt; userFetch = FreeAp.lift(new GetUser(1));
FreeAp&lt;DbOp, List&lt;Post&gt;&gt; postsFetch = FreeAp.lift(new GetPosts(1));

// Combine them - these are INDEPENDENT
FreeAp&lt;DbOp, UserProfile&gt; profile = userFetch.map2(
    postsFetch,
    (user, posts) -&gt; new UserProfile(user, posts)
);
</code></pre>
<p>For more values, chain <code>map2</code> or use the applicative instance:</p>
<pre><code class="language-java">FreeApApplicative&lt;DbOp&gt; applicative = new FreeApApplicative&lt;&gt;();

// Combine three independent fetches
FreeAp&lt;DbOp, Dashboard&gt; dashboard = applicative.map3(
    FreeAp.lift(new GetUser(1)),
    FreeAp.lift(new GetPosts(1)),
    FreeAp.lift(new GetNotifications(1)),
    Dashboard::new
);
</code></pre>
<h3 id="interpreting-with-foldmap"><a class="header" href="#interpreting-with-foldmap">Interpreting with foldMap</a></h3>
<p>To execute a <code>FreeAp</code> program, provide a natural transformation and an <code>Applicative</code> instance:</p>
<pre><code class="language-java">// Natural transformation: DbOp ~&gt; IO
Natural&lt;DbOpKind.Witness, IOKind.Witness&gt; interpreter = fa -&gt; {
    DbOp&lt;?&gt; op = DB_OP.narrow(fa);
    return switch (op) {
        case GetUser g -&gt; IO.widen(IO.of(() -&gt; database.findUser(g.id())));
        case GetPosts g -&gt; IO.widen(IO.of(() -&gt; database.findPosts(g.userId())));
        case GetNotifications g -&gt; IO.widen(IO.of(() -&gt; database.findNotifications(g.userId())));
    };
};

// Interpret the program
FreeAp&lt;DbOp, Dashboard&gt; program = ...;
Kind&lt;IOKind.Witness, Dashboard&gt; result = program.foldMap(interpreter, ioApplicative);
</code></pre>
<h2 id="parallel-execution-3"><a class="header" href="#parallel-execution-3">Parallel Execution</a></h2>
<p>The power of Free Applicative emerges when the target <code>Applicative</code> supports parallelism. Consider using <code>CompletableFuture</code>:</p>
<pre><code class="language-java">// Interpreter to CompletableFuture (can run in parallel)
Natural&lt;DbOpKind.Witness, CFKind.Witness&gt; parallelInterpreter = fa -&gt; {
    DbOp&lt;?&gt; op = DB_OP.narrow(fa);
    return switch (op) {
        case GetUser g -&gt; CF.widen(
            CompletableFuture.supplyAsync(() -&gt; database.findUser(g.id()))
        );
        case GetPosts g -&gt; CF.widen(
            CompletableFuture.supplyAsync(() -&gt; database.findPosts(g.userId()))
        );
    };
};

// When interpreted, GetUser and GetPosts can run in parallel!
FreeAp&lt;DbOp, UserProfile&gt; program = userFetch.map2(postsFetch, UserProfile::new);
Kind&lt;CFKind.Witness, UserProfile&gt; future = program.foldMap(parallelInterpreter, cfApplicative);
</code></pre>
<p>Because the Free Applicative structure makes independence explicit, the <code>CompletableFuture</code> applicative can start both operations immediately rather than waiting for one to complete.</p>
<h2 id="static-analysis-1"><a class="header" href="#static-analysis-1">Static Analysis</a></h2>
<p>Unlike Free Monad, Free Applicative programs can be analysed before execution. The <code>analyze</code> method (an alias for <code>foldMap</code>) emphasises this capability:</p>
<pre><code class="language-java">// Count operations before executing
Natural&lt;DbOpKind.Witness, ConstKind.Witness&lt;Integer&gt;&gt; counter = fa -&gt; {
    return CONST.widen(Const.of(1));  // Each operation counts as 1
};

FreeAp&lt;DbOp, Dashboard&gt; program = ...;
Kind&lt;ConstKind.Witness&lt;Integer&gt;, Dashboard&gt; analysis =
    program.analyze(counter, constApplicative);

int operationCount = CONST.narrow(analysis).value();
System.out.println("Program will execute " + operationCount + " operations");
</code></pre>
<p>This is useful for:</p>
<ul>
<li><strong>Query optimisation</strong>: Batch similar database operations</li>
<li><strong>Cost estimation</strong>: Calculate resource usage before execution</li>
<li><strong>Validation</strong>: Check program structure meets constraints</li>
<li><strong>Logging</strong>: Record what operations will be performed</li>
</ul>
<h2 id="validation-with-error-accumulation-1"><a class="header" href="#validation-with-error-accumulation-1">Validation with Error Accumulation</a></h2>
<p>Free Applicative is excellent for validation that should report <strong>all</strong> errors, not just the first:</p>
<pre><code class="language-java">// Define validation operations
sealed interface ValidationOp&lt;A&gt; {
    record ValidateEmail(String email) implements ValidationOp&lt;String&gt; {}
    record ValidateAge(int age) implements ValidationOp&lt;Integer&gt; {}
    record ValidateName(String name) implements ValidationOp&lt;String&gt; {}
}

// Build validation program
FreeAp&lt;ValidationOp, User&gt; validateUser(String name, String email, int age) {
    return FreeAp.lift(new ValidateName(name)).map2(
        FreeAp.lift(new ValidateEmail(email)).map2(
            FreeAp.lift(new ValidateAge(age)),
            (e, a) -&gt; new Pair&lt;&gt;(e, a)
        ),
        (n, pair) -&gt; new User(n, pair.first(), pair.second())
    );
}

// Interpreter to Validated (accumulates all errors)
Natural&lt;ValidationOpKind.Witness, ValidatedKind.Witness&lt;List&lt;String&gt;&gt;&gt; interpreter = fa -&gt; {
    ValidationOp&lt;?&gt; op = VALIDATION_OP.narrow(fa);
    return switch (op) {
        case ValidateName v -&gt; VALIDATED.widen(
            v.name().length() &gt;= 2
                ? Validated.valid(v.name())
                : Validated.invalid(List.of("Name must be at least 2 characters"))
        );
        case ValidateEmail v -&gt; VALIDATED.widen(
            v.email().contains("@")
                ? Validated.valid(v.email())
                : Validated.invalid(List.of("Invalid email format"))
        );
        case ValidateAge v -&gt; VALIDATED.widen(
            v.age() &gt;= 0 &amp;&amp; v.age() &lt;= 150
                ? Validated.valid(v.age())
                : Validated.invalid(List.of("Age must be between 0 and 150"))
        );
    };
}

// Execute validation
FreeAp&lt;ValidationOp, User&gt; program = validateUser("X", "invalid", -5);
Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, User&gt; result =
    program.foldMap(interpreter, validatedApplicative);

// Result: Invalid(["Name must be at least 2 characters", "Invalid email format", "Age must be between 0 and 150"])
// All three errors are reported!
</code></pre>
<h2 id="retracting-to-the-original-applicative"><a class="header" href="#retracting-to-the-original-applicative">Retracting to the Original Applicative</a></h2>
<p>If your instruction type <code>F</code> is already an <code>Applicative</code>, you can "retract" back to it:</p>
<pre><code class="language-java">FreeAp&lt;IOKind.Witness, String&gt; program = ...;

// Retract: FreeAp[IO, A] -&gt; IO[A]
Kind&lt;IOKind.Witness, String&gt; io = program.retract(ioApplicative);

// Equivalent to:
Kind&lt;IOKind.Witness, String&gt; io = program.foldMap(Natural.identity(), ioApplicative);
</code></pre>
<h2 id="applicative-laws"><a class="header" href="#applicative-laws">Applicative Laws</a></h2>
<p><code>FreeAp</code> satisfies the applicative laws by construction:</p>
<ol>
<li><strong>Identity</strong>: <code>pure(id).ap(fa) == fa</code></li>
<li><strong>Homomorphism</strong>: <code>pure(f).ap(pure(x)) == pure(f(x))</code></li>
<li><strong>Interchange</strong>: <code>ff.ap(pure(x)) == pure(f -&gt; f(x)).ap(ff)</code></li>
<li><strong>Composition</strong>: <code>pure(.).ap(ff).ap(fg).ap(fa) == ff.ap(fg.ap(fa))</code></li>
</ol>
<p>These laws ensure that combining computations behaves predictably.</p>
<h2 id="when-to-use-free-applicative"><a class="header" href="#when-to-use-free-applicative">When to Use Free Applicative</a></h2>
<h3 id="good-use-cases-1"><a class="header" href="#good-use-cases-1">Good Use Cases</a></h3>
<ol>
<li><strong>Parallel data fetching</strong>: Multiple independent API calls or database queries</li>
<li><strong>Validation</strong>: Accumulate all validation errors rather than failing on first</li>
<li><strong>Batching</strong>: Combine similar operations into bulk requests</li>
<li><strong>Static analysis</strong>: Inspect program structure before execution</li>
<li><strong>Cost estimation</strong>: Calculate resource requirements upfront</li>
</ol>
<h3 id="when-free-monad-is-better"><a class="header" href="#when-free-monad-is-better">When Free Monad is Better</a></h3>
<ol>
<li><strong>Conditional logic</strong>: "If user is admin, do X, otherwise do Y"</li>
<li><strong>Sequential dependencies</strong>: "Use the user ID from step 1 in step 2"</li>
<li><strong>Early termination</strong>: "Stop processing if validation fails"</li>
</ol>
<h3 id="combining-both"><a class="header" href="#combining-both">Combining Both</a></h3>
<p>In practice, you might use both. Free Applicative for independent parts, Free Monad for the sequential orchestration:</p>
<pre><code class="language-java">// Free Applicative: independent fetches
FreeAp&lt;DbOp, UserData&gt; fetchUserData = userFetch.map2(postsFetch, UserData::new);

// Free Monad: sequential workflow that uses the fetched data
Free&lt;WorkflowOp, Result&gt; workflow =
    liftFreeAp(fetchUserData)               // Run independent fetches
        .flatMap(userData -&gt;                 // Then use the result
            processUser(userData)            // This depends on fetchUserData
                .flatMap(processed -&gt;
                    saveResult(processed))); // This depends on processUser
</code></pre>
<h2 id="summary-22"><a class="header" href="#summary-22">Summary</a></h2>
<p>Free Applicative provides:</p>
<ul>
<li><strong>Independence</strong>: Computations don't depend on each other's results</li>
<li><strong>Parallelism</strong>: Smart interpreters can execute operations concurrently</li>
<li><strong>Static analysis</strong>: Full program structure visible before execution</li>
<li><strong>Error accumulation</strong>: Collect all errors rather than failing fast</li>
<li><strong>Batching potential</strong>: Similar operations can be combined</li>
</ul>
<p>Use Free Applicative when your computations are independent; use Free Monad when they have sequential dependencies. Often the best solution combines both.</p>
<hr />
<div id="admonition-further-reading" class="admonition admonish-tip" role="note" aria-labelledby="admonition-further-reading-title">
<div class="admonition-title">
<div id="admonition-further-reading-title">
<p>Further Reading</p>
</div>
<a class="admonition-anchor-link" href="monads/free_applicative.html#admonition-further-reading"></a>
</div>
<div>
<ul>
<li><strong>Functional Programming in Scala</strong> (Red Book): Chapter 12 covers applicative functors and their relationship to monads</li>
<li><strong>Cats Documentation</strong>: <a href="https://typelevel.org/cats/datatypes/freeapplicative.html">Free Applicative</a> - Scala implementation with examples</li>
</ul>
</div>
</div>
<div id="admonition-hands-on-learning" class="admonition admonish-info" role="note" aria-labelledby="admonition-hands-on-learning-title">
<div class="admonition-title">
<div id="admonition-hands-on-learning-title">
<p>Hands-On Learning</p>
</div>
<a class="admonition-anchor-link" href="monads/free_applicative.html#admonition-hands-on-learning"></a>
</div>
<div>
<p>Practice Free Applicative in <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/coretypes/Tutorial10_FreeApplicative.java">Tutorial 10: Free Applicative</a> (6 exercises, ~12 minutes).</p>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="monads/free_monad.html">Free</a>
<strong>Next:</strong> <a href="monads/coyoneda.html">Coyoneda</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="coyoneda-1"><a class="header" href="#coyoneda-1">Coyoneda</a></h1>
<h2 id="the-free-functor-and-map-fusion"><a class="header" href="#the-free-functor-and-map-fusion"><em>The Free Functor and Map Fusion</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="monads/coyoneda.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>What Coyoneda is and why it's called the "free functor"</li>
<li>How Coyoneda provides automatic Functor instances for any type constructor</li>
<li>The map fusion optimisation and how it works</li>
<li>Using Coyoneda with Free monads to simplify DSL definitions</li>
<li>The lift and lower pattern</li>
<li>When Coyoneda improves performance</li>
</ul>
</div>
</div>
<div id="admonition-hands-on-practice" class="admonition admonish-note" role="note" aria-labelledby="admonition-hands-on-practice-title">
<div class="admonition-title">
<div id="admonition-hands-on-practice-title">
<p>Hands On Practice</p>
</div>
<a class="admonition-anchor-link" href="monads/coyoneda.html#admonition-hands-on-practice"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/coretypes/Tutorial09_Coyoneda.java">Tutorial09_Coyoneda.java</a></p>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code</p>
</div>
<a class="admonition-anchor-link" href="monads/coyoneda.html#admonition-see-example-code"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/test/java/org/higherkindedj/hkt/coyoneda/CoyonedaTest.java">CoyonedaTest.java</a> - Comprehensive test suite</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/test/java/org/higherkindedj/hkt/coyoneda/CoyonedaFunctorTest.java">CoyonedaFunctorTest.java</a> - Functor law verification</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/coyoneda/CoyonedaExample.java">CoyonedaExample.java</a> - Practical examples</li>
</ul>
</div>
</div>
<h2 id="purpose-10"><a class="header" href="#purpose-10">Purpose</a></h2>
<p>Coyoneda solves two practical problems:</p>
<ol>
<li>
<p><strong>Automatic Functor instances</strong>: Any type constructor <code>F</code> can be wrapped in Coyoneda, which gives it a Functor instance for free, even if <code>F</code> itself doesn't have one.</p>
</li>
<li>
<p><strong>Map fusion</strong>: Multiple consecutive <code>map</code> operations are automatically fused into a single function composition, reducing overhead.</p>
</li>
</ol>
<h3 id="the-problem-coyoneda-solves"><a class="header" href="#the-problem-coyoneda-solves">The Problem Coyoneda Solves</a></h3>
<p>When building Free monads, each instruction type needs a Functor instance. This can be tedious:</p>
<pre><code class="language-java">// Without Coyoneda: must implement Functor for every DSL
sealed interface DatabaseOp&lt;A&gt; {
    record Query(String sql) implements DatabaseOp&lt;ResultSet&gt; {}
    record Update(String sql) implements DatabaseOp&lt;Integer&gt; {}
}

// Tedious: implement Functor&lt;DatabaseOp&gt; manually
// Even more tedious if DatabaseOp has many variants
</code></pre>
<p>With Coyoneda, you can skip the Functor implementation entirely:</p>
<pre><code class="language-java">// With Coyoneda: wrap your DSL and get Functor for free
Coyoneda&lt;DatabaseOp, ResultSet&gt; coyo = Coyoneda.lift(new Query("SELECT * FROM users"));
// Now you can map over it without implementing Functor&lt;DatabaseOp&gt;!
</code></pre>
<h2 id="how-coyoneda-works"><a class="header" href="#how-coyoneda-works">How Coyoneda Works</a></h2>
<p>Coyoneda stores two things:</p>
<ol>
<li>A value of type <code>Kind&lt;F, X&gt;</code> (the original wrapped value)</li>
<li>A function <code>X -&gt; A</code> (the accumulated transformations)</li>
</ol>
<p>When you call <code>map(f)</code>, instead of applying <code>f</code> immediately, Coyoneda just composes <code>f</code> with the existing transformation:</p>
<pre><code>Coyoneda(fx, transform).map(f) = Coyoneda(fx, f.compose(transform))
</code></pre>
<p>The actual mapping only happens when you "lower" back to <code>F</code> using a real Functor instance.</p>
<pre><code>lift: F[A] ──────────────&gt; Coyoneda[F, A]    (wrap with identity function)
                               │
                          map(f).map(g).map(h)
                               │
                               ▼
                          Coyoneda[F, D]    (functions composed, not applied)
                               │
lower: Coyoneda[F, D] ─────────&gt; F[D]       (apply composed function once)
</code></pre>
<h2 id="core-interface-1"><a class="header" href="#core-interface-1">Core Interface</a></h2>
<pre><code class="language-java">public sealed interface Coyoneda&lt;F, A&gt; {

    /**
     * Lifts a Kind&lt;F, A&gt; into Coyoneda with the identity transformation.
     */
    static &lt;F, A&gt; Coyoneda&lt;F, A&gt; lift(Kind&lt;F, A&gt; fa);

    /**
     * Creates a Coyoneda with a value and transformation function.
     */
    static &lt;F, X, A&gt; Coyoneda&lt;F, A&gt; apply(Kind&lt;F, X&gt; fx, Function&lt;? super X, ? extends A&gt; transform);

    /**
     * Maps a function, composing it with existing transformations.
     * No Functor instance required!
     */
    &lt;B&gt; Coyoneda&lt;F, B&gt; map(Function&lt;? super A, ? extends B&gt; f);

    /**
     * Lowers back to Kind&lt;F, A&gt; by applying the accumulated transformation.
     * This is where the actual mapping happens.
     */
    Kind&lt;F, A&gt; lower(Functor&lt;F&gt; functor);

    /**
     * Returns the underlying Kind value (before transformations).
     */
    Kind&lt;F, ?&gt; underlying();
}
</code></pre>
<h2 id="basic-usage-9"><a class="header" href="#basic-usage-9">Basic Usage</a></h2>
<h3 id="lifting-and-mapping"><a class="header" href="#lifting-and-mapping">Lifting and Mapping</a></h3>
<pre><code class="language-java">import static org.higherkindedj.hkt.maybe.MaybeKindHelper.MAYBE;

// Lift a Maybe into Coyoneda
Kind&lt;MaybeKind.Witness, Integer&gt; maybe = MAYBE.widen(Maybe.just(42));
Coyoneda&lt;MaybeKind.Witness, Integer&gt; coyo = Coyoneda.lift(maybe);

// Map without needing a Functor instance
Coyoneda&lt;MaybeKind.Witness, String&gt; mapped = coyo
    .map(x -&gt; x * 2)           // 42 -&gt; 84
    .map(x -&gt; x + 1)           // 84 -&gt; 85
    .map(Object::toString);    // 85 -&gt; "85"

// All three maps are fused into ONE composed function!
// The function (x -&gt; ((x * 2) + 1).toString()) is stored but not yet applied
</code></pre>
<h3 id="lowering-with-a-functor"><a class="header" href="#lowering-with-a-functor">Lowering with a Functor</a></h3>
<pre><code class="language-java">// When ready, lower back using a Functor instance
MaybeFunctor functor = MaybeFunctor.INSTANCE;
Kind&lt;MaybeKind.Witness, String&gt; result = mapped.lower(functor);

// Only NOW does the actual mapping happen - just once!
Maybe&lt;String&gt; finalResult = MAYBE.narrow(result);
// Result: Just("85")
</code></pre>
<h3 id="using-coyonedafunctor"><a class="header" href="#using-coyonedafunctor">Using CoyonedaFunctor</a></h3>
<p>The <code>CoyonedaFunctor&lt;F&gt;</code> class provides a Functor instance for any <code>Coyoneda&lt;F, _&gt;</code>:</p>
<pre><code class="language-java">CoyonedaFunctor&lt;MaybeKind.Witness&gt; coyoFunctor = new CoyonedaFunctor&lt;&gt;();

Kind&lt;CoyonedaKind.Witness&lt;MaybeKind.Witness&gt;, Integer&gt; kindCoyo =
    COYONEDA.widen(Coyoneda.lift(maybe));

Kind&lt;CoyonedaKind.Witness&lt;MaybeKind.Witness&gt;, String&gt; mapped =
    coyoFunctor.map(x -&gt; x.toString(), kindCoyo);
</code></pre>
<h2 id="map-fusion"><a class="header" href="#map-fusion">Map Fusion</a></h2>
<p>Map fusion is the key performance benefit. Consider:</p>
<pre><code class="language-java">// Without Coyoneda: three separate traversals
List&lt;String&gt; result = list.stream()
    .map(x -&gt; x * 2)
    .map(x -&gt; x + 1)
    .map(Object::toString)
    .toList();
// Each map creates intermediate results
</code></pre>
<pre><code class="language-java">// With Coyoneda: functions are composed, single traversal
Coyoneda&lt;ListKind.Witness, Integer&gt; coyo = Coyoneda.lift(LIST.widen(list));
Coyoneda&lt;ListKind.Witness, String&gt; mapped = coyo
    .map(x -&gt; x * 2)
    .map(x -&gt; x + 1)
    .map(Object::toString);
// No mapping yet - just function composition

Kind&lt;ListKind.Witness, String&gt; result = mapped.lower(listFunctor);
// NOW the composed function is applied in ONE traversal
</code></pre>
<p>The benefit is most noticeable when:</p>
<ul>
<li>The underlying structure is expensive to traverse</li>
<li>You have many consecutive map operations</li>
<li>The intermediate types are complex</li>
</ul>
<h2 id="use-with-free-monads-1"><a class="header" href="#use-with-free-monads-1">Use with Free Monads</a></h2>
<p>Coyoneda is particularly useful with Free monads. Without Coyoneda, your instruction set must be a Functor:</p>
<pre><code class="language-java">// Without Coyoneda: must implement Functor&lt;ConsoleOp&gt;
Free&lt;ConsoleOpKind.Witness, String&gt; program = Free.liftF(readLine, consoleOpFunctor);
</code></pre>
<p>With Coyoneda, you can wrap any instruction set:</p>
<pre><code class="language-java">// With Coyoneda: no Functor needed for ConsoleOp
// The Free monad operates on Coyoneda&lt;ConsoleOp, _&gt; instead

// Lift instruction into Coyoneda, then into Free
Coyoneda&lt;ConsoleOpKind.Witness, String&gt; coyoOp = Coyoneda.lift(readLineKind);
Free&lt;CoyonedaKind.Witness&lt;ConsoleOpKind.Witness&gt;, String&gt; program =
    Free.liftF(COYONEDA.widen(coyoOp), new CoyonedaFunctor&lt;&gt;());
</code></pre>
<p>This eliminates boilerplate when you have many instruction types.</p>
<h2 id="the-yoneda-lemma"><a class="header" href="#the-yoneda-lemma">The Yoneda Lemma</a></h2>
<p>Coyoneda is based on the <strong>covariant Yoneda lemma</strong> from category theory. In simplified terms:</p>
<pre><code>Coyoneda[F, A] ≅ F[A]
</code></pre>
<p>This isomorphism is witnessed by:</p>
<ul>
<li><code>lift</code>: <code>F[A] -&gt; Coyoneda[F, A]</code> (wraps with identity function)</li>
<li><code>lower</code>: <code>Coyoneda[F, A] -&gt; F[A]</code> (applies accumulated function via Functor)</li>
</ul>
<p>The isomorphism holds for any Functor <code>F</code>. Coyoneda essentially "delays" the functor operations until lowering.</p>
<h2 id="functor-laws"><a class="header" href="#functor-laws">Functor Laws</a></h2>
<p><code>CoyonedaFunctor</code> satisfies the Functor laws automatically:</p>
<p><strong>Identity Law:</strong></p>
<pre><code class="language-java">coyo.map(x -&gt; x) == coyo
// Composing with identity doesn't change the accumulated function
</code></pre>
<p><strong>Composition Law:</strong></p>
<pre><code class="language-java">coyo.map(f).map(g) == coyo.map(x -&gt; g.apply(f.apply(x)))
// Multiple maps compose into one - this is map fusion!
</code></pre>
<p>These laws hold by construction because <code>map</code> simply composes functions.</p>
<h2 id="when-to-use-coyoneda"><a class="header" href="#when-to-use-coyoneda">When to Use Coyoneda</a></h2>
<h3 id="good-use-cases-2"><a class="header" href="#good-use-cases-2">Good Use Cases</a></h3>
<ol>
<li><strong>Free monad DSLs</strong>: Avoid implementing Functor for each instruction type</li>
<li><strong>Map fusion</strong>: Optimise chains of map operations on expensive structures</li>
<li><strong>Deferred computation</strong>: Delay mapping until you have a Functor available</li>
<li><strong>Generic programming</strong>: Work with type constructors that don't have Functor instances</li>
</ol>
<h3 id="when-you-might-not-need-it"><a class="header" href="#when-you-might-not-need-it">When You Might Not Need It</a></h3>
<ol>
<li><strong>Single map operations</strong>: No fusion benefit with just one map</li>
<li><strong>Already have a Functor</strong>: If implementing Functor is easy, Coyoneda adds indirection</li>
<li><strong>Simple types</strong>: For types like <code>Optional</code> or <code>List</code>, the built-in map is already efficient</li>
</ol>
<h2 id="performance-considerations-10"><a class="header" href="#performance-considerations-10">Performance Considerations</a></h2>
<p>Coyoneda trades:</p>
<ul>
<li><strong>Pros</strong>: Reduced traversals, function composition is cheap, deferred execution</li>
<li><strong>Cons</strong>: Object allocation for Coyoneda wrapper, slightly more complex types</li>
</ul>
<p>The benefit is most significant when:</p>
<ul>
<li>The underlying <code>F</code> is expensive to map over (e.g., large trees, IO operations)</li>
<li>You have many consecutive map operations</li>
<li>You want to defer all mapping to a single point</li>
</ul>
<p>For simple cases with one or two maps on efficient structures, the overhead may not be worth it.</p>
<h2 id="summary-23"><a class="header" href="#summary-23">Summary</a></h2>
<p>Coyoneda provides:</p>
<ul>
<li><strong>Automatic Functor instances</strong>: Any type constructor gains a Functor via wrapping</li>
<li><strong>Map fusion</strong>: Multiple maps compose into a single function application</li>
<li><strong>Deferred execution</strong>: Actual mapping happens only at lowering</li>
<li><strong>DSL simplification</strong>: Free monad instruction sets don't need Functor instances</li>
</ul>
<p>It's a powerful tool for optimising functional pipelines and simplifying Free monad definitions, based on the elegant mathematics of the Yoneda lemma.</p>
<hr />
<div id="admonition-further-reading" class="admonition admonish-tip" role="note" aria-labelledby="admonition-further-reading-title">
<div class="admonition-title">
<div id="admonition-further-reading-title">
<p>Further Reading</p>
</div>
<a class="admonition-anchor-link" href="monads/coyoneda.html#admonition-further-reading"></a>
</div>
<div>
<ul>
<li><strong>Why it helps</strong>: <a href="https://gist.github.com/gregberns/ede18190d5117eea6fb51815e2eab9b2">Introduction to Yoneda and Coyoneda</a> - Explains Coyoneda as a <em>deferred map</em></li>
<li><strong>Bartosz Milewski</strong>: <a href="https://bartoszmilewski.com/2015/09/01/the-yoneda-lemma/">The Yoneda Lemma</a> - The mathematical foundation (more theoretical)</li>
</ul>
</div>
</div>
<div id="admonition-hands-on-learning" class="admonition admonish-info" role="note" aria-labelledby="admonition-hands-on-learning-title">
<div class="admonition-title">
<div id="admonition-hands-on-learning-title">
<p>Hands-On Learning</p>
</div>
<a class="admonition-anchor-link" href="monads/coyoneda.html#admonition-hands-on-learning"></a>
</div>
<div>
<p>Practice Coyoneda in <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/coretypes/Tutorial09_Coyoneda.java">Tutorial 09: Coyoneda</a> (5 exercises, ~10 minutes).</p>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="monads/free_applicative.html">Free Applicative</a>
<strong>Next:</strong> <a href="monads/try_monad.html">Try</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="the-trymonad"><a class="header" href="#the-trymonad">The TryMonad:</a></h1>
<h2 id="typed-error-handling-1"><a class="header" href="#typed-error-handling-1"><em>Typed Error Handling</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="monads/try_monad.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to handle exceptions functionally with Success and Failure cases</li>
<li>Converting exception-throwing code into composable, safe operations</li>
<li>Using <code>recover</code> and <code>recoverWith</code> for graceful error recovery</li>
<li>Building robust parsing and processing pipelines</li>
<li>When to choose Try vs Either for error handling</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code:</p>
</div>
<a class="admonition-anchor-link" href="monads/try_monad.html#admonition-see-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/trymonad/TryExample.java">TryExample.java</a></p>
</div>
</div>
<h2 id="purpose-11"><a class="header" href="#purpose-11">Purpose</a></h2>
<p>The <code>Try&lt;T&gt;</code> type in the <code>Higher-Kinded-J</code> library represents a computation that might result in a value of type <code>T</code> (a <code>Success</code>) or fail with a <code>Throwable</code> (a <code>Failure</code>). It serves as a functional alternative to traditional <code>try-catch</code> blocks for handling exceptions, particularly checked exceptions, within a computation chain.  We can think of it as an <code>Either</code> where the <code>Left</code> is an <code>Exception</code>, but also using try-catch blocks behind the scene, so that we don’t have to.</p>
<p><strong>Try Type</strong></p>
<p><img src="monads/../images/puml/try_type.svg" alt="try_type.svg" /></p>
<p><strong>Monadic Structure</strong></p>
<p><img src="monads/../images/puml/try_monad.svg" alt="try_monad.svg" /></p>
<p>Key benefits include:</p>
<ul>
<li><strong>Explicit Error Handling:</strong> Makes it clear from the return type (<code>Try&lt;T&gt;</code>) that a computation might fail.</li>
<li><strong>Composability:</strong> Allows chaining operations using methods like <code>map</code> and <code>flatMap</code>, where failures are automatically propagated without interrupting the flow with exceptions.</li>
<li><strong>Integration with HKT:</strong> Provides HKT simulation (<code>TryKind</code>) and type class instances (<code>TryMonad</code>) to work seamlessly with generic functional abstractions operating over <code>Kind&lt;F, A&gt;</code>.</li>
<li><strong>Error Recovery:</strong> Offers methods like <code>recover</code> and <code>recoverWith</code> to handle failures gracefully within the computation chain.</li>
</ul>
<p>It implements <code>MonadError&lt;TryKind&lt;?&gt;, Throwable&gt;</code>, signifying its monadic nature and its ability to handle errors of type <code>Throwable</code>.</p>
<p>Now that we understand the structure and benefits of <code>Try</code>, let's explore how to create and work with <code>Try</code> instances in practice.</p>
<h2 id="how-to-use-tryt"><a class="header" href="#how-to-use-tryt">How to Use <code>Try&lt;T&gt;</code></a></h2>
<div id="admonition-creating-instance" class="admonition admonish-note" role="note" aria-labelledby="admonition-creating-instance-title">
<div class="admonition-title">
<div id="admonition-creating-instance-title">
<p>Creating Instance</p>
</div>
<a class="admonition-anchor-link" href="monads/try_monad.html#admonition-creating-instance"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/trymonad/TryExample.java">TryExample.java</a></li>
</ul>
<p>You can create <code>Try</code> instances in several ways:</p>
<ol>
<li>
<p><strong><code>Try.of(Supplier)</code>:</strong> Executes a <code>Supplier</code> and wraps the result in <code>Success</code> or catches any thrown <code>Throwable</code> (including <code>Error</code> and checked exceptions) and wraps it in <code>Failure</code>.</p>
<pre><code class="language-java">import org.higherkindedj.hkt.trymonad.Try;
import java.io.FileInputStream;

// Success case
Try&lt;String&gt; successResult = Try.of(() -&gt; "This will succeed"); // Success("This will succeed")

// Failure case (checked exception)
Try&lt;FileInputStream&gt; failureResult = Try.of(() -&gt; new FileInputStream("nonexistent.txt")); // Failure(FileNotFoundException)

// Failure case (runtime exception)
Try&lt;Integer&gt; divisionResult = Try.of(() -&gt; 10 / 0); // Failure(ArithmeticException)
</code></pre>
</li>
<li>
<p><strong><code>Try.success(value)</code>:</strong> Directly creates a <code>Success</code> instance holding the given value (which can be null).</p>
<pre><code class="language-java">Try&lt;String&gt; directSuccess = Try.success("Known value");
Try&lt;String&gt; successNull = Try.success(null);
</code></pre>
</li>
<li>
<p><strong><code>Try.failure(throwable)</code>:</strong> Directly creates a <code>Failure</code> instance holding the given non-null <code>Throwable</code>.</p>
<pre><code class="language-java">Try&lt;String&gt; directFailure = Try.failure(new RuntimeException("Something went wrong"));
</code></pre>
</li>
</ol>
</div>
</div>
<div id="admonition-checking-the-state" class="admonition admonish-note" role="note" aria-labelledby="admonition-checking-the-state-title">
<div class="admonition-title">
<div id="admonition-checking-the-state-title">
<p>Checking the State</p>
</div>
<a class="admonition-anchor-link" href="monads/try_monad.html#admonition-checking-the-state"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/trymonad/TryExample.java">TryExample.java</a></li>
</ul>
<ul>
<li><code>isSuccess()</code>: Returns <code>true</code> if it's a <code>Success</code>.</li>
<li><code>isFailure()</code>: Returns <code>true</code> if it's a <code>Failure</code>.</li>
</ul>
<h3 id="getting-the-value-use-with-caution"><a class="header" href="#getting-the-value-use-with-caution">Getting the Value (Use with Caution)</a></h3>
<ul>
<li><code>get()</code>: Returns the value if <code>Success</code>, otherwise throws the contained <code>Throwable</code>. <strong>Avoid using this directly; prefer <code>fold</code>, <code>map</code>, <code>flatMap</code>, or recovery methods.</strong></li>
</ul>
</div>
</div>
<div id="admonition-transforming-values-_map_" class="admonition admonish-note" role="note" aria-labelledby="admonition-transforming-values-_map_-title">
<div class="admonition-title">
<div id="admonition-transforming-values-_map_-title">
<p>Transforming Values (<em>map</em>)</p>
</div>
<a class="admonition-anchor-link" href="monads/try_monad.html#admonition-transforming-values-_map_"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/trymonad/TryExample.java">TryExample.java</a></li>
</ul>
<p>Applies a function to the value inside a <code>Success</code>. If the function throws an exception, the result becomes a <code>Failure</code>. If the original <code>Try</code> was a <code>Failure</code>, <code>map</code> does nothing and returns the original <code>Failure</code>.</p>
<pre><code class="language-java">Try&lt;Integer&gt; initialSuccess = Try.success(5);
Try&lt;String&gt; mappedSuccess = initialSuccess.map(value -&gt; "Value: " + value); // Success("Value: 5")

Try&lt;Integer&gt; initialFailure = Try.failure(new RuntimeException("Fail"));
Try&lt;String&gt; mappedFailure = initialFailure.map(value -&gt; "Value: " + value); // Failure(RuntimeException)

Try&lt;Integer&gt; mapThrows = initialSuccess.map(value -&gt; { throw new NullPointerException(); }); // Failure(NullPointerException)
</code></pre>
</div>
</div>
<div id="admonition-chaining-operations-_flatmap_" class="admonition admonish-note" role="note" aria-labelledby="admonition-chaining-operations-_flatmap_-title">
<div class="admonition-title">
<div id="admonition-chaining-operations-_flatmap_-title">
<p>Chaining Operations (<em>flatMap</em>)</p>
</div>
<a class="admonition-anchor-link" href="monads/try_monad.html#admonition-chaining-operations-_flatmap_"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/trymonad/TryExample.java">TryExample.java</a></li>
</ul>
<p>Applies a function that returns another <code>Try</code> to the value inside a <code>Success</code>. This is used to sequence operations where each step might fail. Failures are propagated.</p>
<pre><code class="language-java">Function&lt;Integer, Try&lt;Double&gt;&gt; safeDivide =
value -&gt; (value == 0) ? Try.failure(new ArithmeticException("Div by zero")) : Try.success(10.0 / value);

Try&lt;Integer&gt; inputSuccess = Try.success(2);
Try&lt;Double&gt; result1 = inputSuccess.flatMap(safeDivide); // Success(5.0)

Try&lt;Integer&gt; inputZero = Try.success(0);
Try&lt;Double&gt; result2 = inputZero.flatMap(safeDivide); // Failure(ArithmeticException)

Try&lt;Integer&gt; inputFailure = Try.failure(new RuntimeException("Initial fail"));
Try&lt;Double&gt; result3 = inputFailure.flatMap(safeDivide); // Failure(RuntimeException) - initial failure propagates
</code></pre>
</div>
</div>
<hr />
<h3 id="handling-failures-fold-recover-recoverwith"><a class="header" href="#handling-failures-fold-recover-recoverwith">Handling Failures (<code>fold</code>, <code>recover</code>, <code>recoverWith</code>)</a></h3>
<div id="admonition-_foldsuccessfunc-failurefunc_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_foldsuccessfunc-failurefunc_-title">
<div class="admonition-title">
<div id="admonition-_foldsuccessfunc-failurefunc_-title">
<p><em>fold(successFunc, failureFunc)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/try_monad.html#admonition-_foldsuccessfunc-failurefunc_"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/trymonad/TryExample.java">TryExample.java</a></li>
</ul>
<p>Safely handles both cases by applying one of two functions.</p>
<pre><code class="language-java">String message = result2.fold(
    successValue -&gt; "Succeeded with " + successValue,
    failureThrowable -&gt; "Failed with " + failureThrowable.getMessage()
); // "Failed with Div by zero"

</code></pre>
</div>
</div>
<div id="admonition-_recoverrecoveryfunc_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_recoverrecoveryfunc_-title">
<div class="admonition-title">
<div id="admonition-_recoverrecoveryfunc_-title">
<p><em>recover(recoveryFunc)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/try_monad.html#admonition-_recoverrecoveryfunc_"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/trymonad/TryExample.java">TryExample.java</a></li>
</ul>
<p>If <code>Failure</code>, applies a function <code>Throwable -&gt; T</code> to produce a new <code>Success</code> value. If the recovery function throws, the result is a <code>Failure</code> containing that new exception.</p>
<pre><code class="language-java">Function&lt;Throwable, Double&gt; recoverHandler = throwable -&gt; -1.0;
Try&lt;Double&gt; recovered1 = result2.recover(recoverHandler); // Success(-1.0)
Try&lt;Double&gt; recovered2 = result1.recover(recoverHandler); // Stays Success(5.0)
</code></pre>
</div>
</div>
<div id="admonition-_recoverwithrecoveryfunc_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_recoverwithrecoveryfunc_-title">
<div class="admonition-title">
<div id="admonition-_recoverwithrecoveryfunc_-title">
<p><em>recoverWith(recoveryFunc)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/try_monad.html#admonition-_recoverwithrecoveryfunc_"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/trymonad/TryExample.java">TryExample.java</a></li>
</ul>
<p>Similar to <code>recover</code>, but the recovery function <code>Throwable -&gt; Try&lt;T&gt;</code> must return a <code>Try</code>. This allows recovery to potentially result in another <code>Failure</code>.</p>
<pre><code class="language-java">Function&lt;Throwable, Try&lt;Double&gt;&gt; recoverWithHandler = throwable -&gt;
    (throwable instanceof ArithmeticException) ? Try.success(Double.POSITIVE_INFINITY) : Try.failure(throwable);

Try&lt;Double&gt; recoveredWith1 = result2.recoverWith(recoverWithHandler); // Success(Infinity)
Try&lt;Double&gt; recoveredWith2 = result3.recoverWith(recoverWithHandler); // Failure(RuntimeException) - re-raised
</code></pre>
</div>
</div>
<hr />
<div id="admonition-example-using-_trymonad_" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-using-_trymonad_-title">
<div class="admonition-title">
<div id="admonition-example-using-_trymonad_-title">
<p>Example: Using <em>TryMonad</em></p>
</div>
<a class="admonition-anchor-link" href="monads/try_monad.html#admonition-example-using-_trymonad_"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/trymonad/TryExample.java">TryExample.java</a></li>
</ul>
<p>To use <code>Try</code> with generic code expecting <code>Kind&lt;F, A&gt;</code>:</p>
<ol>
<li><strong>Get Instance:</strong><code>TryMonad tryMonad = TryMonad.INSTANCE;</code></li>
<li><strong>Wrap(Widen):</strong> Use <code>TRY.widen(myTry)</code> or factories like <code>TRY.tryOf(() -&gt; ...)</code>.</li>
<li><strong>Operate:</strong> Use <code>tryMonad.map(...)</code>, <code>tryMonad.flatMap(...)</code>, <code>tryMonad.handleErrorWith(...)</code> etc.</li>
<li><strong>Unwrap(Narrow):</strong> Use <code>TRY.narrow(tryKind)</code> to get the <code>Try&lt;T&gt;</code> back.</li>
</ol>
<pre><code class="language-java">
TryMonad tryMonad = TryMonad.INSTANCE;

Kind&lt;TryKind.Witness, Integer&gt; tryKind1 = TRY.tryOf(() -&gt; 10 / 2); // Success(5) Kind
Kind&lt;TryKind.Witness, Integer&gt; tryKind2 = TRY.tryOf(() -&gt; 10 / 0); // Failure(...) Kind

// Map using Monad instance
Kind&lt;TryKind.Witness, String&gt; mappedKind = tryMonad.map(Object::toString, tryKind1); // Success("5") Kind

// FlatMap using Monad instance
Function&lt;Integer, Kind&lt;TryKind.Witness, Double&gt;&gt; safeDivideKind =
        i -&gt; TRY.tryOf(() -&gt; 10.0 / i);
Kind&lt;TryKind.Witness, Double&gt; flatMappedKind = tryMonad.flatMap(safeDivideKind, tryKind1); // Success(2.0) Kind

// Handle error using MonadError instance
Kind&lt;TryKind.Witness, Integer&gt; handledKind = tryMonad.handleErrorWith(
        tryKind2, // The Failure Kind
        error -&gt; TRY.success(-1) // Recover to Success(-1) Kind
);

// Unwrap
Try&lt;String&gt; mappedTry = TRY.narrow(mappedKind); // Success("5")
Try&lt;Double&gt; flatMappedTry = TRY.narrow(flatMappedKind); // Success(2.0)
Try&lt;Integer&gt; handledTry = TRY.narrow(handledKind); // Success(-1)

System.out.println(mappedTry);
System.out.println(flatMappedTry);
System.out.println(handledTry);
</code></pre>
</div>
</div>
<hr />
<div id="admonition-effect-path-alternative" class="admonition admonish-tip" role="note" aria-labelledby="admonition-effect-path-alternative-title">
<div class="admonition-title">
<div id="admonition-effect-path-alternative-title">
<p>Effect Path Alternative</p>
</div>
<a class="admonition-anchor-link" href="monads/try_monad.html#admonition-effect-path-alternative"></a>
</div>
<div>
<p>For most use cases, prefer <strong><a href="monads/../effect/path_try.html">TryPath</a></strong> which wraps <code>Try</code> and provides:</p>
<ul>
<li>Fluent composition with <code>map</code>, <code>via</code>, <code>recover</code></li>
<li>Seamless integration with the <a href="monads/../optics/focus_dsl.html">Focus DSL</a> for structural navigation</li>
<li>A consistent API shared across all effect types</li>
</ul>
<pre><code class="language-java">// Instead of manual Try chaining:
Try&lt;Config&gt; config = Try.of(() -&gt; loadConfig());
Try&lt;String&gt; value = config.flatMap(c -&gt; Try.of(() -&gt; c.getValue("key")));

// Use TryPath for cleaner composition:
TryPath&lt;String&gt; value = Path.tryOf(() -&gt; loadConfig())
    .via(c -&gt; Path.tryOf(() -&gt; c.getValue("key")));
</code></pre>
<p>See <a href="monads/../effect/effect_path_overview.html">Effect Path Overview</a> for the complete guide.</p>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="monads/coyoneda.html">Coyoneda</a>
<strong>Next:</strong> <a href="monads/validated_monad.html">Validated</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="the-validatedmonad"><a class="header" href="#the-validatedmonad">The ValidatedMonad:</a></h1>
<h2 id="handling-valid-or-invalid-operations"><a class="header" href="#handling-valid-or-invalid-operations"><em>Handling Valid or Invalid Operations</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="monads/validated_monad.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to distinguish between valid and invalid data with explicit types</li>
<li>Using Validated as a MonadError for fail-fast error handling</li>
<li>Understanding when to use monadic operations (fail-fast) vs applicative operations (error accumulation)</li>
<li>The difference between fail-fast validation (Monad/MonadError) and error-accumulating validation (Applicative with Semigroup)</li>
<li>Real-world input validation scenarios with detailed error reporting</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code:</p>
</div>
<a class="admonition-anchor-link" href="monads/validated_monad.html#admonition-see-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/validated/ValidatedMonadExample.java">ValidatedMonadExample.java</a></p>
</div>
</div>
<h2 id="purpose-12"><a class="header" href="#purpose-12">Purpose</a></h2>
<p>The <code>Validated&lt;E, A&gt;</code> type in <code>Higher-Kinded-J</code> represents a value that can either be <code>Valid&lt;A&gt;</code> (correct) or <code>Invalid&lt;E&gt;</code> (erroneous). It is commonly used in scenarios like input validation where you want to clearly distinguish between a successful result and an error. Unlike types like <code>Either</code> which are often used for general-purpose sum types, <code>Validated</code> is specifically focused on the valid/invalid dichotomy. Operations like <code>map</code>, <code>flatMap</code>, and <code>ap</code> are right-biased, meaning they operate on the <code>Valid</code> value and propagate <code>Invalid</code> values unchanged.</p>
<p>The <code>ValidatedMonad&lt;E&gt;</code> provides a monadic interface for <code>Validated&lt;E, A&gt;</code> (where the error type <code>E</code> is fixed for the monad instance), allowing for functional composition and integration with the Higher-Kinded-J framework. This facilitates chaining operations that can result in either a valid outcome or an error.</p>
<div id="admonition-key-benefits-include" class="admonition admonish-info" role="note" aria-labelledby="admonition-key-benefits-include-title">
<div class="admonition-title">
<div id="admonition-key-benefits-include-title">
<p>Key benefits include:</p>
</div>
<a class="admonition-anchor-link" href="monads/validated_monad.html#admonition-key-benefits-include"></a>
</div>
<div>
<ul>
<li><strong>Explicit Validation Outcome:</strong> The type signature <code>Validated&lt;E, A&gt;</code> makes it clear that a computation can result in either a success (<code>Valid&lt;A&gt;</code>) or an error (<code>Invalid&lt;E&gt;</code>).</li>
<li><strong>Functional Composition:</strong> Enables chaining of operations using <code>map</code>, <code>flatMap</code>, and <code>ap</code>. If an operation results in an <code>Invalid</code>, subsequent operations in the chain are typically short-circuited, propagating the <code>Invalid</code> state.</li>
<li><strong>HKT Integration:</strong> <code>ValidatedKind&lt;E, A&gt;</code> (the HKT wrapper for <code>Validated&lt;E, A&gt;</code>) and <code>ValidatedMonad&lt;E&gt;</code> allow <code>Validated</code> to be used with generic functions and type classes that expect <code>Kind&lt;F, A&gt;</code>, <code>Functor&lt;F&gt;</code>, <code>Applicative&lt;F&gt;</code>, or <code>Monad&lt;M&gt;</code>.</li>
<li><strong>Clear Error Handling:</strong> Provides methods like <code>fold</code>, <code>ifValid</code>, <code>ifInvalid</code> to handle both <code>Valid</code> and <code>Invalid</code> cases explicitly.</li>
<li><strong>Standardized Error Handling:</strong> As a <code>MonadError&lt;ValidatedKind.Witness&lt;E&gt;, E&gt;</code>, it offers <code>raiseError</code> to construct error states and <code>handleErrorWith</code> for recovery, integrating with generic error-handling combinators.</li>
</ul>
</div>
</div>
<p><code>ValidatedMonad&lt;E&gt;</code> implements <code>MonadError&lt;ValidatedKind.Witness&lt;E&gt;, E&gt;</code>, which transitively includes <code>Monad&lt;ValidatedKind.Witness&lt;E&gt;&gt;</code>, <code>Applicative&lt;ValidatedKind.Witness&lt;E&gt;&gt;</code>, and <code>Functor&lt;ValidatedKind.Witness&lt;E&gt;&gt;</code>.</p>
<h2 id="structure-9"><a class="header" href="#structure-9">Structure</a></h2>
<p><strong>Validated Type</strong> Conceptually, <code>Validated&lt;E, A&gt;</code> has two sub-types:</p>
<ul>
<li><code>Valid&lt;A&gt;</code>: Contains a valid value of type <code>A</code>.</li>
<li><code>Invalid&lt;E&gt;</code>: Contains an error value of type <code>E</code>.
<img src="monads/../images/puml/validated_type.svg" alt="validated_type.svg" /></li>
</ul>
<p><strong>Monadic Structure</strong> The <code>ValidatedMonad&lt;E&gt;</code> enables monadic operations on <code>ValidatedKind.Witness&lt;E&gt;</code>.
<img src="monads/../images/puml/validated_monad.svg" alt="validated_monad.svg" /></p>
<div id="admonition-related-types" class="admonition admonish-note" role="note" aria-labelledby="admonition-related-types-title">
<div class="admonition-title">
<div id="admonition-related-types-title">
<p>Related Types</p>
</div>
<a class="admonition-anchor-link" href="monads/validated_monad.html#admonition-related-types"></a>
</div>
<div>
<p>Unlike <a href="monads/./either_monad.html">Either Monad</a> which is fail-fast in both Monad and Applicative contexts, <code>Validated</code> can be used with <code>Applicative</code> operations for error accumulation (when <code>E</code> has a <code>Semigroup</code> instance). When used as a Monad via <code>ValidatedMonad</code>, it behaves fail-fast like Either.</p>
</div>
</div>
<h2 id="how-to-use-validatedmonade-and-validatede-a"><a class="header" href="#how-to-use-validatedmonade-and-validatede-a">How to Use <code>ValidatedMonad&lt;E&gt;</code> and <code>Validated&lt;E, A&gt;</code></a></h2>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/validated/ValidatedMonadExample.java">ValidatedMonadExample.java</a></li>
</ul>
<h3 id="creating-instances-5"><a class="header" href="#creating-instances-5">Creating Instances</a></h3>
<p><code>Validated&lt;E, A&gt;</code> instances can be created directly using static factory methods on <code>Validated</code>. For HKT integration, <code>ValidatedKindHelper</code> and <code>ValidatedMonad</code> are used. <code>ValidatedKind&lt;E, A&gt;</code> is the HKT wrapper.</p>
<p><strong>Direct <code>Validated</code> Creation &amp; HKT Helpers:</strong> Refer to <code>ValidatedMonadExample.java</code> (Section 1) for runnable examples.</p>
<div id="admonition-creating-_valid_-_invalid_-and-hkt-wrappers" class="admonition admonish-note" role="note" aria-labelledby="admonition-creating-_valid_-_invalid_-and-hkt-wrappers-title">
<div class="admonition-title">
<div id="admonition-creating-_valid_-_invalid_-and-hkt-wrappers-title">
<p>Creating <em>Valid</em>, <em>Invalid</em> and HKT Wrappers</p>
</div>
<a class="admonition-anchor-link" href="monads/validated_monad.html#admonition-creating-_valid_-_invalid_-and-hkt-wrappers"></a>
</div>
<div>
<p>Creates a <code>Valid</code> instance holding a <strong>non-null</strong> value.</p>
<pre><code class="language-java">Validated&lt;List&lt;String&gt;, String&gt; validInstance = Validated.valid("Success!"); // Valid("Success!")
</code></pre>
<p>Creates an <code>Invalid</code> instance holding a <strong>non-null</strong> error.</p>
<pre><code class="language-java">Validated&lt;List&lt;String&gt;, String&gt; invalidInstance = Validated.invalid(Collections.singletonList("Error: Something went wrong.")); // Invalid([Error: Something went wrong.])
</code></pre>
<p>Converts a <code>Validated&lt;E, A&gt;</code> to <code>Kind&lt;ValidatedKind.Witness&lt;E&gt;, A&gt;</code> using <code>VALIDATED.widen()</code>.</p>
<pre><code class="language-java">Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, String&gt; kindValid = VALIDATED.widen(Validated.valid("Wrapped"));
</code></pre>
<p>Converts a <code>Kind&lt;ValidatedKind.Witness&lt;E&gt;, A&gt;</code> back to <code>Validated&lt;E, A&gt;</code> using <code>VALIDATED.narrow()</code>.</p>
<pre><code class="language-java">Validated&lt;List&lt;String&gt;, String&gt; narrowedValidated = VALIDATED.narrow(kindValid);
</code></pre>
<p>Convenience for <code>widen(Validated.valid(value))</code>using <code>VALIDATED.valid()</code>.</p>
<pre><code class="language-java">Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Integer&gt; kindValidInt = VALIDATED.valid(123);
</code></pre>
<p>Convenience for <code>widen(Validated.invalid(error))</code> using <code>VALIDATED.invalid()</code>.</p>
<pre><code class="language-java">Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Integer&gt; kindInvalidInt = VALIDATED.invalid(Collections.singletonList("Bad number"));
</code></pre>
</div>
</div>
<h3 id="validatedmonade-instance-methods"><a class="header" href="#validatedmonade-instance-methods"><code>ValidatedMonad&lt;E&gt;</code> Instance Methods:</a></h3>
<p>Refer to <code>ValidatedMonadExample.java</code> (Sections 1 &amp; 6) for runnable examples.</p>
<div id="admonition-_validatedmonadofa-value_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_validatedmonadofa-value_-title">
<div class="admonition-title">
<div id="admonition-_validatedmonadofa-value_-title">
<p><em>validatedMonad.of(A value)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/validated_monad.html#admonition-_validatedmonadofa-value_"></a>
</div>
<div>
<p>Lifts a value into <code>ValidatedKind.Witness&lt;E&gt;</code>, creating a <code>Valid(value)</code>. This is part of the <code>Applicative</code> interface.</p>
<pre><code class="language-java">ValidatedMonad&lt;List&lt;String&gt;&gt; validatedMonad = ValidatedMonad.instance();
Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, String&gt; kindFromMonadOf = validatedMonad.of("Monadic Valid"); // Valid("Monadic Valid")
System.out.println("From monad.of(): " + VALIDATED.narrow(kindFromMonadOf));
</code></pre>
<p>Lifts an error <code>E</code> into the <code>ValidatedKind</code> context, creating an <code>Invalid(error)</code>. This is part of the <code>MonadError</code> interface.</p>
<pre><code class="language-java">ValidatedMonad&lt;List&lt;String&gt;&gt; validatedMonad = ValidatedMonad.instance();
List&lt;String&gt; errorPayload = Collections.singletonList("Raised error condition");
Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, String&gt; raisedError =
    validatedMonad.raiseError(errorPayload); // Invalid(["Raised error condition"])
System.out.println("From monad.raiseError(): " + VALIDATED.narrow(raisedError));
</code></pre>
</div>
</div>
<h3 id="interacting-with-validatede-a-values"><a class="header" href="#interacting-with-validatede-a-values">Interacting with <code>Validated&lt;E, A&gt;</code> values</a></h3>
<p>The <code>Validated&lt;E, A&gt;</code> interface itself provides useful methods: Refer to <code>ValidatedMonadExample.java</code> (Section 5) for runnable examples of <code>fold</code>, <code>ifValid</code>, <code>ifInvalid</code>.</p>
<ul>
<li><code>isValid()</code>: Returns <code>true</code> if it's a <code>Valid</code>.</li>
<li><code>isInvalid()</code>: Returns <code>true</code> if it's an <code>Invalid</code>.</li>
<li><code>get()</code>: Returns the value if <code>Valid</code>, otherwise throws <code>NoSuchElementException</code>. <em>Use with caution.</em></li>
<li><code>getError()</code>: Returns the error if <code>Invalid</code>, otherwise throws <code>NoSuchElementException</code>. <em>Use with caution.</em></li>
<li><code>orElse(@NonNull A other)</code>: Returns the value if <code>Valid</code>, otherwise returns <code>other</code>.</li>
<li><code>orElseGet(@NonNull Supplier&lt;? extends @NonNull A&gt; otherSupplier)</code>: Returns the value if <code>Valid</code>, otherwise invokes <code>otherSupplier.get()</code>.</li>
<li><code>orElseThrow(@NonNull Supplier&lt;? extends X&gt; exceptionSupplier)</code>: Returns the value if <code>Valid</code>, otherwise throws the exception from the supplier.</li>
<li><code>ifValid(@NonNull Consumer&lt;? super A&gt; consumer)</code>: Performs action if <code>Valid</code>.</li>
<li><code>ifInvalid(@NonNull Consumer&lt;? super E&gt; consumer)</code>: Performs action if <code>Invalid</code>.</li>
<li><code>fold(@NonNull Function&lt;? super E, ? extends T&gt; invalidMapper, @NonNull Function&lt;? super A, ? extends T&gt; validMapper)</code>: Applies one of two functions depending on the state.</li>
<li><code>Validated</code> also has its own <code>map</code>, <code>flatMap</code>, and <code>ap</code> methods that operate directly on <code>Validated</code> instances.</li>
</ul>
<h3 id="key-operations-via-validatedmonade"><a class="header" href="#key-operations-via-validatedmonade">Key Operations (via <code>ValidatedMonad&lt;E&gt;</code>)</a></h3>
<p>These operations are performed on the HKT wrapper <code>Kind&lt;ValidatedKind.Witness&lt;E&gt;, A&gt;</code>. Refer to <code>ValidatedMonadExample.java</code> (Sections 2, 3, 4) for runnable examples of <code>map</code>, <code>flatMap</code>, and <code>ap</code>.</p>
<p>Applies <code>f</code> to the value inside <code>kind</code> if it's <code>Valid</code>. If <code>kind</code> is <code>Invalid</code>, or if <code>f</code> throws an exception (The behaviour depends on <code>Validated.map</code> internal error handling, typically an <code>Invalid</code> from <code>Validated.map</code> would be a new <code>Invalid</code>), the result is <code>Invalid</code>.</p>
<div id="admonition-transforming-values-_map_" class="admonition admonish-note" role="note" aria-labelledby="admonition-transforming-values-_map_-title">
<div class="admonition-title">
<div id="admonition-transforming-values-_map_-title">
<p>Transforming Values (<em>map</em>)</p>
</div>
<a class="admonition-anchor-link" href="monads/validated_monad.html#admonition-transforming-values-_map_"></a>
</div>
<div>
<pre><code class="language-java">// From ValidatedMonadExample.java (Section 2)
ValidatedMonad&lt;List&lt;String&gt;&gt; validatedMonad = ValidatedMonad.instance();
Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Integer&gt; validKindFromOf = validatedMonad.of(42);
Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Integer&gt; invalidIntKind =
    VALIDATED.invalid(Collections.singletonList("Initial error for map"));

Function&lt;Integer, String&gt; intToString = i -&gt; "Value: " + i;

Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, String&gt; mappedValid =
    validatedMonad.map(intToString, validKindFromOf); // Valid("Value: 42")
System.out.println("Map (Valid input): " + VALIDATED.narrow(mappedValid));

Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, String&gt; mappedInvalid =
    validatedMonad.map(intToString, invalidIntKind); // Invalid(["Initial error for map"])
System.out.println("Map (Invalid input): " + VALIDATED.narrow(mappedInvalid));
</code></pre>
</div>
</div>
<div id="admonition-transforming-values-_flatmap_" class="admonition admonish-note" role="note" aria-labelledby="admonition-transforming-values-_flatmap_-title">
<div class="admonition-title">
<div id="admonition-transforming-values-_flatmap_-title">
<p>Transforming Values (<em>flatMap</em>)</p>
</div>
<a class="admonition-anchor-link" href="monads/validated_monad.html#admonition-transforming-values-_flatmap_"></a>
</div>
<div>
<p>If <code>kind</code> is <code>Valid(a)</code>, applies <code>f</code> to <code>a</code>. <code>f</code> must return a <code>Kind&lt;ValidatedKind.Witness&lt;E&gt;, B&gt;</code>. If <code>kind</code> is <code>Invalid</code>, or <code>f</code> returns an <code>Invalid Kind</code>, the result is <code>Invalid</code>.</p>
<pre><code class="language-java">// From ValidatedMonadExample.java (Section 3)
ValidatedMonad&lt;List&lt;String&gt;&gt; validatedMonad = ValidatedMonad.instance();
Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Integer&gt; positiveNumKind = validatedMonad.of(10);
Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Integer&gt; nonPositiveNumKind = validatedMonad.of(-5);
Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Integer&gt; invalidIntKind =
        VALIDATED.invalid(Collections.singletonList("Initial error for flatMap"));


Function&lt;Integer, Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, String&gt;&gt; intToValidatedStringKind =
    i -&gt; {
      if (i &gt; 0) {
        return VALIDATED.valid("Positive: " + i);
      } else {
        return VALIDATED.invalid(Collections.singletonList("Number not positive: " + i));
      }
    };

Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, String&gt; flatMappedToValid =
    validatedMonad.flatMap(intToValidatedStringKind, positiveNumKind); // Valid("Positive: 10")
System.out.println("FlatMap (Valid to Valid): " + VALIDATED.narrow(flatMappedToValid));

Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, String&gt; flatMappedToInvalid =
    validatedMonad.flatMap(intToValidatedStringKind, nonPositiveNumKind); // Invalid(["Number not positive: -5"])
System.out.println("FlatMap (Valid to Invalid): " + VALIDATED.narrow(flatMappedToInvalid));

Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, String&gt; flatMappedFromInvalid =
    validatedMonad.flatMap(intToValidatedStringKind, invalidIntKind); // Invalid(["Initial error for flatMap"])
System.out.println("FlatMap (Invalid input): " + VALIDATED.narrow(flatMappedFromInvalid));
</code></pre>
</div>
</div>
<div id="admonition-applicative-operation-ap" class="admonition admonish-note" role="note" aria-labelledby="admonition-applicative-operation-ap-title">
<div class="admonition-title">
<div id="admonition-applicative-operation-ap-title">
<p>Applicative Operation (ap)</p>
</div>
<a class="admonition-anchor-link" href="monads/validated_monad.html#admonition-applicative-operation-ap"></a>
</div>
<div>
<ul>
<li>If <code>ff</code> is <code>Valid(f)</code> and <code>fa</code> is <code>Valid(a)</code>, applies <code>f</code> to <code>a</code>, resulting in <code>Valid(f(a))</code>.</li>
<li>If either <code>ff</code> or <code>fa</code> is <code>Invalid</code>, the result is <code>Invalid</code>. Specifically, if <code>ff</code> is <code>Invalid</code>, its error is returned.</li>
<li>If <code>ff</code> is <code>Valid</code> but <code>fa</code> is <code>Invalid</code>, then <code>fa</code>'s error is returned. If both are <code>Invalid</code>, <code>ff</code>'s error takes precedence.</li>
</ul>
<p>Note: This <code>ap</code> behaviour is right-biased and does not accumulate errors in the way some applicative validations might; it propagates the first encountered <code>Invalid</code> or the <code>Invalid</code> function.</p>
<pre><code class="language-java">// From ValidatedMonadExample.java (Section 4)
ValidatedMonad&lt;List&lt;String&gt;&gt; validatedMonad = ValidatedMonad.instance();
Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Function&lt;Integer, String&gt;&gt; validFnKind =
    VALIDATED.valid(i -&gt; "Applied: " + (i * 2));
Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Function&lt;Integer, String&gt;&gt; invalidFnKind =
    VALIDATED.invalid(Collections.singletonList("Function is invalid"));

Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Integer&gt; validValueForAp = validatedMonad.of(25);
Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Integer&gt; invalidValueForAp =
    VALIDATED.invalid(Collections.singletonList("Value is invalid"));

// Valid function, Valid value
Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, String&gt; apValidFnValidVal =
    validatedMonad.ap(validFnKind, validValueForAp); // Valid("Applied: 50")
System.out.println("Ap (ValidFn, ValidVal): " + VALIDATED.narrow(apValidFnValidVal));

// Invalid function, Valid value
Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, String&gt; apInvalidFnValidVal =
    validatedMonad.ap(invalidFnKind, validValueForAp); // Invalid(["Function is invalid"])
System.out.println("Ap (InvalidFn, ValidVal): " + VALIDATED.narrow(apInvalidFnValidVal));

// Valid function, Invalid value
Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, String&gt; apValidFnInvalidVal =
    validatedMonad.ap(validFnKind, invalidValueForAp); // Invalid(["Value is invalid"])
System.out.println("Ap (ValidFn, InvalidVal): " + VALIDATED.narrow(apValidFnInvalidVal));

// Invalid function, Invalid value
Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, String&gt; apInvalidFnInvalidVal =
    validatedMonad.ap(invalidFnKind, invalidValueForAp); // Invalid(["Function is invalid"])
System.out.println("Ap (InvalidFn, InvalidVal): " + VALIDATED.narrow(apInvalidFnInvalidVal));
</code></pre>
</div>
</div>
<h3 id="monaderror-operations"><a class="header" href="#monaderror-operations">MonadError Operations</a></h3>
<p>As <code>ValidatedMonad&lt;E&gt;</code> implements <code>MonadError&lt;ValidatedKind.Witness&lt;E&gt;, E&gt;</code>, it provides standardised ways to create and handle errors. Refer to ValidatedMonadExample.java (Section 6) for detailed examples.</p>
<div id="admonition-_recover_-and-_recoverwith_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_recover_-and-_recoverwith_-title">
<div class="admonition-title">
<div id="admonition-_recover_-and-_recoverwith_-title">
<p><em>recover</em> and <em>recoverWith</em></p>
</div>
<a class="admonition-anchor-link" href="monads/validated_monad.html#admonition-_recover_-and-_recoverwith_"></a>
</div>
<div>
<pre><code class="language-java">// From ValidatedMonadExample.java (Section 6)
ValidatedMonad&lt;List&lt;String&gt;&gt; validatedMonad = ValidatedMonad.instance();
List&lt;String&gt; initialError = Collections.singletonList("Initial Failure");

// 1. Create an Invalid Kind using raiseError
Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Integer&gt; invalidKindRaised = // Renamed to avoid conflict
    validatedMonad.raiseError(initialError);
System.out.println("Raised error: " + VALIDATED.narrow(invalidKindRaised)); // Invalid([Initial Failure])

// 2. Handle the error: recover to a Valid state
Function&lt;List&lt;String&gt;, Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Integer&gt;&gt; recoverToValid =
    errors -&gt; {
        System.out.println("MonadError: Recovery handler called with errors: " + errors);
        return validatedMonad.of(0); // Recover with default value 0
    };
Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Integer&gt; recoveredValid =
    validatedMonad.handleErrorWith(invalidKindRaised, recoverToValid);
System.out.println("Recovered to Valid: " + VALIDATED.narrow(recoveredValid)); // Valid(0)

// 3. Handle the error: transform to another Invalid state
Function&lt;List&lt;String&gt;, Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Integer&gt;&gt; transformError =
    errors -&gt; validatedMonad.raiseError(Collections.singletonList("Transformed Error: " + errors.get(0)));
Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Integer&gt; transformedInvalid =
    validatedMonad.handleErrorWith(invalidKindRaised, transformError);
System.out.println("Transformed to Invalid: " + VALIDATED.narrow(transformedInvalid)); // Invalid([Transformed Error: Initial Failure])

// 4. Handle a Valid Kind: handler is not called
Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Integer&gt; validKindOriginal = validatedMonad.of(100);
Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Integer&gt; notHandled =
    validatedMonad.handleErrorWith(validKindOriginal, recoverToValid); // Handler not called
System.out.println("Handling Valid (no change): " + VALIDATED.narrow(notHandled)); // Valid(100)

// 5. Using a default method like handleError
Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Integer&gt; errorForHandle = validatedMonad.raiseError(Collections.singletonList("Error for handleError"));
Function&lt;List&lt;String&gt;, Integer&gt; plainValueRecoveryHandler = errors -&gt; -1; // Returns plain value
Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Integer&gt; recoveredWithHandle = validatedMonad.handleError(errorForHandle, plainValueRecoveryHandler);
System.out.println("Recovered with handleError: " + VALIDATED.narrow(recoveredWithHandle)); // Valid(-1)
</code></pre>
<p>The default <code>recover</code> and <code>recoverWith</code> methods from <code>MonadError</code> are also available.</p>
</div>
</div>
<div id="admonition-combining-operations-for-simple-validation" class="admonition admonish-note" role="note" aria-labelledby="admonition-combining-operations-for-simple-validation-title">
<div class="admonition-title">
<div id="admonition-combining-operations-for-simple-validation-title">
<p>Combining operations for simple validation</p>
</div>
<a class="admonition-anchor-link" href="monads/validated_monad.html#admonition-combining-operations-for-simple-validation"></a>
</div>
<div>
<p>This example demonstrates how <code>ValidatedMonad</code> along with <code>Validated</code> can be used to chain operations that might succeed or fail. With <code>ValidatedMonad</code> now implementing <code>MonadError</code>, operations like <code>raiseError</code> can be used for clearer error signaling, and <code>handleErrorWith</code> (or other <code>MonadError</code> methods) can be used for more robust recovery strategies within such validation flows.</p>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/validated/ValidatedMonadExample.java">ValidatedMonadExample.java</a> <em>see "Combined Validation Scenario"</em>.</li>
</ul>
<pre><code class="language-java">// Simplified from the ValidatedMonadExample.java
public void combinedValidationScenarioWithMonadError() {
  ValidatedMonad&lt;List&lt;String&gt;&gt; validatedMonad = ValidatedMonad.instance();
  Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, String&gt; userInput1 = validatedMonad.of("123");
  Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, String&gt; userInput2 = validatedMonad.of("abc"); // This will lead to an Invalid

  Function&lt;String, Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Integer&gt;&gt; parseToIntKindMonadError =
      (String s) -&gt; {
        try {
          return validatedMonad.of(Integer.parseInt(s)); // Lifts to Valid
        } catch (NumberFormatException e) {
          // Using raiseError for semantic clarity
          return validatedMonad.raiseError(
              Collections.singletonList("'" + s + "' is not a number (via raiseError)."));
        }
      };

  Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Integer&gt; parsed1 =
      validatedMonad.flatMap(parseToIntKindMonadError, userInput1);
  Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Integer&gt; parsed2 =
      validatedMonad.flatMap(parseToIntKindMonadError, userInput2); // Will be Invalid

  System.out.println("Parsed Input 1 (Combined): " + VALIDATED.narrow(parsed1)); // Valid(123)
  System.out.println("Parsed Input 2 (Combined): " + VALIDATED.narrow(parsed2)); // Invalid(['abc' is not a number...])

  // Example of recovering the parse of userInput2 using handleErrorWith
  Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Integer&gt; parsed2Recovered =
      validatedMonad.handleErrorWith(
          parsed2,
          errors -&gt; {
            System.out.println("Combined scenario recovery: " + errors);
            return validatedMonad.of(0); // Default to 0 if parsing failed
          });
  System.out.println(
      "Parsed Input 2 (Recovered to 0): " + VALIDATED.narrow(parsed2Recovered)); // Valid(0)
}
</code></pre>
<p>This example demonstrates how <code>ValidatedMonad</code> along with <code>Validated</code> can be used to chain operations that might succeed or fail, propagating errors and allowing for clear handling of either outcome, further enhanced by <code>MonadError</code> capabilities.</p>
</div>
</div>
<hr />
<div id="admonition-effect-path-alternative" class="admonition admonish-tip" role="note" aria-labelledby="admonition-effect-path-alternative-title">
<div class="admonition-title">
<div id="admonition-effect-path-alternative-title">
<p>Effect Path Alternative</p>
</div>
<a class="admonition-anchor-link" href="monads/validated_monad.html#admonition-effect-path-alternative"></a>
</div>
<div>
<p>For most use cases, prefer <strong><a href="monads/../effect/path_validation.html">ValidationPath</a></strong> which wraps <code>Validated</code> and provides:</p>
<ul>
<li>Fluent composition with <code>map</code>, <code>via</code>, <code>recover</code></li>
<li>Seamless integration with the <a href="monads/../optics/focus_dsl.html">Focus DSL</a> for structural navigation</li>
<li>A consistent API shared across all effect types</li>
<li>Error accumulation when combined with applicative operations</li>
</ul>
<pre><code class="language-java">// Instead of manual Validated chaining:
Validated&lt;List&lt;Error&gt;, User&gt; user = validateUser(input);
Validated&lt;List&lt;Error&gt;, Order&gt; order = user.flatMap(u -&gt; createOrder(u));

// Use ValidationPath for cleaner composition:
ValidationPath&lt;List&lt;Error&gt;, Order&gt; order = Path.validation(validateUser(input))
    .via(u -&gt; createOrder(u));
</code></pre>
<p>See <a href="monads/../effect/effect_path_overview.html">Effect Path Overview</a> for the complete guide.</p>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="monads/try_monad.html">Try</a>
<strong>Next:</strong> <a href="monads/writer_monad.html">Writer</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="the-writermonad"><a class="header" href="#the-writermonad">The WriterMonad:</a></h1>
<h2 id="accumulating-output-alongside-computations"><a class="header" href="#accumulating-output-alongside-computations"><em>Accumulating Output Alongside Computations</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="monads/writer_monad.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to accumulate logs or output alongside your main computation</li>
<li>Understanding the role of Monoid in combining accumulated values</li>
<li>Building detailed audit trails and debugging information</li>
<li>Using <code>tell</code> for pure logging and <code>listen</code> for capturing output</li>
<li>Creating calculations that produce both results and comprehensive logs</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code:</p>
</div>
<a class="admonition-anchor-link" href="monads/writer_monad.html#admonition-see-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/writer/WriterExample.java">WriterExample.java</a></p>
</div>
</div>
<h2 id="purpose-13"><a class="header" href="#purpose-13">Purpose</a></h2>
<p>The <strong>Writer monad</strong> is a functional pattern designed for computations that, in addition to producing a primary result value, also need to <strong>accumulate</strong> some secondary output or log along the way. Think of scenarios like:</p>
<ul>
<li>Detailed logging of steps within a complex calculation.</li>
<li>Collecting metrics or events during a process.</li>
<li>Building up a sequence of results or messages.</li>
</ul>
<p>A <code>Writer&lt;W, A&gt;</code> represents a computation that produces a main result of type <code>A</code> and simultaneously accumulates an output of type <code>W</code>. The key requirement is that the accumulated type <code>W</code> must form a <strong>Monoid</strong>.</p>
<h3 id="the-role-of-monoidw"><a class="header" href="#the-role-of-monoidw">The Role of <code>Monoid&lt;W&gt;</code></a></h3>
<p>A <code>Monoid&lt;W&gt;</code> is a type class that defines two things for type <code>W</code>:</p>
<ol>
<li><code>empty()</code>: Provides an identity element (like <code>""</code> for String concatenation, <code>0</code> for addition, or an empty list).</li>
<li><code>combine(W w1, W w2)</code>: Provides an <strong>associative</strong> binary operation to combine two values of type <code>W</code> (like <code>+</code> for strings or numbers, or list concatenation).</li>
</ol>
<p>The Writer monad uses the <code>Monoid&lt;W&gt;</code> to:</p>
<ul>
<li>Provide a starting point (the <code>empty</code> value) for the accumulation.</li>
<li>Combine the accumulated outputs (<code>W</code>) from different steps using the <code>combine</code> operation when sequencing computations with <code>flatMap</code> or <code>ap</code>.</li>
</ul>
<p>Common examples for <code>W</code> include <code>String</code> (using concatenation), <code>Integer</code> (using addition or multiplication), or <code>List</code> (using concatenation).</p>
<h2 id="structure-10"><a class="header" href="#structure-10">Structure</a></h2>
<p>The <code>Writer&lt;W, A&gt;</code> record directly implements <code>WriterKind&lt;W, A&gt;</code>, which in turn extends <code>Kind&lt;WriterKind.Witness&lt;W&gt;, A&gt;</code>.</p>
<p><img src="monads/../images/puml/writer.svg" alt="writer.svg" /></p>
<h2 id="the-writerw-a-type"><a class="header" href="#the-writerw-a-type">The <code>Writer&lt;W, A&gt;</code> Type</a></h2>
<p>The core type is the <code>Writer&lt;W, A&gt;</code> record:</p>
<pre><code class="language-java">// From: org.higherkindedj.hkt.writer.Writer
public record Writer&lt;W, A&gt;(@NonNull W log, @Nullable A value) implements WriterKind&lt;W, A&gt; {
  // Static factories
  public static &lt;W, A&gt; @NonNull Writer&lt;W, A&gt; create(@NonNull W log, @Nullable A value);
  public static &lt;W, A&gt; @NonNull Writer&lt;W, A&gt; value(@NonNull Monoid&lt;W&gt; monoidW, @Nullable A value); // Creates (monoidW.empty(), value)
  public static &lt;W&gt; @NonNull Writer&lt;W, Unit&gt; tell(@NonNull W log); // Creates (log, Unit.INSTANCE) 

  // Instance methods (primarily for direct use, HKT versions via Monad instance)
  public &lt;B&gt; @NonNull Writer&lt;W, B&gt; map(@NonNull Function&lt;? super A, ? extends B&gt; f);
  public &lt;B&gt; @NonNull Writer&lt;W, B&gt; flatMap(
          @NonNull Monoid&lt;W&gt; monoidW, // Monoid needed for combining logs
          @NonNull Function&lt;? super A, ? extends Writer&lt;W, ? extends B&gt;&gt; f
  );
  public @Nullable A run(); // Get the value A, discard log
  public @NonNull W exec(); // Get the log W, discard value
}
</code></pre>
<ul>
<li>It simply holds a pair: the accumulated <code>log</code> (of type <code>W</code>) and the computed <code>value</code> (of type <code>A</code>).</li>
<li><code>create(log, value)</code>: Basic constructor.</li>
<li><code>value(monoid, value)</code>: Creates a Writer with the given value and an <em>empty</em> log according to the provided <code>Monoid</code>.</li>
<li><code>tell(log)</code>: Creates a Writer with the given log, and <code>Unit.INSTANCE</code> as it's  value, signifying that the operation's primary purpose is the accumulation of the log. Useful for just adding to the log. (Note: The original <code>Writer.java</code> might have <code>tell(W log)</code> and infer monoid elsewhere, or <code>WriterMonad</code> handles <code>tell</code>).</li>
<li><code>map(...)</code>: Transforms the computed value <code>A</code> to <code>B</code> while leaving the log <code>W</code> untouched.</li>
<li><code>flatMap(...)</code>: Sequences computations. It runs the first Writer, uses its value <code>A</code> to create a second Writer, and combines the logs from both using the provided <code>Monoid</code>.</li>
<li><code>run()</code>: Extracts only the computed value <code>A</code>, discarding the log.</li>
<li><code>exec()</code>: Extracts only the accumulated log <code>W</code>, discarding the value.</li>
</ul>
<h2 id="writer-components"><a class="header" href="#writer-components">Writer Components</a></h2>
<p>To integrate <code>Writer</code> with Higher-Kinded-J:</p>
<ul>
<li><code>WriterKind&lt;W, A&gt;</code>: The HKT interface. <code>Writer&lt;W, A&gt;</code> itself implements <code>WriterKind&lt;W, A&gt;</code>. <code>WriterKind&lt;W, A&gt;</code> extends <code>Kind&lt;WriterKind.Witness&lt;W&gt;, A&gt;</code>.
<ul>
<li>It contains a nested <code>final class Witness&lt;LOG_W&gt; {}</code> which serves as the phantom type <code>F_WITNESS</code> for <code>Writer&lt;LOG_W, ?&gt;</code>.</li>
</ul>
</li>
<li><strong><code>WriterKindHelper</code></strong>: The utility class with static methods:
<ul>
<li><code>widen(Writer&lt;W, A&gt;)</code>: Converts a <code>Writer</code> to <code>Kind&lt;WriterKind.Witness&lt;W&gt;, A&gt;</code>. Since <code>Writer</code> directly implements <code>WriterKind</code>, this is effectively a checked cast.</li>
<li><code>narrow(Kind&lt;WriterKind.Witness&lt;W&gt;, A&gt;)</code>: Converts <code>Kind</code> back to <code>Writer&lt;W,A&gt;</code>. This is also effectively a checked cast after an <code>instanceof Writer</code> check.</li>
<li><code>value(Monoid&lt;W&gt; monoid, A value)</code>: Factory method for a <code>Kind</code> representing a <code>Writer</code> with an empty log.</li>
<li><code>tell(W log)</code>: Factory method for a <code>Kind</code> representing a <code>Writer</code> that only logs.</li>
<li><code>runWriter(Kind&lt;WriterKind.Witness&lt;W&gt;, A&gt;)</code>: Unwraps to <code>Writer&lt;W,A&gt;</code> and returns the record itself.</li>
<li><code>run(Kind&lt;WriterKind.Witness&lt;W&gt;, A&gt;)</code>: Executes (unwraps) and returns only the value <code>A</code>.</li>
<li><code>exec(Kind&lt;WriterKind.Witness&lt;W&gt;, A&gt;)</code>: Executes (unwraps) and returns only the log <code>W</code>.</li>
</ul>
</li>
</ul>
<h2 id="type-class-instances-writerfunctor-writerapplicative-writermonad"><a class="header" href="#type-class-instances-writerfunctor-writerapplicative-writermonad">Type Class Instances (<code>WriterFunctor</code>, <code>WriterApplicative</code>, <code>WriterMonad</code>)</a></h2>
<p>These classes provide the standard functional operations for <code>Kind&lt;WriterKind.Witness&lt;W&gt;, A&gt;</code>, allowing you to treat <code>Writer</code> computations generically. <strong>Crucially, <code>WriterApplicative&lt;W&gt;</code> and <code>WriterMonad&lt;W&gt;</code> require a <code>Monoid&lt;W&gt;</code> instance during construction.</strong></p>
<ul>
<li><code>WriterFunctor&lt;W&gt;</code>: Implements <code>Functor&lt;WriterKind.Witness&lt;W&gt;&gt;</code>. Provides <code>map</code> (operates only on the value <code>A</code>).</li>
<li><strong><code>WriterApplicative&lt;W&gt;</code></strong>: Extends <code>WriterFunctor&lt;W&gt;</code>, implements <code>Applicative&lt;WriterKind.Witness&lt;W&gt;&gt;</code>. Requires a <code>Monoid&lt;W&gt;</code>. Provides <code>of</code> (lifting a value with an empty log) and <code>ap</code> (applying a wrapped function to a wrapped value, combining logs).</li>
<li><strong><code>WriterMonad&lt;W&gt;</code></strong>: Extends <code>WriterApplicative&lt;W&gt;</code>, implements <code>Monad&lt;WriterKind.Witness&lt;W&gt;&gt;</code>. Requires a <code>Monoid&lt;W&gt;</code>. Provides <code>flatMap</code> for sequencing computations, automatically combining logs using the <code>Monoid</code>.</li>
</ul>
<div id="admonition-example-logging-a-complex-calculation" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-logging-a-complex-calculation-title">
<div class="admonition-title">
<div id="admonition-example-logging-a-complex-calculation-title">
<p>Example: Logging a complex calculation</p>
</div>
<a class="admonition-anchor-link" href="monads/writer_monad.html#admonition-example-logging-a-complex-calculation"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/writer/WriterExample.java">WriterExample.java</a></li>
</ul>
<p>You typically instantiate <code>WriterMonad&lt;W&gt;</code> for the specific log type <code>W</code> and its corresponding <code>Monoid</code>.</p>
<h3 id="1-choose-your-log-type-w-and-monoidw"><a class="header" href="#1-choose-your-log-type-w-and-monoidw">1. Choose Your Log Type <code>W</code> and <code>Monoid&lt;W&gt;</code></a></h3>
<p>Decide what you want to accumulate (e.g., <code>String</code> for logs, <code>List&lt;String&gt;</code> for messages, <code>Integer</code> for counts) and get its <code>Monoid</code>.</p>
<pre><code class="language-java">
class StringMonoid implements Monoid&lt;String&gt; {
  @Override public String empty() { return ""; }
  @Override public String combine(String x, String y) { return x + y; }
}

Monoid&lt;String&gt; stringMonoid = new StringMonoid(); 
</code></pre>
<h3 id="2-get-the-writermonad-instance"><a class="header" href="#2-get-the-writermonad-instance">2. Get the <code>WriterMonad</code> Instance</a></h3>
<p>Instantiate the monad for your chosen log type <code>W</code>, providing its <code>Monoid</code>.</p>
<pre><code class="language-java">import org.higherkindedj.hkt.writer.WriterMonad;

// Monad instance for computations logging Strings
// F_WITNESS here is WriterKind.Witness&lt;String&gt;
WriterMonad&lt;String&gt; writerMonad = new WriterMonad&lt;&gt;(stringMonoid);

</code></pre>
<h3 id="3-create-writer-computations"><a class="header" href="#3-create-writer-computations">3. Create Writer Computations</a></h3>
<p>Use <code>WriterKindHelper</code> factory methods, providing the <code>Monoid</code> where needed. The result is <code>Kind&lt;WriterKind.Witness&lt;W&gt;, A&gt;</code>.</p>
<pre><code class="language-java">
// Writer with an initial value and empty log
Kind&lt;WriterKind.Witness&lt;String&gt;, Integer&gt; initialValue = WRITER.value(stringMonoid, 5); // Log: "", Value: 5

// Writer that just logs a message (value is Unit.INSTANCE)
Kind&lt;WriterKind.Witness&lt;String&gt;, Unit&gt; logStart = WRITER.tell("Starting calculation; "); // Log: "Starting calculation; ", Value: ()

// A function that performs a calculation and logs its step
Function&lt;Integer, Kind&lt;WriterKind.Witness&lt;String&gt;, Integer&gt;&gt; addAndLog =
        x -&gt; {
          int result = x + 10;
          String logMsg = "Added 10 to " + x + " -&gt; " + result + "; ";
          // Create a Writer directly then wrap with helper or use helper factory
          return WRITER.widen(Writer.create(logMsg, result));
        };

Function&lt;Integer, Kind&lt;WriterKind.Witness&lt;String&gt;, String&gt;&gt; multiplyAndLogToString =
        x -&gt; {
          int result = x * 2;
          String logMsg = "Multiplied " + x + " by 2 -&gt; " + result + "; ";
          return WRITER.widen(Writer.create(logMsg, "Final:" + result));
        };

</code></pre>
<h3 id="4-compose-computations-using-map-and-flatmap-2"><a class="header" href="#4-compose-computations-using-map-and-flatmap-2">4. Compose Computations using <code>map</code> and <code>flatMap</code></a></h3>
<p>Use the methods on the <code>writerMonad</code> instance. <code>flatMap</code> automatically combines logs using the <code>Monoid</code>.</p>
<pre><code class="language-java">// Chain the operations:
// Start with a pure value 0 in the Writer context (empty log)
Kind&lt;WriterKind.Witness&lt;String&gt;, Integer&gt; computationStart = writerMonad.of(0);

// 1. Log the start
Kind&lt;WriterKind.Witness&lt;String&gt;, Integer&gt; afterLogStart  = writerMonad.flatMap(ignoredUnit -&gt; initialValue, logStart);

Kind&lt;WriterKind.Witness&lt;String&gt;, Integer&gt; step1Value = WRITER.value(stringMonoid, 5); // ("", 5)
Kind&lt;WriterKind.Witness&lt;String&gt;, Unit&gt; step1Log = WRITER.tell("Initial value set to 5; "); // ("Initial value set to 5; ", ())


// Start -&gt; log -&gt; transform value -&gt; log -&gt; transform value ...
Kind&lt;WriterKind.Witness&lt;String&gt;, Integer&gt; calcPart1 = writerMonad.flatMap(
        ignored -&gt; addAndLog.apply(5), // Apply addAndLog to 5, after logging "start"
        WRITER.tell("Starting with 5; ")
);
// calcPart1: Log: "Starting with 5; Added 10 to 5 -&gt; 15; ", Value: 15

Kind&lt;WriterKind.Witness&lt;String&gt;, String&gt; finalComputation = writerMonad.flatMap(
        intermediateValue -&gt; multiplyAndLogToString.apply(intermediateValue),
        calcPart1
);
// finalComputation: Log: "Starting with 5; Added 10 to 5 -&gt; 15; Multiplied 15 by 2 -&gt; 30; ", Value: "Final:30"


// Using map: Only transforms the value, log remains unchanged from the input Kind
Kind&lt;WriterKind.Witness&lt;String&gt;, Integer&gt; initialValForMap = value(stringMonoid, 100); // Log: "", Value: 100
Kind&lt;WriterKind.Witness&lt;String&gt;, String&gt; mappedVal = writerMonad.map(
        i -&gt; "Value is " + i,
        initialValForMap
); // Log: "", Value: "Value is 100"
</code></pre>
<h3 id="5-run-the-computation-and-extract-results"><a class="header" href="#5-run-the-computation-and-extract-results">5. Run the Computation and Extract Results</a></h3>
<p>Use <code>WRITER.runWriter</code>, <code>WRITER.run</code>, or <code>WRITER.exec</code> from <code>WriterKindHelper</code>.</p>
<pre><code class="language-java">
import org.higherkindedj.hkt.writer.Writer; 

// Get the final Writer record (log and value)
Writer&lt;String, String&gt; finalResultWriter = runWriter(finalComputation);
String finalLog = finalResultWriter.log();
String finalValue = finalResultWriter.value();

System.out.println("Final Log: " + finalLog);
// Output: Final Log: Starting with 5; Added 10 to 5 -&gt; 15; Multiplied 15 by 2 -&gt; 30;
System.out.println("Final Value: " + finalValue);
// Output: Final Value: Final:30

// Or get only the value or log
String justValue = WRITER.run(finalComputation); // Extracts value from finalResultWriter
String justLog = WRITER.exec(finalComputation);  // Extracts log from finalResultWriter

System.out.println("Just Value: " + justValue); // Output: Just Value: Final:30
System.out.println("Just Log: " + justLog);     // Output: Just Log: Starting with 5; Added 10 to 5 -&gt; 15; Multiplied 15 by 2 -&gt; 30;

Writer&lt;String, String&gt; mappedResult = WRITER.runWriter(mappedVal);
System.out.println("Mapped Log: " + mappedResult.log());   // Output: Mapped Log
System.out.println("Mapped Value: " + mappedResult.value()); // Output: Mapped Value: Value is 100
</code></pre>
</div>
</div>
<div id="admonition-key-points" class="admonition admonish-tip" role="note" aria-labelledby="admonition-key-points-title">
<div class="admonition-title">
<div id="admonition-key-points-title">
<p>Key Points:</p>
</div>
<a class="admonition-anchor-link" href="monads/writer_monad.html#admonition-key-points"></a>
</div>
<div>
<p>The Writer monad (<code>Writer&lt;W, A&gt;</code>, <code>WriterKind.Witness&lt;W&gt;</code>, <code>WriterMonad&lt;W&gt;</code>) in <code>Higher-Kinded-J</code> provides a structured way to perform computations that produce a main value (<code>A</code>) while simultaneously accumulating some output (<code>W</code>, like logs or metrics).</p>
<p>It relies on a <code>Monoid&lt;W&gt;</code> instance to combine the accumulated outputs when sequencing steps with <code>flatMap</code>. This pattern helps separate the core computation logic from the logging/accumulation aspect, leading to cleaner, more composable code.</p>
<p>The Higher-Kinded-J enables these operations to be performed generically using standard type class interfaces, with <code>Writer&lt;W,A&gt;</code> directly implementing <code>WriterKind&lt;W,A&gt;</code>.</p>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="monads/validated_monad.html">Validated</a>
<strong>Next:</strong> <a href="monads/const_type.html">Const</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="the-const-type-constant-functors-with-phantom-types"><a class="header" href="#the-const-type-constant-functors-with-phantom-types">The Const Type: Constant Functors with Phantom Types</a></h1>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="monads/const_type.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>Understanding phantom types and how Const ignores its second type parameter</li>
<li>Using Const for efficient fold implementations and data extraction</li>
<li>Leveraging Const with bifunctor operations to transform constant values</li>
<li>Applying Const in lens and traversal patterns for compositional getters</li>
<li>Real-world use cases in validation, accumulation, and data mining</li>
<li>How Const relates to Scala's Const and van Laarhoven lenses</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code:</p>
</div>
<a class="admonition-anchor-link" href="monads/const_type.html#admonition-see-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/constant/ConstExample.java">ConstExample.java</a></p>
</div>
</div>
<p>The <code>Const</code> type is a constant functor that holds a value of type <code>C</code> whilst treating <code>A</code> as a <strong>phantom type parameter</strong>: a type that exists only in the type signature but has no runtime representation. This seemingly simple property unlocks powerful patterns for accumulating values, implementing efficient folds, and building compositional getters in the style of van Laarhoven lenses.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="monads/const_type.html#admonition-note"></a>
</div>
<div>
<p>New to phantom types? See the <a href="monads/../glossary.html#phantom-type">Glossary</a> for a detailed explanation with Java-focused examples, or continue reading for practical demonstrations.</p>
</div>
</div>
<hr />
<h2 id="what-is-const"><a class="header" href="#what-is-const">What is Const?</a></h2>
<p>A <code>Const&lt;C, A&gt;</code> is a container that holds a single value of type <code>C</code>. The type parameter <code>A</code> is phantom: it influences the type signature for composition and type safety but doesn't correspond to any stored data. This asymmetry is the key to Const's utility.</p>
<pre><code class="language-java">// Create a Const holding a String, with Integer as the phantom type
Const&lt;String, Integer&gt; stringConst = new Const&lt;&gt;("Hello");

// The constant value is always accessible
String value = stringConst.value(); // "Hello"

// Create a Const holding a count, with Person as the phantom type
Const&lt;Integer, Person&gt; countConst = new Const&lt;&gt;(42);
int count = countConst.value(); // 42
</code></pre>
<h3 id="key-characteristics"><a class="header" href="#key-characteristics">Key Characteristics</a></h3>
<ul>
<li><strong>Constant value</strong>: Holds a value of type <code>C</code> that can be retrieved via <code>value()</code></li>
<li><strong>Phantom type</strong>: The type parameter <code>A</code> exists only for type-level composition</li>
<li><strong>Bifunctor instance</strong>: Implements <code>Bifunctor&lt;ConstKind2.Witness&gt;</code> where:
<ul>
<li><code>first(f, const)</code> transforms the constant value</li>
<li><code>second(g, const)</code> changes only the phantom type, leaving the constant value unchanged</li>
<li><code>bimap(f, g, const)</code> combines both transformations (but only <code>f</code> affects the constant)</li>
</ul>
</li>
</ul>
<hr />
<h2 id="core-components-4"><a class="header" href="#core-components-4">Core Components</a></h2>
<p><strong>The Const Type</strong></p>
<pre><code class="language-java">public record Const&lt;C, A&gt;(C value) {
  public &lt;D&gt; Const&lt;D, A&gt; mapFirst(Function&lt;? super C, ? extends D&gt; firstMapper);
  public &lt;B&gt; Const&lt;C, B&gt; mapSecond(Function&lt;? super A, ? extends B&gt; secondMapper);
  public &lt;D, B&gt; Const&lt;D, B&gt; bimap(
      Function&lt;? super C, ? extends D&gt; firstMapper,
      Function&lt;? super A, ? extends B&gt; secondMapper);
}
</code></pre>
<p><strong>The HKT Bridge for Const</strong></p>
<ul>
<li><strong><code>ConstKind2&lt;C, A&gt;</code></strong>: The HKT marker interface extending <code>Kind2&lt;ConstKind2.Witness, C, A&gt;</code></li>
<li><strong><code>ConstKind2.Witness</code></strong>: The phantom type witness for Const in the Kind2 system</li>
<li><strong><code>ConstKindHelper</code></strong>: Utility providing <code>widen2</code> and <code>narrow2</code> for Kind2 conversions</li>
</ul>
<p><strong>Type Classes for Const</strong></p>
<ul>
<li><strong><code>ConstBifunctor</code></strong>: The singleton bifunctor instance implementing <code>Bifunctor&lt;ConstKind2.Witness&gt;</code></li>
</ul>
<hr />
<h2 id="the-phantom-type-property"><a class="header" href="#the-phantom-type-property">The Phantom Type Property</a></h2>
<p>The defining characteristic of <code>Const</code> is that mapping over the second type parameter has <strong>no effect</strong> on the constant value. This property is enforced both conceptually and at runtime.</p>
<div id="admonition-example-phantom-type-transformations" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-phantom-type-transformations-title">
<div class="admonition-title">
<div id="admonition-example-phantom-type-transformations-title">
<p>Example: Phantom Type Transformations</p>
</div>
<a class="admonition-anchor-link" href="monads/const_type.html#admonition-example-phantom-type-transformations"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/constant/ConstExample.java">ConstExample.java</a></p>
<pre><code class="language-java">import static org.higherkindedj.hkt.constant.ConstKindHelper.CONST;

Bifunctor&lt;ConstKind2.Witness&gt; bifunctor = ConstBifunctor.INSTANCE;

// Start with a Const holding an integer count
Const&lt;Integer, String&gt; original = new Const&lt;&gt;(42);
System.out.println("Original value: " + original.value());
// Output: 42

// Use second() to change the phantom type from String to Double
Kind2&lt;ConstKind2.Witness, Integer, Double&gt; transformed =
    bifunctor.second(
        s -&gt; s.length() * 2.0, // Function defines phantom type transformation
        CONST.widen2(original));

Const&lt;Integer, Double&gt; result = CONST.narrow2(transformed);
System.out.println("After second(): " + result.value());
// Output: 42 (UNCHANGED!)

// The phantom type changed (String -&gt; Double), but the constant value stayed 42
</code></pre>
<p><strong>Note:</strong> Whilst the mapper function in <code>second()</code> is never applied to actual data (since <code>A</code> is phantom), it is still validated and applied to <code>null</code> for exception propagation. This maintains consistency with bifunctor exception semantics.</p>
</div>
</div>
<hr />
<h2 id="const-as-a-bifunctor"><a class="header" href="#const-as-a-bifunctor">Const as a Bifunctor</a></h2>
<p><code>Const</code> naturally implements the <code>Bifunctor</code> type class, providing three fundamental operations:</p>
<h3 id="1-first---transform-the-constant-value"><a class="header" href="#1-first---transform-the-constant-value">1. <code>first()</code> - Transform the Constant Value</a></h3>
<p>The <code>first</code> operation transforms the <strong>constant value</strong> from type <code>C</code> to type <code>D</code>, leaving the phantom type unchanged.</p>
<pre><code class="language-java">Const&lt;String, Integer&gt; stringConst = new Const&lt;&gt;("hello");

// Transform the constant value from String to Integer
Kind2&lt;ConstKind2.Witness, Integer, Integer&gt; lengthConst =
    bifunctor.first(String::length, CONST.widen2(stringConst));

Const&lt;Integer, Integer&gt; result = CONST.narrow2(lengthConst);
System.out.println(result.value()); // Output: 5
</code></pre>
<h3 id="2-second---transform-only-the-phantom-type"><a class="header" href="#2-second---transform-only-the-phantom-type">2. <code>second()</code> - Transform Only the Phantom Type</a></h3>
<p>The <code>second</code> operation changes the <strong>phantom type</strong> from <code>A</code> to <code>B</code> without affecting the constant value.</p>
<pre><code class="language-java">Const&lt;String, Integer&gt; stringConst = new Const&lt;&gt;("constant");

// Change the phantom type from Integer to Boolean
Kind2&lt;ConstKind2.Witness, String, Boolean&gt; boolConst =
    bifunctor.second(i -&gt; i &gt; 10, CONST.widen2(stringConst));

Const&lt;String, Boolean&gt; result = CONST.narrow2(boolConst);
System.out.println(result.value()); // Output: "constant" (unchanged)
</code></pre>
<h3 id="3-bimap---transform-both-simultaneously"><a class="header" href="#3-bimap---transform-both-simultaneously">3. <code>bimap()</code> - Transform Both Simultaneously</a></h3>
<p>The <code>bimap</code> operation combines both transformations, but remember: only the first function affects the constant value.</p>
<pre><code class="language-java">Const&lt;String, Integer&gt; original = new Const&lt;&gt;("hello");

Kind2&lt;ConstKind2.Witness, Integer, String&gt; transformed =
    bifunctor.bimap(
        String::length,          // Transforms constant: "hello" -&gt; 5
        i -&gt; "Number: " + i,     // Phantom type transformation only
        CONST.widen2(original));

Const&lt;Integer, String&gt; result = CONST.narrow2(transformed);
System.out.println(result.value()); // Output: 5
</code></pre>
<hr />
<h2 id="use-case-1-efficient-fold-implementations"><a class="header" href="#use-case-1-efficient-fold-implementations">Use Case 1: Efficient Fold Implementations</a></h2>
<p>One of the most practical applications of <code>Const</code> is implementing folds that accumulate a single value whilst traversing a data structure. The phantom type represents the "shape" being traversed, whilst the constant value accumulates the result.</p>
<div id="admonition-example-folding-with-const" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-folding-with-const-title">
<div class="admonition-title">
<div id="admonition-example-folding-with-const-title">
<p>Example: Folding with Const</p>
</div>
<a class="admonition-anchor-link" href="monads/const_type.html#admonition-example-folding-with-const"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/constant/ConstExample.java">ConstExample.java</a></p>
<pre><code class="language-java">// Count elements in a list using Const
List&lt;String&gt; items = List.of("apple", "banana", "cherry", "date");

Const&lt;Integer, String&gt; count = items.stream()
    .reduce(
        new Const&lt;&gt;(0),                                           // Initial count
        (acc, item) -&gt; new Const&lt;Integer, String&gt;(acc.value() + 1), // Increment
        (c1, c2) -&gt; new Const&lt;&gt;(c1.value() + c2.value()));        // Combine

System.out.println("Count: " + count.value());
// Output: 4

// Accumulate total length of all strings
Const&lt;Integer, String&gt; totalLength = items.stream()
    .reduce(
        new Const&lt;&gt;(0),
        (acc, item) -&gt; new Const&lt;Integer, String&gt;(acc.value() + item.length()),
        (c1, c2) -&gt; new Const&lt;&gt;(c1.value() + c2.value()));

System.out.println("Total length: " + totalLength.value());
// Output: 23
</code></pre>
<p>In this pattern, the phantom type (<code>String</code>) represents the type of elements we're folding over, whilst the constant value (<code>Integer</code>) accumulates the result. This mirrors the implementation of folds in libraries like <a href="https://typelevel.org/cats/datatypes/const.html">Cats</a> and <a href="https://github.com/scalaz/scalaz">Scalaz</a> in Scala.</p>
</div>
</div>
<hr />
<h2 id="use-case-2-getters-and-van-laarhoven-lenses"><a class="header" href="#use-case-2-getters-and-van-laarhoven-lenses">Use Case 2: Getters and Van Laarhoven Lenses</a></h2>
<p><code>Const</code> is fundamental to the lens pattern pioneered by Edward Kmett and popularised in Scala libraries like <a href="https://www.optics.dev/Monocle/">Monocle</a>. A lens is an abstraction for focusing on a part of a data structure, and <code>Const</code> enables the "getter" half of this abstraction.</p>
<h3 id="the-getter-pattern"><a class="header" href="#the-getter-pattern">The Getter Pattern</a></h3>
<p>A getter extracts a field from a structure without transforming it. Using <code>Const</code>, we represent this as a function that produces a <code>Const</code> where the phantom type tracks the source structure.</p>
<div id="admonition-example-compositional-getters" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-compositional-getters-title">
<div class="admonition-title">
<div id="admonition-example-compositional-getters-title">
<p>Example: Compositional Getters</p>
</div>
<a class="admonition-anchor-link" href="monads/const_type.html#admonition-example-compositional-getters"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/constant/ConstExample.java">ConstExample.java</a></p>
<pre><code class="language-java">record Person(String name, int age, String city) {}
record Company(String name, Person ceo) {}

Person alice = new Person("Alice", 30, "London");
Company acmeCorp = new Company("ACME Corp", alice);

// Define a getter using Const
Function&lt;Person, Const&lt;String, Person&gt;&gt; nameGetter =
    person -&gt; new Const&lt;&gt;(person.name());

// Extract the name
Const&lt;String, Person&gt; nameConst = nameGetter.apply(alice);
System.out.println("CEO name: " + nameConst.value());
// Output: Alice

// Define a getter for the CEO from a Company
Function&lt;Company, Const&lt;Person, Company&gt;&gt; ceoGetter =
    company -&gt; new Const&lt;&gt;(company.ceo());

// Compose getters: get CEO name from Company using mapFirst
Function&lt;Company, Const&lt;String, Company&gt;&gt; ceoNameGetter = company -&gt;
    ceoGetter.apply(company)
        .mapFirst(person -&gt; nameGetter.apply(person).value());

Const&lt;String, Company&gt; result = ceoNameGetter.apply(acmeCorp);
System.out.println("Company CEO name: " + result.value());
// Output: Alice
</code></pre>
<p>This pattern is the foundation of van Laarhoven lenses, where <code>Const</code> is used with <code>Functor</code> or <code>Applicative</code> to implement compositional getters. For a deeper dive, see <a href="https://www.twanvl.nl/blog/haskell/cps-functional-references">Van Laarhoven Lenses</a> and <a href="https://www.optics.dev/Monocle/docs/focus">Scala Monocle</a>.</p>
</div>
</div>
<hr />
<h2 id="use-case-3-data-extraction-from-validation-results"><a class="header" href="#use-case-3-data-extraction-from-validation-results">Use Case 3: Data Extraction from Validation Results</a></h2>
<p>When traversing validation results, you often want to extract accumulated errors or valid data without transforming the individual results. <code>Const</code> provides a clean way to express this pattern.</p>
<div id="admonition-example-validation-data-mining" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-validation-data-mining-title">
<div class="admonition-title">
<div id="admonition-example-validation-data-mining-title">
<p>Example: Validation Data Mining</p>
</div>
<a class="admonition-anchor-link" href="monads/const_type.html#admonition-example-validation-data-mining"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/constant/ConstExample.java">ConstExample.java</a></p>
<pre><code class="language-java">record ValidationResult(boolean isValid, List&lt;String&gt; errors, Object data) {}

List&lt;ValidationResult&gt; results = List.of(
    new ValidationResult(true, List.of(), "Valid data 1"),
    new ValidationResult(false, List.of("Error A", "Error B"), null),
    new ValidationResult(true, List.of(), "Valid data 2"),
    new ValidationResult(false, List.of("Error C"), null)
);

// Extract all errors using Const
List&lt;String&gt; allErrors = new ArrayList&lt;&gt;();

for (ValidationResult result : results) {
    // Use Const to extract errors, phantom type represents ValidationResult
    Const&lt;List&lt;String&gt;, ValidationResult&gt; errorConst = new Const&lt;&gt;(result.errors());
    allErrors.addAll(errorConst.value());
}

System.out.println("All errors: " + allErrors);
// Output: [Error A, Error B, Error C]

// Count valid results
Const&lt;Integer, ValidationResult&gt; validCount = results.stream()
    .reduce(
        new Const&lt;&gt;(0),
        (acc, result) -&gt; new Const&lt;Integer, ValidationResult&gt;(
            result.isValid() ? acc.value() + 1 : acc.value()),
        (c1, c2) -&gt; new Const&lt;&gt;(c1.value() + c2.value()));

System.out.println("Valid results: " + validCount.value());
// Output: 2
</code></pre>
<p>The phantom type maintains the "context" of what we're extracting from (ValidationResult), whilst the constant value accumulates the data we care about (errors or counts).</p>
</div>
</div>
<hr />
<h2 id="const-vs-other-types"><a class="header" href="#const-vs-other-types">Const vs Other Types</a></h2>
<p>Understanding how <code>Const</code> relates to similar types clarifies its unique role:</p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>First Parameter</th><th>Second Parameter</th><th>Primary Use</th></tr></thead><tbody>
<tr><td><code>Const&lt;C, A&gt;</code></td><td>Constant value (stored)</td><td>Phantom (not stored)</td><td>Folds, getters, extraction</td></tr>
<tr><td><code>Tuple2&lt;A, B&gt;</code></td><td>First element (stored)</td><td>Second element (stored)</td><td>Pairing related values</td></tr>
<tr><td><code>Identity&lt;A&gt;</code></td><td>Value (stored)</td><td>N/A (single parameter)</td><td>Pure computation wrapper</td></tr>
<tr><td><code>Either&lt;L, R&gt;</code></td><td>Error (sum type)</td><td>Success (sum type)</td><td>Error handling</td></tr>
</tbody></table>
</div>
<p><strong>Use Const when:</strong></p>
<ul>
<li>You need to accumulate a single value during traversal</li>
<li>You're implementing getters or read-only lenses</li>
<li>You want to extract data without transformation</li>
<li>The phantom type provides useful type-level information for composition</li>
</ul>
<p><strong>Use Tuple2 when:</strong></p>
<ul>
<li>You need to store and work with both values</li>
<li>Both parameters represent actual data</li>
</ul>
<p><strong>Use Identity when:</strong></p>
<ul>
<li>You need a minimal monad wrapper with no additional effects</li>
</ul>
<hr />
<h2 id="exception-propagation-note"><a class="header" href="#exception-propagation-note">Exception Propagation Note</a></h2>
<p>Although <code>mapSecond</code> doesn't transform the constant value, the mapper function is still applied to <code>null</code> to ensure exception propagation. This maintains consistency with bifunctor semantics.</p>
<pre><code class="language-java">Const&lt;String, Integer&gt; const_ = new Const&lt;&gt;("value");

// This will throw NullPointerException from the mapper
Const&lt;String, Double&gt; result = const_.mapSecond(i -&gt; {
    if (i == null) throw new NullPointerException("Expected non-null");
    return i * 2.0;
});
</code></pre>
<p>This behaviour ensures that invalid mappers are detected, even though the mapper's result isn't used. For null-safe mappers, simply avoid dereferencing the parameter:</p>
<pre><code class="language-java">// Null-safe phantom type transformation
Const&lt;String, Double&gt; safe = const_.mapSecond(i -&gt; 3.14);
</code></pre>
<hr />
<h2 id="summary-24"><a class="header" href="#summary-24">Summary</a></h2>
<ul>
<li><strong>Const&lt;C, A&gt;</strong> holds a constant value of type <code>C</code> with a phantom type parameter <code>A</code></li>
<li><strong>Phantom types</strong> exist only in type signatures, enabling type-safe composition without runtime overhead</li>
<li><strong>Bifunctor operations</strong>:
<ul>
<li><code>first</code> transforms the constant value</li>
<li><code>second</code> changes only the phantom type</li>
<li><code>bimap</code> combines both (but only affects the constant via the first function)</li>
</ul>
</li>
<li><strong>Use cases</strong>:
<ul>
<li>Efficient fold implementations that accumulate a single value</li>
<li>Compositional getters in lens and traversal patterns</li>
<li>Data extraction from complex structures without transformation</li>
</ul>
</li>
<li><strong>Scala heritage</strong>: Mirrors <code>Const</code> in Cats, Scalaz, and Monocle</li>
<li><strong>External resources</strong>:
<ul>
<li><a href="https://typelevel.org/cats/datatypes/const.html">Cats Const Documentation</a></li>
<li><a href="https://www.optics.dev/Monocle/docs/optics/getter">Monocle Getter Optics</a></li>
<li><a href="https://www.twanvl.nl/blog/haskell/cps-functional-references">Van Laarhoven Lenses</a></li>
</ul>
</li>
</ul>
<p>Understanding <code>Const</code> empowers you to write efficient, compositional code for data extraction and accumulation, leveraging patterns battle-tested in the Scala functional programming ecosystem.</p>
<hr />
<p><strong>Previous:</strong> <a href="monads/writer_monad.html">Writer</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="a-blog-on-types-and-functional-patterns"><a class="header" href="#a-blog-on-types-and-functional-patterns">A Blog on Types and Functional Patterns</a></h1>
<p>This blog series provides excellent background reading whilst you're learning the techniques used in Higher-Kinded-J. Each post builds foundational knowledge that will deepen your understanding of functional programming patterns in Java.</p>
<p>This web series explores the foundational ideas that inspired Higher-Kinded-J's development.</p>
<ul>
<li><a href="https://blog.scottlogic.com/2025/01/20/algebraic-data-types-with-java.html">Algebraic Data Types and Pattern Matching with Java</a></li>
</ul>
<p>In this post, we explore the power of Algebraic Data Types (ADT) with Pattern Matching in Java. We look at how they help us model complex business domains and how using them together gives improvements on the traditional Visitor Pattern.</p>
<ul>
<li><a href="https://blog.scottlogic.com/2025/02/17/variance-in-java-and-scala.html">Variance in Generics, Phantom and Existential types with Java and Scala</a></li>
</ul>
<p>In this post, we look at Variance in Generics and how it is handled in Java and Scala. We consider use-site and declaration-site approaches and the trade-offs of erasure. Finally, we take a look at Phantom and Existential types and how they can enhance the capabilities of the type system when it comes to modelling.</p>
<ul>
<li><a href="https://blog.scottlogic.com/2025/03/05/intersection-and-union-types-with-java-and-scala.html">Intersection and Union types with Java and Scala</a></li>
</ul>
<p>In this post, we will see how Intersection types help us better model type constraints, promoting reuse, and how Union types increase code flexibility. We will compare and contrast approaches and how to use them in the latest Java and Scala.</p>
<ul>
<li><a href="https://blog.scottlogic.com/2025/03/31/functors-monads-with-java-and-scala.html">Functors and Monads with Java and Scala</a></li>
</ul>
<p>Learn about how Functors and Monads provide patterns to write cleaner, more composable, and robust code that helps us deal with operations like handling nulls, managing errors and sequencing asynchronous actions.</p>
<ul>
<li><a href="https://blog.scottlogic.com/2025/04/11/higher-kinded-types-with-java-and-scala.html">Higher Kinded Types with Java and Scala</a></li>
</ul>
<p>In this post, we will see how Higher Kinded Types can help increase the flexibility of our code and reduce duplication.</p>
<ul>
<li><a href="https://blog.scottlogic.com/2025/05/02/recursion-thunks-trampolines-with-java-and-scala.html">Recursion, Thunks and Trampolines with Java and Scala</a></li>
</ul>
<p>In this post, we will see how Thunks and Trampolines can help solve problems by converting deep stack-based recursion into heap-based iteration, helping to prevent StackOverflowErrors.</p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="glossary-of-functional-programming-terms"><a class="header" href="#glossary-of-functional-programming-terms">Glossary of Functional Programming Terms</a></h1>
<div id="admonition-what-this-section-covers" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-this-section-covers-title">
<div class="admonition-title">
<div id="admonition-what-this-section-covers-title">
<p>What This Section Covers</p>
</div>
<a class="admonition-anchor-link" href="glossary.html#admonition-what-this-section-covers"></a>
</div>
<div>
<ul>
<li>Key terminology used throughout Higher-Kinded-J documentation</li>
<li>Explanations tailored for mid-level Java developers</li>
<li>Practical examples to reinforce understanding</li>
<li>Quick reference for concepts you encounter whilst coding</li>
</ul>
</div>
</div>
<p>This glossary provides clear, practical explanations of functional programming and Higher-Kinded-J concepts. Each term includes Java-friendly explanations and examples where helpful.</p>
<hr />
<h2 id="type-system-concepts"><a class="header" href="#type-system-concepts">Type System Concepts</a></h2>
<h3 id="contravariant"><a class="header" href="#contravariant">Contravariant</a></h3>
<p><strong>Definition:</strong> A type parameter is contravariant when it appears in an "input" or "consumer" position. If <code>A</code> is a subtype of <code>B</code>, then <code>F&lt;B&gt;</code> can be treated as a subtype of <code>F&lt;A&gt;</code> when accepting values (note the direction reversal!).</p>
<p><strong>Java Analogy:</strong> Think of <code>? super T</code> in Java generics: this is contravariant. Also, function parameters are contravariant.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Contravariant behaviour in Java (function parameters)
// A function accepting Object can be used where one accepting String is expected
Comparator&lt;Object&gt; objectComparator = (a, b) -&gt; a.toString().compareTo(b.toString());
Comparator&lt;String&gt; stringComparator = objectComparator; // ✅ Valid - contravariance in action

// Note: Java's Consumer&lt;T&gt; is invariant, so Consumer&lt;Object&gt; ≠ Consumer&lt;String&gt;
// But function *parameters* are naturally contravariant

// In Higher-Kinded-J: Profunctor's first parameter is contravariant
Profunctor&lt;FunctionKind.Witness&gt; prof = FunctionProfunctor.INSTANCE;

Function&lt;String, Integer&gt; stringLength = String::length;
// lmap is contravariant - we pre-process the INPUT
Kind2&lt;FunctionKind.Witness, Integer, Integer&gt; intLength =
    prof.lmap(Object::toString, FUNCTION.widen(stringLength));
// Now accepts Integer input by converting it to String first
</code></pre>
<p><strong>Think Of It As:</strong> "Values flow INTO the container" - you're consuming/accepting data.</p>
<p><strong>Important:</strong> The direction is reversed! A function that accepts <code>Object</code> is more flexible than one that accepts only <code>String</code>, so <code>Function&lt;Object, R&gt;</code> is a "subtype" of <code>Function&lt;String, R&gt;</code> in terms of what it can handle.</p>
<p><strong>Where You'll See It:</strong></p>
<ul>
<li>The first parameter of Profunctor (input side)</li>
<li>Function parameters</li>
<li>Consumer types</li>
</ul>
<hr />
<h3 id="covariant"><a class="header" href="#covariant">Covariant</a></h3>
<p><strong>Definition:</strong> A type parameter is covariant when it appears in an "output" or "producer" position. If <code>A</code> is a subtype of <code>B</code>, then <code>F&lt;A&gt;</code> can be treated as a subtype of <code>F&lt;B&gt;</code> when reading values.</p>
<p><strong>Java Analogy:</strong> Think of <code>? extends T</code> in Java generics: this is covariant.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Covariant behaviour in Java collections (read-only)
List&lt;? extends Number&gt; numbers = new ArrayList&lt;Integer&gt;();
Number n = numbers.get(0); // ✅ Safe to read out as Number

// In Higher-Kinded-J: Functor is covariant in its type parameter
Functor&lt;ListKind.Witness&gt; functor = ListFunctor.INSTANCE;
Kind&lt;ListKind.Witness, Integer&gt; ints = LIST.widen(List.of(1, 2, 3));
Kind&lt;ListKind.Witness, String&gt; strings = functor.map(Object::toString, ints);
// Integer -&gt; String transformation (output direction)
</code></pre>
<p><strong>Think Of It As:</strong> "Values flow OUT of the container" - you're producing/reading data.</p>
<p><strong>Where You'll See It:</strong></p>
<ul>
<li>Functor's type parameter (transforms outputs)</li>
<li>Bifunctor's both parameters (both are outputs)</li>
<li>The second parameter of Profunctor (output side)</li>
<li>Return types of functions</li>
</ul>
<hr />
<h3 id="invariant"><a class="header" href="#invariant">Invariant</a></h3>
<p><strong>Definition:</strong> A type parameter is invariant when it appears in both input and output positions, or when the type doesn't allow any subtype substitution.</p>
<p><strong>Java Analogy:</strong> Most mutable collections in Java are invariant: <code>List&lt;Integer&gt;</code> is not a subtype of <code>List&lt;Number&gt;</code>.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Invariant behaviour in Java
List&lt;Integer&gt; ints = new ArrayList&lt;&gt;();
List&lt;Number&gt; nums = ints; // ❌ Compilation error!
// Not allowed because:
// - You could read Number (covariant)
// - You could write Number (contravariant)
// Both directions would violate type safety with mutable collections

// In Higher-Kinded-J: MonadError's error type is typically invariant
MonadError&lt;EitherKind.Witness&lt;String&gt;, String&gt; monadError = EitherMonadError.instance();
// The String error type is fixed; you can't substitute it with Object or CharSequence
</code></pre>
<p><strong>Think Of It As:</strong> "Locked to exactly this type" - no flexibility in either direction.</p>
<p><strong>Where You'll See It:</strong></p>
<ul>
<li>Mutable collections</li>
<li>Types used in both input and output positions</li>
<li>Type parameters that don't participate in transformation operations</li>
</ul>
<hr />
<h3 id="variance-summary-table"><a class="header" href="#variance-summary-table">Variance Summary Table</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Variance</th><th>Direction</th><th>Java Analogy</th><th>Example Type Class</th><th>Intuition</th></tr></thead><tbody>
<tr><td><strong>Covariant</strong></td><td>Output/Producer</td><td><code>? extends T</code></td><td>Functor, Applicative, Monad</td><td>"Reading out"</td></tr>
<tr><td><strong>Contravariant</strong></td><td>Input/Consumer</td><td><code>? super T</code></td><td>Profunctor (first param)</td><td>"Writing in" (reversed)</td></tr>
<tr><td><strong>Invariant</strong></td><td>Neither/Both</td><td>No wildcards</td><td>Monad error type</td><td>"Exact match required"</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="higher-kinded-type-simulation"><a class="header" href="#higher-kinded-type-simulation">Higher-Kinded Type Simulation</a></h2>
<h3 id="defunctionalisation"><a class="header" href="#defunctionalisation">Defunctionalisation</a></h3>
<p><strong>Definition:</strong> A technique for simulating higher-kinded types in languages that don't natively support them. Instead of passing type constructors as parameters, we represent them with marker types (witnesses) and use these as ordinary type parameters.</p>
<p><strong>The Problem It Solves:</strong> Java's type system cannot parametrise over type constructors. You cannot write <code>&lt;F&lt;_&gt;&gt;</code> in Java to mean "any container type F". Defunctionalisation works around this by using witness types to represent type constructors.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// ❌ What we'd like to write but can't in Java:
public &lt;F&lt;_&gt;, A, B&gt; F&lt;B&gt; map(Function&lt;A, B&gt; f, F&lt;A&gt; fa) { ... }

// ✅ What we write using defunctionalisation:
public &lt;F, A, B&gt; Kind&lt;F, B&gt; map(Function&lt;A, B&gt; f, Kind&lt;F, A&gt; fa) { ... }
// Where F is a witness type like OptionalKind.Witness or ListKind.Witness
</code></pre>
<p><strong>How It Works:</strong></p>
<ol>
<li>Define a marker interface (witness type) for each type constructor (e.g., <code>ListKind.Witness</code> for <code>List</code>)</li>
<li>Use <code>Kind&lt;F, A&gt;</code> where <code>F</code> is the witness and <code>A</code> is the type parameter</li>
<li>Provide helper methods to convert between concrete types and their <code>Kind</code> representations</li>
</ol>
<p><strong>Where You'll See It:</strong> Throughout the Higher-Kinded-J library - it's the foundation of the entire HKT simulation.</p>
<p><strong>Related:</strong> <a href="hkts/core-concepts.html">Core Concepts</a></p>
<hr />
<h3 id="higher-kinded-type-hkt"><a class="header" href="#higher-kinded-type-hkt">Higher-Kinded Type (HKT)</a></h3>
<p><strong>Definition:</strong> A type that abstracts over type constructors. In languages with HKT support, you can write generic code that works with any "container" type like <code>List</code>, <code>Optional</code>, or <code>CompletableFuture</code> without knowing which one at compile time.</p>
<p><strong>Java Analogy:</strong> Regular generics let you abstract over types (<code>&lt;T&gt;</code>). Higher-kinded types let you abstract over type constructors (<code>&lt;F&lt;_&gt;&gt;</code>).</p>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Regular generics (abstracting over types):
public &lt;T&gt; T identity(T value) { return value; }

// Higher-kinded types (abstracting over type constructors):
public &lt;F&gt; Kind&lt;F, Integer&gt; increment(Functor&lt;F&gt; functor, Kind&lt;F, Integer&gt; fa) {
    return functor.map(x -&gt; x + 1, fa);
}

// Works with any Functor:
increment(OptionalFunctor.INSTANCE, OPTIONAL.widen(Optional.of(5)));  // Optional[6]
increment(ListFunctor.INSTANCE, LIST.widen(List.of(1, 2, 3)));        // [2, 3, 4]
</code></pre>
<p><strong>Why It Matters:</strong> Enables writing truly generic, reusable functional code that works across different container types.</p>
<p><strong>Related:</strong> <a href="hkts/hkt_introduction.html">HKT Introduction</a></p>
<hr />
<h3 id="kind"><a class="header" href="#kind">Kind</a></h3>
<p><strong>Definition:</strong> The core interface in Higher-Kinded-J that simulates higher-kinded types. <code>Kind&lt;F, A&gt;</code> represents a type constructor <code>F</code> applied to a type <code>A</code>.</p>
<p><strong>Structure:</strong></p>
<ul>
<li><code>Kind&lt;F, A&gt;</code> - Single type parameter (e.g., <code>List&lt;A&gt;</code>, <code>Optional&lt;A&gt;</code>)</li>
<li><code>Kind2&lt;F, A, B&gt;</code> - Two type parameters (e.g., <code>Either&lt;A, B&gt;</code>, <code>Function&lt;A, B&gt;</code>)</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Standard Java types and their Kind representations:
Optional&lt;String&gt;           ≈ Kind&lt;OptionalKind.Witness, String&gt;
List&lt;Integer&gt;              ≈ Kind&lt;ListKind.Witness, Integer&gt;
Either&lt;String, Integer&gt;    ≈ Kind2&lt;EitherKind2.Witness, String, Integer&gt;
Function&lt;String, Integer&gt;  ≈ Kind2&lt;FunctionKind.Witness, String, Integer&gt;

// Converting between representations:
Optional&lt;String&gt; opt = Optional.of("hello");
Kind&lt;OptionalKind.Witness, String&gt; kindOpt = OPTIONAL.widen(opt);
Optional&lt;String&gt; backToOpt = OPTIONAL.narrow(kindOpt);
</code></pre>
<p><strong>Think Of It As:</strong> A wrapper that allows Java's type system to work with type constructors generically.</p>
<p><strong>Note on Either:</strong> Either has two witness types depending on usage:</p>
<ul>
<li><code>EitherKind.Witness&lt;L&gt;</code> for <code>Kind&lt;EitherKind.Witness&lt;L&gt;, R&gt;</code> - used with Functor/Monad (right-biased)</li>
<li><code>EitherKind2.Witness</code> for <code>Kind2&lt;EitherKind2.Witness, L, R&gt;</code> - used with Bifunctor (both sides)</li>
</ul>
<p><strong>Related:</strong> <a href="hkts/core-concepts.html">Core Concepts</a></p>
<hr />
<h3 id="type-constructor"><a class="header" href="#type-constructor">Type Constructor</a></h3>
<p><strong>Definition:</strong> A type that takes one or more type parameters to produce a concrete type. In other words, it's a "type function" that constructs types.</p>
<p><strong>Examples:</strong></p>
<pre><code class="language-java">// List is a type constructor
List      // Not a complete type (needs a parameter)
List&lt;T&gt;   // Type constructor applied to parameter T
List&lt;String&gt;  // Concrete type

// Either is a type constructor with two parameters
Either           // Not a complete type
Either&lt;L, R&gt;     // Type constructor applied to parameters L and R
Either&lt;String, Integer&gt;  // Concrete type

// Optional is a type constructor
Optional         // Not a complete type
Optional&lt;T&gt;      // Type constructor applied to parameter T
Optional&lt;String&gt; // Concrete type
</code></pre>
<p><strong>Notation:</strong> Often written with an underscore to show the "hole": <code>List&lt;_&gt;</code>, <code>Either&lt;String, _&gt;</code>, <code>Optional&lt;_&gt;</code></p>
<p><strong>Why It Matters:</strong> Type constructors are what we abstract over with higher-kinded types. Understanding them is key to understanding HKTs.</p>
<hr />
<h3 id="witness-type"><a class="header" href="#witness-type">Witness Type</a></h3>
<p><strong>Definition:</strong> A marker type used to represent a type constructor in the defunctionalisation pattern. Each type constructor has a corresponding witness type.</p>
<p><strong>Examples:</strong></p>
<pre><code class="language-java">// List type constructor → ListKind.Witness
public interface ListKind&lt;A&gt; extends Kind&lt;ListKind.Witness, A&gt; {
    final class Witness { private Witness() {} }
}

// Optional type constructor → OptionalKind.Witness
public interface OptionalKind&lt;A&gt; extends Kind&lt;OptionalKind.Witness, A&gt; {
    final class Witness { private Witness() {} }
}

// Either type constructor → EitherKind.Witness&lt;L&gt;
public interface EitherKind&lt;L, R&gt; extends Kind2&lt;EitherKind.Witness&lt;L&gt;, L, R&gt; {
    final class Witness&lt;L&gt; { private Witness() {} }
}
</code></pre>
<p><strong>Usage:</strong></p>
<pre><code class="language-java">// The Witness type is used as the F parameter:
Functor&lt;ListKind.Witness&gt; listFunctor = ListFunctor.INSTANCE;
Functor&lt;OptionalKind.Witness&gt; optionalFunctor = OptionalFunctor.INSTANCE;
MonadError&lt;EitherKind.Witness&lt;String&gt;, String&gt; eitherMonad = EitherMonadError.instance();
</code></pre>
<p><strong>Think Of It As:</strong> A compile-time tag that identifies which type constructor we're working with.</p>
<p><strong>Related:</strong> <a href="hkts/core-concepts.html">Core Concepts</a></p>
<hr />
<h3 id="phantom-type"><a class="header" href="#phantom-type">Phantom Type</a></h3>
<p><strong>Definition:</strong> A type parameter that appears in a type signature but has no corresponding runtime representation. It exists purely for compile-time type safety and doesn't store any actual data of that type.</p>
<p><strong>Key Characteristics:</strong></p>
<ul>
<li>Present in the type signature for type-level information</li>
<li>Never instantiated or stored at runtime</li>
<li>Used for type-safe APIs without runtime overhead</li>
<li>Enables compile-time guarantees whilst maintaining efficiency</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Const&lt;C, A&gt; uses A as a phantom type
Const&lt;String, Integer&gt; stringConst = new Const&lt;&gt;("hello");
// The Integer type parameter is phantom - no Integer is stored!

String value = stringConst.value(); // "hello"

// Mapping over the phantom type changes the signature but not the value
Const&lt;String, Double&gt; doubleConst = stringConst.mapSecond(i -&gt; i * 2.0);
System.out.println(doubleConst.value()); // Still "hello" (unchanged!)
</code></pre>
<p><strong>Common Use Cases:</strong></p>
<ul>
<li><strong>State tracking at compile time</strong>: Phantom types in state machines (e.g., <code>DatabaseConnection&lt;Closed&gt;</code> vs <code>DatabaseConnection&lt;Open&gt;</code>)</li>
<li><strong>Units of measure</strong>: Tracking units without runtime overhead (e.g., <code>Measurement&lt;Metres&gt;</code> vs <code>Measurement&lt;Feet&gt;</code>)</li>
<li><strong>Const type</strong>: The second type parameter in <code>Const&lt;C, A&gt;</code> is phantom, enabling fold and getter patterns</li>
<li><strong>Type-safe builders</strong>: Ensuring build steps are called in the correct order</li>
</ul>
<p><strong>Real-World Example:</strong></p>
<pre><code class="language-java">// State machine with phantom types
class FileHandle&lt;State&gt; {
    private File file;

    // Only available when Closed
    FileHandle&lt;Open&gt; open() { ... }
}

class Open {}
class Closed {}

// Type-safe at compile time:
FileHandle&lt;Closed&gt; closed = new FileHandle&lt;&gt;();
FileHandle&lt;Open&gt; opened = closed.open();  // ✅ Allowed
// opened.open();  // ❌ Compile error - already open!
</code></pre>
<p><strong>Benefits:</strong></p>
<ul>
<li>Zero runtime cost - no additional memory or processing</li>
<li>Compile-time safety - prevents incorrect API usage</li>
<li>Self-documenting APIs - type signature conveys intent</li>
<li>Enables advanced patterns like GADTs (Generalised Algebraic Data Types)</li>
</ul>
<p><strong>Where You'll See It:</strong></p>
<ul>
<li><code>Const&lt;C, A&gt;</code> - the <code>A</code> parameter is phantom</li>
<li>Witness types in HKT encoding (though serving a different purpose)</li>
<li>State machines and protocol enforcement</li>
<li>Type-level programming patterns</li>
</ul>
<p><strong>Related:</strong> <a href="monads/const_type.html">Const Type Documentation</a>, <a href="glossary.html#witness-type">Witness Type</a></p>
<hr />
<h2 id="functional-type-classes"><a class="header" href="#functional-type-classes">Functional Type Classes</a></h2>
<h3 id="applicative-1"><a class="header" href="#applicative-1">Applicative</a></h3>
<p><strong>Definition:</strong> A type class that extends Functor with the ability to lift pure values into a context and combine multiple independent computations.</p>
<p><strong>Core Operations:</strong></p>
<ul>
<li><code>of(A value)</code> - Lift a pure value into the context</li>
<li><code>ap(Kind&lt;F, Function&lt;A,B&gt;&gt; ff, Kind&lt;F, A&gt; fa)</code> - Apply a wrapped function to a wrapped value</li>
<li><code>map2</code>, <code>map3</code>, etc. - Combine multiple wrapped values</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">Applicative&lt;OptionalKind.Witness&gt; app = OptionalApplicative.INSTANCE;

// Lift pure values
Kind&lt;OptionalKind.Witness, Integer&gt; five = app.of(5);  // Optional[5]

// Combine independent values
Kind&lt;OptionalKind.Witness, String&gt; result = app.map2(
    app.of("Hello"),
    app.of("World"),
    (a, b) -&gt; a + " " + b
);  // Optional["Hello World"]
</code></pre>
<p><strong>When To Use:</strong> Combining multiple independent effects (form validation, parallel computations, configuration assembly).</p>
<p><strong>Related:</strong> <a href="functional/applicative.html">Applicative Documentation</a></p>
<hr />
<h3 id="bifunctor"><a class="header" href="#bifunctor">Bifunctor</a></h3>
<p><strong>Definition:</strong> A type class for types with two covariant parameters, allowing transformation of both sides independently or simultaneously.</p>
<p><strong>Core Operations:</strong></p>
<ul>
<li><code>bimap(Function&lt;A,C&gt; f, Function&lt;B,D&gt; g, Kind2&lt;F,A,B&gt; fab)</code> - Transform both parameters</li>
<li><code>first(Function&lt;A,C&gt; f, Kind2&lt;F,A,B&gt; fab)</code> - Transform only the first parameter</li>
<li><code>second(Function&lt;B,D&gt; g, Kind2&lt;F,A,B&gt; fab)</code> - Transform only the second parameter</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">Bifunctor&lt;EitherKind.Witness&gt; bifunctor = EitherBifunctor.INSTANCE;

Either&lt;String, Integer&gt; either = Either.right(42);
Kind2&lt;EitherKind.Witness, String, Integer&gt; kindEither = EITHER.widen(either);

// Transform both sides
Kind2&lt;EitherKind.Witness, Integer, String&gt; transformed =
    bifunctor.bimap(String::length, Object::toString, kindEither);
// Right("42")
</code></pre>
<p><strong>When To Use:</strong> Transforming error and success channels, working with pairs/tuples, API format conversion.</p>
<p><strong>Related:</strong> <a href="functional/bifunctor.html">Bifunctor Documentation</a></p>
<hr />
<h3 id="functor-1"><a class="header" href="#functor-1">Functor</a></h3>
<p><strong>Definition:</strong> The most basic type class for types that can be "mapped over". Allows transforming values inside a context without changing the context structure.</p>
<p><strong>Core Operation:</strong></p>
<ul>
<li><code>map(Function&lt;A,B&gt; f, Kind&lt;F,A&gt; fa)</code> - Apply a function to the wrapped value</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">Functor&lt;ListKind.Witness&gt; functor = ListFunctor.INSTANCE;

Kind&lt;ListKind.Witness, String&gt; strings = LIST.widen(List.of("one", "two"));
Kind&lt;ListKind.Witness, Integer&gt; lengths = functor.map(String::length, strings);
// [3, 3]
</code></pre>
<p><strong>Laws:</strong></p>
<ul>
<li>Identity: <code>map(x -&gt; x, fa) == fa</code></li>
<li>Composition: <code>map(g.compose(f), fa) == map(g, map(f, fa))</code></li>
</ul>
<p><strong>When To Use:</strong> Simple transformations where the context (container structure) stays the same.</p>
<p><strong>Related:</strong> <a href="functional/functor.html">Functor Documentation</a></p>
<hr />
<h3 id="monad-1"><a class="header" href="#monad-1">Monad</a></h3>
<p><strong>Definition:</strong> A type class that extends Applicative with the ability to chain dependent computations (flatMap/bind).</p>
<p><strong>Core Operation:</strong></p>
<ul>
<li><code>flatMap(Function&lt;A, Kind&lt;F,B&gt;&gt; f, Kind&lt;F,A&gt; ma)</code> - Chain computations where each depends on the previous result</li>
</ul>
<p><strong>Additional Operations:</strong></p>
<ul>
<li><code>flatMap2/3/4/5(...)</code> - Combine multiple monadic values with a function that returns a monadic value (similar to <code>map2/3/4/5</code> but with effectful combining function)</li>
<li><code>as(B value, Kind&lt;F,A&gt; ma)</code> - Replace the result while preserving the effect</li>
<li><code>peek(Consumer&lt;A&gt; action, Kind&lt;F,A&gt; ma)</code> - Perform side effect without changing the value</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">Monad&lt;OptionalKind.Witness&gt; monad = OptionalMonad.INSTANCE;

// Chain dependent operations
Kind&lt;OptionalKind.Witness, String&gt; result =
    monad.flatMap(
        userId -&gt; monad.flatMap(
            profile -&gt; findAccount(profile.accountId()),
            findProfile(userId)
        ),
        findUser("user123")
    );

// Combine multiple monadic values with effectful result
Kind&lt;OptionalKind.Witness, Order&gt; order =
    monad.flatMap2(
        findUser("user123"),
        findProduct("prod456"),
        (user, product) -&gt; validateAndCreateOrder(user, product)
    );
</code></pre>
<p><strong>Laws:</strong></p>
<ul>
<li>Left Identity: <code>flatMap(f, of(a)) == f(a)</code></li>
<li>Right Identity: <code>flatMap(of, m) == m</code></li>
<li>Associativity: <code>flatMap(g, flatMap(f, m)) == flatMap(x -&gt; flatMap(g, f(x)), m)</code></li>
</ul>
<p><strong>When To Use:</strong> Sequential operations where each step depends on the previous result (database queries, async workflows, error handling pipelines).</p>
<p><strong>Related:</strong> <a href="functional/monad.html">Monad Documentation</a></p>
<hr />
<h3 id="monoid-1"><a class="header" href="#monoid-1">Monoid</a></h3>
<p><strong>Definition:</strong> A type class for types that have an associative binary operation (<code>combine</code>) and an identity element (<code>empty</code>). Extends Semigroup by adding the identity element, making it safe for reducing empty collections.</p>
<p><strong>Core Operations:</strong></p>
<ul>
<li><code>empty()</code> - The identity element</li>
<li><code>combine(A a1, A a2)</code> - Associative binary operation (from Semigroup)</li>
<li><code>combineAll(Iterable&lt;A&gt; elements)</code> - Combine all elements in a collection</li>
<li><code>combineN(A value, int n)</code> - Combine a value with itself n times</li>
<li><code>isEmpty(A value)</code> - Test if a value equals the empty element</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">Monoid&lt;Integer&gt; intAddition = Monoids.integerAddition();

// Identity law: empty is the neutral element
intAddition.combine(5, intAddition.empty());  // 5
intAddition.combine(intAddition.empty(), 5);  // 5

// Combine a collection
List&lt;Integer&gt; numbers = List.of(1, 2, 3, 4, 5);
Integer sum = intAddition.combineAll(numbers);  // 15

// Repeated application
Integer result = intAddition.combineN(3, 4);  // 12 (3+3+3+3)

// Working with Optional values
Monoid&lt;Optional&lt;Integer&gt;&gt; maxMonoid = Monoids.maximum();
Optional&lt;Integer&gt; max = maxMonoid.combineAll(
    List.of(Optional.of(5), Optional.empty(), Optional.of(10))
);  // Optional[10]
</code></pre>
<p><strong>Common Instances in <code>Monoids</code> utility:</strong></p>
<ul>
<li><code>integerAddition()</code>, <code>longAddition()</code>, <code>doubleAddition()</code> - Numeric addition</li>
<li><code>integerMultiplication()</code>, <code>longMultiplication()</code>, <code>doubleMultiplication()</code> - Numeric multiplication</li>
<li><code>string()</code> - String concatenation</li>
<li><code>list()</code>, <code>set()</code> - Collection concatenation/union</li>
<li><code>booleanAnd()</code>, <code>booleanOr()</code> - Boolean operations</li>
<li><code>firstOptional()</code>, <code>lastOptional()</code> - First/last non-empty Optional</li>
<li><code>maximum()</code>, <code>minimum()</code> - Max/min value aggregation with Optional</li>
</ul>
<p><strong>Laws:</strong></p>
<ul>
<li>Left Identity: <code>combine(empty(), a) == a</code></li>
<li>Right Identity: <code>combine(a, empty()) == a</code></li>
<li>Associativity: <code>combine(a, combine(b, c)) == combine(combine(a, b), c)</code> (from Semigroup)</li>
</ul>
<p><strong>When To Use:</strong> Aggregating data (summing values, concatenating strings), reducing collections, folding data structures, accumulating results in parallel computations.</p>
<p><strong>Related:</strong> <a href="functional/semigroup_and_monoid.html">Semigroup and Monoid Documentation</a></p>
<hr />
<h3 id="semigroup-1"><a class="header" href="#semigroup-1">Semigroup</a></h3>
<p><strong>Definition:</strong> A type class for types that have an associative binary operation. The most fundamental algebraic structure for combining values.</p>
<p><strong>Core Operation:</strong></p>
<ul>
<li><code>combine(A a1, A a2)</code> - Associative binary operation</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">Semigroup&lt;String&gt; stringConcat = Semigroups.string();
String result = stringConcat.combine("Hello", " World");  // "Hello World"

// With custom delimiter
Semigroup&lt;String&gt; csvConcat = Semigroups.string(", ");
String csv = csvConcat.combine("apple", "banana");  // "apple, banana"

// For error accumulation in Validated
Semigroup&lt;String&gt; errorAccumulator = Semigroups.string("; ");
Applicative&lt;Validated.Witness&lt;String&gt;&gt; validator =
    ValidatedMonad.instance(errorAccumulator);
// Errors are combined: "Field A is invalid; Field B is required"
</code></pre>
<p><strong>Common Instances in <code>Semigroups</code> utility:</strong></p>
<ul>
<li><code>string()</code> - Basic string concatenation</li>
<li><code>string(String delimiter)</code> - String concatenation with delimiter</li>
<li><code>list()</code> - List concatenation</li>
<li><code>set()</code> - Set union</li>
<li><code>first()</code> - Always takes the first value</li>
<li><code>last()</code> - Always takes the last value</li>
</ul>
<p><strong>Laws:</strong></p>
<ul>
<li>Associativity: <code>combine(a, combine(b, c)) == combine(combine(a, b), c)</code></li>
</ul>
<p><strong>When To Use:</strong> Error accumulation (especially with Validated), combining partial results, building aggregators where an empty/identity value doesn't make sense.</p>
<p><strong>Related:</strong> <a href="functional/semigroup_and_monoid.html">Semigroup and Monoid Documentation</a></p>
<hr />
<h3 id="monaderror-1"><a class="header" href="#monaderror-1">MonadError</a></h3>
<p><strong>Definition:</strong> A type class that extends Monad with explicit error handling capabilities for a specific error type.</p>
<p><strong>Core Operations:</strong></p>
<ul>
<li><code>raiseError(E error)</code> - Create an error state</li>
<li><code>handleErrorWith(Kind&lt;F,A&gt; ma, Function&lt;E, Kind&lt;F,A&gt;&gt; handler)</code> - Recover from errors</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">MonadError&lt;EitherKind.Witness&lt;String&gt;, String&gt; monadError = EitherMonadError.instance();

Kind&lt;EitherKind.Witness&lt;String&gt;, Double&gt; result =
    monadError.handleErrorWith(
        divideOperation,
        error -&gt; monadError.of(0.0)  // Provide default on error
    );
</code></pre>
<p><strong>When To Use:</strong> Workflows that need explicit error handling and recovery (validation, I/O operations, API calls).</p>
<p><strong>Related:</strong> <a href="functional/monad_error.html">MonadError Documentation</a></p>
<hr />
<h3 id="monad-transformer-1"><a class="header" href="#monad-transformer-1">Monad Transformer</a></h3>
<p><strong>Definition:</strong> A type constructor that adds capabilities to an existing monad, allowing multiple effects to be combined in a single computation. Transformers "stack" effects, enabling you to work with combinations like "async computation that may fail" or "IO that produces optional values".</p>
<p><strong>Common Transformers in Higher-Kinded-J:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Transformer</th><th>Adds</th><th>Example Stack</th></tr></thead><tbody>
<tr><td><code>EitherT&lt;F, E, A&gt;</code></td><td>Error handling</td><td><code>EitherT&lt;IO, Error, A&gt;</code> - IO that may fail</td></tr>
<tr><td><code>MaybeT&lt;F, A&gt;</code></td><td>Optionality</td><td><code>MaybeT&lt;CompletableFuture, A&gt;</code> - async optional</td></tr>
<tr><td><code>StateT&lt;F, S, A&gt;</code></td><td>State threading</td><td><code>StateT&lt;Either, State, A&gt;</code> - stateful with errors</td></tr>
</tbody></table>
</div>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Problem: combining async + error handling manually is verbose
CompletableFuture&lt;Either&lt;Error, User&gt;&gt; fetchUser(String id);
CompletableFuture&lt;Either&lt;Error, Profile&gt;&gt; fetchProfile(User user);

// Without transformer: nested flatMaps
CompletableFuture&lt;Either&lt;Error, Profile&gt;&gt; result =
    fetchUser(id).thenCompose(eitherUser -&gt;
        eitherUser.fold(
            error -&gt; CompletableFuture.completedFuture(Either.left(error)),
            user -&gt; fetchProfile(user)
        )
    );

// With EitherT: flat composition
EitherT&lt;CompletableFutureKind.Witness, Error, Profile&gt; result =
    EitherT.fromKind(CF.widen(fetchUser(id)), cfMonad)
        .flatMap(user -&gt; EitherT.fromKind(CF.widen(fetchProfile(user)), cfMonad));

// Run to get the nested type back
CompletableFuture&lt;Either&lt;Error, Profile&gt;&gt; unwrapped =
    CF.narrow(result.value());
</code></pre>
<p><strong>How It Works:</strong></p>
<ol>
<li>Wrap your nested type in the transformer: <code>EitherT.fromKind(...)</code></li>
<li>Use standard monad operations (<code>map</code>, <code>flatMap</code>) on the transformer</li>
<li>The transformer handles the effect interleaving automatically</li>
<li>Unwrap when done using <code>.value()</code> or <code>.run()</code></li>
</ol>
<p><strong>Lift Operations:</strong></p>
<pre><code class="language-java">// Lift the outer monad into the transformer
EitherT&lt;IOKind.Witness, Error, String&gt; lifted =
    EitherT.liftF(IO.delay(() -&gt; "hello"), ioMonad);

// Lift an Either into the transformer
EitherT&lt;IOKind.Witness, Error, Integer&gt; fromEither =
    EitherT.fromEither(Either.right(42), ioMonad);
</code></pre>
<p><strong>When To Use:</strong></p>
<ul>
<li>Combining async operations with error handling</li>
<li>Threading state through effectful computations</li>
<li>When you need multiple effects but want flat composition</li>
<li>Building effect stacks for complex workflows</li>
</ul>
<p><strong>Trade-offs:</strong></p>
<ul>
<li>Adds complexity and potential performance overhead</li>
<li>Stack order matters: <code>EitherT&lt;IO, E, A&gt;</code> ≠ <code>IOT&lt;Either&lt;E, _&gt;, A&gt;</code></li>
<li>Consider <a href="glossary.html#effect-path">Effect Paths</a> for simpler use cases</li>
</ul>
<p><strong>Related:</strong> <a href="glossary.html#monad">Monad</a>, <a href="glossary.html#monaderror">MonadError</a>, <a href="monads/eithert_monad.html">EitherT Documentation</a></p>
<hr />
<h3 id="profunctor-1"><a class="header" href="#profunctor-1">Profunctor</a></h3>
<p><strong>Definition:</strong> A type class for types that are contravariant in their first parameter (input) and covariant in their second parameter (output). The canonical example is <code>Function&lt;A, B&gt;</code>.</p>
<p><strong>Core Operations:</strong></p>
<ul>
<li><code>lmap(Function&lt;C,A&gt; f, Kind2&lt;P,A,B&gt; pab)</code> - Pre-process the input (contravariant)</li>
<li><code>rmap(Function&lt;B,D&gt; g, Kind2&lt;P,A,B&gt; pab)</code> - Post-process the output (covariant)</li>
<li><code>dimap(Function&lt;C,A&gt; f, Function&lt;B,D&gt; g, Kind2&lt;P,A,B&gt; pab)</code> - Transform both simultaneously</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">Profunctor&lt;FunctionKind.Witness&gt; prof = FunctionProfunctor.INSTANCE;

Function&lt;String, Integer&gt; stringLength = String::length;
Kind2&lt;FunctionKind.Witness, String, Integer&gt; kindFunc = FUNCTION.widen(stringLength);

// Adapt to work with integers (converting to string first)
Kind2&lt;FunctionKind.Witness, Integer, Integer&gt; intLength =
    prof.lmap(Object::toString, kindFunc);
</code></pre>
<p><strong>When To Use:</strong> Building adaptable pipelines, API adapters, validation frameworks that need to work with different input/output formats.</p>
<p><strong>Related:</strong> <a href="functional/profunctor.html">Profunctor Documentation</a></p>
<hr />
<h3 id="selective-1"><a class="header" href="#selective-1">Selective</a></h3>
<p><strong>Definition:</strong> A type class that sits between Applicative and Monad, providing conditional effects with static structure. All branches must be known upfront, enabling static analysis.</p>
<p><strong>Core Operations:</strong></p>
<ul>
<li><code>select(Kind&lt;F, Choice&lt;A,B&gt;&gt; fab, Kind&lt;F, Function&lt;A,B&gt;&gt; ff)</code> - Conditionally apply a function</li>
<li><code>whenS(Kind&lt;F, Boolean&gt; cond, Kind&lt;F, Unit&gt; effect)</code> - Execute effect only if condition is true</li>
<li><code>ifS(Kind&lt;F, Boolean&gt; cond, Kind&lt;F, A&gt; then, Kind&lt;F, A&gt; else)</code> - If-then-else with visible branches</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">Selective&lt;IOKind.Witness&gt; selective = IOSelective.INSTANCE;

// Only log if debug is enabled
Kind&lt;IOKind.Witness, Boolean&gt; debugEnabled =
    IO_KIND.widen(IO.delay(() -&gt; config.isDebug()));
Kind&lt;IOKind.Witness, Unit&gt; logEffect =
    IO_KIND.widen(IO.fromRunnable(() -&gt; log.debug("Debug info")));

Kind&lt;IOKind.Witness, Unit&gt; conditionalLog = selective.whenS(debugEnabled, logEffect);
</code></pre>
<p><strong>When To Use:</strong> Feature flags, conditional logging, configuration-based behaviour, multi-source fallback strategies.</p>
<p><strong>Related:</strong> <a href="functional/selective.html">Selective Documentation</a></p>
<hr />
<h3 id="natural-transformation-2"><a class="header" href="#natural-transformation-2">Natural Transformation</a></h3>
<p><strong>Definition:</strong> A polymorphic function between type constructors. Given type constructors <code>F</code> and <code>G</code>, a natural transformation is a function that converts <code>F[A]</code> to <code>G[A]</code> for any type <code>A</code>, without knowing or inspecting what <code>A</code> is.</p>
<p><strong>Core Operation:</strong></p>
<ul>
<li><code>apply(Kind&lt;F, A&gt; fa)</code> - Transform from context F to context G</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Natural transformation from Maybe to List
Natural&lt;MaybeKind.Witness, ListKind.Witness&gt; maybeToList = new Natural&lt;&gt;() {
    @Override
    public &lt;A&gt; Kind&lt;ListKind.Witness, A&gt; apply(Kind&lt;MaybeKind.Witness, A&gt; fa) {
        Maybe&lt;A&gt; maybe = MAYBE.narrow(fa);
        List&lt;A&gt; list = maybe.map(List::of).orElse(List.of());
        return LIST.widen(list);
    }
};

// Use with Free monad interpretation
Free&lt;ConsoleOpKind.Witness, String&gt; program = ...;
Kind&lt;IOKind.Witness, String&gt; executable = program.foldMap(interpreter, ioMonad);
</code></pre>
<p><strong>The Naturality Law:</strong> For any function <code>f: A -&gt; B</code>:</p>
<pre><code>nat.apply(functor.map(f, fa)) == functor.map(f, nat.apply(fa))
</code></pre>
<p><strong>When To Use:</strong> Free monad/applicative interpretation, type conversions between containers, monad transformer lifting.</p>
<p><strong>Related:</strong> <a href="functional/natural_transformation.html">Natural Transformation Documentation</a></p>
<hr />
<h3 id="coyoneda-2"><a class="header" href="#coyoneda-2">Coyoneda</a></h3>
<p><strong>Definition:</strong> The "free functor" that provides automatic Functor instances for any type constructor. Coyoneda stores a value and an accumulated transformation function, deferring actual mapping until lowering.</p>
<p><strong>Core Operations:</strong></p>
<ul>
<li><code>lift(Kind&lt;F, A&gt; fa)</code> - Wrap a value in Coyoneda</li>
<li><code>map(Function&lt;A, B&gt; f)</code> - Compose functions (no Functor needed)</li>
<li><code>lower(Functor&lt;F&gt; functor)</code> - Apply accumulated function using provided Functor</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Lift into Coyoneda - no Functor required for mapping!
Coyoneda&lt;MyDSL, Integer&gt; coyo = Coyoneda.lift(myInstruction);

// Chain maps - functions are composed, not applied
Coyoneda&lt;MyDSL, String&gt; mapped = coyo
    .map(x -&gt; x * 2)
    .map(x -&gt; x + 1)
    .map(Object::toString);

// Only when lowering is the Functor used (and functions applied once)
Kind&lt;MyDSL, String&gt; result = mapped.lower(myDslFunctor);
</code></pre>
<p><strong>Key Benefit:</strong> Enables map fusion (multiple maps become one function composition) and eliminates the need for Functor instances on Free monad instruction sets.</p>
<p><strong>When To Use:</strong> With Free monads to avoid implementing Functor for every DSL instruction type; optimising chains of map operations.</p>
<p><strong>Related:</strong> <a href="monads/coyoneda.html">Coyoneda Documentation</a>, <a href="glossary.html#map-fusion">Map Fusion</a></p>
<hr />
<h3 id="free-applicative-2"><a class="header" href="#free-applicative-2">Free Applicative</a></h3>
<p><strong>Definition:</strong> The applicative counterpart to Free Monad. Whilst Free Monad captures sequential, dependent computations, Free Applicative captures independent computations that can potentially run in parallel.</p>
<p><strong>Core Operations:</strong></p>
<ul>
<li><code>pure(A value)</code> - Lift a pure value</li>
<li><code>lift(Kind&lt;F, A&gt; fa)</code> - Lift a single instruction</li>
<li><code>map2(FreeAp&lt;F, B&gt; fb, BiFunction&lt;A, B, C&gt; f)</code> - Combine independent computations</li>
<li><code>foldMap(Natural&lt;F, G&gt; nat, Applicative&lt;G&gt; app)</code> - Interpret using a natural transformation</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Independent computations - can run in parallel
FreeAp&lt;DbOp, User&gt; userFetch = FreeAp.lift(new GetUser(userId));
FreeAp&lt;DbOp, List&lt;Post&gt;&gt; postsFetch = FreeAp.lift(new GetPosts(userId));

// Combine them - neither depends on the other's result
FreeAp&lt;DbOp, UserProfile&gt; profile = userFetch.map2(
    postsFetch,
    UserProfile::new
);

// Smart interpreter can execute both in parallel or batch them
Kind&lt;CompletableFutureKind.Witness, UserProfile&gt; result =
    profile.foldMap(parallelInterpreter, cfApplicative);
</code></pre>
<p><strong>When To Use:</strong> Parallel data fetching, validation that accumulates all errors, batching independent operations, static analysis of programs before execution.</p>
<p><strong>Related:</strong> <a href="monads/free_applicative.html">Free Applicative Documentation</a>, <a href="monads/free_monad.html">Free Monad</a></p>
<hr />
<h3 id="map-fusion-1"><a class="header" href="#map-fusion-1">Map Fusion</a></h3>
<p><strong>Definition:</strong> An optimisation where multiple consecutive <code>map</code> operations are combined into a single function composition, reducing the number of traversals over a data structure.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Without fusion: three separate traversals
list.map(x -&gt; x * 2)      // Traversal 1
    .map(x -&gt; x + 1)      // Traversal 2
    .map(Object::toString); // Traversal 3

// With Coyoneda: one traversal
Coyoneda.lift(list)
    .map(x -&gt; x * 2)       // Just composes functions
    .map(x -&gt; x + 1)       // Just composes functions
    .map(Object::toString) // Just composes functions
    .lower(listFunctor);   // ONE traversal with composed function
</code></pre>
<p><strong>How It Works:</strong> Coyoneda stores the accumulated function <code>f.andThen(g).andThen(h)</code> instead of applying each map immediately. The composed function is applied once during <code>lower()</code>.</p>
<p><strong>When To Use:</strong> Chains of transformations on expensive-to-traverse structures; automatically enabled when using Coyoneda.</p>
<p><strong>Related:</strong> <a href="glossary.html#coyoneda">Coyoneda</a>, <a href="monads/coyoneda.html">Coyoneda Documentation</a></p>
<hr />
<h2 id="data-types-and-structures"><a class="header" href="#data-types-and-structures">Data Types and Structures</a></h2>
<h3 id="choice"><a class="header" href="#choice">Choice</a></h3>
<p><strong>Definition:</strong> A type representing a choice between two alternatives, similar to <code>Either</code> but used specifically in the context of Selective functors. Can be <code>Left&lt;A&gt;</code> (needs processing) or <code>Right&lt;B&gt;</code> (already processed).</p>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Helper methods in Selective interface
Choice&lt;String, Integer&gt; needsParsing = Selective.left("42");
Choice&lt;String, Integer&gt; alreadyParsed = Selective.right(42);

// In selective operations
Kind&lt;F, Choice&lt;String, Integer&gt;&gt; input = ...;
Kind&lt;F, Function&lt;String, Integer&gt;&gt; parser = ...;
Kind&lt;F, Integer&gt; result = selective.select(input, parser);
// Parser only applied if Choice is Left
</code></pre>
<p><strong>Related:</strong> <a href="functional/selective.html">Selective Documentation</a></p>
<hr />
<h3 id="unit"><a class="header" href="#unit">Unit</a></h3>
<p><strong>Definition:</strong> A type with exactly one value (<code>Unit.INSTANCE</code>), representing the completion of an operation that doesn't produce a meaningful result. The functional equivalent of <code>void</code>, but usable as a type parameter.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// IO action that performs a side effect
Kind&lt;IOKind.Witness, Unit&gt; printAction =
    IO_KIND.widen(IO.fromRunnable(() -&gt; System.out.println("Hello")));

// Optional as MonadError&lt;..., Unit&gt;
MonadError&lt;OptionalKind.Witness, Unit&gt; optionalMonad = OptionalMonad.INSTANCE;
Kind&lt;OptionalKind.Witness, String&gt; empty =
    optionalMonad.raiseError(Unit.INSTANCE);  // Creates Optional.empty()
</code></pre>
<p><strong>When To Use:</strong></p>
<ul>
<li>Effects that don't return a value (logging, printing, etc.)</li>
<li>Error types for contexts where absence is the only error (Optional, Maybe)</li>
</ul>
<p><strong>Related:</strong> <a href="hkts/core-concepts.html">Core Concepts</a></p>
<hr />
<h3 id="const"><a class="header" href="#const">Const</a></h3>
<p><strong>Definition:</strong> A constant functor that wraps a value of type <code>C</code> whilst ignoring a phantom type parameter <code>A</code>. The second type parameter exists purely for type-level information and has no runtime representation.</p>
<p><strong>Structure:</strong> <code>Const&lt;C, A&gt;</code> where <code>C</code> is the concrete value type and <code>A</code> is phantom.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Store a String, phantom type is Integer
Const&lt;String, Integer&gt; stringConst = new Const&lt;&gt;("hello");

String value = stringConst.value(); // "hello"

// Mapping over the phantom type changes the signature but not the value
Const&lt;String, Double&gt; doubleConst = stringConst.mapSecond(i -&gt; i * 2.0);
System.out.println(doubleConst.value()); // Still "hello" (unchanged!)

// Bifunctor allows transforming the actual value
Bifunctor&lt;ConstKind2.Witness&gt; bifunctor = ConstBifunctor.INSTANCE;
Const&lt;Integer, Double&gt; intConst = CONST.narrow2(bifunctor.bimap(
    String::length,
    i -&gt; i * 2.0,
    CONST.widen2(stringConst)
));
System.out.println(intConst.value()); // 5
</code></pre>
<p><strong>When To Use:</strong></p>
<ul>
<li>Implementing van Laarhoven lenses and folds</li>
<li>Accumulating values whilst traversing structures</li>
<li>Teaching phantom types and their practical applications</li>
<li>Building optics that extract rather than modify data</li>
</ul>
<p><strong>Related:</strong> <a href="glossary.html#phantom-type">Phantom Type</a>, <a href="glossary.html#bifunctor">Bifunctor</a>, <a href="monads/const_type.html">Const Type Documentation</a></p>
<hr />
<h2 id="core-effect-types"><a class="header" href="#core-effect-types">Core Effect Types</a></h2>
<h3 id="either"><a class="header" href="#either">Either</a></h3>
<p><strong>Definition:</strong> A sum type representing one of two possible values: <code>Left&lt;L&gt;</code> (typically an error or alternative) or <code>Right&lt;R&gt;</code> (typically the success value). Either is right-biased, meaning operations like <code>map</code> and <code>flatMap</code> work on the <code>Right</code> value.</p>
<p><strong>Structure:</strong> <code>Either&lt;L, R&gt;</code> where <code>L</code> is the left type (often error) and <code>R</code> is the right type (often success).</p>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Creating Either values
Either&lt;String, Integer&gt; success = Either.right(42);
Either&lt;String, Integer&gt; failure = Either.left("Not found");

// Pattern matching with fold
String message = success.fold(
    error -&gt; "Error: " + error,
    value -&gt; "Got: " + value
);  // "Got: 42"

// Chaining operations (right-biased)
Either&lt;String, String&gt; result = success
    .map(n -&gt; n * 2)           // Right(84)
    .map(Object::toString);    // Right("84")

// Error recovery
Either&lt;String, Integer&gt; recovered = failure
    .orElse(Either.right(0));  // Right(0)
</code></pre>
<p><strong>When To Use:</strong></p>
<ul>
<li>Operations that can fail with typed, structured error information</li>
<li>Domain errors that need to be handled explicitly</li>
<li>When you need to preserve error details for later handling</li>
</ul>
<p><strong>Effect Path Equivalent:</strong> Use <a href="glossary.html#effect-path">EitherPath</a> for fluent composition.</p>
<p><strong>Related:</strong> <a href="monads/either_monad.html">Either Documentation</a>, <a href="effect/path_either.html">EitherPath</a></p>
<hr />
<h3 id="maybe"><a class="header" href="#maybe">Maybe</a></h3>
<p><strong>Definition:</strong> A type representing an optional value that may or may not be present. Unlike Java's <code>Optional</code>, <code>Maybe</code> is designed for functional composition and integrates with Higher-Kinded-J's type class hierarchy.</p>
<p><strong>Structure:</strong> <code>Maybe&lt;A&gt;</code> is either <code>Just&lt;A&gt;</code> (contains a value) or <code>Nothing</code> (empty).</p>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Creating Maybe values
Maybe&lt;String&gt; present = Maybe.just("hello");
Maybe&lt;String&gt; absent = Maybe.nothing();

// Safe operations
String upper = present
    .map(String::toUpperCase)
    .orElse("default");  // "HELLO"

// Chaining with flatMap
Maybe&lt;Integer&gt; result = Maybe.just("42")
    .flatMap(s -&gt; {
        try {
            return Maybe.just(Integer.parseInt(s));
        } catch (NumberFormatException e) {
            return Maybe.nothing();
        }
    });  // Just(42)

// Pattern matching
String output = absent.fold(
    () -&gt; "Nothing here",
    value -&gt; "Found: " + value
);  // "Nothing here"
</code></pre>
<p><strong>When To Use:</strong></p>
<ul>
<li>Values that may legitimately be absent (no error, just missing)</li>
<li>Null-safe programming without null checks</li>
<li>When absence is a normal case, not an error</li>
</ul>
<p><strong>Effect Path Equivalent:</strong> Use <a href="glossary.html#effect-path">MaybePath</a> for fluent composition.</p>
<p><strong>Related:</strong> <a href="monads/maybe_monad.html">Maybe Documentation</a>, <a href="effect/path_maybe.html">MaybePath</a></p>
<hr />
<h3 id="try"><a class="header" href="#try">Try</a></h3>
<p><strong>Definition:</strong> A type that captures the result of a computation that may throw an exception. Converts exception-based code into value-based error handling, making exceptions composable.</p>
<p><strong>Structure:</strong> <code>Try&lt;A&gt;</code> is either <code>Success&lt;A&gt;</code> (computation succeeded) or <code>Failure</code> (exception was thrown).</p>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Wrapping exception-throwing code
Try&lt;Integer&gt; parsed = Try.of(() -&gt; Integer.parseInt("42"));     // Success(42)
Try&lt;Integer&gt; failed = Try.of(() -&gt; Integer.parseInt("abc"));    // Failure(NumberFormatException)

// Safe chaining - exceptions don't propagate
Try&lt;String&gt; result = parsed
    .map(n -&gt; n * 2)
    .map(Object::toString);  // Success("84")

// Recovery from failure
Integer value = failed
    .recover(ex -&gt; 0)        // Provide default on any exception
    .get();                  // 0

// Conditional recovery
Try&lt;Integer&gt; recovered = failed.recoverWith(ex -&gt; {
    if (ex instanceof NumberFormatException) {
        return Try.success(0);
    }
    return Try.failure(ex);  // Re-throw other exceptions
});
</code></pre>
<p><strong>When To Use:</strong></p>
<ul>
<li>Wrapping legacy code that throws exceptions</li>
<li>Making exception-based APIs composable</li>
<li>When you want to defer exception handling</li>
</ul>
<p><strong>Effect Path Equivalent:</strong> Use <a href="glossary.html#effect-path">TryPath</a> for fluent composition.</p>
<p><strong>Related:</strong> <a href="monads/try_monad.html">Try Documentation</a>, <a href="effect/path_try.html">TryPath</a></p>
<hr />
<h3 id="io"><a class="header" href="#io">IO</a></h3>
<p><strong>Definition:</strong> A type representing a deferred side-effecting computation. The computation is described but not executed until explicitly run, enabling referential transparency and controlled effect execution.</p>
<p><strong>Structure:</strong> <code>IO&lt;A&gt;</code> wraps a <code>Supplier&lt;A&gt;</code> that produces the side effect when executed.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Describing side effects (nothing executes yet)
IO&lt;String&gt; readLine = IO.delay(() -&gt; scanner.nextLine());
IO&lt;Unit&gt; printHello = IO.fromRunnable(() -&gt; System.out.println("Hello"));

// Composing effects
IO&lt;String&gt; program = printHello
    .flatMap(_ -&gt; readLine)
    .map(String::toUpperCase);

// Nothing has happened yet! Execute when ready:
String result = program.run();  // NOW side effects occur

// Sequencing multiple effects
IO&lt;List&lt;String&gt;&gt; readThreeLines = IO.sequence(List.of(
    readLine, readLine, readLine
));
</code></pre>
<p><strong>When To Use:</strong></p>
<ul>
<li>Deferring side effects for controlled execution</li>
<li>Building pure descriptions of effectful programs</li>
<li>Testing side-effecting code (run different interpreters)</li>
<li>Ensuring effects happen in a specific order</li>
</ul>
<p><strong>Effect Path Equivalent:</strong> Use <a href="glossary.html#effect-path">IOPath</a> for fluent composition.</p>
<p><strong>Related:</strong> <a href="monads/io_monad.html">IO Documentation</a>, <a href="effect/path_io.html">IOPath</a></p>
<hr />
<h3 id="validated"><a class="header" href="#validated">Validated</a></h3>
<p><strong>Definition:</strong> A type for accumulating multiple errors instead of failing fast on the first error. Unlike <code>Either</code>, which short-circuits on the first <code>Left</code>, <code>Validated</code> collects all errors using a <code>Semigroup</code>.</p>
<p><strong>Structure:</strong> <code>Validated&lt;E, A&gt;</code> is either <code>Valid&lt;A&gt;</code> (success) or <code>Invalid&lt;E&gt;</code> (accumulated errors).</p>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Individual validations
Validated&lt;List&lt;String&gt;, String&gt; validName = Validated.valid("Alice");
Validated&lt;List&lt;String&gt;, Integer&gt; invalidAge = Validated.invalid(List.of("Age must be positive"));
Validated&lt;List&lt;String&gt;, String&gt; invalidEmail = Validated.invalid(List.of("Invalid email format"));

// Combine with Applicative - ALL errors accumulated
Semigroup&lt;List&lt;String&gt;&gt; listSemigroup = Semigroups.list();
Applicative&lt;Validated.Witness&lt;List&lt;String&gt;&gt;&gt; app = ValidatedApplicative.instance(listSemigroup);

Validated&lt;List&lt;String&gt;, User&gt; result = app.map3(
    validName,
    invalidAge,
    invalidEmail,
    User::new
);
// Invalid(["Age must be positive", "Invalid email format"])

// Convert from Either for fail-fast then accumulate pattern
Either&lt;String, Integer&gt; eitherResult = Either.left("First error");
Validated&lt;String, Integer&gt; validated = Validated.fromEither(eitherResult);
</code></pre>
<p><strong>When To Use:</strong></p>
<ul>
<li>Form validation where all errors should be shown</li>
<li>Batch processing where you want all failures reported</li>
<li>Configuration validation</li>
<li>Any scenario where fail-fast behaviour loses important information</li>
</ul>
<p><strong>Effect Path Equivalent:</strong> Use <a href="glossary.html#effect-path">ValidationPath</a> for fluent composition.</p>
<p><strong>Related:</strong> <a href="monads/validated_monad.html">Validated Documentation</a>, <a href="effect/path_validation.html">ValidationPath</a></p>
<hr />
<h2 id="effect-path-api"><a class="header" href="#effect-path-api">Effect Path API</a></h2>
<h3 id="effect"><a class="header" href="#effect">Effect</a></h3>
<p><strong>Definition:</strong> A computational context that represents a value alongside some additional behaviour or outcome. Effects model computations that may fail, produce optional results, perform side effects, or require asynchronous execution. Rather than throwing exceptions or returning null, effects make these behaviours explicit in the type system.</p>
<p><strong>Common Effect Types in Higher-Kinded-J:</strong></p>
<ul>
<li><strong>Maybe</strong> - Computation that may produce no result</li>
<li><strong>Either</strong> - Computation that may fail with typed error information</li>
<li><strong>Try</strong> - Computation that may throw an exception</li>
<li><strong>IO</strong> - Computation that performs side effects</li>
<li><strong>Validated</strong> - Computation that accumulates multiple errors</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Without effects: hidden failure modes
User getUser(String id) {
    // Might return null? Throw exception? Which exceptions?
}

// With effects: explicit about what can happen
Either&lt;UserError, User&gt; getUser(String id) {
    // Returns Right(user) on success, Left(error) on failure
}

Maybe&lt;User&gt; findUser(String id) {
    // Returns Just(user) if found, Nothing if not found
}

IO&lt;User&gt; loadUser(String id) {
    // Describes a side effect that will load the user when run
}
</code></pre>
<p><strong>Why Effects Matter:</strong></p>
<ul>
<li>Make failure modes visible in type signatures</li>
<li>Enable composition of operations that may fail</li>
<li>Replace scattered try-catch blocks with unified error handling</li>
<li>Allow reasoning about code behaviour from types alone</li>
</ul>
<p><strong>Related:</strong> <a href="glossary.html#effect-path">Effect Path</a>, <a href="glossary.html#railway-oriented-programming">Railway-Oriented Programming</a></p>
<hr />
<h3 id="railway-oriented-programming"><a class="header" href="#railway-oriented-programming">Railway-Oriented Programming</a></h3>
<p><strong>Definition:</strong> A programming model where computations flow along two parallel tracks: a success track and a failure track. Operations automatically route values to the appropriate track, and failures propagate without manual checking at each step.</p>
<p><strong>The Railway Metaphor:</strong></p>
<pre><code>SUCCESS TRACK  ═══════╦═══════╦═══════╦═══════► Result
                      ║       ║       ║
                   step 1  step 2  step 3
                      ║       ║       ║
FAILURE TRACK  ───────╨───────╨───────╨───────► Error
</code></pre>
<p>When a step succeeds, the value continues on the success track. When a step fails, execution switches to the failure track and subsequent steps are bypassed.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Traditional approach: manual error checking at each step
User user = findUser(id);
if (user == null) return error("User not found");
Account account = getAccount(user);
if (account == null) return error("Account not found");
if (!account.isActive()) return error("Account inactive");
return success(account.getBalance());

// Railway-oriented: automatic track switching
EitherPath&lt;Error, BigDecimal&gt; balance =
    Path.of(findUser(id))
        .via(user -&gt; getAccount(user))
        .via(account -&gt; validateActive(account))
        .map(account -&gt; account.getBalance());
// Failures propagate automatically; no manual checks needed
</code></pre>
<p><strong>Key Operations:</strong></p>
<ul>
<li><code>map</code> - Transform value on success track (stays on same track)</li>
<li><code>via</code> (flatMap) - Chain to next operation that may switch tracks</li>
<li><code>recover</code> - Switch from failure track back to success track</li>
</ul>
<p><strong>Benefits:</strong></p>
<ul>
<li>Eliminates nested if-else and try-catch pyramids</li>
<li>Business logic reads top-to-bottom</li>
<li>Error handling is consistent and composable</li>
<li>Type system ensures all failure cases are addressed</li>
</ul>
<p><strong>Related:</strong> <a href="glossary.html#effect-path">Effect Path</a>, <a href="glossary.html#via">via</a>, <a href="glossary.html#recover">recover</a></p>
<hr />
<h3 id="effect-path"><a class="header" href="#effect-path">Effect Path</a></h3>
<p><strong>Definition:</strong> The primary API in Higher-Kinded-J for working with effects. Effect Paths wrap core effect types (Either, Maybe, Try, IO, Validated) and provide a fluent, railway-oriented interface for composition. Each Path type offers consistent operations (<code>map</code>, <code>via</code>, <code>recover</code>, <code>run</code>) regardless of the underlying effect.</p>
<p><strong>Available Path Types:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Path Type</th><th>Underlying Effect</th><th>Purpose</th></tr></thead><tbody>
<tr><td><code>EitherPath&lt;E, A&gt;</code></td><td><code>Either&lt;E, A&gt;</code></td><td>Typed error handling</td></tr>
<tr><td><code>MaybePath&lt;A&gt;</code></td><td><code>Maybe&lt;A&gt;</code></td><td>Optional values</td></tr>
<tr><td><code>TryPath&lt;A&gt;</code></td><td><code>Try&lt;A&gt;</code></td><td>Exception handling</td></tr>
<tr><td><code>IOPath&lt;A&gt;</code></td><td><code>IO&lt;A&gt;</code></td><td>Deferred side effects</td></tr>
<tr><td><code>ValidationPath&lt;E, A&gt;</code></td><td><code>Validated&lt;E, A&gt;</code></td><td>Error accumulation</td></tr>
<tr><td><code>TrampolinePath&lt;A&gt;</code></td><td><code>Trampoline&lt;A&gt;</code></td><td>Stack-safe recursion</td></tr>
<tr><td><code>CompletableFuturePath&lt;A&gt;</code></td><td><code>CompletableFuture&lt;A&gt;</code></td><td>Async operations</td></tr>
</tbody></table>
</div>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Create paths using the Path factory
EitherPath&lt;Error, User&gt; userPath = Path.either(findUser(id));
MaybePath&lt;Config&gt; configPath = Path.maybe(loadConfig());
TryPath&lt;Data&gt; dataPath = Path.tryOf(() -&gt; parseJson(input));
IOPath&lt;String&gt; ioPath = Path.io(() -&gt; readFile(path));

// All paths share the same fluent API
EitherPath&lt;Error, String&gt; result = userPath
    .map(User::name)                    // Transform success value
    .via(name -&gt; validateName(name))    // Chain dependent operation
    .recover(err -&gt; "Anonymous");       // Handle errors

// Execute and get result
String name = result.run().orElse("Unknown");
</code></pre>
<p><strong>Related:</strong> <a href="glossary.html#path">Path</a>, <a href="glossary.html#via">via</a>, <a href="glossary.html#recover">recover</a>, <a href="effect/ch_intro.html">Effect Path Documentation</a></p>
<hr />
<h3 id="path"><a class="header" href="#path">Path</a></h3>
<p><strong>Definition:</strong> The unified factory class for creating Effect Paths. Provides static methods to wrap values and computations in the appropriate Path type, serving as the main entry point to the Effect Path API.</p>
<p><strong>Factory Methods:</strong></p>
<pre><code class="language-java">// Maybe paths
Path.maybe(nullableValue)           // Wrap nullable, null becomes Nothing
Path.just(nonNullValue)             // Wrap known-present value
Path.nothing()                      // Empty MaybePath

// Either paths
Path.either(eitherValue)            // Wrap existing Either
Path.right(value)                   // Success EitherPath
Path.left(error)                    // Failure EitherPath
Path.of(nullableValue)              // Wrap nullable as EitherPath

// Try paths
Path.tryOf(() -&gt; riskyOperation())  // Wrap exception-throwing code
Path.success(value)                 // Successful TryPath
Path.failure(exception)             // Failed TryPath

// IO paths
Path.io(() -&gt; sideEffect())         // Wrap side-effecting code
Path.ioOf(value)                    // Pure value in IO context

// Validation paths
Path.valid(value)                   // Valid result
Path.invalid(error)                 // Invalid with error
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Building a complete workflow using Path factory
public EitherPath&lt;OrderError, Receipt&gt; processOrder(OrderRequest request) {
    return Path.maybe(customerRepository.find(request.customerId()))
        .toEitherPath(() -&gt; new OrderError.CustomerNotFound())
        .via(customer -&gt; Path.either(validateOrder(request, customer)))
        .via(validated -&gt; Path.tryOf(() -&gt; paymentService.charge(validated))
            .toEitherPath(OrderError.PaymentFailed::new))
        .map(payment -&gt; createReceipt(request, payment));
}
</code></pre>
<p><strong>Related:</strong> <a href="glossary.html#effect-path">Effect Path</a>, <a href="glossary.html#via">via</a>, <a href="glossary.html#recover">recover</a>, <a href="effect/ch_intro.html">Effect Path Documentation</a></p>
<hr />
<h3 id="via"><a class="header" href="#via">via</a></h3>
<p><strong>Definition:</strong> The chaining operation on Effect Paths, equivalent to <code>flatMap</code> on monads. Applies a function that returns a new Path, allowing dependent operations to be sequenced. If the current Path is on the failure track, <code>via</code> is bypassed and the failure propagates.</p>
<p><strong>Signature:</strong> <code>Path&lt;E, A&gt;.via(Function&lt;A, Path&lt;E, B&gt;&gt; f) → Path&lt;E, B&gt;</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Each step depends on the previous result
EitherPath&lt;Error, Order&gt; orderPath =
    Path.of(userId)
        .via(id -&gt; findUser(id))           // Returns EitherPath&lt;Error, User&gt;
        .via(user -&gt; getCart(user))        // Returns EitherPath&lt;Error, Cart&gt;
        .via(cart -&gt; validateCart(cart))   // Returns EitherPath&lt;Error, ValidatedCart&gt;
        .via(valid -&gt; createOrder(valid)); // Returns EitherPath&lt;Error, Order&gt;

// Compare to map (which doesn't chain Paths):
EitherPath&lt;Error, String&gt; mapped = userPath.map(user -&gt; user.name());
// map: A -&gt; B (simple transformation)
// via: A -&gt; Path&lt;E, B&gt; (operation that may fail)
</code></pre>
<p><strong>When To Use:</strong></p>
<ul>
<li>Chaining operations where each step may fail</li>
<li>Sequencing dependent computations</li>
<li>Building pipelines of effectful operations</li>
</ul>
<p><strong>Contrast with map:</strong></p>
<ul>
<li><code>map(A -&gt; B)</code> - Transform the value, stay on same track</li>
<li><code>via(A -&gt; Path&lt;E, B&gt;)</code> - Chain to operation that may switch tracks</li>
</ul>
<p><strong>Related:</strong> <a href="glossary.html#effect-path">Effect Path</a>, <a href="glossary.html#railway-oriented-programming">Railway-Oriented Programming</a>, <a href="glossary.html#recover">recover</a></p>
<hr />
<h3 id="recover"><a class="header" href="#recover">recover</a></h3>
<p><strong>Definition:</strong> The error recovery operation on Effect Paths, equivalent to <code>handleErrorWith</code> on MonadError. Allows switching from the failure track back to the success track by providing an alternative value or computation.</p>
<p><strong>Signature:</strong> <code>Path&lt;E, A&gt;.recover(Function&lt;E, A&gt; handler) → Path&lt;E, A&gt;</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Simple recovery with default value
EitherPath&lt;Error, Config&gt; config = loadConfig()
    .recover(error -&gt; Config.defaults());

// Recovery that inspects the error
EitherPath&lt;ApiError, User&gt; user = fetchUser(id)
    .recover(error -&gt; switch (error) {
        case NotFound _ -&gt; User.guest();
        case RateLimited _ -&gt; User.cached(id);
        default -&gt; throw new RuntimeException(error);  // Re-throw unrecoverable
    });

// Recovery with a new Path (recoverWith)
EitherPath&lt;Error, Data&gt; data = primarySource()
    .recoverWith(error -&gt; fallbackSource());  // Try alternative on failure

// Partial recovery - only handle specific errors
EitherPath&lt;Error, Value&gt; result = operation()
    .recover(error -&gt; {
        if (error instanceof Retryable) {
            return retryOperation();
        }
        throw error;  // Propagate non-retryable errors
    });
</code></pre>
<p><strong>When To Use:</strong></p>
<ul>
<li>Providing default values when operations fail</li>
<li>Implementing fallback strategies</li>
<li>Converting errors to success values</li>
<li>Selective error recovery based on error type</li>
</ul>
<p><strong>Related:</strong> <a href="glossary.html#effect-path">Effect Path</a>, <a href="glossary.html#railway-oriented-programming">Railway-Oriented Programming</a>, <a href="glossary.html#via">via</a></p>
<hr />
<h3 id="effect-optics-bridge"><a class="header" href="#effect-optics-bridge">Effect-Optics Bridge</a></h3>
<p><strong>Definition:</strong> The integration layer that connects Effect Paths with the Focus DSL, allowing seamless composition of effectful computations and immutable data navigation. The bridge enables focusing into data structures retrieved from effects and lifting optic operations into effectful contexts.</p>
<p><strong>How It Works:</strong></p>
<pre><code>EFFECTS DOMAIN                    OPTICS DOMAIN
══════════════                    ═════════════
EitherPath&lt;E, User&gt;  ──┐    ┌──  FocusPath&lt;User, Address&gt;
TryPath&lt;Config&gt;      ──┤    ├──  Lens&lt;Config, Settings&gt;
IOPath&lt;Data&gt;         ──┘    └──  Traversal&lt;Data, Item&gt;
                        │  │
                        ▼  ▼
                   .focus(optic)
                        │
                        ▼
              UNIFIED COMPOSITION
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Fetch user (effect) then navigate to nested data (optics)
EitherPath&lt;Error, String&gt; city = userService.findById(userId)  // Effect: fetch
    .focus(UserFocus.address())                                 // Optics: navigate
    .focus(AddressFocus.city())                                 // Optics: deeper
    .map(String::toUpperCase);                                  // Transform

// Modify nested data within an effectful context
EitherPath&lt;Error, User&gt; updated = userService.findById(userId)
    .focusAndModify(
        UserFocus.address().andThen(AddressFocus.postcode()),
        postcode -&gt; postcode.toUpperCase()
    );

// Combine multiple effect sources with optic navigation
EitherPath&lt;Error, Report&gt; report =
    Path.of(loadCompany(id))
        .focus(CompanyFocus.departments())     // Traverse to departments
        .via(dept -&gt; loadMetrics(dept.id()))   // Effect for each
        .map(metrics -&gt; generateReport(metrics));
</code></pre>
<p><strong>Benefits:</strong></p>
<ul>
<li>No boilerplate for null checks during navigation</li>
<li>Optic failures (missing optional values) integrate with effect failures</li>
<li>Single vocabulary (<code>map</code>, <code>via</code>, <code>focus</code>) for both domains</li>
<li>Type-safe composition across effect and structure boundaries</li>
</ul>
<p><strong>Related:</strong> <a href="glossary.html#effect-path">Effect Path</a>, <a href="glossary.html#focus-dsl">Focus DSL</a>, <a href="glossary.html#focuspath">FocusPath</a></p>
<hr />
<h2 id="optics-terminology"><a class="header" href="#optics-terminology">Optics Terminology</a></h2>
<h3 id="affine"><a class="header" href="#affine">Affine</a></h3>
<p><strong>Definition:</strong> An optic that focuses on zero or one values within a structure. Affine sits between Lens (exactly one) and Prism (zero or one for sum types) in the optic hierarchy. It combines the "might not be there" aspect of Prism with the "focus on part of a product" aspect of Lens.</p>
<p><strong>Core Operations:</strong></p>
<ul>
<li><code>preview(S source)</code> - Try to extract the value (returns Optional)</li>
<li><code>set(A value, S source)</code> - Set the value if the focus exists</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Affine for the first element of a list (might be empty)
Affine&lt;List&lt;String&gt;, String&gt; firstElement = Affine.affine(
    list -&gt; list.isEmpty() ? Optional.empty() : Optional.of(list.get(0)),
    (newFirst, list) -&gt; list.isEmpty() ? list :
        Stream.concat(Stream.of(newFirst), list.stream().skip(1)).toList()
);

List&lt;String&gt; items = List.of("a", "b", "c");
Optional&lt;String&gt; first = firstElement.preview(items);  // Optional["a"]
List&lt;String&gt; updated = firstElement.set("X", items);   // ["X", "b", "c"]

List&lt;String&gt; empty = List.of();
Optional&lt;String&gt; noFirst = firstElement.preview(empty);  // Optional.empty()
List&lt;String&gt; stillEmpty = firstElement.set("X", empty);  // [] (unchanged)
</code></pre>
<p><strong>When To Use:</strong></p>
<ul>
<li>Accessing elements that may not exist (first element, element at index)</li>
<li>Optional fields in product types</li>
<li>Composing Lens with Prism (result is Affine)</li>
</ul>
<p><strong>Hierarchy Position:</strong> <code>Iso → Lens → Affine → Traversal</code>
<code>Iso → Prism → Affine → Traversal</code></p>
<p><strong>Related:</strong> <a href="glossary.html#lens">Lens</a>, <a href="glossary.html#prism">Prism</a>, <a href="optics/affine.html">Affine Documentation</a></p>
<hr />
<h3 id="at"><a class="header" href="#at">At</a></h3>
<p><strong>Definition:</strong> A type class for structures that support indexed access with insertion and deletion semantics. Provides a <code>Lens&lt;S, Optional&lt;A&gt;&gt;</code> where setting to <code>Optional.empty()</code> deletes the entry and setting to <code>Optional.of(value)</code> inserts or updates it.</p>
<p><strong>Core Operations:</strong></p>
<ul>
<li><code>at(I index)</code> - Returns <code>Lens&lt;S, Optional&lt;A&gt;&gt;</code> for the index</li>
<li><code>get(I index, S source)</code> - Read value at index (returns Optional)</li>
<li><code>insertOrUpdate(I index, A value, S source)</code> - Insert or update entry</li>
<li><code>remove(I index, S source)</code> - Delete entry at index</li>
<li><code>modify(I index, Function&lt;A,A&gt; f, S source)</code> - Update value if present</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">At&lt;Map&lt;String, Integer&gt;, String, Integer&gt; mapAt = AtInstances.mapAt();

Map&lt;String, Integer&gt; scores = new HashMap&lt;&gt;(Map.of("alice", 100));

// Insert new entry
Map&lt;String, Integer&gt; withBob = mapAt.insertOrUpdate("bob", 85, scores);
// Result: {alice=100, bob=85}

// Remove entry
Map&lt;String, Integer&gt; noAlice = mapAt.remove("alice", withBob);
// Result: {bob=85}

// Compose with Lens for deep access
Lens&lt;UserProfile, Optional&lt;String&gt;&gt; themeLens =
    settingsLens.andThen(mapAt.at("theme"));
</code></pre>
<p><strong>When To Use:</strong> CRUD operations on maps or lists where you need to insert new entries or delete existing ones whilst maintaining immutability and optics composability.</p>
<p><strong>Related:</strong> <a href="optics/indexed_access.html">Indexed Access: At and Ixed Type Classes</a></p>
<hr />
<h3 id="iso-isomorphism"><a class="header" href="#iso-isomorphism">Iso (Isomorphism)</a></h3>
<p><strong>Definition:</strong> An optic representing a lossless, bidirectional conversion between two types. If you can convert <code>A</code> to <code>B</code> and back to <code>A</code> without losing information, you have an isomorphism.</p>
<p><strong>Core Operations:</strong></p>
<ul>
<li><code>get(S source)</code> - Convert from S to A</li>
<li><code>reverseGet(A value)</code> - Convert from A to S</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// String and List&lt;Character&gt; are isomorphic
Iso&lt;String, List&lt;Character&gt;&gt; stringToChars = Iso.iso(
    s -&gt; s.chars().mapToObj(c -&gt; (char) c).collect(Collectors.toList()),
    chars -&gt; chars.stream().map(String::valueOf).collect(Collectors.joining())
);

List&lt;Character&gt; chars = stringToChars.get("Hello");  // ['H', 'e', 'l', 'l', 'o']
String back = stringToChars.reverseGet(chars);       // "Hello"
</code></pre>
<p><strong>When To Use:</strong> Converting between equivalent representations (e.g., Celsius/Fahrenheit, String/ByteArray, domain models and DTOs with no information loss).</p>
<p><strong>Related:</strong> <a href="optics/iso.html">Iso Documentation</a></p>
<hr />
<h3 id="lens"><a class="header" href="#lens">Lens</a></h3>
<p><strong>Definition:</strong> An optic for working with product types (records with fields). Provides a composable way to get and set fields in immutable data structures.</p>
<p><strong>Core Operations:</strong></p>
<ul>
<li><code>get(S source)</code> - Extract a field value</li>
<li><code>set(A newValue, S source)</code> - Create a new copy with updated field</li>
<li><code>modify(Function&lt;A,A&gt; f, S source)</code> - Update field using a function</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">@GenerateLenses
public record Address(String street, String city) {}

@GenerateLenses
public record Company(String name, Address address) {}

@GenerateLenses
public record Employee(String name, Company company) {}

// Compose lenses for deep updates
Lens&lt;Employee, String&gt; employeeToStreet =
    EmployeeLenses.company()
        .andThen(CompanyLenses.address())
        .andThen(AddressLenses.street());

// Update nested field in one line
Employee updated = employeeToStreet.set("456 New St", originalEmployee);
</code></pre>
<p><strong>Related:</strong> <a href="optics/lenses.html">Lenses Documentation</a></p>
<hr />
<h3 id="prism"><a class="header" href="#prism">Prism</a></h3>
<p><strong>Definition:</strong> An optic for working with sum types (sealed interfaces, Optional, Either). Provides safe access to specific variants within a discriminated union.</p>
<p><strong>Core Operations:</strong></p>
<ul>
<li><code>preview(S source)</code> - Try to extract a variant (returns Optional)</li>
<li><code>review(A value)</code> - Construct the sum type from a variant</li>
<li><code>modify(Function&lt;A,A&gt; f, S source)</code> - Update if variant matches</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">@GeneratePrisms
public sealed interface PaymentMethod {
    record CreditCard(String number) implements PaymentMethod {}
    record BankTransfer(String iban) implements PaymentMethod {}
}

Prism&lt;PaymentMethod, String&gt; creditCardPrism =
    PaymentMethodPrisms.creditCard().andThen(CreditCardLenses.number());

// Safe extraction
Optional&lt;String&gt; cardNumber = creditCardPrism.preview(payment);

// Conditional update
PaymentMethod masked = creditCardPrism.modify(num -&gt; "****" + num.substring(12), payment);
</code></pre>
<p><strong>Related:</strong> <a href="optics/prisms.html">Prisms Documentation</a></p>
<hr />
<h3 id="traversal"><a class="header" href="#traversal">Traversal</a></h3>
<p><strong>Definition:</strong> An optic for working with multiple values within a structure (lists, sets, trees). Allows bulk operations on all elements.</p>
<p><strong>Core Operations:</strong></p>
<ul>
<li><code>modifyF(Applicative&lt;F&gt; app, Function&lt;A, Kind&lt;F,A&gt;&gt; f, S source)</code> - Effectful modification of all elements</li>
<li><code>toList(S source)</code> - Extract all focused values as a list</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">@GenerateLenses
public record Order(String id, List&lt;LineItem&gt; items) {}

Traversal&lt;Order, LineItem&gt; orderItems =
    OrderLenses.items().asTraversal();

// Apply bulk update
Order discounted = orderItems.modify(
    item -&gt; item.withPrice(item.price() * 0.9),
    order
);
</code></pre>
<p><strong>Related:</strong> <a href="optics/traversals.html">Traversals Documentation</a></p>
<hr />
<h3 id="fold"><a class="header" href="#fold">Fold</a></h3>
<p><strong>Definition:</strong> A read-only optic that extracts zero or more values from a structure. Folds are like Traversals but without the ability to modify. They generalise the concept of "folding" or "reducing" over a structure.</p>
<p><strong>Core Operations:</strong></p>
<ul>
<li><code>foldMap(Monoid&lt;M&gt; monoid, Function&lt;A, M&gt; f, S source)</code> - Map and combine all values</li>
<li><code>toList(S source)</code> - Extract all focused values as a list</li>
<li><code>headOption(S source)</code> - Get the first value if any</li>
<li><code>exists(Predicate&lt;A&gt; p, S source)</code> - Check if any value satisfies predicate</li>
<li><code>all(Predicate&lt;A&gt; p, S source)</code> - Check if all values satisfy predicate</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Fold over all players in a league
Fold&lt;League, Player&gt; allPlayers = LeagueFolds.teams()
    .andThen(TeamFolds.players());

// Extract all players
List&lt;Player&gt; players = allPlayers.toList(league);

// Sum all scores using a Monoid
Integer totalScore = allPlayers.foldMap(
    Monoids.integerAddition(),
    Player::score,
    league
);

// Check conditions across all values
boolean anyInactive = allPlayers.exists(p -&gt; !p.isActive(), league);
boolean allQualified = allPlayers.all(p -&gt; p.score() &gt;= 100, league);
</code></pre>
<p><strong>When To Use:</strong></p>
<ul>
<li>Extracting multiple values without modification</li>
<li>Aggregating data from nested structures</li>
<li>Querying collections within complex types</li>
<li>When you need read-only access to multiple elements</li>
</ul>
<p><strong>Related:</strong> <a href="glossary.html#traversal">Traversal</a>, <a href="glossary.html#lens">Getter (Fold of one)</a></p>
<hr />
<h3 id="setter"><a class="header" href="#setter">Setter</a></h3>
<p><strong>Definition:</strong> A write-only optic that can modify zero or more values within a structure. Setters are the dual of Folds: where Folds can only read, Setters can only write. They cannot extract values, only transform them.</p>
<p><strong>Core Operations:</strong></p>
<ul>
<li><code>modify(Function&lt;A, A&gt; f, S source)</code> - Apply function to all focused values</li>
<li><code>set(A value, S source)</code> - Set all focused values to same value</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Setter for all prices in an order
Setter&lt;Order, BigDecimal&gt; allPrices = OrderSetters.items()
    .andThen(LineItemSetters.price());

// Apply discount to all prices
Order discounted = allPrices.modify(
    price -&gt; price.multiply(new BigDecimal("0.9")),
    order
);

// Set all prices to zero (for testing)
Order zeroed = allPrices.set(BigDecimal.ZERO, order);

// Compose with other optics
Setter&lt;Company, String&gt; allEmployeeEmails =
    CompanySetters.departments()
        .andThen(DepartmentSetters.employees())
        .andThen(EmployeeSetters.email());

Company normalised = allEmployeeEmails.modify(String::toLowerCase, company);
</code></pre>
<p><strong>When To Use:</strong></p>
<ul>
<li>Bulk modifications without needing to read values</li>
<li>Applying transformations across nested structures</li>
<li>When modification logic doesn't depend on current values</li>
<li>Composing write-only operations</li>
</ul>
<p><strong>Related:</strong> <a href="glossary.html#traversal">Traversal</a>, <a href="glossary.html#fold">Fold</a></p>
<hr />
<h3 id="focus-dsl"><a class="header" href="#focus-dsl">Focus DSL</a></h3>
<p><strong>Definition:</strong> A domain-specific language for fluent, type-safe navigation and manipulation of immutable data structures. The Focus DSL provides a composable way to build paths through nested records without manual lens composition.</p>
<p><strong>Core Concept:</strong> Instead of composing optics manually, the Focus DSL lets you chain <code>.focus()</code> calls to navigate through data structures, with the optic types inferred automatically.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Without Focus DSL: manual lens composition
Lens&lt;Employee, String&gt; streetLens =
    EmployeeLenses.company()
        .andThen(CompanyLenses.address())
        .andThen(AddressLenses.street());
String street = streetLens.get(employee);

// With Focus DSL: fluent navigation
String street = Focus.on(employee)
    .focus(EmployeeFocus.company())
    .focus(CompanyFocus.address())
    .focus(AddressFocus.street())
    .get();

// Modification is equally fluent
Employee updated = Focus.on(employee)
    .focus(EmployeeFocus.company())
    .focus(CompanyFocus.address())
    .focus(AddressFocus.city())
    .modify(String::toUpperCase);

// Mix with Effect Paths for effectful navigation
EitherPath&lt;Error, String&gt; city = userService.findById(id)
    .focus(UserFocus.address())
    .focus(AddressFocus.city());
</code></pre>
<p><strong>Key Features:</strong></p>
<ul>
<li>Type-safe: Compiler catches invalid paths</li>
<li>Composable: Chain any optic types together</li>
<li>Generated: <code>@GenerateLenses</code> creates Focus helpers automatically</li>
<li>Effect integration: Seamlessly works with Effect Paths</li>
</ul>
<p><strong>Related:</strong> <a href="glossary.html#focuspath">FocusPath</a>, <a href="glossary.html#lens">Lens</a>, <a href="glossary.html#effect-optics-bridge">Effect-Optics Bridge</a>, <a href="optics/focus_dsl.html">Focus DSL Documentation</a></p>
<hr />
<h3 id="focuspath"><a class="header" href="#focuspath">FocusPath</a></h3>
<p><strong>Definition:</strong> A generated helper class that provides pre-composed optic paths for navigating into record types. The annotation processor creates FocusPath classes for each annotated record, offering a fluent API for accessing fields and nested structures.</p>
<p><strong>Generation:</strong> Add <code>@GenerateLenses</code> to your record to generate the corresponding Focus class.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-java">@GenerateLenses
public record User(String name, Address address, List&lt;Order&gt; orders) {}

@GenerateLenses
public record Address(String street, String city, String postcode) {}

// Generated: UserFocus class with methods:
// - UserFocus.name()     → Lens&lt;User, String&gt;
// - UserFocus.address()  → Lens&lt;User, Address&gt;
// - UserFocus.orders()   → Lens&lt;User, List&lt;Order&gt;&gt;

// Use in Focus DSL
String city = Focus.on(user)
    .focus(UserFocus.address())
    .focus(AddressFocus.city())
    .get();

// Compose for reusable paths
Lens&lt;User, String&gt; userCity = UserFocus.address()
    .andThen(AddressFocus.city());

// Use with Effect Paths
EitherPath&lt;Error, String&gt; cityPath = loadUser(id)
    .focus(UserFocus.address())
    .focus(AddressFocus.city());
</code></pre>
<p><strong>Naming Convention:</strong></p>
<ul>
<li>Record <code>Foo</code> generates <code>FooFocus</code> class</li>
<li>Each field <code>bar</code> generates static method <code>FooFocus.bar()</code></li>
</ul>
<p><strong>Related:</strong> <a href="glossary.html#focus-dsl">Focus DSL</a>, <a href="glossary.html#lens">Lens</a>, <a href="optics/code_generation.html">Code Generation</a></p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="contributing-to-java-hkt-simulation"><a class="header" href="#contributing-to-java-hkt-simulation">Contributing to Java HKT Simulation</a></h1>
<p>First off, thank you for considering contributing! This project is a simulation to explore Higher-Kinded Types in Java, and contributions are welcome.</p>
<p>This document provides guidelines for contributing to this project.</p>
<h2 id="code-of-conduct"><a class="header" href="#code-of-conduct">Code of Conduct</a></h2>
<p>This project and everyone participating in it is governed by the <a href="CODE_OF_CONDUCT.html">Code of Conduct</a>. By participating, you are expected to uphold this code. Please report unacceptable behavior to simulation.hkt@gmail.com.</p>
<h2 id="how-can-i-contribute"><a class="header" href="#how-can-i-contribute">How Can I Contribute?</a></h2>
<h3 id="reporting-bugs"><a class="header" href="#reporting-bugs">Reporting Bugs</a></h3>
<ul>
<li>Ensure the bug was not already reported by searching on GitHub under <a href="https://github.com/higher-kinded-j/higher-kinded-j/issues">Issues</a>.</li>
<li>If you're unable to find an open issue addressing the problem, <a href="https://github.com/higher-kinded-j/higher-kinded-j/issues/new">open a new one</a>. Be sure to include a <strong>title and clear description</strong>, as much relevant information as possible, and a <strong>code sample or an executable test case</strong> demonstrating the expected behavior that is not occurring.</li>
<li>Use the "Bug Report" issue template if available.</li>
</ul>
<h3 id="suggesting-enhancements"><a class="header" href="#suggesting-enhancements">Suggesting Enhancements</a></h3>
<ul>
<li>Open a new issue to discuss your enhancement suggestion. Please provide details about the motivation and potential implementation.</li>
<li>Use the "Feature Request" issue template if available.</li>
</ul>
<h3 id="your-first-code-contribution"><a class="header" href="#your-first-code-contribution">Your First Code Contribution</a></h3>
<p>Unsure where to begin contributing? You can start by looking through <code>good first issue</code> or <code>help wanted</code> issues (you can add these labels yourself to issues you think fit).</p>
<h3 id="pull-requests"><a class="header" href="#pull-requests">Pull Requests</a></h3>
<ol>
<li><strong>Fork the repository</strong> on GitHub.</li>
<li><strong>Clone your fork</strong> locally: <code>git clone git@github.com:higher-kinded-j/higher-kinded-j.git</code></li>
<li><strong>Create a new branch</strong> for your changes: <code>git checkout -b name-of-your-feature-or-fix</code></li>
<li><strong>Make your changes.</strong> Ensure you adhere to standard Java coding conventions.</li>
<li><strong>Add tests</strong> for your changes. This is important!</li>
<li><strong>Run the tests:</strong> Make sure the full test suite passes using <code>./gradlew test</code>.</li>
<li><strong>Build the project:</strong> Ensure the project builds without errors using <code>./gradlew build</code>.</li>
<li><strong>Commit your changes:</strong> Use clear and descriptive commit messages. <code>git commit -am 'Add some feature'</code></li>
<li><strong>Push to your fork:</strong> <code>git push origin name-of-your-feature-or-fix</code></li>
<li><strong>Open a Pull Request</strong> against the <code>main</code> branch of the original repository.</li>
<li><strong>Describe your changes</strong> in the Pull Request description. Link to any relevant issues (e.g., "Closes #123").</li>
<li>Ensure the <strong>GitHub Actions CI checks pass</strong>.</li>
</ol>
<h2 id="development-setup"><a class="header" href="#development-setup">Development Setup</a></h2>
<ul>
<li>You need a Java Development Kit (JDK), version <strong>24</strong> or later.</li>
<li>This project uses Gradle. You can use the included Gradle Wrapper (<code>gradlew</code>) to build and test.
<ul>
<li>Build the project: <code>./gradlew build</code></li>
<li>Run tests: <code>./gradlew test</code></li>
<li>Generate JaCoCo coverage reports: <code>./gradlew test jacocoTestReport</code> (HTML report at <code>build/reports/jacoco/test/html/index.html</code>)</li>
</ul>
</li>
</ul>
<h2 id="coding-style"><a class="header" href="#coding-style">Coding Style</a></h2>
<p>Please follow the <a href="https://google.github.io/styleguide/javaguide.html"><strong>Google Java Style Guide</strong></a>. Keep code simple, readable, and well-tested. Consistent formatting is encouraged.</p>
<p>Thank you for contributing!</p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="contributor-covenant-code-of-conduct"><a class="header" href="#contributor-covenant-code-of-conduct">Contributor Covenant Code of Conduct</a></h1>
<h2 id="our-pledge"><a class="header" href="#our-pledge">Our Pledge</a></h2>
<p>We as members, contributors, and leaders pledge to make participation in our
community a harassment-free experience for everyone, regardless of age, body
size, visible or invisible disability, ethnicity, sex characteristics, gender
identity and expression, level of experience, education, socio-economic status,
nationality, personal appearance, race, religion, or sexual identity
and orientation.</p>
<p>We pledge to act and interact in ways that contribute to an open, welcoming,
diverse, inclusive, and healthy community.</p>
<h2 id="our-standards"><a class="header" href="#our-standards">Our Standards</a></h2>
<p>Examples of behavior that contributes to a positive environment for our
community include:</p>
<ul>
<li>Demonstrating empathy and kindness toward other people</li>
<li>Being respectful of differing opinions, viewpoints, and experiences</li>
<li>Giving and gracefully accepting constructive feedback</li>
<li>Accepting responsibility and apologizing to those affected by our mistakes,
and learning from the experience</li>
<li>Focusing on what is best not just for us as individuals, but for the
overall community</li>
</ul>
<p>Examples of unacceptable behavior include:</p>
<ul>
<li>The use of sexualized language or imagery, and sexual attention or
advances of any kind</li>
<li>Trolling, insulting or derogatory comments, and personal or political attacks</li>
<li>Public or private harassment</li>
<li>Publishing others' private information, such as a physical or email
address, without their explicit permission</li>
<li>Other conduct which could reasonably be considered inappropriate in a
professional setting</li>
</ul>
<h2 id="enforcement-responsibilities"><a class="header" href="#enforcement-responsibilities">Enforcement Responsibilities</a></h2>
<p>Community leaders are responsible for clarifying and enforcing our standards of
acceptable behavior and will take appropriate and fair corrective action in
response to any behavior that they deem inappropriate, threatening, offensive,
or harmful.</p>
<p>Community leaders have the right and responsibility to remove, edit, or reject
comments, commits, code, wiki edits, issues, and other contributions that are
not aligned to this Code of Conduct, and will communicate reasons for moderation
decisions when appropriate.</p>
<h2 id="scope"><a class="header" href="#scope">Scope</a></h2>
<p>This Code of Conduct applies within all community spaces, and also applies when
an individual is officially representing the community in public spaces.
Examples of representing our community include using an official e-mail address,
posting via an official social media account, or acting as an appointed
representative at an online or offline event.</p>
<h2 id="enforcement"><a class="header" href="#enforcement">Enforcement</a></h2>
<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported to the community leaders responsible for enforcement at
simulation.hkt@gmail.com.
All complaints will be reviewed and investigated promptly and fairly.</p>
<p>All community leaders are obligated to respect the privacy and security of the
reporter of any incident.</p>
<h2 id="enforcement-guidelines"><a class="header" href="#enforcement-guidelines">Enforcement Guidelines</a></h2>
<p>Community leaders will follow these Community Impact Guidelines in determining
the consequences for any action they deem in violation of this Code of Conduct:</p>
<h3 id="1-correction"><a class="header" href="#1-correction">1. Correction</a></h3>
<p><strong>Community Impact</strong>: Use of inappropriate language or other behavior deemed
unprofessional or unwelcome in the community.</p>
<p><strong>Consequence</strong>: A private, written warning from community leaders, providing
clarity around the nature of the violation and an explanation of why the
behavior was inappropriate. A public apology may be requested.</p>
<h3 id="2-warning"><a class="header" href="#2-warning">2. Warning</a></h3>
<p><strong>Community Impact</strong>: A violation through a single incident or series
of actions.</p>
<p><strong>Consequence</strong>: A warning with consequences for continued behavior. No
interaction with the people involved, including unsolicited interaction with
those enforcing the Code of Conduct, for a specified period of time. This
includes avoiding interactions in community spaces as well as external channels
like social media. Violating these terms may lead to a temporary or
permanent ban.</p>
<h3 id="3-temporary-ban"><a class="header" href="#3-temporary-ban">3. Temporary Ban</a></h3>
<p><strong>Community Impact</strong>: A serious violation of community standards, including
sustained inappropriate behavior.</p>
<p><strong>Consequence</strong>: A temporary ban from any sort of interaction or public
communication with the community for a specified period of time. No public or
private interaction with the people involved, including unsolicited interaction
with those enforcing the Code of Conduct, is allowed during this period.
Violating these terms may lead to a permanent ban.</p>
<h3 id="4-permanent-ban"><a class="header" href="#4-permanent-ban">4. Permanent Ban</a></h3>
<p><strong>Community Impact</strong>: Demonstrating a pattern of violation of community
standards, including sustained inappropriate behavior, harassment of an
individual, or aggression toward or disparagement of classes of individuals.</p>
<p><strong>Consequence</strong>: A permanent ban from any sort of public interaction within
the community.</p>
<h2 id="attribution"><a class="header" href="#attribution">Attribution</a></h2>
<p>This Code of Conduct is adapted from the <a href="https://www.contributor-covenant.org">Contributor Covenant</a>,
version 2.1, available at
<a href="https://www.contributor-covenant.org/version/2/1/code_of_conduct.html">https://www.contributor-covenant.org/version/2/1/code_of_conduct.html</a>.</p>
<p>Community Impact Guidelines were inspired by <a href="https://github.com/mozilla/diversity">Mozilla's code of conduct
enforcement ladder</a>.</p>
<p>For answers to common questions about this code of conduct, see the FAQ at
<a href="https://www.contributor-covenant.org/faq">https://www.contributor-covenant.org/faq</a>. Translations are available at
<a href="https://www.contributor-covenant.org/translations">https://www.contributor-covenant.org/translations</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<p>MIT License</p>
<p>Copyright (c) 2025 Magnus Smith</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="version-switcher.js"></script>
        <script src="./theme/version-switcher.js"></script>
        <script src="./theme/sidebar-nav-link.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
