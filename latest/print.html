<!DOCTYPE HTML>
<html lang="en" class="latte sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Higher-Kinded Types and Optics for Java</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->


            <meta name="description" content="Explore Higher-Kinded Types (HKTs) and Optcs in Java with the Higher-Kinded-J library. Learn about Functors, Applicatives, Monads, Transformers, practical functional patterns, and how to write cleaner, more composable Java code for your projects using Optics.">


        <meta name="keywords" content="Higher-Kinded Types, Higher-Kinded-J, Higher-Kinded Java, Higher Kinded Java, HKT, Java, Optics, Lens, Prism, Traversal, Iso, Functional Programming, Monad, Functor, Applicative, Transformer, Monoid, Traverse, higherkindedj">
        
        <meta property="og:title" content="Higher-Kinded Types and Optics for Java"> 
            <meta property="og:description" content="Explore Higher-Kinded Types (HKTs) and Optcs in Java with the Higher-Kinded-J library. Learn about Functors, Applicatives, Monads, Transformers, practical functional patterns, and how to write cleaner, more composable Java code for your projects using Optics.">
        <meta property="og:type" content="website">
        <meta property="og:url" content="https://higher-kinded-j.github.io/"> 
        
        <meta property="og:image" content="https://higher-kinded-j.github.io/preview.png" />
        <meta property="og:site_name" content="Higher-Kinded-J Documentation" />
        
        
        <meta name="twitter:card" content="summary_large_image" /> <meta name="twitter:title" content="Higher-Kinded Types and Optics for Java - Higher-Kinded-J" />
        <meta name="twitter:description" content="Bringing Higher-Kinded Types and Optics to Java functional patterns" />
        <meta name="twitter:image" content="https://higher-kinded-j.github.io/preview.png" />
        <meta name="description" content="Explore Higher-Kinded Types (HKTs) and Optcs in Java with the Higher-Kinded-J library. Learn about Functors, Applicatives, Monads, Transformers, practical functional patterns, and how to write cleaner, more composable Java code for your projects using Optics.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">
        <meta name="google-site-verification" content="X-xsiAq2cKMLOzh9dexUrX8Onx2h_YMUFgp5lHHUwSg" />
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./mdbook-admonish.css">
        <link rel="stylesheet" href="./theme/catppuccin.css">
        <link rel="stylesheet" href="./theme/catppuccin-admonish.css">
        <link rel="stylesheet" href="./theme/catppuccin-alerts.css">
        <link rel="stylesheet" href="./theme/additional-hkj.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "latte";
            const default_dark_theme = "macchiato";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('latte')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="latte">Latte</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="frappe">Frapp√©</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="macchiato">Macchiato</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mocha">Mocha</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        <div class="version-selector-container">
                            <select id="version-selector" class="version-selector" aria-label="Select documentation version" title="Select documentation version">
                                <option value="">Loading versions...</option>
                            </select>
                        </div>
                    </div>

                    <h1 class="menu-title">Higher-Kinded Types and Optics for Java</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/higher-kinded-j/higher-kinded-j" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<pre><code> _   _ _       _                      _   ___           _          _        ___ 
| | | (_)     | |                    | | / (_)         | |        | |      |_  |
| |_| |_  __ _| |__   ___ _ __ ______| |/ / _ _ __   __| | ___  __| |______  | |
|  _  | |/ _` | '_ \ / _ \ '__|______|    \| | '_ \ / _` |/ _ \/ _` |______| | |
| | | | | (_| | | | |  __/ |         | |\  \ | | | | (_| |  __/ (_| |    /\__/ /
\_| |_/_|\__, |_| |_|\___|_|         \_| \_/_|_| |_|\__,_|\___|\__,_|    \____/ 
          __/ |                                                           
         |___/                                                            
</code></pre>
<h2 id="bringing-higher-kinded-types-and-composable-optics-to-java"><a class="header" href="#bringing-higher-kinded-types-and-composable-optics-to-java"><a href="https://github.com/higher-kinded-j/higher-kinded-j"><em>Bringing Higher-Kinded Types and Composable Optics to Java</em></a></a></h2>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j"><img src="https://img.shields.io/badge/code-blue?logo=github" alt="Static Badge" />
</a>
<a href="https://codecov.io/gh/higher-kinded-j/higher-kinded-j"><img src="https://img.shields.io/codecov/c/github/higher-kinded-j/higher-kinded-j?token=VR0K0ZEDHD" alt="Codecov" /></a> <a href="https://central.sonatype.com/artifact/io.github.higher-kinded-j/hkj-core"><img src="https://img.shields.io/maven-central/v/io.github.higher-kinded-j/hkj-core" alt="Maven Central Version" /></a> <a href="https://github.com/higher-kinded-j/higher-kinded-j/discussions"><img src="https://img.shields.io/github/discussions/higher-kinded-j/higher-kinded-j" alt="GitHub Discussions" /></a> <a href="https://techhub.social/@ultramagnetic"><img src="https://img.shields.io/mastodon/follow/109367467120571209?domain=techhub.social&amp;style=plastic&amp;logoSize=auto" alt="Mastodon Follow" /></a></p>
<p>Higher-Kinded-J brings two powerful functional programming toolsets to Java, enabling developers to write more abstract, composable, and robust code:</p>
<ol>
<li>A <strong>Higher-Kinded Types (HKT) Simulation</strong> to abstract over computational contexts like <code>Optional</code>, <code>List</code>, or <code>CompletableFuture</code>.</li>
<li>A powerful <strong>Optics Library</strong> to abstract over immutable data structures, with boilerplate-free code generation.</li>
</ol>
<p>These work together to solve common Java pain points in a functional, type-safe way.</p>
<h2 id="two-pillars-of-functional-programming"><a class="header" href="#two-pillars-of-functional-programming"><em>Two Pillars of Functional Programming</em></a></h2>
<h2 id="1-a-higher-kinded-types-simulation-"><a class="header" href="#1-a-higher-kinded-types-simulation-">1: A <a href="hkts/hkt_introduction.html">Higher-Kinded Types</a> Simulation ‚öôÔ∏è</a></h2>
<p>Java's type system lacks native support for Higher-Kinded Types, making it difficult to write code that abstracts over "container" types. We can't easily define a generic function that works identically for <code>List&lt;A&gt;</code>, <code>Optional&lt;A&gt;</code>, and <code>CompletableFuture&lt;A&gt;</code>.</p>
<p>Higher-Kinded-J <strong>simulates HKTs in Java</strong> using a technique inspired by defunctionalisation. This unlocks the ability to use common functional abstractions like <code>Functor</code>, <code>Applicative</code>, and <code>Monad</code> generically across different data types.</p>
<p><strong>With HKTs, you can:</strong></p>
<ul>
<li><strong>Abstract Over Context:</strong> Write logic that works polymorphically over different computational contexts (optionality, asynchrony, error handling, collections).</li>
<li><strong>Leverage Typeclasses:</strong> Consistently apply powerful patterns like <code>map</code>, <code>flatMap</code>, <code>sequence</code>, and <code>traverse</code> across diverse data types.</li>
<li><strong>Build Adaptable Pipelines:</strong> Use profunctors to create flexible data transformation pipelines that adapt to different input and output formats.</li>
<li><strong>Manage Effects:</strong> Use provided monads like <code>IO</code>, <code>Either</code>, <code>Validated</code>, and <code>State</code> to build robust, composable workflows.</li>
</ul>
<h2 id="2-a-powerful-optics-library-"><a class="header" href="#2-a-powerful-optics-library-">2: A Powerful <a href="optics/optics_intro.html">Optics</a> Library üîé</a></h2>
<p>Working with immutable data structures, like Java records, is great for safety but leads to verbose "copy-and-update" logic for nested data.</p>
<p>Higher-Kinded-J provides a full-featured <strong>Optics library</strong> that treats data access as a first-class value. An optic is a <strong>composable, functional getter/setter</strong> that lets you "zoom in" on a piece of data within a larger structure.</p>
<p><strong>With Optics, you can:</strong></p>
<ul>
<li><strong>Eliminate Boilerplate:</strong> An annotation processor <strong>generates</strong> <code>Lens</code>, <code>Prism</code>, <code>Iso</code>, <code>Fold</code>, and <code>Traversal</code> optics for your records and sealed interfaces automatically.</li>
<li><strong>Perform Deep Updates Effortlessly:</strong> Compose optics to create a path deep into a nested structure and perform immutable updates in a single, readable line.</li>
<li><strong>Decouple Data and Operations:</strong> Model your data cleanly as immutable records, while defining complex, reusable operations separately as optics.</li>
<li><strong>Perform Effectful Updates:</strong> The Optics library is built on top of the HKT simulation, allowing you to perform failable, asynchronous, or stateful updates using the powerful <code>modifyF</code> method.</li>
<li><strong>Adapt to Different Data Types:</strong> Every optic is a profunctor, meaning it can be adapted to work with different source and target types using <code>contramap</code>, <code>map</code>, and <code>dimap</code> operations. This provides incredible flexibility for API integration, legacy system support, and data format transformations.</li>
<li><strong>Query with Precision:</strong> Use <strong>filtered traversals</strong> to declaratively focus on elements matching predicates, and <strong>indexed optics</strong> to perform position-aware transformations with full index tracking.</li>
<li><strong>Java-Friendly Syntax:</strong> Leverage the <strong>fluent API</strong> for discoverable, readable optic operations, or use the <strong>Free Monad DSL</strong> to build composable optic programs with multiple execution strategies (direct, logging, validation).</li>
</ul>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<div class="mdbook-alerts mdbook-alerts-note">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  note
</p>
<p>Before diving in, ensure you have the following:
<strong>Java Development Kit (JDK): Version 24</strong> or later. The library makes use of features available in this version.</p>
</div>
<p>The project is modular. To use it, add the relevant dependencies to your <code>build.gradle</code> or <code>pom.xml</code>. The use of an annotation processor helps to automatically generate the required boilerplate for Optics and other patterns.</p>
<p><strong>For HKTs:</strong></p>
<pre><code class="language-gradle">    // build.gradle.kts
    implementation("io.github.higher-kinded-j:hkj-core:LATEST_VERSION")
</code></pre>
<p><strong>For Optics:</strong></p>
<pre><code class="language-gradle">    // build.gradle.kts
    implementation("io.github.higher-kinded-j:hkj-core:LATEST_VERSION")
    annotationProcessor("io.github.higher-kinded-j:hkj-processor:LATEST_VERSION")
    annotationProcessor("io.github.higher-kinded-j:hkj-processor-plugins:LATEST_VERSION")
</code></pre>
<p><strong>For SNAPSHOTS:</strong></p>
<pre><code class="language-gradle">repositories {
    mavenCentral()
    maven {
        url= uri("https://central.sonatype.com/repository/maven-snapshots/")
    }
}
</code></pre>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<p>We recommend following the documentation in order to get a full understanding of the library's capabilities.</p>
<h4 id="optics-guides"><a class="header" href="#optics-guides">Optics Guides</a></h4>
<p>This series provides a practical, step-by-step introduction to solving real-world problems with optics.</p>
<ol>
<li><strong><a href="optics/optics_intro.html">An Introduction to Optics</a>:</strong> Learn what optics are and the problems they solve.</li>
<li><strong><a href="optics/lenses.html">Practical Guide: Lenses</a>:</strong> A deep dive into using <code>Lens</code> for nested immutable updates.</li>
<li><strong><a href="optics/prisms.html">Practical Guide: Prisms</a>:</strong> Learn how to use <code>Prism</code> to safely work with <code>sealed interface</code> (sum types).</li>
<li><strong><a href="optics/iso.html">Practical Guide: Isos</a>:</strong> Understand how <code>Iso</code> provides a bridge between equivalent data types.</li>
<li><strong><a href="optics/traversals.html">Practical Guide: Traversals</a>:</strong> Master the <code>Traversal</code> for performing bulk updates on collections.</li>
<li><strong><a href="optics/profunctor_optics.html">Profunctor Optics</a>:</strong> Discover how to adapt optics to work with different data types and structures.</li>
<li><strong><a href="optics/composing_optics.html">Capstone Example: Deep Validation</a>:</strong> A complete example that composes multiple optics to solve a complex problem.</li>
<li><strong><a href="optics/filtered_optics.html">Practical Guide: Filtered Optics</a>:</strong> Learn how to compose predicates with optics for declarative filtering.</li>
<li><strong><a href="optics/indexed_optics.html">Practical Guide: Indexed Optics</a>:</strong> Discover position-aware transformations with index tracking.</li>
<li><strong><a href="optics/limiting_traversals.html">Practical Guide: Limiting Traversals</a>:</strong> Master traversals that focus on portions of lists.</li>
<li><strong><a href="optics/fluent_api.html">Fluent API for Optics</a>:</strong> Explore Java-friendly syntax for optic operations.</li>
<li><strong><a href="optics/free_monad_dsl.html">Free Monad DSL</a>:</strong> Build composable optic programs as data structures.</li>
<li><strong><a href="optics/interpreters.html">Optic Interpreters</a>:</strong> Execute optic programs with different strategies (logging, validation).</li>
</ol>
<h4 id="hkt-core-concepts"><a class="header" href="#hkt-core-concepts">HKT Core Concepts</a></h4>
<p>For users who want to understand the underlying HKT simulation that powers the optics library or use monads directly.</p>
<ol>
<li><strong><a href="hkts/hkt_introduction.html">An Introduction to HKTs</a>:</strong> Learn what HKTs are and the problems they solve.</li>
<li><strong><a href="hkts/core-concepts.html">Core Concepts</a>:</strong> Understand <code>Kind</code>, Witness Types, and Type Classes (<code>Functor</code>, <code>Monad</code>).</li>
<li><strong><a href="monads/supported-types.html">Supported Types</a>:</strong> See which types are simulated and have typeclass instances.</li>
<li><strong><a href="hkts/usage-guide.html">Usage Guide</a>:</strong> Learn the practical steps for using the HKT simulation directly.</li>
<li><strong><a href="hkts/hkt_basic_examples.html">Examples of how to use HKTs</a></strong>: Practical Examples of how to use the Monads.</li>
<li><strong><a href="hkts/order-walkthrough.html">Order Example Walkthrough</a>:</strong> A detailed example of building a robust workflow with monad transformers.</li>
<li><strong><a href="hkts/extending-simulation.html">Extending Higher-Kinded-J</a>:</strong> Learn how to add HKT support for your own custom types.</li>
</ol>
<h4 id="history"><a class="header" href="#history">History</a></h4>
<p><strong>Higher-Kinded-J evolved from a simulation</strong> that was originally created for the blog post <a href="https://blog.scottlogic.com/2025/04/11/higher-kinded-types-with-java-and-scala.html">Higher Kinded Types with Java and Scala</a> that explored Higher-Kinded types and their lack of support in Java. The blog post discussed a process called defuctionalisation that could be used to simulate Higher-Kinded types in Java. Since then Higher-Kinded-J has grown into something altogether more useful supporting more functional patterns.</p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="introduction-to-higher-kinded-types"><a class="header" href="#introduction-to-higher-kinded-types">Introduction to Higher-Kinded Types</a></h1>
<p><img src="hkts/../images/rubiks1932.jpg" alt="rubiks1932.jpg" /></p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="hkts/hkt_introduction.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>The analogy between higher-order functions and higher-kinded types</li>
<li>Why Java's type system limitations necessitate HKT simulation</li>
<li>How abstractions over "container" types enable more reusable code</li>
<li>The difference between first-order types, generic types, and higher-kinded types</li>
<li>Real-world benefits: less boilerplate, more abstraction, better composition</li>
</ul>
</div>
</div>
<p>We can think about Higher-Kinded Types (HKT) by making an analogy with Higher-Order Functions (HOF).</p>
<p><em>higher-kinded types are to types what higher-order functions are to functions.</em></p>
<p>They both represent a powerful form of abstraction, just at different levels.</p>
<h3 id="the-meaning-of-regular-and-higher-order"><a class="header" href="#the-meaning-of-regular-and-higher-order">The Meaning of "Regular" and "Higher-Order"</a></h3>
<p><strong>Functions</strong> model Behaviour</p>
<ul>
<li><strong>First-Order (Regular) Function:</strong> This kind of function operates on simple values. It takes a value(s) like a <code>int</code> and returns a value.</li>
</ul>
<pre><code class="language-java">// Take a value and return a value
int square(int num) {
    return num * num;
}    
</code></pre>
<ul>
<li><strong>Higher-Order Function:</strong> This kind of function operates on <em>other functions</em>.  It can take functions as arguments and or return a new function as the result.  It abstracts over the <strong>behaviour</strong>.</li>
</ul>
<pre><code class="language-java">// Takes a Set of type A and a function fn that maps types of A to B,
//  returns a new Set of type B
&lt;A, B&gt; Set&lt;B&gt; mapper(Set&lt;A&gt; list, Function&lt;A, B&gt; fn) {
    // ... applies fn to each element of the set
}
</code></pre>
<p><code>mapper</code> is a higher-order function because it takes the function <code>fn</code> as an argument.</p>
<p><strong>Types</strong> model Structure</p>
<ul>
<li><strong>First-Order (Regular) Type:</strong> A simple, concrete type like <code>int</code>, or <code>Set&lt;Double&gt;</code> represents a specific kind of data.</li>
<li><strong>Higher-Kinded Type (HKT):</strong> This is a "type that operates on types." More accurately, it's a generic type constructor that can itself be treated as a type parameter. It abstracts over structure or computational context.</li>
</ul>
<p>Let us consider <code>Set&lt;T&gt;</code>. <code>Set</code> itself without the <code>T</code>, is a type constructor.  Think of it as a "function" for types: Supply it a type (like <code>Integer</code>), and it produces a new concrete type <code>Set&lt;Integer&gt;</code>.</p>
<p>A higher-kinded type allows us to write code that is generic over <code>Set</code> itself, or <code>List</code>, or <code>CompletableFuture</code>.</p>
<h3 id="generic-code-in-practice"><a class="header" href="#generic-code-in-practice">Generic code in Practice</a></h3>
<p><strong>Functions</strong></p>
<p><em>Without Higher-Order Functions:</em></p>
<p>To apply different operations to a list, we would need to write separate loops for each one.</p>
<pre><code class="language-java">List&lt;String&gt; results = new ArrayList&lt;&gt;();
for (int i : numbers) {
    results.add(intToString(i)); // Behavior is hardcoded
}
</code></pre>
<p><em>With Higher-Order Functions:</em></p>
<p>We abstract the behaviour into a function and pass it in. This is much more flexible.</p>
<pre><code class="language-java">
// A map for List
&lt;A, B&gt; List&lt;B&gt; mapList(List&lt;A&gt; list, Function&lt;A, B&gt; f);

// A map for Optional
&lt;A, B&gt; Optional&lt;B&gt; mapOptional(Optional&lt;A&gt; opt, Function&lt;A, B&gt; f);

// A map for CompletableFuture
&lt;A, B&gt; CompletableFuture&lt;B&gt; mapFuture(CompletableFuture&lt;A&gt; future, Function&lt;A, B&gt; f);

</code></pre>
<p>Notice the repeated pattern: the core logic is the same, but the "container" is different.</p>
<p><em>With Higher-Kinded Types:</em></p>
<p>With Higher-Kinded-J we can abstract over the container <code>F</code> itself. This allows us to write one single, generic map function that works for any container structure or computational context that can be mapped over (i.e., any <code>Functor</code>). This is precisely what the <code>GenericExample.java</code> demonstrates.</p>
<pre><code class="language-java">// F is a "type variable" that stands for List, Optional, etc.
// This is a function generic over the container F.
public static &lt;F, A, B&gt; Kind&lt;F, B&gt; map(
    Functor&lt;F&gt; functorInstance, // The implementation for F
    Kind&lt;F, A&gt; kindBox,         // The container with a value
    Function&lt;A, B&gt; f) {         // The behaviour to apply
    return functorInstance.map(f, kindBox);
}

</code></pre>
<p>Here, <code>Kind&lt;F, A&gt;</code> is the higher-kinded type that represents "some container F holding a value of type A."</p>
<p>Both concepts allow you to write more generic and reusable code by parametrising things that are normally fixed. <strong>Higher-order functions parametrise behaviour, while higher-kinded types parametrise the structure that contains the behaviour.</strong></p>
<p>We will discuss the <code>GenericExample.java</code> in detail later, but you can take a peek at the code here</p>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/GenericExample.java">GenericExample.java</a></li>
</ul>
<h2 id="the-core-idea-abstraction-over-containers"><a class="header" href="#the-core-idea-abstraction-over-containers">The Core Idea: Abstraction over Containers</a></h2>
<p>In short: a higher-kinded type is a way to be generic over the container type itself.
Think about the different "container" types you use every day in Java: <code>List&lt;T&gt;</code>, <code>Optional&lt;T&gt;</code>, <code>Future&lt;T&gt;</code>, <code>Set&lt;T&gt;</code>. All of these are generic containers that hold a value of type <code>T</code>.
The problem is that you can't write a single method in Java that accepts any of these containers and performs an action, because <code>List</code>, <code>Optional</code>, and <code>Future</code> don't share a useful common interface. A higher-kinded type solves this by letting you write code that works with <code>F&lt;T&gt;</code>, where <code>F</code> itself is a variable representing the container type (<code>List</code>, <code>Optional</code>, etc.).</p>
<h2 id="building-up-from-java-generics"><a class="header" href="#building-up-from-java-generics">Building Up from Java Generics</a></h2>
<h3 id="level-1-concrete-types-like-values"><a class="header" href="#level-1-concrete-types-like-values">Level 1: Concrete Types (like values)</a></h3>
<p>A normal, complete type is like a value. It's a "thing".</p>
<pre><code class="language-java">String myString;          // A concrete type
List&lt;Integer&gt; myIntList;  // Also a concrete type (a List of Integers)
</code></pre>
<h3 id="level-2-generic-types-like-functions"><a class="header" href="#level-2-generic-types-like-functions">Level 2: Generic Types (like functions)</a></h3>
<p>A generic type definition like <code>List&lt;T&gt;</code> is not a complete type. It's a type constructor. It's like a function at the type level: you give it a type (e.g., <code>String</code>), and it produces a concrete type (<code>List&lt;String&gt;</code>).</p>
<pre><code class="language-java">// List&lt;T&gt; is a "type function" that takes one parameter, T.
// We can call it a type of kind: * -&gt; *
// (It takes one concrete type to produce one concrete type)
</code></pre>
<p>You can't declare a variable of type <code>List</code>. You must provide the type parameter <code>T</code>.</p>
<h3 id="level-3-higher-kinded-types-like-functions-that-take-other-functions"><a class="header" href="#level-3-higher-kinded-types-like-functions-that-take-other-functions">Level 3: Higher-Kinded Types (like functions that take other functions)</a></h3>
<p>This is the part Java doesn't support directly. A higher-kinded type is a construct that is generic over the type constructor itself.
Imagine you want to write a single map function that works on any container. You want to write code that says: <em>"Given any container F holding type A, and a function to turn an A into a B, I will give you back a container F holding type B."</em>
In imaginary Java syntax, it would look like this:</p>
<pre><code class="language-java">// THIS IS NOT REAL JAVA SYNTAX
public &lt;F&lt;?&gt;, A, B&gt; F&lt;B&gt; map(F&lt;A&gt; container, Function&lt;A, B&gt; func);
</code></pre>
<p>Here, <code>F </code>is the higher-kinded type parameter. It's a variable that can stand for <code>List</code>, <code>Optional</code>, <code>Future</code>, or any other <code>* -&gt; *</code> type constructor.</p>
<h2 id="a-practical-analogy-the-shipping-company"><a class="header" href="#a-practical-analogy-the-shipping-company">A Practical Analogy: The Shipping Company</a></h2>
<p><img src="hkts/../images/containers.png" alt="containers.png" /></p>
<p>Think of it like working at a shipping company.
A concrete type <code>List&lt;String&gt;</code> is a "Cardboard Box full of Apples".
A generic type <code>List&lt;T&gt;</code> is a blueprint for a "Cardboard Box" that can hold anything (<code>T</code>).
Now, you want to write a single set of instructions (a function) for your robotic arm called addInsuranceLabel. You want these instructions to work on any kind of container.
Without HKTs (The Java Way): You have to write separate instructions for each container type.</p>
<pre><code class="language-java">addInsuranceToCardboardBox(CardboardBox&lt;T&gt; box, ...)
addInsuranceToPlasticCrate(PlasticCrate&lt;T&gt; crate, ...)
addInsuranceToMetalCase(MetalCase&lt;T&gt; case, ...)
</code></pre>
<p>With HKTs (The Abstract Way): You write one generic set of instructions.</p>
<pre><code class="language-java">addInsuranceToContainer(Container&lt;T&gt; container, ...)
</code></pre>
<p>A higher-kinded type is the concept of being able to write code that refers to <code>Container&lt;T&gt;</code> ‚Äî an abstraction over the container or "context" that holds the data.</p>
<p>Higher-Kinded-J <strong>simulates HKTs in Java</strong> using a technique inspired by defunctionalisation. It allows you to define and use common functional abstractions like <code>Functor</code>, <code>Applicative</code>, and <code>Monad</code> (including <code>MonadError</code>) in a way that works <em>generically</em> across different simulated type constructors.</p>
<p><strong>Why bother?</strong> Higher-Kinded-J unlocks several benefits:</p>
<ul>
<li><strong>Write Abstract Code:</strong> Define functions and logic that operate polymorphically over different computational contexts (e.g., handle optionality, asynchronous operations, error handling, side effects, or collections using the <em>same</em> core logic).</li>
<li><strong>Leverage Functional Patterns:</strong> Consistently apply powerful patterns like <code>map</code>, <code>flatMap</code>, <code>ap</code>, <code>sequence</code>, <code>traverse</code>, and monadic error handling (<code>raiseError</code>, <code>handleErrorWith</code>) across diverse data types.</li>
<li><strong>Build Composable Systems:</strong> Create complex workflows and abstractions by composing smaller, generic pieces, as demonstrated in the included <a href="hkts/order-walkthrough.html">Order Processing Example</a>.</li>
<li><strong>Understand HKT Concepts:</strong> Provides a practical, hands-on way to understand HKTs and type classes even within Java's limitations.</li>
<li><strong>Lay the Foundations:</strong> Building on HKTs unlocks the possibilities for advanced abstractions like <a href="hkts/../optics/optics_intro.html">Optics</a>, which provide composable ways to access and modify nested data structures.</li>
</ul>
<p>While Higher-Kinded-J introduces some boilerplate compared to languages with native HKT support, it offers a valuable way to explore these powerful functional programming concepts in Java.</p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="core-concepts-of-higher-kinded-j"><a class="header" href="#core-concepts-of-higher-kinded-j">Core Concepts of Higher-Kinded-J</a></h1>
<p><img src="hkts/../images/concepts.png" alt="concepts.png" /></p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="hkts/core-concepts.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How the Kind&lt;F, A&gt; interface simulates higher-kinded types in Java</li>
<li>The role of witness types in representing type constructors</li>
<li>Understanding defunctionalisation and how it enables HKT simulation</li>
<li>The difference between internal library types and external Java types</li>
<li>How type classes provide generic operations across different container types</li>
</ul>
</div>
</div>
<p>Higher-Kinded-J employs several key components to emulate Higher-Kinded Types (HKTs) and associated functional type classes in Java. Understanding these is crucial for using and extending the library.</p>
<p><a href="hkts/hkt_basic_examples.html">Feel free to skip ahead to the examples and come back later for the theory</a></p>
<h2 id="1-the-hkt-problem-in-java"><a class="header" href="#1-the-hkt-problem-in-java">1. The HKT Problem in Java</a></h2>
<p>As we've already discussed, Java's type system lacks native support for Higher-Kinded Types. We can easily parametrise a type by another type (like <code>List&lt;String&gt;</code>), but we cannot easily parametrise a type or method by a <em>type constructor</em> itself (like <code>F&lt;_&gt;</code>). We can't write <code>void process&lt;F&lt;_&gt;&gt;(F&lt;Integer&gt; data)</code> to mean "process any container F of Integers".</p>
<div id="admonition-warning" class="admonition admonish-warning" role="note" aria-labelledby="admonition-warning-title">
<div class="admonition-title">
<div id="admonition-warning-title">
<p>Warning</p>
</div>
<a class="admonition-anchor-link" href="hkts/core-concepts.html#admonition-warning"></a>
</div>
<div>
<p>You'll often see Higher-Kinded Types represented with an underscore, such as <code>F&lt;_&gt;</code> (e.g., <code>List&lt;_&gt;</code>, <code>Optional&lt;_&gt;</code>). This notation, borrowed from languages like Scala, represents a "type constructor"‚Äîa type that is waiting for a type parameter. It's important to note that this underscore is a conceptual placeholder and is not the same as Java's <code>?</code> wildcard, which is used for instantiated types. Our library provides a way to simulate this <code>F&lt;_&gt;</code> concept in Java.</p>
</div>
</div>
<h2 id="2-the-kindf-a-bridge"><a class="header" href="#2-the-kindf-a-bridge">2. The <code>Kind&lt;F, A&gt;</code> Bridge</a></h2>
<p>At the very centre of the library are the <code>Kind</code> interfaces, which make higher-kinded types possible in Java.</p>
<ul>
<li>
<p><strong><code>Kind&lt;F, A&gt;</code></strong>: This is the foundational interface that emulates a higher-kinded type. It represents a type <code>F</code> that is generic over a type <code>A</code>. For example, <code>Kind&lt;ListKind.Witness, String&gt;</code> represents a <code>List&lt;String&gt;</code>. You will see this interface used everywhere as the common currency for all our functional abstractions.</p>
</li>
<li>
<p><strong><code>Kind2&lt;F, A, B&gt;</code></strong>: This interface extends the concept to types that take two type parameters, such as <code>Function&lt;A, B&gt;</code> or <code>Either&lt;L, R&gt;</code>. For example, <code>Kind2&lt;FunctionKind.Witness, String, Integer&gt;</code> represents a <code>Function&lt;String, Integer&gt;</code>. This is essential for working with profunctors and other dual-parameter abstractions.</p>
</li>
</ul>
<p><img src="hkts/../images/puml/defunctionalisation_internal.svg" alt="defunctionalisation_internal.svg" /></p>
<ul>
<li><strong>Purpose:</strong> To simulate the application of a type constructor <code>F</code> (like <code>List</code>, <code>Optional</code>, <code>IO</code>) to a type argument <code>A</code> (like <code>String</code>, <code>Integer</code>), representing the concept of <code>F&lt;A&gt;</code>.</li>
<li><strong><code>F</code> (Witness Type):</strong> This is the crucial part of the simulation. Since <code>F&lt;_&gt;</code> isn't a real Java type parameter, we use a <em>marker type</em> (often an empty interface specific to the constructor) as a "witness" or stand-in for <code>F</code>. Examples:
<ul>
<li><code>ListKind&lt;ListKind.Witness&gt;</code> represents the <code>List</code> type constructor.</li>
<li><code>OptionalKind&lt;OptionalKind.Witness&gt;</code> represents the <code>Optional</code> type constructor.</li>
<li><code>EitherKind.Witness&lt;L&gt;</code> represents the <code>Either&lt;L, _&gt;</code> type constructor (where <code>L</code> is fixed).</li>
<li><code>IOKind&lt;IOKind.Witness&gt;</code> represents the <code>IO</code> type constructor.</li>
</ul>
</li>
<li><strong><code>A</code> (Type Argument):</strong> The concrete type contained within or parametrised by the constructor (e.g., <code>Integer</code> in <code>List&lt;Integer&gt;</code>).</li>
<li><strong>How it Works:</strong> The library provides a seamless bridge between a standard java type, like a <code>java.util.List&lt;Integer&gt;</code>and its <code>Kind</code> representation <code>Kind&lt;ListKind.Witness, Integer&gt;</code>. Instead of requiring you to manually wrap objects, this conversion is handled by static helper methods, typically <code>widen</code> and <code>narrow</code>.
<ul>
<li>To treat a <code>List&lt;Integer&gt;</code> as a <code>Kind</code>, you use a helper function like <code>LIST.widen()</code>.</li>
<li>This <code>Kind</code> object can then be passed to generic functions (such as <code>map</code> or <code>flatMap</code> from a <code>Functor</code> or <code>Monad</code> instance) that expect <code>Kind&lt;F, A&gt;</code>.</li>
</ul>
</li>
<li><strong>Reference:</strong> <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-api/src/main/java/org/higherkindedj/hkt/Kind.java"><code>Kind.java</code></a></li>
</ul>
<div id="admonition-tip" class="admonition admonish-tip" role="note" aria-labelledby="admonition-tip-title">
<div class="admonition-title">
<div id="admonition-tip-title">
<p>Tip</p>
</div>
<a class="admonition-anchor-link" href="hkts/core-concepts.html#admonition-tip"></a>
</div>
<div>
<p>For quick definitions of HKT concepts like Kind, Witness Types, and Defunctionalisation, see the <a href="hkts/../glossary.html">Glossary</a>.</p>
</div>
</div>
<h2 id="3-type-classes-functor-applicative-monad-monaderror"><a class="header" href="#3-type-classes-functor-applicative-monad-monaderror">3. Type Classes (<code>Functor</code>, <code>Applicative</code>, <code>Monad</code>, <code>MonadError</code>)</a></h2>
<p>These are interfaces that define standard functional operations that work <em>generically</em> over any simulated type constructor <code>F</code> (represented by its witness type) for which an instance of the type class exists. They operate on <code>Kind&lt;F, A&gt;</code> objects.</p>
<p><img src="hkts/../images/puml/core_typeclasses_high_level.svg" alt="core_typeclasses_high_level.svg" /></p>
<ul>
<li><strong><code>Functor&lt;F&gt;</code>:</strong>
<ul>
<li>Defines <code>map(Function&lt;A, B&gt; f, Kind&lt;F, A&gt; fa)</code>: Applies a function <code>f: A -&gt; B</code> to the value(s) inside the context <code>F</code> without changing the context's structure, resulting in a <code>Kind&lt;F, B&gt;</code>. Think <code>List.map</code>, <code>Optional.map</code>.</li>
<li>Laws: Identity (<code>map(id) == id</code>), Composition (<code>map(g.compose(f)) == map(g).compose(map(f))</code>).</li>
<li>Reference: <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-api/src/main/java/org/higherkindedj/hkt/Functor.java"><code>Functor.java</code></a></li>
</ul>
</li>
<li><strong><code>Applicative&lt;F&gt;</code>:</strong>
<ul>
<li>Extends <code>Functor&lt;F&gt;</code>.</li>
<li>Adds <code>of(A value)</code>: Lifts a pure value <code>A</code> into the context <code>F</code>, creating a <code>Kind&lt;F, A&gt;</code>. (e.g., <code>1</code> becomes <code>Optional.of(1)</code> wrapped in <code>Kind</code>).</li>
<li>Adds <code>ap(Kind&lt;F, Function&lt;A, B&gt;&gt; ff, Kind&lt;F, A&gt; fa)</code>: Applies a function wrapped in context <code>F</code> to a value wrapped in context <code>F</code>, returning a <code>Kind&lt;F, B&gt;</code>. This enables combining multiple independent values within the context.</li>
<li>Provides default <code>mapN</code> methods (e.g., <code>map2</code>, <code>map3</code>) built upon <code>ap</code> and <code>map</code>.</li>
<li>Laws: Identity, Homomorphism, Interchange, Composition.</li>
<li>Reference: <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-api/src/main/java/org/higherkindedj/hkt/Applicative.java"><code>Applicative.java</code></a></li>
</ul>
</li>
<li><strong><code>Monad&lt;F&gt;</code>:</strong>
<ul>
<li>Extends <code>Applicative&lt;F&gt;</code>.</li>
<li>Adds <code>flatMap(Function&lt;A, Kind&lt;F, B&gt;&gt; f, Kind&lt;F, A&gt; ma)</code>: Sequences operations within the context <code>F</code>. Takes a value <code>A</code> from context <code>F</code>, applies a function <code>f</code> that returns a <em>new context</em> <code>Kind&lt;F, B&gt;</code>, and returns the result flattened into a single <code>Kind&lt;F, B&gt;</code>. Essential for chaining dependent computations (e.g., chaining <code>Optional</code> calls, sequencing <code>CompletableFuture</code>s, combining <code>IO</code> actions). Also known in functional languages as <code>bind</code> or <code>&gt;&gt;=</code>.</li>
<li>Provides default <code>flatMapN</code> methods (e.g., <code>flatMap2</code>, <code>flatMap3</code>, <code>flatMap4</code>, <code>flatMap5</code>) for combining multiple monadic values with an effectful function. These methods sequence operations where the combining function itself returns a monadic value, unlike <code>mapN</code> which uses a pure function.</li>
<li>Laws: Left Identity, Right Identity, Associativity.</li>
<li>Reference: <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-api/src/main/java/org/higherkindedj/hkt/Monad.java"><code>Monad.java</code></a></li>
</ul>
</li>
<li><strong><code>MonadError&lt;F, E&gt;</code>:</strong>
<ul>
<li>Extends <code>Monad&lt;F&gt;</code>.</li>
<li>Adds error handling capabilities for contexts <code>F</code> that have a defined error type <code>E</code>.</li>
<li>Adds <code>raiseError(E error)</code>: Lifts an error <code>E</code> into the context <code>F</code>, creating a <code>Kind&lt;F, A&gt;</code> representing the error state (e.g., <code>Either.Left</code>, <code>Try.Failure</code> or failed <code>CompletableFuture</code>).</li>
<li>Adds <code>handleErrorWith(Kind&lt;F, A&gt; ma, Function&lt;E, Kind&lt;F, A&gt;&gt; handler)</code>: Allows recovering from an error state <code>E</code> by providing a function that takes the error and returns a <em>new context</em> <code>Kind&lt;F, A&gt;</code>.</li>
<li>Provides default recovery methods like <code>handleError</code>, <code>recover</code>, <code>recoverWith</code>.</li>
<li>Reference: <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-api/src/main/java/org/higherkindedj/hkt/MonadError.java"><code>MonadError.java</code></a></li>
</ul>
</li>
</ul>
<h2 id="4-defunctionalisation-per-type-constructor"><a class="header" href="#4-defunctionalisation-per-type-constructor">4. Defunctionalisation (Per Type Constructor)</a></h2>
<p>For each Java type constructor (like <code>List</code>, <code>Optional</code>, <code>IO</code>) you want to simulate as a Higher-Kinded Type, a specific pattern involving several components is used. The exact implementation differs slightly depending on whether the type is defined <em>within</em> the Higher-Kinded-J library (e.g., <code>Id</code>, <code>Maybe</code>, <code>IO</code>, monad transformers) or if it's an <em>external type</em> (e.g., <code>java.util.List</code>, <code>java.util.Optional</code>, <code>java.util.concurrent.CompletableFuture</code>).</p>
<p><strong>Common Components:</strong></p>
<ul>
<li>
<p><strong>The <code>XxxKind</code> Interface:</strong> A specific marker interface, for example, <code>OptionalKind&lt;A&gt;</code>. This interface extends <code>Kind&lt;F, A&gt;</code>, where <code>F</code> is the witness type representing the type constructor.</p>
<ul>
<li><strong>Example:</strong> <code>public interface OptionalKind&lt;A&gt; extends Kind&lt;OptionalKind.Witness, A&gt; { /* ... Witness class ... */ }</code></li>
<li>The <code>Witness</code> (e.g., <code>OptionalKind.Witness</code>) is a static nested final class (or a separate, accessible class) within <code>OptionalKind</code>. This <code>Witness</code> type is what's used as the <code>F</code> parameter in generic type classes like <code>Monad&lt;F&gt;</code>.</li>
</ul>
</li>
<li>
<p><strong>The <code>KindHelper</code> Class (e.g., <code>OptionalKindHelper</code>):</strong> A crucial utility <code>widen</code> and <code>narrow</code> methods:</p>
<ul>
<li><code>widen(...)</code>: Converts the standard Java type (e.g., <code>Optional&lt;String&gt;</code>) into its <code>Kind&lt;F, A&gt;</code> representation.</li>
<li><code>narrow(Kind&lt;F, A&gt; kind)</code>: Converts the <code>Kind&lt;F, A&gt;</code> representation back to the underlying Java type (e.g., <code>Optional&lt;String&gt;</code>).
<ul>
<li><strong>Crucially, this method throws <code>KindUnwrapException</code> if the input <code>kind</code> is structurally invalid</strong> (e.g., <code>null</code>, the wrong <code>Kind</code> type, or (<em>for holder-based types</em>) a <code>Holder</code> containing <code>null</code> where it shouldn't). This ensures robustness.</li>
</ul>
</li>
<li>May contain other convenience factory methods.</li>
</ul>
</li>
<li>
<p><strong>Type Class Instance(s):</strong> Concrete classes implementing <code>Functor&lt;F&gt;</code>, <code>Monad&lt;F&gt;</code>, etc., for the specific witness type <code>F</code> (e.g., <code>OptionalMonad implements Monad&lt;OptionalKind.Witness&gt;</code>). These instances use the <code>KindHelper</code>'s <code>widen</code> and <code>narrow</code> methods to operate on the underlying Java types.</p>
</li>
</ul>
<p><strong>External Types:</strong></p>
<p><img src="hkts/../images/puml/defunctionalisation_external.svg" alt="defunctionalisation_external.svg" /></p>
<ul>
<li><strong>For Types Defined Within Higher-Kinded-J (e.g., <code>Id</code>, <code>IO</code>, <code>Maybe</code>, <code>Either</code>, Monad Transformers like <code>EitherT</code>):</strong>
<ul>
<li>These types are designed to directly participate in the HKT simulation.</li>
<li>The type itself (e.g., <code>Id&lt;A&gt;</code>, <code>IO&lt;A&gt;</code>, <code>Just&lt;T&gt;</code>, <code>Either.Right&lt;L,R&gt;</code>) will directly implement its corresponding <code>XxxKind</code> interface (e.g., <code>Id&lt;A&gt; implements IdKind&lt;A&gt;</code>, <code>IO&lt;A&gt; extends IOKind&lt;A&gt;</code>, <code>Just&lt;T&gt; implements MaybeKind&lt;T&gt;</code>, <code>Either.Right&lt;L,R&gt; implements EitherKind&lt;L,R&gt;</code>).</li>
<li>In this case, a separate <code>Holder</code> record is <strong>not needed</strong> for the primary <code>widen</code>/<code>narrow</code> mechanism in the <code>KindHelper</code>.</li>
<li><code>XxxKindHelper.widen(IO&lt;A&gt; io)</code> would effectively be a type cast (after null checks) to <code>Kind&lt;IOKind.Witness, A&gt;</code> because <code>IO&lt;A&gt;</code> <em>is already</em> an <code>IOKind&lt;A&gt;</code>.</li>
<li><code>XxxKindHelper.narrow(Kind&lt;IOKind.Witness, A&gt; kind)</code> would check <code>instanceof IO</code> and perform a cast.</li>
<li>This approach provides <strong>zero runtime overhead</strong> for widen/narrow operations (no wrapper object allocation) and improved debugging experience (actual types visible in stack traces).</li>
</ul>
</li>
</ul>
<p>This distinction is important for understanding how <code>wrap</code> and <code>unwrap</code> function for different types. However, from the perspective of a user of a type class instance (like <code>OptionalMonad</code>), the interaction remains consistent: you provide a <code>Kind</code> object, and the type class instance handles the necessary operations.</p>
<h2 id="5-the-unit-type"><a class="header" href="#5-the-unit-type">5. The <code>Unit</code> Type</a></h2>
<p>In functional programming, it's common to have computations or functions that perform an action (often a side effect) but do not produce a specific, meaningful result value. In Java, methods that don't return a value use the <code>void</code> keyword. However, <code>void</code> is not a first-class type and cannot be used as a generic type parameter <code>A</code> in <code>Kind&lt;F, A&gt;</code>.</p>
<p>Higher-Kinded-J provides the <code>org.higherkindedj.hkt.Unit</code> type to address this.</p>
<ul>
<li><strong>Purpose:</strong> <code>Unit</code> is a type that has exactly one value, <code>Unit.INSTANCE</code>. It is used to represent the successful completion of an operation that doesn't yield any other specific information. Think of it as a functional equivalent of <code>void</code>, but usable as a generic type.</li>
<li><strong>Usage in HKT:</strong>
<ul>
<li>When a monadic action <code>Kind&lt;F, A&gt;</code> completes successfully but has no specific value to return (e.g., an <code>IO</code> action that prints to the console), <code>A</code> can be <code>Unit</code>. The action would then be <code>Kind&lt;F, Unit&gt;</code>, and its successful result would conceptually be <code>Unit.INSTANCE</code>. For example, <code>IO&lt;Unit&gt;</code> for a print operation.</li>
<li>In <code>MonadError&lt;F, E&gt;</code>, if the error state <code>E</code> simply represents an absence or a failure without specific details (like <code>Optional.empty()</code> or <code>Maybe.Nothing()</code>), <code>Unit</code> can be used as the type for <code>E</code>. The <code>raiseError</code> method would then be called with <code>Unit.INSTANCE</code>. For instance, <code>OptionalMonad</code> implements <code>MonadError&lt;OptionalKind.Witness, Unit&gt;</code>, and <code>MaybeMonad</code> implements <code>MonadError&lt;MaybeKind.Witness, Unit&gt;</code>.</li>
</ul>
</li>
<li><strong>Example:</strong>
<pre><code class="language-java">// An IO action that just performs a side effect (printing)
Kind&lt;IOKind.Witness, Unit&gt; printAction = IOKindHelper.delay(() -&gt; {
    System.out.println("Effect executed!");
    return Unit.INSTANCE; // Explicitly return Unit.INSTANCE
});
IOKindHelper.unsafeRunSync(printAction); // Executes the print

// Optional treated as MonadError&lt;..., Unit&gt;
OptionalMonad optionalMonad = OptionalMonad.INSTANCE;
Kind&lt;OptionalKind.Witness, String&gt; emptyOptional = optionalMonad.raiseError(Unit.INSTANCE); // Creates Optional.empty()
</code></pre>
</li>
<li><strong>Reference:</strong> <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/unit/Unit.java"><code>Unit.java</code></a></li>
</ul>
<h2 id="6-error-handling-philosophy"><a class="header" href="#6-error-handling-philosophy">6. Error Handling Philosophy</a></h2>
<ul>
<li><strong>Domain Errors:</strong> These are expected business-level errors or alternative outcomes. They are represented <em>within</em> the structure of the simulated type (e.g., <code>Either.Left</code>, <code>Maybe.Nothing</code>, <code>Try.Failure</code>, a failed <code>CompletableFuture</code>, potentially a specific result type within <code>IO</code>). These are handled using the type's specific methods or <code>MonadError</code> capabilities (<code>handleErrorWith</code>, <code>recover</code>, <code>fold</code>, <code>orElse</code>, etc.) <em>after</em> successfully unwrapping the <code>Kind</code>.</li>
<li><strong>Simulation Errors (<code>KindUnwrapException</code>):</strong> These indicate a problem with the HKT simulation <em>itself</em> ‚Äì usually a programming error. Examples include passing <code>null</code> to <code>unwrap</code>, passing a <code>ListKind</code> to <code>OptionalKindHelper.unwrap</code>, or (if it were possible) having a <code>Holder</code> record contain a <code>null</code> reference to the underlying Java object it's supposed to hold. These are signalled by throwing the unchecked <code>KindUnwrapException</code> from <code>unwrap</code> methods to clearly distinguish infrastructure issues from domain errors. You typically shouldn't need to catch <code>KindUnwrapException</code> unless debugging the simulation usage itself.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="usage-guide-working-with-higher-kinded-j"><a class="header" href="#usage-guide-working-with-higher-kinded-j">Usage Guide: Working with Higher-Kinded-J</a></h1>
<p><img src="hkts/../images/oa-movements.png" alt="oa-movements.png" /></p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="hkts/usage-guide.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>The five-step workflow for using Higher-Kinded-J effectively</li>
<li>How to identify the right context (witness type) for your use case</li>
<li>Using widen() and narrow() to convert between Java types and Kind representations</li>
<li>When and how to handle KindUnwrapException safely</li>
<li>Writing generic functions that work with any Functor or Monad</li>
</ul>
</div>
</div>
<p>This guide explains the step-by-step process of using Higher-Kinded-J's simulated Higher-Kinded Types (HKTs) and associated type classes like <code>Functor</code>, <code>Applicative</code>, <code>Monad</code>, and <code>MonadError</code>.</p>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/GenericExample.java">GenericExample.java</a></li>
</ul>
<h2 id="core-workflow"><a class="header" href="#core-workflow">Core Workflow</a></h2>
<p>The general process involves these steps:</p>
<div id="admonition-step-1-identify-the-context-_f_witness_" class="admonition admonish-note" role="note" aria-labelledby="admonition-step-1-identify-the-context-_f_witness_-title">
<div class="admonition-title">
<div id="admonition-step-1-identify-the-context-_f_witness_-title">
<p>Step 1: Identify the Context (<em>F_WITNESS</em>)</p>
</div>
<a class="admonition-anchor-link" href="hkts/usage-guide.html#admonition-step-1-identify-the-context-_f_witness_"></a>
</div>
<div>
<p>Determine which type constructor (computational context) you want to work with abstractly. This context is represented by its <em>witness type</em>.</p>
<p>Examples:</p>
<ul>
<li><code>ListKind.Witness</code> for <code>java.util.List</code></li>
<li><code>OptionalKind.Witness</code> for <code>java.util.Optional</code></li>
<li><code>MaybeKind.Witness</code> for the custom <code>Maybe</code> type</li>
<li><code>EitherKind.Witness&lt;L&gt;</code> for the custom <code>Either&lt;L, R&gt;</code> type (where <code>L</code> is fixed)</li>
<li><code>TryKind.Witness</code> for the custom <code>Try</code> type</li>
<li><code>CompletableFutureKind.Witness</code> for <code>java.util.concurrent.CompletableFuture</code></li>
<li><code>IOKind.Witness</code> for the custom <code>IO</code> type</li>
<li><code>LazyKind.Witness</code> for the custom <code>Lazy</code> type</li>
<li><code>ReaderKind.Witness&lt;R_ENV&gt;</code> for the custom <code>Reader&lt;R_ENV, A&gt;</code> type</li>
<li><code>StateKind.Witness&lt;S&gt;</code> for the custom <code>State&lt;S, A&gt;</code> type</li>
<li><code>WriterKind.Witness&lt;W&gt;</code> for the custom <code>Writer&lt;W, A&gt;</code> type</li>
<li>For transformers, e.g., <code>EitherTKind.Witness&lt;F_OUTER_WITNESS, L_ERROR&gt;</code></li>
</ul>
</div>
</div>
<div id="admonition-step-2-find-the-type-class-instance" class="admonition admonish-note" role="note" aria-labelledby="admonition-step-2-find-the-type-class-instance-title">
<div class="admonition-title">
<div id="admonition-step-2-find-the-type-class-instance-title">
<p>Step 2: Find the Type Class Instance</p>
</div>
<a class="admonition-anchor-link" href="hkts/usage-guide.html#admonition-step-2-find-the-type-class-instance"></a>
</div>
<div>
<p>Obtain an instance of the required type class (<code>Functor&lt;F_WITNESS&gt;</code>, <code>Applicative&lt;F_WITNESS&gt;</code>, <code>Monad&lt;F_WITNESS&gt;</code>, <code>MonadError&lt;F_WITNESS, E&gt;</code>) for your chosen context's witness type <code>F_WITNESS</code>.</p>
<p>These are concrete classes provided in the corresponding package.</p>
<p>Examples:</p>
<ul>
<li><strong><code>Optional</code></strong>:
<code>OptionalMonad optionalMonad = OptionalMonad.INSTANCE;</code> (This implements <code>MonadError&lt;OptionalKind.Witness, Unit&gt;</code>)</li>
<li><strong><code>List</code></strong>: <code>ListMonad listMonad = ListMonad.INSTANCE;</code> (This implements <code>Monad&lt;ListKind.Witness&gt;</code>)</li>
<li><strong><code>CompletableFuture</code></strong>: <code>CompletableFutureMonad futureMonad = CompletableFutureMonad.INSTANCE;</code> (This implements <code>MonadError&lt;CompletableFutureKind.Witness, Throwable&gt;</code>)</li>
<li><strong><code>Either&lt;String, ?&gt;</code></strong>: <code>EitherMonad&lt;String&gt; eitherMonad =  EitherMonad.instance();</code> (This implements <code>MonadError&lt;EitherKind.Witness&lt;String&gt;, String&gt;</code>)</li>
<li><strong><code>IO</code></strong>: <code>IOMonad ioMonad = IOMonad.INSTANCE;</code> (This implements <code>Monad&lt;IOKind.Witness&gt;</code>)</li>
<li><strong><code>Writer&lt;String, ?&gt;</code></strong>: <code>WriterMonad&lt;String&gt; writerMonad = new WriterMonad&lt;&gt;(new StringMonoid());</code> (This implements <code>Monad&lt;WriterKind.Witness&lt;String&gt;&gt;</code>)</li>
</ul>
</div>
</div>
<div id="admonition-step-3-wrap-your-value-_javatype_---_kind_" class="admonition admonish-note" role="note" aria-labelledby="admonition-step-3-wrap-your-value-_javatype_---_kind_-title">
<div class="admonition-title">
<div id="admonition-step-3-wrap-your-value-_javatype_---_kind_-title">
<p>Step 3: Wrap Your Value (<em>JavaType<A></em> -&gt; <em>Kind&lt;F_WITNESS, A&gt;</em>)</p>
</div>
<a class="admonition-anchor-link" href="hkts/usage-guide.html#admonition-step-3-wrap-your-value-_javatype_---_kind_"></a>
</div>
<div>
<p>Convert your standard Java object (e.g., a <code>List&lt;Integer&gt;</code>, an <code>Optional&lt;String&gt;</code>, an <code>IO&lt;String&gt;</code>) into Higher-Kinded-J's <code>Kind</code> representation using the <code>widen</code> instance method from the corresponding <code>XxxKindHelper</code> enum's singleton instance. You'll typically use a static import for the singleton instance for brevity.</p>
<pre><code class="language-java"> import static org.higherkindedj.hkt.optional.OptionalKindHelper.OPTIONAL; 
 // ...
 Optional&lt;String&gt; myOptional = Optional.of("test");
 // Widen it into the Higher-Kinded-J Kind type
 // F_WITNESS here is OptionalKind.Witness
 Kind&lt;OptionalKind.Witness, String&gt; optionalKind = OPTIONAL.widen(myOptional);
</code></pre>
<ul>
<li>Helper enums provide convenience factory methods that also return <code>Kind</code> instances, e.g., <code>MAYBE.just("value")</code>, <code>TRY.failure(ex)</code>, <code>IO_OP.delay(() -&gt; ...)</code>, <code>LAZY.defer(() -&gt; ...)</code>. Remember to import thes statically from the XxxKindHelper classes.</li>
<li><strong>Note on Widening</strong>:
<ul>
<li>For JDK types (like <code>List</code>, <code>Optional</code>), <code>widen</code> typically creates an internal <code>Holder</code> object that wraps the JDK type and implements the necessary <code>XxxKind</code> interface.</li>
<li>For library-defined types (<code>Id</code>, <code>IO</code>, <code>Maybe</code>, <code>Either</code>, <code>Validated</code>, Transformers like <code>EitherT</code>) that directly implement their <code>XxxKind</code> interface (which in turn extends <code>Kind</code>), the <code>widen</code> method on the helper enum performs a null check and then a direct (and safe) cast to the <code>Kind</code> type. This provides zero runtime overhead‚Äîno wrapper object allocation needed.</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="admonition-step-4-apply-type-class-methods" class="admonition admonish-note" role="note" aria-labelledby="admonition-step-4-apply-type-class-methods-title">
<div class="admonition-title">
<div id="admonition-step-4-apply-type-class-methods-title">
<p>Step 4: Apply Type Class Methods</p>
</div>
<a class="admonition-anchor-link" href="hkts/usage-guide.html#admonition-step-4-apply-type-class-methods"></a>
</div>
<div>
<p>Use the methods defined by the type class interface (<code>map</code>, <code>flatMap</code>, <code>of</code>, <code>ap</code>, <code>raiseError</code>, <code>handleErrorWith</code>, etc.) by calling them on the <strong>type class instance</strong> obtained in <em>Step 2</em>, passing your <code>Kind</code> value(s) as arguments. <strong>Do not call <code>map</code>/<code>flatMap</code> directly on the <code>Kind</code> object itself if it's just the <code>Kind</code> interface.</strong> (Some concrete <code>Kind</code> implementations like <code>Id</code> or <code>Maybe</code> might offer direct methods, but for generic programming, use the type class instance).</p>
<pre><code class="language-java"> import static org.higherkindedj.hkt.optional.OptionalKindHelper.OPTIONAL;
 // ...
 OptionalMonad optionalMonad = OptionalMonad.INSTANCE;
 Kind&lt;OptionalKind.Witness, String&gt; optionalKind = OPTIONAL.widen(Optional.of("test")); // from previous step

 // --- Using map ---
 Function&lt;String, Integer&gt; lengthFunc = String::length;
 // Apply map using the monad instance
 Kind&lt;OptionalKind.Witness, Integer&gt; lengthKind = optionalMonad.map(lengthFunc, optionalKind);
 // lengthKind now represents Kind&lt;OptionalKind.Witness, Integer&gt; containing Optional.of(4)

 // --- Using flatMap ---
 // Function A -&gt; Kind&lt;F_WITNESS, B&gt;
 Function&lt;Integer, Kind&lt;OptionalKind.Witness, String&gt;&gt; checkLength =
     len -&gt; OPTIONAL.widen(len &gt; 3 ? Optional.of("Long enough") : Optional.empty());
 // Apply flatMap using the monad instance
 Kind&lt;OptionalKind.Witness, String&gt; checkedKind = optionalMonad.flatMap(checkLength, lengthKind);
 // checkedKind now represents Kind&lt;OptionalKind.Witness, String&gt; containing Optional.of("Long enough")

 // --- Using MonadError (for Optional, error type is Unit) ---
 Kind&lt;OptionalKind.Witness, String&gt; emptyKind = optionalMonad.raiseError(Unit.INSTANCE); // Represents Optional.empty()
 // Handle the empty case (error state) using handleErrorWith
 Kind&lt;OptionalKind.Witness, String&gt; handledKind = optionalMonad.handleErrorWith(
     emptyKind,
     ignoredError -&gt; OPTIONAL.widen(Optional.of("Default Value")) // Ensure recovery function also returns a Kind
 );

</code></pre>
<p><strong>Note</strong>: For complex chains of monadic operations, consider using <a href="hkts/../functional/for_comprehension.html">For Comprehensions</a> which provide more readable syntax than nested <code>flatMap</code> calls.</p>
</div>
</div>
<div id="admonition-step-5-unwrapnarrow-the-result-_kind---javatype_" class="admonition admonish-note" role="note" aria-labelledby="admonition-step-5-unwrapnarrow-the-result-_kind---javatype_-title">
<div class="admonition-title">
<div id="admonition-step-5-unwrapnarrow-the-result-_kind---javatype_-title">
<p>Step 5: Unwrap/Narrow the Result (<em>Kind&lt;F_WITNESS, A&gt; -&gt; JavaType<A></em>)</p>
</div>
<a class="admonition-anchor-link" href="hkts/usage-guide.html#admonition-step-5-unwrapnarrow-the-result-_kind---javatype_"></a>
</div>
<div>
<p>When you need the underlying Java value back (e.g., to return from a method boundary, perform side effects like printing or running <code>IO</code>), use the <code>narrow</code> instance method from the corresponding <code>XxxKindHelper</code> enum's singleton instance.</p>
<pre><code>```java
import static org.higherkindedj.hkt.optional.OptionalKindHelper.OPTIONAL; 
import static org.higherkindedj.hkt.io.IOKindHelper.IO_OP; 

// ...
// Continuing the Optional example:
 Kind&lt;OptionalKind.Witness, String&gt; checkedKind = /* from previous step */;
 Kind&lt;OptionalKind.Witness, String&gt; handledKind = /* from previous step */;

 Optional&lt;String&gt; finalOptional = OPTIONAL.narrow(checkedKind);
 System.out.println("Final Optional: " + finalOptional); 
 // Output: Optional[Long enough]

 Optional&lt;String&gt; handledOptional = OPTIONAL.narrow(handledKind);
 System.out.println("Handled Optional: " + handledOptional); 
 // Output: Optional[Default Value]

 // Example for IO:
  IOMonad ioMonad = IOMonad.INSTANCE;
  Kind&lt;IOKind.Witness, String&gt; ioKind = IO_OP.delay(() -&gt; "Hello from IO!"); 
  // Use IO_OP.delay
  // unsafeRunSync is an instance method on IOKindHelper.IO_OP
  String ioResult = IO_OP.unsafeRunSync(ioKind);
  System.out.println(ioResult);
```
</code></pre>
</div>
</div>
<hr />
<div id="admonition-handling-_kindunwrapexception_" class="admonition admonish-note" role="note" aria-labelledby="admonition-handling-_kindunwrapexception_-title">
<div class="admonition-title">
<div id="admonition-handling-_kindunwrapexception_-title">
<p>Handling <em>KindUnwrapException</em></p>
</div>
<a class="admonition-anchor-link" href="hkts/usage-guide.html#admonition-handling-_kindunwrapexception_"></a>
</div>
<div>
<p>The <code>narrow</code> instance methods in all <code>KindHelper</code> enums are designed to be robust against <em>structural</em> errors within the HKT simulation layer.</p>
<ul>
<li><strong>When it's thrown</strong>: If you pass <code>null</code> to <code>narrow</code>. For external types using a <code>Holder</code> (like <code>Optional</code> with <code>OptionalHolder</code>), if the <code>Kind</code> instance is not the expected <code>Holder</code> type, an exception is also thrown. For types that directly implement their <code>XxxKind</code> interface, <code>narrow</code> will throw if the <code>Kind</code> is not an instance of that specific concrete type.</li>
<li><strong>What it means</strong>: This exception signals a problem with how you are using Higher-Kinded-J itself ‚Äì usually a programming error in creating or passing <code>Kind</code> objects.</li>
<li><strong>How to handle</strong>: You generally <strong>should not</strong> need to catch <code>KindUnwrapException</code> in typical application logic. Its occurrence points to a bug that needs fixing in the code using Higher-Kinded-J.</li>
</ul>
<pre><code class="language-java">  // import static org.higherkindedj.hkt.optional.OptionalKindHelper.OPTIONAL;
  public void handlingUnwrapExceptions() {
    try {
      // ERROR: Attempting to narrow null
      Optional&lt;String&gt; result = OPTIONAL.narrow(null);
    } catch(KindUnwrapException e) {
      System.err.println("Higher-Kinded-J Usage Error: " + e.getMessage());
      // Example Output (message from OptionalKindHelper.INVALID_KIND_NULL_MSG):
      // Usage Error: Cannot narrow null Kind for Optional
    }
  }
</code></pre>
<p><strong>Important Distinction:</strong></p>
<ul>
<li><strong><code>KindUnwrapException</code></strong>: Signals a problem with the Higher-Kinded-J structure itself (e.g., invalid <code>Kind</code> object passed to <code>narrow</code>). Fix the code using Higher-Kinded-J.</li>
<li><strong>Domain Errors / Absence</strong>: Represented <em>within</em> a valid <code>Kind</code> structure (e.g., <code>Optional.empty()</code> widened to <code>Kind&lt;OptionalKind.Witness, A&gt;</code>, <code>Either.Left</code> widened to <code>Kind&lt;EitherKind.Witness&lt;L&gt;, R&gt;</code>). These should be handled using the monad's specific methods (<code>orElse</code>, <code>fold</code>, <code>handleErrorWith</code>, etc.) or by using the <code>MonadError</code> methods <em>before</em> narrowing back to the final Java type.</li>
</ul>
</div>
</div>
<div id="admonition-example-generic-function" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-generic-function-title">
<div class="admonition-title">
<div id="admonition-example-generic-function-title">
<p>Example: Generic Function</p>
</div>
<a class="admonition-anchor-link" href="hkts/usage-guide.html#admonition-example-generic-function"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/GenericExample.java">GenericExample.java</a></li>
</ul>
<p>Higher-Kinded-J allows writing functions generic over the simulated type constructor (represented by its witness <code>F_WITNESS</code>).</p>
<pre><code class="language-java">// import static org.higherkindedj.hkt.list.ListKindHelper.LIST;
// import static org.higherkindedj.hkt.optional.OptionalKindHelper.OPTIONAL;
// ...

// Generic function: Applies a function within any Functor context F_WITNESS.
// Requires the specific Functor&lt;F_WITNESS&gt; instance to be passed in.
public static &lt;F_WITNESS, A, B&gt; Kind&lt;F_WITNESS, B&gt; mapWithFunctor(
    Functor&lt;F_WITNESS&gt; functorInstance, // Pass the type class instance for F_WITNESS
    Function&lt;A, B&gt; fn,
    Kind&lt;F_WITNESS, A&gt; kindABox) { 

  // Use the map method from the provided Functor instance
  return functorInstance.map(fn, kindABox);
}

public void genericExample() { 
  // Get instances of the type classes for the specific types (F_WITNESS) we want to use
  ListMonad listMonad = new ListMonad(); // Implements Functor&lt;ListKind.Witness&gt;
  OptionalMonad optionalMonad = OptionalMonad.INSTANCE; // Implements Functor&lt;OptionalKind.Witness&gt;

  Function&lt;Integer, Integer&gt; doubleFn = x -&gt; x * 2;

  // --- Use with List ---
  List&lt;Integer&gt; nums = List.of(1, 2, 3);
  // Widen the List. F_WITNESS is ListKind.Witness
  Kind&lt;ListKind.Witness, Integer&gt; listKind = LIST.widen(nums); 
  // Call the generic function, passing the ListMonad instance and the widened List
  Kind&lt;ListKind.Witness, Integer&gt; doubledListKind = mapWithFunctor(listMonad, doubleFn, listKind);
  System.out.println("Doubled List: " + LIST.narrow(doubledListKind)); // Output: [2, 4, 6]

  // --- Use with Optional (Present) ---
  Optional&lt;Integer&gt; optNum = Optional.of(10);
  // Widen the Optional. F_WITNESS is OptionalKind.Witness
  Kind&lt;OptionalKind.Witness, Integer&gt; optKind = OPTIONAL.widen(optNum); 
  // Call the generic function, passing the OptionalMonad instance and the widened Optional
  Kind&lt;OptionalKind.Witness, Integer&gt; doubledOptKind = mapWithFunctor(optionalMonad, doubleFn, optKind);
  System.out.println("Doubled Optional: " + OPTIONAL.narrow(doubledOptKind)); // Output: Optional[20]

  // --- Use with Optional (Empty) ---
  Optional&lt;Integer&gt; emptyOpt = Optional.empty();
  Kind&lt;OptionalKind.Witness, Integer&gt; emptyOptKind = OPTIONAL.widen(emptyOpt); 
  // Call the generic function, map does nothing on empty
  Kind&lt;OptionalKind.Witness, Integer&gt; doubledEmptyOptKind = mapWithFunctor(optionalMonad, doubleFn, emptyOptKind);
  System.out.println("Doubled Empty Optional: " + OPTIONAL.narrow(doubledEmptyOptKind)); // Output: Optional.empty
}

</code></pre>
</div>
</div><div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="higher-kinded-types---basic-usage-examples"><a class="header" href="#higher-kinded-types---basic-usage-examples">Higher-Kinded Types - Basic Usage Examples</a></h1>
<blockquote>
<p>This document provides a brief summary of the example classes found in the <code>org.higherkindedj.example.basic</code> package in the <a href="https://github.com/higher-kinded-j/higher-kinded-j/tree/main/hkj-examples/src/main/java/org/higherkindedj/example/basic">HKJ-Examples</a>.</p>
</blockquote>
<p>These examples showcase how to use various monads and monad transformers to handle common programming tasks like managing optional values, asynchronous operations, and state in a functional way.</p>
<hr />
<h2 id="monads"><a class="header" href="#monads">Monads</a></h2>
<h3 id="eitherexamplejava"><a class="header" href="#eitherexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/either/EitherExample.java">EitherExample.java</a></a></h3>
<p>This example demonstrates the <strong>Either monad</strong>. <code>Either</code> is used to represent a value that can be one of two types, typically a success value (<code>Right</code>) or an error value (<code>Left</code>).</p>
<ul>
<li><strong>Key Concept</strong>: A <code>Either</code> provides a way to handle computations that can fail with a specific error type.</li>
<li><strong>Demonstrates</strong>:
<ul>
<li>Creating <code>Either</code> instances for success (<code>Right</code>) and failure (<code>Left</code>) cases.</li>
<li>Using <code>flatMap</code> to chain operations that return an <code>Either</code>, short-circuiting on failure.</li>
<li>Using <code>fold</code> to handle both the <code>Left</code> and <code>Right</code> cases.</li>
</ul>
</li>
</ul>
<pre><code class="language-java">// Chain operations that can fail
Either&lt;String, Integer&gt; result = input.flatMap(parse).flatMap(checkPositive);

// Fold to handle both outcomes
String message = result.fold(
    leftValue -&gt; "Operation failed with: " + leftValue,
    rightValue -&gt; "Operation succeeded with: " + rightValue
);
</code></pre>
<h3 id="forcomprehensionexamplejava"><a class="header" href="#forcomprehensionexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/expression/ForComprehensionExample.java">ForComprehensionExample.java</a></a></h3>
<p>This example demonstrates how to use the <code>For</code> comprehension, a feature that provides a more readable, sequential syntax for composing monadic operations (equivalent to <code>flatMap</code> chains).</p>
<ul>
<li><strong>Key Concept</strong>: A <code>For</code> comprehension offers syntactic sugar for <code>flatMap</code> and <code>map</code> calls, making complex monadic workflows easier to write and understand.</li>
<li><strong>Demonstrates</strong>:
<ul>
<li>Using <code>For.from()</code> to start and chain monadic operations.</li>
<li>Applying comprehensions to different monads like <code>List</code>, <code>Maybe</code>, and the <code>StateT</code> monad transformer.</li>
<li>Filtering intermediate results with <code>.when()</code>.</li>
<li>Introducing intermediate values with <code>.let()</code>.</li>
<li>Producing a final result with <code>.yield()</code>.</li>
</ul>
</li>
</ul>
<pre><code class="language-java">// A for-comprehension with List
final Kind&lt;ListKind.Witness, String&gt; result =
    For.from(listMonad, list1)
        .from(_ -&gt; list2)
        .when(t -&gt; (t._1() + t._2()) % 2 != 0) // Filter
        .let(t -&gt; "Sum: " + (t._1() + t._2())) // Introduce new value
        .yield((a, b, c) -&gt; a + " + " + b + " = " + c); // Final result
</code></pre>
<h3 id="completablefutureexamplejava"><a class="header" href="#completablefutureexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/future/CompletableFutureExample.java">CompletableFutureExample.java</a></a></h3>
<p>This example covers the <strong>CompletableFuture monad</strong>. It shows how to use <code>CompletableFuture</code> within the Higher-Kinded-J framework to manage asynchronous computations and handle potential errors.</p>
<ul>
<li><strong>Key Concept</strong>: The <code>CompletableFuture</code> monad is used to compose asynchronous operations in a non-blocking way.</li>
<li><strong>Demonstrates</strong>:
<ul>
<li>Creating <code>Kind</code>-wrapped <code>CompletableFuture</code> instances for success and failure.</li>
<li>Using <code>map</code> (which corresponds to <code>thenApply</code>).</li>
<li>Using <code>flatMap</code> (which corresponds to <code>thenCompose</code>) to chain dependent asynchronous steps.</li>
<li>Using <code>handleErrorWith</code> to recover from exceptions that occur within the future.</li>
</ul>
</li>
</ul>
<pre><code class="language-java">// Using handleErrorWith to recover from a failed future
Function&lt;Throwable, Kind&lt;CompletableFutureKind.Witness, String&gt;&gt; recoveryHandler =
    error -&gt; {
      System.out.println("Handling error: " + error.getMessage());
      return futureMonad.of("Recovered from Error");
    };

Kind&lt;CompletableFutureKind.Witness, String&gt; recoveredFuture =
    futureMonad.handleErrorWith(failedFutureKind, recoveryHandler);
</code></pre>
<h3 id="idexamplejava"><a class="header" href="#idexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/id/IdExample.java">IdExample.java</a></a></h3>
<p>This example introduces the <strong>Identity (Id) monad</strong>. The <code>Id</code> monad is the simplest monad; it wraps a value without adding any computational context. It is primarily used to make generic code that works with any monad also work with simple, synchronous values.</p>
<ul>
<li><strong>Key Concept</strong>: The <code>Id</code> monad represents a direct, synchronous computation. It wraps a value, and its <code>flatMap</code> operation simply applies the function to the value.</li>
<li><strong>Demonstrates</strong>:
<ul>
<li>Wrapping a plain value into an <code>Id</code>.</li>
<li>Using <code>map</code> and <code>flatMap</code> on an <code>Id</code> value.</li>
<li>Its use as the underlying monad in a monad transformer stack, effectively turning <code>StateT&lt;S, IdKind.Witness, A&gt;</code> into <code>State&lt;S, A&gt;</code>.</li>
</ul>
</li>
</ul>
<pre><code class="language-java">// flatMap on Id simply applies the function to the wrapped value.
Id&lt;String&gt; idFromOf = Id.of(42);
Id&lt;String&gt; directFlatMap = idFromOf.flatMap(i -&gt; Id.of("Direct FlatMap: " + i));
// directFlatMap.value() is "Direct FlatMap: 42"
</code></pre>
<h3 id="ioexamplejava"><a class="header" href="#ioexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/io/IOExample.java">IOExample.java</a></a></h3>
<p>This example introduces the <strong>IO monad</strong>, which is used to encapsulate side effects like reading from the console, writing to a file, or making a network request.</p>
<ul>
<li><strong>Key Concept</strong>: The <code>IO</code> monad describes a computation that can perform side effects. These effects are only executed when the <code>IO</code> action is explicitly run.</li>
<li><strong>Demonstrates</strong>:
<ul>
<li>Creating <code>IO</code> actions that describe side effects using <code>delay</code>.</li>
<li>Composing <code>IO</code> actions using <code>map</code> and <code>flatMap</code> to create more complex programs.</li>
<li>Executing <code>IO</code> actions to produce a result using <code>unsafeRunSync</code>.</li>
</ul>
</li>
</ul>
<pre><code class="language-java">// Create an IO action to read a line from the console
Kind&lt;IOKind.Witness, String&gt; readLine = IO_OP.delay(() -&gt; {
    System.out.print("Enter your name: ");
    try (Scanner scanner = new Scanner(System.in)) {
        return scanner.nextLine();
    }
});

// Execute the action to get the result
String name = IO_OP.unsafeRunSync(readLine);
</code></pre>
<h3 id="lazyexamplejava"><a class="header" href="#lazyexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/lazy/LazyExample.java">LazyExample.java</a></a></h3>
<p>This example covers the <strong>Lazy monad</strong>. It's used to defer a computation until its result is explicitly requested. The result is then memoized (cached) so the computation is only executed once.</p>
<ul>
<li><strong>Key Concept</strong>: A <code>Lazy</code> computation is not executed when it is created, but only when <code>force()</code> is called. The result (or exception) is then stored for subsequent calls.</li>
<li><strong>Demonstrates</strong>:
<ul>
<li>Creating a deferred computation with <code>LAZY.defer()</code>.</li>
<li>Forcing evaluation with <code>LAZY.force()</code>.</li>
<li>How results are memoized, preventing re-computation.</li>
<li>Using <code>map</code> and <code>flatMap</code> to build chains of lazy operations.</li>
</ul>
</li>
</ul>
<pre><code class="language-java">// Defer a computation
java.util.concurrent.atomic.AtomicInteger counter = new java.util.concurrent.atomic.AtomicInteger(0);
Kind&lt;LazyKind.Witness, String&gt; deferredLazy = LAZY.defer(() -&gt; {
    counter.incrementAndGet();
    return "Computed Value";
});

// The computation only runs when force() is called
System.out.println(LAZY.force(deferredLazy)); // counter becomes 1
System.out.println(LAZY.force(deferredLazy)); // result is from cache, counter remains 1
</code></pre>
<h3 id="listmonadexamplejava"><a class="header" href="#listmonadexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/list/ListMonadExample.java">ListMonadExample.java</a></a></h3>
<p>This example demonstrates the <strong>List monad</strong>. It shows how to perform monadic operations on a standard Java <code>List</code>, treating it as a context that can hold zero or more results.</p>
<ul>
<li><strong>Key Concept</strong>: The <code>List</code> monad represents non-deterministic computation, where an operation can produce multiple results.</li>
<li><strong>Demonstrates</strong>:
<ul>
<li>Wrapping a <code>List</code> into a <code>Kind&lt;ListKind.Witness, A&gt;</code>.</li>
<li>Using <code>map</code> to transform every element in the list.</li>
<li>Using <code>flatMap</code> to apply a function that returns a list to each element, and then flattening the result.</li>
</ul>
</li>
</ul>
<pre><code class="language-java">// A function that returns multiple results for even numbers
Function&lt;Integer, Kind&lt;ListKind.Witness, Integer&gt;&gt; duplicateIfEven =
    n -&gt; {
      if (n % 2 == 0) {
        return LIST.widen(Arrays.asList(n, n * 10));
      } else {
        return LIST.widen(List.of()); // Empty list for odd numbers
      }
    };

// flatMap applies the function and flattens the resulting lists
Kind&lt;ListKind.Witness, Integer&gt; flatMappedKind = listMonad.flatMap(duplicateIfEven, numbersKind);
</code></pre>
<h3 id="maybeexamplejava"><a class="header" href="#maybeexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/maybe/MaybeExample.java">MaybeExample.java</a></a></h3>
<p>This example covers the <strong>Maybe monad</strong>. <code>Maybe</code> is a type that represents an optional value, similar to Java's <code>Optional</code>, but designed to be used as a monad within the Higher-Kinded-J ecosystem. It has two cases: <code>Just&lt;A&gt;</code> (a value is present) and <code>Nothing</code> (a value is absent).</p>
<ul>
<li><strong>Key Concept</strong>: The <code>Maybe</code> monad provides a way to represent computations that may or may not return a value, explicitly handling the absence of a value.</li>
<li><strong>Demonstrates</strong>:
<ul>
<li>Creating <code>Just</code> and <code>Nothing</code> instances.</li>
<li>Using <code>map</code> to transform a <code>Just</code> value.</li>
<li>Using <code>flatMap</code> to chain operations that return a <code>Maybe</code>.</li>
<li>Handling the <code>Nothing</code> case using <code>handleErrorWith</code>.</li>
</ul>
</li>
</ul>
<pre><code class="language-java">// flatMap to parse a string, which can result in Nothing
Function&lt;String, Kind&lt;MaybeKind.Witness, Integer&gt;&gt; parseString =
    s -&gt; {
      try {
        return MAYBE.just(Integer.parseInt(s));
      } catch (NumberFormatException e) {
        return MAYBE.nothing();
      }
    };
</code></pre>
<h3 id="optionalexamplejava"><a class="header" href="#optionalexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/optional/OptionalExample.java">OptionalExample.java</a></a></h3>
<p>This example introduces the <strong>Optional monad</strong>. It demonstrates how to wrap Java's <code>Optional</code> in a <code>Kind</code> to work with it in a monadic way, allowing for chaining of operations and explicit error handling.</p>
<ul>
<li><strong>Key Concept</strong>: The <code>Optional</code> monad provides a way to represent computations that may or may not return a value.</li>
<li><strong>Demonstrates</strong>:
<ul>
<li>Wrapping <code>Optional</code> instances into a <code>Kind&lt;OptionalKind.Witness, A&gt;</code>.</li>
<li>Using <code>map</code> to transform the value inside a present <code>Optional</code>.</li>
<li>Using <code>flatMap</code> to chain operations that return <code>Optional</code>.</li>
<li>Using <code>handleErrorWith</code> to provide a default value when the <code>Optional</code> is empty.</li>
</ul>
</li>
</ul>
<pre><code class="language-java">// Using flatMap to parse a string to an integer, which may fail
Function&lt;String, Kind&lt;OptionalKind.Witness, Integer&gt;&gt; parseToIntKind =
    s -&gt; {
      try {
        return OPTIONAL.widen(Optional.of(Integer.parseInt(s)));
      } catch (NumberFormatException e) {
        return OPTIONAL.widen(Optional.empty());
      }
    };

Kind&lt;OptionalKind.Witness, Integer&gt; parsedPresent =
    optionalMonad.flatMap(parseToIntKind, presentInput);
</code></pre>
<h3 id="readerexamplejava"><a class="header" href="#readerexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/reader/ReaderExample.java">ReaderExample.java</a></a></h3>
<p>This example introduces the <strong>Reader monad</strong>. The <code>Reader</code> monad is a pattern used for dependency injection. It represents a computation that depends on some configuration or environment of type <code>R</code>.</p>
<ul>
<li><strong>Key Concept</strong>: A <code>Reader&lt;R, A&gt;</code> represents a function <code>R -&gt; A</code>. It allows you to "read" from a configuration <code>R</code> to produce a value <code>A</code>, without explicitly passing the configuration object everywhere.</li>
<li><strong>Demonstrates</strong>:
<ul>
<li>Creating <code>Reader</code> computations that access parts of a configuration object.</li>
<li>Using <code>flatMap</code> to chain computations where one step depends on the result of a previous step and the shared configuration.</li>
<li>Running the final <code>Reader</code> computation by providing a concrete configuration object.</li>
</ul>
</li>
</ul>
<pre><code class="language-java">// A Reader that depends on the AppConfig environment
Kind&lt;ReaderKind.Witness&lt;AppConfig&gt;, String&gt; connectionStringReader =
    readerMonad.flatMap(
        dbUrl -&gt; READER.reader(config -&gt; dbUrl + "?apiKey=" + config.apiKey()),
        getDbUrl // Another Reader that gets the DB URL
    );

// The computation is only run when a config is provided
String connectionString = READER.runReader(connectionStringReader, productionConfig);
</code></pre>
<h3 id="stateexample-bankaccountworkflowjava"><a class="header" href="#stateexample-bankaccountworkflowjava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/state/StateExample.java">StateExample</a>, <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/state/BankAccountWorkflow.java">BankAccountWorkflow.java</a></a></h3>
<p>These examples demonstrate the <strong>State monad</strong>. The <code>State</code> monad is used to manage state in a purely functional way, abstracting away the boilerplate of passing state from one function to the next.</p>
<ul>
<li><strong>Key Concept</strong>: A <code>State&lt;S, A&gt;</code> represents a function <code>S -&gt; (S, A)</code>, which takes an initial state and returns a new state and a computed value. The monad chains these functions together.</li>
<li><strong>Demonstrates</strong>:
<ul>
<li>Creating stateful actions like <code>push</code>, <code>pop</code>, <code>deposit</code>, and <code>withdraw</code>.</li>
<li>Using <code>State.modify</code> to update the state and <code>State.inspect</code> to read from it.</li>
<li>Composing these actions into a larger workflow using a <code>For</code> comprehension.</li>
<li>Running the final computation with an initial state to get the final state and result.</li>
</ul>
</li>
</ul>
<pre><code class="language-java">// A stateful action to withdraw money, returning a boolean success flag
public static Function&lt;BigDecimal, Kind&lt;StateKind.Witness&lt;AccountState&gt;, Boolean&gt;&gt; withdraw(String description) {
    return amount -&gt; STATE.widen(
        State.of(currentState -&gt; {
            if (currentState.balance().compareTo(amount) &gt;= 0) {
                // ... update state and return success
                return new StateTuple&lt;&gt;(true, updatedState);
            } else {
                // ... update state with rejection and return failure
                return new StateTuple&lt;&gt;(false, updatedState);
            }
        })
    );
}
</code></pre>
<h3 id="tryexamplejava"><a class="header" href="#tryexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/trymonad/TryExample.java">TryExample.java</a></a></h3>
<p>This example introduces the <strong>Try monad</strong>. It's designed to encapsulate computations that can throw exceptions, making error handling more explicit and functional.</p>
<ul>
<li><strong>Key Concept</strong>: A <code>Try</code> represents a computation that results in either a <code>Success</code> containing a value or a <code>Failure</code> containing an exception.</li>
<li><strong>Demonstrates</strong>:
<ul>
<li>Creating <code>Try</code> instances for successful and failed computations.</li>
<li>Using <code>map</code> and <code>flatMap</code> to chain operations, where exceptions are caught and wrapped in a <code>Failure</code>.</li>
<li>Using <code>recover</code> and <code>recoverWith</code> to handle failures and provide alternative values or computations.</li>
</ul>
</li>
</ul>
<pre><code class="language-java">// A function that returns a Try, succeeding or failing based on the input
Function&lt;Integer, Try&lt;Double&gt;&gt; safeDivide =
    value -&gt;
        (value == 0)
            ? Try.failure(new ArithmeticException("Div by zero"))
            : Try.success(10.0 / value);

// flatMap chains the operation, propagating failure
Try&lt;Double&gt; result = input.flatMap(safeDivide);
</code></pre>
<h3 id="validatedmonadexamplejava"><a class="header" href="#validatedmonadexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/validated/ValidatedMonadExample.java">ValidatedMonadExample.java</a></a></h3>
<p>This example showcases the <strong>Validated applicative functor</strong>. While it has a <code>Monad</code> instance, it's often used as an <code>Applicative</code> to accumulate errors. This example, however, focuses on its monadic (fail-fast) behaviour.</p>
<ul>
<li><strong>Key Concept</strong>: <code>Validated</code> is used for validation scenarios where you want either to get a valid result or to accumulate validation errors.</li>
<li><strong>Demonstrates</strong>:
<ul>
<li>Creating <code>Valid</code> and <code>Invalid</code> instances.</li>
<li>Using <code>flatMap</code> to chain validation steps, where the first <code>Invalid</code> result short-circuits the computation.</li>
<li>Using <code>handleErrorWith</code> to recover from a validation failure.</li>
</ul>
</li>
</ul>
<pre><code class="language-java">// A validation function that returns a Kind-wrapped Validated
Function&lt;String, Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Integer&gt;&gt; parseToIntKind =
    s -&gt; {
      try {
        return validatedMonad.of(Integer.parseInt(s)); // Lifts to Valid
      } catch (NumberFormatException e) {
        return validatedMonad.raiseError(Collections.singletonList("'" + s + "' is not a number."));
      }
    };
</code></pre>
<h3 id="writerexamplejava"><a class="header" href="#writerexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/writer/WriterExample.java">WriterExample.java</a></a></h3>
<p>This example introduces the <strong>Writer monad</strong>. The <code>Writer</code> monad is used for computations that need to produce a log or accumulate a secondary value alongside their primary result.</p>
<ul>
<li><strong>Key Concept</strong>: A <code>Writer&lt;W, A&gt;</code> represents a computation that returns a primary result <code>A</code> and an accumulated value <code>W</code> (like a log), where <code>W</code> must have a <code>Monoid</code> instance to define how values are combined.</li>
<li><strong>Demonstrates</strong>:
<ul>
<li>Using <code>tell</code> to append to the log.</li>
<li>Using <code>flatMap</code> to sequence computations, where both the results and logs are combined automatically.</li>
<li>Running the final <code>Writer</code> to extract both the final value and the fully accumulated log.</li>
</ul>
</li>
</ul>
<pre><code class="language-java">// An action that performs a calculation and logs what it did
Function&lt;Integer, Kind&lt;WriterKind.Witness&lt;String&gt;, Integer&gt;&gt; addAndLog =
    x -&gt; {
      int result = x + 10;
      String logMsg = "Added 10 to " + x + " -&gt; " + result + "; ";
      return WRITER.widen(new Writer&lt;&gt;(logMsg, result));
    };

// The monad combines the logs from each step automatically
Kind&lt;WriterKind.Witness&lt;String&gt;, String&gt; finalComputation = writerMonad.flatMap(
    intermediateValue -&gt; multiplyAndLogToString.apply(intermediateValue),
    addAndLog.apply(5)
);
</code></pre>
<h3 id="genericexamplejava"><a class="header" href="#genericexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/GenericExample.java">GenericExample.java</a></a></h3>
<p>This example showcases how to write <strong>generic functions</strong> that can operate on any <code>Functor</code> (or <code>Monad</code>) by accepting the type class instance as a parameter. This is a core concept of higher-kinded polymorphism.</p>
<ul>
<li><strong>Key Concept</strong>: By abstracting over the computational context (<code>F</code>), you can write code that works for <code>List</code>, <code>Optional</code>, <code>IO</code>, or any other type that has a <code>Functor</code> instance.</li>
<li><strong>Demonstrates</strong>:
<ul>
<li>Writing a generic <code>mapWithFunctor</code> function that takes a <code>Functor&lt;F&gt;</code> instance and a <code>Kind&lt;F, A&gt;</code>.</li>
<li>Calling this generic function with different monad instances (<code>ListMonad</code>, <code>OptionalMonad</code>) and their corresponding <code>Kind</code>-wrapped types.</li>
</ul>
</li>
</ul>
<pre><code class="language-java">// A generic function that works for any Functor F
public static &lt;F, A, B&gt; Kind&lt;F, B&gt; mapWithFunctor(
    Functor&lt;F&gt; functorInstance, // The type class instance
    Function&lt;A, B&gt; fn,
    Kind&lt;F, A&gt; kindBox) { // The value in its context
    return functorInstance.map(fn, kindBox);
}

// Calling it with a List
Kind&lt;ListKind.Witness, Integer&gt; doubledList = mapWithFunctor(listMonad, doubleFn, listKind);

// Calling it with an Optional
Kind&lt;OptionalKind.Witness, Integer&gt; doubledOpt = mapWithFunctor(optionalMonad, doubleFn, optKind);
</code></pre>
<h3 id="profunctorexamplejava"><a class="header" href="#profunctorexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/profunctor/ProfunctorExample.java">ProfunctorExample.java</a></a></h3>
<p>This example demonstrates the <strong>Profunctor</strong> type class using <code>FunctionProfunctor</code>, showing how to build flexible, adaptable data transformation pipelines.</p>
<ul>
<li><strong>Key Concept</strong>: A <code>Profunctor</code> is contravariant in its first parameter and covariant in its second, making it perfect for adapting both the input and output of functions.</li>
<li><strong>Demonstrates</strong>:
<ul>
<li>Using <code>lmap</code> to adapt function inputs (contravariant mapping)</li>
<li>Using <code>rmap</code> to adapt function outputs (covariant mapping)</li>
<li>Using <code>dimap</code> to adapt both input and output simultaneously</li>
<li>Building real-world API adapters and validation pipelines</li>
<li>Creating reusable transformation chains</li>
</ul>
</li>
</ul>
<pre><code class="language-java">// Original function: String length calculator
Function&lt;String, Integer&gt; stringLength = String::length;

// Adapt the input: now works with integers!
Kind2&lt;FunctionKind.Witness, Integer, Integer&gt; intToLength =
    profunctor.lmap(Object::toString, lengthFunction);

// Adapt the output: now returns formatted strings!
Kind2&lt;FunctionKind.Witness, String, String&gt; lengthToString =
    profunctor.rmap(len -&gt; "Length: " + len, lengthFunction);

// Adapt both input and output in one operation
Kind2&lt;FunctionKind.Witness, Integer, String&gt; fullTransform =
    profunctor.dimap(Object::toString, len -&gt; "Result: " + len, lengthFunction);
</code></pre>
<hr />
<h2 id="monad-transformers"><a class="header" href="#monad-transformers">Monad Transformers</a></h2>
<p>These examples show how to use <strong>monad transformers</strong> (<code>EitherT</code>, <code>MaybeT</code>, <code>OptionalT</code>, <code>ReaderT</code>, <code>StateT</code>) to combine the capabilities of different monads.</p>
<h3 id="eithertexamplejava"><a class="header" href="#eithertexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/either_t/EitherTExample.java">EitherTExample.java</a></a></h3>
<ul>
<li><strong>Key Concept</strong>: <code>EitherT</code> stacks the <code>Either</code> monad on top of another monad <code>F</code>, creating a new monad <code>EitherT&lt;F, L, R&gt;</code> that handles both the effects of <code>F</code> and the failure logic of <code>Either</code>.</li>
<li><strong>Scenario</strong>: Composing synchronous validation (<code>Either</code>) with an asynchronous operation (<code>CompletableFuture</code>) in a single, clean workflow.</li>
</ul>
<h3 id="maybetexamplejava"><a class="header" href="#maybetexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/maybe_t/MaybeTExample.java">MaybeTExample.java</a></a></h3>
<ul>
<li><strong>Key Concept</strong>: <code>MaybeT</code> stacks the <code>Maybe</code> monad on top of another monad <code>F</code>. This is useful for asynchronous operations that may not return a value.</li>
<li><strong>Scenario</strong>: Fetching a userLogin and their preferences from a database asynchronously, where each step might not find a result.</li>
</ul>
<h3 id="optionaltexamplejava"><a class="header" href="#optionaltexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/optional_t/OptionalTExample.java">OptionalTExample.java</a></a></h3>
<ul>
<li><strong>Key Concept</strong>: <code>OptionalT</code> stacks <code>Optional</code> on top of another monad <code>F</code>, creating <code>OptionalT&lt;F, A&gt;</code> to handle asynchronous operations that may return an empty result.</li>
<li><strong>Scenario</strong>: Fetching a userLogin and their preferences from a database asynchronously, where each step might not find a result.</li>
</ul>
<h3 id="readertexamplejava-readertunitexamplejava--readertasyncunitexamplejava"><a class="header" href="#readertexamplejava-readertunitexamplejava--readertasyncunitexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/reader_t/ReaderTExample.java">ReaderTExample.java</a>, <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/reader_t/ReaderTAsyncExample.java">ReaderTUnitExample.java</a>,  <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/reader_t/ReaderTAsyncUnitExample.java">ReaderTAsyncUnitExample.java</a></a></h3>
<ul>
<li><strong>Key Concept</strong>: <code>ReaderT</code> combines the <code>Reader</code> monad (for dependency injection) with an outer monad <code>F</code>. This allows for computations that both read from a shared environment and have effects of type <code>F</code>.</li>
<li><strong>Scenario</strong>: An asynchronous workflow that depends on a configuration object (<code>AppConfig</code>) to fetch and process data.</li>
</ul>
<h3 id="statetexamplejava-statetstackexample"><a class="header" href="#statetexamplejava-statetstackexample"><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/state_t/StateTExample.java">StateTExample.java</a>, <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/state_t/StateTStackExample.java">StateTStackExample</a></a></h3>
<ul>
<li><strong>Key Concept</strong>: <code>StateT</code> combines the <code>State</code> monad with an outer monad <code>F</code>. This is for stateful computations that also involve effects from <code>F</code>.</li>
<li><strong>Scenario</strong>: A stateful stack that can fail (using <code>Optional</code> as the outer monad), where popping from an empty stack results in <code>Optional.empty()</code>.</li>
</ul>
<hr />
<p>For more advanced patterns combining State with other monads, see the <a href="hkts/order-walkthrough.html">Order Processing Example</a> which demonstrates <code>StateT</code> with <code>EitherT</code>.</p>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="quick-reference-guide"><a class="header" href="#quick-reference-guide">Quick Reference Guide</a></h1>
<p>This section provides at-a-glance summaries of all type classes in Higher-Kinded-J. Use this as a quick lookup while coding or to compare different type classes.</p>
<h2 id="core-type-classes"><a class="header" href="#core-type-classes">Core Type Classes</a></h2>
<h3 id="functor"><a class="header" href="#functor">Functor</a></h3>
<div id="admonition-functor-quick-reference" class="admonition admonish-tip" role="note" aria-labelledby="admonition-functor-quick-reference-title">
<div class="admonition-title">
<div id="admonition-functor-quick-reference-title">
<p>Functor Quick Reference</p>
</div>
<a class="admonition-anchor-link" href="hkts/quick_reference.html#admonition-functor-quick-reference"></a>
</div>
<div>
<p><strong>Core Method:</strong> <code>map(Function&lt;A,B&gt; f, Kind&lt;F,A&gt; fa) -&gt; Kind&lt;F,B&gt;</code></p>
<p><strong>Purpose:</strong> Transform values inside a context without changing the context structure</p>
<p><strong>Use When:</strong></p>
<ul>
<li>You have a simple transformation function <code>A -&gt; B</code></li>
<li>The context/container should remain unchanged</li>
<li>No dependency between input and output contexts</li>
</ul>
<p><strong>Laws:</strong></p>
<ul>
<li>Identity: <code>map(identity) == identity</code></li>
<li>Composition: <code>map(g ‚àò f) == map(g) ‚àò map(f)</code></li>
</ul>
<p><strong>Common Instances:</strong> List, Optional, Maybe, Either, IO, CompletableFuture</p>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Transform string to length, preserving Optional context
Kind&lt;OptionalKind.Witness, Integer&gt; lengths = 
    optionalFunctor.map(String::length, optionalString);
</code></pre>
<p><strong>Think Of It As:</strong> Applying a function "inside the box" without opening it</p>
</div>
</div>
<h3 id="applicative"><a class="header" href="#applicative">Applicative</a></h3>
<div id="admonition-applicative-quick-reference" class="admonition admonish-tip" role="note" aria-labelledby="admonition-applicative-quick-reference-title">
<div class="admonition-title">
<div id="admonition-applicative-quick-reference-title">
<p>Applicative Quick Reference</p>
</div>
<a class="admonition-anchor-link" href="hkts/quick_reference.html#admonition-applicative-quick-reference"></a>
</div>
<div>
<p><strong>Core Methods:</strong></p>
<ul>
<li><code>of(A value) -&gt; Kind&lt;F,A&gt;</code> (lift pure value)</li>
<li><code>ap(Kind&lt;F,Function&lt;A,B&gt;&gt; ff, Kind&lt;F,A&gt; fa) -&gt; Kind&lt;F,B&gt;</code> (apply wrapped function)</li>
</ul>
<p><strong>Purpose:</strong> Combine independent computations within a context</p>
<p><strong>Use When:</strong></p>
<ul>
<li>You need to combine multiple wrapped values</li>
<li>Operations are independent (don't depend on each other's results)</li>
<li>You want to accumulate errors from multiple validations</li>
</ul>
<p><strong>Key Insight:</strong> <code>map2</code>, <code>map3</code>, etc. are built on <code>ap</code> for combining 2, 3, or more values</p>
<p><strong>Laws:</strong> Identity, Composition, Homomorphism, Interchange</p>
<p><strong>Common Patterns:</strong></p>
<ul>
<li>Form validation (collect all errors)</li>
<li>Combining configuration values</li>
<li>Parallel computations</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Combine two independent validations
Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, User&gt; userLogin = 
    applicative.map2(
        validateUsername(input.username()),
        validatePassword(input.password()),
        User::new
    );
</code></pre>
<p><strong>Think Of It As:</strong> Combining multiple "boxes" when contents are independent</p>
</div>
</div>
<h3 id="monad"><a class="header" href="#monad">Monad</a></h3>
<div id="admonition-monad-quick-reference" class="admonition admonish-tip" role="note" aria-labelledby="admonition-monad-quick-reference-title">
<div class="admonition-title">
<div id="admonition-monad-quick-reference-title">
<p>Monad Quick Reference</p>
</div>
<a class="admonition-anchor-link" href="hkts/quick_reference.html#admonition-monad-quick-reference"></a>
</div>
<div>
<p><strong>Core Method:</strong> <code>flatMap(Function&lt;A,Kind&lt;F,B&gt;&gt; f, Kind&lt;F,A&gt; fa) -&gt; Kind&lt;F,B&gt;</code></p>
<p><strong>Purpose:</strong> Sequence dependent computations within a context</p>
<p><strong>Use When:</strong></p>
<ul>
<li>Each step depends on the result of the previous step</li>
<li>You need to chain operations that return wrapped values</li>
<li>You want short-circuiting behaviour on failure</li>
</ul>
<p><strong>Key Difference from Applicative:</strong> Operations are sequential and dependent</p>
<p><strong>Laws:</strong></p>
<ul>
<li>Left Identity: <code>flatMap(f, of(a)) == f(a)</code></li>
<li>Right Identity: <code>flatMap(of, m) == m</code></li>
<li>Associativity: <code>flatMap(g, flatMap(f, m)) == flatMap(x -&gt; flatMap(g, f(x)), m)</code></li>
</ul>
<p><strong>Utility Methods:</strong></p>
<ul>
<li><code>as(B value, Kind&lt;F,A&gt; fa)</code> - replace value, keep effect</li>
<li><code>peek(Consumer&lt;A&gt; action, Kind&lt;F,A&gt; fa)</code> - side effect without changing value</li>
<li><code>flatMap2/3/4/5(...)</code> - combine multiple monadic values where the combining function itself returns a monadic value (useful for dependent validations or operations)</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Chain database operations where each depends on the previous
Kind&lt;OptionalKind.Witness, Account&gt; account =
    monad.flatMap(userLogin -&gt;
        monad.flatMap(profile -&gt;
            findAccount(profile.accountId()),
            findProfile(userLogin.id())),
        findUser(userId));

// Combine multiple monadic values with effectful result
Kind&lt;OptionalKind.Witness, Order&gt; order =
    monad.flatMap2(
        findUser(userId),
        findProduct(productId),
        (user, product) -&gt; validateAndCreateOrder(user, product) // Returns Optional
    );
</code></pre>
<p><strong>Think Of It As:</strong> Chaining operations where each "opens the box" and "puts result in new box"</p>
</div>
</div>
<h3 id="monaderror"><a class="header" href="#monaderror">MonadError</a></h3>
<div id="admonition-monaderror-quick-reference" class="admonition admonish-tip" role="note" aria-labelledby="admonition-monaderror-quick-reference-title">
<div class="admonition-title">
<div id="admonition-monaderror-quick-reference-title">
<p>MonadError Quick Reference</p>
</div>
<a class="admonition-anchor-link" href="hkts/quick_reference.html#admonition-monaderror-quick-reference"></a>
</div>
<div>
<p><strong>Core Methods:</strong></p>
<ul>
<li><code>raiseError(E error) -&gt; Kind&lt;F,A&gt;</code> (create error state)</li>
<li><code>handleErrorWith(Kind&lt;F,A&gt; fa, Function&lt;E,Kind&lt;F,A&gt;&gt; handler) -&gt; Kind&lt;F,A&gt;</code> (recover from error)</li>
</ul>
<p><strong>Purpose:</strong> Add explicit error handling to monadic computations</p>
<p><strong>Use When:</strong></p>
<ul>
<li>You need to handle specific error types</li>
<li>You want to recover from failures in a workflow</li>
<li>You need to distinguish between different kinds of failures</li>
</ul>
<p><strong>Key Insight:</strong> Error type <code>E</code> is fixed for each MonadError instance</p>
<p><strong>Common Error Types:</strong></p>
<ul>
<li><code>Throwable</code> for CompletableFuture</li>
<li><code>Unit</code> for Optional/Maybe (absence as error)</li>
<li>Custom domain error types for Either/Validated</li>
</ul>
<p><strong>Recovery Methods:</strong></p>
<ul>
<li><code>handleError(fa, Function&lt;E,A&gt; handler)</code> - recover to pure value</li>
<li><code>recover(fa, A defaultValue)</code> - provide default value</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Handle division by zero gracefully
Kind&lt;EitherKind.Witness&lt;String&gt;, Double&gt; result = 
    monadError.handleErrorWith(
        divideOperation,
        error -&gt; monadError.of(0.0) // recover with default
    );
</code></pre>
<p><strong>Think Of It As:</strong> try-catch for functional programming</p>
</div>
</div>
<h3 id="selective"><a class="header" href="#selective">Selective</a></h3>
<div id="admonition-selective-quick-reference" class="admonition admonish-tip" role="note" aria-labelledby="admonition-selective-quick-reference-title">
<div class="admonition-title">
<div id="admonition-selective-quick-reference-title">
<p>Selective Quick Reference</p>
</div>
<a class="admonition-anchor-link" href="hkts/quick_reference.html#admonition-selective-quick-reference"></a>
</div>
<div>
<p><strong>Core Methods:</strong></p>
<ul>
<li><code>select(Kind&lt;F,Choice&lt;A,B&gt;&gt; fab, Kind&lt;F,Function&lt;A,B&gt;&gt; ff) -&gt; Kind&lt;F,B&gt;</code> (conditional function application)</li>
<li><code>whenS(Kind&lt;F,Boolean&gt; cond, Kind&lt;F,Unit&gt; effect) -&gt; Kind&lt;F,Unit&gt;</code> (conditional effect)</li>
<li><code>ifS(Kind&lt;F,Boolean&gt; cond, Kind&lt;F,A&gt; then, Kind&lt;F,A&gt; else) -&gt; Kind&lt;F,A&gt;</code> (if-then-else)</li>
</ul>
<p><strong>Purpose:</strong> Execute effects conditionally with static structure (all branches known upfront)</p>
<p><strong>Use When:</strong></p>
<ul>
<li>You need conditional effects but want static analysis</li>
<li>All possible branches should be visible at construction time (enabling static analysis)</li>
<li>You want more power than Applicative but less than Monad</li>
<li>Building feature flags, conditional logging, or validation with alternatives</li>
</ul>
<p><strong>Key Insight:</strong> Sits between Applicative and Monad - provides conditional effects without full dynamic choice</p>
<p><strong>Common Patterns:</strong></p>
<ul>
<li>Feature flag activation</li>
<li>Debug/production mode switching</li>
<li>Multi-source configuration fallback</li>
<li>Conditional validation</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Only log if debug flag is enabled
Selective&lt;IOKind.Witness&gt; selective = IOSelective.INSTANCE;

Kind&lt;IOKind.Witness, Boolean&gt; debugEnabled =
    IO_KIND.widen(IO.delay(() -&gt; config.isDebug()));
Kind&lt;IOKind.Witness, Unit&gt; logEffect =
    IO_KIND.widen(IO.fromRunnable(() -&gt; log.debug("Debug info")));

Kind&lt;IOKind.Witness, Unit&gt; conditionalLog = selective.whenS(debugEnabled, logEffect);
// Log effect only executes if debugEnabled is true
</code></pre>
<p><strong>Think Of It As:</strong> If-then-else for functional programming with compile-time visible branches</p>
</div>
</div>
<h2 id="data-combination-type-classes"><a class="header" href="#data-combination-type-classes">Data Combination Type Classes</a></h2>
<h3 id="semigroup"><a class="header" href="#semigroup">Semigroup</a></h3>
<div id="admonition-semigroup-quick-reference" class="admonition admonish-tip" role="note" aria-labelledby="admonition-semigroup-quick-reference-title">
<div class="admonition-title">
<div id="admonition-semigroup-quick-reference-title">
<p>Semigroup Quick Reference</p>
</div>
<a class="admonition-anchor-link" href="hkts/quick_reference.html#admonition-semigroup-quick-reference"></a>
</div>
<div>
<p><strong>Core Method:</strong> <code>combine(A a1, A a2) -&gt; A</code></p>
<p><strong>Purpose:</strong> Types that can be combined associatively</p>
<p><strong>Key Property:</strong> Associativity - <code>combine(a, combine(b, c)) == combine(combine(a, b), c)</code></p>
<p><strong>Use When:</strong></p>
<ul>
<li>You need to combine/merge two values of the same type</li>
<li>Order of combination doesn't matter (due to associativity)</li>
<li>Building blocks for parallel processing</li>
</ul>
<p><strong>Common Instances:</strong></p>
<ul>
<li>String concatenation: <code>"a" + "b" + "c"</code></li>
<li>Integer addition: <code>1 + 2 + 3</code></li>
<li>List concatenation: <code>[1,2] + [3,4] + [5,6]</code></li>
<li>Set union: <code>{1,2} ‚à™ {2,3} ‚à™ {3,4}</code></li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Combine error messages
Semigroup&lt;String&gt; stringConcat = Semigroups.string("; ");
String combined = stringConcat.combine("Error 1", "Error 2");
// Result: "Error 1; Error 2"
</code></pre>
<p><strong>Think Of It As:</strong> The <code>+</code> operator generalised to any type</p>
</div>
</div>
<h3 id="monoid"><a class="header" href="#monoid">Monoid</a></h3>
<div id="admonition-monoid-quick-reference" class="admonition admonish-tip" role="note" aria-labelledby="admonition-monoid-quick-reference-title">
<div class="admonition-title">
<div id="admonition-monoid-quick-reference-title">
<p>Monoid Quick Reference</p>
</div>
<a class="admonition-anchor-link" href="hkts/quick_reference.html#admonition-monoid-quick-reference"></a>
</div>
<div>
<p><strong>Core Methods:</strong></p>
<ul>
<li><code>combine(A a1, A a2) -&gt; A</code> (from Semigroup)</li>
<li><code>empty() -&gt; A</code> (identity element)</li>
</ul>
<p><strong>Purpose:</strong> Semigroups with an identity/neutral element</p>
<p><strong>Key Properties:</strong></p>
<ul>
<li>Associativity (from Semigroup)</li>
<li>Identity: <code>combine(a, empty()) == combine(empty(), a) == a</code></li>
</ul>
<p><strong>Use When:</strong></p>
<ul>
<li>You need a starting value for reductions/folds</li>
<li>Implementing fold operations over data structures</li>
<li>You might be combining zero elements</li>
</ul>
<p><strong>Common Instances:</strong></p>
<ul>
<li>String: empty = <code>""</code>, combine = concatenation</li>
<li>Integer addition: empty = <code>0</code>, combine = <code>+</code></li>
<li>Integer multiplication: empty = <code>1</code>, combine = <code>*</code></li>
<li>List: empty = <code>[]</code>, combine = concatenation</li>
<li>Boolean AND: empty = <code>true</code>, combine = <code>&amp;&amp;</code></li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Sum a list using integer addition monoid
Integer sum = listFoldable.foldMap(
    Monoids.integerAddition(),
    Function.identity(),
    numbersList
);
</code></pre>
<p><strong>Think Of It As:</strong> Semigroup + a "starting point" for combinations</p>
</div>
</div>
<h2 id="structure-iterating-type-classes"><a class="header" href="#structure-iterating-type-classes">Structure-Iterating Type Classes</a></h2>
<h3 id="foldable"><a class="header" href="#foldable">Foldable</a></h3>
<div id="admonition-foldable-quick-reference" class="admonition admonish-tip" role="note" aria-labelledby="admonition-foldable-quick-reference-title">
<div class="admonition-title">
<div id="admonition-foldable-quick-reference-title">
<p>Foldable Quick Reference</p>
</div>
<a class="admonition-anchor-link" href="hkts/quick_reference.html#admonition-foldable-quick-reference"></a>
</div>
<div>
<p><strong>Core Method:</strong> <code>foldMap(Monoid&lt;M&gt; monoid, Function&lt;A,M&gt; f, Kind&lt;F,A&gt; fa) -&gt; M</code></p>
<p><strong>Purpose:</strong> Reduce a data structure to a single summary value</p>
<p><strong>Use When:</strong></p>
<ul>
<li>You want to aggregate/summarise data in a structure</li>
<li>You need different types of reductions (sum, concat, any/all, etc.)</li>
<li>You want to count, find totals, or collapse collections</li>
</ul>
<p><strong>Key Insight:</strong> Different Monoids give different aggregations from same data</p>
<p><strong>Common Operations:</strong></p>
<ul>
<li>Sum numbers: use integer addition monoid</li>
<li>Concatenate strings: use string monoid</li>
<li>Check all conditions: use boolean AND monoid</li>
<li>Count elements: map to 1, use integer addition monoid</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Multiple aggregations of the same list
List&lt;Integer&gt; numbers = List.of(1, 2, 3, 4, 5);

// Sum
Integer sum = foldable.foldMap(Monoids.integerAddition(), 
    Function.identity(), numbers); // 15

// Concatenate as strings  
String concat = foldable.foldMap(Monoids.string(), 
    String::valueOf, numbers); // "12345"

// Check all positive
Boolean allPositive = foldable.foldMap(Monoids.booleanAnd(), 
    n -&gt; n &gt; 0, numbers); // true
</code></pre>
<p><strong>Think Of It As:</strong> Swiss Army knife for data aggregation</p>
</div>
</div>
<h3 id="traverse"><a class="header" href="#traverse">Traverse</a></h3>
<div id="admonition-traverse-quick-reference" class="admonition admonish-tip" role="note" aria-labelledby="admonition-traverse-quick-reference-title">
<div class="admonition-title">
<div id="admonition-traverse-quick-reference-title">
<p>Traverse Quick Reference</p>
</div>
<a class="admonition-anchor-link" href="hkts/quick_reference.html#admonition-traverse-quick-reference"></a>
</div>
<div>
<p><strong>Core Method:</strong> <code>traverse(Applicative&lt;G&gt; app, Function&lt;A,Kind&lt;G,B&gt;&gt; f, Kind&lt;F,A&gt; fa) -&gt; Kind&lt;G,Kind&lt;F,B&gt;&gt;</code></p>
<p><strong>Purpose:</strong> Apply an effectful function to each element and "flip" the contexts</p>
<p><strong>Use When:</strong></p>
<ul>
<li>You have a collection and want to apply an effect to each element</li>
<li>You want to validate every item and collect all errors</li>
<li>You need to "turn inside-out": <code>F&lt;G&lt;A&gt;&gt;</code> becomes <code>G&lt;F&lt;A&gt;&gt;</code></li>
</ul>
<p><strong>Key Operations:</strong></p>
<ul>
<li><code>traverse</code>: apply function then flip</li>
<li><code>sequence</code>: just flip contexts (when you already have <code>F&lt;G&lt;A&gt;&gt;</code>)</li>
</ul>
<p><strong>Common Patterns:</strong></p>
<ul>
<li>Validate every item in a list</li>
<li>Make async calls for each element</li>
<li>Parse/process each item, collecting all failures</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Validate every string in a list, collect all errors
List&lt;String&gt; inputs = List.of("123", "abc", "456");

Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Kind&lt;ListKind.Witness, Integer&gt;&gt; result =
    listTraverse.traverse(
        validatedApplicative,
        this::parseInteger, // String -&gt; Validated&lt;List&lt;String&gt;, Integer&gt;
        LIST.widen(inputs)
    );

// Result: either Valid(List[123, 456]) or Invalid(["abc is not a number"])
</code></pre>
<p><strong>Think Of It As:</strong> Applying effects to collections while flipping the "nesting order"</p>
</div>
</div>
<h2 id="dual-parameter-type-classes"><a class="header" href="#dual-parameter-type-classes">Dual-Parameter Type Classes</a></h2>
<h3 id="profunctor"><a class="header" href="#profunctor">Profunctor</a></h3>
<div id="admonition-profunctor-quick-reference" class="admonition admonish-tip" role="note" aria-labelledby="admonition-profunctor-quick-reference-title">
<div class="admonition-title">
<div id="admonition-profunctor-quick-reference-title">
<p>Profunctor Quick Reference</p>
</div>
<a class="admonition-anchor-link" href="hkts/quick_reference.html#admonition-profunctor-quick-reference"></a>
</div>
<div>
<p><strong>Core Methods:</strong></p>
<ul>
<li><code>lmap(Function&lt;C,A&gt; f, Kind2&lt;P,A,B&gt; pab) -&gt; Kind2&lt;P,C,B&gt;</code> (contravariant on input)</li>
<li><code>rmap(Function&lt;B,D&gt; g, Kind2&lt;P,A,B&gt; pab) -&gt; Kind2&lt;P,A,D&gt;</code> (covariant on output)</li>
<li><code>dimap(Function&lt;C,A&gt; f, Function&lt;B,D&gt; g, Kind2&lt;P,A,B&gt; pab) -&gt; Kind2&lt;P,C,D&gt;</code> (both)</li>
</ul>
<p><strong>Purpose:</strong> Adapt inputs and outputs of two-parameter types (especially functions)</p>
<p><strong>Use When:</strong></p>
<ul>
<li>Building flexible data transformation pipelines</li>
<li>Creating API adapters that convert between different formats</li>
<li>You need to preprocess inputs or postprocess outputs</li>
<li>Building reusable validation or transformation logic</li>
</ul>
<p><strong>Key Insight:</strong></p>
<ul>
<li><code>lmap</code> = preprocess the input (contravariant)</li>
<li><code>rmap</code> = postprocess the output (covariant)</li>
<li><code>dimap</code> = do both transformations</li>
</ul>
<p><strong>Common Instance:</strong> <code>Function&lt;A,B&gt;</code> is the canonical Profunctor</p>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Adapt a string length function to work with integers and return formatted strings
Function&lt;String, Integer&gt; stringLength = String::length;

// Input adaptation: Integer -&gt; String  
Kind2&lt;FunctionKind.Witness, Integer, Integer&gt; intToLength = 
    profunctor.lmap(Object::toString, FUNCTION.widen(stringLength));

// Output adaptation: Integer -&gt; String
Kind2&lt;FunctionKind.Witness, String, String&gt; lengthToString = 
    profunctor.rmap(len -&gt; "Length: " + len, FUNCTION.widen(stringLength));

// Both adaptations
Kind2&lt;FunctionKind.Witness, Integer, String&gt; fullAdaptation = 
    profunctor.dimap(Object::toString, len -&gt; "Result: " + len, 
        FUNCTION.widen(stringLength));
</code></pre>
<p><strong>Think Of It As:</strong> The adapter pattern for functional programming</p>
</div>
</div>
<h2 id="decision-guide"><a class="header" href="#decision-guide">Decision Guide</a></h2>
<div id="admonition-choosing-the-right-type-class" class="admonition admonish-warning" role="note" aria-labelledby="admonition-choosing-the-right-type-class-title">
<div class="admonition-title">
<div id="admonition-choosing-the-right-type-class-title">
<p>Choosing the Right Type Class</p>
</div>
<a class="admonition-anchor-link" href="hkts/quick_reference.html#admonition-choosing-the-right-type-class"></a>
</div>
<div>
<p><strong>Start Simple, Go Complex:</strong></p>
<ol>
<li><strong>Functor</strong> - Simple transformations, context unchanged</li>
<li><strong>Applicative</strong> - Combine independent computations</li>
<li><strong>Selective</strong> OR <strong>Monad</strong> - Choose based on needs:
<ul>
<li><strong>Selective</strong>: Conditional effects with all branches visible upfront (static analysis)</li>
<li><strong>Monad</strong>: Chain dependent computations with dynamic choice</li>
</ul>
</li>
<li><strong>MonadError</strong> - Add error handling to Monad</li>
<li><strong>Traverse</strong> - Apply effects to collections</li>
<li><strong>Profunctor</strong> - Adapt inputs/outputs of functions</li>
</ol>
<p><strong>Decision Tree:</strong></p>
<ul>
<li>Need to transform values? ‚Üí <strong>Functor</strong></li>
<li>Need to combine independent operations? ‚Üí <strong>Applicative</strong></li>
<li>Need conditional effects with static structure? ‚Üí <strong>Selective</strong></li>
<li>Need sequential dependent operations? ‚Üí <strong>Monad</strong> (chain dependent computations with dynamic choices based on previous results)</li>
<li>Need error recovery? ‚Üí <strong>MonadError</strong></li>
<li>Need to process collections with effects? ‚Üí <strong>Traverse</strong></li>
<li>Need to adapt function interfaces? ‚Üí <strong>Profunctor</strong></li>
<li>Need to aggregate/summarise data? ‚Üí <strong>Foldable</strong></li>
<li>Need to combine values? ‚Üí <strong>Semigroup/Monoid</strong></li>
</ul>
<p><strong>Common Patterns:</strong></p>
<ul>
<li><strong>Form validation:</strong> Applicative (independent fields) or Traverse (list of fields)</li>
<li><strong>Database operations:</strong> Monad (dependent queries) + MonadError (failure handling)</li>
<li><strong>API integration:</strong> Profunctor (adapt formats) + Monad (chain calls)</li>
<li><strong>Configuration:</strong> Applicative (combine settings) + Reader (dependency injection)</li>
<li><strong>Conditional effects:</strong> Selective (feature flags, debug mode) or Monad (dynamic choice)</li>
<li><strong>Configuration fallback:</strong> Selective (try multiple sources with static branches)</li>
<li><strong>Logging:</strong> Writer (accumulate logs) + Monad (sequence operations)</li>
<li><strong>State management:</strong> State/StateT (thread state) + Monad (sequence updates)</li>
</ul>
</div>
</div>
<h2 id="type-hierarchy"><a class="header" href="#type-hierarchy">Type Hierarchy</a></h2>
<div id="admonition-type-class-relationships" class="admonition admonish-info" role="note" aria-labelledby="admonition-type-class-relationships-title">
<div class="admonition-title">
<div id="admonition-type-class-relationships-title">
<p>Type Class Relationships</p>
</div>
<a class="admonition-anchor-link" href="hkts/quick_reference.html#admonition-type-class-relationships"></a>
</div>
<div>
<pre><code>        Functor
            ‚Üë
    Applicative ‚Üê Apply
       ‚Üó    ‚Üñ
Selective   Monad
               ‚Üë
          MonadError

Semigroup
    ‚Üë
  Monoid

Functor + Foldable
    ‚Üë
 Traverse

(Two-parameter types)
Profunctor
Bifunctor
</code></pre>
<p><strong>Inheritance Meaning:</strong></p>
<ul>
<li>Every <strong>Applicative</strong> is also a <strong>Functor</strong></li>
<li>Every <strong>Selective</strong> is also an <strong>Applicative</strong> (and therefore a <strong>Functor</strong>)</li>
<li>Every <strong>Monad</strong> is also an <strong>Applicative</strong> (and therefore a <strong>Functor</strong>)</li>
<li>Every <strong>MonadError</strong> is also a <strong>Monad</strong> (and therefore <strong>Applicative</strong> and <strong>Functor</strong>)</li>
<li><strong>Selective</strong> and <strong>Monad</strong> are siblings - both extend <strong>Applicative</strong> directly</li>
<li>Every <strong>Monoid</strong> is also a <strong>Semigroup</strong></li>
<li>Every <strong>Traverse</strong> provides both <strong>Functor</strong> and <strong>Foldable</strong> capabilities</li>
</ul>
<p><strong>Practical Implication:</strong> If you have a <code>Monad&lt;F&gt;</code> instance, you can also use it as an <code>Applicative&lt;F&gt;</code> or <code>Functor&lt;F&gt;</code>. Selective and Monad are alternative extensions of Applicative with different trade-offs.</p>
</div>
</div>
<h2 id="common-monoid-instances"><a class="header" href="#common-monoid-instances">Common Monoid Instances</a></h2>
<div id="admonition-ready-to-use-monoids" class="admonition admonish-note" role="note" aria-labelledby="admonition-ready-to-use-monoids-title">
<div class="admonition-title">
<div id="admonition-ready-to-use-monoids-title">
<p>Ready-to-Use Monoids</p>
</div>
<a class="admonition-anchor-link" href="hkts/quick_reference.html#admonition-ready-to-use-monoids"></a>
</div>
<div>
<p><strong>Numeric:</strong></p>
<ul>
<li><code>Monoids.integerAddition()</code> - sum integers (empty = 0)</li>
<li><code>Monoids.integerMultiplication()</code> - multiply integers (empty = 1)</li>
</ul>
<p><strong>Text:</strong></p>
<ul>
<li><code>Monoids.string()</code> - concatenate strings (empty = "")</li>
<li><code>Monoids.string(delimiter)</code> - join with delimiter</li>
</ul>
<p><strong>Boolean:</strong></p>
<ul>
<li><code>Monoids.booleanAnd()</code> - logical AND (empty = true)</li>
<li><code>Monoids.booleanOr()</code> - logical OR (empty = false)</li>
</ul>
<p><strong>Collections:</strong></p>
<ul>
<li><code>Monoids.list()</code> - concatenate lists (empty = [])</li>
</ul>
<p><strong>Custom:</strong></p>
<pre><code class="language-java">// Create your own monoid
Monoid&lt;MyType&gt; myMonoid = new Monoid&lt;MyType&gt;() {
    public MyType empty() { return MyType.defaultValue(); }
    public MyType combine(MyType a, MyType b) { return a.mergeWith(b); }
};
</code></pre>
</div>
</div>
<h2 id="performance-notes"><a class="header" href="#performance-notes">Performance Notes</a></h2>
<div id="admonition-performance-considerations" class="admonition admonish-warning" role="note" aria-labelledby="admonition-performance-considerations-title">
<div class="admonition-title">
<div id="admonition-performance-considerations-title">
<p>Performance Considerations</p>
</div>
<a class="admonition-anchor-link" href="hkts/quick_reference.html#admonition-performance-considerations"></a>
</div>
<div>
<p><strong>When to Use HKT vs Direct Methods:</strong></p>
<p><strong>Use HKT When:</strong></p>
<ul>
<li>Writing generic code that works with multiple container types</li>
<li>Building complex workflows with multiple type classes</li>
<li>You need the power of type class composition</li>
</ul>
<p><strong>Use Direct Methods When:</strong></p>
<ul>
<li>Simple, one-off transformations</li>
<li>Performance-critical hot paths</li>
<li>Working with a single, known container type</li>
</ul>
<p><strong>Examples:</strong></p>
<pre><code class="language-java">// Hot path - use direct method
Optional&lt;String&gt; result = optional.map(String::toUpperCase);

// Generic reusable code - use HKT
public static &lt;F&gt; Kind&lt;F, String&gt; normalise(Functor&lt;F&gt; functor, Kind&lt;F, String&gt; input) {
    return functor.map(String::toUpperCase, input);
}
</code></pre>
<p><strong>Memory:</strong> HKT simulation adds minimal overhead (single wrapper object per operation)
<strong>CPU:</strong> Direct method calls vs type class method calls are comparable in modern JVMs</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="extending-higher-kinded-type-simulation"><a class="header" href="#extending-higher-kinded-type-simulation">Extending Higher Kinded Type Simulation</a></h1>
<p><img src="hkts/../images/extending-crane.png" alt="extending-crane.png" /></p>
<p>You can add support for new Java types (type constructors) to the Higher-Kinded-J simulation framework, allowing them to be used with type classes like <code>Functor</code>, <code>Monad</code>, etc.</p>
<p>There are two main scenarios:</p>
<ol>
<li><strong>Adapting External Types</strong>: For types you don't own (e.g., JDK classes like <code>java.util.Set</code>, <code>java.util.Map</code>, or classes from other libraries).</li>
<li><strong>Integrating Custom Library Types</strong>: For types defined within your own project or a library you control, where you can modify the type itself.</li>
</ol>
<blockquote>
<p><strong>Note:</strong> Within Higher-Kinded-J, core library types like <code>IO</code>, <code>Maybe</code>, and <code>Either</code> follow Scenario 2‚Äîthey directly implement their respective Kind interfaces (<code>IOKind</code>, <code>MaybeKind</code>, <code>EitherKind</code>). This provides zero runtime overhead for widen/narrow operations.</p>
</blockquote>
<p>The core pattern involves creating:</p>
<ul>
<li>An <code>XxxKind</code> interface with a nested <code>Witness</code> type (this remains the same).</li>
<li>An <code>XxxConverterOps</code> interface defining the <code>widen</code> and <code>narrow</code> operations for the specific type.</li>
<li>An <code>XxxKindHelper</code> <strong>enum</strong> that implements <code>XxxConverterOps</code> and provides a singleton instance (e.g., <code>SET</code>, <code>MY_TYPE</code>) for accessing these operations as instance methods.</li>
<li>Type class instances (e.g., for <code>Functor</code>, <code>Monad</code>).</li>
</ul>
<p>For external types, an additional <code>XxxHolder</code> record is typically used internally by the helper enum to wrap the external type.</p>
<h2 id="scenario-1-adapting-an-external-type-eg-javautilseta"><a class="header" href="#scenario-1-adapting-an-external-type-eg-javautilseta">Scenario 1: Adapting an External Type (e.g., <code>java.util.Set&lt;A&gt;</code>)</a></h2>
<p>Since we cannot modify <code>java.util.Set</code> to directly implement our <code>Kind</code> structure, we need a wrapper (a <code>Holder</code>).</p>
<p><strong>Goal:</strong> Simulate <code>java.util.Set&lt;A&gt;</code> as <code>Kind&lt;SetKind.Witness, A&gt;</code> and provide <code>Functor</code>, <code>Applicative</code>, and <code>Monad</code> instances for it.</p>
<p><strong>Note:</strong> This pattern is useful when integrating third-party libraries or JDK types that you cannot modify directly.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="hkts/extending-simulation.html#admonition-note"></a>
</div>
<div>
<ol>
<li>
<p><strong>Create the <code>Kind</code> Interface with Witness (<code>SetKind.java</code>)</strong>:</p>
<ul>
<li>Define a marker interface that extends <code>Kind&lt;SetKind.Witness, A&gt;</code>.</li>
<li>Inside this interface, define a <code>static final class Witness {}</code> which will serve as the phantom type <code>F</code> for <code>Set</code>.</li>
</ul>
<pre><code class="language-java">package org.higherkindedj.hkt.set; // Example package

import org.higherkindedj.hkt.Kind;
import org.jspecify.annotations.NullMarked;

/**
 * Kind interface marker for java.util.Set&lt;A&gt;.
 * The Witness type F = SetKind.Witness
 * The Value type A = A
 */
@NullMarked
public interface SetKind&lt;A&gt; extends Kind&lt;SetKind.Witness, A&gt; {
  /**
   * Witness type for {@link java.util.Set} to be used with {@link Kind}.
   */
  final class Witness {
    private Witness() {} 
  }
}
</code></pre>
</li>
<li>
<p><strong>Create the <code>ConverterOps</code> Interface (<code>SetConverterOps.java</code>)</strong>:</p>
<ul>
<li>Define an interface specifying the <code>widen</code> and <code>narrow</code> methods for <code>Set</code>.</li>
</ul>
<pre><code class="language-java">package org.higherkindedj.hkt.set;

import java.util.Set;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.exception.KindUnwrapException; // If narrow throws it
import org.jspecify.annotations.NonNull;
import org.jspecify.annotations.Nullable;

public interface SetConverterOps {
  &lt;A&gt; @NonNull Kind&lt;SetKind.Witness, A&gt; widen(@NonNull Set&lt;A&gt; set);
  &lt;A&gt; @NonNull Set&lt;A&gt; narrow(@Nullable Kind&lt;SetKind.Witness, A&gt; kind) throws KindUnwrapException;
}
</code></pre>
</li>
<li>
<p><strong>Create the <code>KindHelper</code> Enum with an Internal <code>Holder</code> (<code>SetKindHelper.java</code>)</strong>:</p>
<ul>
<li>Define an <code>enum</code> (e.g., <code>SetKindHelper</code>) that implements <code>SetConverterOps</code>.</li>
<li>Provide a singleton instance (e.g., <code>SET</code>).</li>
<li>Inside this helper, define a package-private <code>record SetHolder&lt;A&gt;(@NonNull Set&lt;A&gt; set) implements SetKind&lt;A&gt; {}</code>. This record wraps the actual <code>java.util.Set</code>.</li>
<li><strong><code>widen</code> method</strong>: Takes the Java type (e.g., <code>Set&lt;A&gt;</code>), performs null checks, and returns a new <code>SetHolder&lt;&gt;(set)</code> cast to <code>Kind&lt;SetKind.Witness, A&gt;</code>.</li>
<li><strong><code>narrow</code> method</strong>: Takes <code>Kind&lt;SetKind.Witness, A&gt; kind</code>, performs null checks, verifies <code>kind instanceof SetHolder</code>, extracts the underlying <code>Set&lt;A&gt;</code>, and returns it. It throws <code>KindUnwrapException</code> for any structural invalidity.</li>
</ul>
<pre><code class="language-java">package org.higherkindedj.hkt.set;

import java.util.Objects;
import java.util.Set;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.exception.KindUnwrapException;
import org.jspecify.annotations.NonNull;
import org.jspecify.annotations.Nullable;

public enum SetKindHelper implements SetConverterOps {
    SET; // Singleton instance

    // Error messages can be static final within the enum
    private static final String ERR_INVALID_KIND_NULL = "Cannot narrow null Kind for Set";
    private static final String ERR_INVALID_KIND_TYPE = "Kind instance is not a SetHolder: ";
    private static final String ERR_INVALID_KIND_TYPE_NULL = "Input Set cannot be null for widen";
  
    // Holder Record (package-private for testability if needed)
    record SetHolder&lt;AVal&gt;(@NonNull Set&lt;AVal&gt; set) implements SetKind&lt;AVal&gt; { }

    @Override
    public &lt;A&gt; @NonNull Kind&lt;SetKind.Witness, A&gt; widen(@NonNull Set&lt;A&gt; set) {
        Objects.requireNonNull(set, ERR_INVALID_KIND_TYPE_NULL);
        return  new SetHolder&lt;&gt;(set);
    }

    @Override
    public &lt;A&gt; @NonNull Set&lt;A&gt; narrow(@Nullable Kind&lt;SetKind.Witness, A&gt; kind) {
        if (kind == null) {
            throw new KindUnwrapException(ERR_INVALID_KIND_NULL);
        }
        if (kind instanceof SetHolder&lt;?&gt; holder) { 
            // SetHolder's 'set' component is @NonNull, so holder.set() is guaranteed non-null.
            return (Set&lt;A&gt;) holder.set();
        } else {
            throw new KindUnwrapException(ERR_INVALID_KIND_TYPE + kind.getClass().getName());
        }
    }
}
</code></pre>
</li>
</ol>
</div>
</div>
<h2 id="scenario-2-integrating-a-custom-library-type"><a class="header" href="#scenario-2-integrating-a-custom-library-type">Scenario 2: Integrating a Custom Library Type</a></h2>
<p>If you are defining a new type <em>within your library</em> (e.g., a custom <code>MyType&lt;A&gt;</code>), you can design it to directly participate in the HKT simulation. This approach typically doesn't require an explicit <code>Holder</code> record if your type can directly implement the <code>XxxKind</code> interface.</p>
<blockquote>
<p><strong>Examples in Higher-Kinded-J:</strong> <code>IO&lt;A&gt;</code>, <code>Maybe&lt;A&gt;</code> (via <code>Just&lt;T&gt;</code> and <code>Nothing&lt;T&gt;</code>), <code>Either&lt;L,R&gt;</code> (via <code>Left</code> and <code>Right</code>), <code>Validated&lt;E,A&gt;</code>, <code>Id&lt;A&gt;</code>, and monad transformers all use this pattern. Their widen/narrow operations are simple type-safe casts with no wrapper object allocation.</p>
</blockquote>
<div id="admonition-note-1" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-1-title">
<div class="admonition-title">
<div id="admonition-note-1-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="hkts/extending-simulation.html#admonition-note-1"></a>
</div>
<div>
<ol>
<li>
<p><strong>Define Your Type and its <code>Kind</code> Interface</strong>:</p>
<ul>
<li>Your custom type (e.g., <code>MyType&lt;A&gt;</code>) directly implements its corresponding <code>MyTypeKind&lt;A&gt;</code> interface.</li>
<li><code>MyTypeKind&lt;A&gt;</code> extends <code>Kind&lt;MyType.Witness, A&gt;</code> and defines the nested <code>Witness</code> class. (This part remains unchanged).</li>
</ul>
<pre><code class="language-java">package org.example.mytype;

import org.higherkindedj.hkt.Kind;
import org.jspecify.annotations.NullMarked;

// 1. The Kind Interface with Witness
@NullMarked
public interface MyTypeKind&lt;A&gt; extends Kind&lt;MyType.Witness, A&gt; {
  /** Witness type for MyType. */
  final class Witness { private Witness() {} }
}

// 2. Your Custom Type directly implements its Kind interface
public record MyType&lt;A&gt;(A value) implements MyTypeKind&lt;A&gt; {
    // ... constructors, methods for MyType ...
}
</code></pre>
</li>
<li>
<p><strong>Create the <code>ConverterOps</code> Interface (<code>MyTypeConverterOps.java</code>)</strong>:</p>
<ul>
<li>Define an interface specifying the <code>widen</code> and <code>narrow</code> methods for <code>MyType</code>.</li>
</ul>
<pre><code class="language-java">package org.example.mytype;

import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.exception.KindUnwrapException;
import org.jspecify.annotations.NonNull;
import org.jspecify.annotations.Nullable;

public interface MyTypeConverterOps {
    &lt;A&gt; @NonNull Kind&lt;MyType.Witness, A&gt; widen(@NonNull MyType&lt;A&gt; myTypeValue);
    &lt;A&gt; @NonNull MyType&lt;A&gt; narrow(@Nullable Kind&lt;MyType.Witness, A&gt; kind) throws KindUnwrapException;
}
</code></pre>
</li>
<li>
<p><strong>Create the <code>KindHelper</code> Enum (<code>MyTypeKindHelper.java</code>)</strong>:</p>
<ul>
<li>Define an <code>enum</code> (e.g., <code>MyTypeKindHelper</code>) that implements <code>MyTypeConverterOps</code>.</li>
<li>Provide a singleton instance (e.g., <code>MY_TYPE</code>).</li>
<li><strong><code>widen(MyType&lt;A&gt; myTypeValue)</code></strong>: Since <code>MyType&lt;A&gt;</code> <em>is</em> already a <code>MyTypeKind&lt;A&gt;</code> (and thus a <code>Kind</code>), this method performs a null check and then a direct cast.</li>
<li><strong><code>narrow(Kind&lt;MyType.Witness, A&gt; kind)</code></strong>: This method checks <code>if (kind instanceof MyType&lt;?&gt; myTypeInstance)</code> and then casts and returns <code>myTypeInstance</code>.</li>
</ul>
<pre><code class="language-java">package org.example.mytype;

import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.exception.KindUnwrapException;
import org.jspecify.annotations.NonNull;
import org.jspecify.annotations.Nullable;
import java.util.Objects;

public enum MyTypeKindHelper implements MyTypeConverterOps {
    MY_TYPE; // Singleton instance

    private static final String ERR_INVALID_KIND_NULL = "Cannot narrow null Kind for MyType";
    private static final String ERR_INVALID_KIND_TYPE = "Kind instance is not a MyType: ";

    @Override
    @SuppressWarnings("unchecked") // MyType&lt;A&gt; is MyTypeKind&lt;A&gt; is Kind&lt;MyType.Witness, A&gt;
    public &lt;A&gt; @NonNull Kind&lt;MyType.Witness, A&gt; widen(@NonNull MyType&lt;A&gt; myTypeValue) {
        Objects.requireNonNull(myTypeValue, "Input MyType cannot be null for widen");
        return (MyTypeKind&lt;A&gt;) myTypeValue; // Direct cast
    }

    @Override
    @SuppressWarnings("unchecked")
    public &lt;A&gt; @NonNull MyType&lt;A&gt; narrow(@Nullable Kind&lt;MyType.Witness, A&gt; kind) {
        if (kind == null) {
            throw new KindUnwrapException(ERR_INVALID_KIND_NULL);
        }
        // Check if it's an instance of your actual type
        if (kind instanceof MyType&lt;?&gt; myTypeInstance) { // Pattern match for MyType
            return (MyType&lt;A&gt;) myTypeInstance; // Direct cast
        } else {
            throw new KindUnwrapException(ERR_INVALID_KIND_TYPE + kind.getClass().getName());
        }
    }
}
</code></pre>
</li>
<li>
<p><strong>Implement Type Class Instances</strong>:</p>
<ul>
<li>These will be similar to the external type scenario (e.g., <code>MyTypeMonad implements Monad&lt;MyType.Witness&gt;</code>), using <code>MyTypeKindHelper.MY_TYPE.widen(...)</code> and <code>MyTypeKindHelper.MY_TYPE.narrow(...)</code> (or with static import <code>MY_TYPE.widen(...)</code>).</li>
</ul>
</li>
</ol>
</div>
</div>
<div id="admonition-note-2" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-2-title">
<div class="admonition-title">
<div id="admonition-note-2-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="hkts/extending-simulation.html#admonition-note-2"></a>
</div>
<div>
<ul>
<li><strong>Immutability</strong>: Favour immutable data structures for your <code>Holder</code> or custom type if possible, as this aligns well with functional programming principles.</li>
<li><strong>Null Handling</strong>: Be very clear about null handling. Can the wrapped Java type be null? Can the value <code>A</code> inside be null? <code>KindHelper</code>'s <code>widen</code> method should typically reject a null container itself. <code>Monad.of(null)</code> behaviour depends on the specific monad (e.g., <code>OptionalMonad.OPTIONAL_MONAD.of(null)</code> is empty via <code>OPTIONAL.widen(Optional.empty())</code>, <code>ListMonad.LIST_MONAD.of(null)</code> might be an empty list or a list with a null element based on its definition).</li>
<li><strong>Testing</strong>: Thoroughly test your <code>XxxKindHelper</code> enum (especially <code>narrow</code> with invalid inputs) and your type class instances (Functor, Applicative, Monad laws).</li>
</ul>
<p>By following these patterns, you can integrate new or existing types into the Higher-Kinded-J framework, enabling them to be used with generic functional abstractions. The <code>KindHelper</code> enums, along with their corresponding <code>ConverterOps</code> interfaces, provide a standardised way to handle the <code>widen</code> and <code>narrow</code> conversions.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="core-api-interfaces-the-building-blocks"><a class="header" href="#core-api-interfaces-the-building-blocks">Core API Interfaces: The Building Blocks</a></h1>
<p>The <code>hkj-api</code> module contains the heart of the <code>higher-kinded-j</code> library‚Äîa set of interfaces that define the core functional programming abstractions. These are the building blocks you will use to write powerful, generic, and type-safe code.</p>
<p>This document provides a high-level overview of the most important interfaces, which are often referred to as <strong>type classes</strong>.</p>
<hr />
<h2 id="core-hkt-abstraction"><a class="header" href="#core-hkt-abstraction">Core HKT Abstraction</a></h2>
<p>At the very centre of the library is the <code>Kind</code> interface, which makes higher-kinded types possible in Java.</p>
<ul>
<li><strong><code>Kind&lt;F, A&gt;</code></strong>: This is the foundational interface that emulates a higher-kinded type. It represents a type <code>F</code> that is generic over a type <code>A</code>. For example, <code>Kind&lt;ListKind.Witness, String&gt;</code> represents a <code>List&lt;String&gt;</code>. You will see this interface used everywhere as the common currency for all our functional abstractions.</li>
</ul>
<hr />
<h2 id="the-monad-hierarchy"><a class="header" href="#the-monad-hierarchy">The Monad Hierarchy</a></h2>
<p>The most commonly used type classes form a hierarchy of power and functionality, starting with <code>Functor</code> and building up to <code>Monad</code>.</p>
<h3 id="functorf"><a class="header" href="#functorf"><strong><code>Functor&lt;F&gt;</code></strong></a></h3>
<p>A <strong><code>Functor</code></strong> is a type class for any data structure that can be "mapped over". It provides a single operation, <code>map</code>, which applies a function to the value(s) inside the structure without changing the structure itself.</p>
<ul>
<li><strong>Key Method</strong>: <code>map(Function&lt;A, B&gt; f, Kind&lt;F, A&gt; fa)</code></li>
<li><strong>Intuition</strong>: If you have a <code>List&lt;A&gt;</code> and a function <code>A -&gt; B</code>, a <code>Functor</code> for <code>List</code> lets you produce a <code>List&lt;B&gt;</code>. The same logic applies to <code>Optional</code>, <code>Either</code>, <code>Try</code>, etc.</li>
</ul>
<h3 id="applicativef"><a class="header" href="#applicativef"><strong><code>Applicative&lt;F&gt;</code></strong></a></h3>
<p>An <strong><code>Applicative</code></strong> (or Applicative Functor) is a <code>Functor</code> with more power. It allows you to apply a function that is itself wrapped in the data structure. This is essential for combining multiple independent computations.</p>
<ul>
<li><strong>Key Methods</strong>:
<ul>
<li><code>of(A value)</code>: Lifts a normal value <code>A</code> into the applicative context <code>F&lt;A&gt;</code>.</li>
<li><code>ap(Kind&lt;F, Function&lt;A, B&gt;&gt; ff, Kind&lt;F, A&gt; fa)</code>: Applies a wrapped function to a wrapped value.</li>
</ul>
</li>
<li><strong>Intuition</strong>: If you have an <code>Optional&lt;Function&lt;A, B&gt;&gt;</code> and an <code>Optional&lt;A&gt;</code>, you can use the <code>Applicative</code> for <code>Optional</code> to get an <code>Optional&lt;B&gt;</code>. This is how <code>Validated</code> is able to accumulate errors from multiple independent validation steps.</li>
</ul>
<h3 id="monadf"><a class="header" href="#monadf"><strong><code>Monad&lt;F&gt;</code></strong></a></h3>
<p>A <strong><code>Monad</code></strong> is an <code>Applicative</code> that adds the power of sequencing dependent computations. It provides a way to chain operations together, where the result of one operation is fed into the next.</p>
<ul>
<li><strong>Key Method</strong>: <code>flatMap(Function&lt;A, Kind&lt;F, B&gt;&gt; f, Kind&lt;F, A&gt; fa)</code></li>
<li><strong>Intuition</strong>: <code>flatMap</code> is the powerhouse of monadic composition. It takes a value from a context (like an <code>Optional&lt;A&gt;</code>), applies a function that returns a <em>new</em> context (<code>A -&gt; Optional&lt;B&gt;</code>), and flattens the result into a single context (<code>Optional&lt;B&gt;</code>). This is what enables the elegant, chainable workflows you see in the examples.</li>
</ul>
<h3 id="monaderrorf-e"><a class="header" href="#monaderrorf-e"><strong><code>MonadError&lt;F, E&gt;</code></strong></a></h3>
<p>A <strong><code>MonadError</code></strong> is a specialised <code>Monad</code> that has a defined error type <code>E</code>. It provides explicit methods for raising and handling errors within a monadic workflow.</p>
<ul>
<li><strong>Key Methods</strong>:
<ul>
<li><code>raiseError(E error)</code>: Lifts an error <code>E</code> into the monadic context <code>F&lt;A&gt;</code>.</li>
<li><code>handleErrorWith(Kind&lt;F, A&gt; fa, Function&lt;E, Kind&lt;F, A&gt;&gt; f)</code>: Provides a way to recover from a failed computation.</li>
</ul>
</li>
</ul>
<h3 id="alternativef"><a class="header" href="#alternativef"><strong><code>Alternative&lt;F&gt;</code></strong></a></h3>
<p>An <strong><code>Alternative</code></strong> is an <code>Applicative</code> that adds the concept of choice and failure. It provides operations for combining alternatives and representing empty/failed computations. Alternative sits at the same level as <code>Applicative</code> in the type class hierarchy.</p>
<ul>
<li><strong>Key Methods</strong>:
<ul>
<li><code>empty()</code>: Returns the empty/failure element for the applicative.</li>
<li><code>orElse(Kind&lt;F, A&gt; fa, Supplier&lt;Kind&lt;F, A&gt;&gt; fb)</code>: Combines two alternatives, preferring the first if it succeeds, otherwise evaluating and returning the second.</li>
<li><code>guard(boolean condition)</code>: Returns success (<code>of(Unit.INSTANCE)</code>) if true, otherwise empty.</li>
</ul>
</li>
<li><strong>Use Case</strong>: Essential for parser combinators, fallback chains, non-deterministic computation, and trying multiple alternatives with lazy evaluation.</li>
</ul>
<h3 id="selectivef"><a class="header" href="#selectivef"><strong><code>Selective&lt;F&gt;</code></strong></a></h3>
<p>A <strong><code>Selective</code></strong> functor sits between <code>Applicative</code> and <code>Monad</code> in terms of power. It extends <code>Applicative</code> with the ability to conditionally apply effects based on the result of a previous computation, whilst maintaining a static structure where all possible branches are visible upfront.</p>
<ul>
<li><strong>Key Methods</strong>:
<ul>
<li><code>select(Kind&lt;F, Choice&lt;A, B&gt;&gt; fab, Kind&lt;F, Function&lt;A, B&gt;&gt; ff)</code>: Core operation that conditionally applies a function based on a <code>Choice</code>.</li>
<li><code>whenS(Kind&lt;F, Boolean&gt; fcond, Kind&lt;F, Unit&gt; fa)</code>: Conditionally executes an effect based on a boolean condition.</li>
<li><code>ifS(Kind&lt;F, Boolean&gt; fcond, Kind&lt;F, A&gt; fthen, Kind&lt;F, A&gt; felse)</code>: Provides if-then-else semantics with both branches visible upfront.</li>
</ul>
</li>
<li><strong>Use Case</strong>: Perfect for feature flags, conditional logging, configuration-based behaviour, and any scenario where you need conditional effects with static analysis capabilities.</li>
</ul>
<h3 id="monadzerof"><a class="header" href="#monadzerof"><strong><code>MonadZero&lt;F&gt;</code></strong></a></h3>
<p>A <strong><code>MonadZero</code></strong> is a <code>Monad</code> that also extends <code>Alternative</code>, combining monadic bind with choice operations. It adds the concept of a "zero" or "empty" element, allowing it to represent failure or absence.</p>
<ul>
<li><strong>Key Methods</strong>:
<ul>
<li><code>zero()</code>: Returns the zero/empty element for the monad (implements <code>empty()</code> from Alternative).</li>
<li>Inherits <code>orElse()</code> and <code>guard()</code> from <code>Alternative</code>.</li>
</ul>
</li>
<li><strong>Use Case</strong>: Primarily enables filtering in for-comprehensions via the <code>when()</code> clause. Also provides all Alternative operations for monadic contexts. Implemented by List, Maybe, Optional, and Stream.</li>
</ul>
<hr />
<h2 id="data-aggregation-type-classes"><a class="header" href="#data-aggregation-type-classes">Data Aggregation Type Classes</a></h2>
<p>These type classes define how data can be combined and reduced.</p>
<h3 id="semigroupa"><a class="header" href="#semigroupa"><strong><code>Semigroup&lt;A&gt;</code></strong></a></h3>
<p>A <strong><code>Semigroup</code></strong> is a simple type class for any type <code>A</code> that has an associative <code>combine</code> operation. It's the foundation for any kind of data aggregation.</p>
<ul>
<li><strong>Key Method</strong>: <code>combine(A a1, A a2)</code></li>
<li><strong>Use Case</strong>: Its primary use in this library is to tell a <code>Validated``Applicative</code> how to accumulate errors.</li>
</ul>
<h3 id="monoida"><a class="header" href="#monoida"><strong><code>Monoid&lt;A&gt;</code></strong></a></h3>
<p>A <strong><code>Monoid</code></strong> is a <code>Semigroup</code> that also has an "empty" or "identity" element. This is a value that, when combined with any other value, does nothing.</p>
<ul>
<li><strong>Key Methods</strong>:
<ul>
<li><code>combine(A a1, A a2)</code> (from <code>Semigroup</code>)</li>
<li><code>empty()</code></li>
</ul>
</li>
<li><strong>Use Case</strong>: Essential for folding data structures, where <code>empty()</code> provides the starting value for the reduction.</li>
</ul>
<hr />
<h2 id="structure-iterating-type-classes-1"><a class="header" href="#structure-iterating-type-classes-1">Structure-Iterating Type Classes</a></h2>
<p>These type classes define how to iterate over and manipulate the contents of a data structure in a generic way.</p>
<h3 id="foldablef"><a class="header" href="#foldablef"><strong><code>Foldable&lt;F&gt;</code></strong></a></h3>
<p>A <strong><code>Foldable</code></strong> is a type class for any data structure <code>F</code> that can be reduced to a single summary value. It uses a <code>Monoid</code> to combine the elements.</p>
<ul>
<li><strong>Key Method</strong>: <code>foldMap(Monoid&lt;M&gt; monoid, Function&lt;A, M&gt; f, Kind&lt;F, A&gt; fa)</code></li>
<li><strong>Intuition</strong>: It abstracts the process of iterating over a collection and aggregating the results.</li>
</ul>
<h3 id="traversef"><a class="header" href="#traversef"><strong><code>Traverse&lt;F&gt;</code></strong></a></h3>
<p>A <strong><code>Traverse</code></strong> is a powerful type class that extends both <code>Functor</code> and <code>Foldable</code>. It allows you to iterate over a data structure <code>F&lt;A&gt;</code> and apply an effectful function <code>A -&gt; G&lt;B&gt;</code> at each step, collecting the results into a single effect <code>G&lt;F&lt;B&gt;&gt;</code>.</p>
<ul>
<li><strong>Key Method</strong>: <code>traverse(Applicative&lt;G&gt; applicative, Function&lt;A, Kind&lt;G, B&gt;&gt; f, Kind&lt;F, A&gt; fa)</code></li>
<li><strong>Use Case</strong>: This is incredibly useful for tasks like validating every item in a <code>List</code>, where the validation returns a <code>Validated</code>. The result is a single <code>Validated</code> containing either a <code>List</code> of all successful results or an accumulation of all errors.</li>
</ul>
<hr />
<h2 id="dual-parameter-type-classes-1"><a class="header" href="#dual-parameter-type-classes-1">Dual-Parameter Type Classes</a></h2>
<p>These type classes work with types that take two type parameters, such as functions, profunctors, and bifunctors.</p>
<h3 id="profunctorp"><a class="header" href="#profunctorp"><strong><code>Profunctor&lt;P&gt;</code></strong></a></h3>
<p>A <strong><code>Profunctor</code></strong> is a type class for any type constructor <code>P&lt;A, B&gt;</code> that is contravariant in its first parameter and covariant in its second. This is the abstraction behind functions and many data transformation patterns.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="functional/functional_api.html#admonition-note"></a>
</div>
<div>
<p>New to variance terminology? See the <a href="functional/../glossary.html">Glossary</a> for detailed explanations of covariant, contravariant, and invariant with Java-focused examples.</p>
</div>
</div>
<ul>
<li><strong>Key Methods</strong>:
<ul>
<li><code>lmap(Function&lt;C, A&gt; f, Kind2&lt;P, A, B&gt; pab)</code>: Pre-process the input (contravariant mapping)</li>
<li><code>rmap(Function&lt;B, C&gt; g, Kind2&lt;P, A, B&gt; pab)</code>: Post-process the output (covariant mapping)</li>
<li><code>dimap(Function&lt;C, A&gt; f, Function&lt;B, D&gt; g, Kind2&lt;P, A, B&gt; pab)</code>: Transform both input and output simultaneously</li>
</ul>
</li>
<li><strong>Use Case</strong>: Essential for building flexible data transformation pipelines, API adapters, and validation frameworks that can adapt to different input and output formats without changing core business logic.</li>
</ul>
<h3 id="profunctors-in-optics"><a class="header" href="#profunctors-in-optics"><strong>Profunctors in Optics</strong></a></h3>
<p>Importantly, every optic in higher-kinded-j is fundamentally a profunctor. This means that <code>Lens</code>, <code>Prism</code>, <code>Iso</code>, and <code>Traversal</code> all support profunctor operations through their <code>contramap</code>, <code>map</code>, and <code>dimap</code> methods. This provides incredible flexibility for adapting optics to work with different data types and structures, making them highly reusable across different contexts and API boundaries.</p>
<h3 id="bifunctorf"><a class="header" href="#bifunctorf"><strong><code>Bifunctor&lt;F&gt;</code></strong></a></h3>
<p>A <strong><code>Bifunctor</code></strong> is a type class for any type constructor <code>F&lt;A, B&gt;</code> that is covariant in <em>both</em> its type parameters. Unlike <code>Profunctor</code>, which is contravariant in the first parameter, <code>Bifunctor</code> allows you to map over both sides independently or simultaneously.</p>
<div id="admonition-note-1" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-1-title">
<div class="admonition-title">
<div id="admonition-note-1-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="functional/functional_api.html#admonition-note-1"></a>
</div>
<div>
<p>New to variance terminology? See the <a href="functional/../glossary.html">Glossary</a> for detailed explanations of covariant, contravariant, and invariant with Java-focused examples.</p>
</div>
</div>
<ul>
<li><strong>Key Methods</strong>:
<ul>
<li><code>bimap(Function&lt;A, C&gt; f, Function&lt;B, D&gt; g, Kind2&lt;F, A, B&gt; fab)</code>: Transform both type parameters simultaneously</li>
<li><code>first(Function&lt;A, C&gt; f, Kind2&lt;F, A, B&gt; fab)</code>: Map over only the first type parameter</li>
<li><code>second(Function&lt;B, D&gt; g, Kind2&lt;F, A, B&gt; fab)</code>: Map over only the second type parameter</li>
</ul>
</li>
<li><strong>Use Case</strong>: Essential for transforming both channels of sum types (like <code>Either&lt;L, R&gt;</code> or <code>Validated&lt;E, A&gt;</code>) or product types (like <code>Tuple2&lt;A, B&gt;</code> or <code>Writer&lt;W, A&gt;</code>), where both parameters hold data rather than representing input/output relationships. Perfect for API response transformation, validation pipelines, data migration, and error handling scenarios.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="functor-the-mappable-type-class"><a class="header" href="#functor-the-mappable-type-class">Functor: The "Mappable" Type Class</a></h1>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="functional/functor.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to transform values inside containers without changing the container structure</li>
<li>The difference between regular functions and functorial mapping</li>
<li>Functor laws (identity and composition) and why they matter</li>
<li>How to use Functor instances with List, Optional, and other containers</li>
<li>When to choose Functor over direct method calls</li>
</ul>
</div>
</div>
<p>At the heart of functional programming is the ability to transform data within a container without having to open it. The <strong><code>Functor</code></strong> type class provides exactly this capability. It's the simplest and most common abstraction for any data structure that can be "mapped over."</p>
<p>If you've ever used <code>Optional.map()</code> or <code>Stream.map()</code>, you've already been using the Functor pattern! <code>higher-kinded-j</code> simply formalises this concept so you can apply it to any data structure.</p>
<hr />
<h2 id="what-is-it"><a class="header" href="#what-is-it">What is it?</a></h2>
<p>A <strong><code>Functor</code></strong> is a type class for any data structure <code>F</code> that supports a <code>map</code> operation. This operation takes a function from <code>A -&gt; B</code> and applies it to the value(s) inside a container <code>F&lt;A&gt;</code>, producing a new container <code>F&lt;B&gt;</code> of the same shape.</p>
<p>Think of a <code>Functor</code> as a generic "box" that holds a value. The <code>map</code> function lets you transform the contents of the box without ever taking the value out. Whether the box is an <code>Optional</code> that might be empty, a <code>List</code> with many items, or a <code>Try</code> that might hold an error, the mapping logic remains the same.</p>
<p>The interface for <code>Functor</code> in <code>hkj-api</code> is simple and elegant:</p>
<pre><code class="language-java">public interface Functor&lt;F&gt; {
  &lt;A, B&gt; @NonNull Kind&lt;F, B&gt; map(final Function&lt;? super A, ? extends B&gt; f, final Kind&lt;F, A&gt; fa);
}
</code></pre>
<ul>
<li><code>f</code>: The function to apply to the value inside the Functor.</li>
<li><code>fa</code>: The higher-kinded <code>Functor</code> instance (e.g., a <code>Kind&lt;Optional.Witness, String&gt;</code>).</li>
</ul>
<hr />
<h3 id="the-functor-laws"><a class="header" href="#the-functor-laws">The Functor Laws</a></h3>
<p>For a <code>Functor</code> implementation to be lawful, it must obey two simple rules. These ensure that the <code>map</code> operation is predictable and doesn't have unexpected side effects.</p>
<ol>
<li>
<p><strong>Identity Law</strong>: Mapping with the identity function (<code>x -&gt; x</code>) should change nothing.</p>
<pre><code class="language-java">functor.map(x -&gt; x, fa); // This must be equivalent to fa
</code></pre>
</li>
<li>
<p><strong>Composition Law</strong>: Mapping with two functions composed together is the same as mapping with each function one after the other.</p>
<pre><code class="language-java">Function&lt;A, B&gt; f = ...;
Function&lt;B, C&gt; g = ...;

// This...
functor.map(g.compose(f), fa);

// ...must be equivalent to this:
functor.map(g, functor.map(f, fa));
</code></pre>
</li>
</ol>
<p>These laws ensure that <code>map</code> is only about transformation and preserves the structure of the data type.</p>
<hr />
<h3 id="why-is-it-useful"><a class="header" href="#why-is-it-useful">Why is it useful?</a></h3>
<p><code>Functor</code> allows you to write generic, reusable code that transforms values inside any "mappable" data structure. This is the first step toward abstracting away the boilerplate of dealing with different container types.</p>
<p><strong>Example: Mapping over an <code>Optional</code> and a <code>List</code></strong></p>
<p>Let's see how we can use the <code>Functor</code> instances for <code>Optional</code> and <code>List</code> to apply the same logic to different data structures.</p>
<pre><code class="language-java">import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.list.ListFunctor;
import org.higherkindedj.hkt.list.ListKind;
import org.higherkindedj.hkt.optional.OptionalFunctor;
import org.higherkindedj.hkt.optional.OptionalKind;
import java.util.List;
import java.util.Optional;
import static org.higherkindedj.hkt.list.ListKindHelper.LIST;
import static org.higherkindedj.hkt.optional.OptionalKindHelper.OPTIONAL;


// Our function that we want to apply
Function&lt;String, Integer&gt; stringLength = String::length;

// --- Scenario 1: Mapping over an Optional ---
Functor&lt;OptionalKind.Witness&gt; optionalFunctor = OptionalFunctor.INSTANCE;

// The data
Kind&lt;OptionalKind.Witness, String&gt; optionalWithValue = OPTIONAL.widen(Optional.of("Hello"));
Kind&lt;OptionalKind.Witness, String&gt; optionalEmpty = OPTIONAL.widen(Optional.empty());

// Apply the map
Kind&lt;OptionalKind.Witness, Integer&gt; lengthWithValue = optionalFunctor.map(stringLength, optionalWithValue);
Kind&lt;OptionalKind.Witness, Integer&gt; lengthEmpty = optionalFunctor.map(stringLength, optionalEmpty);

// Result: Optional[5]
System.out.println(OPTIONAL.narrow(lengthWithValue));
// Result: Optional.empty
System.out.println(OPTIONAL.narrow(lengthEmpty));


// --- Scenario 2: Mapping over a List ---
Functor&lt;ListKind.Witness&gt; listFunctor = ListFunctor.INSTANCE;

// The data
Kind&lt;ListKind.Witness, String&gt; listOfStrings = LIST.widen(List.of("one", "two", "three"));

// Apply the map
Kind&lt;ListKind.Witness, Integer&gt; listOfLengths = listFunctor.map(stringLength, listOfStrings);

// Result: [3, 3, 5]
System.out.println(LIST.narrow(listOfLengths));
</code></pre>
<p>As you can see, the <code>Functor</code> provides a consistent API for transformation, regardless of the underlying data structure. This is the first and most essential step on the path to more powerful abstractions like <code>Applicative</code> and <code>Monad</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="applicative-applying-wrapped-functions"><a class="header" href="#applicative-applying-wrapped-functions">Applicative: Applying Wrapped Functions</a></h1>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="functional/applicative.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to apply wrapped functions to wrapped values using <code>ap</code></li>
<li>The difference between independent computations (Applicative) and dependent ones (Monad)</li>
<li>How to combine multiple validation results and accumulate all errors</li>
<li>Using <code>map2</code>, <code>map3</code> and other convenience methods for combining values</li>
<li>Real-world validation scenarios with the Validated type</li>
</ul>
</div>
</div>
<p>Whilst a <code>Functor</code> excels at applying a <em>pure</em> function to a value inside a context, what happens when the function you want to apply is <em>also</em> wrapped in a context? This is where the <strong><code>Applicative</code></strong> type class comes in. It's the next step up in power from a <code>Functor</code> and allows you to combine multiple computations within a context in a very powerful way.</p>
<hr />
<h2 id="what-is-it-1"><a class="header" href="#what-is-it-1">What is it?</a></h2>
<p>An <strong><code>Applicative</code></strong> (or Applicative Functor) is a <code>Functor</code> that also provides two key operations:</p>
<ol>
<li><strong><code>of</code></strong> (also known as <code>pure</code>): Lifts a regular value into the applicative context. For example, it can take a <code>String</code> and wrap it to become an <code>Optional&lt;String&gt;</code>.</li>
<li><strong><code>ap</code></strong>: Takes a function that is wrapped in the context (e.g., an <code>Optional&lt;Function&lt;A, B&gt;&gt;</code>) and applies it to a value that is also in the context (e.g., an <code>Optional&lt;A&gt;</code>).</li>
</ol>
<p>This ability to apply a <em>wrapped function</em> to a <em>wrapped value</em> is what makes <code>Applicative</code> so powerful. It's the foundation for combining independent computations.</p>
<p>The interface for <code>Applicative</code> in <code>hkj-api</code> extends <code>Functor</code>:</p>
<pre><code class="language-java">@NullMarked
public interface Applicative&lt;F&gt; extends Functor&lt;F&gt; {

  &lt;A&gt; @NonNull Kind&lt;F, A&gt; of(@Nullable A value);

  &lt;A, B&gt; @NonNull Kind&lt;F, B&gt; ap(
      Kind&lt;F, ? extends Function&lt;A, B&gt;&gt; ff,
      Kind&lt;F, A&gt; fa
  );

  // Default methods for map2, map3, etc. are also provided
  default &lt;A, B, C&gt; @NonNull Kind&lt;F, C&gt; map2(
      final Kind&lt;F, A&gt; fa,
      final Kind&lt;F, B&gt; fb,
      final BiFunction&lt;? super A, ? super B, ? extends C&gt; f) {
    return ap(map(a -&gt; b -&gt; f.apply(a, b), fa), fb);
  }
}
</code></pre>
<hr />
<h3 id="why-is-it-useful-1"><a class="header" href="#why-is-it-useful-1">Why is it useful?</a></h3>
<p>The primary use case for <code>Applicative</code> is to combine the results of several independent computations that are all inside the same context. The classic example is <strong>data validation</strong>, where you want to validate multiple fields and accumulate all the errors.</p>
<p>Whilst a <code>Monad</code> (using <code>flatMap</code>) can also combine computations, it cannot accumulate errors in the same way. When a monadic chain fails, it short-circuits, giving you only the <em>first</em> error. An <code>Applicative</code>, on the other hand, can process all computations independently and combine the results.</p>
<p><strong>Example: Validating a User Registration Form</strong></p>
<p>Imagine you have a registration form and you need to validate both the username and the password. Each validation can either succeed or return a list of error messages. We can use the <code>Applicative</code> for <code>Validated</code> to run both validations and get all the errors back at once.</p>
<pre><code class="language-java">import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.validated.Validated;
import org.higherkindedj.hkt.validated.ValidatedMonad;
import org.higherkindedj.hkt.Semigroups;

import java.util.List;
import static org.higherkindedj.hkt.validated.ValidatedKindHelper.VALIDATED;

// A simple User class
record User(String username, String password) {}

// Validation functions
public Validated&lt;List&lt;String&gt;, String&gt; validateUsername(String username) {
    if (username.length() &lt; 3) {
        return Validated.invalid(List.of("Username must be at least 3 characters"));
    }
    return Validated.valid(username);
}

public Validated&lt;List&lt;String&gt;, String&gt; validatePassword(String password) {
    if (!password.matches(".*\\d.*")) {
        return Validated.invalid(List.of("Password must contain a number"));
    }
    return Validated.valid(password);
}


// --- Get the Applicative instance for Validated ---
// We need a Semigroup to tell the Applicative how to combine errors (in this case, by concatenating lists)
Applicative&lt;Validated.Witness&lt;List&lt;String&gt;&gt;&gt; applicative =
    ValidatedMonad.instance(Semigroups.list());

// --- Scenario 1: All validations pass ---
Validated&lt;List&lt;String&gt;, String&gt; validUsername = validateUsername("test_user");
Validated&lt;List&lt;String&gt;, String&gt; validPassword = validatePassword("password123");

Kind&lt;Validated.Witness&lt;List&lt;String&gt;&gt;, User&gt; validResult =
    applicative.map2(
        VALIDATED.widen(validUsername),
        VALIDATED.widen(validPassword),
        User::new // If both are valid, create a new User
    );

// Result: Valid(User[username=test_user, password=password123])
System.out.println(VALIDATED.narrow(validResult));


// --- Scenario 2: Both validations fail ---
Validated&lt;List&lt;String&gt;, String&gt; invalidUsername = validateUsername("no");
Validated&lt;List&lt;String&gt;, String&gt; invalidPassword = validatePassword("bad");

Kind&lt;Validated.Witness&lt;List&lt;String&gt;&gt;, User&gt; invalidResult =
    applicative.map2(
        VALIDATED.widen(invalidUsername),
        VALIDATED.widen(invalidPassword),
        User::new
    );

// The errors from both validations are accumulated!
// Result: Invalid([Username must be at least 3 characters, Password must contain a number])
System.out.println(VALIDATED.narrow(invalidResult));
</code></pre>
<p>This error accumulation is impossible with <code>Functor</code> and is one of the key features that makes <code>Applicative</code> so indispensable for real-world functional programming.</p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="alternative"><a class="header" href="#alternative">Alternative</a></h1>
<p>The <code>Alternative</code> type class represents applicative functors that support choice and failure. It extends the <code>Applicative</code> interface with operations for combining alternatives and representing empty/failed computations. Alternative sits at the same level as <code>Applicative</code> in the type class hierarchy, providing a more general abstraction than <code>MonadZero</code>.</p>
<p>The interface for Alternative in hkj-api extends Applicative:</p>
<pre><code class="language-java">public interface Alternative&lt;F&gt; extends Applicative&lt;F&gt; {
    &lt;A&gt; Kind&lt;F, A&gt; empty();
    &lt;A&gt; Kind&lt;F, A&gt; orElse(Kind&lt;F, A&gt; fa, Supplier&lt;Kind&lt;F, A&gt;&gt; fb);
    default Kind&lt;F, Unit&gt; guard(boolean condition);
}
</code></pre>
<h3 id="why-is-it-useful-2"><a class="header" href="#why-is-it-useful-2">Why is it useful?</a></h3>
<p>An <code>Applicative</code> provides a way to apply functions within a context and combine multiple values. An <code>Alternative</code> adds two critical operations to this structure:</p>
<ul>
<li><code>empty()</code>: Returns the "empty" or "failure" element for the applicative functor.</li>
<li><code>orElse(fa, fb)</code>: Combines two alternatives, preferring the first if it succeeds, otherwise evaluating and returning the second.</li>
</ul>
<p>These operations enable:</p>
<ul>
<li><strong>Choice and fallback mechanisms</strong>: Try one computation, if it fails, try another</li>
<li><strong>Non-deterministic computation</strong>: Represent multiple possible results (e.g., List concatenation)</li>
<li><strong>Parser combinators</strong>: Essential for building flexible parsers that try alternatives</li>
<li><strong>Conditional effects</strong>: Using the <code>guard()</code> helper for filtering</li>
</ul>
<h3 id="relationship-with-monadzero"><a class="header" href="#relationship-with-monadzero">Relationship with MonadZero</a></h3>
<p>In higher-kinded-j, <code>MonadZero</code> extends both <code>Monad</code> and <code>Alternative</code>:</p>
<pre><code class="language-java">public interface MonadZero&lt;F&gt; extends Monad&lt;F&gt;, Alternative&lt;F&gt; {
    &lt;A&gt; Kind&lt;F, A&gt; zero();

    @Override
    default &lt;A&gt; Kind&lt;F, A&gt; empty() {
        return zero();
    }
}
</code></pre>
<p>This means:</p>
<ul>
<li>Every <code>MonadZero</code> is also an <code>Alternative</code></li>
<li>The <code>zero()</code> method provides the implementation for <code>empty()</code></li>
<li>Types that are MonadZero (List, Maybe, Optional, Stream) automatically get Alternative operations</li>
</ul>
<h3 id="key-implementations-in-this-project"><a class="header" href="#key-implementations-in-this-project">Key Implementations in this Project</a></h3>
<p>For different types, Alternative has different semantics:</p>
<ul>
<li><strong>Maybe</strong>: <code>empty()</code> returns <code>Nothing</code>. <code>orElse()</code> returns the first <code>Just</code>, or the second if the first is <code>Nothing</code>.</li>
<li><strong>Optional</strong>: <code>empty()</code> returns <code>Optional.empty()</code>. <code>orElse()</code> returns the first present value, or the second if the first is empty.</li>
<li><strong>List</strong>: <code>empty()</code> returns an empty list <code>[]</code>. <code>orElse()</code> concatenates both lists (non-deterministic choice).</li>
<li><strong>Stream</strong>: <code>empty()</code> returns an empty stream. <code>orElse()</code> concatenates both streams lazily.</li>
</ul>
<h3 id="primary-uses"><a class="header" href="#primary-uses">Primary Uses</a></h3>
<h4 id="1-fallback-chains-with-maybeoptional"><a class="header" href="#1-fallback-chains-with-maybeoptional">1. Fallback Chains with Maybe/Optional</a></h4>
<p>Try multiple sources, using the first successful one:</p>
<pre><code class="language-java">import org.higherkindedj.hkt.Alternative;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.maybe.MaybeKind;
import org.higherkindedj.hkt.maybe.MaybeMonad;
import org.higherkindedj.hkt.maybe.Maybe;

import static org.higherkindedj.hkt.maybe.MaybeKindHelper.MAYBE;

// Get the Alternative instance for Maybe
final Alternative&lt;MaybeKind.Witness&gt; alt = MaybeMonad.INSTANCE;

// Simulate trying multiple configuration sources
Kind&lt;MaybeKind.Witness, String&gt; fromEnv = MAYBE.nothing();      // Not found
Kind&lt;MaybeKind.Witness, String&gt; fromFile = MAYBE.just("config.txt");  // Found!
Kind&lt;MaybeKind.Witness, String&gt; fromDefault = MAYBE.just("default");

// Try sources in order
Kind&lt;MaybeKind.Witness, String&gt; config = alt.orElse(
    fromEnv,
    () -&gt; alt.orElse(
        fromFile,
        () -&gt; fromDefault
    )
);

Maybe&lt;String&gt; result = MAYBE.narrow(config);
System.out.println("Config: " + result.get()); // "config.txt"
</code></pre>
<p><strong>Using <code>orElseAll()</code> for cleaner syntax:</strong></p>
<pre><code class="language-java">Kind&lt;MaybeKind.Witness, String&gt; config = alt.orElseAll(
    fromEnv,
    () -&gt; fromFile,
    () -&gt; fromDefault
);
</code></pre>
<h4 id="2-non-deterministic-computation-with-list"><a class="header" href="#2-non-deterministic-computation-with-list">2. Non-Deterministic Computation with List</a></h4>
<p>Represent all possible outcomes:</p>
<pre><code class="language-java">import org.higherkindedj.hkt.Alternative;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.list.ListKind;
import org.higherkindedj.hkt.list.ListMonad;

import java.util.Arrays;
import java.util.List;

import static org.higherkindedj.hkt.list.ListKindHelper.LIST;

// Get the Alternative instance for List
final Alternative&lt;ListKind.Witness&gt; alt = ListMonad.INSTANCE;

// Possible actions
Kind&lt;ListKind.Witness, String&gt; actions1 = LIST.widen(Arrays.asList("move_left", "move_right"));
Kind&lt;ListKind.Witness, String&gt; actions2 = LIST.widen(Arrays.asList("jump", "duck"));

// Combine all possibilities
Kind&lt;ListKind.Witness, String&gt; allActions = alt.orElse(actions1, () -&gt; actions2);

List&lt;String&gt; result = LIST.narrow(allActions);
System.out.println("All actions: " + result);
// Output: [move_left, move_right, jump, duck]
</code></pre>
<h4 id="3-conditional-success-with-guard"><a class="header" href="#3-conditional-success-with-guard">3. Conditional Success with guard()</a></h4>
<p>Filter based on conditions:</p>
<pre><code class="language-java">import org.higherkindedj.hkt.Alternative;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.Unit;
import org.higherkindedj.hkt.maybe.MaybeKind;
import org.higherkindedj.hkt.maybe.MaybeMonad;
import org.higherkindedj.hkt.maybe.Maybe;

import static org.higherkindedj.hkt.maybe.MaybeKindHelper.MAYBE;

final Alternative&lt;MaybeKind.Witness&gt; alt = MaybeMonad.INSTANCE;

// Check authentication
boolean isAuthenticated = true;
Kind&lt;MaybeKind.Witness, Unit&gt; authCheck = alt.guard(isAuthenticated);

Maybe&lt;Unit&gt; result = MAYBE.narrow(authCheck);
System.out.println("Authenticated: " + result.isJust()); // true

// guard(false) returns empty()
Kind&lt;MaybeKind.Witness, Unit&gt; failedCheck = alt.guard(false);
System.out.println("Failed: " + MAYBE.narrow(failedCheck).isNothing()); // true
</code></pre>
<h4 id="4-lazy-evaluation"><a class="header" href="#4-lazy-evaluation">4. Lazy Evaluation</a></h4>
<p>The second argument to <code>orElse()</code> is provided via <code>Supplier</code>, enabling lazy evaluation:</p>
<pre><code class="language-java">final Alternative&lt;MaybeKind.Witness&gt; alt = MaybeMonad.INSTANCE;

Kind&lt;MaybeKind.Witness, String&gt; primary = MAYBE.just("found");

Kind&lt;MaybeKind.Witness, String&gt; result = alt.orElse(
    primary,
    () -&gt; {
        System.out.println("Computing fallback...");
        return MAYBE.just("fallback");
    }
);

// "Computing fallback..." is never printed because primary succeeded
System.out.println("Result: " + MAYBE.narrow(result).get()); // "found"
</code></pre>
<p>For <strong>Maybe</strong> and <strong>Optional</strong>, the second alternative is only evaluated if the first is empty.</p>
<p>For <strong>List</strong> and <strong>Stream</strong>, both alternatives are always evaluated (to concatenate them), but the <code>Supplier</code> still provides control over when the second collection is created.</p>
<h3 id="alternative-laws"><a class="header" href="#alternative-laws">Alternative Laws</a></h3>
<p>Alternative instances must satisfy these laws:</p>
<ol>
<li>
<p><strong>Left Identity</strong>: <code>orElse(empty(), () -&gt; fa) ‚â° fa</code></p>
<ul>
<li>empty is the left identity for orElse</li>
</ul>
</li>
<li>
<p><strong>Right Identity</strong>: <code>orElse(fa, () -&gt; empty()) ‚â° fa</code></p>
<ul>
<li>empty is the right identity for orElse</li>
</ul>
</li>
<li>
<p><strong>Associativity</strong>: <code>orElse(fa, () -&gt; orElse(fb, () -&gt; fc)) ‚â° orElse(orElse(fa, () -&gt; fb), () -&gt; fc)</code></p>
<ul>
<li>The order of combining alternatives doesn't matter</li>
</ul>
</li>
<li>
<p><strong>Left Absorption</strong>: <code>ap(empty(), fa) ‚â° empty()</code></p>
<ul>
<li>Applying an empty function gives empty</li>
</ul>
</li>
<li>
<p><strong>Right Absorption</strong>: <code>ap(ff, empty()) ‚â° empty()</code></p>
<ul>
<li>Applying any function to empty gives empty</li>
</ul>
</li>
</ol>
<h3 id="practical-example-configuration-loading"><a class="header" href="#practical-example-configuration-loading">Practical Example: Configuration Loading</a></h3>
<p>Here's a complete example showing how Alternative enables elegant fallback chains:</p>
<pre><code class="language-java">import org.higherkindedj.hkt.Alternative;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.maybe.MaybeKind;
import org.higherkindedj.hkt.maybe.MaybeMonad;
import org.higherkindedj.hkt.maybe.Maybe;

import static org.higherkindedj.hkt.maybe.MaybeKindHelper.MAYBE;

public class ConfigLoader {
    private final Alternative&lt;MaybeKind.Witness&gt; alt = MaybeMonad.INSTANCE;

    public Kind&lt;MaybeKind.Witness, String&gt; loadConfig(String key) {
        return alt.orElseAll(
            readFromEnvironment(key),
            () -&gt; readFromConfigFile(key),
            () -&gt; readFromDatabase(key),
            () -&gt; getDefaultValue(key)
        );
    }

    private Kind&lt;MaybeKind.Witness, String&gt; readFromEnvironment(String key) {
        String value = System.getenv(key);
        return value != null ? MAYBE.just(value) : MAYBE.nothing();
    }

    private Kind&lt;MaybeKind.Witness, String&gt; readFromConfigFile(String key) {
        // Simulate file reading
        return MAYBE.nothing(); // Not found
    }

    private Kind&lt;MaybeKind.Witness, String&gt; readFromDatabase(String key) {
        // Simulate database query
        return MAYBE.just("db-value-" + key);
    }

    private Kind&lt;MaybeKind.Witness, String&gt; getDefaultValue(String key) {
        return MAYBE.just("default-" + key);
    }
}

// Usage
ConfigLoader loader = new ConfigLoader();
Kind&lt;MaybeKind.Witness, String&gt; config = loader.loadConfig("APP_NAME");
Maybe&lt;String&gt; result = MAYBE.narrow(config);
System.out.println("Config value: " + result.get()); // "db-value-APP_NAME"
</code></pre>
<h3 id="comparison-alternative-vs-monadzero"><a class="header" href="#comparison-alternative-vs-monadzero">Comparison: Alternative vs MonadZero</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th>Alternative</th><th>MonadZero</th></tr></thead><tbody>
<tr><td>Extends</td><td>Applicative</td><td>Monad (and Alternative)</td></tr>
<tr><td>Power Level</td><td>Less powerful</td><td>More powerful</td></tr>
<tr><td>Core Methods</td><td><code>empty()</code>, <code>orElse()</code></td><td><code>zero()</code>, inherits <code>orElse()</code></td></tr>
<tr><td>Use Case</td><td>Choice, fallback, alternatives</td><td>Filtering, monadic zero</td></tr>
<tr><td>Examples</td><td>Parser combinators, fallback chains</td><td>For-comprehension filtering</td></tr>
</tbody></table>
</div>
<p>In practice, since <code>MonadZero</code> extends <code>Alternative</code> in higher-kinded-j, types like List, Maybe, Optional, and Stream have access to both sets of operations.</p>
<h3 id="when-to-use-alternative"><a class="header" href="#when-to-use-alternative">When to Use Alternative</a></h3>
<p>Use Alternative when you need to:</p>
<ul>
<li><strong>Try multiple alternatives</strong> with fallback behaviour</li>
<li><strong>Combine all possibilities</strong> (for List/Stream)</li>
<li><strong>Conditionally proceed</strong> based on boolean conditions (<code>guard()</code>)</li>
<li><strong>Build parser combinators</strong> or similar choice-based systems</li>
<li>Work at the <strong>Applicative level</strong> without requiring full Monad power</li>
</ul>
<p>Alternative provides a principled, composable way to handle choice and failure in functional programming.</p>
<h2 id="complete-working-example"><a class="header" href="#complete-working-example">Complete Working Example</a></h2>
<p>For a complete, runnable example demonstrating Alternative with configuration loading, see:</p>
<p><strong><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/alternative/AlternativeConfigExample.java">AlternativeConfigExample.java</a></strong></p>
<p>This example demonstrates:</p>
<ul>
<li>Basic <code>orElse()</code> fallback patterns</li>
<li><code>orElseAll()</code> for multiple fallback sources</li>
<li><code>guard()</code> for conditional validation</li>
<li>Lazy evaluation benefits</li>
<li>Parser combinator patterns using Alternative</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="monad-sequencing-computations"><a class="header" href="#monad-sequencing-computations">Monad: Sequencing Computations</a></h1>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="functional/monad.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to sequence computations where each step depends on previous results</li>
<li>The power of <code>flatMap</code> for chaining operations that return wrapped values</li>
<li>When to use Monad vs Applicative (dependent vs independent computations)</li>
<li>Essential utility methods: <code>as</code>, <code>peek</code>, <code>flatMapIfOrElse</code>, and <code>flatMapN</code></li>
<li>How to combine multiple monadic values with <code>flatMap2</code>, <code>flatMap3</code>, etc.</li>
<li>How monadic short-circuiting works in practice</li>
</ul>
</div>
</div>
<p>You've seen how <code>Functor</code> lets you <code>map</code> over a value in a context and how <code>Applicative</code> lets you combine independent computations within a context. Now, we'll introduce the most powerful of the trio: <strong><code>Monad</code></strong>.</p>
<p>A <code>Monad</code> builds on <code>Applicative</code> by adding one crucial ability: sequencing computations that <strong>depend on each other</strong>. If the result of the first operation is needed to determine the second operation, you need a <code>Monad</code>.</p>
<hr />
<h2 id="what-is-it-2"><a class="header" href="#what-is-it-2">What is it?</a></h2>
<p>A <strong><code>Monad</code></strong> is an <code>Applicative</code> that provides a new function called <strong><code>flatMap</code></strong> (also known as <code>bind</code> in some languages). This is the powerhouse of monadic composition.</p>
<p>While <code>map</code> takes a simple function <code>A -&gt; B</code>, <code>flatMap</code> takes a function that returns a new value <em>already wrapped in the monadic context</em>, i.e., <code>A -&gt; Kind&lt;F, B&gt;</code>. <code>flatMap</code> then intelligently flattens the nested result <code>Kind&lt;F, Kind&lt;F, B&gt;&gt;</code> into a simple <code>Kind&lt;F, B&gt;</code>.</p>
<p>This flattening behaviour is what enables you to chain operations together in a clean, readable sequence without creating deeply nested structures.</p>
<hr />
<h2 id="the-monad-interface"><a class="header" href="#the-monad-interface">The <code>Monad</code> Interface</a></h2>
<p>The interface for <code>Monad</code> in <code>hkj-api</code> extends <code>Applicative</code> and adds <code>flatMap</code> along with several useful default methods for common patterns.</p>
<pre><code class="language-java">@NullMarked
public interface Monad&lt;M&gt; extends Applicative&lt;M&gt; {
  // Core sequencing method
  &lt;A, B&gt; @NonNull Kind&lt;M, B&gt; flatMap(
      final Function&lt;? super A, ? extends Kind&lt;M, B&gt;&gt; f, final Kind&lt;M, A&gt; ma);

  // Type-safe conditional branching
  default &lt;A, B&gt; @NonNull Kind&lt;M, B&gt; flatMapIfOrElse(
      final Predicate&lt;? super A&gt; predicate,
      final Function&lt;? super A, ? extends Kind&lt;M, B&gt;&gt; ifTrue,
      final Function&lt;? super A, ? extends Kind&lt;M, B&gt;&gt; ifFalse,
      final Kind&lt;M, A&gt; ma) {
    return flatMap(a -&gt; predicate.test(a) ? ifTrue.apply(a) : ifFalse.apply(a), ma);
  }

  // Replace the value while preserving the effect
  default &lt;A, B&gt; @NonNull Kind&lt;M, B&gt; as(final B b, final Kind&lt;M, A&gt; ma) {
    return map(_ -&gt; b, ma);
  }

  // Perform a side-effect without changing the value
  default &lt;A&gt; @NonNull Kind&lt;M, A&gt; peek(final Consumer&lt;? super A&gt; action, final Kind&lt;M, A&gt; ma) {
    return map(a -&gt; {
      action.accept(a);
      return a;
    }, ma);
  }

  // Combine multiple monadic values (flatMapN methods)
  default &lt;A, B, R&gt; @NonNull Kind&lt;M, R&gt; flatMap2(
      Kind&lt;M, A&gt; ma, Kind&lt;M, B&gt; mb,
      BiFunction&lt;? super A, ? super B, ? extends Kind&lt;M, R&gt;&gt; f) {
    return flatMap(a -&gt; flatMap(b -&gt; f.apply(a, b), mb), ma);
  }

  default &lt;A, B, C, R&gt; @NonNull Kind&lt;M, R&gt; flatMap3(
      Kind&lt;M, A&gt; ma, Kind&lt;M, B&gt; mb, Kind&lt;M, C&gt; mc,
      Function3&lt;? super A, ? super B, ? super C, ? extends Kind&lt;M, R&gt;&gt; f) {
    return flatMap(a -&gt; flatMap2(mb, mc, (b, c) -&gt; f.apply(a, b, c)), ma);
  }

  // flatMap4 and flatMap5 build on flatMap3 and flatMap4 respectively...
}
</code></pre>
<h3 id="monad-vs-applicative"><a class="header" href="#monad-vs-applicative">Monad vs. Applicative</a></h3>
<p>The key difference is simple but profound:</p>
<ul>
<li><strong><code>Applicative</code></strong> is for combining <strong>independent</strong> computations. The shape and structure of all the computations are known upfront. This is why it can accumulate errors from multiple validations‚Äîit runs all of them.</li>
<li><strong><code>Monad</code></strong> is for sequencing <strong>dependent</strong> computations. The computation in the second step cannot be known until the first step has completed. This is why it short-circuits on failure‚Äîif the first step fails, there is no value to feed into the second step.</li>
</ul>
<hr />
<h3 id="why-is-it-useful-3"><a class="header" href="#why-is-it-useful-3">Why is it useful?</a></h3>
<p><code>Monad</code> is essential for building any kind of workflow where steps depend on the result of previous steps, especially when those steps might fail or be asynchronous. It allows you to write what looks like a simple sequence of operations while hiding the complexity of error handling, null checks, or concurrency.</p>
<p>This pattern is the foundation for the <strong>for-comprehension</strong> builder in <code>higher-kinded-j</code>, which transforms a chain of <code>flatMap</code> calls into clean, imperative-style code.</p>
<h4 id="core-method-flatmap"><a class="header" href="#core-method-flatmap">Core Method: <code>flatMap</code></a></h4>
<p>This is the primary method for chaining dependent operations.</p>
<p><strong>Example: A Safe Database Workflow</strong></p>
<p>Imagine a workflow where you need to fetch a user, then use their ID to fetch their account, and finally use the account details to get their balance. Any of these steps could fail (e.g., return an empty <code>Optional</code>). With <code>flatMap</code>, the chain becomes clean and safe.</p>
<pre><code class="language-java">import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.Monad;
import org.higherkindedj.hkt.optional.OptionalMonad;
import java.util.Optional;
import static org.higherkindedj.hkt.optional.OptionalKindHelper.OPTIONAL;

// Mock data records and repository functions from the previous example...
record User(int id, String name) {}
record Account(int userId, String accountId) {}

public Kind&lt;Optional.Witness, User&gt; findUser(int id) { /* ... */ }
public Kind&lt;Optional.Witness, Account&gt; findAccount(User user) { /* ... */ }
public Kind&lt;Optional.Witness, Double&gt; getBalance(Account account) { /* ... */ }

// --- Get the Monad instance for Optional ---
Monad&lt;Optional.Witness&gt; monad = OptionalMonad.INSTANCE;

// --- Scenario 1: Successful workflow ---
Kind&lt;Optional.Witness, Double&gt; balanceSuccess = monad.flatMap(user -&gt;
    monad.flatMap(account -&gt;
        getBalance(account),
        findAccount(user)),
    findUser(1));

// Result: Optional[1000.0]
System.out.println(OPTIONAL.narrow(balanceSuccess));

// --- Scenario 2: Failing workflow (user not found) ---
Kind&lt;Optional.Witness, Double&gt; balanceFailure = monad.flatMap(user -&gt;
    /* this part is never executed */
    monad.flatMap(account -&gt; getBalance(account), findAccount(user)),
    findUser(2)); // This returns Optional.empty()

// The chain short-circuits immediately.
// Result: Optional.empty
System.out.println(OPTIONAL.narrow(balanceFailure));
</code></pre>
<p>The <code>flatMap</code> chain elegantly handles the "happy path" while also providing robust, short-circuiting logic for the failure cases, all without a single null check.</p>
<hr />
<h2 id="utility-methods"><a class="header" href="#utility-methods">Utility Methods</a></h2>
<p><code>Monad</code> also provides default methods for common tasks like debugging, conditional logic, and transforming results.</p>
<h3 id="flatmapiforelse"><a class="header" href="#flatmapiforelse"><code>flatMapIfOrElse</code></a></h3>
<p>This is the type-safe way to perform conditional branching in a monadic chain. It applies one of two functions based on a predicate, ensuring that both paths result in the same final type and avoiding runtime errors.</p>
<p>Let's imagine we only want to fetch accounts for "standard" users (ID &lt; 100).</p>
<pre><code class="language-java">// --- Get the Monad instance for Optional ---
Monad&lt;Optional.Witness&gt; monad = OptionalMonad.INSTANCE;

// A user who meets the condition
Kind&lt;Optional.Witness, User&gt; standardUser = OPTIONAL.widen(Optional.of(new User(1, "Alice")));
// A user who does not
Kind&lt;Optional.Witness, User&gt; premiumUser = OPTIONAL.widen(Optional.of(new User(101, "Bob")));

// --- Scenario 1: Predicate is true ---
Kind&lt;Optional.Witness, Account&gt; resultSuccess = monad.flatMapIfOrElse(
    user -&gt; user.id() &lt; 100,      // Predicate: user is standard
    user -&gt; findAccount(user),    // Action if true: find their account
    user -&gt; OPTIONAL.widen(Optional.empty()), // Action if false: return empty
    standardUser
);
// Result: Optional[Account[userId=1, accountId=acc-123]]
System.out.println(OPTIONAL.narrow(resultSuccess));


// --- Scenario 2: Predicate is false ---
Kind&lt;Optional.Witness, Account&gt; resultFailure = monad.flatMapIfOrElse(
    user -&gt; user.id() &lt; 100,
    user -&gt; findAccount(user),
    user -&gt; OPTIONAL.widen(Optional.empty()), // This path is taken
    premiumUser
);
// Result: Optional.empty
System.out.println(OPTIONAL.narrow(resultFailure));
</code></pre>
<h3 id="as"><a class="header" href="#as"><code>as</code></a></h3>
<p>Replaces the value inside a monad while preserving its effect (e.g., success or failure). This is useful when you only care <em>that</em> an operation succeeded, not what its result was.</p>
<pre><code class="language-java">// After finding a user, we just want a confirmation message.
Kind&lt;Optional.Witness, String&gt; successMessage = monad.as("User found successfully", findUser(1));

// Result: Optional["User found successfully"]
System.out.println(OPTIONAL.narrow(successMessage));

// If the user isn't found, the effect (empty Optional) is preserved.
Kind&lt;Optional.Witness, String&gt; failureMessage = monad.as("User found successfully", findUser(99));

// Result: Optional.empty
System.out.println(OPTIONAL.narrow(failureMessage));
</code></pre>
<h3 id="peek"><a class="header" href="#peek"><code>peek</code></a></h3>
<p>Allows you to perform a side-effect (like logging) on the value inside a monad without altering the flow. The original monadic value is always returned.</p>
<pre><code class="language-java">// Log the user's name if they are found
Kind&lt;Optional.Witness, User&gt; peekSuccess = monad.peek(
    user -&gt; System.out.println("LOG: Found user -&gt; " + user.name()),
    findUser(1)
);
// Console output: LOG: Found user -&gt; Alice
// Result: Optional[User[id=1, name=Alice]] (The original value is unchanged)
System.out.println("Return value: " + OPTIONAL.narrow(peekSuccess));


// If the user isn't found, the action is never executed.
Kind&lt;Optional.Witness, User&gt; peekFailure = monad.peek(
    user -&gt; System.out.println("LOG: Found user -&gt; " + user.name()),
    findUser(99)
);
// Console output: (nothing)
// Result: Optional.empty
System.out.println("Return value: " + OPTIONAL.narrow(peekFailure));
</code></pre>
<hr />
<h2 id="combining-multiple-monadic-values-flatmapn-"><a class="header" href="#combining-multiple-monadic-values-flatmapn-">Combining Multiple Monadic Values: <code>flatMapN</code> üîÑ</a></h2>
<p>Just as <code>Applicative</code> provides <code>map2</code>, <code>map3</code>, etc. for combining independent computations with a pure function, <code>Monad</code> provides <code>flatMap2</code>, <code>flatMap3</code>, <code>flatMap4</code>, and <code>flatMap5</code> for combining multiple monadic values where the combining function itself returns a monadic value.</p>
<p>These methods are perfect when you need to:</p>
<ul>
<li>Sequence multiple independent computations and then perform a final effectful operation</li>
<li>Validate multiple pieces of data together with an operation that may fail</li>
<li>Combine results from multiple sources with additional logic that may produce effects</li>
</ul>
<h3 id="flatmap2"><a class="header" href="#flatmap2"><code>flatMap2</code></a></h3>
<p>Combines two monadic values and applies a function that returns a new monadic value.</p>
<p><strong>Example: Validating and Combining Two Database Results</strong></p>
<pre><code class="language-java">import java.util.Optional;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.Monad;
import org.higherkindedj.hkt.optional.OptionalMonad;
import static org.higherkindedj.hkt.optional.OptionalKindHelper.OPTIONAL;

record User(int id, String name) {}
record Order(int userId, String item) {}
record UserOrder(User user, Order order) {}

// Mock repository functions
public Kind&lt;Optional.Witness, User&gt; findUser(int id) { /* ... */ }
public Kind&lt;Optional.Witness, Order&gt; findOrder(int orderId) { /* ... */ }

// Validation function that might fail
public Kind&lt;Optional.Witness, UserOrder&gt; validateAndCombine(User user, Order order) {
    if (order.userId() != user.id()) {
        return OPTIONAL.widen(Optional.empty()); // Validation failed
    }
    return OPTIONAL.widen(Optional.of(new UserOrder(user, order)));
}

Monad&lt;Optional.Witness&gt; monad = OptionalMonad.INSTANCE;

// Combine user and order, then validate
Kind&lt;Optional.Witness, UserOrder&gt; result = monad.flatMap2(
    findUser(1),
    findOrder(100),
    (user, order) -&gt; validateAndCombine(user, order)
);

// Result: Optional[UserOrder[...]] if valid, Optional.empty if any step fails
System.out.println(OPTIONAL.narrow(result));
</code></pre>
<h3 id="flatmap3-and-higher-arities"><a class="header" href="#flatmap3-and-higher-arities"><code>flatMap3</code> and Higher Arities</a></h3>
<p>For more complex scenarios, you can combine three, four, or five monadic values:</p>
<pre><code class="language-java">record Product(int id, String name, double price) {}
record Inventory(int productId, int quantity) {}

public Kind&lt;Optional.Witness, Product&gt; findProduct(int id) { /* ... */ }
public Kind&lt;Optional.Witness, Inventory&gt; checkInventory(int productId) { /* ... */ }

// Process an order with user, product, and inventory check
Kind&lt;Optional.Witness, String&gt; orderResult = monad.flatMap3(
    findUser(1),
    findProduct(100),
    checkInventory(100),
    (user, product, inventory) -&gt; {
        if (inventory.quantity() &lt;= 0) {
            return OPTIONAL.widen(Optional.empty()); // Out of stock
        }
        String confirmation = String.format(
            "Order confirmed for %s: %s (qty: %d)",
            user.name(), product.name(), inventory.quantity()
        );
        return OPTIONAL.widen(Optional.of(confirmation));
    }
);
</code></pre>
<h3 id="flatmapn-vs-mapn"><a class="header" href="#flatmapn-vs-mapn"><code>flatMapN</code> vs <code>mapN</code></a></h3>
<p>The key difference between <code>flatMapN</code> and <code>mapN</code> is:</p>
<ul>
<li><strong><code>mapN</code></strong> (from Applicative): The combining function returns a <strong>pure value</strong> (<code>(A, B) -&gt; C</code>)</li>
<li><strong><code>flatMapN</code></strong> (from Monad): The combining function returns a <strong>monadic value</strong> (<code>(A, B) -&gt; Kind&lt;M, C&gt;</code>)</li>
</ul>
<p>This makes <code>flatMapN</code> methods ideal when the combination of values needs to perform additional effects, such as:</p>
<ul>
<li>Additional validation that might fail</li>
<li>Database lookups based on combined criteria</li>
<li>Computations that may produce side effects</li>
<li>Operations that need to maintain monadic context</li>
</ul>
<pre><code class="language-java">// mapN: Pure combination
Kind&lt;Optional.Witness, String&gt; mapResult = monad.map2(
    findUser(1),
    findOrder(100),
    (user, order) -&gt; user.name() + " ordered " + order.item() // Pure function
);

// flatMapN: Effectful combination
Kind&lt;Optional.Witness, String&gt; flatMapResult = monad.flatMap2(
    findUser(1),
    findOrder(100),
    (user, order) -&gt; validateAndProcess(user, order) // Returns Optional
);
</code></pre>
<p>This pattern is especially powerful when combined with error-handling monads like <code>Either</code> or <code>Try</code>, where the combining function can itself fail with a meaningful error.</p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="monaderror-handling-errors-gracefully"><a class="header" href="#monaderror-handling-errors-gracefully">MonadError: Handling Errors Gracefully</a></h1>
<p>While a <code>Monad</code> is excellent for sequencing operations that might fail (like with <code>Optional</code> or <code>Either</code>), it doesn't provide a standardised way to <em>inspect</em> or <em>recover</em> from those failures. The <strong><code>MonadError</code></strong> type class fills this gap.</p>
<p>It's a specialised <code>Monad</code> that has a defined error type <code>E</code>, giving you a powerful and abstract API for raising and handling errors within any monadic workflow.</p>
<hr />
<h2 id="what-is-it-3"><a class="header" href="#what-is-it-3">What is it?</a></h2>
<p>A <strong><code>MonadError</code></strong> is a <code>Monad</code> that provides two additional, fundamental operations for working with failures:</p>
<ol>
<li><strong><code>raiseError(E error)</code></strong>: This allows you to construct a failed computation by lifting an error value <code>E</code> directly into the monadic context.</li>
<li><strong><code>handleErrorWith(Kind&lt;F, A&gt; fa, ...)</code></strong>: This is the recovery mechanism. It allows you to inspect a potential failure and provide a fallback computation to rescue the workflow.</li>
</ol>
<p>By abstracting over a specific error type <code>E</code>, <code>MonadError</code> allows you to write generic, resilient code that can work with any data structure capable of representing failure, such as <code>Either&lt;E, A&gt;</code>, <code>Try&lt;A&gt;</code> (where <code>E</code> is <code>Throwable</code>), or even custom error-handling monads.</p>
<p>The interface for <code>MonadError</code> in <code>hkj-api</code> extends <code>Monad</code>:</p>
<pre><code class="language-java">@NullMarked
public interface MonadError&lt;F, E&gt; extends Monad&lt;F&gt; {

  &lt;A&gt; @NonNull Kind&lt;F, A&gt; raiseError(@Nullable final E error);

  &lt;A&gt; @NonNull Kind&lt;F, A&gt; handleErrorWith(
      final Kind&lt;F, A&gt; ma,
      final Function&lt;? super E, ? extends Kind&lt;F, A&gt;&gt; handler);

  // Default recovery methods like handleError, recover, etc. are also provided
  default &lt;A&gt; @NonNull Kind&lt;F, A&gt; handleError(
      final Kind&lt;F, A&gt; ma,
      final Function&lt;? super E, ? extends A&gt; handler) {
    return handleErrorWith(ma, error -&gt; of(handler.apply(error)));
  }
}
</code></pre>
<hr />
<h3 id="why-is-it-useful-4"><a class="header" href="#why-is-it-useful-4">Why is it useful?</a></h3>
<p><code>MonadError</code> formalises the pattern of "try-catch" in a purely functional way. It lets you build complex workflows that need to handle specific types of errors without coupling your logic to a concrete implementation like <code>Either</code> or <code>Try</code>. You can write a function once, and it will work seamlessly with any data type that has a <code>MonadError</code> instance.</p>
<p>This is incredibly useful for building robust applications, separating business logic from error-handling logic, and providing sensible fallbacks when operations fail.</p>
<p><strong>Example: A Resilient Division Workflow</strong></p>
<p>Let's model a division operation that can fail with a specific error message. We'll use <code>Either&lt;String, A&gt;</code> as our data type, which is a perfect fit for <code>MonadError</code>.</p>
<pre><code class="language-java">import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.either.Either;
import org.higherkindedj.hkt.either.EitherMonad;
import static org.higherkindedj.hkt.either.EitherKindHelper.EITHER;

// --- Get the MonadError instance for Either&lt;String, ?&gt; ---
MonadError&lt;Either.Witness&lt;String&gt;, String&gt; monadError = EitherMonad.instance();

// A function that performs division, raising a specific error on failure
public Kind&lt;Either.Witness&lt;String&gt;, Integer&gt; safeDivide(int a, int b) {
    if (b == 0) {
        return monadError.raiseError("Cannot divide by zero!");
    }
    return monadError.of(a / b);
}

// --- Scenario 1: A successful division ---
Kind&lt;Either.Witness&lt;String&gt;, Integer&gt; success = safeDivide(10, 2);

// Result: Right(5)
System.out.println(EITHER.narrow(success));


// --- Scenario 2: A failed division ---
Kind&lt;Either.Witness&lt;String&gt;, Integer&gt; failure = safeDivide(10, 0);

// Result: Left(Cannot divide by zero!)
System.out.println(EITHER.narrow(failure));


// --- Scenario 3: Recovering from the failure ---
// We can use handleErrorWith to catch the error and return a fallback value.
Kind&lt;Either.Witness&lt;String&gt;, Integer&gt; recovered = monadError.handleErrorWith(
    failure,
    errorMessage -&gt; {
        System.out.println("Caught an error: " + errorMessage);
        return monadError.of(0); // Recover with a default value of 0
    }
);

// Result: Right(0)
System.out.println(EITHER.narrow(recovered));
</code></pre>
<p>In this example, <code>raiseError</code> allows us to create the failure case in a clean, declarative way, while <code>handleErrorWith</code> provides a powerful mechanism for recovery, making our code more resilient and predictable.</p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="semigroup-and-monoid-foundational-type-classes"><a class="header" href="#semigroup-and-monoid-foundational-type-classes">Semigroup and Monoid: Foundational Type Classes</a></h1>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="functional/semigroup_and_monoid.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>The fundamental building blocks for combining data: Semigroup and Monoid</li>
<li>How associative operations enable parallel and sequential data processing</li>
<li>Using Monoids for error accumulation in validation scenarios</li>
<li>Practical applications with String concatenation, integer addition, and boolean operations</li>
<li>Advanced Monoid operations: combining collections, repeated application, and identity testing</li>
<li>Working with numeric types: Long and Double monoid instances</li>
<li>Optional-based monoids for data aggregation: first, last, maximum, and minimum</li>
<li>How these abstractions power Foldable operations and validation workflows</li>
</ul>
</div>
</div>
<p>In functional programming, we often use <strong>type classes</strong> to define common behaviours that can be applied to a wide range of data types. These act as interfaces that allow us to write more abstract and reusable code. In <code>higher-kinded-j</code>, we provide a number of these type classes to enable powerful functional patterns.</p>
<p>Here we will cover two foundational type classes: <code>Semigroup</code> and <code>Monoid</code>. Understanding these will give you a solid foundation for many of the more advanced concepts in the library.</p>
<hr />
<h2 id="semigroupa-1"><a class="header" href="#semigroupa-1"><strong><code>Semigroup&lt;A&gt;</code></strong></a></h2>
<p>A <strong><code>Semigroup</code></strong> is one of the simplest and most fundamental type classes. It provides a blueprint for types that have a single, associative way of being combined.</p>
<h3 id="what-is-it-4"><a class="header" href="#what-is-it-4">What is it?</a></h3>
<p>A <code>Semigroup</code> is a type class for any data type that has a <code>combine</code> operation. This operation takes two values of the same type and merges them into a single value of that type. The only rule is that this operation must be <strong>associative</strong>.</p>
<p>This means that for any values <code>a</code>, <code>b</code>, and <code>c</code>:</p>
<p><code>(a.combine(b)).combine(c)</code> must be equal to <code>a.combine(b.combine(c))</code></p>
<p>The interface for <code>Semigroup</code> in <code>hkj-api</code> is as follows:</p>
<pre><code class="language-java">public interface Semigroup&lt;A&gt; {
    A combine(A a1, A a2);
}
</code></pre>
<h3 id="common-instances-the-semigroups-utility"><a class="header" href="#common-instances-the-semigroups-utility">Common Instances: The <code>Semigroups</code> Utility</a></h3>
<p>To make working with <code>Semigroup</code> easier, <code>higher-kinded-j</code> provides a <code>Semigroups</code> utility interface with static factory methods for common instances.</p>
<pre><code class="language-java">// Get a Semigroup for concatenating Strings
Semigroup&lt;String&gt; stringConcat = Semigroups.string();

// Get a Semigroup for concatenating Strings with a delimiter
Semigroup&lt;String&gt; stringConcatDelimited = Semigroups.string(", ");

// Get a Semigroup for concatenating Lists
Semigroup&lt;List&lt;Integer&gt;&gt; listConcat = Semigroups.list();
</code></pre>
<h3 id="where-is-it-used-in-higher-kinded-j"><a class="header" href="#where-is-it-used-in-higher-kinded-j">Where is it used in <code>higher-kinded-j</code>?</a></h3>
<p>The primary and most powerful use case for <code>Semigroup</code> in this library is to enable <strong>error accumulation</strong> with the <strong><code>Validated</code></strong> data type.</p>
<p>When you use the <code>Applicative</code> instance for <code>Validated</code>, you must provide a <code>Semigroup</code> for the error type. This tells the applicative how to combine errors when multiple invalid computations occur.</p>
<p><strong>Example: Accumulating Validation Errors</strong></p>
<pre><code class="language-java">// Create an applicative for Validated that accumulates String errors by joining them.
Applicative&lt;Validated.Witness&lt;String&gt;&gt; applicative =
    ValidatedMonad.instance(Semigroups.string("; "));

// Two invalid results
Validated&lt;String, Integer&gt; invalid1 = Validated.invalid("Field A is empty");
Validated&lt;String, Integer&gt; invalid2 = Validated.invalid("Field B is not a number");

// Combine them using the applicative's map2 method
Kind&lt;Validated.Witness&lt;String&gt;, Integer&gt; result =
    applicative.map2(
        VALIDATED.widen(invalid1),
        VALIDATED.widen(invalid2),
        (val1, val2) -&gt; val1 + val2
    );

// The errors are combined using our Semigroup
// Result: Invalid("Field A is empty; Field B is not a number")
System.out.println(VALIDATED.narrow(result));
</code></pre>
<hr />
<h2 id="monoida-1"><a class="header" href="#monoida-1"><strong><code>Monoid&lt;A&gt;</code></strong></a></h2>
<p>A <strong><code>Monoid</code></strong> is a <code>Semigroup</code> with a special "identity" or "empty" element. This makes it even more powerful, as it provides a way to have a "starting" or "default" value.</p>
<h3 id="what-is-it-5"><a class="header" href="#what-is-it-5">What is it?</a></h3>
<p>A <code>Monoid</code> is a type class for any data type that has an associative <code>combine</code> operation (from <code>Semigroup</code>) and an <code>empty</code> value. This <code>empty</code> value is a special element that, when combined with any other value, returns that other value.</p>
<p>This is known as the <strong>identity law</strong>. For any value <code>a</code>:</p>
<p><code>a.combine(empty())</code> must be equal to <code>a``empty().combine(a)</code> must be equal to <code>a</code></p>
<p>The interface for <code>Monoid</code> in <code>hkj-api</code> extends <code>Semigroup</code>:</p>
<pre><code class="language-java">public interface Monoid&lt;A&gt; extends Semigroup&lt;A&gt; {
    A empty();
}
</code></pre>
<h3 id="common-instances-the-monoids-utility"><a class="header" href="#common-instances-the-monoids-utility">Common Instances: The <code>Monoids</code> Utility</a></h3>
<p>Similar to <code>Semigroups</code>, the library provides a <code>Monoids</code> utility interface for creating common instances.</p>
<pre><code class="language-java">// Get a Monoid for integer addition (empty = 0)
Monoid&lt;Integer&gt; intAddition = Monoids.integerAddition();

// Get a Monoid for String concatenation (empty = "")
Monoid&lt;String&gt; stringMonoid = Monoids.string();

// Get a Monoid for boolean AND (empty = true)
Monoid&lt;Boolean&gt; booleanAnd = Monoids.booleanAnd();
</code></pre>
<h3 id="where-it-is-used-in-higher-kinded-j"><a class="header" href="#where-it-is-used-in-higher-kinded-j">Where it is used in <code>higher-kinded-j</code></a></h3>
<p>A <code>Monoid</code> is essential for <strong>folding</strong> (or reducing) a data structure. The <code>empty</code> element provides a safe starting value, which means you can correctly fold a collection that might be empty.</p>
<p>This is formalised in the <strong><code>Foldable</code></strong> typeclass, which has a <code>foldMap</code> method. This method maps every element in a structure to a monoidal type and then combines all the results.</p>
<p><strong>Example: Using <code>foldMap</code> with different Monoids</strong></p>
<pre><code class="language-java">List&lt;Integer&gt; numbers = List.of(1, 2, 3, 4, 5);
Kind&lt;ListKind.Witness, Integer&gt; numbersKind = LIST.widen(numbers);

// 1. Sum the list using the integer addition monoid
Integer sum = ListTraverse.INSTANCE.foldMap(
    Monoids.integerAddition(),
    Function.identity(),
    numbersKind
); // Result: 15

// 2. Concatenate the numbers as strings
String concatenated = ListTraverse.INSTANCE.foldMap(
    Monoids.string(),
    String::valueOf,
    numbersKind
); // Result: "12345"
</code></pre>
<hr />
<h2 id="advanced-monoid-operations"><a class="header" href="#advanced-monoid-operations"><strong>Advanced Monoid Operations</strong></a></h2>
<p>The <code>Monoid</code> interface provides several powerful default methods that build upon the basic <code>combine</code> and <code>empty</code> operations. These methods handle common aggregation patterns and make working with collections much more convenient.</p>
<h3 id="combineall-aggregating-collections"><a class="header" href="#combineall-aggregating-collections"><code>combineAll</code>: Aggregating Collections</a></h3>
<p>The <code>combineAll</code> method takes an iterable collection and combines all its elements using the monoid's operation. If the collection is empty, it returns the identity element.</p>
<pre><code class="language-java">Monoid&lt;Integer&gt; sum = Monoids.integerAddition();
List&lt;Integer&gt; salesData = List.of(120, 450, 380, 290);

Integer totalSales = sum.combineAll(salesData);
// Result: 1240

// Works safely with empty collections
Integer emptyTotal = sum.combineAll(Collections.emptyList());
// Result: 0 (the empty value)
</code></pre>
<p>This is particularly useful for batch processing scenarios where you need to aggregate data from multiple sources:</p>
<pre><code class="language-java">// Combining log messages
Monoid&lt;String&gt; logMonoid = Monoids.string();
List&lt;String&gt; logMessages = loadLogMessages();
String combinedLog = logMonoid.combineAll(logMessages);

// Merging configuration sets
Monoid&lt;Set&lt;String&gt;&gt; configMonoid = Monoids.set();
List&lt;Set&lt;String&gt;&gt; featureFlags = List.of(
    Set.of("feature-a", "feature-b"),
    Set.of("feature-b", "feature-c"),
    Set.of("feature-d")
);
Set&lt;String&gt; allFlags = configMonoid.combineAll(featureFlags);
// Result: ["feature-a", "feature-b", "feature-c", "feature-d"]
</code></pre>
<h3 id="combinen-repeated-application"><a class="header" href="#combinen-repeated-application"><code>combineN</code>: Repeated Application</a></h3>
<p>The <code>combineN</code> method combines a value with itself <code>n</code> times. This is useful for scenarios where you need to apply the same value repeatedly:</p>
<pre><code class="language-java">Monoid&lt;Integer&gt; product = Monoids.integerMultiplication();

// Calculate 2^5 using multiplication monoid
Integer result = product.combineN(2, 5);
// Result: 32 (2 * 2 * 2 * 2 * 2)

// Repeat a string pattern
Monoid&lt;String&gt; stringMonoid = Monoids.string();
String border = stringMonoid.combineN("=", 50);
// Result: "=================================================="

// Build a list with repeated elements
Monoid&lt;List&lt;String&gt;&gt; listMonoid = Monoids.list();
List&lt;String&gt; repeated = listMonoid.combineN(List.of("item"), 3);
// Result: ["item", "item", "item"]
</code></pre>
<p><strong>Special cases:</strong></p>
<ul>
<li>When <code>n = 0</code>, returns the empty value</li>
<li>When <code>n = 1</code>, returns the value unchanged</li>
<li>When <code>n &lt; 0</code>, throws <code>IllegalArgumentException</code></li>
</ul>
<h3 id="isempty-identity-testing"><a class="header" href="#isempty-identity-testing"><code>isEmpty</code>: Identity Testing</a></h3>
<p>The <code>isEmpty</code> method tests whether a given value equals the identity element of the monoid:</p>
<pre><code class="language-java">Monoid&lt;Integer&gt; sum = Monoids.integerAddition();
Monoid&lt;Integer&gt; product = Monoids.integerMultiplication();

sum.isEmpty(0);      // true (0 is the identity for addition)
sum.isEmpty(5);      // false

product.isEmpty(1);  // true (1 is the identity for multiplication)
product.isEmpty(0);  // false

Monoid&lt;String&gt; stringMonoid = Monoids.string();
stringMonoid.isEmpty("");     // true
stringMonoid.isEmpty("text"); // false
</code></pre>
<p>This is particularly useful for optimisation and conditional logic:</p>
<pre><code class="language-java">public void processIfNotEmpty(Monoid&lt;String&gt; monoid, String value) {
    if (!monoid.isEmpty(value)) {
        // Only process non-empty values
        performExpensiveOperation(value);
    }
}
</code></pre>
<hr />
<h2 id="working-with-numeric-types"><a class="header" href="#working-with-numeric-types"><strong>Working with Numeric Types</strong></a></h2>
<p>The <code>Monoids</code> utility provides comprehensive support for numeric operations beyond just <code>Integer</code>. This is particularly valuable for financial calculations, statistical operations, and scientific computing.</p>
<h3 id="long-monoids"><a class="header" href="#long-monoids">Long Monoids</a></h3>
<p>For working with large numeric values or high-precision calculations:</p>
<pre><code class="language-java">// Long addition for counting large quantities
Monoid&lt;Long&gt; longSum = Monoids.longAddition();
List&lt;Long&gt; userCounts = List.of(1_500_000L, 2_300_000L, 890_000L);
Long totalUsers = longSum.combineAll(userCounts);
// Result: 4,690,000

// Long multiplication for compound calculations
Monoid&lt;Long&gt; longProduct = Monoids.longMultiplication();
Long compound = longProduct.combineN(2L, 20);
// Result: 1,048,576 (2^20)
</code></pre>
<h3 id="double-monoids"><a class="header" href="#double-monoids">Double Monoids</a></h3>
<p>For floating-point arithmetic and statistical computations:</p>
<pre><code class="language-java">// Double addition for financial calculations
Monoid&lt;Double&gt; dollarSum = Monoids.doubleAddition();
List&lt;Double&gt; expenses = List.of(49.99, 129.50, 89.99);
Double totalExpenses = dollarSum.combineAll(expenses);
// Result: 269.48

// Double multiplication for compound interest
Monoid&lt;Double&gt; growth = Monoids.doubleMultiplication();
Double interestRate = 1.05; // 5% per year
Double compoundGrowth = growth.combineN(interestRate, 10);
// Result: ‚âà1.629 (after 10 years)
</code></pre>
<p><strong>Practical Example: Statistical Calculations</strong></p>
<pre><code class="language-java">public class Statistics {

    public static double calculateMean(List&lt;Double&gt; values) {
        if (values.isEmpty()) {
            throw new IllegalArgumentException("Cannot calculate mean of an empty list.");
        }

        Monoid&lt;Double&gt; sum = Monoids.doubleAddition();
        Double total = sum.combineAll(values);
        return total / values.size();
    }

    public static double calculateProduct(List&lt;Double&gt; factors) {
        Monoid&lt;Double&gt; product = Monoids.doubleMultiplication();
        return product.combineAll(factors);
    }
}

// Usage
List&lt;Double&gt; measurements = List.of(23.5, 24.1, 23.8, 24.3);
double average = Statistics.calculateMean(measurements);
// Result: 23.925
</code></pre>
<hr />
<h2 id="optional-monoids-for-data-aggregation"><a class="header" href="#optional-monoids-for-data-aggregation"><strong>Optional Monoids for Data Aggregation</strong></a></h2>
<p>One of the most powerful features of the <code>Monoids</code> utility is its support for <code>Optional</code>-based aggregation. These monoids elegantly handle the common pattern of finding the "best" value from a collection of optional results.</p>
<h3 id="firstoptional-and-lastoptional"><a class="header" href="#firstoptional-and-lastoptional"><code>firstOptional</code> and <code>lastOptional</code></a></h3>
<p>These monoids select the first or last non-empty optional value, making them perfect for fallback chains and priority-based selection:</p>
<pre><code class="language-java">Monoid&lt;Optional&lt;String&gt;&gt; first = Monoids.firstOptional();
Monoid&lt;Optional&lt;String&gt;&gt; last = Monoids.lastOptional();

List&lt;Optional&lt;String&gt;&gt; configs = List.of(
    Optional.empty(),           // Missing config
    Optional.of("default.conf"), // Found!
    Optional.of("user.conf")    // Also found
);

// Get first available configuration
Optional&lt;String&gt; primaryConfig = first.combineAll(configs);
// Result: Optional["default.conf"]

// Get last available configuration
Optional&lt;String&gt; latestConfig = last.combineAll(configs);
// Result: Optional["user.conf"]
</code></pre>
<p><strong>Practical Example: Configuration Fallback Chain</strong></p>
<pre><code class="language-java">public class ConfigLoader {

    public Optional&lt;Config&gt; loadConfig() {
        Monoid&lt;Optional&lt;Config&gt;&gt; firstAvailable = Monoids.firstOptional();

        return firstAvailable.combineAll(List.of(
            loadFromEnvironment(),     // Try environment variables first
            loadFromUserHome(),        // Then user's home directory
            loadFromWorkingDir(),      // Then current directory
            loadDefaultConfig()        // Finally, use defaults
        ));
    }

    private Optional&lt;Config&gt; loadFromEnvironment() {
        return Optional.ofNullable(System.getenv("APP_CONFIG"))
            .map(this::parseConfig);
    }

    private Optional&lt;Config&gt; loadFromUserHome() {
        Path userConfig = Paths.get(System.getProperty("user.home"), ".apprc");
        return Files.exists(userConfig)
            ? Optional.of(parseConfigFile(userConfig))
            : Optional.empty();
    }

    // ... other loaders
}
</code></pre>
<h3 id="maximum-and-minimum"><a class="header" href="#maximum-and-minimum"><code>maximum</code> and <code>minimum</code></a></h3>
<p>These monoids find the maximum or minimum value from a collection of optional values. They work with any <code>Comparable</code> type or accept a custom <code>Comparator</code>:</p>
<pre><code class="language-java">Monoid&lt;Optional&lt;Integer&gt;&gt; max = Monoids.maximum();
Monoid&lt;Optional&lt;Integer&gt;&gt; min = Monoids.minimum();

List&lt;Optional&lt;Integer&gt;&gt; scores = List.of(
    Optional.of(85),
    Optional.empty(),      // Missing data
    Optional.of(92),
    Optional.of(78),
    Optional.empty()
);

Optional&lt;Integer&gt; highestScore = max.combineAll(scores);
// Result: Optional[92]

Optional&lt;Integer&gt; lowestScore = min.combineAll(scores);
// Result: Optional[78]
</code></pre>
<p><strong>Using Custom Comparators</strong></p>
<p>For more complex types, you can provide a custom comparator:</p>
<pre><code class="language-java">public record Product(String name, double price) {}

// Find most expensive product
Monoid&lt;Optional&lt;Product&gt;&gt; mostExpensive =
    Monoids.maximum(Comparator.comparing(Product::price));

List&lt;Optional&lt;Product&gt;&gt; products = List.of(
    Optional.of(new Product("Widget", 29.99)),
    Optional.empty(),
    Optional.of(new Product("Gadget", 49.99)),
    Optional.of(new Product("Gizmo", 19.99))
);

Optional&lt;Product&gt; priciest = mostExpensive.combineAll(products);
// Result: Optional[Product("Gadget", 49.99)]

// Find product with shortest name
Monoid&lt;Optional&lt;Product&gt;&gt; shortestName =
    Monoids.minimum(Comparator.comparing(p -&gt; p.name().length()));

Optional&lt;Product&gt; shortest = shortestName.combineAll(products);
// Result: Optional[Product("Gizmo", 19.99)]
</code></pre>
<p><strong>Practical Example: Finding Best Offers</strong></p>
<pre><code class="language-java">public class PriceComparison {

    public record Offer(String vendor, BigDecimal price, boolean inStock)
        implements Comparable&lt;Offer&gt; {

        @Override
        public int compareTo(Offer other) {
            return this.price.compareTo(other.price);
        }
    }

    public Optional&lt;Offer&gt; findBestOffer(List&lt;String&gt; vendors, String productId) {
        Monoid&lt;Optional&lt;Offer&gt;&gt; cheapest = Monoids.minimum();

        List&lt;Optional&lt;Offer&gt;&gt; offers = vendors.stream()
            .map(vendor -&gt; fetchOffer(vendor, productId))
            .filter(opt -&gt; opt.map(Offer::inStock).orElse(false)) // Only in-stock items
            .collect(Collectors.toList());

        return cheapest.combineAll(offers);
    }

    private Optional&lt;Offer&gt; fetchOffer(String vendor, String productId) {
        // API call to get offer from vendor
        // Returns Optional.empty() if unavailable
    }
}
</code></pre>
<p><strong>When Both Optionals are Empty</strong></p>
<p>It's worth noting that these monoids handle empty collections gracefully:</p>
<pre><code class="language-java">Monoid&lt;Optional&lt;Integer&gt;&gt; max = Monoids.maximum();

List&lt;Optional&lt;Integer&gt;&gt; allEmpty = List.of(
    Optional.empty(),
    Optional.empty()
);

Optional&lt;Integer&gt; result = max.combineAll(allEmpty);
// Result: Optional.empty()

// Also works with empty list
Optional&lt;Integer&gt; emptyResult = max.combineAll(Collections.emptyList());
// Result: Optional.empty()
</code></pre>
<p>This makes them perfect for aggregation pipelines where you're not certain data will be present, but you want to find the best available value if any exists.</p>
<hr />
<h2 id="conclusion"><a class="header" href="#conclusion"><strong>Conclusion</strong></a></h2>
<p>Semigroups and Monoids are deceptively simple abstractions that unlock powerful patterns for data combination and aggregation. By understanding these type classes, you gain:</p>
<ul>
<li><strong>Composability</strong>: Build complex aggregations from simple, reusable pieces</li>
<li><strong>Type Safety</strong>: Let the compiler ensure your combinations are valid</li>
<li><strong>Flexibility</strong>: Swap monoids to get different behaviours from the same code</li>
<li><strong>Elegance</strong>: Express data aggregation intent clearly and concisely</li>
</ul>
<p>The new utility methods (<code>combineAll</code>, <code>combineN</code>, <code>isEmpty</code>) and expanded instance library (numeric types, Optional-based aggregations) make these abstractions even more practical for everyday Java development.</p>
<p><strong>Further Reading:</strong></p>
<ul>
<li><a href="functional/foldable_and_traverse.html">Foldable and Traverse</a> - See how Monoids power folding operations</li>
<li><a href="functional/applicative.html">Applicative</a> - Learn how Semigroups enable error accumulation with Validated</li>
<li><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/Optional.html">Java Optional Documentation</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="foldable--traverse-reducing-a-structure-to-a-summary"><a class="header" href="#foldable--traverse-reducing-a-structure-to-a-summary">Foldable &amp; Traverse: Reducing a Structure to a Summary</a></h1>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="functional/foldable_and_traverse.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to reduce any data structure to a summary value using <code>foldMap</code></li>
<li>The power of swapping Monoids to get different aggregations from the same data</li>
<li>Turning effects "inside-out" with <code>traverse</code> operations</li>
<li>Validating entire collections and collecting all errors at once</li>
<li>The relationship between <code>sequence</code> and <code>traverse</code> for effectful operations</li>
</ul>
</div>
</div>
<p>The <strong><code>Foldable</code></strong> typeclass represents one of the most common and powerful patterns in functional programming: <strong>reducing a data structure to a single summary value</strong>. If you've ever calculated the sum of a list of numbers or concatenated a list of strings, you've performed a fold.</p>
<p><code>Foldable</code> abstracts this pattern, allowing you to write generic code that can aggregate any data structure that knows how to be folded.</p>
<hr />
<h2 id="what-is-it-6"><a class="header" href="#what-is-it-6">What is it?</a></h2>
<p>A typeclass is <code>Foldable</code> if it can be "folded up" from left to right into a summary value. The key to this process is the <strong><code>Monoid</code></strong>, which provides two essential things:</p>
<ol>
<li>An <strong><code>empty</code></strong> value to start with (e.g., <code>0</code> for addition).</li>
<li>A <strong><code>combine</code></strong> operation to accumulate the results (e.g., <code>+</code>).</li>
</ol>
<p>The core method of the <code>Foldable</code> typeclass is <strong><code>foldMap</code></strong>.</p>
<h3 id="the-foldmap-method"><a class="header" href="#the-foldmap-method">The <code>foldMap</code> Method</a></h3>
<p><code>foldMap</code> is a powerful operation that does two things in one step:</p>
<ol>
<li>It <strong>maps</strong> each element in the data structure to a value of a monoidal type.</li>
<li>It <strong>folds</strong> (combines) all of those monoidal values into a final result.</li>
</ol>
<p>The interface for <code>Foldable</code> in <code>hkj-api</code> is as follows:</p>
<pre><code class="language-java">public interface Foldable&lt;F&gt; {
  &lt;A, M&gt; M foldMap(
      Monoid&lt;M&gt; monoid,
      Function&lt;? super A, ? extends M&gt; f,
      Kind&lt;F, A&gt; fa
  );
}
</code></pre>
<hr />
<h3 id="why-is-it-useful-5"><a class="header" href="#why-is-it-useful-5">Why is it useful?</a></h3>
<p><code>Foldable</code> allows you to perform powerful aggregations on any data structure without needing to know its internal representation. By simply swapping out the <code>Monoid</code>, you can get completely different summaries from the same data.</p>
<p>Let's see this in action with <code>List</code>, which has a <code>Foldable</code> instance provided by <code>ListTraverse</code>.</p>
<p><strong>Example: Aggregating a List with Different Monoids</strong></p>
<pre><code class="language-java">// Our data
List&lt;Integer&gt; numbers = List.of(1, 2, 3, 4, 5);
Kind&lt;ListKind.Witness, Integer&gt; numbersKind = LIST.widen(numbers);

// Our Foldable instance for List
Foldable&lt;ListKind.Witness&gt; listFoldable = ListTraverse.INSTANCE;

// --- Scenario 1: Sum the numbers ---
// We use the integer addition monoid (empty = 0, combine = +)
Integer sum = listFoldable.foldMap(
    Monoids.integerAddition(),
    Function.identity(), // Map each number to itself
    numbersKind
);
// Result: 15

// --- Scenario 2: Check if all numbers are positive ---
// We map each number to a boolean and use the "AND" monoid (empty = true, combine = &amp;&amp;)
Boolean allPositive = listFoldable.foldMap(
    Monoids.booleanAnd(),
    num -&gt; num &gt; 0,
    numbersKind
);
// Result: true

// --- Scenario 3: Convert to strings and concatenate ---
// We map each number to a string and use the string monoid (empty = "", combine = +)
String asString = listFoldable.foldMap(
    Monoids.string(),
    String::valueOf,
    numbersKind
);
// Result: "12345"
</code></pre>
<p>As you can see, <code>foldMap</code> provides a single, abstract way to perform a wide variety of aggregations, making your code more declarative and reusable.</p>
<hr />
<h1 id="traverse-effectful-folding"><a class="header" href="#traverse-effectful-folding">Traverse: Effectful Folding</a></h1>
<p>The <strong><code>Traverse</code></strong> typeclass is a powerful extension of <code>Foldable</code> and <code>Functor</code>. It allows you to iterate over a data structure, but with a twist: at each step, you can perform an <strong>effectful</strong> action and then collect all the results back into a single effect.</p>
<p>This is one of the most useful typeclasses for real-world applications, as it elegantly handles scenarios like validating all items in a list, fetching data for each ID in a collection, and much more.</p>
<hr />
<h2 id="what-is-it-7"><a class="header" href="#what-is-it-7">What is it?</a></h2>
<p>A typeclass is <code>Traverse</code> if it can be "traversed" from left to right. The key to this process is the <strong><code>Applicative</code></strong>, which defines how to sequence the effects at each step.</p>
<p>The core method of the <code>Traverse</code> typeclass is <strong><code>traverse</code></strong>.</p>
<h3 id="the-traverse-method"><a class="header" href="#the-traverse-method">The <code>traverse</code> Method</a></h3>
<p>The <code>traverse</code> method takes a data structure and a function that maps each element to an effectful computation (wrapped in an <code>Applicative</code> like <code>Validated</code>, <code>Optional</code>, or <code>Either</code>). It then runs these effects in sequence and collects the results.</p>
<p>The true power of <code>traverse</code> is that it can turn a structure of effects "inside-out". For example, it can transform a <code>List&lt;Validated&lt;E, A&gt;&gt;</code> into a single <code>Validated&lt;E, List&lt;A&gt;&gt;</code>.</p>
<p>The interface for <code>Traverse</code> in <code>hkj-api</code> extends <code>Functor</code> and <code>Foldable</code>:</p>
<p><strong>Java</strong></p>
<pre><code>public interface Traverse&lt;T&gt; extends Functor&lt;T&gt;, Foldable&lt;T&gt; {
  &lt;F, A, B&gt; Kind&lt;F, Kind&lt;T, B&gt;&gt; traverse(
      Applicative&lt;F&gt; applicative,
      Function&lt;A, Kind&lt;F, B&gt;&gt; f,
      Kind&lt;T, A&gt; ta
  );
  //... sequenceA method also available
}
</code></pre>
<hr />
<h3 id="why-is-it-useful-6"><a class="header" href="#why-is-it-useful-6">Why is it useful?</a></h3>
<p><code>Traverse</code> abstracts away the boilerplate of iterating over a collection, performing a failable action on each element, and then correctly aggregating the results.</p>
<p><strong>Example: Validating a List of Promo Codes</strong></p>
<p>Imagine you have a list of promo codes, and you want to validate each one. Your validation function returns a <code>Validated&lt;String, PromoCode&gt;</code>. Without <code>traverse</code>, you'd have to write a manual loop, collect all the errors, and handle the logic yourself.</p>
<p>With <code>traverse</code>, this becomes a single, elegant expression.</p>
<p><strong>Java</strong></p>
<pre><code>// Our validation function
public Kind&lt;Validated.Witness&lt;String&gt;, String&gt; validateCode(String code) {
    if (code.startsWith("VALID")) {
        return VALIDATED.widen(Validated.valid(code));
    }
    return VALIDATED.widen(Validated.invalid("'" + code + "' is not a valid code"));
}

// Our data
List&lt;String&gt; codes = List.of("VALID-A", "EXPIRED", "VALID-B", "INVALID");
Kind&lt;ListKind.Witness, String&gt; codesKind = LIST.widen(codes);

// The Applicative for Validated, using a Semigroup to join errors
Applicative&lt;Validated.Witness&lt;String&gt;&gt; validatedApplicative =
    ValidatedMonad.instance(Semigroups.string("; "));

// --- Traverse the list ---
Kind&lt;Validated.Witness&lt;String&gt;, Kind&lt;ListKind.Witness, String&gt;&gt; result =
    ListTraverse.INSTANCE.traverse(
        validatedApplicative,
        this::validateCode,
        codesKind
    );

// The result is a single Validated instance with accumulated errors.
// Result: Invalid("'EXPIRED' is not a valid code; 'INVALID' is not a valid code")
System.out.println(VALIDATED.narrow(result));
</code></pre>
<h3 id="sequencea"><a class="header" href="#sequencea"><code>sequenceA</code></a></h3>
<p><code>Traverse</code> also provides <code>sequenceA</code>, which is a specialised version of <code>traverse</code>. It's used when you already have a data structure containing effects (e.g., a <code>List&lt;Optional&lt;A&gt;&gt;</code>) and you want to flip it into a single effect containing the data structure (<code>Optional&lt;List&lt;A&gt;&gt;</code>).</p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="monadzero"><a class="header" href="#monadzero">MonadZero</a></h1>
<p>The <code>MonadZero</code> is a more advanced type class that extends both <code>Monad</code> and <code>Alternative</code> to combine the power of monadic bind with choice operations. It includes the concept of a "zero" or "empty" element and is designed for monads that can represent failure, absence, or emptiness, allowing them to be used in filtering operations and alternative chains.</p>
<p>The interface for MonadZero in hkj-api extends Monad and Alternative:</p>
<pre><code class="language-java">public interface MonadZero&lt;F&gt; extends Monad&lt;F&gt;, Alternative&lt;F&gt; {
    &lt;A&gt; Kind&lt;F, A&gt; zero();

    @Override
    default &lt;A&gt; Kind&lt;F, A&gt; empty() {
        return zero();
    }
}
</code></pre>
<h3 id="why-is-it-useful-7"><a class="header" href="#why-is-it-useful-7">Why is it useful?</a></h3>
<p>A <code>Monad</code> provides a way to sequence computations within a context (<code>flatMap</code>, <code>map</code>, <code>of</code>). An <code>Alternative</code> provides choice and failure operations (<code>empty()</code>, <code>orElse()</code>). A <code>MonadZero</code> combines both:</p>
<ul>
<li><code>zero()</code>: Returns the "empty" or "zero" element for the monad (implements <code>empty()</code> from Alternative).</li>
<li><code>orElse()</code>: Combines two alternatives (inherited from Alternative).</li>
<li><code>guard()</code>: Conditional success helper (inherited from Alternative).</li>
</ul>
<p>This <code>zero</code> element acts as an absorbing element in a monadic sequence, similar to how multiplying by zero results in zero. If a computation results in a <code>zero</code>, subsequent operations in the chain are typically skipped.</p>
<p><code>MonadZero</code> is particularly useful for making for-comprehensions more powerful. When you are working with a monad that has a <code>MonadZero</code> instance, you can use a <code>when()</code> clause to filter results within the comprehension.</p>
<p><strong>Key Implementations in this Project:</strong></p>
<ul>
<li>For <strong>List</strong>, <code>zero()</code> returns an empty list <code>[]</code>.</li>
<li>For <strong>Maybe</strong>, <code>zero()</code> returns <code>Nothing</code>.</li>
<li>For <strong>Optional</strong>, <code>zero()</code> returns <code>Optional.empty()</code>.</li>
</ul>
<h3 id="primary-uses-1"><a class="header" href="#primary-uses-1">Primary Uses</a></h3>
<p>The main purpose of <code>MonadZero</code> is to enable filtering within monadic comprehensions. It allows you to discard results that don't meet a certain criterion.</p>
<h4 id="1-filtering-in-for-comprehensions"><a class="header" href="#1-filtering-in-for-comprehensions">1. Filtering in For-Comprehensions</a></h4>
<p>As already mentioned the most powerful application in this codebase is within the <strong><code>For</code> comprehension builder</strong>. The builder has two entry points:</p>
<ul>
<li><code>For.from(monad, ...)</code>: For any standard <code>Monad</code>.</li>
<li><code>For.from(monadZero, ...)</code>: An overloaded version specifically for a <code>MonadZero</code>.</li>
</ul>
<p>Only the version that accepts a <code>MonadZero</code> provides the <code>.when(predicate)</code> filtering step. When the predicate in a <code>.when()</code> clause evaluates to <code>false</code>, the builder internally calls <code>monad.zero()</code> to terminate that specific computational path.</p>
<h4 id="2-generic-functions"><a class="header" href="#2-generic-functions">2. Generic Functions</a></h4>
<p>It allows you to write generic functions that can operate over any monad that has a concept of "failure" or "emptiness," such as <code>List</code>, <code>Maybe</code>, or <code>Optional</code>.</p>
<h3 id="code-example-for-comprehension-with-listmonad"><a class="header" href="#code-example-for-comprehension-with-listmonad">Code Example: <code>For</code> Comprehension with <code>ListMonad</code></a></h3>
<p>The following example demonstrates how <code>MonadZero</code> enables filtering.</p>
<pre><code class="language-java">import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.expression.For;
import org.higherkindedj.hkt.list.ListKind;
import org.higherkindedj.hkt.list.ListMonad;
import java.util.Arrays;
import java.util.List;

import static org.higherkindedj.hkt.list.ListKindHelper.LIST;

// 1. Get the MonadZero instance for List
final ListMonad listMonad = ListMonad.INSTANCE;

// 2. Define the initial data sources
final Kind&lt;ListKind.Witness, Integer&gt; list1 = LIST.widen(Arrays.asList(1, 2, 3));
final Kind&lt;ListKind.Witness, Integer&gt; list2 = LIST.widen(Arrays.asList(10, 20));

// 3. Build the comprehension using the filterable 'For'
final Kind&lt;ListKind.Witness, String&gt; result =
    For.from(listMonad, list1)                       // Start with a MonadZero
        .from(a -&gt; list2)                            // Generator (flatMap)
        .when(t -&gt; (t._1() + t._2()) % 2 != 0)        // Filter: if the sum is odd
        .let(t -&gt; "Sum: " + (t._1() + t._2()))        // Binding (map)
        .yield((a, b, c) -&gt; a + " + " + b + " = " + c); // Final projection

// 4. Unwrap the result
final List&lt;String&gt; narrow = LIST.narrow(result);
System.out.println("Result of List comprehension: " + narrow);
</code></pre>
<p><strong>Explanation:</strong></p>
<ul>
<li>The comprehension iterates through all pairs of <code>(a, b)</code> from <code>list1</code> and <code>list2</code>.</li>
<li>The <code>.when(...)</code> clause checks if the sum <code>a + b</code> is odd.</li>
<li>If the sum is even, the <code>monad.zero()</code> method (which returns an empty list) is invoked for that path, effectively discarding it.</li>
<li>If the sum is odd, the computation continues to the <code>.let()</code> and <code>.yield()</code> steps.</li>
</ul>
<p><strong>Output:</strong></p>
<p><code>Result of List comprehension: [1 + 10 = Sum: 11, 1 + 20 = Sum: 21, 3 + 10 = Sum: 13, 3 + 20 = Sum: 23]</code></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="selective-conditional-effects"><a class="header" href="#selective-conditional-effects">Selective: Conditional Effects</a></h1>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="functional/selective.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How Selective bridges the gap between Applicative and Monad</li>
<li>Conditional effect execution without full monadic power</li>
<li>Using <code>select</code>, <code>whenS</code>, and <code>ifS</code> for static branching</li>
<li>Building robust workflows with compile-time visible alternatives</li>
<li>Combining multiple alternatives with <code>orElse</code></li>
<li>Real-world examples of conditional effect execution</li>
</ul>
</div>
</div>
<p>You've seen how <code>Applicative</code> lets you combine independent computations and how <code>Monad</code> lets you chain dependent computations. The <strong><code>Selective</code></strong> type class sits precisely between them, providing a powerful middle ground: <strong>conditional effects with static structure</strong>.</p>
<hr />
<h2 id="what-is-it-8"><a class="header" href="#what-is-it-8">What is it?</a></h2>
<p>A <strong><code>Selective</code></strong> functor extends <code>Applicative</code> with the ability to conditionally apply effects based on the result of a previous computation. Unlike <code>Monad</code>, which allows arbitrary dynamic choice of effects, Selective provides a more restricted form of conditional execution where all possible branches must be provided upfront.</p>
<p>This static structure enables:</p>
<ul>
<li><strong>Static analysis</strong>: All possible execution paths are visible at construction time</li>
<li><strong>Optimisation</strong>: Compilers and runtimes can analyse and potentially parallelise branches</li>
<li><strong>Conditional effects</strong>: Execute operations only when needed, without full monadic power</li>
<li><strong>Type-safe branching</strong>: All branches must produce the same result type</li>
</ul>
<p>The interface for <code>Selective</code> in <code>hkj-api</code> extends <code>Applicative</code>:</p>
<pre><code class="language-java">@NullMarked
public interface Selective&lt;F&gt; extends Applicative&lt;F&gt; {
  // Core operation
  &lt;A, B&gt; Kind&lt;F, B&gt; select(Kind&lt;F, Choice&lt;A, B&gt;&gt; fab, Kind&lt;F, Function&lt;A, B&gt;&gt; ff);

  // Derived operations
  default &lt;A&gt; Kind&lt;F, Unit&gt; whenS(Kind&lt;F, Boolean&gt; fcond, Kind&lt;F, Unit&gt; fa) { ... }
  default &lt;A&gt; Kind&lt;F, A&gt; ifS(Kind&lt;F, Boolean&gt; fcond, Kind&lt;F, A&gt; fthen, Kind&lt;F, A&gt; felse) { ... }
  default &lt;A, B, C&gt; Kind&lt;F, C&gt; branch(Kind&lt;F, Choice&lt;A, B&gt;&gt; fab,
                                       Kind&lt;F, Function&lt;A, C&gt;&gt; fl,
                                       Kind&lt;F, Function&lt;B, C&gt;&gt; fr) { ... }
  // ... and more
}
</code></pre>
<hr />
<h2 id="the-core-operation-select"><a class="header" href="#the-core-operation-select">The Core Operation: <code>select</code></a></h2>
<p>The fundamental operation is <code>select</code>, which takes a <code>Choice&lt;A, B&gt;</code> (similar to <code>Either</code>) and a function:</p>
<ul>
<li>If the choice is <code>Left(a)</code>, the function is applied to <code>a</code> to produce <code>B</code></li>
<li>If the choice is <code>Right(b)</code>, the function is ignored and <code>b</code> is returned</li>
</ul>
<p><strong>Example: Conditional Validation</strong></p>
<pre><code class="language-java">import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.Selective;
import org.higherkindedj.hkt.maybe.MaybeSelective;
import org.higherkindedj.hkt.maybe.Maybe;
import static org.higherkindedj.hkt.maybe.MaybeKindHelper.MAYBE;

Selective&lt;MaybeKind.Witness&gt; selective = MaybeSelective.INSTANCE;

// A value that might need validation
Kind&lt;MaybeKind.Witness, Choice&lt;String, Integer&gt;&gt; input =
    MAYBE.widen(Maybe.just(Selective.left("42"))); // Left: needs parsing

// Parser function (only applied if Choice is Left)
Kind&lt;MaybeKind.Witness, Function&lt;String, Integer&gt;&gt; parser =
    MAYBE.widen(Maybe.just(s -&gt; Integer.parseInt(s)));

Kind&lt;MaybeKind.Witness, Integer&gt; result = selective.select(input, parser);
// Result: Just(42)

// If input was already Right(42), parser would not be used
Kind&lt;MaybeKind.Witness, Choice&lt;String, Integer&gt;&gt; alreadyParsed =
    MAYBE.widen(Maybe.just(Selective.right(42)));

Kind&lt;MaybeKind.Witness, Integer&gt; result2 = selective.select(alreadyParsed, parser);
// Result: Just(42) - parser was not applied
</code></pre>
<hr />
<h2 id="conditional-effect-execution-whens"><a class="header" href="#conditional-effect-execution-whens">Conditional Effect Execution: <code>whenS</code></a></h2>
<p>The <code>whenS</code> operation is the primary way to conditionally execute effects. It takes an effectful boolean condition and an effect that returns <code>Unit</code>, executing the effect only if the condition is <code>true</code>.</p>
<p><strong>Example: Conditional Logging</strong></p>
<pre><code class="language-java">import org.higherkindedj.hkt.io.IOSelective;
import org.higherkindedj.hkt.io.IO;
import org.higherkindedj.hkt.Unit;
import static org.higherkindedj.hkt.io.IOKindHelper.IO_KIND;

Selective&lt;IOKind.Witness&gt; selective = IOSelective.INSTANCE;

// Check if debug mode is enabled
Kind&lt;IOKind.Witness, Boolean&gt; debugEnabled =
    IO_KIND.widen(IO.delay(() -&gt; Config.isDebugMode()));

// The logging effect (only executed if debug is enabled)
Kind&lt;IOKind.Witness, Unit&gt; logEffect =
    IO_KIND.widen(IO.fromRunnable(() -&gt; log.debug("Debug information")));

// Conditional execution
Kind&lt;IOKind.Witness, Unit&gt; maybeLog = selective.whenS(debugEnabled, logEffect);

// Run the IO
IO.narrow(maybeLog).unsafeRunSync();
// Only logs if Config.isDebugMode() returns true
</code></pre>
<h3 id="whens_-discarding-results"><a class="header" href="#whens_-discarding-results"><code>whenS_</code>: Discarding Results</a></h3>
<p>When you have an effect that returns a value but you want to treat it as a <code>Unit</code>-returning operation, use <code>whenS_</code>:</p>
<pre><code class="language-java">// Database write returns row count, but we don't care about the value
Kind&lt;IOKind.Witness, Integer&gt; writeEffect =
    IO_KIND.widen(IO.delay(() -&gt; database.write(data)));

Kind&lt;IOKind.Witness, Boolean&gt; shouldPersist =
    IO_KIND.widen(IO.delay(() -&gt; config.shouldPersist()));

// Discard the Integer result, treat as Unit
Kind&lt;IOKind.Witness, Unit&gt; maybeWrite = selective.whenS_(shouldPersist, writeEffect);
</code></pre>
<hr />
<h2 id="branching-ifs"><a class="header" href="#branching-ifs">Branching: <code>ifS</code></a></h2>
<p>The <code>ifS</code> operation provides if-then-else semantics for selective functors. Unlike monadic branching, both branches must be provided upfront.</p>
<p><strong>Example: Configuration-Based Behaviour</strong></p>
<pre><code class="language-java">import org.higherkindedj.hkt.either.EitherSelective;
import org.higherkindedj.hkt.either.Either;
import static org.higherkindedj.hkt.either.EitherKindHelper.EITHER;

Selective&lt;EitherKind.Witness&lt;String&gt;&gt; selective = EitherSelective.instance();

// Check environment
Kind&lt;EitherKind.Witness&lt;String&gt;, Boolean&gt; isProd =
    EITHER.widen(Either.right(System.getenv("ENV").equals("production")));

// Production configuration
Kind&lt;EitherKind.Witness&lt;String&gt;, Config&gt; prodConfig =
    EITHER.widen(Either.right(new Config("prod", 443, true)));

// Development configuration
Kind&lt;EitherKind.Witness&lt;String&gt;, Config&gt; devConfig =
    EITHER.widen(Either.right(new Config("dev", 8080, false)));

// Select configuration based on environment
Kind&lt;EitherKind.Witness&lt;String&gt;, Config&gt; config =
    selective.ifS(isProd, prodConfig, devConfig);

// Result: Either.right(Config("prod", 443, true)) if ENV=production
//         Either.right(Config("dev", 8080, false)) otherwise
</code></pre>
<hr />
<h2 id="trying-alternatives-orelse"><a class="header" href="#trying-alternatives-orelse">Trying Alternatives: <code>orElse</code></a></h2>
<p>The <code>orElse</code> operation tries multiple alternatives in sequence, returning the first successful result.</p>
<p><strong>Example: Fallback Configuration Sources</strong></p>
<pre><code class="language-java">import java.util.List;

Selective&lt;OptionalKind.Witness&gt; selective = OptionalSelective.INSTANCE;

// Try multiple configuration sources
List&lt;Kind&lt;OptionalKind.Witness, Choice&lt;String, Config&gt;&gt;&gt; sources = List.of(
    // Try environment variables
    OPTIONAL.widen(tryEnvConfig()),
    // Try config file
    OPTIONAL.widen(tryFileConfig()),
    // Try default config
    OPTIONAL.widen(Optional.of(Selective.right(defaultConfig())))
);

Kind&lt;OptionalKind.Witness, Choice&lt;String, Config&gt;&gt; result =
    selective.orElse(sources);

// Returns the first successful Config, or the last error
</code></pre>
<hr />
<h2 id="selective-vs-applicative-vs-monad"><a class="header" href="#selective-vs-applicative-vs-monad">Selective vs Applicative vs Monad</a></h2>
<p>Understanding the differences helps you choose the right abstraction:</p>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Applicative</th><th>Selective</th><th>Monad</th></tr></thead><tbody>
<tr><td><strong>Combine independent effects</strong></td><td>‚úÖ</td><td>‚úÖ</td><td>‚úÖ</td></tr>
<tr><td><strong>Conditional effects</strong></td><td>‚ùå</td><td>‚úÖ</td><td>‚úÖ</td></tr>
<tr><td><strong>Dynamic effect choice</strong></td><td>‚ùå</td><td>‚ùå</td><td>‚úÖ</td></tr>
<tr><td><strong>Static structure</strong></td><td>‚úÖ</td><td>‚úÖ</td><td>‚ùå</td></tr>
<tr><td><strong>Error accumulation</strong></td><td>‚úÖ (with Validated)</td><td>‚úÖ (with Validated)</td><td>‚ùå</td></tr>
<tr><td><strong>Analyse all branches</strong></td><td>‚úÖ</td><td>‚úÖ</td><td>‚ùå</td></tr>
</tbody></table>
</div>
<p><strong>When to use Selective:</strong></p>
<ul>
<li>You need conditional effects but want static analysis</li>
<li>All branches should be known at construction time</li>
<li>You want optimisation opportunities from visible alternatives</li>
<li>You need something more powerful than Applicative but less than Monad</li>
</ul>
<p><strong>Example: Static vs Dynamic Choice</strong></p>
<pre><code class="language-java">// Selective: Both branches visible at construction
Kind&lt;F, A&gt; selectiveChoice = selective.ifS(
    condition,
    branchA,  // Known upfront
    branchB   // Known upfront
);

// Monad: Second computation depends on first result (dynamic)
Kind&lt;M, B&gt; monadicChoice = monad.flatMap(a -&gt; {
    if (a &gt; 10) return computeX(a);  // Not known until 'a' is available
    else return computeY(a);
}, source);
</code></pre>
<hr />
<h2 id="multi-way-branching-branch"><a class="header" href="#multi-way-branching-branch">Multi-Way Branching: <code>branch</code></a></h2>
<p>For more complex branching, <code>branch</code> handles both sides of a <code>Choice</code> with different handlers:</p>
<pre><code class="language-java">Kind&lt;F, Choice&lt;ErrorA, ErrorB&gt;&gt; input = ...; // Could be either error type

Kind&lt;F, Function&lt;ErrorA, String&gt;&gt; handleA =
    selective.of(a -&gt; "Error type A: " + a);

Kind&lt;F, Function&lt;ErrorB, String&gt;&gt; handleB =
    selective.of(b -&gt; "Error type B: " + b);

Kind&lt;F, String&gt; result = selective.branch(input, handleA, handleB);
// Applies the appropriate handler based on which error type
</code></pre>
<h2 id="chaining-conditional-functions-aps"><a class="header" href="#chaining-conditional-functions-aps">Chaining Conditional Functions: <code>apS</code></a></h2>
<p>For chaining multiple conditional functions, <code>apS</code> applies a list of functions sequentially to a value, propagating either the successful result or the first error. It's useful for building a pipeline of validation or transformation steps.</p>
<p><strong>Example: Multi-Step Validation</strong></p>
<pre><code class="language-java">Kind&lt;F, Choice&lt;Error, Data&gt;&gt; initialData = ...;

List&lt;Kind&lt;F, Function&lt;Data, Choice&lt;Error, Data&gt;&gt;&gt;&gt; validationSteps = List.of(
    validateStep1,
    validateStep2,
    validateStep3
);

// Applies each validation step in order, short-circuiting on the first error.
Kind&lt;F, Choice&lt;Error, Data&gt;&gt; finalResult = selective.apS(initialData, validationSteps);
</code></pre>
<hr />
<hr />
<h2 id="real-world-example-feature-flags"><a class="header" href="#real-world-example-feature-flags">Real-World Example: Feature Flags</a></h2>
<p><strong>Scenario:</strong> Execute analytics tracking only if the feature flag is enabled.</p>
<pre><code class="language-java">import org.higherkindedj.hkt.io.IOSelective;
import org.higherkindedj.hkt.io.IO;
import static org.higherkindedj.hkt.io.IOKindHelper.IO_KIND;

public class AnalyticsService {
    private final Selective&lt;IOKind.Witness&gt; selective = IOSelective.INSTANCE;

    public Kind&lt;IOKind.Witness, Unit&gt; trackEvent(String eventName, User user) {
        // Check feature flag (effectful)
        Kind&lt;IOKind.Witness, Boolean&gt; flagEnabled =
            IO_KIND.widen(IO.delay(() -&gt; featureFlags.isEnabled("analytics")));

        // The tracking effect (potentially expensive)
        Kind&lt;IOKind.Witness, Unit&gt; trackingEffect =
            IO_KIND.widen(IO.fromRunnable(() -&gt; {
                analytics.track(eventName, user.id(), user.properties());
                log.info("Tracked event: " + eventName);
            }));

        // Only track if flag is enabled
        return selective.whenS(flagEnabled, trackingEffect);
    }
}

// Usage
AnalyticsService analytics = new AnalyticsService();
Kind&lt;IOKind.Witness, Unit&gt; trackingOperation =
    analytics.trackEvent("user_signup", currentUser);

// Execute the IO
IO.narrow(trackingOperation).unsafeRunSync();
// Only sends analytics if feature flag is enabled
</code></pre>
<hr />
<h2 id="implementations"><a class="header" href="#implementations">Implementations</a></h2>
<p>Higher-Kinded-J provides Selective instances for:</p>
<ul>
<li><strong><code>Either&lt;E, *&gt;</code></strong> - <code>EitherSelective</code></li>
<li><strong><code>Maybe</code></strong> - <code>MaybeSelective</code></li>
<li><strong><code>Optional</code></strong> - <code>OptionalSelective</code></li>
<li><strong><code>List</code></strong> - <code>ListSelective</code></li>
<li><strong><code>IO</code></strong> - <code>IOSelective</code></li>
<li><strong><code>Reader&lt;R, *&gt;</code></strong> - <code>ReaderSelective</code></li>
<li><strong><code>Id</code></strong> - <code>IdSelective</code></li>
<li><strong><code>Validated&lt;E, *&gt;</code></strong> - <code>ValidatedSelective</code></li>
</ul>
<hr />
<h2 id="key-takeaways"><a class="header" href="#key-takeaways">Key Takeaways</a></h2>
<ul>
<li><strong>Selective sits between Applicative and Monad</strong>, providing conditional effects with static structure</li>
<li><strong><code>select</code> is the core operation</strong>, conditionally applying a function based on a <code>Choice</code></li>
<li><strong><code>whenS</code> enables conditional effect execution</strong>, perfect for feature flags and debug logging</li>
<li><strong><code>ifS</code> provides if-then-else semantics</strong> with both branches visible upfront</li>
<li><strong>All branches are known at construction time</strong>, enabling static analysis and optimisation</li>
<li><strong>Use Selective when you need conditional effects but want to avoid full monadic power</strong></li>
</ul>
<hr />
<p><strong>Previous:</strong> <a href="functional/monad_zero.html">MonadZero</a>
<strong>Next:</strong> <a href="functional/profunctor.html">Profunctor</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="profunctor-building-adaptable-data-pipelines"><a class="header" href="#profunctor-building-adaptable-data-pipelines">Profunctor: Building Adaptable Data Pipelines</a></h1>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="functional/profunctor.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to build adaptable data transformation pipelines</li>
<li>The dual nature of Profunctors: contravariant inputs and covariant outputs</li>
<li>Using <code>lmap</code>, <code>rmap</code>, and <code>dimap</code> to adapt functions for different contexts</li>
<li>Creating flexible API adapters and validation pipelines</li>
<li>Real-world applications in data format transformation and system integration</li>
</ul>
</div>
</div>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="functional/profunctor.html#admonition-note"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/profunctor/ProfunctorExample.java">ProfunctorExample.java</a></p>
</div>
</div>
<p>So far, we've explored type classes that work with single type parameters‚Äî<code>Functor</code>, <code>Applicative</code>, and <code>Monad</code> all operate on types like <code>F&lt;A&gt;</code>. But what about types that take <em>two</em> parameters, like <code>Function&lt;A, B&gt;</code> or <code>Either&lt;L, R&gt;</code>? This is where <strong>Profunctors</strong> come in.</p>
<p>A <strong>Profunctor</strong> is a powerful abstraction for working with types that are <strong>contravariant</strong> in their first type parameter and <strong>covariant</strong> in their second. Think of it as a generalisation of how functions work: you can pre-process the input (contravariant) and post-process the output (covariant).</p>
<div id="admonition-note-1" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-1-title">
<div class="admonition-title">
<div id="admonition-note-1-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="functional/profunctor.html#admonition-note-1"></a>
</div>
<div>
<p>New to variance terminology? See the <a href="functional/../glossary.html">Glossary</a> for detailed explanations of covariant, contravariant, and invariant with Java-focused examples.</p>
</div>
</div>
<hr />
<h2 id="what-is-a-profunctor"><a class="header" href="#what-is-a-profunctor">What is a Profunctor?</a></h2>
<p>A <code>Profunctor</code> is a type class for any type constructor <code>P&lt;A, B&gt;</code> that supports three key operations:</p>
<ul>
<li><strong><code>lmap</code></strong>: Map over the first (input) type parameter contravariantly</li>
<li><strong><code>rmap</code></strong>: Map over the second (output) type parameter covariantly</li>
<li><strong><code>dimap</code></strong>: Map over both parameters simultaneously</li>
</ul>
<p>The interface for <code>Profunctor</code> in <code>hkj-api</code> works with <code>Kind2&lt;P, A, B&gt;</code>:</p>
<pre><code class="language-java">@NullMarked
public interface Profunctor&lt;P&gt; {
  
    // Map over the input (contravariant)
    default &lt;A, B, C&gt; Kind2&lt;P, C, B&gt; lmap(
        Function&lt;? super C, ? extends A&gt; f, 
        Kind2&lt;P, A, B&gt; pab) {
        return dimap(f, Function.identity(), pab);
    }

    // Map over the output (covariant)
    default &lt;A, B, C&gt; Kind2&lt;P, A, C&gt; rmap(
        Function&lt;? super B, ? extends C&gt; g, 
        Kind2&lt;P, A, B&gt; pab) {
        return dimap(Function.identity(), g, pab);
    }

    // Map over both input and output
    &lt;A, B, C, D&gt; Kind2&lt;P, C, D&gt; dimap(
        Function&lt;? super C, ? extends A&gt; f,
        Function&lt;? super B, ? extends D&gt; g,
        Kind2&lt;P, A, B&gt; pab);
}
</code></pre>
<hr />
<h2 id="the-canonical-example-functions"><a class="header" href="#the-canonical-example-functions">The Canonical Example: Functions</a></h2>
<p>The most intuitive example of a profunctor is the humble <code>Function&lt;A, B&gt;</code>. Functions are naturally:</p>
<ul>
<li><strong>Contravariant in their input</strong>: If you have a function <code>String -&gt; Integer</code>, you can adapt it to work with any type that can be converted <em>to</em> a <code>String</code></li>
<li><strong>Covariant in their output</strong>: You can adapt the same function to produce any type that an <code>Integer</code> can be converted <em>to</em></li>
</ul>
<p>Let's see this in action with <code>FunctionProfunctor</code>:</p>
<pre><code class="language-java">import static org.higherkindedj.hkt.func.FunctionKindHelper.FUNCTION;
import org.higherkindedj.hkt.func.FunctionProfunctor;

// Our original function: calculate string length
Function&lt;String, Integer&gt; stringLength = String::length;
Kind2&lt;FunctionKind.Witness, String, Integer&gt; lengthFunction = FUNCTION.widen(stringLength);

FunctionProfunctor profunctor = FunctionProfunctor.INSTANCE;

// LMAP: Adapt the input - now we can use integers!
Kind2&lt;FunctionKind.Witness, Integer, Integer&gt; intToLength =
    profunctor.lmap(Object::toString, lengthFunction);

Function&lt;Integer, Integer&gt; intLengthFunc = FUNCTION.getFunction(intToLength);
System.out.println(intLengthFunc.apply(12345)); // Output: 5

// RMAP: Adapt the output - now we get formatted strings!
Kind2&lt;FunctionKind.Witness, String, String&gt; lengthToString =
    profunctor.rmap(len -&gt; "Length: " + len, lengthFunction);

Function&lt;String, String&gt; lengthStringFunc = FUNCTION.getFunction(lengthToString);
System.out.println(lengthStringFunc.apply("Hello")); // Output: "Length: 5"

// DIMAP: Adapt both sides simultaneously
Kind2&lt;FunctionKind.Witness, Integer, String&gt; fullTransform =
    profunctor.dimap(
        Object::toString,           // int -&gt; string
        len -&gt; "Result: " + len,    // int -&gt; string
        lengthFunction);

Function&lt;Integer, String&gt; fullFunc = FUNCTION.getFunction(fullTransform);
System.out.println(fullFunc.apply(42)); // Output: "Result: 2"
</code></pre>
<hr />
<h2 id="why-profunctors-matter"><a class="header" href="#why-profunctors-matter">Why Profunctors Matter</a></h2>
<p>Profunctors excel at creating <strong>adaptable data transformation pipelines</strong>. They're particularly powerful for:</p>
<h3 id="1-api-adapters-"><a class="header" href="#1-api-adapters-">1. <strong>API Adapters</strong> üîå</a></h3>
<p>When you need to integrate with external systems that expect different data formats:</p>
<pre><code class="language-java">// Core business logic: validate a userLogin
Function&lt;User, ValidationResult&gt; validateUser = userLogin -&gt; {
    boolean isValid = userLogin.email().contains("@") &amp;&amp; !userLogin.name().isEmpty();
    return new ValidationResult(isValid, isValid ? "Valid userLogin" : "Invalid userLogin data");
};

// The API expects UserDto input and ApiResponse output
Kind2&lt;FunctionKind.Witness, UserDto, ApiResponse&lt;ValidationResult&gt;&gt; apiValidator =
    profunctor.dimap(
        // Convert UserDto -&gt; User (contravariant)
        dto -&gt; new User(dto.fullName(), dto.emailAddress(), 
                        LocalDate.parse(dto.birthDateString())),
        // Convert ValidationResult -&gt; ApiResponse (covariant)  
        result -&gt; new ApiResponse&lt;&gt;(result, "OK", result.isValid() ? 200 : 400),
        FUNCTION.widen(validateUser));

// Now our core logic works seamlessly with the external API format!
Function&lt;UserDto, ApiResponse&lt;ValidationResult&gt;&gt; apiFunc = FUNCTION.getFunction(apiValidator);
</code></pre>
<h3 id="2-validation-pipelines-"><a class="header" href="#2-validation-pipelines-">2. <strong>Validation Pipelines</strong> ‚úÖ</a></h3>
<p>Build reusable validation logic that adapts to different input and output formats:</p>
<pre><code class="language-java">// Core validation: check if a number is positive
Function&lt;Double, Boolean&gt; isPositive = x -&gt; x &gt; 0;

// Adapt for string input with detailed error messages
Kind2&lt;FunctionKind.Witness, String, String&gt; stringValidator =
    profunctor.dimap(
        // Parse string to double
        str -&gt; {
            try {
                return Double.parseDouble(str);
            } catch (NumberFormatException e) {
                return -1.0; // Invalid marker
            }
        },
        // Convert boolean to message
        isValid -&gt; isValid ? "‚úì Valid positive number" : "‚úó Not a positive number",
        FUNCTION.widen(isPositive));

Function&lt;String, String&gt; validator = FUNCTION.getFunction(stringValidator);
System.out.println(validator.apply("42.5"));  // "‚úì Valid positive number"
System.out.println(validator.apply("-10"));   // "‚úó Not a positive number"
</code></pre>
<h3 id="3-data-transformation-chains-"><a class="header" href="#3-data-transformation-chains-">3. <strong>Data Transformation Chains</strong> üîó</a></h3>
<p>Chain multiple adaptations to build complex data processing pipelines:</p>
<pre><code class="language-java">// Core transformation: User -&gt; UserDto  
Function&lt;User, UserDto&gt; userToDto = userLogin -&gt;
    new UserDto(userLogin.name(), userLogin.email(), 
                userLogin.birthDate().format(DateTimeFormatter.ISO_LOCAL_DATE));

// Build a CSV-to-JSON pipeline
Kind2&lt;FunctionKind.Witness, String, String&gt; csvToJsonTransform =
    profunctor.dimap(
        csvParser,    // String -&gt; User (parse CSV)
        dtoToJson,    // UserDto -&gt; String (serialise to JSON)
        FUNCTION.widen(userToDto));

// Add error handling with another rmap
Kind2&lt;FunctionKind.Witness, String, ApiResponse&lt;String&gt;&gt; safeTransform =
    profunctor.rmap(
        jsonString -&gt; {
            if (jsonString.contains("INVALID")) {
                return new ApiResponse&lt;&gt;("", "ERROR: Invalid input data", 400);
            }
            return new ApiResponse&lt;&gt;(jsonString, "SUCCESS", 200);
        },
        csvToJsonTransform);
</code></pre>
<hr />
<h2 id="profunctor-laws"><a class="header" href="#profunctor-laws">Profunctor Laws</a></h2>
<p>For a <code>Profunctor</code> to be lawful, it must satisfy two key properties:</p>
<ol>
<li><strong>Identity</strong>: <code>dimap(identity, identity, p) == p</code></li>
<li><strong>Composition</strong>: <code>dimap(f1 ‚àò f2, g1 ‚àò g2, p) == dimap(f2, g1, dimap(f1, g2, p))</code></li>
</ol>
<p>These laws ensure that profunctor operations are predictable and composable‚Äîyou can build complex transformations by combining simpler ones without unexpected behaviour.</p>
<hr />
<h2 id="when-to-use-profunctors"><a class="header" href="#when-to-use-profunctors">When to Use Profunctors</a></h2>
<p>Profunctors are ideal when you need to:</p>
<ul>
<li><strong>Adapt existing functions</strong> to work with different input/output types</li>
<li><strong>Build flexible APIs</strong> that can handle multiple data formats</li>
<li><strong>Create reusable transformation pipelines</strong> that can be configured for different use cases</li>
<li><strong>Integrate with external systems</strong> without changing your core business logic</li>
<li><strong>Handle both sides of a computation</strong> (input preprocessing and output postprocessing)</li>
</ul>
<p>The next time you find yourself writing similar functions that differ only in their input parsing or output formatting, consider whether a profunctor could help you write the logic once and adapt it as needed!</p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="bifunctor-mapping-over-both-sides"><a class="header" href="#bifunctor-mapping-over-both-sides">Bifunctor: Mapping Over Both Sides</a></h1>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="functional/bifunctor.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to transform types with two covariant parameters independently or simultaneously</li>
<li>The difference between sum types (Either, Validated) and product types (Tuple2, Writer)</li>
<li>Using <code>bimap</code>, <code>first</code>, and <code>second</code> operations effectively</li>
<li>Transforming both error and success channels in validation scenarios</li>
<li>Real-world applications in API design, data migration, and error handling</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code:</p>
</div>
<a class="admonition-anchor-link" href="functional/bifunctor.html#admonition-see-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/bifunctor/BifunctorExample.java">BifunctorExample.java</a></p>
</div>
</div>
<p>Whilst <code>Functor</code> lets us map over types with a single parameter like <code>F&lt;A&gt;</code>, many useful types have <em>two</em> parameters. <code>Either&lt;L, R&gt;</code>, <code>Tuple2&lt;A, B&gt;</code>, <code>Validated&lt;E, A&gt;</code>, and <code>Writer&lt;W, A&gt;</code> all carry two distinct types. The <strong><code>Bifunctor</code></strong> type class provides a uniform interface for transforming both parameters.</p>
<p>Unlike <code>Profunctor</code>, which is contravariant in the first parameter and covariant in the second (representing input/output relationships), <code>Bifunctor</code> is <strong>covariant in both parameters</strong>. This makes it perfect for types where both sides hold data that can be independently transformed.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="functional/bifunctor.html#admonition-note"></a>
</div>
<div>
<p>New to variance terminology? See the <a href="functional/../glossary.html">Glossary</a> for detailed explanations of covariant, contravariant, and invariant with Java-focused examples.</p>
</div>
</div>
<hr />
<h2 id="what-is-a-bifunctor"><a class="header" href="#what-is-a-bifunctor">What is a Bifunctor?</a></h2>
<p>A <strong><code>Bifunctor</code></strong> is a type class for any type constructor <code>F&lt;A, B&gt;</code> that supports mapping over both its type parameters. It provides three core operations:</p>
<ul>
<li><strong><code>bimap</code></strong>: Transform both type parameters simultaneously</li>
<li><strong><code>first</code></strong>: Transform only the first type parameter</li>
<li><strong><code>second</code></strong>: Transform only the second type parameter</li>
</ul>
<p>The interface for <code>Bifunctor</code> in <code>hkj-api</code> works with <code>Kind2&lt;F, A, B&gt;</code>:</p>
<pre><code class="language-java">@NullMarked
public interface Bifunctor&lt;F&gt; {

    // Transform only the first parameter
    default &lt;A, B, C&gt; Kind2&lt;F, C, B&gt; first(
        Function&lt;? super A, ? extends C&gt; f,
        Kind2&lt;F, A, B&gt; fab) {
        return bimap(f, Function.identity(), fab);
    }

    // Transform only the second parameter
    default &lt;A, B, D&gt; Kind2&lt;F, A, D&gt; second(
        Function&lt;? super B, ? extends D&gt; g,
        Kind2&lt;F, A, B&gt; fab) {
        return bimap(Function.identity(), g, fab);
    }

    // Transform both parameters simultaneously
    &lt;A, B, C, D&gt; Kind2&lt;F, C, D&gt; bimap(
        Function&lt;? super A, ? extends C&gt; f,
        Function&lt;? super B, ? extends D&gt; g,
        Kind2&lt;F, A, B&gt; fab);
}
</code></pre>
<hr />
<h2 id="sum-types-vs-product-types"><a class="header" href="#sum-types-vs-product-types">Sum Types vs Product Types</a></h2>
<p>Understanding the distinction between <strong>sum types</strong> and <strong>product types</strong> is crucial to using bifunctors effectively.</p>
<h3 id="sum-types-exclusive-or-"><a class="header" href="#sum-types-exclusive-or-">Sum Types (Exclusive OR) üîÄ</a></h3>
<p>A <strong>sum type</strong> represents a choice between alternatives‚Äîyou have <em>either</em> one value <em>or</em> another, but never both. In type theory, if type <code>A</code> has <code>n</code> possible values and type <code>B</code> has <code>m</code> possible values, then <code>Either&lt;A, B&gt;</code> has <code>n + m</code> possible values (hence "sum").</p>
<p>Examples in higher-kinded-j:</p>
<ul>
<li><strong><code>Either&lt;L, R&gt;</code></strong>: Holds <em>either</em> a <code>Left</code> value (conventionally an error) <em>or</em> a <code>Right</code> value (conventionally a success)</li>
<li><strong><code>Validated&lt;E, A&gt;</code></strong>: Holds <em>either</em> an <code>Invalid</code> error <em>or</em> a <code>Valid</code> result</li>
</ul>
<p>When you use <code>bimap</code> on a sum type, only <em>one</em> of the two functions will actually execute, depending on which variant is present.</p>
<h3 id="product-types-both-and-"><a class="header" href="#product-types-both-and-">Product Types (Both AND) üîó</a></h3>
<p>A <strong>product type</strong> contains multiple values simultaneously‚Äîyou have <em>both</em> the first value <em>and</em> the second value. In type theory, if type <code>A</code> has <code>n</code> possible values and type <code>B</code> has <code>m</code> possible values, then <code>Tuple2&lt;A, B&gt;</code> has <code>n √ó m</code> possible values (hence "product").</p>
<p>Examples in higher-kinded-j:</p>
<ul>
<li><strong><code>Tuple2&lt;A, B&gt;</code></strong>: Holds <em>both</em> a first value <em>and</em> a second value</li>
<li><strong><code>Writer&lt;W, A&gt;</code></strong>: Holds <em>both</em> a log/output value <em>and</em> a computation result</li>
</ul>
<p>When you use <code>bimap</code> on a product type, <em>both</em> functions execute because both values are always present.</p>
<hr />
<h2 id="the-bifunctor-laws"><a class="header" href="#the-bifunctor-laws">The Bifunctor Laws</a></h2>
<p>For a <code>Bifunctor</code> to be lawful, it must satisfy two fundamental properties:</p>
<ol>
<li>
<p><strong>Identity Law</strong>: Mapping with identity functions changes nothing</p>
<pre><code class="language-java">bifunctor.bimap(x -&gt; x, y -&gt; y, fab); // Must be equivalent to fab
</code></pre>
</li>
<li>
<p><strong>Composition Law</strong>: Mapping with composed functions is equivalent to mapping in sequence</p>
<pre><code class="language-java">Function&lt;A, B&gt; f1 = ...;
Function&lt;B, C&gt; f2 = ...;
Function&lt;D, E&gt; g1 = ...;
Function&lt;E, F&gt; g2 = ...;

// These must be equivalent:
bifunctor.bimap(f2.compose(f1), g2.compose(g1), fab);
bifunctor.bimap(f2, g2, bifunctor.bimap(f1, g1, fab));
</code></pre>
</li>
</ol>
<p>These laws ensure that bifunctor operations are predictable, composable, and preserve the structure of your data.</p>
<hr />
<h2 id="why-is-it-useful-8"><a class="header" href="#why-is-it-useful-8">Why is it useful?</a></h2>
<p>Bifunctors provide a uniform interface for transforming dual-parameter types, which arise frequently in functional programming. Rather than learning different APIs for transforming <code>Either</code>, <code>Tuple2</code>, <code>Validated</code>, and <code>Writer</code>, you use the same operations everywhere.</p>
<h3 id="key-use-cases"><a class="header" href="#key-use-cases">Key Use Cases</a></h3>
<ul>
<li><strong>Error Handling</strong>: Transform both error and success channels simultaneously</li>
<li><strong>API Design</strong>: Normalise internal representations to external formats</li>
<li><strong>Data Migration</strong>: Convert both fields of legacy data structures</li>
<li><strong>Validation</strong>: Format both error messages and valid results</li>
<li><strong>Logging</strong>: Transform both the log output and the computation result</li>
</ul>
<hr />
<h2 id="example-1-either--a-sum-type"><a class="header" href="#example-1-either--a-sum-type">Example 1: Either ‚Äì A Sum Type</a></h2>
<p><code>Either&lt;L, R&gt;</code> is the quintessential sum type. It holds <em>either</em> a <code>Left</code> (conventionally an error) <em>or</em> a <code>Right</code> (conventionally a success).</p>
<pre><code class="language-java">import static org.higherkindedj.hkt.either.EitherKindHelper.EITHER;
import org.higherkindedj.hkt.Bifunctor;
import org.higherkindedj.hkt.either.Either;
import org.higherkindedj.hkt.either.EitherBifunctor;
import org.higherkindedj.hkt.Kind2;

Bifunctor&lt;EitherKind2.Witness&gt; bifunctor = EitherBifunctor.INSTANCE;

// Success case: transform the Right channel
Either&lt;String, Integer&gt; success = Either.right(42);
Kind2&lt;EitherKind2.Witness, String, String&gt; formatted =
    bifunctor.second(
        n -&gt; "Success: " + n,
        EITHER.widen2(success));

System.out.println(EITHER.narrow2(formatted));
// Output: Right(Success: 42)

// Error case: transform the Left channel
Either&lt;String, Integer&gt; error = Either.left("FILE_NOT_FOUND");
Kind2&lt;EitherKind2.Witness, String, Integer&gt; enhanced =
    bifunctor.first(
        err -&gt; "Error Code: " + err,
        EITHER.widen2(error));

System.out.println(EITHER.narrow2(enhanced));
// Output: Left(Error Code: FILE_NOT_FOUND)

// Transform both channels with bimap
Either&lt;String, Integer&gt; either = Either.right(100);
Kind2&lt;EitherKind2.Witness, Integer, String&gt; both =
    bifunctor.bimap(
        String::length,        // Left: string -&gt; int (not executed here)
        n -&gt; "Value: " + n,    // Right: int -&gt; string (executed)
        EITHER.widen2(either));

System.out.println(EITHER.narrow2(both));
// Output: Right(Value: 100)
</code></pre>
<p><strong>Note:</strong> With <code>Either</code>, only one function in <code>bimap</code> executes because <code>Either</code> is a <em>sum type</em>‚Äîyou have either Left <em>or</em> Right, never both.</p>
<hr />
<h2 id="example-2-tuple2--a-product-type"><a class="header" href="#example-2-tuple2--a-product-type">Example 2: Tuple2 ‚Äì A Product Type</a></h2>
<p><code>Tuple2&lt;A, B&gt;</code> is a product type that holds <em>both</em> a first value <em>and</em> a second value simultaneously.</p>
<pre><code class="language-java">import static org.higherkindedj.hkt.tuple.Tuple2KindHelper.TUPLE2;
import org.higherkindedj.hkt.Bifunctor;
import org.higherkindedj.hkt.tuple.Tuple2;
import org.higherkindedj.hkt.tuple.Tuple2Bifunctor;

Bifunctor&lt;Tuple2Kind2.Witness&gt; bifunctor = Tuple2Bifunctor.INSTANCE;

// A tuple representing (name, age)
Tuple2&lt;String, Integer&gt; person = new Tuple2&lt;&gt;("Alice", 30);

// Transform only the first element
Kind2&lt;Tuple2Kind2.Witness, Integer, Integer&gt; nameLength =
    bifunctor.first(String::length, TUPLE2.widen2(person));

System.out.println(TUPLE2.narrow2(nameLength));
// Output: Tuple2(5, 30)

// Transform only the second element
Kind2&lt;Tuple2Kind2.Witness, String, String&gt; ageFormatted =
    bifunctor.second(age -&gt; age + " years", TUPLE2.widen2(person));

System.out.println(TUPLE2.narrow2(ageFormatted));
// Output: Tuple2(Alice, 30 years)

// Transform both simultaneously with bimap
Kind2&lt;Tuple2Kind2.Witness, String, String&gt; formatted =
    bifunctor.bimap(
        name -&gt; "Name: " + name,  // First: executed
        age -&gt; "Age: " + age,      // Second: executed
        TUPLE2.widen2(person));

System.out.println(TUPLE2.narrow2(formatted));
// Output: Tuple2(Name: Alice, Age: 30)
</code></pre>
<p><strong>Note:</strong> With <code>Tuple2</code>, both functions in <code>bimap</code> execute because <code>Tuple2</code> is a <em>product type</em>‚Äîboth values are always present.</p>
<hr />
<h2 id="example-3-validated--error-accumulation"><a class="header" href="#example-3-validated--error-accumulation">Example 3: Validated ‚Äì Error Accumulation</a></h2>
<p><code>Validated&lt;E, A&gt;</code> is a sum type designed for validation scenarios where you need to accumulate errors.</p>
<pre><code class="language-java">import static org.higherkindedj.hkt.validated.ValidatedKindHelper.VALIDATED;
import org.higherkindedj.hkt.Bifunctor;
import org.higherkindedj.hkt.validated.Validated;
import org.higherkindedj.hkt.validated.ValidatedBifunctor;
import java.util.List;

Bifunctor&lt;ValidatedKind2.Witness&gt; bifunctor = ValidatedBifunctor.INSTANCE;

// Valid case
Validated&lt;List&lt;String&gt;, Integer&gt; valid = Validated.valid(100);
Kind2&lt;ValidatedKind2.Witness, List&lt;String&gt;, String&gt; transformedValid =
    bifunctor.second(n -&gt; "Score: " + n, VALIDATED.widen2(valid));

System.out.println(VALIDATED.narrow2(transformedValid));
// Output: Valid(Score: 100)

// Invalid case with multiple errors
Validated&lt;List&lt;String&gt;, Integer&gt; invalid =
    Validated.invalid(List.of("TOO_SMALL", "OUT_OF_RANGE"));

// Transform errors to be more user-friendly
Kind2&lt;ValidatedKind2.Witness, String, Integer&gt; userFriendly =
    bifunctor.first(
        errors -&gt; "Validation failed: " + String.join(", ", errors),
        VALIDATED.widen2(invalid));

System.out.println(VALIDATED.narrow2(userFriendly));
// Output: Invalid(Validation failed: TOO_SMALL, OUT_OF_RANGE)
</code></pre>
<hr />
<h2 id="example-4-writer--logging-with-computation"><a class="header" href="#example-4-writer--logging-with-computation">Example 4: Writer ‚Äì Logging with Computation</a></h2>
<p><code>Writer&lt;W, A&gt;</code> is a product type that holds <em>both</em> a log value <em>and</em> a computation result.</p>
<pre><code class="language-java">import static org.higherkindedj.hkt.writer.WriterKindHelper.WRITER;
import org.higherkindedj.hkt.Bifunctor;
import org.higherkindedj.hkt.writer.Writer;
import org.higherkindedj.hkt.writer.WriterBifunctor;

Bifunctor&lt;WriterKind2.Witness&gt; bifunctor = WriterBifunctor.INSTANCE;

// A Writer with a log and a result
Writer&lt;String, Integer&gt; computation = new Writer&lt;&gt;("Calculated: ", 42);

// Transform the log channel
Kind2&lt;WriterKind2.Witness, String, Integer&gt; uppercaseLog =
    bifunctor.first(String::toUpperCase, WRITER.widen2(computation));

System.out.println(WRITER.narrow2(uppercaseLog));
// Output: Writer(CALCULATED: , 42)

// Transform both log and result
Kind2&lt;WriterKind2.Witness, List&lt;String&gt;, String&gt; structured =
    bifunctor.bimap(
        log -&gt; List.of("[LOG]", log),   // Wrap log in structured format
        value -&gt; "Result: " + value,     // Format the result
        WRITER.widen2(computation));

System.out.println(WRITER.narrow2(structured));
// Output: Writer([LOG], Calculated: , Result: 42)
</code></pre>
<hr />
<h2 id="example-5-const--a-phantom-type-bifunctor"><a class="header" href="#example-5-const--a-phantom-type-bifunctor">Example 5: Const ‚Äì A Phantom Type Bifunctor</a></h2>
<p><code>Const&lt;C, A&gt;</code> is a unique bifunctor where the second type parameter is <strong>phantom</strong> (not stored at runtime), making it perfect for fold operations, getters in lens libraries, and data extraction patterns.</p>
<pre><code class="language-java">import static org.higherkindedj.hkt.constant.ConstKindHelper.CONST;
import org.higherkindedj.hkt.Bifunctor;
import org.higherkindedj.hkt.constant.Const;
import org.higherkindedj.hkt.constant.ConstBifunctor;

Bifunctor&lt;ConstKind2.Witness&gt; bifunctor = ConstBifunctor.INSTANCE;

// A Const holding a count, with String as the phantom type
Const&lt;Integer, String&gt; count = new Const&lt;&gt;(42);
System.out.println("Original: " + count.value());
// Output: 42

// Transform the constant value with first()
Kind2&lt;ConstKind2.Witness, String, String&gt; transformed =
    bifunctor.first(
        n -&gt; "Count: " + n,  // Transforms the constant: 42 -&gt; "Count: 42"
        CONST.widen2(count));

System.out.println(CONST.narrow2(transformed).value());
// Output: "Count: 42"

// Transform ONLY the phantom type with second()
Kind2&lt;ConstKind2.Witness, Integer, Double&gt; phantomChanged =
    bifunctor.second(
        s -&gt; s.length() * 2.0,  // This defines the phantom type transformation
        CONST.widen2(count));

System.out.println(CONST.narrow2(phantomChanged).value());
// Output: 42 (UNCHANGED!)

// Use bimap() - but only first() affects the constant
Kind2&lt;ConstKind2.Witness, String, Boolean&gt; both =
    bifunctor.bimap(
        n -&gt; "#" + n,          // Transforms constant: 42 -&gt; "#42"
        s -&gt; s.isEmpty(),      // Phantom type transformation only
        CONST.widen2(count));

System.out.println(CONST.narrow2(both).value());
// Output: "#42"
</code></pre>
<p><strong>Note:</strong> With <code>Const</code>, the <code>second</code> function in <code>bimap</code> never affects the constant value because the second type parameter is phantom. This property makes <code>Const</code> ideal for folds that accumulate a single value whilst traversing a structure, and for implementing getters in van Laarhoven lens patterns.</p>
<p>For more on <code>Const</code> and its applications in folds and lens patterns, see the <a href="functional/../monads/const_type.html">Const Type documentation</a>.</p>
<hr />
<h2 id="real-world-scenario-api-response-transformation"><a class="header" href="#real-world-scenario-api-response-transformation">Real-World Scenario: API Response Transformation</a></h2>
<p>One of the most common uses of bifunctors is transforming internal data representations to external API formats.</p>
<pre><code class="language-java">// Internal representation uses simple error codes and domain objects
Either&lt;String, UserData&gt; internalResult = Either.left("USER_NOT_FOUND");

// External API requires structured error objects and formatted responses
Function&lt;String, ApiError&gt; toApiError =
    code -&gt; new ApiError(code, "Error occurred", 404);

Function&lt;UserData, ApiResponse&gt; toApiResponse =
    user -&gt; new ApiResponse(user.name(), user.email(), 200);

Bifunctor&lt;EitherKind2.Witness&gt; bifunctor = EitherBifunctor.INSTANCE;

Kind2&lt;EitherKind2.Witness, ApiError, ApiResponse&gt; apiResult =
    bifunctor.bimap(
        toApiError,     // Transform internal error to API error format
        toApiResponse,  // Transform internal data to API response format
        EITHER.widen2(internalResult));

// Result: Left(ApiError(USER_NOT_FOUND, Error occurred, 404))
</code></pre>
<p>This approach keeps your domain logic clean whilst providing flexible adaptation to external requirements.</p>
<hr />
<h2 id="bifunctor-vs-profunctor"><a class="header" href="#bifunctor-vs-profunctor">Bifunctor vs Profunctor</a></h2>
<p>Whilst both type classes work with dual-parameter types, they serve different purposes:</p>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Bifunctor</th><th>Profunctor</th></tr></thead><tbody>
<tr><td>First parameter</td><td>Covariant (output)</td><td>Contravariant (input)</td></tr>
<tr><td>Second parameter</td><td>Covariant (output)</td><td>Covariant (output)</td></tr>
<tr><td>Typical use</td><td>Data structures with two outputs</td><td>Functions and transformations</td></tr>
<tr><td>Examples</td><td><code>Either&lt;L, R&gt;</code>, <code>Tuple2&lt;A, B&gt;</code></td><td><code>Function&lt;A, B&gt;</code>, optics</td></tr>
<tr><td>Use case</td><td>Transform both "sides" of data</td><td>Adapt input and output of pipelines</td></tr>
</tbody></table>
</div>
<p><strong>Use Bifunctor when:</strong> Both parameters represent data you want to transform (errors and results, first and second elements).</p>
<p><strong>Use Profunctor when:</strong> The first parameter represents input (contravariant) and the second represents output (covariant), like in functions.</p>
<hr />
<h2 id="when-to-use-bifunctor"><a class="header" href="#when-to-use-bifunctor">When to Use Bifunctor</a></h2>
<p>Bifunctors are ideal when you need to:</p>
<ul>
<li><strong>Normalise API responses</strong> by transforming both error and success formats</li>
<li><strong>Migrate data schemas</strong> by transforming both fields of legacy structures</li>
<li><strong>Format validation results</strong> by enhancing both error messages and valid values</li>
<li><strong>Process paired data</strong> like tuples, logs with results, or any product type</li>
<li><strong>Handle sum types uniformly</strong> by providing transformations for all variants</li>
</ul>
<p>The power of bifunctors lies in their ability to abstract over the dual-parameter structure whilst preserving the semantics (sum vs product) of the underlying type.</p>
<hr />
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<ul>
<li><strong>Bifunctor</strong> provides <code>bimap</code>, <code>first</code>, and <code>second</code> for transforming dual-parameter types</li>
<li><strong>Sum types</strong> (Either, Validated) execute only one function based on which variant is present</li>
<li><strong>Product types</strong> (Tuple2, Writer) execute both functions since both values are present</li>
<li><strong>Use cases</strong> include API design, validation, data migration, and error handling</li>
<li><strong>Differs from Profunctor</strong> by being covariant in both parameters rather than contravariant/covariant</li>
</ul>
<p>Understanding bifunctors empowers you to write generic, reusable transformation logic that works uniformly across diverse dual-parameter types.</p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="for-comprehensions"><a class="header" href="#for-comprehensions">For-Comprehensions</a></h1>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="functional/for_comprehension.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to transform nested <code>flatMap</code> chains into readable, sequential code</li>
<li>The four types of operations: generators (<code>.from()</code>), bindings (<code>.let()</code>), guards (<code>.when()</code>), and projections (<code>.yield()</code>)</li>
<li>Building complex workflows with StateT and other monad transformers</li>
<li>Converting "pyramid of doom" code into clean, imperative-style scripts</li>
<li>Real-world examples from simple Maybe operations to complex state management</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code:</p>
</div>
<a class="admonition-anchor-link" href="functional/for_comprehension.html#admonition-see-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/expression/ForComprehensionExample.java">ForComprehensionExample.java</a></p>
</div>
</div>
<p>Endless nested callbacks and unreadable chains of flatMap calls can be tiresome. The <code>higher-kinded-j</code> library brings the elegance and power of Scala-style for-comprehensions to Java, allowing you to write complex asynchronous and sequential logic in a way that is clean, declarative, and easy to follow.</p>
<p>Let's see how to transform "callback hell" into a readable, sequential script.</p>
<h2 id="the-pyramid-of-doom-problem"><a class="header" href="#the-pyramid-of-doom-problem">The "Pyramid of Doom" Problem</a></h2>
<p>In functional programming, monads are a powerful tool for sequencing operations, especially those with a context like <code>Optional</code>, <code>List</code>, or <code>CompletableFuture</code>. However, chaining these operations with <code>flatMap</code> can quickly become hard to read.</p>
<p>Consider combining three <code>Maybe</code> values:</p>
<pre><code class="language-java">// The "nested" way
Kind&lt;MaybeKind.Witness, Integer&gt; result = maybeMonad.flatMap(a -&gt;
    maybeMonad.flatMap(b -&gt;
        maybeMonad.map(c -&gt; a + b + c, maybeC),
    maybeB),
maybeA);
</code></pre>
<p>This code works, but the logic is buried inside nested lambdas. The intent‚Äîto simply get values from <code>maybeA</code>, <code>maybeB</code>, and <code>maybeC</code> and add them‚Äîis obscured. This is often called the "pyramid of doom."</p>
<h2 id="for-a-fluent-sequential-builder"><a class="header" href="#for-a-fluent-sequential-builder"><em>For</em> A Fluent, Sequential Builder</a></h2>
<p>The <code>For</code> comprehension builder provides a much more intuitive way to write the same logic. It lets you express the sequence of operations as if they were simple, imperative steps.</p>
<p>Here‚Äôs the same example rewritten with the <code>For</code> builder:</p>
<pre><code class="language-java">import static org.higherkindedj.hkt.maybe.MaybeKindHelper.MAYBE;
import org.higherkindedj.hkt.expression.For;
// ... other imports

var maybeMonad = MaybeMonad.INSTANCE;
var maybeA = MAYBE.just(5);
var maybeB = MAYBE.just(10);
var maybeC = MAYBE.just(20);

// The clean, sequential way
var result = For.from(maybeMonad, maybeA)    // Get a from maybeA
    .from(a -&gt; maybeB)                       // Then, get b from maybeB
    .from(t -&gt; maybeC)                       // Then, get c from maybeC
    .yield((a, b, c) -&gt; a + b + c);          // Finally, combine them

System.out.println(MAYBE.narrow(result)); // Prints: Just(35)
</code></pre>
<p>This version is flat, readable, and directly expresses the intended sequence of operations. The <code>For</code> builder automatically handles the <code>flatMap</code> and <code>map</code> calls behind the scenes.</p>
<h2 id="core-operations-of-the-for-builder"><a class="header" href="#core-operations-of-the-for-builder">Core Operations of the <code>For</code> Builder</a></h2>
<p>A for-comprehension is built by chaining four types of operations:</p>
<h3 id="1-generators-from"><a class="header" href="#1-generators-from">1. Generators: <code>.from()</code></a></h3>
<p>A generator is the workhorse of the comprehension. It takes a value from a previous step, uses it to produce a new monadic value (like another <code>Maybe</code> or <code>List</code>), and extracts the result for the next step. This is a direct equivalent of <strong><code>flatMap</code></strong>.</p>
<p>Each <code>.from()</code> adds a new variable to the scope of the comprehension.</p>
<pre><code class="language-java">// Generates all combinations of userLogin IDs and roles
var userRoles = For.from(listMonad, LIST.widen(List.of("userLogin-1", "userLogin-2"))) // a: "userLogin-1", "userLogin-2"
    .from(a -&gt; LIST.widen(List.of("viewer", "editor")))       // b: "viewer", "editor"
    .yield((a, b) -&gt; a + " is a " + b);

// Result: ["userLogin-1 is a viewer", "userLogin-1 is a editor", "userLogin-2 is a viewer", "userLogin-2 is a editor"]
</code></pre>
<h3 id="2-value-bindings-let"><a class="header" href="#2-value-bindings-let">2. Value Bindings: <code>.let()</code></a></h3>
<p>A <code>.let()</code> binding allows you to compute a pure, simple value from the results you've gathered so far and add it to the scope. It does <em>not</em> involve a monad. This is equivalent to a <strong><code>map</code></strong> operation that carries the new value forward.</p>
<pre><code class="language-java">var idMonad = IdMonad.instance();

var result = For.from(idMonad, Id.of(10))        // a = 10
    .let(a -&gt; a * 2)                          // b = 20 (a pure calculation)
    .yield((a, b) -&gt; "Value: " + a + ", Doubled: " + b);

// Result: "Value: 10, Doubled: 20"
System.out.println(ID.unwrap(result));
</code></pre>
<h3 id="3-guards-when"><a class="header" href="#3-guards-when">3. Guards: <code>.when()</code></a></h3>
<p>For monads that can represent failure or emptiness (like <code>List</code>, <code>Maybe</code>, or <code>Optional</code>), you can use <code>.when()</code> to <strong>filter</strong> results. If the condition is false, the current computational path is stopped by returning the monad's "zero" value (e.g., an empty list or <code>Maybe.nothing()</code>).</p>
<blockquote>
<p>This feature requires a <code>MonadZero</code> instance. See the <code>MonadZero</code> documentation for more details.</p>
</blockquote>
<pre><code class="language-java">var evens = For.from(listMonad, LIST.widen(List.of(1, 2, 3, 4, 5, 6)))
    .when(i -&gt; i % 2 == 0) // Guard: only keep even numbers
    .yield(i -&gt; i);

// Result: [2, 4, 6]
</code></pre>
<h3 id="4-projection-yield"><a class="header" href="#4-projection-yield">4. Projection: <code>.yield()</code></a></h3>
<p>Every comprehension ends with <code>.yield()</code>. This is the final <strong><code>map</code></strong> operation where you take all the values you've gathered from the generators and bindings and produce your final result. You can access the bound values as individual lambda parameters or as a single <code>Tuple</code>.</p>
<h2 id="turn-the-power-up-statet-example"><a class="header" href="#turn-the-power-up-statet-example">Turn the power up: <code>StateT</code> Example</a></h2>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/expression/ForComprehensionExample.java">ForComprehensionExample.java</a></li>
</ul>
<p>The true power of for-comprehensions becomes apparent when working with complex structures like monad transformers. A <code>StateT</code> over <code>Optional</code> represents a <strong>stateful computation that can fail</strong>. Writing this with nested <code>flatMap</code> calls would be extremely complex. With the <code>For</code> builder, it becomes a simple, readable script.</p>
<pre><code class="language-java">import static org.higherkindedj.hkt.optional.OptionalKindHelper.OPTIONAL;
import static org.higherkindedj.hkt.state_t.StateTKindHelper.STATE_T;
// ... other imports

private static void stateTExample() {
    final var optionalMonad = OptionalMonad.INSTANCE;
    final var stateTMonad = StateTMonad.&lt;Integer, OptionalKind.Witness&gt;instance(optionalMonad);

    // Helper: adds a value to the state (an integer)
    final Function&lt;Integer, Kind&lt;StateTKind.Witness&lt;Integer, OptionalKind.Witness&gt;, Unit&gt;&gt; add =
        n -&gt; StateT.create(s -&gt; optionalMonad.of(StateTuple.of(s + n, Unit.INSTANCE)), optionalMonad);

    // Helper: gets the current state as the value
    final var get = StateT.&lt;Integer, OptionalKind.Witness, Integer&gt;create(s -&gt; optionalMonad.of(StateTuple.of(s, s)), optionalMonad);

    // This workflow looks like a simple script, but it's a fully-typed, purely functional composition!
    final var statefulComputation =
        For.from(stateTMonad, add.apply(10))      // Add 10 to state
            .from(a -&gt; add.apply(5))              // Then, add 5 more
            .from(b -&gt; get)                       // Then, get the current state (15)
            .let(t -&gt; "The state is " + t._3())   // Compute a string from it
            .yield((a, b, c, d) -&gt; d + ", original value was " + c); // Produce the final string

    // Run the computation with an initial state of 0
    final var resultOptional = STATE_T.runStateT(statefulComputation, 0);
    final Optional&lt;StateTuple&lt;Integer, String&gt;&gt; result = OPTIONAL.narrow(resultOptional);

    result.ifPresent(res -&gt; {
        System.out.println("Final value: " + res.value());
        System.out.println("Final state: " + res.state());
    });
    // Expected Output:
    // Final value: The state is 15, original value was 15
    // Final state: 15
}
</code></pre>
<p>In this example, Using the <code>For</code> comprehension really helps hide the complexity of threading the state (<code>Integer</code>) and handling potential failures (<code>Optional</code>), making the logic clear and maintainable.</p>
<p>For a more extensive example of using the full power of the For comprehension head over to the <a href="functional/../hkts/order-walkthrough.html">Order Workflow</a></p>
<h2 id="similarities-to-scala"><a class="header" href="#similarities-to-scala">Similarities to Scala</a></h2>
<p>If you're familiar with Scala, you'll recognise the pattern. In Scala, a for-comprehension looks like this:</p>
<pre><code class="language-scala">for {
 a &lt;- maybeA
 b &lt;- maybeB
 if (a + b &gt; 10)
 c = a + b
} yield c * 2
</code></pre>
<p>This is built in syntactic sugar that the compiler translates into a series of <code>flatMap</code>, <code>map</code>, and <code>withFilter</code> calls.
The <code>For</code> builder in <code>higher-kinded-j</code> provides the same expressive power through a method-chaining API.</p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="supported-types"><a class="header" href="#supported-types">Supported Types</a></h1>
<p><img src="monads/../images/monads_everywhere.webp" alt="monads_everywhere.webp" /></p>
<p>Higher-Kinded-J provides Higher-Kinded Type (HKT) simulation capabilities, allowing various Java types and custom types to be used with generic functional type classes like <code>Functor</code>, <code>Applicative</code>, <code>Monad</code>, and <code>MonadError</code>.</p>
<p>This is achieved by representing the application of a type constructor <code>F</code> to a type <code>A</code> as <code>Kind&lt;F_WITNESS, A&gt;</code>, where <code>F_WITNESS</code> is a special "witness" or phantom type unique to the type constructor <code>F</code>.</p>
<p><img src="monads/../images/puml/supported_types.svg" alt="supported_types.svg" /></p>
<hr />
<p><strong>Key for Understanding Entries:</strong></p>
<ul>
<li><strong>Type:</strong> The Java type or custom type being simulated.</li>
<li><strong><code>XxxKind&lt;A&gt;</code> Interface:</strong> The specific <code>Kind</code> interface for this type (e.g., <code>OptionalKind&lt;A&gt;</code>). It extends <code>Kind&lt;XxxKind.Witness, A&gt;</code> and usually contains the nested <code>final class Witness {}</code>.</li>
<li><strong>Witness Type <code>F_WITNESS</code>:</strong> The phantom type used as the first parameter to <code>Kind</code> (e.g., <code>OptionalKind.Witness</code>). This is what parameterizes the type classes (e.g., <code>Monad&lt;OptionalKind.Witness&gt;</code>).</li>
<li><strong><code>XxxKindHelper</code> Class:</strong> Provides <code>widen</code> and <code>narrow</code> methods.
<ul>
<li>For <strong>external types</strong> (like <code>java.util.List</code>, <code>java.util.Optional</code>), <code>widen</code> typically creates an internal <code>XxxHolder</code> record which implements <code>XxxKind&lt;A&gt;</code>, and <code>narrow</code> extracts the Java type from this holder.</li>
<li>For <strong>library-defined types</strong> (<code>Id</code>, <code>IO</code>, <code>Maybe</code>, <code>Either</code>, <code>Validated</code>, <code>Try</code>, monad transformers), the type itself directly implements <code>XxxKind&lt;A&gt;</code>. This means <code>widen</code> performs a null check and direct cast (zero overhead), and <code>narrow</code> checks <code>instanceof</code> the actual type and casts.</li>
</ul>
</li>
<li><strong>Type Class Instances:</strong> Concrete implementations of <code>Functor&lt;F_WITNESS&gt;</code>, <code>Monad&lt;F_WITNESS&gt;</code>, etc.</li>
</ul>
<hr />
<h3 id="1-ida-identity"><a class="header" href="#1-ida-identity">1. <code>Id&lt;A&gt;</code> (Identity)</a></h3>
<ul>
<li><strong>Type Definition</strong>: A custom record (<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/id/Id.java"><code>Id</code></a>) that directly wraps a value <code>A</code>. It's the simplest monad.</li>
<li><strong><code>IdKind&lt;A&gt;</code> Interface</strong>: <code>Id&lt;A&gt;</code> itself implements <code>IdKind&lt;A&gt;</code>, and <code>IdKind&lt;A&gt; extends Kind&lt;IdKind.Witness, A&gt;</code>.</li>
<li><strong>Witness Type <code>F_WITNESS</code></strong>: <code>IdKind.Witness</code></li>
<li><strong><code>IdKindHelper</code></strong>: <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/id/IdKindHelper.java"><code>IdKindHelper</code></a> (<code>wrap</code> casts <code>Id</code> to <code>Kind</code>, <code>unwrap</code> casts <code>Kind</code> to <code>Id</code>; <code>narrow</code> is a convenience for unwrap).</li>
<li><strong>Type Class Instances</strong>:
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/id/IdMonad.java"><code>IdMonad</code></a> (<code>Monad&lt;IdKind.Witness&gt;</code>)</li>
</ul>
</li>
<li><strong>Notes</strong>: <code>Id.of(a)</code> creates <code>Id(a)</code>. <code>map</code> and <code>flatMap</code> operate directly. Useful as a base for monad transformers and generic programming with no extra effects. <code>Id&lt;A&gt;</code> directly implements <code>IdKind&lt;A&gt;</code>.</li>
<li><strong>Usage</strong>: <a href="monads/./identity.html">How to use the Identity Monad</a></li>
</ul>
<hr />
<h3 id="2-javautillista"><a class="header" href="#2-javautillista">2. <code>java.util.List&lt;A&gt;</code></a></h3>
<ul>
<li><strong>Type Definition</strong>: Standard Java <code>java.util.List&lt;A&gt;</code>.</li>
<li><strong><code>ListKind&lt;A&gt;</code> Interface</strong>: <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/list/ListKind.java"><code>ListKind&lt;A&gt;</code></a> extends <code>Kind&lt;ListKind.Witness, A&gt;</code>.</li>
<li><strong>Witness Type <code>F_WITNESS</code></strong>: <code>ListKind.Witness</code></li>
<li><strong><code>ListKindHelper</code></strong>: Uses an internal <code>ListHolder&lt;A&gt;</code> record that implements <code>ListKind&lt;A&gt;</code> to wrap <code>java.util.List&lt;A&gt;</code>.</li>
<li><strong>Type Class Instances</strong>:
<ul>
<li><code>ListFunctor</code> (<code>Functor&lt;ListKind.Witness&gt;</code>)</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/list/ListMonad.java"><code>ListMonad</code></a> (<code>Monad&lt;ListKind.Witness&gt;</code>)</li>
</ul>
</li>
<li><strong>Notes</strong>: Standard list monad behaviour. <code>of(a)</code> creates a singleton list <code>List.of(a)</code>; <code>of(null)</code> results in an empty list.</li>
<li><strong>Usage</strong>: <a href="monads/./list_monad.html">How to use the List Monad</a></li>
</ul>
<hr />
<h3 id="3-javautilstreamstreama"><a class="header" href="#3-javautilstreamstreama">3. <code>java.util.stream.Stream&lt;A&gt;</code></a></h3>
<ul>
<li><strong>Type Definition</strong>: Standard Java <code>java.util.stream.Stream&lt;A&gt;</code>.</li>
<li><strong><code>StreamKind&lt;A&gt;</code> Interface</strong>: <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/stream/StreamKind.java"><code>StreamKind&lt;A&gt;</code></a> extends <code>Kind&lt;StreamKind.Witness, A&gt;</code>.</li>
<li><strong>Witness Type <code>F_WITNESS</code></strong>: <code>StreamKind.Witness</code></li>
<li><strong><code>StreamKindHelper</code></strong>: Uses an internal <code>StreamHolder&lt;A&gt;</code> record that implements <code>StreamKind&lt;A&gt;</code> to wrap <code>java.util.stream.Stream&lt;A&gt;</code>. Provides <code>widen</code>, <code>narrow</code>.</li>
<li><strong>Type Class Instances</strong>:
<ul>
<li><code>StreamFunctor</code> (<code>Functor&lt;StreamKind.Witness&gt;</code>)</li>
<li><code>StreamApplicative</code> (<code>Applicative&lt;StreamKind.Witness&gt;</code>)</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/stream/StreamMonad.java"><code>StreamMonad</code></a> (<code>MonadZero&lt;StreamKind.Witness&gt;</code>)</li>
<li><code>StreamTraverse</code> (<code>Traverse&lt;StreamKind.Witness&gt;</code>, <code>Foldable&lt;StreamKind.Witness&gt;</code>)</li>
</ul>
</li>
<li><strong>Notes</strong>: Lazy, potentially infinite sequences with <strong>single-use semantics</strong> - each Stream can only be consumed once. Attempting to reuse a consumed stream throws <code>IllegalStateException</code>. <code>of(a)</code> creates singleton stream; <code>of(null)</code> creates empty stream. <code>zero()</code> returns empty stream. Use <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/stream/StreamOps.java"><code>StreamOps</code></a> for additional utility operations.</li>
<li><strong>Usage</strong>: <a href="monads/./stream_monad.html">How to use the Stream Monad</a></li>
</ul>
<hr />
<h3 id="4-trampolinea"><a class="header" href="#4-trampolinea">4. <code>Trampoline&lt;A&gt;</code></a></h3>
<ul>
<li><strong>Type Definition</strong>: Custom sealed interface (<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/trampoline/Trampoline.java"><code>Trampoline</code></a>) implementing stack-safe recursion through trampolining. Provides three constructors: <code>Done&lt;A&gt;</code> (completed computation), <code>More&lt;A&gt;</code> (deferred computation), and <code>FlatMap&lt;A, B&gt;</code> (monadic sequencing).</li>
<li><strong><code>TrampolineKind&lt;A&gt;</code> Interface</strong>: <code>Trampoline&lt;A&gt;</code> itself implements <code>TrampolineKind&lt;A&gt;</code>, and <code>TrampolineKind&lt;A&gt; extends Kind&lt;TrampolineKind.Witness, A&gt;</code>.</li>
<li><strong>Witness Type <code>F_WITNESS</code></strong>: <code>TrampolineKind.Witness</code></li>
<li><strong><code>TrampolineKindHelper</code></strong>: <code>widen</code> casts <code>Trampoline</code> to <code>Kind</code>; <code>narrow</code> casts <code>Kind</code> to <code>Trampoline</code>. Provides <code>done(value)</code> for completed computations and <code>defer(supplier)</code> for deferred evaluation.</li>
<li><strong>Type Class Instances</strong>:
<ul>
<li><code>TrampolineFunctor</code> (<code>Functor&lt;TrampolineKind.Witness&gt;</code>)</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/trampoline/TrampolineMonad.java"><code>TrampolineMonad</code></a> (<code>Monad&lt;TrampolineKind.Witness&gt;</code>)</li>
</ul>
</li>
<li><strong>Notes</strong>: Enables stack-safe tail recursion by converting recursive calls into iterative data structure processing, preventing <code>StackOverflowError</code> in deeply recursive computations (verified with 100,000+ iterations). <code>done(value)</code> creates an already evaluated result; <code>defer(supplier)</code> defers computation. The <code>run()</code> method executes the trampoline iteratively using an explicit stack. Essential for recursive algorithms (factorial, Fibonacci, tree traversals) and provides <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/trampoline/TrampolineUtils.java"><code>TrampolineUtils</code></a> for guaranteed stack-safe applicative operations.</li>
<li><strong>Usage</strong>: <a href="monads/./trampoline_monad.html">How to use the Trampoline Monad</a></li>
</ul>
<hr />
<h3 id="5-freef-a"><a class="header" href="#5-freef-a">5. <code>Free&lt;F, A&gt;</code></a></h3>
<ul>
<li><strong>Type Definition</strong>: Custom sealed interface (<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/free/Free.java"><code>Free</code></a>) representing programmes as data structures that can be interpreted in different ways. Provides three constructors: <code>Pure&lt;F,A&gt;</code> (terminal value), <code>Suspend&lt;F,A&gt;</code> (suspended computation), and <code>FlatMapped&lt;F,X,A&gt;</code> (monadic sequencing).</li>
<li><strong><code>FreeKind&lt;F, A&gt;</code> Interface</strong>: <code>Free&lt;F,A&gt;</code> itself implements <code>FreeKind&lt;F,A&gt;</code>, and <code>FreeKind&lt;F,A&gt; extends Kind&lt;FreeKind.Witness&lt;F&gt;, A&gt;</code>.</li>
<li><strong>Witness Type <code>F_WITNESS</code></strong>: <code>FreeKind.Witness&lt;F&gt;</code> (where <code>F</code> is the instruction set functor)</li>
<li><strong><code>FreeKindHelper</code></strong>: <code>widen</code> casts <code>Free</code> to <code>Kind</code>; <code>narrow</code> casts <code>Kind</code> to <code>Free</code>. Provides <code>pure(value)</code>, <code>suspend(computation)</code>, <code>liftF(fa, functor)</code>.</li>
<li><strong>Type Class Instances</strong>:
<ul>
<li><code>FreeFunctor&lt;F&gt;</code> (<code>Functor&lt;FreeKind.Witness&lt;F&gt;&gt;</code>)</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/free/FreeMonad.java"><code>FreeMonad&lt;F&gt;</code></a> (<code>Monad&lt;FreeKind.Witness&lt;F&gt;&gt;</code>)</li>
</ul>
</li>
<li><strong>Notes</strong>: Enables building domain-specific languages (DSLs) as composable data structures. Programmes are interpreted via <code>foldMap</code> with natural transformations, allowing multiple interpreters (IO, Test, Optimisation, etc.). Stack-safe execution using Higher-Kinded-J's <code>Trampoline</code> monad internally, demonstrating library composability (verified with 10,000+ operations). Essential for separating programme description from execution, enabling testability and alternative interpretations. Provides <code>liftF</code> to lift functor values into Free, <code>map</code> and <code>flatMap</code> for composition, and <code>foldMap</code> for interpretation. Useful for building testable workflows, query languages, and effect systems where the same programme needs different execution strategies.</li>
<li><strong>Usage</strong>: <a href="monads/./free_monad.html">How to use the Free Monad</a></li>
</ul>
<hr />
<h3 id="6-javautiloptionala"><a class="header" href="#6-javautiloptionala">6. <code>java.util.Optional&lt;A&gt;</code></a></h3>
<ul>
<li><strong>Type Definition</strong>: Standard Java <code>java.util.Optional&lt;A&gt;</code>.</li>
<li><strong><code>OptionalKind&lt;A&gt;</code> Interface</strong>: <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/optional/OptionalKind.java"><code>OptionalKind&lt;A&gt;</code></a> extends <code>Kind&lt;OptionalKind.Witness, A&gt;</code>.</li>
<li><strong>Witness Type <code>F_WITNESS</code></strong>: <code>OptionalKind.Witness</code></li>
<li><strong><code>OptionalKindHelper</code></strong>: Uses an internal <code>OptionalHolder&lt;A&gt;</code> record that implements <code>OptionalKind&lt;A&gt;</code> to wrap <code>java.util.Optional&lt;A&gt;</code>.</li>
<li><strong>Type Class Instances</strong>:
<ul>
<li><code>OptionalFunctor</code> (<code>Functor&lt;OptionalKind.Witness&gt;</code>)</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/optional/OptionalMonad.java"><code>OptionalMonad</code></a> (<code>MonadError&lt;OptionalKind.Witness, Unit&gt;</code>)</li>
</ul>
</li>
<li><strong>Notes</strong>: <code>Optional.empty()</code> is the error state. <code>raiseError(Unit.INSTANCE)</code> creates <code>Optional.empty()</code>. <code>of(value)</code> uses <code>Optional.ofNullable(value)</code>.</li>
<li><strong>Usage</strong>: <a href="monads/./optional_monad.html">How to use the Optional Monad</a></li>
</ul>
<hr />
<h3 id="7-maybea"><a class="header" href="#7-maybea">7. <code>Maybe&lt;A&gt;</code></a></h3>
<ul>
<li><strong>Type Definition</strong>: Custom sealed interface (<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/maybe/Maybe.java"><code>Maybe</code></a>) with <code>Just&lt;A&gt;</code> (non-null) and <code>Nothing&lt;A&gt;</code> implementations.</li>
<li><strong><code>MaybeKind&lt;A&gt;</code> Interface</strong>: <code>Just&lt;T&gt;</code> and <code>Nothing&lt;T&gt;</code> directly implement <code>MaybeKind&lt;T&gt;</code>, which extends <code>Kind&lt;MaybeKind.Witness, T&gt;</code>.</li>
<li><strong>Witness Type <code>F_WITNESS</code></strong>: <code>MaybeKind.Witness</code></li>
<li><strong><code>MaybeKindHelper</code></strong>: <code>widen</code> performs null check and casts <code>Maybe</code> to <code>Kind</code> (zero overhead); <code>narrow</code> checks <code>instanceof Maybe</code> and casts. Provides <code>just(value)</code>, <code>nothing()</code>, <code>fromNullable(value)</code>.</li>
<li><strong>Type Class Instances</strong>:
<ul>
<li><code>MaybeFunctor</code> (<code>Functor&lt;MaybeKind.Witness&gt;</code>)</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/maybe/MaybeMonad.java"><code>MaybeMonad</code></a> (<code>MonadError&lt;MaybeKind.Witness, Unit&gt;</code>)</li>
</ul>
</li>
<li><strong>Notes</strong>: <code>Nothing</code> is the error state; <code>raiseError(Unit.INSTANCE</code>) creates <code>Nothing</code>. <code>Maybe.just(value)</code> requires non-null. <code>MaybeMonad.of(value)</code> uses <code>Maybe.fromNullable()</code>.</li>
<li><strong>Usage</strong>: <a href="monads/./maybe_monad.html">How to use the Maybe Monad</a></li>
</ul>
<hr />
<h3 id="8-eitherl-r"><a class="header" href="#8-eitherl-r">8. <code>Either&lt;L, R&gt;</code></a></h3>
<ul>
<li><strong>Type Definition</strong>: Custom sealed interface (<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/either/Either.java"><code>Either</code></a>) with <code>Left&lt;L,R&gt;</code> and <code>Right&lt;L,R&gt;</code> records.</li>
<li><strong><code>EitherKind&lt;L, R&gt;</code> Interface</strong>: <code>Either.Left&lt;L,R&gt;</code> and <code>Either.Right&lt;L,R&gt;</code> directly implement <code>EitherKind&lt;L,R&gt;</code> (and <code>EitherKind2&lt;L,R&gt;</code> for bifunctor operations), which extends <code>Kind&lt;EitherKind.Witness&lt;L&gt;, R&gt;</code>.</li>
<li><strong>Witness Type <code>F_WITNESS</code></strong>: <code>EitherKind.Witness&lt;L&gt;</code> (Error type <code>L</code> is fixed for the witness).</li>
<li><strong><code>EitherKindHelper</code></strong>: <code>widen</code> performs null check and casts <code>Either</code> to <code>Kind</code> (zero overhead); <code>narrow</code> checks <code>instanceof Either</code> and casts. Provides <code>left(l)</code>, <code>right(r)</code>.</li>
<li><strong>Type Class Instances</strong>:
<ul>
<li><code>EitherFunctor&lt;L&gt;</code> (<code>Functor&lt;EitherKind.Witness&lt;L&gt;&gt;</code>)</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/either/EitherMonad.java"><code>EitherMonad&lt;L&gt;</code></a> (<code>MonadError&lt;EitherKind.Witness&lt;L&gt;, L&gt;</code>)</li>
</ul>
</li>
<li><strong>Notes</strong>: Right-biased. <code>Left(l)</code> is the error state. <code>of(r)</code> creates <code>Right(r)</code>.</li>
<li><strong>Usage</strong>: <a href="monads/./either_monad.html">How to use the Either Monad</a></li>
</ul>
<hr />
<h3 id="9-trya"><a class="header" href="#9-trya">9. <code>Try&lt;A&gt;</code></a></h3>
<ul>
<li><strong>Type Definition</strong>: Custom sealed interface (<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/trymonad/Try.java"><code>Try</code></a>) with <code>Success&lt;A&gt;</code> and <code>Failure&lt;A&gt;</code> (wrapping <code>Throwable</code>).</li>
<li><strong><code>TryKind&lt;A&gt;</code> Interface</strong>: <code>Try&lt;A&gt;</code> itself implements <code>TryKind&lt;A&gt;</code>, and <code>TryKind&lt;A&gt; extends Kind&lt;TryKind.Witness, A&gt;</code>.</li>
<li><strong>Witness Type <code>F_WITNESS</code></strong>: <code>TryKind.Witness</code></li>
<li><strong><code>TryKindHelper</code></strong>: <code>wrap</code> casts <code>Try</code> to <code>Kind</code>; <code>unwrap</code> casts <code>Kind</code> to <code>Try</code>. Provides <code>success(value)</code>, <code>failure(throwable)</code>, <code>tryOf(supplier)</code>.</li>
<li><strong>Type Class Instances</strong>:
<ul>
<li><code>TryFunctor</code> (<code>Functor&lt;TryKind.Witness&gt;</code>)</li>
<li><code>TryApplicative</code> (<code>Applicative&lt;TryKind.Witness&gt;</code>)</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/trymonad/TryMonad.java"><code>TryMonad</code></a> (<code>MonadError&lt;TryKind.Witness, Throwable&gt;</code>)</li>
</ul>
</li>
<li><strong>Notes</strong>: <code>Failure(t)</code> is the error state. <code>of(v)</code> creates <code>Success(v)</code>.</li>
<li><strong>Usage</strong>: <a href="monads/./try_monad.html">How to use the Try Monad</a></li>
</ul>
<hr />
<h3 id="10-javautilconcurrentcompletablefuturea"><a class="header" href="#10-javautilconcurrentcompletablefuturea">10. <code>java.util.concurrent.CompletableFuture&lt;A&gt;</code></a></h3>
<ul>
<li><strong>Type Definition</strong>: Standard Java <code>java.util.concurrent.CompletableFuture&lt;A&gt;</code>.</li>
<li><strong><code>CompletableFutureKind&lt;A&gt;</code> Interface</strong>: <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/future/CompletableFutureKind.java"><code>CompletableFutureKind&lt;A&gt;</code></a> extends <code>Kind&lt;CompletableFutureKind.Witness, A&gt;</code>.</li>
<li><strong>Witness Type <code>F_WITNESS</code></strong>: <code>CompletableFutureKind.Witness</code></li>
<li><strong><code>CompletableFutureKindHelper</code></strong>: Uses an internal <code>CompletableFutureHolder&lt;A&gt;</code> record. Provides <code>wrap</code>, <code>unwrap</code>, <code>join</code>.</li>
<li><strong>Type Class Instances</strong>:
<ul>
<li><code>CompletableFutureFunctor</code> (<code>Functor&lt;CompletableFutureKind.Witness&gt;</code>)</li>
<li><code>CompletableFutureApplicative</code> (<code>Applicative&lt;CompletableFutureKind.Witness&gt;</code>)</li>
<li><code>CompletableFutureMonad</code> (<code>Monad&lt;CompletableFutureKind.Witness&gt;</code>)</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/future/CompletableFutureMonad.java"><code>CompletableFutureMonad</code></a> (<code>MonadError&lt;CompletableFutureKind.Witness, Throwable&gt;</code>)</li>
</ul>
</li>
<li><strong>Notes</strong>: Represents asynchronous computations. A failed future is the error state. <code>of(v)</code> creates <code>CompletableFuture.completedFuture(v)</code>.</li>
<li><strong>Usage</strong>: <a href="monads/./cf_monad.html">How to use the CompletableFuture Monad</a></li>
</ul>
<hr />
<h3 id="11-ioa"><a class="header" href="#11-ioa">11. <code>IO&lt;A&gt;</code></a></h3>
<ul>
<li><strong>Type Definition</strong>: Custom interface (<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/io/IO.java"><code>IO</code></a>) representing a deferred, potentially side-effecting computation.</li>
<li><strong><code>IOKind&lt;A&gt;</code> Interface</strong>: <code>IO&lt;A&gt;</code> directly extends <code>IOKind&lt;A&gt;</code>, which extends <code>Kind&lt;IOKind.Witness, A&gt;</code>.</li>
<li><strong>Witness Type <code>F_WITNESS</code></strong>: <code>IOKind.Witness</code></li>
<li><strong><code>IOKindHelper</code></strong>: <code>widen</code> performs null check and returns the <code>IO</code> directly as <code>Kind</code> (zero overhead); <code>narrow</code> checks <code>instanceof IO</code> and casts. Provides <code>delay(supplier)</code>, <code>unsafeRunSync(kind)</code>.</li>
<li><strong>Type Class Instances</strong>:
<ul>
<li><code>IOFunctor</code> (<code>Functor&lt;IOKind.Witness&gt;</code>)</li>
<li><code>IOApplicative</code> (<code>Applicative&lt;IOKind.Witness&gt;</code>)</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/io/IOMonad.java"><code>IOMonad</code></a> (<code>Monad&lt;IOKind.Witness&gt;</code>)</li>
</ul>
</li>
<li><strong>Notes</strong>: Evaluation is deferred until <code>unsafeRunSync</code>. Exceptions during execution are generally unhandled by <code>IOMonad</code> itself unless caught within the IO's definition.</li>
<li><strong>Usage</strong>: <a href="monads/./io_monad.html">How to use the IO Monad</a></li>
</ul>
<hr />
<h3 id="12-lazya"><a class="header" href="#12-lazya">12. <code>Lazy&lt;A&gt;</code></a></h3>
<ul>
<li><strong>Type Definition</strong>: Custom class (<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/lazy/Lazy.java"><code>Lazy</code></a>) for deferred computation with memoization.</li>
<li><strong><code>LazyKind&lt;A&gt;</code> Interface</strong>: <code>Lazy&lt;A&gt;</code> itself implements <code>LazyKind&lt;A&gt;</code>, and <code>LazyKind&lt;A&gt; extends Kind&lt;LazyKind.Witness, A&gt;</code>.</li>
<li><strong>Witness Type <code>F_WITNESS</code></strong>: <code>LazyKind.Witness</code></li>
<li><strong><code>LazyKindHelper</code></strong>: <code>wrap</code> casts <code>Lazy</code> to <code>Kind</code>; <code>unwrap</code> casts <code>Kind</code> to <code>Lazy</code>. Provides <code>defer(supplier)</code>, <code>now(value)</code>, <code>force(kind)</code>.</li>
<li><strong>Type Class Instances</strong>:
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/lazy/LazyMonad.java"><code>LazyMonad</code></a> (<code>Monad&lt;LazyKind.Witness&gt;</code>)</li>
</ul>
</li>
<li><strong>Notes</strong>: Result or exception is memoized. <code>of(a)</code> creates an already evaluated <code>Lazy.now(a)</code>.</li>
<li><strong>Usage</strong>: <a href="monads/./lazy_monad.html">How to use the Lazy Monad</a></li>
</ul>
<hr />
<h3 id="13-readerr_env-a"><a class="header" href="#13-readerr_env-a">13. <code>Reader&lt;R_ENV, A&gt;</code></a></h3>
<ul>
<li><strong>Type Definition</strong>: Custom functional interface (<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/reader/Reader.java"><code>Reader</code></a>) wrapping <code>Function&lt;R_ENV, A&gt;</code>.</li>
<li><strong><code>ReaderKind&lt;R_ENV, A&gt;</code> Interface</strong>: <code>Reader&lt;R_ENV,A&gt;</code> itself implements <code>ReaderKind&lt;R_ENV,A&gt;</code>, and <code>ReaderKind&lt;R_ENV,A&gt; extends Kind&lt;ReaderKind.Witness&lt;R_ENV&gt;, A&gt;</code>.</li>
<li><strong>Witness Type <code>F_WITNESS</code></strong>: <code>ReaderKind.Witness&lt;R_ENV&gt;</code> (Environment type <code>R_ENV</code> is fixed).</li>
<li><strong><code>ReaderKindHelper</code></strong>: <code>wrap</code> casts <code>Reader</code> to <code>Kind</code>; <code>unwrap</code> casts <code>Kind</code> to <code>Reader</code>. Provides <code>reader(func)</code>, <code>ask()</code>, <code>constant(value)</code>, <code>runReader(kind, env)</code>.</li>
<li><strong>Type Class Instances</strong>:
<ul>
<li><code>ReaderFunctor&lt;R_ENV&gt;</code> (<code>Functor&lt;ReaderKind.Witness&lt;R_ENV&gt;&gt;</code>)</li>
<li><code>ReaderApplicative&lt;R_ENV&gt;</code> (<code>Applicative&lt;ReaderKind.Witness&lt;R_ENV&gt;&gt;</code>)</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/reader/ReaderMonad.java"><code>ReaderMonad&lt;R_ENV&gt;</code></a> (<code>Monad&lt;ReaderKind.Witness&lt;R_ENV&gt;&gt;</code>)</li>
</ul>
</li>
<li><strong>Notes</strong>: <code>of(a)</code> creates a <code>Reader</code> that ignores the environment and returns <code>a</code>.</li>
<li><strong>Usage</strong>: <a href="monads/./reader_monad.html">How to use the Reader Monad</a></li>
</ul>
<hr />
<h3 id="14-states-a"><a class="header" href="#14-states-a">14. <code>State&lt;S, A&gt;</code></a></h3>
<ul>
<li><strong>Type Definition</strong>: Custom functional interface (<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/state/State.java"><code>State</code></a>) wrapping <code>Function&lt;S, StateTuple&lt;S, A&gt;&gt;</code>.</li>
<li><strong><code>StateKind&lt;S,A&gt;</code> Interface</strong>: <code>State&lt;S,A&gt;</code> itself implements <code>StateKind&lt;S,A&gt;</code>, and <code>StateKind&lt;S,A&gt; extends Kind&lt;StateKind.Witness&lt;S&gt;, A&gt;</code>.</li>
<li><strong>Witness Type <code>F_WITNESS</code></strong>: <code>StateKind.Witness&lt;S&gt;</code> (State type <code>S</code> is fixed).</li>
<li><strong><code>StateKindHelper</code></strong>: <code>wrap</code> casts <code>State</code> to <code>Kind</code>; <code>unwrap</code> casts <code>Kind</code> to <code>State</code>. Provides <code>pure(value)</code>, <code>get()</code>, <code>set(state)</code>, <code>modify(func)</code>, <code>inspect(func)</code>, <code>runState(kind, initialState)</code>, etc.</li>
<li><strong>Type Class Instances</strong>:
<ul>
<li><code>StateFunctor&lt;S&gt;</code> (<code>Functor&lt;StateKind.Witness&lt;S&gt;&gt;</code>)</li>
<li><code>StateApplicative&lt;S&gt;</code> (<code>Applicative&lt;StateKind.Witness&lt;S&gt;&gt;</code>)</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/state/StateMonad.java"><code>StateMonad&lt;S&gt;</code></a> (<code>Monad&lt;StateKind.Witness&lt;S&gt;&gt;</code>)</li>
</ul>
</li>
<li><strong>Notes</strong>: <code>of(a)</code> (<code>pure</code>) returns <code>a</code> without changing state.</li>
<li><strong>Usage</strong>: <a href="monads/./state_monad.html">How to use the State Monad</a></li>
</ul>
<hr />
<h3 id="15-writerw-a"><a class="header" href="#15-writerw-a">15. <code>Writer&lt;W, A&gt;</code></a></h3>
<ul>
<li><strong>Type Definition</strong>: Custom record (<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/writer/Writer.java"><code>Writer</code></a>) holding <code>(W log, A value)</code>. Requires <code>Monoid&lt;W&gt;</code>.</li>
<li><strong><code>WriterKind&lt;W, A&gt;</code> Interface</strong>: <code>Writer&lt;W,A&gt;</code> itself implements <code>WriterKind&lt;W,A&gt;</code>, and <code>WriterKind&lt;W,A&gt; extends Kind&lt;WriterKind.Witness&lt;W&gt;, A&gt;</code>.</li>
<li><strong>Witness Type <code>F_WITNESS</code></strong>: <code>WriterKind.Witness&lt;W&gt;</code> (Log type <code>W</code> and its <code>Monoid</code> are fixed).</li>
<li><strong><code>WriterKindHelper</code></strong>: <code>wrap</code> casts <code>Writer</code> to <code>Kind</code>; <code>unwrap</code> casts <code>Kind</code> to <code>Writer</code>. Provides <code>value(monoid, val)</code>, <code>tell(monoid, log)</code>, <code>runWriter(kind)</code>, etc.</li>
<li><strong>Type Class Instances</strong>: (Requires <code>Monoid&lt;W&gt;</code> for Applicative/Monad)
<ul>
<li><code>WriterFunctor&lt;W&gt;</code> (<code>Functor&lt;WriterKind.Witness&lt;W&gt;&gt;</code>)</li>
<li><code>WriterApplicative&lt;W&gt;</code> (<code>Applicative&lt;WriterKind.Witness&lt;W&gt;&gt;</code>)</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/writer/WriterMonad.java"><code>WriterMonad&lt;W&gt;</code></a> (<code>Monad&lt;WriterKind.Witness&lt;W&gt;&gt;</code>)</li>
</ul>
</li>
<li><strong>Notes</strong>: <code>of(a)</code> (<code>value</code>) produces <code>a</code> with an empty log (from <code>Monoid.empty()</code>).</li>
<li><strong>Usage</strong>: <a href="monads/./writer_monad.html">How to use the Writer Monad</a></li>
</ul>
<hr />
<h3 id="16-validatede-a"><a class="header" href="#16-validatede-a">16. <code>Validated&lt;E, A&gt;</code></a></h3>
<ul>
<li><strong>Type Definition</strong>: Custom sealed interface (<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/validated/Validated.java"><code>Validated</code></a>) with <code>Valid&lt;E, A&gt;</code> (holding <code>A</code>) and <code>Invalid&lt;E, A&gt;</code> (holding <code>E</code>) implementations.</li>
<li><strong><code>ValidatedKind&lt;E, A&gt;</code> Interface</strong>: Defines the HKT structure (<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/validated/ValidatedKind.java"><code>ValidatedKind</code></a>) for <code>Validated&lt;E,A&gt;</code>. It extends <code>Kind&lt;ValidatedKind.Witness&lt;E&gt;, A&gt;</code>. Concrete <code>Valid&lt;E,A&gt;</code> and <code>Invalid&lt;E,A&gt;</code> instances are cast to this kind by <code>ValidatedKindHelper</code>.</li>
<li><strong>Witness Type <code>F_WITNESS</code></strong>: <code>ValidatedKind.Witness&lt;E&gt;</code> (Error type <code>E</code> is fixed for the HKT witness).</li>
<li><strong><code>ValidatedKindHelper</code> Class</strong>: (<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/validated/ValidatedKindHelper.java"><code>ValidatedKindHelper</code></a>). <code>widen</code> casts <code>Validated&lt;E,A&gt;</code> (specifically <code>Valid</code> or <code>Invalid</code> instances) to <code>Kind&lt;ValidatedKind.Witness&lt;E&gt;, A&gt;</code>. <code>narrow</code> casts <code>Kind</code> back to <code>Validated&lt;E,A&gt;</code>. Provides static factory methods <code>valid(value)</code> and <code>invalid(error)</code> that return the Kind-wrapped type.</li>
<li><strong>Type Class Instances</strong>: (Error type <code>E</code> is fixed for the monad instance)
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/validated/ValidatedMonad.java"><code>ValidatedMonad&lt;E&gt;</code></a> (<code>MonadError&lt;ValidatedKind.Witness&lt;E&gt;, E&gt;</code>). This also provides <code>Monad</code>, <code>Functor</code>, and <code>Applicative</code> behaviour.</li>
</ul>
</li>
<li><strong>Notes</strong>: <code>Validated</code> is right-biased, meaning operations like <code>map</code> and <code>flatMap</code> apply to the <code>Valid</code> case and propagate <code>Invalid</code> untouched. <code>ValidatedMonad.of(a)</code> creates a <code>Valid(a)</code>. As a <code>MonadError</code>, <code>ValidatedMonad</code> provides <code>raiseError(error)</code> to create an <code>Invalid(error)</code> and <code>handleErrorWith(kind, handler)</code> for standardised error recovery. The <code>ap</code> method is also right-biased and does not accumulate errors from multiple <code>Invalid</code>s in the typical applicative sense; it propagates the first <code>Invalid</code> encountered or an <code>Invalid</code> function.</li>
<li><strong>Usage</strong>: <a href="monads/./validated_monad.html">How to use the Validated Monad</a></li>
</ul>
<hr />
<h3 id="17-constc-a"><a class="header" href="#17-constc-a">17. <code>Const&lt;C, A&gt;</code></a></h3>
<ul>
<li><strong>Type Definition</strong>: Custom record (<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/constant/Const.java"><code>Const</code></a>) holding a constant value of type <code>C</code> whilst treating <code>A</code> as a phantom type parameter (present in the type signature but not stored).</li>
<li><strong><code>ConstKind2&lt;C, A&gt;</code> Interface</strong>: (<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/constant/ConstKind2.java"><code>ConstKind2&lt;C, A&gt;</code></a>) extends <code>Kind2&lt;ConstKind2.Witness, C, A&gt;</code>. This interface allows <code>Const</code> to be used with bifunctor operations.</li>
<li><strong>Witness Type <code>F_WITNESS</code></strong>: <code>ConstKind2.Witness</code> (used for bifunctor type class instances).</li>
<li><strong><code>ConstKindHelper</code> Class</strong>: (<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/constant/ConstKindHelper.java"><code>ConstKindHelper</code></a>). Provides <code>widen2</code> to cast <code>Const&lt;C, A&gt;</code> to <code>Kind2&lt;ConstKind2.Witness, C, A&gt;</code> and <code>narrow2</code> to cast back. Uses an internal <code>ConstKind2Holder&lt;C, A&gt;</code> record that implements <code>ConstKind2&lt;C, A&gt;</code>.</li>
<li><strong>Type Class Instances</strong>: (Only bifunctor, no monad instance as mapping the phantom type has no computational effect)
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/constant/ConstBifunctor.java"><code>ConstBifunctor</code></a> (<code>Bifunctor&lt;ConstKind2.Witness&gt;</code>). This instance provides <code>first</code> (transforms the constant value), <code>second</code> (changes only the phantom type), and <code>bimap</code> (combines both, though only <code>first</code> affects the constant value).</li>
</ul>
</li>
<li><strong>Notes</strong>: The second type parameter <code>A</code> is <strong>phantom</strong>‚Äîit exists only in the type signature and has no runtime representation. Calling <code>mapSecond</code> or <code>second</code> preserves the constant value whilst changing the phantom type in the signature. This makes <code>Const</code> particularly useful for fold implementations (accumulating a single value), getter patterns in lens libraries (van Laarhoven lenses), and data extraction from structures without transformation. The mapper function in <code>second</code> is applied to <code>null</code> for exception propagation, so use null-safe mappers. Similar to <code>Const</code> in Scala's Cats and Scalaz libraries.</li>
<li><strong>Usage</strong>: <a href="monads/./const_type.html">How to use the Const Type</a></li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="the-completablefuturemonad"><a class="header" href="#the-completablefuturemonad">The CompletableFutureMonad:</a></h1>
<h2 id="asynchronous-computations-with-completablefuture"><a class="header" href="#asynchronous-computations-with-completablefuture"><em>Asynchronous Computations with <code>CompletableFuture</code></em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="monads/cf_monad.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to compose asynchronous operations functionally</li>
<li>Using MonadError capabilities for async error handling and recovery</li>
<li>Building non-blocking workflows with <code>map</code>, <code>flatMap</code>, and <code>handleErrorWith</code></li>
<li>Integration with EitherT for combining async operations with typed errors</li>
<li>Real-world patterns for resilient microservice communication</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code:</p>
</div>
<a class="admonition-anchor-link" href="monads/cf_monad.html#admonition-see-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/future/CompletableFutureExample.java">CompletableFutureExample.java</a></p>
</div>
</div>
<p>Java's <code>java.util.concurrent.CompletableFuture&lt;T&gt;</code> is a powerful tool for asynchronous programming. The <code>higher-kinded-j</code> library provides a way to treat <code>CompletableFuture</code> as a monadic context using the HKT simulation. This allows developers to compose asynchronous operations and handle their potential failures (<code>Throwable</code>) in a more functional and generic style, leveraging type classes like <code>Functor</code>, <code>Applicative</code>, <code>Monad</code>, and crucially, <code>MonadError</code>.</p>
<p><strong>Higher-Kinded Bridge for CompletableFuture</strong></p>
<p><img src="monads/../images/puml/cf_kind.svg" alt="cf_kind.svg" /></p>
<p><strong>TypeClasses</strong></p>
<p><img src="monads/../images/puml/cf_monad.svg" alt="cf_monad.svg" /></p>
<p>The simulation for <code>CompletableFuture</code> involves these components:</p>
<ol>
<li><strong><code>CompletableFuture&lt;A&gt;</code></strong>: The standard Java class representing an asynchronous computation that will eventually result in a value of type <code>A</code> or fail with an exception (a <code>Throwable</code>).</li>
<li><strong><code>CompletableFutureKind&lt;A&gt;</code></strong>: The HKT marker interface (<code>Kind&lt;CompletableFutureKind.Witness, A&gt;</code>) for <code>CompletableFuture</code>. This allows <code>CompletableFuture</code> to be used generically with type classes. The witness type is <code>CompletableFutureKind.Witness</code>.</li>
<li><strong><code>CompletableFutureKindHelper</code></strong>: The utility class for bridging between <code>CompletableFuture&lt;A&gt;</code> and <code>CompletableFutureKind&lt;A&gt;</code>. Key methods:
<ul>
<li><code>widen(CompletableFuture&lt;A&gt;)</code>: Wraps a standard <code>CompletableFuture</code> into its <code>Kind</code> representation.</li>
<li><code>narrow(Kind&lt;CompletableFutureKind.Witness, A&gt;)</code>: Unwraps the <code>Kind</code> back to the concrete <code>CompletableFuture</code>. Throws <code>KindUnwrapException</code> if the input Kind is invalid.</li>
<li><code>join(Kind&lt;CompletableFutureKind.Witness, A&gt;)</code>: A convenience method to unwrap the <code>Kind</code> and then block (<code>join()</code>) on the underlying <code>CompletableFuture</code> to get its result. It re-throws runtime exceptions and errors directly but wraps checked exceptions in <code>CompletionException</code>. <em>Use primarily for testing or at the very end of an application where blocking is acceptable.</em></li>
</ul>
</li>
<li><strong><code>CompletableFutureFunctor</code></strong>: Implements <code>Functor&lt;CompletableFutureKind.Witness&gt;</code>. Provides <code>map</code>, which corresponds to <code>CompletableFuture.thenApply()</code>.</li>
<li><strong><code>CompletableFutureApplicative</code></strong>: Extends <code>Functor</code>, implements <code>Applicative&lt;CompletableFutureKind.Witness&gt;</code>.
<ul>
<li><code>of(A value)</code>: Creates an already successfully completed <code>CompletableFutureKind</code> using <code>CompletableFuture.completedFuture(value)</code>.</li>
<li><code>ap(Kind&lt;F, Function&lt;A,B&gt;&gt;, Kind&lt;F, A&gt;)</code>: Corresponds to <code>CompletableFuture.thenCombine()</code>, applying a function from one future to the value of another when both complete.</li>
</ul>
</li>
<li><strong><code>CompletableFutureMonad</code></strong>: Extends <code>Applicative</code>, implements <code>Monad&lt;CompletableFutureKind.Witness&gt;</code>.
<ul>
<li><code>flatMap(Function&lt;A, Kind&lt;F, B&gt;&gt;, Kind&lt;F, A&gt;)</code>: Corresponds to <code>CompletableFuture.thenCompose()</code>, sequencing asynchronous operations where one depends on the result of the previous one.</li>
</ul>
</li>
<li><strong><code>CompletableFutureMonad</code></strong>: Extends <code>Monad</code>, implements <code>MonadError&lt;CompletableFutureKind.Witness, Throwable&gt;</code>. This is often the most useful instance to work with.
<ul>
<li><code>raiseError(Throwable error)</code>: Creates an already exceptionally completed <code>CompletableFutureKind</code> using <code>CompletableFuture.failedFuture(error)</code>.</li>
<li><code>handleErrorWith(Kind&lt;F, A&gt;, Function&lt;Throwable, Kind&lt;F, A&gt;&gt;)</code>: Corresponds to <code>CompletableFuture.exceptionallyCompose()</code>, allowing asynchronous recovery from failures.</li>
</ul>
</li>
</ol>
<h2 id="purpose-and-usage"><a class="header" href="#purpose-and-usage">Purpose and Usage</a></h2>
<ul>
<li><strong>Functional Composition of Async Ops</strong>: Use <code>map</code>, <code>ap</code>, and <code>flatMap</code> (via the type class instances) to build complex asynchronous workflows in a declarative style, similar to how you'd compose synchronous operations with <code>Optional</code> or <code>List</code>.</li>
<li><strong>Unified Error Handling</strong>: Treat asynchronous failures (<code>Throwable</code>) consistently using <code>MonadError</code> operations (<code>raiseError</code>, <code>handleErrorWith</code>). This allows integrating error handling directly into the composition chain.</li>
<li><strong>HKT Integration</strong>: Enables writing generic code that can operate on <code>CompletableFuture</code> alongside other simulated monadic types (like <code>Optional</code>, <code>Either</code>, <code>IO</code>) by programming against the <code>Kind&lt;F, A&gt;</code> interface and type classes. This is powerfully demonstrated when using <code>CompletableFutureKind</code> as the outer monad <code>F</code> in the <code>EitherT</code> transformer (see <a href="monads/../hkts/order-walkthrough.html">Order Example Walkthrough</a>).</li>
</ul>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<div id="admonition-example-1-creating-_completablefuturekind_-instances" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-1-creating-_completablefuturekind_-instances-title">
<div class="admonition-title">
<div id="admonition-example-1-creating-_completablefuturekind_-instances-title">
<p>Example 1: Creating <em>CompletableFutureKind</em> Instances</p>
</div>
<a class="admonition-anchor-link" href="monads/cf_monad.html#admonition-example-1-creating-_completablefuturekind_-instances"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/future/CompletableFutureExample.java">CompletableFutureExample.java</a></li>
</ul>
<pre><code class="language-java">public void createExample() {
   // Get the MonadError instance
   CompletableFutureMonad futureMonad = CompletableFutureMonad.INSTANCE;

   // --- Using of() ---
   // Creates a Kind wrapping an already completed future
   Kind&lt;CompletableFutureKind.Witness, String&gt; successKind = futureMonad.of("Success!");

   // --- Using raiseError() ---
   // Creates a Kind wrapping an already failed future
   RuntimeException error = new RuntimeException("Something went wrong");
   Kind&lt;CompletableFutureKind.Witness, String&gt; failureKind = futureMonad.raiseError(error);

   // --- Wrapping existing CompletableFutures ---
   CompletableFuture&lt;Integer&gt; existingFuture = CompletableFuture.supplyAsync(() -&gt; {
      try {
         TimeUnit.MILLISECONDS.sleep(20);
      } catch (InterruptedException e) { /* ignore */ }
      return 123;
   });
   Kind&lt;CompletableFutureKind.Witness, Integer&gt; wrappedExisting = FUTURE.widen(existingFuture);

   CompletableFuture&lt;Integer&gt; failedExisting = new CompletableFuture&lt;&gt;();
   failedExisting.completeExceptionally(new IllegalArgumentException("Bad input"));
   Kind&lt;CompletableFutureKind.Witness, Integer&gt; wrappedFailed = FUTURE.widen(failedExisting);

   // You typically don't interact with 'unwrap' unless needed at boundaries or for helper methods like 'join'.
   CompletableFuture&lt;String&gt; unwrappedSuccess = FUTURE.narrow(successKind);
   CompletableFuture&lt;String&gt; unwrappedFailure = FUTURE.narrow(failureKind);
}
</code></pre>
</div>
</div>
<div id="admonition-example-2-using-_map_-_flatmap_-_ap_" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-2-using-_map_-_flatmap_-_ap_-title">
<div class="admonition-title">
<div id="admonition-example-2-using-_map_-_flatmap_-_ap_-title">
<p>Example 2: Using <em>map</em>, <em>flatMap</em>, <em>ap</em></p>
</div>
<a class="admonition-anchor-link" href="monads/cf_monad.html#admonition-example-2-using-_map_-_flatmap_-_ap_"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/future/CompletableFutureExample.java">CompletableFutureExample.java</a></li>
</ul>
<p>These examples show how to use the type class instance (<code>futureMonad</code>) to apply operations.</p>
<pre><code class="language-java">public void monadExample() {
   // Get the MonadError instance
   CompletableFutureMonad futureMonad = CompletableFutureMonad.INSTANCE;

   // --- map (thenApply) ---
   Kind&lt;CompletableFutureKind.Witness, Integer&gt; initialValueKind = futureMonad.of(10);
   Kind&lt;CompletableFutureKind.Witness, String&gt; mappedKind = futureMonad.map(
           value -&gt; "Result: " + value,
           initialValueKind
   );
   // Join for testing/demonstration
   System.out.println("Map Result: " + FUTURE.join(mappedKind)); // Output: Result: 10

   // --- flatMap (thenCompose) ---
   // Function A -&gt; Kind&lt;F, B&gt;
   Function&lt;String, Kind&lt;CompletableFutureKind.Witness, String&gt;&gt; asyncStep2 =
           input -&gt; FUTURE.widen(
                   CompletableFuture.supplyAsync(() -&gt; input + " -&gt; Step2 Done")
           );

   Kind&lt;CompletableFutureKind.Witness, String&gt; flatMappedKind = futureMonad.flatMap(
           asyncStep2,
           mappedKind // Result from previous map step ("Result: 10")
   );
   System.out.println("FlatMap Result: " + FUTURE.join(flatMappedKind)); // Output: Result: 10 -&gt; Step2 Done

   // --- ap (thenCombine) ---
   Kind&lt;CompletableFutureKind.Witness, Function&lt;Integer, String&gt;&gt; funcKind = futureMonad.of(i -&gt; "FuncResult:" + i);
   Kind&lt;CompletableFutureKind.Witness, Integer&gt; valKind = futureMonad.of(25);

   Kind&lt;CompletableFutureKind.Witness, String&gt; apResult = futureMonad.ap(funcKind, valKind);
   System.out.println("Ap Result: " + FUTURE.join(apResult)); // Output: FuncResult:25

   // --- mapN ---
   Kind&lt;CompletableFutureKind.Witness, Integer&gt; f1 = futureMonad.of(5);
   Kind&lt;CompletableFutureKind.Witness, String&gt; f2 = futureMonad.of("abc");

   BiFunction&lt;Integer, String, String&gt; combine = (i, s) -&gt; s + i;
   Kind&lt;CompletableFutureKind.Witness, String&gt; map2Result = futureMonad.map2(f1, f2, combine);
   System.out.println("Map2 Result: " + FUTURE.join(map2Result)); // Output: abc5

}
</code></pre>
</div>
</div>
<div id="admonition-example-3-handling-errors-with-_handleerrorwith_" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-3-handling-errors-with-_handleerrorwith_-title">
<div class="admonition-title">
<div id="admonition-example-3-handling-errors-with-_handleerrorwith_-title">
<p>Example 3: Handling Errors with <em>handleErrorWith</em></p>
</div>
<a class="admonition-anchor-link" href="monads/cf_monad.html#admonition-example-3-handling-errors-with-_handleerrorwith_"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/future/CompletableFutureExample.java">CompletableFutureExample.java</a></li>
</ul>
<p>This is where <code>CompletableFutureMonad</code> shines, providing functional error recovery.</p>
<pre><code class="language-java"> public void errorHandlingExample(){
   // Get the MonadError instance
   CompletableFutureMonad futureMonad = CompletableFutureMonad.INSTANCE;
   RuntimeException runtimeEx = new IllegalStateException("Processing Failed");
   IOException checkedEx = new IOException("File Not Found");

   Kind&lt;CompletableFutureKind.Witness, String&gt; failedRuntimeKind = futureMonad.raiseError(runtimeEx);
   Kind&lt;CompletableFutureKind.Witness, String&gt; failedCheckedKind = futureMonad.raiseError(checkedEx);
   Kind&lt;CompletableFutureKind.Witness, String&gt; successKind = futureMonad.of("Original Success");

   // --- Handler Function ---
   // Function&lt;Throwable, Kind&lt;CompletableFutureKind.Witness, String&gt;&gt;
   Function&lt;Throwable, Kind&lt;CompletableFutureKind.Witness, String&gt;&gt; recoveryHandler =
           error -&gt; {
              System.out.println("Handling error: " + error.getMessage());
              if (error instanceof IOException) {
                 // Recover from specific checked exceptions
                 return futureMonad.of("Recovered from IO Error");
              } else if (error instanceof IllegalStateException) {
                 // Recover from specific runtime exceptions
                 return FUTURE.widen(CompletableFuture.supplyAsync(()-&gt;{
                    System.out.println("Async recovery..."); // Recovery can be async too!
                    return "Recovered from State Error (async)";
                 }));
              } else if (error instanceof ArithmeticException) { 
                 // Recover from ArithmeticException
                 return futureMonad.of("Recovered from Arithmetic Error: " + error.getMessage());
              }
              else {
                 // Re-raise unhandled errors
                 System.out.println("Unhandled error type: " + error.getClass().getSimpleName());
                 return futureMonad.raiseError(new RuntimeException("Recovery failed", error));
              }
           };

   // --- Applying Handler ---

   // Handle RuntimeException
   Kind&lt;CompletableFutureKind.Witness, String&gt; recoveredRuntime = futureMonad.handleErrorWith(
           failedRuntimeKind,
           recoveryHandler
   );
   System.out.println("Recovered (Runtime): " + FUTURE.join(recoveredRuntime));
   // Output:
   // Handling error: Processing Failed
   // Async recovery...
   // Recovered (Runtime): Recovered from State Error (async)


   // Handle CheckedException
   Kind&lt;CompletableFutureKind.Witness, String&gt; recoveredChecked = futureMonad.handleErrorWith(
           failedCheckedKind,
           recoveryHandler
   );
   System.out.println("Recovered (Checked): " + FUTURE.join(recoveredChecked));
   // Output:
   // Handling error: File Not Found
   // Recovered (Checked): Recovered from IO Error


   // Handler is ignored for success
   Kind&lt;CompletableFutureKind.Witness, String&gt; handledSuccess = futureMonad.handleErrorWith(
           successKind,
           recoveryHandler // This handler is never called
   );
   System.out.println("Handled (Success): " + FUTURE.join(handledSuccess));
   // Output: Handled (Success): Original Success


   // Example of re-raising an unhandled error
   ArithmeticException unhandledEx = new ArithmeticException("Bad Maths");
   Kind&lt;CompletableFutureKind.Witness, String&gt; failedUnhandledKind = futureMonad.raiseError(unhandledEx);
   Kind&lt;CompletableFutureKind.Witness, String&gt; failedRecovery = futureMonad.handleErrorWith(
           failedUnhandledKind,
           recoveryHandler
   );

   try {
      FUTURE.join(failedRecovery);
   } catch (CompletionException e) { // join wraps the "Recovery failed" exception
      System.err.println("Caught re-raised error: " + e.getCause());
      System.err.println("  Original cause: " + e.getCause().getCause());
   }
   // Output:
   // Handling error: Bad Maths
}
</code></pre>
<ul>
<li><code>handleErrorWith</code> allows you to inspect the <code>Throwable</code> and return a <em>new</em><code>CompletableFutureKind</code>, potentially recovering the flow.</li>
<li>The handler receives the <em>cause</em> of the failure (unwrapped from <code>CompletionException</code> if necessary).</li>
</ul>
</div>
</div><div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="the-eithermonad"><a class="header" href="#the-eithermonad">The EitherMonad:</a></h1>
<h2 id="typed-error-handling"><a class="header" href="#typed-error-handling"><em>Typed Error Handling</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="monads/either_monad.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to represent computations that can succeed (Right) or fail (Left) with specific error types</li>
<li>Building type-safe error handling without exceptions</li>
<li>Chaining operations with automatic Left propagation</li>
<li>Using fold to handle both success and failure cases</li>
<li>Integration with EitherT for combining with other effects</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code:</p>
</div>
<a class="admonition-anchor-link" href="monads/either_monad.html#admonition-see-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/either/EitherExample.java">EitherExample.java</a></p>
</div>
</div>
<h2 id="purpose"><a class="header" href="#purpose">Purpose</a></h2>
<p>The <code>Either&lt;L, R&gt;</code> type represents a value that can be one of two possible types, conventionally denoted as <code>Left</code> and <code>Right</code>. Its primary purpose in functional programming and this library is to provide an explicit, type-safe way to handle computations that can result in either a successful outcome or a specific kind of failure.</p>
<ul>
<li><strong><code>Right&lt;L, R&gt;</code></strong>: By convention, represents the <strong>success</strong> case, holding a value of type <code>R</code>.</li>
<li><strong><code>Left&lt;L, R&gt;</code></strong>: By convention, represents the <strong>failure</strong> or alternative case, holding a value of type <code>L</code> (often an error type).</li>
</ul>
<p>Unlike throwing exceptions, <code>Either</code> makes the possibility of failure explicit in the return type of a function. Unlike <code>Optional</code> or <code>Maybe</code>, which simply signal the absence of a value, <code>Either</code> allows carrying specific information about <em>why</em> a computation failed in the <code>Left</code> value.</p>
<p>We can think of <code>Either</code> as an extension of <code>Maybe</code>. The <code>Right</code> is equivalent to <code>Maybe.Just</code>, and the <code>Left</code> is the equivalent of <code>Maybe.Nothing</code> <strong>but now we can allow it to carry a value.</strong></p>
<p>The implementation in this library is a <code>sealed interface Either&lt;L, R&gt;</code> with two <code>record</code> implementations: <code>Left&lt;L, R&gt;</code> and <code>Right&lt;L, R&gt;</code>. Both <code>Left</code> and <code>Right</code> directly implement <code>EitherKind&lt;L, R&gt;</code> (and <code>EitherKind2&lt;L, R&gt;</code> for bifunctor operations), which extend <code>Kind&lt;EitherKind.Witness&lt;L&gt;, R&gt;</code>. This means widen/narrow operations have zero runtime overhead‚Äîno wrapper object allocation needed.</p>
<h2 id="structure"><a class="header" href="#structure">Structure</a></h2>
<p><img src="monads/../images/puml/either_type.svg" alt="either_type.svg" /></p>
<div id="admonition-related-types" class="admonition admonish-note" role="note" aria-labelledby="admonition-related-types-title">
<div class="admonition-title">
<div id="admonition-related-types-title">
<p>Related Types</p>
</div>
<a class="admonition-anchor-link" href="monads/either_monad.html#admonition-related-types"></a>
</div>
<div>
<p>For handling exceptions specifically, see <a href="monads/./try_monad.html">Try Monad</a>, which is an <code>Either</code> specialised with <code>Throwable</code> as the error type. For fail-fast validation with error accumulation in applicative context, see <a href="monads/./validated_monad.html">Validated Monad</a>.</p>
</div>
</div>
<h2 id="creating-instances"><a class="header" href="#creating-instances">Creating Instances</a></h2>
<p>You create <code>Either</code> instances using the static factory methods:</p>
<div id="admonition-creating-instances" class="admonition admonish-note" role="note" aria-labelledby="admonition-creating-instances-title">
<div class="admonition-title">
<div id="admonition-creating-instances-title">
<p>Creating Instances</p>
</div>
<a class="admonition-anchor-link" href="monads/either_monad.html#admonition-creating-instances"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/either/EitherExample.java">EitherExample.java</a></li>
</ul>
<pre><code class="language-java">
// Success case
Either&lt;String, Integer&gt; success = Either.right(123);

// Failure case
Either&lt;String, Integer&gt; failure = Either.left("File not found");

// Null values are permitted in Left or Right by default in this implementation
Either&lt;String, Integer&gt; rightNull = Either.right(null);
Either&lt;String, Integer&gt; leftNull = Either.left(null);
</code></pre>
</div>
</div>
<h2 id="working-with-either"><a class="header" href="#working-with-either">Working with <code>Either</code></a></h2>
<p>Several methods are available to interact with <code>Either</code> values:</p>
<div id="admonition-checking-state" class="admonition admonish-note" role="note" aria-labelledby="admonition-checking-state-title">
<div class="admonition-title">
<div id="admonition-checking-state-title">
<p>Checking State</p>
</div>
<a class="admonition-anchor-link" href="monads/either_monad.html#admonition-checking-state"></a>
</div>
<div>
<ul>
<li>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/either/EitherExample.java">EitherExample.java</a></p>
<ul>
<li><code>isLeft()</code>: Returns <code>true</code> if it's a <code>Left</code>, <code>false</code> otherwise.</li>
<li><code>isRight()</code>: Returns <code>true</code> if it's a <code>Right</code>, <code>false</code> otherwise.</li>
</ul>
<pre><code class="language-java">if (success.isRight()) {
    System.out.println("It's Right!");
}
if (failure.isLeft()) {
    System.out.println("It's Left!");
}
</code></pre>
</li>
</ul>
</div>
</div>
<div id="admonition-extracting-values-_use-with-caution_" class="admonition admonish-note" role="note" aria-labelledby="admonition-extracting-values-_use-with-caution_-title">
<div class="admonition-title">
<div id="admonition-extracting-values-_use-with-caution_-title">
<p>Extracting Values (<em>Use with Caution</em>)</p>
</div>
<a class="admonition-anchor-link" href="monads/either_monad.html#admonition-extracting-values-_use-with-caution_"></a>
</div>
<div>
<ul>
<li>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/either/EitherExample.java">EitherExample.java</a></p>
<ul>
<li><code>getLeft()</code>: Returns the <code>value</code> if it's a <code>Left</code>, otherwise throws <code>NoSuchElementException</code>.</li>
<li><code>getRight()</code>: Returns the <code>value</code> if it's a <code>Right</code>, otherwise throws <code>NoSuchElementException</code>.</li>
</ul>
<pre><code class="language-java">  try {
    Integer value = success.getRight(); // Returns 123
    String error = failure.getLeft();  // Returns "File not found"
    // String errorFromSuccess = success.getLeft(); // Throws NoSuchElementException
  } catch (NoSuchElementException e) {
    System.err.println("Attempted to get the wrong side: " + e.getMessage());
  }
</code></pre>
</li>
</ul>
</div>
</div>
<p><em>Note: Prefer <code>fold</code> or pattern matching over direct <code>getLeft</code>/<code>getRight</code> calls.</em></p>
<div id="admonition-pattern-matching--folding" class="admonition admonish-note" role="note" aria-labelledby="admonition-pattern-matching--folding-title">
<div class="admonition-title">
<div id="admonition-pattern-matching--folding-title">
<p>Pattern Matching / Folding</p>
</div>
<a class="admonition-anchor-link" href="monads/either_monad.html#admonition-pattern-matching--folding"></a>
</div>
<div>
<ul>
<li>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/either/EitherExample.java">EitherExample.java</a></p>
</li>
<li>
<p>The <code>fold</code> method is the safest way to handle both cases by providing two functions: one for the <code>Left</code> case and one for the <code>Right</code> case. It returns the result of whichever function is applied.</p>
<pre><code class="language-java">String resultMessage = failure.fold(
    leftValue -&gt; "Operation failed with: " + leftValue,  // Function for Left
    rightValue -&gt; "Operation succeeded with: " + rightValue // Function for Right
);
// resultMessage will be "Operation failed with: File not found"

String successMessage = success.fold(
    leftValue -&gt; "Error: " + leftValue,
    rightValue -&gt; "Success: " + rightValue
);
// successMessage will be "Success: 123"
</code></pre>
</li>
</ul>
</div>
</div>
<div id="admonition-_map_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_map_-title">
<div class="admonition-title">
<div id="admonition-_map_-title">
<p><em>Map</em></p>
</div>
<a class="admonition-anchor-link" href="monads/either_monad.html#admonition-_map_"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/either/EitherExample.java">EitherExample.java</a></li>
</ul>
<p>Applies a function only to the <code>Right</code> value, leaving a <code>Left</code> unchanged. This is known as being "right-biased".</p>
<pre><code class="language-java">  Function&lt;Integer, String&gt; intToString = Object::toString;

  Either&lt;String, String&gt; mappedSuccess = success.map(intToString); // Right(123) -&gt; Right("123")
  Either&lt;String, String&gt; mappedFailure = failure.map(intToString); // Left(...) -&gt; Left(...) unchanged

  System.out.println(mappedSuccess); // Output: Right(value=123)
  System.out.println(mappedFailure); // Output: Left(value=File not found)
</code></pre>
</div>
</div>
<div id="admonition-_flatmap_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_flatmap_-title">
<div class="admonition-title">
<div id="admonition-_flatmap_-title">
<p><em>flatMap</em></p>
</div>
<a class="admonition-anchor-link" href="monads/either_monad.html#admonition-_flatmap_"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/either/EitherExample.java">EitherExample.java</a></li>
</ul>
<p>Applies a function that <em>itself returns an <code>Either</code></em> to a <code>Right</code> value. If the initial <code>Either</code> is <code>Left</code>, it's returned unchanged. If the function applied to the <code>Right</code> value returns a <code>Left</code>, that <code>Left</code> becomes the result. This allows sequencing operations where each step can fail. The <code>Left</code> type acts as a functor that dismisses the mapped function <code>f</code> and returns itself (<code>map(f) -&gt; Left(Value)</code>). It preserves the value it holds. After a <code>Left</code> is encountered, subsequent transformations via <code>map</code> or <code>flatMap</code> are typically short-circuited.</p>
<pre><code class="language-java">public void basicFlatMap(){

  // Example: Parse string, then check if positive
  Function&lt;String, Either&lt;String, Integer&gt;&gt; parse = s -&gt; {
    try { return Either.right(Integer.parseInt(s.trim())); }
    catch (NumberFormatException e) { return Either.left("Invalid number"); }
  };
  Function&lt;Integer, Either&lt;String, Integer&gt;&gt; checkPositive = i -&gt;
      (i &gt; 0) ? Either.right(i) : Either.left("Number not positive");

  Either&lt;String, String&gt; input1 = Either.right(" 10 ");
  Either&lt;String, String&gt; input2 = Either.right(" -5 ");
  Either&lt;String, String&gt; input3 = Either.right(" abc ");
  Either&lt;String, String&gt; input4 = Either.left("Initial error");

  // Chain parse then checkPositive
  Either&lt;String, Integer&gt; result1 = input1.flatMap(parse).flatMap(checkPositive); // Right(10)
  Either&lt;String, Integer&gt; result2 = input2.flatMap(parse).flatMap(checkPositive); // Left("Number not positive")
  Either&lt;String, Integer&gt; result3 = input3.flatMap(parse).flatMap(checkPositive); // Left("Invalid number")
  Either&lt;String, Integer&gt; result4 = input4.flatMap(parse).flatMap(checkPositive); // Left("Initial error")

  System.out.println(result1);
  System.out.println(result2);
  System.out.println(result3);
  System.out.println(result4);
}
</code></pre>
</div>
</div>
<div id="admonition-using-_eithermonad_" class="admonition admonish-example" role="note" aria-labelledby="admonition-using-_eithermonad_-title">
<div class="admonition-title">
<div id="admonition-using-_eithermonad_-title">
<p>Using <em>EitherMonad</em></p>
</div>
<a class="admonition-anchor-link" href="monads/either_monad.html#admonition-using-_eithermonad_"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/either/EitherExample.java">EitherExample.java</a></li>
</ul>
<p>To use <code>Either</code> within Higher-Kinded-J framework:</p>
<ol>
<li>
<p><strong>Identify Context:</strong> You are working with <code>Either&lt;L, R&gt;</code> where <code>L</code> is your chosen error type. The HKT witness will be <code>EitherKind.Witness&lt;L&gt;</code>.</p>
</li>
<li>
<p><strong>Get Type Class Instance:</strong> Obtain an instance of <code>EitherMonad&lt;L&gt;</code> for your specific error type <code>L</code>. This instance implements <code>MonadError&lt;EitherKind.Witness&lt;L&gt;, L&gt;</code>.</p>
<pre><code class="language-java">// Assuming TestError is your error type
EitherMonad&lt;TestError&gt; eitherMonad = EitherMonad.instance()
// Now 'eitherMonad' can be used for operations on Kind&lt;EitherKind.Witness&lt;String&gt;, A&gt;
</code></pre>
</li>
<li>
<p><strong>Wrap</strong>: Convert your <code>Either&lt;L, R&gt;</code> instances to <code>Kind&lt;EitherKind.Witness&lt;L&gt;, R&gt;</code> using <code>EITHER.widen()</code>. Since <code>Either&lt;L,R&gt;</code> directly implements <code>EitherKind&lt;L,R&gt;</code>.</p>
<pre><code class="language-java"> EitherMonad&lt;String&gt; eitherMonad = EitherMonad.instance()

 Either&lt;String, Integer&gt; myEither = Either.right(10);
 // F_WITNESS is EitherKind.Witness&lt;String&gt;, A is Integer
 Kind&lt;EitherKind.Witness&lt;String&gt;, Integer&gt; eitherKind = EITHER.widen(myEither);
</code></pre>
</li>
<li>
<p><strong>Apply Operations:</strong>  Use the methods on the <code>eitherMonad</code> instance (<code>map</code>, <code>flatMap</code>, <code>ap</code>, <code>raiseError</code>, <code>handleErrorWith</code>, etc.).</p>
<pre><code class="language-java">// Using map via the Monad instance
 Kind&lt;EitherKind.Witness&lt;String&gt;, String&gt; mappedKind = eitherMonad.map(Object::toString, eitherKind);
 System.out.println("mappedKind: " + EITHER.narrow(mappedKind)); // Output: Right[value = 10]

 // Using flatMap via the Monad instance
 Function&lt;Integer, Kind&lt;EitherKind.Witness&lt;String&gt;, Double&gt;&gt; nextStep =
     i -&gt; EITHER.widen( (i &gt; 5) ? Either.right(i/2.0) : Either.left("TooSmall"));
 Kind&lt;EitherKind.Witness&lt;String&gt;, Double&gt; flatMappedKind = eitherMonad.flatMap(nextStep, eitherKind);

 // Creating a Left Kind using raiseError
 Kind&lt;EitherKind.Witness&lt;String&gt;, Integer&gt; errorKind = eitherMonad.raiseError("E101"); // L is String here

 // Handling an error
 Kind&lt;EitherKind.Witness&lt;String&gt;, Integer&gt; handledKind =
     eitherMonad.handleErrorWith(errorKind, error -&gt; { 
       System.out.println("Handling error: " + error);
       return eitherMonad.of(0); // Recover with Right(0)
     });
</code></pre>
</li>
<li>
<p><strong>Unwrap:</strong> Get the final <code>Either&lt;L, R&gt;</code> back using <code>EITHER.narrow()</code> when needed.</p>
<pre><code class="language-java"> Either&lt;String, Integer&gt; finalEither = EITHER.narrow(handledKind);
 System.out.println("Final unwrapped Either: " + finalEither); // Output: Right(0)
</code></pre>
</li>
</ol>
</div>
</div>
<div id="admonition-key-points" class="admonition admonish-tip" role="note" aria-labelledby="admonition-key-points-title">
<div class="admonition-title">
<div id="admonition-key-points-title">
<p>Key Points:</p>
</div>
<a class="admonition-anchor-link" href="monads/either_monad.html#admonition-key-points"></a>
</div>
<div>
<ul>
<li>Explicitly modelling and handling domain-specific errors (e.g., validation failures, resource not found, business rule violations).</li>
<li>Sequencing operations where any step might fail with a typed error, short-circuiting the remaining steps.</li>
<li>Serving as the inner type for monad transformers like <code>EitherT</code> to combine typed errors with other effects like asynchronicity (see the <a href="monads/../hkts/order-walkthrough.html">Order Example Walkthrough</a>).</li>
<li>Providing a more informative alternative to returning <code>null</code> or relying solely on exceptions for expected failure conditions.</li>
</ul>
</div>
</div><div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="identity-monad-id"><a class="header" href="#identity-monad-id">Identity Monad (Id)</a></h1>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code:</p>
</div>
<a class="admonition-anchor-link" href="monads/identity.html#admonition-see-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/id/IdExample.java">IdExample.java</a></p>
</div>
</div>
The Identity Monad, often referred to as `IdMonad`, is the simplest possible monad. It represents a computation that doesn't add any additional context or effect beyond simply holding a value. It's a direct wrapper around a value.
<p>While it might seem trivial on its own, the Identity Monad plays a crucial role in a higher-kinded type library for several reasons:</p>
<ol>
<li>
<p><strong>Base Case for Monad Transformers</strong>: Many monad transformers (like <code>StateT</code>, <code>ReaderT</code>, <code>MaybeT</code>, etc.) can be specialised to their simpler, non-transformed monad counterparts by using <code>Id</code> as the underlying monad. For example:</p>
<ul>
<li><code>StateT&lt;S, IdKind.Witness, A&gt;</code> is conceptually equivalent to <code>State&lt;S, A&gt;</code>.</li>
<li><code>MaybeT&lt;IdKind.Witness, A&gt;</code> is conceptually equivalent to <code>Maybe&lt;A&gt;</code>.
This allows for a unified way to define transformers and derive base monads.</li>
</ul>
</li>
<li>
<p><strong>Generic Programming</strong>: When writing functions that are generic over any <code>Monad&lt;F&gt;</code>, <code>Id</code> can serve as the "no-effect" monad, allowing you to use these generic functions with pure values without introducing unnecessary complexity.</p>
</li>
<li>
<p><strong>Understanding Monads</strong>: It provides a clear example of the monadic structure (<code>of</code>, <code>flatMap</code>, <code>map</code>) without any distracting side effects or additional computational context.</p>
</li>
</ol>
<h2 id="what-is-id"><a class="header" href="#what-is-id">What is Id?</a></h2>
<p>An <code>Id&lt;A&gt;</code> is simply a container that holds a value of type <code>A</code>.</p>
<ul>
<li><code>Id.of(value)</code> creates an <code>Id</code> instance holding <code>value</code>.</li>
<li><code>idInstance.value()</code> retrieves the value from the <code>Id</code> instance.</li>
</ul>
<h2 id="key-classes-and-concepts"><a class="header" href="#key-classes-and-concepts">Key Classes and Concepts</a></h2>
<p><img src="monads/../images/puml/id_monad.svg" alt="id_monad.svg" /></p>
<ul>
<li><strong><code>Id&lt;A&gt;</code></strong>: The data type itself. It's a record that wraps a value of type <code>A</code>. It implements <code>IdKind&lt;A&gt;</code>, which extends <code>Kind&lt;IdKind.Witness, A&gt;</code>.</li>
<li><strong><code>IdKind&lt;A&gt;</code></strong>: The Kind interface marker for the <code>Id</code> type. It extends <code>Kind&lt;IdKind.Witness, A&gt;</code>, following the standard Higher-Kinded-J pattern used by other types like <code>TrampolineKind</code> and <code>FreeKind</code>.</li>
<li><strong><code>IdKind.Witness</code></strong>: A static nested class within <code>IdKind</code> used as the phantom type marker (the <code>F</code> in <code>Kind&lt;F, A&gt;</code>) to represent the <code>Id</code> type constructor at the type level. This is part of the HKT emulation pattern.</li>
<li><strong><code>IdKindHelper</code></strong>: A utility class providing static helper methods:
<ul>
<li><code>narrow(Kind&lt;IdKind.Witness, A&gt; kind)</code>: Safely casts a <code>Kind</code> back to a concrete <code>Id&lt;A&gt;</code>.</li>
<li><code>widen(Id&lt;A&gt; id)</code>: widens an <code>Id&lt;A&gt;</code> to <code>Kind&lt;IdKind.Witness, A&gt;</code>. (Often an identity cast since <code>Id</code> implements <code>Kind</code>).</li>
<li><code>narrows(Kind&lt;IdKind.Witness, A&gt; kind)</code>: A convenience to narrow and then get the value.</li>
</ul>
</li>
<li><strong><code>IdMonad</code></strong>: The singleton class that implements <code>Monad&lt;IdKind.Witness&gt;</code>, providing the monadic operations for <code>Id</code>.</li>
</ul>
<h2 id="using-id-and-idmonad"><a class="header" href="#using-id-and-idmonad">Using <code>Id</code> and <code>IdMonad</code></a></h2>
<div id="admonition-example-1-creating-id-instances" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-1-creating-id-instances-title">
<div class="admonition-title">
<div id="admonition-example-1-creating-id-instances-title">
<p>Example 1: Creating Id Instances</p>
</div>
<a class="admonition-anchor-link" href="monads/identity.html#admonition-example-1-creating-id-instances"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/id/IdExample.java">IdExample.java</a></li>
</ul>
<pre><code class="language-java">public void createExample(){
  // Direct creation
  Id&lt;String&gt; idString = Id.of("Hello, Identity!");
  Id&lt;Integer&gt; idInt = Id.of(123);
  Id&lt;String&gt; idNull = Id.of(null); // Id can wrap null

  // Accessing the value
  String value = idString.value(); // "Hello, Identity!"
  Integer intValue = idInt.value();   // 123
  String nullValue = idNull.value(); // null
}
</code></pre>
</div>
</div>
<div id="admonition-example-2-using-with-idmonad" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-2-using-with-idmonad-title">
<div class="admonition-title">
<div id="admonition-example-2-using-with-idmonad-title">
<p>Example 2: Using with IdMonad</p>
</div>
<a class="admonition-anchor-link" href="monads/identity.html#admonition-example-2-using-with-idmonad"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/id/IdExample.java">IdExample.java</a></li>
</ul>
<p>The <code>IdMonad</code> provides the standard monadic operations.</p>
<pre><code class="language-java">public void monadExample(){
  IdMonad idMonad = IdMonad.instance();

  // 1. 'of' (lifting a value)
  Kind&lt;IdKind.Witness, Integer&gt; kindInt = idMonad.of(42);
  Id&lt;Integer&gt; idFromOf = ID.narrow(kindInt);
  System.out.println("From of: " + idFromOf.value()); // Output: From of: 42

  // 2. 'map' (applying a function to the wrapped value)
  Kind&lt;IdKind.Witness, String&gt; kindStringMapped = idMonad.map(
      i -&gt; "Value is " + i,
      kindInt
  );
  Id&lt;String&gt; idMapped = ID.narrow(kindStringMapped);
  System.out.println("Mapped: " + idMapped.value()); // Output: Mapped: Value is 42

  // 3. 'flatMap' (applying a function that returns an Id)
  Kind&lt;IdKind.Witness, String&gt; kindStringFlatMapped = idMonad.flatMap(
      i -&gt; Id.of("FlatMapped: " + (i * 2)), // Function returns Id&lt;String&gt;
      kindInt
  );
  Id&lt;String&gt; idFlatMapped = ID.narrow(kindStringFlatMapped);
  System.out.println("FlatMapped: " + idFlatMapped.value()); // Output: FlatMapped: 84

  // flatMap can also be called directly on Id if the function returns Id
  Id&lt;String&gt; directFlatMap = idFromOf.flatMap(i -&gt; Id.of("Direct FlatMap: " + i));
  System.out.println(directFlatMap.value()); // Output: Direct FlatMap: 42

  // 4. 'ap' (applicative apply)
  Kind&lt;IdKind.Witness, Function&lt;Integer, String&gt;&gt; kindFunction = idMonad.of(i -&gt; "Applied: " + i);
  Kind&lt;IdKind.Witness, String&gt; kindApplied = idMonad.ap(kindFunction, kindInt);
  Id&lt;String&gt; idApplied = ID.narrow(kindApplied);
  System.out.println("Applied: " + idApplied.value()); // Output: Applied: 42
}
</code></pre>
</div>
</div>
<div id="admonition-example-3-using-id-with-monad-transformers" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-3-using-id-with-monad-transformers-title">
<div class="admonition-title">
<div id="admonition-example-3-using-id-with-monad-transformers-title">
<p>Example 3: Using Id with Monad Transformers</p>
</div>
<a class="admonition-anchor-link" href="monads/identity.html#admonition-example-3-using-id-with-monad-transformers"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/id/IdExample.java">IdExample.java</a></li>
</ul>
<p>As mentioned in the <a href="monads/../transformers/statet_transformer.html">StateT Monad Transformer</a> documentation, <code>State&lt;S,A&gt;</code> can be thought of as <code>StateT&lt;S, IdKind.Witness, A&gt;</code>.</p>
<p>Let's illustrate how you might define a <code>State</code> monad type alias or use <code>StateT</code> with <code>IdMonad</code>:</p>
<pre><code class="language-java">  public void transformerExample(){
  // Conceptually, State&lt;S, A&gt; is StateT&lt;S, IdKind.Witness, A&gt;
  // We can create a StateTMonad instance using IdMonad as the underlying monad.
  StateTMonad&lt;Integer, IdKind.Witness&gt; stateMonadOverId =
      StateTMonad.instance(IdMonad.instance());

  // Example: A "State" computation that increments the state and returns the old state
  Function&lt;Integer, Kind&lt;IdKind.Witness, StateTuple&lt;Integer, Integer&gt;&gt;&gt; runStateFn =
      currentState -&gt; Id.of(StateTuple.of(currentState + 1, currentState));

  // Create the StateT (acting as State)
  Kind&lt;StateTKind.Witness&lt;Integer, IdKind.Witness&gt;, Integer&gt; incrementAndGet =
      StateTKindHelper.stateT(runStateFn, IdMonad.instance());

  // Run it
  Integer initialState = 10;
  Kind&lt;IdKind.Witness, StateTuple&lt;Integer, Integer&gt;&gt; resultIdTuple =
      StateTKindHelper.runStateT(incrementAndGet, initialState);

  // Unwrap the Id and then the StateTuple
  Id&lt;StateTuple&lt;Integer, Integer&gt;&gt; idTuple = ID.narrow(resultIdTuple);
  StateTuple&lt;Integer, Integer&gt; tuple = idTuple.value();

  System.out.println("Initial State: " + initialState);       // Output: Initial State: 10
  System.out.println("Returned Value (Old State): " + tuple.value()); // Output: Returned Value (Old State): 10
  System.out.println("Final State: " + tuple.state());         // Output: Final State: 11
}
</code></pre>
<p>This example shows that <code>StateT</code> with <code>Id</code> behaves just like a standard <code>State</code> monad, where the "effect" of the underlying monad is simply identity (no additional effect).</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="the-iomonad"><a class="header" href="#the-iomonad">The IOMonad:</a></h1>
<h2 id="managing-side-effects-with-io"><a class="header" href="#managing-side-effects-with-io"><em>Managing Side Effects with <code>IO</code></em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="monads/io_monad.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to describe side effects without performing them immediately</li>
<li>Building pure functional programs with deferred execution</li>
<li>Composing complex side-effecting operations using <code>map</code> and <code>flatMap</code></li>
<li>The difference between describing effects and running them with <code>unsafeRunSync</code></li>
<li>Creating testable, composable programs that separate logic from execution</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code:</p>
</div>
<a class="admonition-anchor-link" href="monads/io_monad.html#admonition-see-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/io/IOExample.java">IOExample.java</a></p>
</div>
</div>
<p>In functional programming, managing side effects (like printing to the console, reading files, making network calls, generating random numbers, or getting the current time) while maintaining purity is a common challenge.</p>
<p>The <code>IO&lt;A&gt;</code> monad in <code>higher-kinded-j</code> provides a way to encapsulate these side-effecting computations, making them first-class values that can be composed and manipulated functionally.</p>
<p>The key idea is that an <code>IO&lt;A&gt;</code> value doesn't <em>perform</em> the side effect immediately upon creation. Instead, it represents a <em>description</em> or <em>recipe</em> for a computation that, when executed, will perform the effect and potentially produce a value of type <code>A</code>. The actual execution is deferred until explicitly requested.</p>
<h2 id="core-components"><a class="header" href="#core-components">Core Components</a></h2>
<p><strong>The IO Type</strong></p>
<p><img src="monads/../images/puml/io_detail.svg" alt="io_detail.svg" /></p>
<p><strong>The HKT Bridge for IO</strong></p>
<p><img src="monads/../images/puml/io_kind.svg" alt="io_kind.svg" /></p>
<p><strong>Typeclasses for IO</strong></p>
<p><img src="monads/../images/puml/io_monad.svg" alt="io_monad.svg" /></p>
<p>The <code>IO</code> functionality is built upon several related components:</p>
<ol>
<li><strong><code>IO&lt;A&gt;</code></strong>: The core functional interface. An <code>IO&lt;A&gt;</code> instance essentially wraps a <code>Supplier&lt;A&gt;</code> (or similar function) that performs the side effect and returns a value <code>A</code>. The crucial method is <code>unsafeRunSync()</code>, which executes the encapsulated computation. <code>IO&lt;A&gt;</code> directly extends <code>IOKind&lt;A&gt;</code>, making it a first-class participant in the HKT simulation.</li>
<li><strong><code>IOKind&lt;A&gt;</code></strong>: The HKT marker interface (<code>Kind&lt;IOKind.Witness, A&gt;</code>) for <code>IO</code>. This allows <code>IO</code> to be treated as a generic type constructor <code>F</code> in type classes like <code>Functor</code>, <code>Applicative</code>, and <code>Monad</code>. The witness type is <code>IOKind.Witness</code>. Since <code>IO&lt;A&gt;</code> directly extends this interface, no wrapper types are needed.</li>
<li><strong><code>IOKindHelper</code></strong>: The essential utility class for working with <code>IO</code> in the HKT simulation. It provides:
<ul>
<li><code>widen(IO&lt;A&gt;)</code>: Converts a concrete <code>IO&lt;A&gt;</code> instance into its HKT representation <code>Kind&lt;IOKind.Witness, A&gt;</code>. Since <code>IO</code> directly implements <code>IOKind</code>, this is a null-checked cast with zero runtime overhead.</li>
<li><code>narrow(Kind&lt;IOKind.Witness, A&gt;)</code>: Converts back to the concrete <code>IO&lt;A&gt;</code>. Performs an <code>instanceof IO</code> check and cast. Throws <code>KindUnwrapException</code> if the input Kind is invalid.</li>
<li><code>delay(Supplier&lt;A&gt;)</code>: The primary factory method to create an <code>IOKind&lt;A&gt;</code> by wrapping a side-effecting computation described by a <code>Supplier</code>.</li>
<li><code>unsafeRunSync(Kind&lt;IOKind.Witness, A&gt;)</code>: The method to <em>execute</em> the computation described by an <code>IOKind</code>. This is typically called at the "end of the world" in your application (e.g., in the <code>main</code> method) to run the composed IO program.</li>
</ul>
</li>
<li><strong><code>IOFunctor</code></strong>: Implements <code>Functor&lt;IOKind.Witness&gt;</code>. Provides the <code>map</code> operation to transform the result value <code>A</code> of an <code>IO</code> computation <em>without</em> executing the effect.</li>
<li><strong><code>IOApplicative</code></strong>: Extends <code>IOFunctor</code> and implements <code>Applicative&lt;IOKind.Witness&gt;</code>. Provides <code>of</code> (to lift a pure value into <code>IO</code> without side effects) and <code>ap</code> (to apply a function within <code>IO</code> to a value within <code>IO</code>).</li>
<li><strong><code>IOMonad</code></strong>: Extends <code>IOApplicative</code> and implements <code>Monad&lt;IOKind.Witness&gt;</code>. Provides <code>flatMap</code> to sequence <code>IO</code> computations, ensuring effects happen in the intended order.</li>
</ol>
<h2 id="purpose-and-usage-1"><a class="header" href="#purpose-and-usage-1">Purpose and Usage</a></h2>
<ul>
<li><strong>Encapsulating Side Effects</strong>: Describe effects (like printing, reading files, network calls) as <code>IO</code> values without executing them immediately.</li>
<li><strong>Maintaining Purity</strong>: Functions that create or combine <code>IO</code> values remain pure. They don't perform the effects themselves, they just build up a description of the effects to be performed later.</li>
<li><strong>Composition</strong>: Use <code>map</code> and <code>flatMap</code> (via <code>IOMonad</code>) to build complex sequences of side-effecting operations from smaller, reusable <code>IO</code> actions.</li>
<li><strong>Deferred Execution</strong>: Effects are only performed when <code>unsafeRunSync</code> is called on the final, composed <code>IO</code> value. This separates the description of the program from its execution.</li>
</ul>
<p><strong>Important Note:</strong> <code>IO</code> in this library primarily deals with <em>deferring</em> execution. It does <em>not</em> automatically provide sophisticated error handling like <code>Either</code> or <code>Try</code>, nor does it manage asynchronicity like <code>CompletableFuture</code>. Exceptions thrown during <code>unsafeRunSync</code> will typically propagate unless explicitly handled <em>within</em> the <code>Supplier</code> provided to <code>IOKindHelper.delay</code>. For combining IO with typed error handling, consider using <code>EitherT&lt;IOKind.Witness, E, A&gt;</code> (monad transformer) or wrapping IO operations with <code>Try</code> for exception handling.</p>
<div id="admonition-example-1-creating-basic-io-actions" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-1-creating-basic-io-actions-title">
<div class="admonition-title">
<div id="admonition-example-1-creating-basic-io-actions-title">
<p>Example 1: Creating Basic IO Actions</p>
</div>
<a class="admonition-anchor-link" href="monads/io_monad.html#admonition-example-1-creating-basic-io-actions"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/io/IOExample.java">IOExample.java</a></li>
</ul>
<p>Use <code>IOKindHelper.delay</code> to capture side effects. Use <code>IOMonad.of</code> for pure values within IO.</p>
<pre><code class="language-java">import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.io.*; 
import org.higherkindedj.hkt.Unit;
import java.util.function.Supplier;
import java.util.Scanner;

// Get the IOMonad instance
IOMonad ioMonad = IOMonad.INSTANCE;

// IO action to print a message
Kind&lt;IOKind.Witness, Unit&gt; printHello = IOKindHelper.delay(() -&gt; {
    System.out.println("Hello from IO!");
    return Unit.INSTANCE;
});

// IO action to read a line from the console
Kind&lt;IOKind.Witness, String&gt; readLine = IOKindHelper.delay(() -&gt; {
    System.out.print("Enter your name: ");
    // Scanner should ideally be managed more robustly in real apps
    try (Scanner scanner = new Scanner(System.in)) {
         return scanner.nextLine();
    }
});

// IO action that returns a pure value (no side effect description here)
Kind&lt;IOKind.Witness, Integer&gt; pureValueIO = ioMonad.of(42);

// IO action that simulates getting the current time (a side effect)
Kind&lt;IOKind.Witness, Long&gt; currentTime = IOKindHelper.delay(System::currentTimeMillis);

// Creating an IO action that might fail internally
Kind&lt;IOKind.Witness, String&gt; potentiallyFailingIO = IOKindHelper.delay(() -&gt; {
   if (Math.random() &lt; 0.5) {
       throw new RuntimeException("Simulated failure!");
   }
   return "Success!";
});


</code></pre>
</div>
</div>
<p><em>Nothing happens when you create these <code>IOKind</code> values. The <code>Supplier</code> inside <code>delay</code> is not executed.</em></p>
<div id="admonition-example-2-executing-io-actions" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-2-executing-io-actions-title">
<div class="admonition-title">
<div id="admonition-example-2-executing-io-actions-title">
<p>Example 2. Executing IO Actions</p>
</div>
<a class="admonition-anchor-link" href="monads/io_monad.html#admonition-example-2-executing-io-actions"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/io/IOExample.java">IOExample.java</a></li>
</ul>
<p>Use <code>IOKindHelper.unsafeRunSync</code> to run the computation.</p>
<pre><code class="language-java">// (Continuing from above examples)

// Execute printHello
System.out.println("Running printHello:");
IOKindHelper.unsafeRunSync(printHello); // Actually prints "Hello from IO!"

// Execute readLine (will block for user input)
// System.out.println("\nRunning readLine:");
// String name = IOKindHelper.unsafeRunSync(readLine);
// System.out.println("User entered: " + name);

// Execute pureValueIO
System.out.println("\nRunning pureValueIO:");
Integer fetchedValue = IOKindHelper.unsafeRunSync(pureValueIO);
System.out.println("Fetched pure value: " + fetchedValue); // Output: 42

// Execute potentiallyFailingIO
System.out.println("\nRunning potentiallyFailingIO:");
try {
String result = IOKindHelper.unsafeRunSync(potentiallyFailingIO);
   System.out.println("Succeeded: " + result);
} catch (RuntimeException e) {
   System.err.println("Caught expected failure: " + e.getMessage());
   }

// Notice that running the same IO action again executes the effect again
   System.out.println("\nRunning printHello again:");
IOKindHelper.unsafeRunSync(printHello); // Prints "Hello from IO!" again
</code></pre>
</div>
</div>
<div id="admonition-example-3-composing-io-actions-with-map-and-flatmap" class="admonition admonish-note" role="note" aria-labelledby="admonition-example-3-composing-io-actions-with-map-and-flatmap-title">
<div class="admonition-title">
<div id="admonition-example-3-composing-io-actions-with-map-and-flatmap-title">
<p>Example 3: Composing IO Actions with <code>map</code> and <code>flatMap</code></p>
</div>
<a class="admonition-anchor-link" href="monads/io_monad.html#admonition-example-3-composing-io-actions-with-map-and-flatmap"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/io/IOExample.java">IOExample.java</a></li>
</ul>
<p>Use <code>IOMonad</code> instance methods.</p>
<pre><code class="language-java">import org.higherkindedj.hkt.io.IOMonad;
import org.higherkindedj.hkt.Unit;
import java.util.function.Function;

IOMonad ioMonad = IOMonad.INSTANCE;

// --- map example ---
Kind&lt;IOKind.Witness, String&gt; readLineAction = IOKindHelper.delay(() -&gt; "Test Input"); // Simulate input

// Map the result of readLineAction without executing readLine yet
Kind&lt;IOKind.Witness, String&gt; greetAction = ioMonad.map(
    name -&gt; "Hello, " + name + "!", // Function to apply to the result
    readLineAction
);

System.out.println("Greet action created, not executed yet.");
// Now execute the mapped action
String greeting = IOKindHelper.unsafeRunSync(greetAction);
System.out.println("Result of map: " + greeting); // Output: Hello, Test Input!

// --- flatMap example ---
// Action 1: Get name
Kind&lt;IOKind.Witness, String&gt; getName = IOKindHelper.delay(() -&gt; {
    System.out.println("Effect: Getting name...");
    return "Alice";
});

// Action 2 (depends on name): Print greeting
Function&lt;String, Kind&lt;IOKind.Witness, Unit&gt;&gt; printGreeting = name -&gt;
    IOKindHelper.delay(() -&gt; {
        System.out.println("Effect: Printing greeting for " + name);
        System.out.println("Welcome, " + name + "!");
        return Unit.INSTANCE;
    });

// Combine using flatMap
Kind&lt;IOKind.Witness, Void&gt; combinedAction = ioMonad.flatMap(printGreeting, getName);

System.out.println("\nCombined action created, not executed yet.");
// Execute the combined action
IOKindHelper.unsafeRunSync(combinedAction);
// Output:
// Effect: Getting name...
// Effect: Printing greeting for Alice
// Welcome, Alice!

// --- Full Program Example ---
Kind&lt;IOKind.Witness, Unit&gt; program = ioMonad.flatMap(
    ignored -&gt; ioMonad.flatMap( // Chain after printing hello
        name -&gt; ioMonad.map( // Map the result of printing the greeting
            ignored2 -&gt; { System.out.println("Program finished");
              return Unit.INSTANCE; },
              printGreeting.apply(name) // Action 3: Print greeting based on name
        ),
        readLine // Action 2: Read line
    ),
    printHello // Action 1: Print Hello
);

System.out.println("\nComplete IO Program defined. Executing...");
// IOKindHelper.unsafeRunSync(program); // Uncomment to run the full program
</code></pre>
<p><em>Notes:</em></p>
<ul>
<li><code>map</code> transforms the <em>result</em> of an <code>IO</code> action without changing the effect itself (though the transformation happens <em>after</em> the effect runs).</li>
<li><code>flatMap</code> sequences <code>IO</code> actions, ensuring the effect of the first action completes before the second action (which might depend on the first action's result) begins.</li>
</ul>
</div>
</div><div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="the-lazy-monad"><a class="header" href="#the-lazy-monad">The Lazy Monad:</a></h1>
<h2 id="lazy-evaluation-with-lazy"><a class="header" href="#lazy-evaluation-with-lazy"><em>Lazy Evaluation with <code>Lazy</code></em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="monads/lazy_monad.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to defer expensive computations until their results are actually needed</li>
<li>Understanding memoisation and how results are cached after first evaluation</li>
<li>Handling exceptions in lazy computations with ThrowableSupplier</li>
<li>Composing lazy operations while preserving laziness</li>
<li>Building efficient pipelines that avoid unnecessary work</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code:</p>
</div>
<a class="admonition-anchor-link" href="monads/lazy_monad.html#admonition-see-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/lazy/LazyExample.java">LazyExample.java</a></p>
</div>
</div>
<p>This article introduces the <code>Lazy&lt;A&gt;</code> type and its associated components within the <code>higher-kinded-j</code> library. <code>Lazy</code> provides a mechanism for deferred computation, where a value is calculated only when needed and the result (or any exception thrown during calculation) is memoised (cached).</p>
<h2 id="core-components-1"><a class="header" href="#core-components-1">Core Components</a></h2>
<p><strong>The Lazy Type</strong></p>
<p><img src="monads/../images/puml/lazy_class.svg" alt="lazy_class.svg" /></p>
<p><strong>The HKT Bridge for Lazy</strong></p>
<p><img src="monads/../images/puml/lazy_kind.svg" alt="lazy_kind.svg" /></p>
<p><strong>Typeclasses for Lazy</strong></p>
<p><img src="monads/../images/puml/lazy_monad.svg" alt="lazy_monad.svg" /></p>
<p>The lazy evaluation feature revolves around these key types:</p>
<ol>
<li><strong><code>ThrowableSupplier&lt;T&gt;</code></strong>: A functional interface similar to <code>java.util.function.Supplier</code>, but its <code>get()</code> method is allowed to throw any <code>Throwable</code> (including checked exceptions). This is used as the underlying computation for <code>Lazy</code>.</li>
<li><strong><code>Lazy&lt;A&gt;</code></strong>: The core class representing a computation that produces a value of type <code>A</code> lazily. It takes a <code>ThrowableSupplier&lt;? extends A&gt;</code> during construction (<code>Lazy.defer</code>). Evaluation is triggered only by the <code>force()</code> method, and the result or exception is cached. <code>Lazy.now(value)</code> creates an already evaluated instance.</li>
<li><strong><code>LazyKind&lt;A&gt;</code></strong>: The HKT marker interface (<code>Kind&lt;LazyKind.Witness, A&gt;</code>) for <code>Lazy</code>, allowing it to be used generically with type classes like <code>Functor</code> and <code>Monad</code>.</li>
<li><strong><code>LazyKindHelper</code></strong>: A utility class providing static methods to bridge between the concrete <code>Lazy&lt;A&gt;</code> type and its HKT representation <code>LazyKind&lt;A&gt;</code>. It includes:
<ul>
<li><code>widen(Lazy&lt;A&gt;)</code>: Wraps a <code>Lazy</code> instance into <code>LazyKind</code>.</li>
<li><code>narrow(Kind&lt;LazyKind.Witness, A&gt;)</code>: Unwraps <code>LazyKind</code> back to <code>Lazy</code>. Throws <code>KindUnwrapException</code> if the input Kind is invalid.</li>
<li><code>defer(ThrowableSupplier&lt;A&gt;)</code>: Factory to create a <code>LazyKind</code> from a computation.</li>
<li><code>now(A value)</code>: Factory to create an already evaluated <code>LazyKind</code>.</li>
<li><code>force(Kind&lt;LazyKind.Witness, A&gt;)</code>: Convenience method to unwrap and force evaluation.</li>
</ul>
</li>
<li><strong><code>LazyMonad</code></strong>: The type class instance implementing <code>Monad&lt;LazyKind.Witness&gt;</code>, <code>Applicative&lt;LazyKind.Witness&gt;</code>, and <code>Functor&lt;LazyKind.Witness&gt;</code>. It provides standard monadic operations (<code>map</code>, <code>flatMap</code>, <code>of</code>, <code>ap</code>) for <code>LazyKind</code>, ensuring laziness is maintained during composition.</li>
</ol>
<h2 id="purpose-and-usage-2"><a class="header" href="#purpose-and-usage-2">Purpose and Usage</a></h2>
<ul>
<li><strong>Deferred Computation</strong>: Use <code>Lazy</code> when you have potentially expensive computations that should only execute if their result is actually needed.</li>
<li><strong>Memoization</strong>: The result (or exception) of the computation is stored after the first call to <code>force()</code>, subsequent calls return the cached result without re-computation.</li>
<li><strong>Exception Handling</strong>: Computations wrapped in <code>Lazy.defer</code> can throw any <code>Throwable</code>. This exception is caught, memoised, and re-thrown by <code>force()</code>.</li>
<li><strong>Functional Composition</strong>: <code>LazyMonad</code> allows chaining lazy computations using <code>map</code> and <code>flatMap</code> while preserving laziness. The composition itself doesn't trigger evaluation; only forcing the final <code>LazyKind</code> does.</li>
<li><strong>HKT Integration</strong>: <code>LazyKind</code> and <code>LazyMonad</code> enable using lazy computations within generic functional code expecting <code>Kind&lt;F, A&gt;</code> and <code>Monad&lt;F&gt;</code>.</li>
</ul>
<div id="admonition-example-creating-lazy-instances" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-creating-lazy-instances-title">
<div class="admonition-title">
<div id="admonition-example-creating-lazy-instances-title">
<p>Example: Creating Lazy Instances</p>
</div>
<a class="admonition-anchor-link" href="monads/lazy_monad.html#admonition-example-creating-lazy-instances"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/lazy/LazyExample.java">LazyExample.java</a></li>
</ul>
<pre><code class="language-java">
// 1. Deferring a computation (that might throw checked exception)
java.util.concurrent.atomic.AtomicInteger counter = new java.util.concurrent.atomic.AtomicInteger(0);
Kind&lt;LazyKind.Witness, String&gt; deferredLazy = LAZY.defer(() -&gt; {
    System.out.println("Executing expensive computation...");
    counter.incrementAndGet();
    // Simulate potential failure
    if (System.currentTimeMillis() % 2 == 0) {
         // Throwing a checked exception is allowed by ThrowableSupplier
         throw new java.io.IOException("Simulated IO failure");
    }
    Thread.sleep(50); // Simulate work
    return "Computed Value";
});

// 2. Creating an already evaluated Lazy
Kind&lt;LazyKind.Witness, String&gt; nowLazy = LAZY.now("Precomputed Value");

// 3. Using the underlying Lazy type directly (less common when using HKT)
Lazy&lt;String&gt; directLazy = Lazy.defer(() -&gt; { counter.incrementAndGet(); return "Direct Lazy"; });
</code></pre>
</div>
</div>
<div id="admonition-example-forcing-evaluation" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-forcing-evaluation-title">
<div class="admonition-title">
<div id="admonition-example-forcing-evaluation-title">
<p>Example: Forcing Evaluation</p>
</div>
<a class="admonition-anchor-link" href="monads/lazy_monad.html#admonition-example-forcing-evaluation"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/lazy/LazyExample.java">LazyExample.java</a></li>
</ul>
<p>Evaluation only happens when <code>force()</code> is called (directly or via the helper).</p>
<pre><code class="language-java">// (Continuing from above)
System.out.println("Lazy instances created. Counter: " + counter.get()); // Output: 0

try {
    // Force the deferred computation
    String result1 = LAZY.force(deferredLazy); // force() throws Throwable
    System.out.println("Result 1: " + result1);
    System.out.println("Counter after first force: " + counter.get()); // Output: 1

    // Force again - uses memoised result
    String result2 = LAZY.force(deferredLazy);
    System.out.println("Result 2: " + result2);
    System.out.println("Counter after second force: " + counter.get()); // Output: 1 (not re-computed)

    // Force the 'now' instance
    String resultNow = LAZY.force(nowLazy);
    System.out.println("Result Now: " + resultNow);
    System.out.println("Counter after forcing 'now': " + counter.get()); // Output: 1 (no computation ran for 'now')

} catch (Throwable t) { // Catch Throwable because force() can re-throw anything
    System.err.println("Caught exception during force: " + t);
    // Exception is also memoised:
    try {
        LAZY.force(deferredLazy);
    } catch (Throwable t2) {
        System.err.println("Caught memoised exception: " + t2);
        System.out.println("Counter after failed force: " + counter.get()); // Output: 1
    }
}
</code></pre>
</div>
</div>
<div id="admonition-example-using-_lazymonad_-_map_-and-_flatmap_" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-using-_lazymonad_-_map_-and-_flatmap_-title">
<div class="admonition-title">
<div id="admonition-example-using-_lazymonad_-_map_-and-_flatmap_-title">
<p>Example: Using <em>LazyMonad</em> (<em>map</em> and <em>flatMap</em>)</p>
</div>
<a class="admonition-anchor-link" href="monads/lazy_monad.html#admonition-example-using-_lazymonad_-_map_-and-_flatmap_"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/lazy/LazyExample.java">LazyExample.java</a></li>
</ul>
<pre><code class="language-java">
LazyMonad lazyMonad = LazyMonad.INSTANCE;
counter.set(0); // Reset counter for this example

Kind&lt;LazyKind.Witness, Integer&gt; initialLazy = LAZY.defer(() -&gt; { counter.incrementAndGet(); return 10; });

// --- map ---
// Apply a function lazily
Function&lt;Integer, String&gt; toStringMapper = i -&gt; "Value: " + i;
Kind&lt;LazyKind.Witness, String&gt; mappedLazy = lazyMonad.map(toStringMapper, initialLazy);

System.out.println("Mapped Lazy created. Counter: " + counter.get()); // Output: 0

try {
    System.out.println("Mapped Result: " + LAZY.force(mappedLazy)); // Triggers evaluation of initialLazy &amp; map
    // Output: Mapped Result: Value: 10
    System.out.println("Counter after forcing mapped: " + counter.get()); // Output: 1
} catch (Throwable t) { /* ... */ }


// --- flatMap ---
// Sequence lazy computations
Function&lt;Integer, Kind&lt;LazyKind.Witness, String&gt;&gt; multiplyAndStringifyLazy =
    i -&gt; LAZY.defer(() -&gt; { // Inner computation is also lazy
        int result = i * 5;
        return "Multiplied: " + result;
    });

Kind&lt;LazyKind.Witness, String&gt; flatMappedLazy = lazyMonad.flatMap(multiplyAndStringifyLazy, initialLazy);

System.out.println("FlatMapped Lazy created. Counter: " + counter.get()); // Output: 1 (map already forced initialLazy)

try {
    System.out.println("FlatMapped Result: " + force(flatMappedLazy)); // Triggers evaluation of inner lazy
    // Output: FlatMapped Result: Multiplied: 50
} catch (Throwable t) { /* ... */ }

// --- Chaining ---
Kind&lt;LazyKind.Witness, String&gt; chainedLazy = lazyMonad.flatMap(
    value1 -&gt; lazyMonad.map(
        value2 -&gt; "Combined: " + value1 + " &amp; " + value2, // Combine results
        LAZY.defer(()-&gt;value1 * 2) // Second lazy step, depends on result of first
    ),
    LAZY.defer(()-&gt;5) // First lazy step
);

try{
    System.out.println("Chained Result: "+force(chainedLazy)); // Output: Combined: 5 &amp; 10
}catch(Throwable t){/* ... */}
</code></pre>
</div>
</div><div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="the-listmonad"><a class="header" href="#the-listmonad">The ListMonad:</a></h1>
<h2 id="monadic-operations-on-java-lists"><a class="header" href="#monadic-operations-on-java-lists"><em>Monadic Operations on Java Lists</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="monads/list_monad.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to work with Lists as contexts representing multiple possible values</li>
<li>Using <code>flatMap</code> for non-deterministic computations and combinations</li>
<li>Generating Cartesian products and filtering results</li>
<li>Understanding how List models choice and branching computations</li>
<li>Building search algorithms and combinatorial problems with monadic operations</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code:</p>
</div>
<a class="admonition-anchor-link" href="monads/list_monad.html#admonition-see-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/list/ListMonadExample.java">ListMonadExample.java</a></p>
</div>
</div>
<h2 id="purpose-1"><a class="header" href="#purpose-1">Purpose</a></h2>
<p>The <code>ListMonad</code> in the <code>Higher-Kinded-J</code> library provides a monadic interface for Java's standard <code>java.util.List</code>. It allows developers to work with lists in a more functional style, enabling operations like <code>map</code>, <code>flatMap</code>, and <code>ap</code> (apply) within the higher-kinded type system. This is particularly useful for sequencing operations that produce lists, transforming list elements, and applying functions within a list context, all while integrating with the generic <code>Kind&lt;F, A&gt;</code> abstractions.</p>
<p>Key benefits include:</p>
<ul>
<li><strong>Functional Composition:</strong> Easily chain operations on lists, where each operation might return a list itself.</li>
<li><strong>HKT Integration:</strong> <code>ListKind</code> (the higher-kinded wrapper for <code>List</code>) and <code>ListMonad</code> allow <code>List</code> to be used with generic functions and type classes expecting <code>Kind&lt;F, A&gt;</code>, <code>Functor&lt;F&gt;</code>, <code>Applicative&lt;F&gt;</code>, or <code>Monad&lt;F&gt;</code>.</li>
<li><strong>Standard List Behavior:</strong> Leverages the familiar behaviour of Java lists, such as non-uniqueness of elements and order preservation. <code>flatMap</code> corresponds to applying a function that returns a list to each element and then concatenating the results.</li>
</ul>
<p>It implements <code>Monad&lt;ListKind&lt;A&gt;&gt;</code>, inheriting from <code>Functor&lt;ListKind&lt;A&gt;&gt;</code> and <code>Applicative&lt;ListKind&lt;A&gt;&gt;</code>.</p>
<h2 id="structure-1"><a class="header" href="#structure-1">Structure</a></h2>
<p><img src="monads/../images/puml/list_monad.svg" alt="list_monad.svg" /></p>
<h2 id="how-to-use-listmonad-and-listkind"><a class="header" href="#how-to-use-listmonad-and-listkind">How to Use <code>ListMonad</code> and <code>ListKind</code></a></h2>
<h3 id="creating-instances-1"><a class="header" href="#creating-instances-1">Creating Instances</a></h3>
<p><code>ListKind&lt;A&gt;</code> is the higher-kinded type representation for <code>java.util.List&lt;A&gt;</code>. You typically create <code>ListKind</code> instances using the <code>ListKindHelper</code> utility class or the <code>of</code> method from <code>ListMonad</code>.</p>
<div id="admonition-_listwidenlist_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_listwidenlist_-title">
<div class="admonition-title">
<div id="admonition-_listwidenlist_-title">
<p><em>LIST.widen(List<A>)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/list_monad.html#admonition-_listwidenlist_"></a>
</div>
<div>
<p>Converts a standard <code>java.util.List&lt;A&gt;</code> into a <code>Kind&lt;ListKind.Witness, A&gt;</code>.</p>
<pre><code class="language-java">List&lt;String&gt; stringList = Arrays.asList("a", "b", "c");
Kind&lt;ListKind.Witness, String&gt; listKind1 = LIST.widen(stringList);

List&lt;Integer&gt; intList = Collections.singletonList(10);
Kind&lt;ListKind.Witness, Integer&gt; listKind2 = LIST.widen(intList);

List&lt;Object&gt; emptyList = Collections.emptyList();
Kind&lt;ListKind.Witness, Object&gt; listKindEmpty = LIST.widen(emptyList);

</code></pre>
</div>
</div>
<div id="admonition-_listmonadofa-value_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_listmonadofa-value_-title">
<div class="admonition-title">
<div id="admonition-_listmonadofa-value_-title">
<p><em>listMonad.of(A value)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/list_monad.html#admonition-_listmonadofa-value_"></a>
</div>
<div>
<p>Lifts a single value into the <code>ListKind</code> context, creating a singleton list. A <code>null</code> input value results in an empty <code>ListKind</code>.</p>
<pre><code class="language-java">ListMonad listMonad = ListMonad.INSTANCE;

Kind&lt;ListKind.Witness, String&gt; listKindOneItem = listMonad.of("hello"); // Contains a list with one element: "hello"
Kind&lt;ListKind.Witness, Integer&gt; listKindAnotherItem = listMonad.of(42);  // Contains a list with one element: 42
Kind&lt;ListKind.Witness, Object&gt; listKindFromNull = listMonad.of(null); // Contains an empty list
</code></pre>
</div>
</div>
<div id="admonition-_listnarrow_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_listnarrow_-title">
<div class="admonition-title">
<div id="admonition-_listnarrow_-title">
<p><em>LIST.narrow()</em></p>
</div>
<a class="admonition-anchor-link" href="monads/list_monad.html#admonition-_listnarrow_"></a>
</div>
<div>
<p>To get the underlying <code>java.util.List&lt;A&gt;</code> from a <code>Kind&lt;ListKind.Witness, A&gt;</code>, use <code>LIST.narrow()</code>:</p>
<pre><code class="language-java">Kind&lt;ListKind.Witness, A&gt; listKind = LIST.widen(List.of("example"));
List&lt;String&gt; unwrappedList = LIST.narrow(listKind); // Returns Arrays.asList("example")
System.out.println(unwrappedList);
</code></pre>
</div>
</div>
<h3 id="key-operations"><a class="header" href="#key-operations">Key Operations</a></h3>
<p>The <code>ListMonad</code> provides standard monadic operations:</p>
<div id="admonition-_mapfunction-f-kind-fa_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_mapfunction-f-kind-fa_-title">
<div class="admonition-title">
<div id="admonition-_mapfunction-f-kind-fa_-title">
<p><em>map(Function&lt;A, B&gt; f, Kind&lt;ListKind.Witness, A&gt; fa)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/list_monad.html#admonition-_mapfunction-f-kind-fa_"></a>
</div>
<div>
<p><strong><code>map(Function&lt;A, B&gt; f, Kind&lt;ListKind.Witness, A&gt; fa)</code>:</strong></p>
<p>Applies a function <code>f</code> to each element of the list within <code>fa</code>, returning a new <code>ListKind</code> containing the transformed elements.</p>
<pre><code class="language-java">
ListMonad listMonad = ListMonad.INSTANCE;
ListKind&lt;Integer&gt; numbers = LIST.widen(Arrays.asList(1, 2, 3));

Function&lt;Integer, String&gt; intToString = i -&gt; "Number: " + i;
ListKind&lt;String&gt; strings = listMonad.map(intToString, numbers);

// LIST.narrow(strings) would be: ["Number: 1", "Number: 2", "Number: 3"]
System.out.println(LIST.narrow(strings));
</code></pre>
</div>
</div>
<div id="admonition-_flatmapfunction-f-kind-ma_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_flatmapfunction-f-kind-ma_-title">
<div class="admonition-title">
<div id="admonition-_flatmapfunction-f-kind-ma_-title">
<p><em>flatMap(Function&lt;A, Kind&lt;ListKind.Witness, B&gt;&gt; f, Kind&lt;ListKind.Witness, A&gt; ma)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/list_monad.html#admonition-_flatmapfunction-f-kind-ma_"></a>
</div>
<div>
<p><strong><code>flatMap(Function&lt;A, Kind&lt;ListKind.Witness, B&gt;&gt; f, Kind&lt;ListKind.Witness, A&gt; ma)</code>:</strong></p>
<p>Applies a function <code>f</code> to each element of the list within <code>ma</code>. The function <code>f</code> itself returns a <code>ListKind&lt;B&gt;</code>. <code>flatMap</code> then concatenates (flattens) all these resulting lists into a single <code>ListKind&lt;B&gt;</code>.</p>
<pre><code class="language-java">
ListMonad listMonad = ListMonad.INSTANCE;
Kind&lt;ListKind.Witness, Integer&gt; initialValues = LIST.widen(Arrays.asList(1, 2, 3));

// Function that takes an integer and returns a list of itself and itself + 10
Function&lt;Integer, Kind&lt;ListKind.Witness, Integer&gt;&gt; replicateAndAddTen =
    i -&gt; LIST.widen(Arrays.asList(i, i + 10));

Kind&lt;ListKind.Witness, Integer&gt; flattenedList = listMonad.flatMap(replicateAndAddTen, initialValues);

// LIST.narrow(flattenedList) would be: [1, 11, 2, 12, 3, 13]
System.out.println(LIST.narrow(flattenedList));

// Example with empty list results
Function&lt;Integer, Kind&lt;ListKind.Witness, String&gt;&gt; toWordsIfEven =
    i -&gt; (i % 2 == 0) ?
         LIST.widen(Arrays.asList("even", String.valueOf(i))) :
         LIST.widen(new ArrayList&lt;&gt;()); // empty list for odd numbers

Kind&lt;ListKind.Witness, String&gt; wordsList = listMonad.flatMap(toWordsIfEven, initialValues);
// LIST.narrow(wordsList) would be: ["even", "2"]
 System.out.println(LIST.narrow(wordsList));
</code></pre>
</div>
</div>
<div id="admonition-_apkind-ff-kind-fa_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_apkind-ff-kind-fa_-title">
<div class="admonition-title">
<div id="admonition-_apkind-ff-kind-fa_-title">
<p><em>ap(Kind&lt;ListKind.Witness, Function&lt;A, B&gt;&gt; ff, Kind&lt;ListKind.Witness, A&gt; fa)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/list_monad.html#admonition-_apkind-ff-kind-fa_"></a>
</div>
<div>
<p><strong><code>ap(Kind&lt;ListKind.Witness, Function&lt;A, B&gt;&gt; ff, Kind&lt;ListKind.Witness, A&gt; fa)</code>:</strong></p>
<p>Applies a list of functions <code>ff</code> to a list of values <code>fa</code>. This results in a new list where each function from <code>ff</code> is applied to each value in <code>fa</code> (Cartesian product style).</p>
<pre><code class="language-java">
ListMonad listMonad = ListMonad.INSTANCE;

Function&lt;Integer, String&gt; addPrefix = i -&gt; "Val: " + i;
Function&lt;Integer, String&gt; multiplyAndString = i -&gt; "Mul: " + (i * 2);

Kind&lt;ListKind.Witness, Function&lt;Integer, String&gt;&gt; functions =
    LIST.widen(Arrays.asList(addPrefix, multiplyAndString));
Kind&lt;ListKind.Witness, Integer&gt; values = LIST.widen(Arrays.asList(10, 20));

Kind&lt;ListKind.Witness, String&gt; appliedResults = listMonad.ap(functions, values);

// LIST.narrow(appliedResults) would be:
// ["Val: 10", "Val: 20", "Mul: 20", "Mul: 40"]
System.out.println(LIST.narrow(appliedResults));
</code></pre>
</div>
</div>
<div id="admonition-example-using-listmonad" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-using-listmonad-title">
<div class="admonition-title">
<div id="admonition-example-using-listmonad-title">
<p>Example: Using ListMonad</p>
</div>
<a class="admonition-anchor-link" href="monads/list_monad.html#admonition-example-using-listmonad"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/list/ListMonadExample.java">ListMonadExample.java</a></li>
</ul>
<p>To use <code>ListMonad</code> in generic contexts that operate over <code>Kind&lt;F, A&gt;</code>:</p>
<ol>
<li><strong>Get an instance of <code>ListMonad</code>:</strong></li>
</ol>
<pre><code class="language-java">ListMonad listMonad = ListMonad.INSTANCE;
</code></pre>
<ol start="2">
<li><strong>Wrap your List into <code>Kind</code>:</strong></li>
</ol>
<pre><code class="language-java">List&lt;Integer&gt; myList = Arrays.asList(10, 20, 30);
Kind&lt;ListKind.Witness, Integer&gt; listKind = LIST.widen(myList);
</code></pre>
<ol start="3">
<li><strong>Use <code>ListMonad</code> methods:</strong></li>
</ol>
<pre><code class="language-java">import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.list.ListKind;
import org.higherkindedj.hkt.list.ListKindHelper;
import org.higherkindedj.hkt.list.ListMonad;

import java.util.Arrays;
import java.util.List;
import java.util.function.Function;
import java.util.stream.Collectors;

public class ListMonadExample {
   public static void main(String[] args) {
      ListMonad listMonad = ListMonad.INSTANCE;

      // 1. Create a ListKind
      Kind&lt;ListKind.Witness, Integer&gt; numbersKind = LIST.widen(Arrays.asList(1, 2, 3, 4));

      // 2. Use map
      Function&lt;Integer, String&gt; numberToDecoratedString = n -&gt; "*" + n + "*";
      Kind&lt;ListKind.Witness, String&gt; stringsKind = listMonad.map(numberToDecoratedString, numbersKind);
      System.out.println("Mapped: " + LIST.narrow(stringsKind));
      // Expected: Mapped: [*1*, *2*, *3*, *4*]

      // 3. Use flatMap
      // Function: integer -&gt; ListKind of [integer, integer*10] if even, else empty ListKind
      Function&lt;Integer, Kind&lt;ListKind.Witness, Integer&gt;&gt; duplicateIfEven = n -&gt; {
         if (n % 2 == 0) {
            return LIST.widen(Arrays.asList(n, n * 10));
         } else {
            return LIST.widen(List.of()); // Empty list
         }
      };
      Kind&lt;ListKind.Witness, Integer&gt; flatMappedKind = listMonad.flatMap(duplicateIfEven, numbersKind);
      System.out.println("FlatMapped: " + LIST.narrow(flatMappedKind));
      // Expected: FlatMapped: [2, 20, 4, 40]

      // 4. Use of
      Kind&lt;ListKind.Witness, String&gt; singleValueKind = listMonad.of("hello world");
      System.out.println("From 'of': " + LIST.narrow(singleValueKind));
      // Expected: From 'of': [hello world]

      Kind&lt;ListKind.Witness, String&gt; fromNullOf = listMonad.of(null);
      System.out.println("From 'of' with null: " + LIST.narrow(fromNullOf));
      // Expected: From 'of' with null: []


      // 5. Use ap
      Kind&lt;ListKind.Witness, Function&lt;Integer, String&gt;&gt; listOfFunctions =
              LIST.widen(Arrays.asList(
                      i -&gt; "F1:" + i,
                      i -&gt; "F2:" + (i * i)
              ));
      Kind&lt;ListKind.Witness, Integer&gt; inputNumbersForAp = LIST.widen(Arrays.asList(5, 6));

      Kind&lt;ListKind.Witness, String&gt; apResult = listMonad.ap(listOfFunctions, inputNumbersForAp);
      System.out.println("Ap result: " + LIST.narrow(apResult));
      // Expected: Ap result: [F1:5, F1:6, F2:25, F2:36]


      // Unwrap to get back the standard List
      List&lt;Integer&gt; finalFlatMappedList = LIST.narrow(flatMappedKind);
      System.out.println("Final unwrapped flatMapped list: " + finalFlatMappedList);
   }
}
</code></pre>
<p>This example demonstrates how to wrap Java Lists into <code>ListKind</code>, apply monadic operations using <code>ListMonad</code>, and then unwrap them back to standard Lists.</p>
</div>
</div><div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="the-maybemonad"><a class="header" href="#the-maybemonad">The MaybeMonad:</a></h1>
<h2 id="handling-optional-values-with-non-null-guarantee"><a class="header" href="#handling-optional-values-with-non-null-guarantee"><em>Handling Optional Values with Non-Null Guarantee</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="monads/maybe_monad.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How Maybe provides null-safe optional values with guaranteed non-null contents</li>
<li>The difference between Maybe and Optional (non-null guarantee in Just)</li>
<li>Using Maybe as a MonadError with Unit as the error type</li>
<li>Chaining operations with automatic Nothing propagation</li>
<li>Building robust pipelines that handle absence gracefully</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code:</p>
</div>
<a class="admonition-anchor-link" href="monads/maybe_monad.html#admonition-see-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/maybe/MaybeExample.java">MaybeExample.java</a></p>
</div>
</div>
<h2 id="purpose-2"><a class="header" href="#purpose-2">Purpose</a></h2>
<p>How do you handle optional values in Java without falling into the null pointer trap? The <code>Maybe&lt;T&gt;</code> type in Higher-Kinded-J provides an elegant solution‚Äîrepresenting a value that might be present (<code>Just&lt;T&gt;</code>) or absent (<code>Nothing&lt;T&gt;</code>), with one crucial guarantee: a <code>Just&lt;T&gt;</code> will never hold null.</p>
<p>The <code>Maybe&lt;T&gt;</code> type is conceptually similar to <code>java.util.Optional&lt;T&gt;</code> but with a key distinction: a <code>Just&lt;T&gt;</code> is guaranteed to hold a <strong>non-null</strong> value. This strictness helps prevent <code>NullPointerExceptions</code> when a value is asserted to be present. <code>Maybe.fromNullable(T value)</code> or <code>MaybeMonad.of(T value)</code> should be used if the input value could be null, as these will correctly produce a <code>Nothing</code> in such cases.</p>
<p>The <code>MaybeMonad</code> provides a monadic interface for <code>Maybe</code>, allowing for functional composition and integration with the Higher-Kinded Type (HKT) system. This facilitates chaining operations that may or may not yield a value, propagating the <code>Nothing</code> state automatically.</p>
<div id="admonition-key-benefits-include" class="admonition admonish-info" role="note" aria-labelledby="admonition-key-benefits-include-title">
<div class="admonition-title">
<div id="admonition-key-benefits-include-title">
<p>Key benefits include:</p>
</div>
<a class="admonition-anchor-link" href="monads/maybe_monad.html#admonition-key-benefits-include"></a>
</div>
<div>
<ul>
<li><strong>Explicit Optionality with Non-Null Safety:</strong> <code>Just&lt;T&gt;</code> guarantees its contained value is not null. <code>Nothing&lt;T&gt;</code> clearly indicates absence.</li>
<li><strong>Functional Composition:</strong> Enables elegant chaining of operations using <code>map</code>, <code>flatMap</code>, and <code>ap</code>, where <code>Nothing</code> short-circuits computations.</li>
<li><strong>HKT Integration:</strong> <code>MaybeKind&lt;A&gt;</code> (the HKT wrapper for <code>Maybe&lt;A&gt;</code>) and <code>MaybeMonad</code> allow <code>Maybe</code> to be used with generic functions and type classes that expect <code>Kind&lt;F, A&gt;</code>, <code>Functor&lt;F&gt;</code>, <code>Applicative&lt;F&gt;</code>, <code>Monad&lt;M&gt;</code>, or <code>MonadError&lt;M, E&gt;</code>.</li>
<li><strong>Error Handling for Absence:</strong> <code>MaybeMonad</code> implements <code>MonadError&lt;MaybeKind.Witness, Unit&gt;</code>. <code>Nothing</code> is treated as the "error" state, with <code>Unit</code> as the phantom error type, signifying absence.</li>
</ul>
</div>
</div>
<p>It implements <code>MonadError&lt;MaybeKind.Witness, Unit&gt;</code>, which transitively includes <code>Monad&lt;MaybeKind.Witness&gt;</code>, <code>Applicative&lt;MaybeKind.Witness&gt;</code>, and <code>Functor&lt;MaybeKind.Witness&gt;</code>.</p>
<h2 id="structure-2"><a class="header" href="#structure-2">Structure</a></h2>
<p><img src="monads/../images/puml/maybe_monad.svg" alt="maybe_monad.svg" /></p>
<div id="admonition-related-types" class="admonition admonish-note" role="note" aria-labelledby="admonition-related-types-title">
<div class="admonition-title">
<div id="admonition-related-types-title">
<p>Related Types</p>
</div>
<a class="admonition-anchor-link" href="monads/maybe_monad.html#admonition-related-types"></a>
</div>
<div>
<p>For working with Java's standard <code>Optional</code> type in the HKT system, see <a href="monads/./optional_monad.html">Optional Monad</a>. For error handling with typed error values, see <a href="monads/./either_monad.html">Either Monad</a>.</p>
</div>
</div>
<h2 id="how-to-use-maybemonad-and-maybe"><a class="header" href="#how-to-use-maybemonad-and-maybe">How to Use <code>MaybeMonad</code> and <code>Maybe</code></a></h2>
<h3 id="creating-instances-2"><a class="header" href="#creating-instances-2">Creating Instances</a></h3>
<p><code>Maybe&lt;A&gt;</code> instances can be created directly using static factory methods on <code>Maybe</code>, or via <code>MaybeMonad</code> for HKT integration. Since <code>Just&lt;T&gt;</code> and <code>Nothing&lt;T&gt;</code> directly implement <code>MaybeKind&lt;T&gt;</code>, they are first-class participants in the HKT simulation with zero runtime overhead for widen/narrow operations.</p>
<p><strong>Direct <code>Maybe</code> Creation:</strong></p>
 <div id="admonition-_maybejustnonnull-t-value_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_maybejustnonnull-t-value_-title">
 <div class="admonition-title">
 <div id="admonition-_maybejustnonnull-t-value_-title">
<p><em>Maybe.just(@NonNull T value)</em></p>
 </div>
 <a class="admonition-anchor-link" href="monads/maybe_monad.html#admonition-_maybejustnonnull-t-value_"></a>
 </div>
 <div>
<p>Creates a <code>Just</code> holding a <strong>non-null</strong> value. Throws <code>NullPointerException</code> if <code>value</code> is null.</p>
<pre><code class="language-java">Maybe&lt;String&gt; justHello = Maybe.just("Hello"); // Just("Hello")
Maybe&lt;String&gt; illegalJust = Maybe.just(null); // Throws NullPointerException
</code></pre>
 </div>
 </div>
  <div id="admonition-_maybenothing_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_maybenothing_-title">
  <div class="admonition-title">
  <div id="admonition-_maybenothing_-title">
<p><em>Maybe.nothing()</em></p>
  </div>
  <a class="admonition-anchor-link" href="monads/maybe_monad.html#admonition-_maybenothing_"></a>
  </div>
  <div>
<p>Returns a singleton <code>Nothing</code> instance.</p>
<pre><code class="language-java">Maybe&lt;Integer&gt; noInt = Maybe.nothing(); // Nothing
</code></pre>
  </div>
  </div>
  <div id="admonition-_maybefromnullablenullable-t-value_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_maybefromnullablenullable-t-value_-title">
  <div class="admonition-title">
  <div id="admonition-_maybefromnullablenullable-t-value_-title">
<p><em>Maybe.fromNullable(@Nullable T value)</em></p>
  </div>
  <a class="admonition-anchor-link" href="monads/maybe_monad.html#admonition-_maybefromnullablenullable-t-value_"></a>
  </div>
  <div>
<p>Creates <code>Just(value)</code> if <code>value</code> is non-null, otherwise <code>Nothing</code>.</p>
<pre><code class="language-java">Maybe&lt;String&gt; fromPresent = Maybe.fromNullable("Present"); // Just("Present")
Maybe&lt;String&gt; fromNull = Maybe.fromNullable(null);     // Nothing
</code></pre>
  </div>
  </div>
<p><strong><code>MaybeKindHelper</code> (for HKT wrapping):</strong></p>
<div id="admonition-_maybekindhelperwidenmaybe-maybe_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_maybekindhelperwidenmaybe-maybe_-title">
<div class="admonition-title">
<div id="admonition-_maybekindhelperwidenmaybe-maybe_-title">
<p><em>MaybeKindHelper.widen(Maybe<A> maybe)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/maybe_monad.html#admonition-_maybekindhelperwidenmaybe-maybe_"></a>
</div>
<div>
<p>Converts a <code>Maybe&lt;A&gt;</code> to <code>Kind&lt;MaybeKind.Witness, A&gt;</code>. Since <code>Just</code> and <code>Nothing</code> directly implement <code>MaybeKind</code>, this performs a null check and type-safe cast (zero overhead‚Äîno wrapper object allocation).</p>
<pre><code class="language-java">Kind&lt;MaybeKind.Witness, String&gt; kindJust = MAYBE.widen(Maybe.just("Wrapped"));
Kind&lt;MaybeKind.Witness,Integer&gt; kindNothing = MAYBE.widen(Maybe.nothing());
</code></pre>
</div>
</div>
<div id="admonition-_maybejustnonnull-a-value_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_maybejustnonnull-a-value_-title">
<div class="admonition-title">
<div id="admonition-_maybejustnonnull-a-value_-title">
<p><em>MAYBE.just(@NonNull A value)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/maybe_monad.html#admonition-_maybejustnonnull-a-value_"></a>
</div>
<div>
<p>Convenience for <code>widen(Maybe.just(value))</code>.</p>
</div>
</div>
<div id="admonition-_maybenothing_-1" class="admonition admonish-note" role="note" aria-labelledby="admonition-_maybenothing_-1-title">
<div class="admonition-title">
<div id="admonition-_maybenothing_-1-title">
<p><em>MAYBE.nothing()</em></p>
</div>
<a class="admonition-anchor-link" href="monads/maybe_monad.html#admonition-_maybenothing_-1"></a>
</div>
<div>
<p>Convenience for <code>widen(Maybe.nothing())</code>.</p>
</div>
</div>
<p><strong><code>MaybeMonad</code> Instance Methods:</strong></p>
<div id="admonition-_maybemonadofnullable-a-value_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_maybemonadofnullable-a-value_-title">
<div class="admonition-title">
<div id="admonition-_maybemonadofnullable-a-value_-title">
<p><em>maybeMonad.of(@Nullable A value)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/maybe_monad.html#admonition-_maybemonadofnullable-a-value_"></a>
</div>
<div>
<p>Lifts a value into <code>Kind&lt;MaybeKind.Witness, A&gt;</code>. Uses <code>Maybe.fromNullable()</code> internally.</p>
<pre><code class="language-java">MaybeMonad maybeMonad = MaybeMonad.INSTANCE;
Kind&lt;MaybeKind.Witness, String&gt; kindFromMonad = maybeMonad.of("Monadic"); // Just("Monadic")
Kind&lt;MaybeKind.Witness, String&gt; kindNullFromMonad = maybeMonad.of(null);   // Nothing
</code></pre>
</div>
</div>
<div id="admonition-_maybemonadraiseerrornullable-unit-error_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_maybemonadraiseerrornullable-unit-error_-title">
<div class="admonition-title">
<div id="admonition-_maybemonadraiseerrornullable-unit-error_-title">
<p><em>maybeMonad.raiseError(@Nullable Unit error)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/maybe_monad.html#admonition-_maybemonadraiseerrornullable-unit-error_"></a>
</div>
<div>
<p>Creates a <code>Kind&lt;MaybeKind.Witness, E&gt;</code> representing <code>Nothing</code>. The <code>error</code> (Unit) argument is ignored.</p>
<pre><code class="language-java">Kind&lt;MaybeKind.Witness, Double&gt; errorKind = maybeMonad.raiseError(Unit.INSTANCE); // Nothing
</code></pre>
</div>
</div>
<div id="admonition-unwrapping-_maybekind_" class="admonition admonish-note" role="note" aria-labelledby="admonition-unwrapping-_maybekind_-title">
<div class="admonition-title">
<div id="admonition-unwrapping-_maybekind_-title">
<p>Unwrapping <em>MaybeKind</em></p>
</div>
<a class="admonition-anchor-link" href="monads/maybe_monad.html#admonition-unwrapping-_maybekind_"></a>
</div>
<div>
<p>To get the underlying <code>Maybe&lt;A&gt;</code> from a <code>MaybeKind&lt;A&gt;</code>, use <code>MAYBE.narrow()</code>:</p>
<pre><code class="language-java">MaybeKind&lt;String&gt; kindJust = MAYBE.just("Example");
Maybe&lt;String&gt; unwrappedMaybe = MAYBE.narrow(kindJust); // Just("Example")
System.out.println("Unwrapped: " + unwrappedMaybe);

MaybeKind&lt;Integer&gt; kindNothing = MAYBE.nothing();
Maybe&lt;Integer&gt; unwrappedNothing = MAYBE.narrow(kindNothing); // Nothing
System.out.println("Unwrapped Nothing: " + unwrappedNothing);
</code></pre>
</div>
</div>
<h3 id="interacting-with-maybe-values"><a class="header" href="#interacting-with-maybe-values">Interacting with <code>Maybe</code> values</a></h3>
<p>The <code>Maybe</code> interface itself provides useful methods:</p>
<ul>
<li><code>isJust()</code>: Returns <code>true</code> if it's a <code>Just</code>.</li>
<li><code>isNothing()</code>: Returns <code>true</code> if it's a <code>Nothing</code>.</li>
<li><code>get()</code>: Returns the value if <code>Just</code>, otherwise throws <code>NoSuchElementException</code>. <strong>Use with caution.</strong></li>
<li><code>orElse(@NonNull T other)</code>: Returns the value if <code>Just</code>, otherwise returns <code>other</code>.</li>
<li><code>orElseGet(@NonNull Supplier&lt;? extends @NonNull T&gt; other)</code>: Returns the value if <code>Just</code>, otherwise invokes <code>other.get()</code>.</li>
<li>The <code>Maybe</code> interface also has its own <code>map</code> and <code>flatMap</code> methods, which are similar in behaviour to those on <code>MaybeMonad</code> but operate directly on <code>Maybe</code> instances.</li>
</ul>
<h3 id="key-operations-via-maybemonad"><a class="header" href="#key-operations-via-maybemonad">Key Operations (via <code>MaybeMonad</code>)</a></h3>
<div id="admonition-example-_mapfunction-f-kind-ma_" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-_mapfunction-f-kind-ma_-title">
<div class="admonition-title">
<div id="admonition-example-_mapfunction-f-kind-ma_-title">
<p>Example: <em>map(Function&lt;A, B&gt; f, Kind&lt;MaybeKind.Witness, A&gt; ma)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/maybe_monad.html#admonition-example-_mapfunction-f-kind-ma_"></a>
</div>
<div>
<p>Applies <code>f</code> to the value inside <code>ma</code> if it's <code>Just</code>. If <code>ma</code> is <code>Nothing</code>, or if <code>f</code> returns <code>null</code> (which <code>Maybe.fromNullable</code> then converts to <code>Nothing</code>), the result is <code>Nothing</code>.</p>
<pre><code class="language-java">void mapExample() {
  MaybeMonad maybeMonad = MaybeMonad.INSTANCE;
  Kind&lt;MaybeKind.Witness, Integer&gt; justNum = MAYBE.just(10);
  Kind&lt;MaybeKind.Witness, Integer&gt; nothingNum = MAYBE.nothing();

  Function&lt;Integer, String&gt; numToString = n -&gt; "Val: " + n;
  Kind&lt;MaybeKind.Witness, String&gt; justStr = maybeMonad.map(numToString, justNum); // Just("Val: 10")
  Kind&lt;MaybeKind.Witness, String&gt; nothingStr = maybeMonad.map(numToString, nothingNum); // Nothing

  Function&lt;Integer, String&gt; numToNull = n -&gt; null;
  Kind&lt;MaybeKind.Witness, String&gt; mappedToNull = maybeMonad.map(numToNull, justNum); // Nothing

  System.out.println("Map (Just): " + MAYBE.narrow(justStr));
  System.out.println("Map (Nothing): " + MAYBE.narrow(nothingStr));
  System.out.println("Map (To Null): " + MAYBE.narrow(mappedToNull));
}
</code></pre>
</div>
</div>
<div id="admonition-example-_flatmapfunction-f-kind-ma_" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-_flatmapfunction-f-kind-ma_-title">
<div class="admonition-title">
<div id="admonition-example-_flatmapfunction-f-kind-ma_-title">
<p>Example: <em>flatMap(Function&lt;A, Kind&lt;MaybeKind.Witness, B&gt;&gt; f, Kind&lt;MaybeKind.Witness, A&gt; ma)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/maybe_monad.html#admonition-example-_flatmapfunction-f-kind-ma_"></a>
</div>
<div>
<p>If <code>ma</code> is <code>Just(a)</code>, applies <code>f</code> to <code>a</code>. <code>f</code> must return a <code>Kind&lt;MaybeKind.Witness, B&gt;</code>. If <code>ma</code> is <code>Nothing</code>, or <code>f</code> returns <code>Nothing</code>, the result is <code>Nothing</code>.</p>
<pre><code class="language-java">void flatMapExample() {
  MaybeMonad maybeMonad = MaybeMonad.INSTANCE;
  Function&lt;String, Kind&lt;MaybeKind.Witness, Integer&gt;&gt; parseString = s -&gt; {
    try {
      return MAYBE.just(Integer.parseInt(s));
    } catch (NumberFormatException e) {
      return MAYBE.nothing();
    }
  };

  Kind&lt;MaybeKind.Witness, String&gt; justFiveStr = MAYBE.just("5");
  Kind&lt;MaybeKind.Witness, Integer&gt; parsedJust = maybeMonad.flatMap(parseString, justFiveStr); // Just(5)

  Kind&lt;MaybeKind.Witness, String&gt; justNonNumStr = MAYBE.just("abc");
  Kind&lt;MaybeKind.Witness, Integer&gt; parsedNonNum = maybeMonad.flatMap(parseString, justNonNumStr); // Nothing

  System.out.println("FlatMap (Just): " + MAYBE.narrow(parsedJust));
  System.out.println("FlatMap (NonNum): " + MAYBE.narrow(parsedNonNum));
}
</code></pre>
</div>
</div>
<div id="admonition-example-_apkind-ff-kind-fa_" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-_apkind-ff-kind-fa_-title">
<div class="admonition-title">
<div id="admonition-example-_apkind-ff-kind-fa_-title">
<p>Example: <em>ap(Kind&lt;MaybeKind.Witness, Function&lt;A, B&gt;&gt; ff, Kind&lt;MaybeKind.Witness, A&gt; fa)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/maybe_monad.html#admonition-example-_apkind-ff-kind-fa_"></a>
</div>
<div>
<p>If <code>ff</code> is <code>Just(f)</code> and <code>fa</code> is <code>Just(a)</code>, applies <code>f</code> to <code>a</code>. Otherwise, <code>Nothing</code>.</p>
<pre><code class="language-java">void apExample() {
  MaybeMonad maybeMonad = MaybeMonad.INSTANCE;
  Kind&lt;MaybeKind.Witness, Integer&gt; justNum = MAYBE.just(10);
  Kind&lt;MaybeKind.Witness, Integer&gt; nothingNum = MAYBE.nothing();
  Kind&lt;MaybeKind.Witness, Function&lt;Integer, String&gt;&gt; justFunc = MAYBE.just(i -&gt; "Result: " + i);
  Kind&lt;MaybeKind.Witness, Function&lt;Integer, String&gt;&gt; nothingFunc = MAYBE.nothing();

  Kind&lt;MaybeKind.Witness, String&gt; apApplied = maybeMonad.ap(justFunc, justNum); // Just("Result: 10")
  Kind&lt;MaybeKind.Witness, String&gt; apNothingFunc = maybeMonad.ap(nothingFunc, justNum); // Nothing
  Kind&lt;MaybeKind.Witness, String&gt; apNothingVal = maybeMonad.ap(justFunc, nothingNum); // Nothing

  System.out.println("Ap (Applied): " + MAYBE.narrow(apApplied));
  System.out.println("Ap (Nothing Func): " + MAYBE.narrow(apNothingFunc));
  System.out.println("Ap (Nothing Val): " + MAYBE.narrow(apNothingVal));
}
</code></pre>
</div>
</div>
<div id="admonition-example-_handleerrorwithkind-ma-function-handler_" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-_handleerrorwithkind-ma-function-handler_-title">
<div class="admonition-title">
<div id="admonition-example-_handleerrorwithkind-ma-function-handler_-title">
<p>Example: <em>handleErrorWith(Kind&lt;MaybeKind.Witness, A&gt; ma, Function&lt;Void, Kind&lt;MaybeKind.Witness, A&gt;&gt; handler)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/maybe_monad.html#admonition-example-_handleerrorwithkind-ma-function-handler_"></a>
</div>
<div>
<p>If <code>ma</code> is <code>Just</code>, it's returned. If <code>ma</code> is <code>Nothing</code> (the "error" state), <code>handler</code> is invoked (with <code>Unit.INSTANCE</code> for <code>Unit</code>) to provide a recovery <code>MaybeKind</code>.</p>
<pre><code class="language-java">void handleErrorWithExample() {
  MaybeMonad maybeMonad = MaybeMonad.INSTANCE;
  Function&lt;Unit, Kind&lt;MaybeKind.Witness, String&gt;&gt; recover = v -&gt; MAYBE.just("Recovered");

  Kind&lt;MaybeKind.Witness, String&gt; handledJust = maybeMonad.handleErrorWith(MAYBE.just("Original"), recover); // Just("Original")
  Kind&lt;MaybeKind.Witness, String&gt; handledNothing = maybeMonad.handleErrorWith(MAYBE.nothing(), recover);    // Just("Recovered")

  System.out.println("HandleError (Just): " + MAYBE.narrow(handledJust));
  System.out.println("HandleError (Nothing): " + MAYBE.narrow(handledNothing));
}
</code></pre>
</div>
</div>
<div id="admonition-example-using-_maybemonad_" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-using-_maybemonad_-title">
<div class="admonition-title">
<div id="admonition-example-using-_maybemonad_-title">
<p>Example: Using <em>MaybeMonad</em></p>
</div>
<a class="admonition-anchor-link" href="monads/maybe_monad.html#admonition-example-using-_maybemonad_"></a>
</div>
<div>
<p>A complete example demonstrating generic usage:</p>
<pre><code class="language-java">public void monadExample() {
  MaybeMonad maybeMonad = MaybeMonad.INSTANCE;

  // 1. Create MaybeKind instances
  Kind&lt;MaybeKind.Witness, Integer&gt; presentIntKind = MAYBE.just(100);
  Kind&lt;MaybeKind.Witness, Integer&gt; absentIntKind = MAYBE.nothing();
  Kind&lt;MaybeKind.Witness, String&gt; nullInputStringKind = maybeMonad.of(null); // Becomes Nothing

  // 2. Use map
  Function&lt;Integer, String&gt; intToStatus = n -&gt; "Status: " + n;
  Kind&lt;MaybeKind.Witness, String&gt; mappedPresent = maybeMonad.map(intToStatus, presentIntKind);
  Kind&lt;MaybeKind.Witness, String&gt; mappedAbsent = maybeMonad.map(intToStatus, absentIntKind);

  System.out.println("Mapped (Present): " + MAYBE.narrow(mappedPresent)); // Just(Status: 100)
  System.out.println("Mapped (Absent): " + MAYBE.narrow(mappedAbsent));   // Nothing

  // 3. Use flatMap
  Function&lt;Integer, Kind&lt;MaybeKind.Witness, String&gt;&gt; intToPositiveStatusKind = n -&gt;
      (n &gt; 0) ? maybeMonad.of("Positive: " + n) : MAYBE.nothing();

  Kind&lt;MaybeKind.Witness, String&gt; flatMappedPresent = maybeMonad.flatMap(intToPositiveStatusKind, presentIntKind);
  Kind&lt;MaybeKind.Witness, String&gt; flatMappedZero = maybeMonad.flatMap(intToPositiveStatusKind, maybeMonad.of(0)); // 0 is not &gt; 0

  System.out.println("FlatMapped (Present Positive): " + MAYBE.narrow(flatMappedPresent)); // Just(Positive: 100)
  System.out.println("FlatMapped (Zero): " + MAYBE.narrow(flatMappedZero)); // Nothing

  // 4. Use 'of' and 'raiseError'
  Kind&lt;MaybeKind.Witness, String&gt; fromOf = maybeMonad.of("Direct Value");
  Kind&lt;MaybeKind.Witness, String&gt; fromRaiseError = maybeMonad.raiseError(Unit.INSTANCE); // Creates Nothing
  System.out.println("From 'of': " + MAYBE.narrow(fromOf)); // Just(Direct Value)
  System.out.println("From 'raiseError': " + MAYBE.narrow(fromRaiseError)); // Nothing
  System.out.println("From 'of(null)': " + MAYBE.narrow(nullInputStringKind)); // Nothing


  // 5. Use handleErrorWith
  Function&lt;Void, Kind&lt;MaybeKind.Witness, Integer&gt;&gt; recoverWithDefault =
      v -&gt; maybeMonad.of(-1); // Default value if absent

  Kind&lt;MaybeKind.Witness, Integer&gt; recoveredFromAbsent =
      maybeMonad.handleErrorWith(absentIntKind, recoverWithDefault);
  Kind&lt;MaybeKind.Witness, Integer&gt; notRecoveredFromPresent =
      maybeMonad.handleErrorWith(presentIntKind, recoverWithDefault);

  System.out.println("Recovered (from Absent): " + MAYBE.narrow(recoveredFromAbsent)); // Just(-1)
  System.out.println("Recovered (from Present): " + MAYBE.narrow(notRecoveredFromPresent)); // Just(100)

  // Using the generic processData function
  Kind&lt;MaybeKind.Witness, String&gt; processedPresent = processData(presentIntKind, x -&gt; "Processed: " + x, "N/A", maybeMonad);
  Kind&lt;MaybeKind.Witness, String&gt; processedAbsent = processData(absentIntKind, x -&gt; "Processed: " + x, "N/A", maybeMonad);

  System.out.println("Generic Process (Present): " + MAYBE.narrow(processedPresent)); // Just(Processed: 100)
  System.out.println("Generic Process (Absent): " + MAYBE.narrow(processedAbsent));   // Just(N/A)

  // Unwrap to get back the standard Maybe
  Maybe&lt;String&gt; finalMappedMaybe = MAYBE.narrow(mappedPresent);
  System.out.println("Final unwrapped mapped maybe: " + finalMappedMaybe); // Just(Status: 100)
}

public static &lt;A, B&gt; Kind&lt;MaybeKind.Witness, B&gt; processData(
    Kind&lt;MaybeKind.Witness, A&gt; inputKind,
    Function&lt;A, B&gt; mapper,
    B defaultValueOnAbsence,
    MaybeMonad monad
) {
  // inputKind is now Kind&lt;MaybeKind.Witness, A&gt;, which is compatible with monad.map
  Kind&lt;MaybeKind.Witness, B&gt; mappedKind = monad.map(mapper, inputKind);

  // The result of monad.map is Kind&lt;MaybeKind.Witness, B&gt;.
  // The handler (Unit v) -&gt; monad.of(defaultValueOnAbsence) also produces Kind&lt;MaybeKind.Witness, B&gt;.
  return monad.handleErrorWith(mappedKind, (Unit v) -&gt; monad.of(defaultValueOnAbsence));
}
</code></pre>
<p>This example highlights how <code>MaybeMonad</code> facilitates working with optional values in a functional, type-safe manner, especially when dealing with the HKT abstractions and requiring non-null guarantees for present values.</p>
</div>
</div><div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="the-optionalmonad"><a class="header" href="#the-optionalmonad">The OptionalMonad:</a></h1>
<h2 id="monadic-operations-for-java-optional"><a class="header" href="#monadic-operations-for-java-optional"><em>Monadic Operations for Java Optional</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="monads/optional_monad.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to integrate Java's Optional with Higher-Kinded-J's type class system</li>
<li>Using MonadError with Unit to represent absence as an error state</li>
<li>Chaining optional operations with automatic empty propagation</li>
<li>Building safe database and service call pipelines</li>
<li>When to choose Optional vs Maybe for your use case</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code:</p>
</div>
<a class="admonition-anchor-link" href="monads/optional_monad.html#admonition-see-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/optional/OptionalExample.java">OptionalExample.java</a></p>
</div>
</div>
<h2 id="purpose-3"><a class="header" href="#purpose-3">Purpose</a></h2>
<p>The <code>OptionalMonad</code> in the <code>Higher-Kinded-J</code> library provides a monadic interface for Java's standard <code>java.util.Optional&lt;T&gt;</code>. It allows developers to work with <code>Optional</code> values in a more functional and composable style, enabling operations like <code>map</code>, <code>flatMap</code>, and <code>ap</code> (apply) within the higher-kinded type (HKT) system. This is particularly useful for sequencing operations that may or may not produce a value, handling the presence or absence of values gracefully.</p>
<p>Key benefits include:</p>
<ul>
<li><strong>Functional Composition:</strong> Easily chain operations on <code>Optional</code>s, where each operation might return an <code>Optional</code> itself. If any step results in an <code>Optional.empty()</code>, subsequent operations are typically short-circuited, propagating the empty state.</li>
<li><strong>HKT Integration:</strong> <code>OptionalKind&lt;A&gt;</code> (the higher-kinded wrapper for <code>Optional&lt;A&gt;</code>) and <code>OptionalMonad</code> allow <code>Optional</code> to be used with generic functions and type classes expecting <code>Kind&lt;F, A&gt;</code>, <code>Functor&lt;F&gt;</code>, <code>Applicative&lt;F&gt;</code>, <code>Monad&lt;M&gt;</code>, or even <code>MonadError&lt;M, E&gt;</code>.</li>
<li><strong>Error Handling for Absence:</strong> <code>OptionalMonad</code> implements <code>MonadError&lt;OptionalKind.Witness, Unit&gt;</code>. In this context, <code>Optional.empty()</code> is treated as the "error" state, and <code>Unit</code> is used as the phantom error type, signifying absence rather than a traditional exception.</li>
</ul>
<p>It implements <code>MonadError&lt;OptionalKind.Witness, Unit&gt;</code>, which means it also transitively implements <code>Monad&lt;OptionalKind.Witness&gt;</code>, <code>Applicative&lt;OptionalKind.Witness&gt;</code>, and <code>Functor&lt;OptionalKind.Witness&gt;</code>.</p>
<h2 id="structure-3"><a class="header" href="#structure-3">Structure</a></h2>
<p><img src="monads/../images/puml/optional_monad.svg" alt="optional_monad.svg" /></p>
<h2 id="how-to-use-optionalmonad-and-optionalkind"><a class="header" href="#how-to-use-optionalmonad-and-optionalkind">How to Use <code>OptionalMonad</code> and <code>OptionalKind</code></a></h2>
<h3 id="creating-instances-3"><a class="header" href="#creating-instances-3">Creating Instances</a></h3>
<p><code>OptionalKind&lt;A&gt;</code> is the higher-kinded type representation for <code>java.util.Optional&lt;A&gt;</code>. You typically create <code>OptionalKind</code> instances using the <code>OptionalKindHelper</code> utility class or the <code>of</code> and <code>raiseError</code> methods from <code>OptionalMonad</code>.</p>
<div id="admonition-_optionalwidenoptional_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_optionalwidenoptional_-title">
<div class="admonition-title">
<div id="admonition-_optionalwidenoptional_-title">
<p><em>OPTIONAL.widen(Optional<A>)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/optional_monad.html#admonition-_optionalwidenoptional_"></a>
</div>
<div>
<p>Converts a standard <code>java.util.Optional&lt;A&gt;</code> into an <code>OptionalKind&lt;A&gt;</code>.</p>
<pre><code class="language-java">// Wrapping a present Optional
Optional&lt;String&gt; presentOptional = Optional.of("Hello");
OptionalKind&lt;String&gt; kindPresent = OPTIONAL.widen(presentOptional);

// Wrapping an empty Optional
Optional&lt;Integer&gt; emptyOptional = Optional.empty();
OptionalKind&lt;Integer&gt; kindEmpty = OPTIONAL.widen(emptyOptional);

// Wrapping an Optional that might be null (though Optional itself won't be null)
String possiblyNullValue = null;
Optional&lt;String&gt; nullableOptional = Optional.ofNullable(possiblyNullValue); // Results in Optional.empty()
OptionalKind&lt;String&gt; kindFromNullable = OPTIONAL.widen(nullableOptional);
</code></pre>
</div>
</div>
<div id="admonition-_optionalmonadofa-value_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_optionalmonadofa-value_-title">
<div class="admonition-title">
<div id="admonition-_optionalmonadofa-value_-title">
<p><em>optionalMonad.of(A value)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/optional_monad.html#admonition-_optionalmonadofa-value_"></a>
</div>
<div>
<p>Lifts a single value (which can be <code>null</code>) into the <code>OptionalKind</code> context. It uses <code>Optional.ofNullable(value)</code> internally.</p>
<pre><code class="language-java">OptionalMonad optionalMonad = OptionalMonad.INSTANCE;

Kind&lt;OptionalKind.Witness, String&gt; kindFromValue = optionalMonad.of("World"); // Wraps Optional.of("World")
Kind&lt;OptionalKind.Witness, Integer&gt; kindFromNullValue = optionalMonad.of(null); // Wraps Optional.empty()
</code></pre>
</div>
</div>
<div id="admonition-_optionalmonadraiseerrorunit-error_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_optionalmonadraiseerrorunit-error_-title">
<div class="admonition-title">
<div id="admonition-_optionalmonadraiseerrorunit-error_-title">
<p><em>optionalMonad.raiseError(Unit error)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/optional_monad.html#admonition-_optionalmonadraiseerrorunit-error_"></a>
</div>
<div>
<p>Creates an empty <code>OptionalKind</code>. Since <code>Unit</code> is the error type, this method effectively represents the "error" state of an <code>Optional</code>, which is <code>Optional.empty()</code>. The <code>error</code> argument (which would be <code>Unit.INSTANCE</code> for <code>Unit</code>) is ignored.</p>
<pre><code class="language-java">
OptionalMonad optionalMonad = OptionalMonad.INSTANCE;
Kind&lt;OptionalKind.Witness, String&gt; emptyKindFromError = optionalMonad.raiseError(Unit.INSTANCE); // Represents Optional.empty()
</code></pre>
</div>
</div>
<div id="admonition-_optionalnarrow_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_optionalnarrow_-title">
<div class="admonition-title">
<div id="admonition-_optionalnarrow_-title">
<p><em>OPTIONAL.narrow()</em></p>
</div>
<a class="admonition-anchor-link" href="monads/optional_monad.html#admonition-_optionalnarrow_"></a>
</div>
<div>
<p>To get the underlying <code>java.util.Optional&lt;A&gt;</code> from an <code>OptionalKind&lt;A&gt;</code>, use <code>OPTIONAL.narrow()</code>:</p>
<pre><code class="language-java">
OptionalKind&lt;String&gt; kindPresent = OPTIONAL.widen(Optional.of("Example"));
Optional&lt;String&gt; unwrappedOptional = OPTIONAL.narrow(kindPresent); // Returns Optional.of("Example")
System.out.println("Unwrapped: " + unwrappedOptional);

OptionalKind&lt;Integer&gt; kindEmpty = OPTIONAL.widen(Optional.empty());
Optional&lt;Integer&gt; unwrappedEmpty = OPTIONAL.narrow(kindEmpty); // Returns Optional.empty()
System.out.println("Unwrapped Empty: " + unwrappedEmpty);
</code></pre>
</div>
</div>
<h3 id="key-operations-1"><a class="header" href="#key-operations-1">Key Operations</a></h3>
<p>The <code>OptionalMonad</code> provides standard monadic and error-handling operations:</p>
<div id="admonition-example-_mapfunction-f-kind-fa_" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-_mapfunction-f-kind-fa_-title">
<div class="admonition-title">
<div id="admonition-example-_mapfunction-f-kind-fa_-title">
<p>Example: <em>map(Function&lt;A, B&gt; f, Kind&lt;OptionalKind.Witness, A&gt; fa)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/optional_monad.html#admonition-example-_mapfunction-f-kind-fa_"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/optional/OptionalExample.java">OptionalExample.java</a></li>
</ul>
<p>Applies a function <code>f</code> to the value inside <code>fa</code> if it's present. If <code>fa</code> is empty, it remains empty. The function <code>f</code> can return <code>null</code>, which <code>Optional.map</code> will turn into an <code>Optional.empty()</code>.</p>
<pre><code class="language-java">
public void mapExample() {
   OptionalMonad optionalMonad = OptionalMonad.INSTANCE;
   OptionalKind&lt;Integer&gt; presentNumber = OPTIONAL.widen(Optional.of(10));
   OptionalKind&lt;Integer&gt; emptyNumber = OPTIONAL.widen(Optional.empty());

   Function&lt;Integer, String&gt; intToString = i -&gt; "Number: " + i;
   Kind&lt;OptionalKind.Witness, String&gt; presentString = optionalMonad.map(intToString, presentNumber);
   // OPTIONAL.narrow(presentString) would be Optional.of("Number: 10")

   Kind&lt;OptionalKind.Witness, String&gt; emptyString = optionalMonad.map(intToString, emptyNumber);
   // OPTIONAL.narrow(emptyString) would be Optional.empty()

   Function&lt;Integer, String&gt; intToNull = i -&gt; null;
   Kind&lt;OptionalKind.Witness, String&gt; mappedToNull = optionalMonad.map(intToNull, presentNumber);
   // OPTIONAL.narrow(mappedToNull) would be Optional.empty()

   System.out.println("Map (Present): " + OPTIONAL.narrow(presentString));
   System.out.println("Map (Empty): " + OPTIONAL.narrow(emptyString));
   System.out.println("Map (To Null): " + OPTIONAL.narrow(mappedToNull));
}
</code></pre>
</div>
</div>
<div id="admonition-example-_flatmapfunction-f-kind-ma_" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-_flatmapfunction-f-kind-ma_-title">
<div class="admonition-title">
<div id="admonition-example-_flatmapfunction-f-kind-ma_-title">
<p>Example: <em>flatMap(Function&lt;A, Kind&lt;OptionalKind.Witness, B&gt;&gt; f, Kind&lt;OptionalKind.Witness, A&gt; ma)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/optional_monad.html#admonition-example-_flatmapfunction-f-kind-ma_"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/optional/OptionalExample.java">OptionalExample.java</a></li>
</ul>
<p>Applies a function <code>f</code> to the value inside <code>ma</code> if it's present. The function <code>f</code> itself returns an <code>OptionalKind&lt;B&gt;</code>. If <code>ma</code> is empty, or if <code>f</code> returns an empty <code>OptionalKind</code>, the result is an empty <code>OptionalKind</code>.</p>
<pre><code class="language-java">public void flatMapExample() {
   OptionalMonad optionalMonad = OptionalMonad.INSTANCE;
   OptionalKind&lt;String&gt; presentInput = OPTIONAL.widen(Optional.of("5"));
   OptionalKind&lt;String&gt; emptyInput = OPTIONAL.widen(Optional.empty());

   Function&lt;String, Kind&lt;OptionalKind.Witness, Integer&gt;&gt; parseToIntKind = s -&gt; {
      try {
         return OPTIONAL.widen(Optional.of(Integer.parseInt(s)));
      } catch (NumberFormatException e) {
         return OPTIONAL.widen(Optional.empty());
      }
   };

   Kind&lt;OptionalKind.Witness, Integer&gt; parsedPresent = optionalMonad.flatMap(parseToIntKind, presentInput);
   // OPTIONAL.narrow(parsedPresent) would be Optional.of(5)

   Kind&lt;OptionalKind.Witness, Integer&gt; parsedEmpty = optionalMonad.flatMap(parseToIntKind, emptyInput);
   // OPTIONAL.narrow(parsedEmpty) would be Optional.empty()

   OptionalKind&lt;String&gt; nonNumericInput = OPTIONAL.widen(Optional.of("abc"));
   Kind&lt;OptionalKind.Witness, Integer&gt; parsedNonNumeric = optionalMonad.flatMap(parseToIntKind, nonNumericInput);
   // OPTIONAL.narrow(parsedNonNumeric) would be Optional.empty()

   System.out.println("FlatMap (Present): " + OPTIONAL.narrow(parsedPresent));
   System.out.println("FlatMap (Empty Input): " + OPTIONAL.narrow(parsedEmpty));
   System.out.println("FlatMap (Non-numeric): " + OPTIONAL.narrow(parsedNonNumeric));
}
</code></pre>
</div>
</div>
<div id="admonition-example-_apkind-ff-kind-fa_" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-_apkind-ff-kind-fa_-title">
<div class="admonition-title">
<div id="admonition-example-_apkind-ff-kind-fa_-title">
<p>Example: <em>ap(Kind&lt;OptionalKind.Witness, Function&lt;A, B&gt;&gt; ff, Kind&lt;OptionalKind.Witness, A&gt; fa)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/optional_monad.html#admonition-example-_apkind-ff-kind-fa_"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/optional/OptionalExample.java">OptionalExample.java</a></li>
</ul>
<p>Applies an <code>OptionalKind</code> containing a function <code>ff</code> to an <code>OptionalKind</code> containing a value <code>fa</code>. If both are present, the function is applied. Otherwise, the result is empty.</p>
<pre><code class="language-java"> public void apExample() {
   OptionalMonad optionalMonad = OptionalMonad.INSTANCE;

   OptionalKind&lt;Function&lt;Integer, String&gt;&gt; presentFuncKind =
           OPTIONAL.widen(Optional.of(i -&gt; "Value: " + i));
   OptionalKind&lt;Function&lt;Integer, String&gt;&gt; emptyFuncKind =
           OPTIONAL.widen(Optional.empty());

   OptionalKind&lt;Integer&gt; presentValueKind = OPTIONAL.widen(Optional.of(100));
   OptionalKind&lt;Integer&gt; emptyValueKind = OPTIONAL.widen(Optional.empty());

   // Both present
   Kind&lt;OptionalKind.Witness, String&gt; result1 = optionalMonad.ap(presentFuncKind, presentValueKind);
   // OPTIONAL.narrow(result1) is Optional.of("Value: 100")

   // Function empty
   Kind&lt;OptionalKind.Witness, String&gt; result2 = optionalMonad.ap(emptyFuncKind, presentValueKind);
   // OPTIONAL.narrow(result2) is Optional.empty()

   // Value empty
   Kind&lt;OptionalKind.Witness, String&gt; result3 = optionalMonad.ap(presentFuncKind, emptyValueKind);
   // OPTIONAL.narrow(result3) is Optional.empty()

   System.out.println("Ap (Both Present): " + OPTIONAL.narrow(result1));
   System.out.println("Ap (Function Empty): " + OPTIONAL.narrow(result2));
   System.out.println("Ap (Value Empty): " + OPTIONAL.narrow(result3));
}

</code></pre>
</div>
</div>
<div id="admonition-example-handleerrorwithkind-ma-function-handler" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-handleerrorwithkind-ma-function-handler-title">
<div class="admonition-title">
<div id="admonition-example-handleerrorwithkind-ma-function-handler-title">
<p>Example: handleErrorWith(Kind&lt;OptionalKind.Witness, A&gt; ma, Function&lt;Unit, Kind&lt;OptionalKind.Witness, A&gt;&gt; handler)</p>
</div>
<a class="admonition-anchor-link" href="monads/optional_monad.html#admonition-example-handleerrorwithkind-ma-function-handler"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/optional/OptionalExample.java">OptionalExample.java</a></li>
</ul>
<p>If <code>ma</code> is present, it's returned. If <code>ma</code> is empty (the "error" state), the <code>handler</code> function is invoked (with <code>Unit.INSTANCE</code> as the <code>Unit</code> argument) to provide a recovery <code>OptionalKind</code>.</p>
<pre><code class="language-java">public void handleErrorWithExample() {
   OptionalMonad optionalMonad = OptionalMonad.INSTANCE;

   Kind&lt;OptionalKind.Witness, String&gt; presentKind = OPTIONAL.widen(Optional.of("Exists"));
   OptionalKind&lt;String&gt; emptyKind = OPTIONAL.widen(Optional.empty());

   Function&lt;Unit, Kind&lt;OptionalKind.Witness, String&gt;&gt; recoveryFunction =
           (Unit unitInstance) -&gt; OPTIONAL.widen(Optional.of("Recovered Value"));

   // Handling error on a present OptionalKind
   Kind&lt;OptionalKind.Witness, String&gt; handledPresent =
           optionalMonad.handleErrorWith(presentKind, recoveryFunction);
   // OPTIONAL.narrow(handledPresent) is Optional.of("Exists")

   // Handling error on an empty OptionalKind
   Kind&lt;OptionalKind.Witness, String&gt; handledEmpty =
           optionalMonad.handleErrorWith(emptyKind, recoveryFunction);

   // OPTIONAL.narrow(handledEmpty) is Optional.of("Recovered Value")
   System.out.println("HandleError (Present): " + OPTIONAL.narrow(handledPresent));
   System.out.println("HandleError (Empty): " + OPTIONAL.narrow(handledEmpty));
}
</code></pre>
</div>
</div>
<div id="admonition-example-using-_optionalmonad_" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-using-_optionalmonad_-title">
<div class="admonition-title">
<div id="admonition-example-using-_optionalmonad_-title">
<p>Example: Using <em>OptionalMonad</em></p>
</div>
<a class="admonition-anchor-link" href="monads/optional_monad.html#admonition-example-using-_optionalmonad_"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/optional/OptionalExample.java">OptionalExample.java</a></li>
</ul>
<p>To use <code>OptionalMonad</code> in generic contexts that operate over <code>Kind&lt;F, A&gt;</code>:</p>
<pre><code class="language-java">public void monadExample() {
    OptionalMonad optionalMonad = OptionalMonad.INSTANCE;

    // 1. Create OptionalKind instances
    OptionalKind&lt;Integer&gt; presentIntKind = OPTIONAL.widen(Optional.of(10));
    Kind&lt;OptionalKind.Witness, Integer&gt; emptyIntKind = optionalMonad.raiseError(null); // Creates empty
    
    // 2. Use map
    Function&lt;Integer, String&gt; intToMessage = n -&gt; "Value is " + n;
    Kind&lt;OptionalKind.Witness, String&gt; mappedPresent = optionalMonad.map(intToMessage, presentIntKind);
    Kind&lt;OptionalKind.Witness, String&gt; mappedEmpty = optionalMonad.map(intToMessage, emptyIntKind);
    
    System.out.println("Mapped (Present): " + OPTIONAL.narrow(mappedPresent)); // Optional[Value is 10]
    System.out.println("Mapped (Empty): " + OPTIONAL.narrow(mappedEmpty));   // Optional.empty
    
    // 3. Use flatMap
    Function&lt;Integer, Kind&lt;OptionalKind.Witness, Double&gt;&gt; intToOptionalDouble = n -&gt;
        (n &gt; 0) ? optionalMonad.of(n / 2.0) : optionalMonad.raiseError(null);
    
    Kind&lt;OptionalKind.Witness, Double&gt; flatMappedPresent = optionalMonad.flatMap(intToOptionalDouble, presentIntKind);
    Kind&lt;OptionalKind.Witness, Double&gt; flatMappedEmpty = optionalMonad.flatMap(intToOptionalDouble, emptyIntKind);
    Kind&lt;OptionalKind.Witness, Integer&gt; zeroIntKind = optionalMonad.of(0);
    Kind&lt;OptionalKind.Witness, Double&gt; flatMappedZero = optionalMonad.flatMap(intToOptionalDouble, zeroIntKind);
    
    
    System.out.println("FlatMapped (Present): " + OPTIONAL.narrow(flatMappedPresent)); // Optional[5.0]
    System.out.println("FlatMapped (Empty): " + OPTIONAL.narrow(flatMappedEmpty));     // Optional.empty
    System.out.println("FlatMapped (Zero): " + OPTIONAL.narrow(flatMappedZero));       // Optional.empty
    
    // 4. Use 'of' and 'raiseError' (already shown in creation)
    
    // 5. Use handleErrorWith
    Function&lt;Unit, Kind&lt;OptionalKind.Witness, Integer&gt;&gt; recoverWithDefault =
        v -&gt; optionalMonad.of(-1); // Default value if empty
    
    Kind&lt;OptionalKind.Witness, Integer&gt; recoveredFromEmpty =
        optionalMonad.handleErrorWith(emptyIntKind, recoverWithDefault);
    Kind&lt;OptionalKind.Witness, Integer&gt; notRecoveredFromPresent =
        optionalMonad.handleErrorWith(presentIntKind, recoverWithDefault);
    
    System.out.println("Recovered (from Empty): " + OPTIONAL.narrow(recoveredFromEmpty)); // Optional[-1]
    System.out.println("Recovered (from Present): " + OPTIONAL.narrow(notRecoveredFromPresent)); // Optional[10]
    
    // Unwrap to get back the standard Optional
    Optional&lt;String&gt; finalMappedOptional = OPTIONAL.narrow(mappedPresent);
    System.out.println("Final unwrapped mapped optional: " + finalMappedOptional);
}
</code></pre>
<p>This example demonstrates wrapping <code>Optional</code>s, applying monadic and error-handling operations via <code>OptionalMonad</code>, and unwrapping back to standard <code>Optional</code>s. The <code>MonadError</code> capabilities allow treating absence (<code>Optional.empty</code>) as a recoverable "error" state.</p>
</div>
</div><div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="the-reader-monad"><a class="header" href="#the-reader-monad">The Reader Monad:</a></h1>
<h2 id="managed-dependencies-and-configuration"><a class="header" href="#managed-dependencies-and-configuration"><em>Managed Dependencies and Configuration</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="monads/reader_monad.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to inject dependencies functionally without passing them everywhere</li>
<li>Building computations that depend on shared configuration or context</li>
<li>Using <code>ask</code> to access the environment and <code>local</code> to modify it</li>
<li>Creating testable code with explicit dependency management</li>
<li>Real-world examples with database connections and API configurations</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code:</p>
</div>
<a class="admonition-anchor-link" href="monads/reader_monad.html#admonition-see-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/reader/ReaderExample.java">ReaderExample.java</a></p>
</div>
</div>
<h2 id="purpose-4"><a class="header" href="#purpose-4">Purpose</a></h2>
<p>The <strong>Reader monad</strong> is a functional programming pattern primarily used for managing dependencies and context propagation in a clean and composable way. Imagine you have multiple functions or components that all need access to some shared, read-only environment, such as:</p>
<ul>
<li>Configuration settings (database URLs, API keys, feature flags).</li>
<li>Shared resources (thread pools, connection managers).</li>
<li>User context (userLogin ID, permissions).</li>
</ul>
<p>Instead of explicitly passing this environment object as an argument to every single function (which can become cumbersome and clutter signatures), the Reader monad encapsulates computations that <em>depend</em> on such an environment.</p>
<p>A <code>Reader&lt;R, A&gt;</code> represents a computation that, when provided with an environment of type <code>R</code>, will produce a value of type <code>A</code>. It essentially wraps a function <code>R -&gt; A</code>.</p>
<p>The benefits of using the Reader monad include:</p>
<ol>
<li><strong>Implicit Dependency Injection:</strong> The environment (<code>R</code>) is implicitly passed along the computation chain. Functions defined within the Reader context automatically get access to the environment when needed, without needing it explicitly in their signature.</li>
<li><strong>Composability:</strong> Reader computations can be easily chained together using standard monadic operations like <code>map</code> and <code>flatMap</code>.</li>
<li><strong>Testability:</strong> Dependencies are managed explicitly when the final Reader computation is run, making it easier to provide mock environments or configurations during testing.</li>
<li><strong>Code Clarity:</strong> Reduces the need to pass configuration objects through multiple layers of functions.</li>
</ol>
<p>In <code>Higher-Kinded-J</code>, the Reader monad pattern is implemented via the <code>Reader&lt;R, A&gt;</code> interface and its corresponding HKT simulation types (<code>ReaderKind</code>, <code>ReaderKindHelper</code>) and type class instances (<code>ReaderMonad</code>, <code>ReaderApplicative</code>, <code>ReaderFunctor</code>).</p>
<h2 id="structure-4"><a class="header" href="#structure-4">Structure</a></h2>
<p><img src="monads/../images/puml/reader_monad.svg" alt="reader_monad.svg" /></p>
<h2 id="the-readerr-a-type"><a class="header" href="#the-readerr-a-type">The <code>Reader&lt;R, A&gt;</code> Type</a></h2>
<p>The core type is the <code>Reader&lt;R, A&gt;</code> functional interface:</p>
<pre><code class="language-java">@FunctionalInterface
public interface Reader&lt;R, A&gt; {
  @Nullable A run(@NonNull R r); // The core function: Environment -&gt; Value

  // Static factories
  static &lt;R, A&gt; @NonNull Reader&lt;R, A&gt; of(@NonNull Function&lt;R, A&gt; runFunction);
  static &lt;R, A&gt; @NonNull Reader&lt;R, A&gt; constant(@Nullable A value);
  static &lt;R&gt; @NonNull Reader&lt;R, R&gt; ask();

  // Instance methods (for composition)
  default &lt;B&gt; @NonNull Reader&lt;R, B&gt; map(@NonNull Function&lt;? super A, ? extends B&gt; f);
  default &lt;B&gt; @NonNull Reader&lt;R, B&gt; flatMap(@NonNull Function&lt;? super A, ? extends Reader&lt;R, ? extends B&gt;&gt; f);
}
</code></pre>
<ul>
<li><code>run(R r)</code>: Executes the computation by providing the environment <code>r</code> and returning the result <code>A</code>.</li>
<li><code>of(Function&lt;R, A&gt;)</code>: Creates a <code>Reader</code> from a given function.</li>
<li><code>constant(A value)</code>: Creates a <code>Reader</code> that ignores the environment and always returns the provided value.</li>
<li><code>ask()</code>: Creates a <code>Reader</code> that simply returns the environment itself as the result.</li>
<li><code>map(Function&lt;A, B&gt;)</code>: Transforms the result <code>A</code> to <code>B</code><em>after</em> the reader is run, without affecting the required environment <code>R</code>.</li>
<li><code>flatMap(Function&lt;A, Reader&lt;R, B&gt;&gt;)</code>: Sequences computations. It runs the first reader, uses its result <code>A</code> to create a <em>second</em> reader (<code>Reader&lt;R, B&gt;</code>), and then runs that second reader with the <em>original</em> environment <code>R</code>.</li>
</ul>
<h2 id="reader-components"><a class="header" href="#reader-components">Reader Components</a></h2>
<p>To integrate <code>Reader</code> with Higher-Kinded-J:</p>
<ul>
<li><strong><code>ReaderKind&lt;R, A&gt;</code>:</strong> The marker interface extending <code>Kind&lt;ReaderKind.Witness&lt;R&gt;, A&gt;</code>. The witness type <code>F</code> is <code>ReaderKind.Witness&lt;R&gt;</code> (where <code>R</code> is fixed for a given monad instance), and the value type <code>A</code> is the result type of the reader.</li>
<li><strong><code>ReaderKindHelper</code>:</strong> The utility class with static methods:
<ul>
<li><code>widen(Reader&lt;R, A&gt;)</code>: Converts a <code>Reader</code> to <code>ReaderKind&lt;R, A&gt;</code>.</li>
<li><code>narrow(Kind&lt;ReaderKind.Witness&lt;R&gt;, A&gt;)</code>: Converts <code>ReaderKind</code> back to <code>Reader</code>. Throws <code>KindUnwrapException</code> if the input is invalid.</li>
<li><code>reader(Function&lt;R, A&gt;)</code>: Factory method to create a <code>ReaderKind</code> from a function.</li>
<li><code>constant(A value)</code>: Factory method for a <code>ReaderKind</code> returning a constant value.</li>
<li><code>ask()</code>: Factory method for a <code>ReaderKind</code> that returns the environment.</li>
<li><code>runReader(Kind&lt;ReaderKind.Witness&lt;R&gt;, A&gt; kind, R environment)</code>: The primary way to execute a <code>ReaderKind</code> computation by providing the environment.</li>
</ul>
</li>
</ul>
<h2 id="type-class-instances-readerfunctor-readerapplicative-readermonad"><a class="header" href="#type-class-instances-readerfunctor-readerapplicative-readermonad">Type Class Instances (<code>ReaderFunctor</code>, <code>ReaderApplicative</code>, <code>ReaderMonad</code>)</a></h2>
<p>These classes provide the standard functional operations for <code>ReaderKind.Witness&lt;R&gt;</code>, allowing you to treat <code>Reader</code> computations generically within Higher-Kinded-J:</p>
<ul>
<li><strong><code>ReaderFunctor&lt;R&gt;</code>:</strong> Implements <code>Functor&lt;ReaderKind.Witness&lt;R&gt;&gt;</code>. Provides the <code>map</code> operation.</li>
<li><strong><code>ReaderApplicative&lt;R&gt;</code>:</strong> Extends <code>ReaderFunctor&lt;R&gt;</code> and implements <code>Applicative&lt;ReaderKind.Witness&lt;R&gt;&gt;</code>. Provides <code>of</code> (lifting a value) and <code>ap</code> (applying a wrapped function to a wrapped value).</li>
<li><strong><code>ReaderMonad&lt;R&gt;</code>:</strong> Extends <code>ReaderApplicative&lt;R&gt;</code> and implements <code>Monad&lt;ReaderKind.Witness&lt;R&gt;&gt;</code>. Provides <code>flatMap</code> for sequencing computations that depend on previous results while implicitly carrying the environment <code>R</code>.</li>
</ul>
<p>You typically instantiate <code>ReaderMonad&lt;R&gt;</code> for the specific environment type <code>R</code> you are working with.</p>
<div id="admonition-example-managing-configuration" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-managing-configuration-title">
<div class="admonition-title">
<div id="admonition-example-managing-configuration-title">
<p>Example: Managing Configuration</p>
</div>
<a class="admonition-anchor-link" href="monads/reader_monad.html#admonition-example-managing-configuration"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/reader/ReaderExample.java">ReaderExample.java</a></li>
</ul>
<h3 id="1-define-your-environment"><a class="header" href="#1-define-your-environment">1. Define Your Environment</a></h3>
<pre><code class="language-java">// Example Environment: Application Configuration
record AppConfig(String databaseUrl, int timeoutMillis, String apiKey) {}
</code></pre>
<h3 id="2-create-reader-computations"><a class="header" href="#2-create-reader-computations">2. Create Reader Computations</a></h3>
<p>Use <code>ReaderKindHelper</code> factory methods:</p>
<pre><code class="language-java">import static org.higherkindedj.hkt.reader.ReaderKindHelper.*;

import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.reader.ReaderKind;

// Reader that retrieves the database URL from the config
Kind&lt;ReaderKind.Witness&lt;AppConfig&gt;, String&gt; getDbUrl = reader(AppConfig::databaseUrl);

// Reader that retrieves the timeout
Kind&lt;ReaderKind.Witness&lt;AppConfig&gt;, Integer&gt; getTimeout = reader(AppConfig::timeoutMillis);

// Reader that returns a constant value, ignoring the environment
Kind&lt;ReaderKind.Witness&lt;AppConfig&gt;, String&gt; getDefaultUser = constant("guest");

// Reader that returns the entire configuration environment
Kind&lt;ReaderKind.Witness&lt;AppConfig&gt;, AppConfig&gt; getConfig = ask();
</code></pre>
<h3 id="3-get-the-readermonad-instance"><a class="header" href="#3-get-the-readermonad-instance">3. Get the <code>ReaderMonad</code> Instance</a></h3>
<p>Instantiate the monad for your specific environment type <code>R</code>.</p>
<pre><code class="language-java">import org.higherkindedj.hkt.reader.ReaderMonad;

// Monad instance for computations depending on AppConfig
ReaderMonad&lt;AppConfig&gt; readerMonad = new ReaderMonad&lt;&gt;();
</code></pre>
<h3 id="4-compose-computations-using-map-and-flatmap"><a class="header" href="#4-compose-computations-using-map-and-flatmap">4. Compose Computations using <code>map</code> and <code>flatMap</code></a></h3>
<p>Use the methods on the <code>readerMonad</code> instance.</p>
<pre><code class="language-java">// Example 1: Map the timeout value
Kind&lt;ReaderKind.Witness&lt;AppConfig&gt;, String&gt; timeoutMessage = readerMonad.map(
    timeout -&gt; "Timeout is: " + timeout + "ms",
    getTimeout // Input: Kind&lt;ReaderKind.Witness&lt;AppConfig&gt;, Integer&gt;
);

// Example 2: Use flatMap to get DB URL and then construct a connection string (depends on URL)
Function&lt;String, Kind&lt;ReaderKind.Witness&lt;AppConfig&gt;, String&gt;&gt; buildConnectionString =
    dbUrl -&gt; reader( // &lt;- We return a new Reader computation
        config -&gt; dbUrl + "?apiKey=" + config.apiKey() // Access apiKey via the 'config' env
    );

Kind&lt;ReaderKind.Witness&lt;AppConfig&gt;, String&gt; connectionStringReader = readerMonad.flatMap(
    buildConnectionString, // Function: String -&gt; Kind&lt;ReaderKind.Witness&lt;AppConfig&gt;, String&gt;
    getDbUrl               // Input: Kind&lt;ReaderKind.Witness&lt;AppConfig&gt;, String&gt;
);

// Example 3: Combine multiple values using mapN (from Applicative)
Kind&lt;ReaderKind.Witness&lt;AppConfig&gt;, String&gt; dbInfo = readerMonad.map2(
    getDbUrl,
    getTimeout,
    (url, timeout) -&gt; "DB: " + url + " (Timeout: " + timeout + ")"
);
</code></pre>
<h3 id="5-run-the-computation"><a class="header" href="#5-run-the-computation">5. Run the Computation</a></h3>
<p>Provide the actual environment using <code>ReaderKindHelper.runReader</code>:</p>
<pre><code class="language-java">AppConfig productionConfig = new AppConfig("prod-db.example.com", 5000, "prod-key-123");
AppConfig stagingConfig = new AppConfig("stage-db.example.com", 10000, "stage-key-456");

// Run the composed computations with different environments
String prodTimeoutMsg = runReader(timeoutMessage, productionConfig);
String stageTimeoutMsg = runReader(timeoutMessage, stagingConfig);

String prodConnectionString = runReader(connectionStringReader, productionConfig);
String stageConnectionString = runReader(connectionStringReader, stagingConfig);

String prodDbInfo = runReader(dbInfo, productionConfig);
String stageDbInfo = runReader(dbInfo, stagingConfig);

// Get the raw config using ask()
AppConfig retrievedProdConfig = runReader(getConfig, productionConfig);


System.out.println("Prod Timeout: " + prodTimeoutMsg);           // Output: Timeout is: 5000ms
System.out.println("Stage Timeout: " + stageTimeoutMsg);         // Output: Timeout is: 10000ms
System.out.println("Prod Connection: " + prodConnectionString); // Output: prod-db.example.com?apiKey=prod-key-123
System.out.println("Stage Connection: " + stageConnectionString);// Output: stage-db.example.com?apiKey=stage-key-456
System.out.println("Prod DB Info: " + prodDbInfo);               // Output: DB: prod-db.example.com (Timeout: 5000)
System.out.println("Stage DB Info: " + stageDbInfo);             // Output: DB: stage-db.example.com (Timeout: 10000)
System.out.println("Retrieved Prod Config: " + retrievedProdConfig); // Output: AppConfig[databaseUrl=prod-db.example.com, timeoutMillis=5000, apiKey=prod-key-123]
</code></pre>
<p>Notice how the functions (<code>buildConnectionString</code>, the lambda in <code>map2</code>) don't need <code>AppConfig</code> as a parameter, but they can access it when needed within the <code>reader(...)</code> factory or implicitly via <code>flatMap</code> composition. The configuration is only provided once at the end when <code>runReader</code> is called.</p>
</div>
</div>
<div id="admonition-example-reader-for-side-effects-returning-unit" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-reader-for-side-effects-returning-unit-title">
<div class="admonition-title">
<div id="admonition-example-reader-for-side-effects-returning-unit-title">
<p>Example: Reader for Side-Effects (Returning Unit)</p>
</div>
<a class="admonition-anchor-link" href="monads/reader_monad.html#admonition-example-reader-for-side-effects-returning-unit"></a>
</div>
<div>
<p>Sometimes, a computation depending on an environment <code>R</code> might perform an action (like logging or initialising a component based on <code>R</code>) but doesn't produce a specific value other than signaling its completion. In such cases, the result type <code>A</code> of the <code>Reader&lt;R, A&gt;</code> can be <code>org.higherkindedj.hkt.Unit</code>.</p>
<pre><code class="language-java">import static org.higherkindedj.hkt.reader.ReaderKindHelper.*;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.reader.ReaderKind;
import org.higherkindedj.hkt.reader.ReaderMonad;
import org.higherkindedj.hkt.Unit; // Import Unit

// Assume AppConfig is defined as before
// record AppConfig(String databaseUrl, int timeoutMillis, String apiKey) {}

// ReaderMonad instance (can be the same as before)
// ReaderMonad&lt;AppConfig&gt; readerMonad = new ReaderMonad&lt;&gt;();

// A Reader computation that performs a side-effect (printing to console)
// using the config and returns Unit.
Kind&lt;ReaderKind.Witness&lt;AppConfig&gt;, Unit&gt; logApiKey = reader(
    config -&gt; {
        System.out.println("Accessed API Key: " + config.apiKey().substring(0, Math.min(config.apiKey().length(), 4)) + "...");
        return Unit.INSTANCE; // Explicitly return Unit.INSTANCE
    }
);

// You can compose this with other Reader computations.
// For example, get the DB URL and then log the API key.
Kind&lt;ReaderKind.Witness&lt;AppConfig&gt;, Unit&gt; getUrlAndLogKey = readerMonad.flatMap(
    dbUrl -&gt; {
        System.out.println("Database URL for logging context: " + dbUrl);
        // After processing dbUrl (here, just printing), return the next action
        return logApiKey;
    },
    getDbUrl // Assuming getDbUrl: Kind&lt;ReaderKind.Witness&lt;AppConfig&gt;, String&gt;
);


// To run it:
// AppConfig currentConfig = new AppConfig("prod-db.example.com", 5000, "prod-key-123");
// Unit result = runReader(logApiKey, currentConfig);
// System.out.println("Log API Key result: " + result); // Output: Log API Key result: ()

// Unit resultChained = runReader(getUrlAndLogKey, currentConfig);
// System.out.println("Get URL and Log Key result: " + resultChained);
// Output:
// Database URL for logging context: prod-db.example.com
// Accessed API Key: prod...
// Get URL and Log Key result: ()
</code></pre>
<p>In this example:</p>
<ul>
<li><code>logApiKey</code> is a <code>Reader&lt;AppConfig, Unit&gt;</code>. Its purpose is to perform an action (logging) using the <code>AppConfig</code>.</li>
<li>It returns <code>Unit.INSTANCE</code> to signify that the action completed successfully but yields no other specific data.</li>
<li>When composing, flatMap can be used to sequence such an action. If logApiKey were the last step in a sequence, the overall <code>flatMap</code> chain would also result in <code>Kind&lt;ReaderKind.Witness&lt;AppConfig&gt;, Unit&gt;</code>.</li>
</ul>
</div>
</div>
<div id="admonition-key-points" class="admonition admonish-tip" role="note" aria-labelledby="admonition-key-points-title">
<div class="admonition-title">
<div id="admonition-key-points-title">
<p>Key Points:</p>
</div>
<a class="admonition-anchor-link" href="monads/reader_monad.html#admonition-key-points"></a>
</div>
<div>
<p>The Reader monad (<code>Reader&lt;R, A&gt;</code>, <code>ReaderKind</code>, <code>ReaderMonad</code>) in <code>Higher-Kinded-J</code> provides a functional approach to dependency injection and configuration management.</p>
<p>It allows you to define computations that depend on a read-only environment <code>R</code> without explicitly passing <code>R</code> everywhere. By using Higher-Kinded-J and the <code>ReaderMonad</code>, you can compose these dependent functions cleanly using <code>map</code> and <code>flatMap</code>, providing the actual environment only once when the final computation is executed via <code>runReader</code>.</p>
<p>This leads to more modular, testable, and less cluttered code when dealing with shared context.</p>
</div>
</div>
<div id="admonition-further-reading" class="admonition admonish-tip" role="note" aria-labelledby="admonition-further-reading-title">
<div class="admonition-title">
<div id="admonition-further-reading-title">
<p>Further Reading</p>
</div>
<a class="admonition-anchor-link" href="monads/reader_monad.html#admonition-further-reading"></a>
</div>
<div>
<p>For deeper exploration of the Reader monad and dependency injection patterns:</p>
<p><strong>Foundational Resources:</strong></p>
<ul>
<li><strong>Cats Documentation</strong>: <a href="https://typelevel.org/cats/datatypes/reader.html">Reader Monad</a> - Scala implementation with practical examples</li>
<li><strong>Haskell Wiki</strong>: <a href="https://wiki.haskell.org/All_About_Monads#The_Reader_monad">Reader Monad</a> - Theoretical foundation and use cases</li>
<li><strong>Mark Seemann</strong>: <a href="https://blog.ploeh.dk/2017/01/27/from-dependency-injection-to-dependency-rejection/">Dependency Injection Revisited</a> - Functional alternatives to traditional DI</li>
</ul>
<p><strong>Java-Focused Resources:</strong></p>
<ul>
<li><strong>Functional Java</strong>: <a href="http://www.functionaljava.org/javadoc/4.8.1/functionaljava/fj/Reader.html">Reader implementation</a> - Pure functional library for Java with Reader monad</li>
<li><strong>Vavr Documentation</strong>: <a href="https://docs.vavr.io/#_functions">Function composition patterns</a> - Demonstrates functional composition techniques applicable to Reader pattern</li>
<li><strong>Baeldung</strong>: <a href="https://www.baeldung.com/vavr">Introduction to Vavr</a> - Java FP patterns and idioms</li>
<li><strong>Richard Warburton</strong>: "Java 8 Lambdas" (O'Reilly, 2014) - Functional programming fundamentals in Java</li>
<li><strong>Pierre-Yves Saumont</strong>: "Functional Programming in Java" (Manning, 2017) - Chapter on handling dependencies functionally</li>
</ul>
</div>
</div><div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="the-state-monad"><a class="header" href="#the-state-monad">The State Monad:</a></h1>
<h2 id="managing-state-functionally"><a class="header" href="#managing-state-functionally"><em>Managing State Functionally</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="monads/state_monad.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to manage state functionally without mutable variables</li>
<li>Using <code>get</code>, <code>set</code>, <code>modify</code>, and <code>inspect</code> for state operations</li>
<li>Building complex stateful workflows with automatic state threading</li>
<li>Creating a bank account simulation with transaction history</li>
<li>Why pure state management leads to more testable and maintainable code</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code:</p>
</div>
<a class="admonition-anchor-link" href="monads/state_monad.html#admonition-see-example-code"></a>
</div>
<div>
<ul>
<li>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/state/StateExample.java">StateExample</a></p>
</li>
<li>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/state/BankAccountWorkflow.java">BankAccountWorkflow.java</a></p>
</li>
</ul>
</div>
</div>
<h2 id="purpose-5"><a class="header" href="#purpose-5">Purpose</a></h2>
<p>State is everywhere in programming‚Äîcounters increment, configurations update, game characters level up. Yet managing state functionally, without mutation, often feels like fighting the paradigm. The State monad resolves this tension elegantly.</p>
<p>In many applications, we need to manage computations that involve <strong>state</strong> that changes over time.</p>
<p>Examples include:</p>
<ul>
<li>A counter being incremented.</li>
<li>A configuration object being updated.</li>
<li>The state of a game character.</li>
<li>Parsing input where the current position needs to be tracked.</li>
</ul>
<p>While imperative programming uses mutable variables, functional programming prefers immutability. The <strong>State monad</strong> provides a purely functional way to handle stateful computations without relying on mutable variables.</p>
<p>A <code>State&lt;S, A&gt;</code> represents a computation that takes an initial state <code>S</code> and produces a result value <code>A</code> along with a <strong>new, updated state</strong> <code>S</code>. It essentially wraps a function of the type <code>S -&gt; (A, S)</code>.</p>
<h3 id="key-benefits"><a class="header" href="#key-benefits">Key Benefits</a></h3>
<ol>
<li><strong>Explicit State:</strong> The state manipulation is explicitly encoded within the type <code>State&lt;S, A&gt;</code>.</li>
<li><strong>Purity:</strong> Functions using the State monad remain pure; they don't cause side effects by mutating external state. Instead, they describe how the state <em>should</em> transform.</li>
<li><strong>Composability:</strong> State computations can be easily sequenced using standard monadic operations (<code>map</code>, <code>flatMap</code>), where the state is automatically threaded through the sequence without explicitly threading state everywhere.</li>
<li><strong>Decoupling</strong>: Logic is decoupled from state handling mechanics.</li>
<li><strong>Testability:</strong> Pure state transitions are easier to test and reason about than code relying on mutable side effects.</li>
</ol>
<p>In <code>Higher-Kinded-J</code>, the State monad pattern is implemented via the <code>State&lt;S, A&gt;</code> interface, its associated <code>StateTuple&lt;S, A&gt;</code> record, the HKT simulation types (<code>StateKind</code>, <code>StateKindHelper</code>), and the type class instances (<code>StateMonad</code>, <code>StateApplicative</code>, <code>StateFunctor</code>).</p>
<h2 id="structure-5"><a class="header" href="#structure-5">Structure</a></h2>
<p><img src="monads/../images/puml/state_monad.svg" alt="state_monad.svg" /></p>
<h2 id="the-states-a-type-and-statetuples-a"><a class="header" href="#the-states-a-type-and-statetuples-a">The <code>State&lt;S, A&gt;</code> Type and <code>StateTuple&lt;S, A&gt;</code></a></h2>
<p>The core type is the <code>State&lt;S, A&gt;</code> functional interface:</p>
<pre><code class="language-java">@FunctionalInterface
public interface State&lt;S, A&gt; {

  // Represents the result: final value A and final state S
  record StateTuple&lt;S, A&gt;(@Nullable A value, @NonNull S state) { /* ... */ }

  // The core function: Initial State -&gt; (Result Value, Final State)
  @NonNull StateTuple&lt;S, A&gt; run(@NonNull S initialState);

  // Static factories
  static &lt;S, A&gt; @NonNull State&lt;S, A&gt; of(@NonNull Function&lt;@NonNull S, @NonNull StateTuple&lt;S, A&gt;&gt; runFunction);
  static &lt;S, A&gt; @NonNull State&lt;S, A&gt; pure(@Nullable A value); // Creates State(s -&gt; (value, s))
  static &lt;S&gt; @NonNull State&lt;S, S&gt; get();                      // Creates State(s -&gt; (s, s))
  static &lt;S&gt; @NonNull State&lt;S, Unit&gt; set(@NonNull S newState); // Creates State(s -&gt; (Unit.INSTANCE, newState))
  static &lt;S&gt; @NonNull State&lt;S, Unit&gt; modify(@NonNull Function&lt;@NonNull S, @NonNull S&gt; f); // Creates State(s -&gt; (Unit.INSTANCE, f(s)))
  static &lt;S, A&gt; @NonNull State&lt;S, A&gt; inspect(@NonNull Function&lt;@NonNull S, @Nullable A&gt; f); // Creates State(s -&gt; (f(s), s))

  // Instance methods for composition
  default &lt;B&gt; @NonNull State&lt;S, B&gt; map(@NonNull Function&lt;? super A, ? extends B&gt; f);
  default &lt;B&gt; @NonNull State&lt;S, B&gt; flatMap(@NonNull Function&lt;? super A, ? extends State&lt;S, ? extends B&gt;&gt; f);
}
</code></pre>
<ul>
<li><code>StateTuple&lt;S, A&gt;</code>: A simple record holding the pair <code>(value: A, state: S)</code> returned by running a <code>State</code> computation.</li>
<li><code>run(S initialState)</code>: Executes the stateful computation by providing the starting state.</li>
<li><code>of(...)</code>: The basic factory method taking the underlying function <code>S -&gt; StateTuple&lt;S, A&gt;</code>.</li>
<li><code>pure(A value)</code>: Creates a computation that returns the given value <code>A</code><em>without changing</em> the state.</li>
<li><code>get()</code>: Creates a computation that returns the <em>current</em> state <code>S</code> as its value, leaving the state unchanged.</li>
<li><code>set(S newState)</code>: Creates a computation that <em>replaces</em> the current state with <code>newState</code> and returns <code>Unit.INSTANCE</code> as its result value.</li>
<li><code>modify(Function&lt;S, S&gt; f)</code>: Creates a computation that applies a function <code>f</code> to the current state to get the <em>new</em> state, returning Unit.INSTANCE as its result value.</li>
<li><code>inspect(Function&lt;S, A&gt; f)</code>: Creates a computation that applies a function <code>f</code> to the current state to calculate a <em>result value</em><code>A</code>, leaving the state unchanged.</li>
<li><code>map(...)</code>: Transforms the <em>result value</em><code>A</code> to <code>B</code> after the computation runs, leaving the state transition logic untouched.</li>
<li><code>flatMap(...)</code>: The core sequencing operation. It runs the first <code>State</code> computation, takes its result value <code>A</code>, uses it to create a <em>second</em><code>State</code> computation, and runs that second computation using the state produced by the first one. The final result and state are those from the second computation.</li>
</ul>
<h2 id="state-components"><a class="header" href="#state-components">State Components</a></h2>
<p>To integrate <code>State</code> with Higher-Kinded-J:</p>
<ul>
<li><strong><code>StateKind&lt;S, A&gt;</code>:</strong> The marker interface extending <code>Kind&lt;StateKind.Witness&lt;S&gt;, A&gt;</code>. The witness type <code>F</code> is <code>StateKind.Witness&lt;S&gt;</code> (where <code>S</code> is fixed for a given monad instance), and the value type <code>A</code> is the result type <code>A</code> from <code>StateTuple</code>.</li>
<li><strong><code>StateKindHelper</code>:</strong> The utility class with static methods:
<ul>
<li><code>widen(State&lt;S, A&gt;)</code>: Converts a <code>State</code> to <code>Kind&lt;StateKind.Witness&lt;S&gt;, A&gt;</code>.</li>
<li><code>narrow(Kind&lt;StateKind.Witness&lt;S&gt;, A&gt;)</code>: Converts <code>StateKind</code> back to <code>State</code>. Throws <code>KindUnwrapException</code> if the input is invalid.</li>
<li><code>pure(A value)</code>: Factory for <code>Kind</code> equivalent to <code>State.pure</code>.</li>
<li><code>get()</code>: Factory for <code>Kind</code> equivalent to <code>State.get</code>.</li>
<li><code>set(S newState)</code>: Factory for <code>Kind</code> equivalent to <code>State.set</code>.</li>
<li><code>modify(Function&lt;S, S&gt; f)</code>: Factory for <code>Kind</code> equivalent to <code>State.modify</code>.</li>
<li><code>inspect(Function&lt;S, A&gt; f)</code>: Factory for <code>Kind</code> equivalent to <code>State.inspect</code>.</li>
<li><code>runState(Kind&lt;StateKind.Witness&lt;S&gt;, A&gt; kind, S initialState)</code>: Runs the computation and returns the <code>StateTuple&lt;S, A&gt;</code>.</li>
<li><code>evalState(Kind&lt;StateKind.Witness&lt;S&gt;, A&gt; kind, S initialState)</code>: Runs the computation and returns only the final value <code>A</code>.</li>
<li><code>execState(Kind&lt;StateKind.Witness&lt;S&gt;, A&gt; kind, S initialState)</code>: Runs the computation and returns only the final state <code>S</code>.</li>
</ul>
</li>
</ul>
<h2 id="type-class-instances-statefunctor-stateapplicative-statemonad"><a class="header" href="#type-class-instances-statefunctor-stateapplicative-statemonad">Type Class Instances (<code>StateFunctor</code>, <code>StateApplicative</code>, <code>StateMonad</code>)</a></h2>
<p>These classes provide the standard functional operations for <code>StateKind.Witness&lt;S&gt;</code>:</p>
<ul>
<li><strong><code>StateFunctor&lt;S&gt;</code>:</strong> Implements <code>Functor&lt;StateKind.Witness&lt;S&gt;&gt;</code>. Provides <code>map</code>.</li>
<li><strong><code>StateApplicative&lt;S&gt;</code>:</strong> Extends <code>StateFunctor&lt;S&gt;</code>, implements <code>Applicative&lt;StateKind.Witness&lt;S&gt;&gt;</code>. Provides <code>of</code> (same as <code>pure</code>) and <code>ap</code>.</li>
<li><strong><code>StateMonad&lt;S&gt;</code>:</strong> Extends <code>StateApplicative&lt;S&gt;</code>, implements <code>Monad&lt;StateKind.Witness&lt;S&gt;&gt;</code>. Provides <code>flatMap</code> for sequencing stateful computations.</li>
</ul>
<p>You instantiate <code>StateMonad&lt;S&gt;</code> for the specific state type <code>S</code> you are working with.</p>
<div id="admonition-example-managing-bank-account-transactions" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-managing-bank-account-transactions-title">
<div class="admonition-title">
<div id="admonition-example-managing-bank-account-transactions-title">
<p>Example: Managing Bank Account Transactions</p>
</div>
<a class="admonition-anchor-link" href="monads/state_monad.html#admonition-example-managing-bank-account-transactions"></a>
</div>
<div>
<p>We want to model a bank account where we can:</p>
<ul>
<li>Deposit funds.</li>
<li>Withdraw funds (if sufficient balance).</li>
<li>Get the current balance.</li>
<li>Get the transaction history.</li>
</ul>
<p>All these operations will affect or depend on the account's state (balance and history).</p>
<h2 id="1-define-the-state"><a class="header" href="#1-define-the-state">1. Define the State</a></h2>
<p>First, we define a record to represent the state of our bank account.</p>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/state/AccountState.java">AccountState.java</a></li>
</ul>
<pre><code class="language-java">public record AccountState(BigDecimal balance, List&lt;Transaction&gt; history) {
  public AccountState {
    requireNonNull(balance, "Balance cannot be null.");
    requireNonNull(history, "History cannot be null.");
    // Ensure history is unmodifiable and a defensive copy is made.
    history = Collections.unmodifiableList(new ArrayList&lt;&gt;(history));
  }

  // Convenience constructor for initial state
  public static AccountState initial(BigDecimal initialBalance) {
    requireNonNull(initialBalance, "Initial balance cannot be null");
    if (initialBalance.compareTo(BigDecimal.ZERO) &lt; 0) {
      throw new IllegalArgumentException("Initial balance cannot be negative.");
    }
    Transaction initialTx = new Transaction(
            TransactionType.INITIAL_BALANCE,
            initialBalance,
            LocalDateTime.now(),
            "Initial account balance"
    );
    // The history now starts with this initial transaction
    return new AccountState(initialBalance, Collections.singletonList(initialTx));
  }

  public AccountState addTransaction(Transaction transaction) {
    requireNonNull(transaction, "Transaction cannot be null");
    List&lt;Transaction&gt; newHistory = new ArrayList&lt;&gt;(history); // Takes current history
    newHistory.add(transaction);                             // Adds new one
    return new AccountState(this.balance, Collections.unmodifiableList(newHistory));
  }

  public AccountState withBalance(BigDecimal newBalance) {
    requireNonNull(newBalance, "New balance cannot be null");
    return new AccountState(newBalance, this.history);
  }
}
</code></pre>
<h3 id="2-define-transaction-types"><a class="header" href="#2-define-transaction-types">2. Define Transaction Types</a></h3>
<p>We'll also need a way to represent transactions.</p>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/state/TransactionType.java">TransactionType.java</a></li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/state/Transaction.java">Transaction.java</a></li>
</ul>
<pre><code class="language-java">public enum TransactionType {
  INITIAL_BALANCE,
  DEPOSIT,
  WITHDRAWAL,
  REJECTED_WITHDRAWAL,
  REJECTED_DEPOSIT
}

public record Transaction(
        TransactionType type, BigDecimal amount, LocalDateTime timestamp, String description) {
  public Transaction {
    requireNonNull(type, "Transaction type cannot be null");
    requireNonNull(amount, "Transaction amount cannot be null");
    requireNonNull(timestamp, "Transaction timestamp cannot be null");
    requireNonNull(description, "Transaction description cannot be null");
    if (type != INITIAL_BALANCE &amp;&amp; amount.compareTo(BigDecimal.ZERO) &lt;= 0) {
      if (!(type == REJECTED_DEPOSIT &amp;&amp; amount.compareTo(BigDecimal.ZERO) &lt;= 0)
              &amp;&amp; !(type == REJECTED_WITHDRAWAL &amp;&amp; amount.compareTo(BigDecimal.ZERO) &lt;= 0)) {
        throw new IllegalArgumentException(
                "Transaction amount must be positive for actual operations.");
      }
    }
  }
}
</code></pre>
<h3 id="3-define-state-actions"><a class="header" href="#3-define-state-actions">3. Define State Actions</a></h3>
<p>Now, we define our bank operations as functions that return <code>Kind&lt;StateKind.Witness&lt;AccountState&gt;, YourResultType&gt;</code>.
These actions describe how the state should change and what value they produce.</p>
<p>We'll put these in a <code>BankAccountWorkflow.java class</code>.</p>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/state/BankAccountWorkflow.java">BankAccountWorkflow.java</a></li>
</ul>
<pre><code class="language-java">public class BankAccountWorkflow {

  private static final StateMonad&lt;AccountState&gt; accountStateMonad = new StateMonad&lt;&gt;();

  public static Function&lt;BigDecimal, Kind&lt;StateKind.Witness&lt;AccountState&gt;, Unit&gt;&gt; deposit(
          String description) {
    return amount -&gt;
        STATE.widen(
          State.modify(
            currentState -&gt; {
              if (amount.compareTo(BigDecimal.ZERO) &lt;= 0) {
                // For rejected deposit, log the problematic amount
                Transaction rejected =
                        new Transaction(
                                TransactionType.REJECTED_DEPOSIT,
                                amount,
                                LocalDateTime.now(),
                                "Rejected Deposit: " + description + " - Invalid Amount " + amount);
                return currentState.addTransaction(rejected);
              }
              BigDecimal newBalance = currentState.balance().add(amount);
              Transaction tx =
                      new Transaction(
                              TransactionType.DEPOSIT, amount, LocalDateTime.now(), description);
              return currentState.withBalance(newBalance).addTransaction(tx);
        }));
  }

  public static Function&lt;BigDecimal, Kind&lt;StateKind.Witness&lt;AccountState&gt;, Boolean&gt;&gt; withdraw(
          String description) {
    return amount -&gt;
        STATE.widen(
                State.of(
                    currentState -&gt; {
                      if (amount.compareTo(BigDecimal.ZERO) &lt;= 0) {
                        // For rejected withdrawal due to invalid amount, log the problematic amount
                        Transaction rejected =
                            new Transaction(
                                    TransactionType.REJECTED_WITHDRAWAL,
                                    amount,
                                    LocalDateTime.now(),
                                    "Rejected Withdrawal: " + description + " - Invalid Amount " + amount);
                        return new StateTuple&lt;&gt;(false, currentState.addTransaction(rejected));
                      }
                      if (currentState.balance().compareTo(amount) &gt;= 0) {
                        BigDecimal newBalance = currentState.balance().subtract(amount);
                        Transaction tx =
                                new Transaction(
                                        TransactionType.WITHDRAWAL, amount, LocalDateTime.now(), description);
                        AccountState updatedState =
                                currentState.withBalance(newBalance).addTransaction(tx);
                        return new StateTuple&lt;&gt;(true, updatedState);
                      } else {
                        // For rejected withdrawal due to insufficient funds, log the amount that was
                        // attempted
                        Transaction tx =
                            new Transaction(
                                    TransactionType.REJECTED_WITHDRAWAL,
                                    amount,
                                    LocalDateTime.now(),
                                    "Rejected Withdrawal: "
                                            + description
                                            + " - Insufficient Funds. Balance: "
                                            + currentState.balance());
                        AccountState updatedState = currentState.addTransaction(tx);
                        return new StateTuple&lt;&gt;(false, updatedState);
                      }
                  }));
  }

  public static Kind&lt;StateKind.Witness&lt;AccountState&gt;, BigDecimal&gt; getBalance() {
    return STATE.widen(State.inspect(AccountState::balance));
  }

  public static Kind&lt;StateKind.Witness&lt;AccountState&gt;, List&lt;Transaction&gt;&gt; getHistory() {
    return STATE.widen(State.inspect(AccountState::history));
  }

  // ... main method will be added

}
</code></pre>
<h3 id="4-compose-computations-using-map-and-flatmap-1"><a class="header" href="#4-compose-computations-using-map-and-flatmap-1">4. Compose Computations using <code>map</code> and <code>flatMap</code></a></h3>
<p>We use <code>flatMap</code> and <code>map</code> from  <code>accountStateMonad</code> to sequence these actions. The state is threaded automatically.</p>
<pre><code class="language-java">public class BankAccountWorkflow {
  // ... (monad instance and previous actions)
  public static void main(String[] args) {
    // Initial state: Account with ¬£100 balance.
    AccountState initialState = AccountState.initial(new BigDecimal("100.00"));
   var workflow =
           For.from(accountStateMonad, deposit("Salary").apply(new BigDecimal("20.00")))
               .from(a -&gt; withdraw("Bill Payment").apply(new BigDecimal("50.00")))
               .from(b -&gt; withdraw("Groceries").apply(new BigDecimal("70.00")))
               .from(c -&gt; getBalance())
               .from(t -&gt; getHistory())
               .yield((deposit, w1, w2, bal, history) -&gt; {
                 var report = new StringBuilder();
                 history.forEach(tx -&gt; report.append("  - %s\n".formatted(tx)));
                 return report.toString();
               });

    StateTuple&lt;AccountState, String&gt; finalResultTuple =
        StateKindHelper.runState(workflow, initialState);

    System.out.println(finalResultTuple.value());

    System.out.println("\nDirect Final Account State:");
    System.out.println("Balance: ¬£" + finalResultTuple.state().balance());
    System.out.println(
        "History contains " + finalResultTuple.state().history().size() + " transaction(s):");
    finalResultTuple.state().history().forEach(tx -&gt; System.out.println("  - " + tx));
  }
}
</code></pre>
<h3 id="5-run-the-computation-1"><a class="header" href="#5-run-the-computation-1">5. Run the Computation</a></h3>
<p>The <code>StateKindHelper.runState(workflow, initialState)</code> call executes the entire sequence of operations, starting with <code>initialState</code>.
It returns a StateTuple containing the final result of the <em>entire workflow</em> (in this case, the <code>String</code> report) and the final state of the <code>AccountState</code>.</p>
<pre><code>
Direct Final Account State:
Balance: ¬£0.00
History contains 4 transaction(s):
  - Transaction[type=INITIAL_BALANCE, amount=100.00, timestamp=2025-05-18T17:35:53.564874439, description=Initial account balance]
  - Transaction[type=DEPOSIT, amount=20.00, timestamp=2025-05-18T17:35:53.578424630, description=Salary]
  - Transaction[type=WITHDRAWAL, amount=50.00, timestamp=2025-05-18T17:35:53.579196349, description=Bill Payment]
  - Transaction[type=WITHDRAWAL, amount=70.00, timestamp=2025-05-18T17:35:53.579453984, description=Groceries]
</code></pre>
</div>
</div>
<div id="admonition-key-points" class="admonition admonish-tip" role="note" aria-labelledby="admonition-key-points-title">
<div class="admonition-title">
<div id="admonition-key-points-title">
<p>Key Points:</p>
</div>
<a class="admonition-anchor-link" href="monads/state_monad.html#admonition-key-points"></a>
</div>
<div>
<p>The State monad (<code>State&lt;S, A&gt;</code>, <code>StateKind</code>, <code>StateMonad</code>) , as provided by higher-kinded-j, offers an elegant and functional way to manage state transformations.</p>
<p>By defining atomic state operations and composing them with map and flatMap, you can build complex stateful workflows that are easier to reason about, test, and maintain, as the state is explicitly managed by the monad's structure rather than through mutable side effects. The For comprehension helps simplify the workflow.</p>
<p>Key operations like <code>get</code>, <code>set</code>, <code>modify</code>, and <code>inspect</code> provide convenient ways to interact with the state within the monadic context.</p>
</div>
</div>
<div id="admonition-further-reading" class="admonition admonish-tip" role="note" aria-labelledby="admonition-further-reading-title">
<div class="admonition-title">
<div id="admonition-further-reading-title">
<p>Further Reading</p>
</div>
<a class="admonition-anchor-link" href="monads/state_monad.html#admonition-further-reading"></a>
</div>
<div>
<p>For deeper exploration of the State monad and its applications:</p>
<p><strong>Foundational Resources:</strong></p>
<ul>
<li><strong>Philip Wadler</strong>: <a href="https://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf">Monads for functional programming</a> - Classic paper introducing monads including State</li>
<li><strong>Cats Documentation</strong>: <a href="https://typelevel.org/cats/datatypes/state.html">State Monad</a> - Scala implementation with comprehensive examples</li>
<li><strong>Haskell Wiki</strong>: <a href="https://wiki.haskell.org/State_Monad">State Monad</a> - Conceptual foundation and theory</li>
</ul>
<p><strong>Java-Focused Resources:</strong></p>
<ul>
<li><strong>Pierre-Yves Saumont</strong>: "Functional Programming in Java" (Manning, 2017) - Deep dive into functional techniques including state management</li>
<li><strong>Venkat Subramaniam</strong>: "Functional Programming in Java" (O'Reilly, 2014) - Practical guide to FP patterns in modern Java</li>
</ul>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="the-streammonad"><a class="header" href="#the-streammonad">The StreamMonad:</a></h1>
<h2 id="lazy-potentially-infinite-sequences-with-functional-operations"><a class="header" href="#lazy-potentially-infinite-sequences-with-functional-operations"><em>Lazy, Potentially Infinite Sequences with Functional Operations</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="monads/stream_monad.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to work with Streams as contexts for lazy, potentially infinite sequences</li>
<li>Understanding Stream's <strong>single-use semantics</strong> and how to work with them</li>
<li>Using <code>map</code>, <code>flatMap</code>, and <code>ap</code> for lazy functional composition</li>
<li>Leveraging StreamOps utilities for common stream operations</li>
<li>Building efficient data processing pipelines with monadic operations</li>
<li>When to choose Stream over List for sequential processing</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code:</p>
</div>
<a class="admonition-anchor-link" href="monads/stream_monad.html#admonition-see-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/StreamExample.java">StreamExample.java</a></p>
</div>
</div>
<h2 id="purpose-6"><a class="header" href="#purpose-6">Purpose</a></h2>
<p>The <code>StreamMonad</code> in the <code>Higher-Kinded-J</code> library provides a monadic interface for Java's standard <code>java.util.stream.Stream</code>. It allows developers to work with streams in a functional style, enabling operations like <code>map</code>, <code>flatMap</code>, and <code>ap</code> within the higher-kinded type system. This is particularly useful for processing sequences of data lazily, handling potentially infinite sequences, and composing stream operations in a type-safe manner.</p>
<p>Key benefits include:</p>
<ul>
<li><strong>Lazy Evaluation:</strong> Operations are not performed until a terminal operation is invoked, allowing for efficient processing of large or infinite sequences.</li>
<li><strong>HKT Integration:</strong> <code>StreamKind</code> (the higher-kinded wrapper for <code>Stream</code>) and <code>StreamMonad</code> allow <code>Stream</code> to be used with generic functions and type classes expecting <code>Kind&lt;F, A&gt;</code>, <code>Functor&lt;F&gt;</code>, <code>Applicative&lt;F&gt;</code>, or <code>Monad&lt;F&gt;</code>.</li>
<li><strong>MonadZero Instance:</strong> Provides an empty stream via <code>zero()</code>, useful for filtering and conditional logic.</li>
<li><strong>Functional Composition:</strong> Easily chain operations on streams where each operation maintains laziness and allows composition of complex data transformations.</li>
</ul>
<p>It implements <code>MonadZero&lt;StreamKind.Witness&gt;</code>, inheriting from <code>Monad</code>, <code>Applicative</code>, and <code>Functor</code>.</p>
<div id="admonition-important-single-use-semantics" class="admonition admonish-warning" role="note" aria-labelledby="admonition-important-single-use-semantics-title">
<div class="admonition-title">
<div id="admonition-important-single-use-semantics-title">
<p>Important: Single-Use Semantics</p>
</div>
<a class="admonition-anchor-link" href="monads/stream_monad.html#admonition-important-single-use-semantics"></a>
</div>
<div>
<p>Java Streams have <strong>single-use semantics</strong>. Once a terminal operation has been performed on a stream (including operations that narrow and inspect the stream), that stream cannot be reused. Attempting to operate on a consumed stream throws <code>IllegalStateException</code>.</p>
<p><strong>Best Practice:</strong> Create fresh stream instances for each operation sequence. Don't store and reuse <code>Kind&lt;StreamKind.Witness, A&gt;</code> instances after they've been consumed.</p>
</div>
</div>
<h2 id="structure-6"><a class="header" href="#structure-6">Structure</a></h2>
<p><img src="monads/../images/puml/stream_monad.svg" alt="stream_monad.svg" /></p>
<h2 id="how-to-use-streammonad-and-streamkind"><a class="header" href="#how-to-use-streammonad-and-streamkind">How to Use <code>StreamMonad</code> and <code>StreamKind</code></a></h2>
<h3 id="creating-instances-4"><a class="header" href="#creating-instances-4">Creating Instances</a></h3>
<p><code>StreamKind&lt;A&gt;</code> is the higher-kinded type representation for <code>java.util.stream.Stream&lt;A&gt;</code>. You create <code>StreamKind</code> instances using the <code>StreamKindHelper</code> utility class, the <code>of</code> method from <code>StreamMonad</code>, or the convenient factory methods in <code>StreamOps</code>.</p>
<div id="admonition-_streamwidenstream_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_streamwidenstream_-title">
<div class="admonition-title">
<div id="admonition-_streamwidenstream_-title">
<p><em>STREAM.widen(Stream<A>)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/stream_monad.html#admonition-_streamwidenstream_"></a>
</div>
<div>
<p>Converts a standard <code>java.util.stream.Stream&lt;A&gt;</code> into a <code>Kind&lt;StreamKind.Witness, A&gt;</code>.</p>
<pre><code class="language-java">Stream&lt;String&gt; stringStream = Stream.of("a", "b", "c");
Kind&lt;StreamKind.Witness, String&gt; streamKind1 = STREAM.widen(stringStream);

Stream&lt;Integer&gt; intStream = Stream.of(1, 2, 3);
Kind&lt;StreamKind.Witness, Integer&gt; streamKind2 = STREAM.widen(intStream);

Stream&lt;Object&gt; emptyStream = Stream.empty();
Kind&lt;StreamKind.Witness, Object&gt; streamKindEmpty = STREAM.widen(emptyStream);
</code></pre>
</div>
</div>
<div id="admonition-_streammonadofa-value_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_streammonadofa-value_-title">
<div class="admonition-title">
<div id="admonition-_streammonadofa-value_-title">
<p><em>streamMonad.of(A value)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/stream_monad.html#admonition-_streammonadofa-value_"></a>
</div>
<div>
<p>Lifts a single value into the <code>StreamKind</code> context, creating a singleton stream. A <code>null</code> input value results in an empty <code>StreamKind</code>.</p>
<pre><code class="language-java">StreamMonad streamMonad = StreamMonad.INSTANCE;

Kind&lt;StreamKind.Witness, String&gt; streamKindOneItem = streamMonad.of("hello"); // Contains a stream with one element: "hello"
Kind&lt;StreamKind.Witness, Integer&gt; streamKindAnotherItem = streamMonad.of(42);  // Contains a stream with one element: 42
Kind&lt;StreamKind.Witness, Object&gt; streamKindFromNull = streamMonad.of(null); // Contains an empty stream
</code></pre>
</div>
</div>
<div id="admonition-_streammonadzero_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_streammonadzero_-title">
<div class="admonition-title">
<div id="admonition-_streammonadzero_-title">
<p><em>streamMonad.zero()</em></p>
</div>
<a class="admonition-anchor-link" href="monads/stream_monad.html#admonition-_streammonadzero_"></a>
</div>
<div>
<p>Creates an empty <code>StreamKind</code>, useful for filtering operations or providing a "nothing" value in monadic computations.</p>
<pre><code class="language-java">StreamMonad streamMonad = StreamMonad.INSTANCE;

Kind&lt;StreamKind.Witness, String&gt; emptyStreamKind = streamMonad.zero(); // Empty stream
</code></pre>
</div>
</div>
<div id="admonition-_streamnarrow_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_streamnarrow_-title">
<div class="admonition-title">
<div id="admonition-_streamnarrow_-title">
<p><em>STREAM.narrow()</em></p>
</div>
<a class="admonition-anchor-link" href="monads/stream_monad.html#admonition-_streamnarrow_"></a>
</div>
<div>
<p>To get the underlying <code>java.util.stream.Stream&lt;A&gt;</code> from a <code>Kind&lt;StreamKind.Witness, A&gt;</code>, use <code>STREAM.narrow()</code>:</p>
<pre><code class="language-java">Kind&lt;StreamKind.Witness, String&gt; streamKind = STREAM.widen(Stream.of("example"));
Stream&lt;String&gt; unwrappedStream = STREAM.narrow(streamKind); // Returns Stream containing "example"

// You can then perform terminal operations on the unwrapped stream
List&lt;String&gt; result = unwrappedStream.collect(Collectors.toList());
System.out.println(result); // [example]
</code></pre>
</div>
</div>
<div id="admonition-_streamops-factory-methods_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_streamops-factory-methods_-title">
<div class="admonition-title">
<div id="admonition-_streamops-factory-methods_-title">
<p><em>StreamOps Factory Methods</em></p>
</div>
<a class="admonition-anchor-link" href="monads/stream_monad.html#admonition-_streamops-factory-methods_"></a>
</div>
<div>
<p>The <code>StreamOps</code> utility class provides convenient factory methods for creating <code>StreamKind</code> instances:</p>
<pre><code class="language-java">// Create from varargs
Kind&lt;StreamKind.Witness, Integer&gt; numbers = fromArray(1, 2, 3, 4, 5);

// Create a range (exclusive end)
Kind&lt;StreamKind.Witness, Integer&gt; range = range(1, 11); // 1 through 10

// Create from collection
List&lt;String&gt; names = Arrays.asList("Alice", "Bob", "Charlie");
Kind&lt;StreamKind.Witness, String&gt; nameStream = fromIterable(names);

// Create empty stream
Kind&lt;StreamKind.Witness, String&gt; empty = empty();
</code></pre>
</div>
</div>
<h3 id="key-operations-2"><a class="header" href="#key-operations-2">Key Operations</a></h3>
<p>The <code>StreamMonad</code> provides standard monadic operations, all maintaining lazy evaluation:</p>
<div id="admonition-_mapfunction-f-kind-fa_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_mapfunction-f-kind-fa_-title">
<div class="admonition-title">
<div id="admonition-_mapfunction-f-kind-fa_-title">
<p><em>map(Function&lt;A, B&gt; f, Kind&lt;StreamKind.Witness, A&gt; fa)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/stream_monad.html#admonition-_mapfunction-f-kind-fa_"></a>
</div>
<div>
<p><strong><code>map(Function&lt;A, B&gt; f, Kind&lt;StreamKind.Witness, A&gt; fa)</code>:</strong></p>
<p>Applies a function <code>f</code> to each element of the stream within <code>fa</code>, returning a new <code>StreamKind</code> containing the transformed elements. The transformation is <strong>lazy</strong> and won't execute until a terminal operation is performed.</p>
<pre><code class="language-java">StreamMonad streamMonad = StreamMonad.INSTANCE;
Kind&lt;StreamKind.Witness, Integer&gt; numbers = STREAM.widen(Stream.of(1, 2, 3));

Function&lt;Integer, String&gt; intToString = i -&gt; "Number: " + i;
Kind&lt;StreamKind.Witness, String&gt; strings = streamMonad.map(intToString, numbers);

// At this point, no transformation has occurred yet (lazy)
// Terminal operation triggers execution:
List&lt;String&gt; result = STREAM.narrow(strings).collect(Collectors.toList());
System.out.println(result);
// Output: [Number: 1, Number: 2, Number: 3]
</code></pre>
</div>
</div>
<div id="admonition-_flatmapfunction-f-kind-ma_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_flatmapfunction-f-kind-ma_-title">
<div class="admonition-title">
<div id="admonition-_flatmapfunction-f-kind-ma_-title">
<p><em>flatMap(Function&lt;A, Kind&lt;StreamKind.Witness, B&gt;&gt; f, Kind&lt;StreamKind.Witness, A&gt; ma)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/stream_monad.html#admonition-_flatmapfunction-f-kind-ma_"></a>
</div>
<div>
<p><strong><code>flatMap(Function&lt;A, Kind&lt;StreamKind.Witness, B&gt;&gt; f, Kind&lt;StreamKind.Witness, A&gt; ma)</code>:</strong></p>
<p>Applies a function <code>f</code> to each element of the stream within <code>ma</code>. The function <code>f</code> itself returns a <code>StreamKind&lt;B&gt;</code>. <code>flatMap</code> then flattens all these resulting streams into a single <code>StreamKind&lt;B&gt;</code>. Evaluation remains lazy.</p>
<pre><code class="language-java">StreamMonad streamMonad = StreamMonad.INSTANCE;
Kind&lt;StreamKind.Witness, Integer&gt; initialValues = STREAM.widen(Stream.of(1, 2, 3));

// Function that takes an integer and returns a stream of itself and itself + 10
Function&lt;Integer, Kind&lt;StreamKind.Witness, Integer&gt;&gt; replicateAndAddTen =
    i -&gt; STREAM.widen(Stream.of(i, i + 10));

Kind&lt;StreamKind.Witness, Integer&gt; flattenedStream = streamMonad.flatMap(replicateAndAddTen, initialValues);

// Lazy - evaluation happens at terminal operation
List&lt;Integer&gt; result = STREAM.narrow(flattenedStream).collect(Collectors.toList());
System.out.println(result);
// Output: [1, 11, 2, 12, 3, 13]

// Example with conditional logic
Function&lt;Integer, Kind&lt;StreamKind.Witness, String&gt;&gt; toWordsIfEven =
    i -&gt; (i % 2 == 0) ?
         STREAM.widen(Stream.of("even", String.valueOf(i))) :
         streamMonad.zero(); // Empty stream for odd numbers

Kind&lt;StreamKind.Witness, String&gt; wordStream = streamMonad.flatMap(toWordsIfEven, initialValues);
List&lt;String&gt; words = STREAM.narrow(wordStream).collect(Collectors.toList());
System.out.println(words);
// Output: [even, 2]
</code></pre>
</div>
</div>
<div id="admonition-_apkind-ff-kind-fa_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_apkind-ff-kind-fa_-title">
<div class="admonition-title">
<div id="admonition-_apkind-ff-kind-fa_-title">
<p><em>ap(Kind&lt;StreamKind.Witness, Function&lt;A, B&gt;&gt; ff, Kind&lt;StreamKind.Witness, A&gt; fa)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/stream_monad.html#admonition-_apkind-ff-kind-fa_"></a>
</div>
<div>
<p><strong><code>ap(Kind&lt;StreamKind.Witness, Function&lt;A, B&gt;&gt; ff, Kind&lt;StreamKind.Witness, A&gt; fa)</code>:</strong></p>
<p>Applies a stream of functions <code>ff</code> to a stream of values <code>fa</code>. This results in a new stream where each function from <code>ff</code> is applied to each value in <code>fa</code> (Cartesian product style). Evaluation remains lazy.</p>
<pre><code class="language-java">StreamMonad streamMonad = StreamMonad.INSTANCE;

Function&lt;Integer, String&gt; addPrefix = i -&gt; "Val: " + i;
Function&lt;Integer, String&gt; multiplyAndString = i -&gt; "Mul: " + (i * 2);

Kind&lt;StreamKind.Witness, Function&lt;Integer, String&gt;&gt; functions =
    STREAM.widen(Stream.of(addPrefix, multiplyAndString));
Kind&lt;StreamKind.Witness, Integer&gt; values = STREAM.widen(Stream.of(10, 20));

Kind&lt;StreamKind.Witness, String&gt; appliedResults = streamMonad.ap(functions, values);

// Lazy - collects when terminal operation is performed
List&lt;String&gt; result = STREAM.narrow(appliedResults).collect(Collectors.toList());
System.out.println(result);
// Output: [Val: 10, Val: 20, Mul: 20, Mul: 40]
</code></pre>
</div>
</div>
<h2 id="streamops-utility-documentation"><a class="header" href="#streamops-utility-documentation">StreamOps Utility Documentation</a></h2>
<p>The <code>StreamOps</code> class provides a rich set of static utility methods for working with <code>StreamKind</code> instances. These operations complement the monadic interface with practical stream manipulation functions.</p>
<h3 id="creation-operations"><a class="header" href="#creation-operations">Creation Operations</a></h3>
<div id="admonition-factory-methods" class="admonition admonish-note" role="note" aria-labelledby="admonition-factory-methods-title">
<div class="admonition-title">
<div id="admonition-factory-methods-title">
<p>Factory Methods</p>
</div>
<a class="admonition-anchor-link" href="monads/stream_monad.html#admonition-factory-methods"></a>
</div>
<div>
<pre><code class="language-java">// Create from varargs
Kind&lt;StreamKind.Witness, T&gt; fromArray(T... elements)

// Create from Iterable
Kind&lt;StreamKind.Witness, T&gt; fromIterable(Iterable&lt;T&gt; iterable)

// Create a range [start, end)
Kind&lt;StreamKind.Witness, Integer&gt; range(int start, int end)

// Create empty stream
Kind&lt;StreamKind.Witness, T&gt; empty()
</code></pre>
<p><strong>Examples:</strong></p>
<pre><code class="language-java">Kind&lt;StreamKind.Witness, String&gt; names = fromArray("Alice", "Bob", "Charlie");
Kind&lt;StreamKind.Witness, Integer&gt; numbers = range(1, 101); // 1 to 100
Kind&lt;StreamKind.Witness, String&gt; emptyStream = empty();
</code></pre>
</div>
</div>
<h3 id="filtering-and-selection"><a class="header" href="#filtering-and-selection">Filtering and Selection</a></h3>
<div id="admonition-filtering-operations" class="admonition admonish-note" role="note" aria-labelledby="admonition-filtering-operations-title">
<div class="admonition-title">
<div id="admonition-filtering-operations-title">
<p>Filtering Operations</p>
</div>
<a class="admonition-anchor-link" href="monads/stream_monad.html#admonition-filtering-operations"></a>
</div>
<div>
<pre><code class="language-java">// Keep only elements matching predicate
Kind&lt;StreamKind.Witness, A&gt; filter(Predicate&lt;A&gt; predicate, Kind&lt;StreamKind.Witness, A&gt; stream)

// Take first n elements
Kind&lt;StreamKind.Witness, A&gt; take(long n, Kind&lt;StreamKind.Witness, A&gt; stream)

// Skip first n elements
Kind&lt;StreamKind.Witness, A&gt; drop(long n, Kind&lt;StreamKind.Witness, A&gt; stream)
</code></pre>
<p><strong>Examples:</strong></p>
<pre><code class="language-java">Kind&lt;StreamKind.Witness, Integer&gt; numbers = range(1, 101);

// Get only even numbers
Kind&lt;StreamKind.Witness, Integer&gt; evens = filter(n -&gt; n % 2 == 0, numbers);

// Get first 10 elements
Kind&lt;StreamKind.Witness, Integer&gt; first10 = take(10, range(1, 1000));

// Skip first 5 elements
Kind&lt;StreamKind.Witness, Integer&gt; afterFirst5 = drop(5, range(1, 20));
</code></pre>
</div>
</div>
<h3 id="combination-operations"><a class="header" href="#combination-operations">Combination Operations</a></h3>
<div id="admonition-combining-streams" class="admonition admonish-note" role="note" aria-labelledby="admonition-combining-streams-title">
<div class="admonition-title">
<div id="admonition-combining-streams-title">
<p>Combining Streams</p>
</div>
<a class="admonition-anchor-link" href="monads/stream_monad.html#admonition-combining-streams"></a>
</div>
<div>
<pre><code class="language-java">// Concatenate two streams sequentially
Kind&lt;StreamKind.Witness, A&gt; concat(Kind&lt;StreamKind.Witness, A&gt; stream1, Kind&lt;StreamKind.Witness, A&gt; stream2)

// Zip two streams element-wise with combiner function
Kind&lt;StreamKind.Witness, C&gt; zip(Kind&lt;StreamKind.Witness, A&gt; stream1, Kind&lt;StreamKind.Witness, B&gt; stream2, BiFunction&lt;A, B, C&gt; combiner)

// Pair each element with its index (starting from 0)
Kind&lt;StreamKind.Witness, Tuple2&lt;Integer, A&gt;&gt; zipWithIndex(Kind&lt;StreamKind.Witness, A&gt; stream)
</code></pre>
<p><strong>Examples:</strong></p>
<pre><code class="language-java">Kind&lt;StreamKind.Witness, Integer&gt; first = range(1, 4);   // 1, 2, 3
Kind&lt;StreamKind.Witness, Integer&gt; second = range(10, 13); // 10, 11, 12

// Sequential concatenation
Kind&lt;StreamKind.Witness, Integer&gt; combined = concat(first, second);
// Result: 1, 2, 3, 10, 11, 12

// Element-wise combination
Kind&lt;StreamKind.Witness, String&gt; names = fromArray("Alice", "Bob", "Charlie");
Kind&lt;StreamKind.Witness, Integer&gt; ages = fromArray(25, 30, 35);
Kind&lt;StreamKind.Witness, String&gt; profiles = zip(names, ages,
    (name, age) -&gt; name + " is " + age);
// Result: "Alice is 25", "Bob is 30", "Charlie is 35"

// Index pairing
Kind&lt;StreamKind.Witness, String&gt; items = fromArray("apple", "banana", "cherry");
Kind&lt;StreamKind.Witness, Tuple2&lt;Integer, String&gt;&gt; indexed = zipWithIndex(items);
// Result: (0, "apple"), (1, "banana"), (2, "cherry")
</code></pre>
</div>
</div>
<h3 id="terminal-operations"><a class="header" href="#terminal-operations">Terminal Operations</a></h3>
<div id="admonition-consuming-streams" class="admonition admonish-note" role="note" aria-labelledby="admonition-consuming-streams-title">
<div class="admonition-title">
<div id="admonition-consuming-streams-title">
<p>Consuming Streams</p>
</div>
<a class="admonition-anchor-link" href="monads/stream_monad.html#admonition-consuming-streams"></a>
</div>
<div>
<pre><code class="language-java">// Collect to List
List&lt;A&gt; toList(Kind&lt;StreamKind.Witness, A&gt; stream)

// Collect to Set
Set&lt;A&gt; toSet(Kind&lt;StreamKind.Witness, A&gt; stream)

// Execute side effect for each element
void forEach(Consumer&lt;A&gt; action, Kind&lt;StreamKind.Witness, A&gt; stream)
</code></pre>
<p><strong>Examples:</strong></p>
<pre><code class="language-java">Kind&lt;StreamKind.Witness, Integer&gt; numbers = range(1, 6);

// Collect to List
List&lt;Integer&gt; numberList = toList(numbers); // [1, 2, 3, 4, 5]

// Collect to Set (removes duplicates)
Kind&lt;StreamKind.Witness, String&gt; words = fromArray("a", "b", "a", "c");
Set&lt;String&gt; uniqueWords = toSet(words); // {"a", "b", "c"}

// Execute side effects
Kind&lt;StreamKind.Witness, String&gt; messages = fromArray("Hello", "World");
forEach(System.out::println, messages);
// Prints:
// Hello
// World
</code></pre>
</div>
</div>
<h3 id="side-effects-and-debugging"><a class="header" href="#side-effects-and-debugging">Side Effects and Debugging</a></h3>
<div id="admonition-observation-operations" class="admonition admonish-note" role="note" aria-labelledby="admonition-observation-operations-title">
<div class="admonition-title">
<div id="admonition-observation-operations-title">
<p>Observation Operations</p>
</div>
<a class="admonition-anchor-link" href="monads/stream_monad.html#admonition-observation-operations"></a>
</div>
<div>
<pre><code class="language-java">// Execute side effect for each element while passing through
Kind&lt;StreamKind.Witness, A&gt; tap(Consumer&lt;A&gt; action, Kind&lt;StreamKind.Witness, A&gt; stream)
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-java">List&lt;String&gt; log = new ArrayList&lt;&gt;();

Kind&lt;StreamKind.Witness, Integer&gt; pipeline = tap(
    n -&gt; log.add("Processing: " + n),
    StreamMonad.INSTANCE.map(n -&gt; n * 2, range(1, 4))
);

// Side effects haven't executed yet (lazy)
System.out.println("Log size: " + log.size()); // 0

// Terminal operation triggers execution
List&lt;Integer&gt; result = toList(pipeline);
System.out.println("Log size: " + log.size()); // 3
System.out.println("Log: " + log); // [Processing: 2, Processing: 4, Processing: 6]
System.out.println("Result: " + result); // [2, 4, 6]
</code></pre>
</div>
</div>
<h2 id="important-constraints-single-use-semantics"><a class="header" href="#important-constraints-single-use-semantics">Important Constraints: Single-Use Semantics</a></h2>
<div id="admonition-critical-stream-single-use-limitation" class="admonition admonish-danger" role="note" aria-labelledby="admonition-critical-stream-single-use-limitation-title">
<div class="admonition-title">
<div id="admonition-critical-stream-single-use-limitation-title">
<p>Critical: Stream Single-Use Limitation</p>
</div>
<a class="admonition-anchor-link" href="monads/stream_monad.html#admonition-critical-stream-single-use-limitation"></a>
</div>
<div>
<p>Unlike <code>List</code> or <code>Optional</code>, Java Streams can only be consumed <strong>once</strong>. This is a fundamental characteristic of <code>java.util.stream.Stream</code> that is preserved in the HKT representation.</p>
<p><strong>What This Means:</strong></p>
<ul>
<li>Once you perform a terminal operation on a stream (including <code>narrow()</code> followed by collection), that stream is consumed</li>
<li>Attempting to reuse a consumed stream throws <code>IllegalStateException</code></li>
<li>Each <code>Kind&lt;StreamKind.Witness, A&gt;</code> instance can only flow through one pipeline to completion</li>
</ul>
<p><strong>Correct Approach:</strong></p>
<pre><code class="language-java">// Create fresh stream for each independent operation
Kind&lt;StreamKind.Witness, Integer&gt; stream1 = range(1, 4);
List&lt;Integer&gt; result1 = toList(stream1); // ‚úì First use

Kind&lt;StreamKind.Witness, Integer&gt; stream2 = range(1, 4); // Create new stream
List&lt;Integer&gt; result2 = toList(stream2); // ‚úì Second use with fresh stream
</code></pre>
<p><strong>Incorrect Approach:</strong></p>
<pre><code class="language-java">// DON'T DO THIS - Will throw IllegalStateException
Kind&lt;StreamKind.Witness, Integer&gt; stream = range(1, 4);
List&lt;Integer&gt; result1 = toList(stream);  // ‚úì First use
List&lt;Integer&gt; result2 = toList(stream);  // ‚úó ERROR: stream already consumed!
</code></pre>
<p><strong>Design Implications:</strong></p>
<ul>
<li>Don't store <code>StreamKind</code> instances in fields for reuse</li>
<li>Create streams on-demand when needed</li>
<li>Use factory methods or suppliers to generate fresh streams</li>
<li>Consider using <code>List</code> if you need to process data multiple times</li>
</ul>
</div>
</div>
<h2 id="practical-example-complete-usage"><a class="header" href="#practical-example-complete-usage">Practical Example: Complete Usage</a></h2>
<div id="admonition-comprehensive-stream-example" class="admonition admonish-example" role="note" aria-labelledby="admonition-comprehensive-stream-example-title">
<div class="admonition-title">
<div id="admonition-comprehensive-stream-example-title">
<p>Comprehensive Stream Example</p>
</div>
<a class="admonition-anchor-link" href="monads/stream_monad.html#admonition-comprehensive-stream-example"></a>
</div>
<div>
<p>Here's a complete example demonstrating various Stream operations:</p>
<pre><code class="language-java">import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.stream.StreamKind;
import org.higherkindedj.hkt.stream.StreamMonad;
import static org.higherkindedj.hkt.stream.StreamKindHelper.STREAM;
import static org.higherkindedj.hkt.stream.StreamOps.*;

import java.util.List;
import java.util.function.Function;

public class StreamUsageExample {
   public static void main(String[] args) {
      StreamMonad streamMonad = StreamMonad.INSTANCE;

      // 1. Create a StreamKind using range
      Kind&lt;StreamKind.Witness, Integer&gt; numbersKind = range(1, 11); // 1 through 10

      // 2. Use map to transform (lazy)
      Function&lt;Integer, String&gt; numberToString = n -&gt; "Item-" + n;
      Kind&lt;StreamKind.Witness, String&gt; stringsKind = streamMonad.map(numberToString, numbersKind);

      System.out.println("Mapped: " + toList(stringsKind));
      // Expected: [Item-1, Item-2, Item-3, ..., Item-10]

      // 3. Create fresh stream for flatMap example
      Kind&lt;StreamKind.Witness, Integer&gt; numbersKind2 = range(1, 6);

      // flatMap: duplicate even numbers, skip odd numbers
      Function&lt;Integer, Kind&lt;StreamKind.Witness, Integer&gt;&gt; duplicateIfEven = n -&gt; {
         if (n % 2 == 0) {
            return fromArray(n, n); // Duplicate even numbers
         } else {
            return streamMonad.zero(); // Skip odd numbers
         }
      };

      Kind&lt;StreamKind.Witness, Integer&gt; flatMappedKind = streamMonad.flatMap(duplicateIfEven, numbersKind2);
      System.out.println("FlatMapped: " + toList(flatMappedKind));
      // Expected: [2, 2, 4, 4]

      // 4. Use of to create singleton
      Kind&lt;StreamKind.Witness, String&gt; singleValueKind = streamMonad.of("hello world");
      System.out.println("From 'of': " + toList(singleValueKind));
      // Expected: [hello world]

      // 5. Use zero to create empty stream
      Kind&lt;StreamKind.Witness, String&gt; emptyKind = streamMonad.zero();
      System.out.println("From 'zero': " + toList(emptyKind));
      // Expected: []

      // 6. StreamOps: filter and take
      Kind&lt;StreamKind.Witness, Integer&gt; largeRange = range(1, 101);
      Kind&lt;StreamKind.Witness, Integer&gt; evensFirst10 = take(10, filter(n -&gt; n % 2 == 0, largeRange));
      System.out.println("First 10 evens: " + toList(evensFirst10));
      // Expected: [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]

      // 7. Zip two streams
      Kind&lt;StreamKind.Witness, String&gt; names = fromArray("Alice", "Bob", "Charlie");
      Kind&lt;StreamKind.Witness, Integer&gt; scores = fromArray(95, 87, 92);
      Kind&lt;StreamKind.Witness, String&gt; results = zip(names, scores,
          (name, score) -&gt; name + ": " + score);

      System.out.println("Results: " + toList(results));
      // Expected: [Alice: 95, Bob: 87, Charlie: 92]

      // 8. Demonstrating single-use constraint
      Kind&lt;StreamKind.Witness, Integer&gt; streamOnce = range(1, 4);
      List&lt;Integer&gt; firstUse = toList(streamOnce);
      System.out.println("First use: " + firstUse);
      // Expected: [1, 2, 3]

      // Must create new stream for second use
      Kind&lt;StreamKind.Witness, Integer&gt; streamTwice = range(1, 4);
      List&lt;Integer&gt; secondUse = toList(streamTwice);
      System.out.println("Second use (new stream): " + secondUse);
      // Expected: [1, 2, 3]
   }
}
</code></pre>
</div>
</div>
<h2 id="when-to-use-streammonad"><a class="header" href="#when-to-use-streammonad">When to Use StreamMonad</a></h2>
<p><strong>Choose <code>StreamMonad</code> when:</strong></p>
<ul>
<li>Processing large datasets where lazy evaluation provides memory efficiency</li>
<li>Working with potentially infinite sequences</li>
<li>Building complex data transformation pipelines</li>
<li>You need intermediate laziness and only want to materialise results at the end</li>
<li>Single-pass processing is sufficient for your use case</li>
</ul>
<p><strong>Choose <code>ListMonad</code> instead when:</strong></p>
<ul>
<li>You need to process the same data multiple times</li>
<li>Random access to elements is required</li>
<li>The entire dataset fits comfortably in memory</li>
<li>You need to store the result for later reuse</li>
</ul>
<p><strong>Key Difference:</strong> <code>List</code> is eager and reusable; <code>Stream</code> is lazy and single-use.</p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="the-trampoline-monad"><a class="header" href="#the-trampoline-monad">The Trampoline Monad:</a></h1>
<h2 id="stack-safe-recursion-in-java"><a class="header" href="#stack-safe-recursion-in-java"><em>Stack-Safe Recursion in Java</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="monads/trampoline_monad.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to convert deeply recursive algorithms to stack-safe iterative ones</li>
<li>Implementing mutually recursive functions without stack overflow</li>
<li>Using <code>Trampoline.done</code> and <code>Trampoline.defer</code> to build trampolined computations</li>
<li>Composing recursive operations using <code>map</code> and <code>flatMap</code></li>
<li>When to use Trampoline vs. traditional recursion</li>
<li>Leveraging <code>TrampolineUtils</code> for stack-safe applicative operations</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code:</p>
</div>
<a class="admonition-anchor-link" href="monads/trampoline_monad.html#admonition-see-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/trampoline/TrampolineExample.java">TrampolineExample.java</a></p>
</div>
</div>
<div id="admonition-further-reading" class="admonition admonish-tip" role="note" aria-labelledby="admonition-further-reading-title">
<div class="admonition-title">
<div id="admonition-further-reading-title">
<p>Further Reading</p>
</div>
<a class="admonition-anchor-link" href="monads/trampoline_monad.html#admonition-further-reading"></a>
</div>
<div>
<p>For a comprehensive exploration of recursion, thunks, and trampolines in Java and Scala, see Scott Logic's blog post: <a href="https://blog.scottlogic.com/2025/05/02/recursion-thunks-trampolines-with-java-and-scala.html">Recursion, Thunks and Trampolines with Java and Scala</a>.</p>
</div>
</div>
<p>In functional programming, recursion is a natural way to express iterative algorithms. However, the JVM's call stack has a limited depth, and deeply recursive computations can cause <code>StackOverflowError</code>. The JVM lacks tail-call optimisation, which means even tail-recursive functions will consume stack space.</p>
<p>The <code>Trampoline&lt;A&gt;</code> type in <code>higher-kinded-j</code> solves this problem by converting recursive calls into data structures that are evaluated iteratively. Instead of making recursive calls directly (which grow the call stack), you return a <code>Trampoline</code> value that describes the next step of the computation. The <code>run()</code> method then processes these steps in a loop, using constant stack space regardless of recursion depth.</p>
<h2 id="core-components-2"><a class="header" href="#core-components-2">Core Components</a></h2>
<p><strong>The Trampoline Structure</strong></p>
<p><img src="monads/../images/puml/trampoline_structure.svg" alt="trampoline_structure.svg" /></p>
<p><strong>The HKT Bridge for Trampoline</strong></p>
<p><img src="monads/../images/puml/trampoline_kind.svg" alt="trampoline_kind.svg" /></p>
<p><strong>Typeclasses for Trampoline</strong></p>
<p><img src="monads/../images/puml/trampoline_monad.svg" alt="trampoline_monad.svg" /></p>
<p>The <code>Trampoline</code> functionality is built upon several related components:</p>
<ol>
<li>
<p><strong><code>Trampoline&lt;A&gt;</code></strong>: The core sealed interface representing a stack-safe computation. It has three constructors:</p>
<ul>
<li><code>Done&lt;A&gt;</code>: Represents a completed computation holding a final value.</li>
<li><code>More&lt;A&gt;</code>: Represents a suspended computation (deferred thunk) that will be evaluated later.</li>
<li><code>FlatMap&lt;A, B&gt;</code>: Represents a sequenced computation resulting from monadic bind operations.</li>
</ul>
</li>
<li>
<p><strong><code>TrampolineKind&lt;A&gt;</code></strong>: The HKT marker interface (<code>Kind&lt;TrampolineKind.Witness, A&gt;</code>) for <code>Trampoline</code>. This allows <code>Trampoline</code> to be treated as a generic type constructor <code>F</code> in type classes like <code>Functor</code> and <code>Monad</code>. The witness type is <code>TrampolineKind.Witness</code>.</p>
</li>
<li>
<p><strong><code>TrampolineKindHelper</code></strong>: The essential utility class for working with <code>Trampoline</code> in the HKT simulation. It provides:</p>
<ul>
<li><code>widen(Trampoline&lt;A&gt;)</code>: Wraps a concrete <code>Trampoline&lt;A&gt;</code> instance into its HKT representation <code>TrampolineKind&lt;A&gt;</code>.</li>
<li><code>narrow(Kind&lt;TrampolineKind.Witness, A&gt;)</code>: Unwraps a <code>TrampolineKind&lt;A&gt;</code> back to the concrete <code>Trampoline&lt;A&gt;</code>. Throws <code>KindUnwrapException</code> if the input Kind is invalid.</li>
<li><code>done(A value)</code>: Creates a <code>TrampolineKind&lt;A&gt;</code> representing a completed computation.</li>
<li><code>defer(Supplier&lt;Trampoline&lt;A&gt;&gt; next)</code>: Creates a <code>TrampolineKind&lt;A&gt;</code> representing a deferred computation.</li>
<li><code>run(Kind&lt;TrampolineKind.Witness, A&gt;)</code>: Executes the trampoline and returns the final result.</li>
</ul>
</li>
<li>
<p><strong><code>TrampolineFunctor</code></strong>: Implements <code>Functor&lt;TrampolineKind.Witness&gt;</code>. Provides the <code>map</code> operation to transform the result value of a trampoline computation.</p>
</li>
<li>
<p><strong><code>TrampolineMonad</code></strong>: Extends <code>TrampolineFunctor</code> and implements <code>Monad&lt;TrampolineKind.Witness&gt;</code>. Provides <code>of</code> (to lift a pure value into <code>Trampoline</code>) and <code>flatMap</code> (to sequence trampoline computations).</p>
</li>
<li>
<p><strong><code>TrampolineUtils</code></strong>: Utility class providing guaranteed stack-safe applicative operations:</p>
<ul>
<li><code>traverseListStackSafe</code>: Stack-safe list traversal for any applicative.</li>
<li><code>map2StackSafe</code>: Stack-safe map2 for chaining many operations.</li>
<li><code>sequenceStackSafe</code>: Stack-safe sequence operation.</li>
</ul>
</li>
</ol>
<h2 id="purpose-and-usage-3"><a class="header" href="#purpose-and-usage-3">Purpose and Usage</a></h2>
<ul>
<li><strong>Stack Safety</strong>: Converts recursive calls into data structures processed iteratively, preventing <code>StackOverflowError</code> on deep recursion (verified with 100,000+ iterations).</li>
<li><strong>Tail Call Optimisation</strong>: Effectively provides tail-call optimisation for Java, which lacks native support for it.</li>
<li><strong>Lazy Evaluation</strong>: Computations are not executed until <code>run()</code> is explicitly called.</li>
<li><strong>Composability</strong>: Trampolined computations can be chained using <code>map</code> and <code>flatMap</code>.</li>
</ul>
<p><strong>Key Methods:</strong></p>
<ul>
<li><code>Trampoline.done(value)</code>: Creates a completed computation with a final value.</li>
<li><code>Trampoline.defer(supplier)</code>: Defers a computation by wrapping it in a supplier.</li>
<li><code>trampoline.run()</code>: Executes the trampoline iteratively and returns the final result.</li>
<li><code>trampoline.map(f)</code>: Transforms the result without executing the trampoline.</li>
<li><code>trampoline.flatMap(f)</code>: Sequences trampolines whilst maintaining stack safety.</li>
</ul>
<div id="admonition-example-1-stack-safe-factorial" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-1-stack-safe-factorial-title">
<div class="admonition-title">
<div id="admonition-example-1-stack-safe-factorial-title">
<p>Example 1: Stack-Safe Factorial</p>
</div>
<a class="admonition-anchor-link" href="monads/trampoline_monad.html#admonition-example-1-stack-safe-factorial"></a>
</div>
<div>
<p>The classic factorial function is a simple example of recursion. For large numbers, naive recursion will cause stack overflow:</p>
<pre><code class="language-java">import org.higherkindedj.hkt.trampoline.Trampoline;
import java.math.BigInteger;

public class FactorialExample {
    // Naive recursive factorial - WILL OVERFLOW for large n
    static BigInteger factorialNaive(BigInteger n) {
        if (n.compareTo(BigInteger.ZERO) &lt;= 0) {
            return BigInteger.ONE;
        }
        return n.multiply(factorialNaive(n.subtract(BigInteger.ONE)));
    }

    // Stack-safe trampolined factorial - safe for very large n
    static Trampoline&lt;BigInteger&gt; factorial(BigInteger n, BigInteger acc) {
        if (n.compareTo(BigInteger.ZERO) &lt;= 0) {
            return Trampoline.done(acc);
        }
        // Instead of recursive call, return a deferred computation
        return Trampoline.defer(() -&gt;
            factorial(n.subtract(BigInteger.ONE), n.multiply(acc))
        );
    }

    public static void main(String[] args) {
        // This would overflow: factorialNaive(BigInteger.valueOf(10000));

        // This is stack-safe
        BigInteger result = factorial(
            BigInteger.valueOf(10000),
            BigInteger.ONE
        ).run();

        System.out.println("Factorial computed safely!");
        System.out.println("Result has " + result.toString().length() + " digits");
    }
}
</code></pre>
</div>
</div>
<p><strong>Key Insight:</strong> Instead of making a direct recursive call (which pushes a new frame onto the call stack), we return <code>Trampoline.defer(() -&gt; ...)</code> which creates a data structure. The <code>run()</code> method then evaluates these structures iteratively.</p>
<div id="admonition-example-2-mutual-recursion---isevenisodd" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-2-mutual-recursion---isevenisodd-title">
<div class="admonition-title">
<div id="admonition-example-2-mutual-recursion---isevenisodd-title">
<p>Example 2: Mutual Recursion - isEven/isOdd</p>
</div>
<a class="admonition-anchor-link" href="monads/trampoline_monad.html#admonition-example-2-mutual-recursion---isevenisodd"></a>
</div>
<div>
<p>Mutually recursive functions are another classic case where stack overflow occurs easily:</p>
<pre><code class="language-java">import org.higherkindedj.hkt.trampoline.Trampoline;

public class MutualRecursionExample {
    // Naive mutual recursion - WILL OVERFLOW for large n
    static boolean isEvenNaive(int n) {
        if (n == 0) return true;
        return isOddNaive(n - 1);
    }

    static boolean isOddNaive(int n) {
        if (n == 0) return false;
        return isEvenNaive(n - 1);
    }

    // Stack-safe trampolined versions
    static Trampoline&lt;Boolean&gt; isEven(int n) {
        if (n == 0) return Trampoline.done(true);
        return Trampoline.defer(() -&gt; isOdd(n - 1));
    }

    static Trampoline&lt;Boolean&gt; isOdd(int n) {
        if (n == 0) return Trampoline.done(false);
        return Trampoline.defer(() -&gt; isEven(n - 1));
    }

    public static void main(String[] args) {
        // This would overflow: isEvenNaive(1000000);

        // This is stack-safe
        boolean result = isEven(1000000).run();
        System.out.println("1000000 is even: " + result); // true

        boolean result2 = isOdd(999999).run();
        System.out.println("999999 is odd: " + result2); // true
    }
}
</code></pre>
</div>
</div>
<div id="admonition-example-3-fibonacci-with-trampoline" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-3-fibonacci-with-trampoline-title">
<div class="admonition-title">
<div id="admonition-example-3-fibonacci-with-trampoline-title">
<p>Example 3: Fibonacci with Trampoline</p>
</div>
<a class="admonition-anchor-link" href="monads/trampoline_monad.html#admonition-example-3-fibonacci-with-trampoline"></a>
</div>
<div>
<p>Computing Fibonacci numbers recursively is inefficient and stack-unsafe. With trampolining, we achieve stack safety (though we'd still want memoisation for efficiency):</p>
<pre><code class="language-java">import org.higherkindedj.hkt.trampoline.Trampoline;
import java.math.BigInteger;

public class FibonacciExample {
    // Stack-safe Fibonacci using tail recursion with accumulator
    static Trampoline&lt;BigInteger&gt; fibonacci(int n, BigInteger a, BigInteger b) {
        if (n == 0) return Trampoline.done(a);
        if (n == 1) return Trampoline.done(b);

        return Trampoline.defer(() -&gt;
            fibonacci(n - 1, b, a.add(b))
        );
    }

    public static void main(String[] args) {
        // Compute the 10,000th Fibonacci number - stack-safe!
        BigInteger fib10000 = fibonacci(
            10000,
            BigInteger.ZERO,
            BigInteger.ONE
        ).run();

        System.out.println("Fibonacci(10000) has " +
            fib10000.toString().length() + " digits");
    }
}
</code></pre>
</div>
</div>
<div id="admonition-example-4-using-map-and-flatmap" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-4-using-map-and-flatmap-title">
<div class="admonition-title">
<div id="admonition-example-4-using-map-and-flatmap-title">
<p>Example 4: Using map and flatMap</p>
</div>
<a class="admonition-anchor-link" href="monads/trampoline_monad.html#admonition-example-4-using-map-and-flatmap"></a>
</div>
<div>
<p>Trampoline is a monad, so you can compose computations using <code>map</code> and <code>flatMap</code>:</p>
<pre><code class="language-java">import org.higherkindedj.hkt.trampoline.Trampoline;

public class TrampolineCompositionExample {
    static Trampoline&lt;Integer&gt; countDown(int n) {
        if (n &lt;= 0) return Trampoline.done(0);
        return Trampoline.defer(() -&gt; countDown(n - 1));
    }

    public static void main(String[] args) {
        // Use map to transform the result
        Trampoline&lt;String&gt; countWithMessage = countDown(100000)
            .map(result -&gt; "Countdown complete! Final: " + result);

        System.out.println(countWithMessage.run());

        // Use flatMap to sequence trampolines
        Trampoline&lt;Integer&gt; sequenced = countDown(50000)
            .flatMap(first -&gt; countDown(50000)
                .map(second -&gt; first + second));

        System.out.println("Sequenced result: " + sequenced.run());
    }
}
</code></pre>
</div>
</div>
<div id="admonition-example-5-integration-with-trampolineutils" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-5-integration-with-trampolineutils-title">
<div class="admonition-title">
<div id="admonition-example-5-integration-with-trampolineutils-title">
<p>Example 5: Integration with TrampolineUtils</p>
</div>
<a class="admonition-anchor-link" href="monads/trampoline_monad.html#admonition-example-5-integration-with-trampolineutils"></a>
</div>
<div>
<p>When traversing large collections with custom applicatives, use <code>TrampolineUtils</code> for guaranteed stack safety:</p>
<pre><code class="language-java">import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.trampoline.TrampolineUtils;
import org.higherkindedj.hkt.id.*;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class TrampolineUtilsExample {
    public static void main(String[] args) {
        // Create a large list
        List&lt;Integer&gt; largeList = IntStream.range(0, 100000)
            .boxed()
            .collect(Collectors.toList());

        // Traverse it safely
        Kind&lt;IdKind.Witness, List&lt;String&gt;&gt; result =
            TrampolineUtils.traverseListStackSafe(
                largeList,
                i -&gt; Id.of("item-" + i),
                IdMonad.instance()
            );

        List&lt;String&gt; unwrapped = IdKindHelper.ID.narrow(result).value();
        System.out.println("Traversed " + unwrapped.size() + " elements safely");
    }
}
</code></pre>
<p>See <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/trampoline/TrampolineUtils.java"><code>TrampolineUtils</code> documentation</a> for more details on stack-safe applicative operations.</p>
</div>
</div>
<h2 id="when-to-use-trampoline"><a class="header" href="#when-to-use-trampoline">When to Use Trampoline</a></h2>
<p><strong>Use Trampoline when:</strong></p>
<ol>
<li><strong>Deep Recursion</strong>: Processing data structures or algorithms that recurse deeply (&gt;1,000 levels).</li>
<li><strong>Tail Recursion</strong>: Converting tail-recursive algorithms that would otherwise overflow.</li>
<li><strong>Mutual Recursion</strong>: Implementing mutually recursive functions.</li>
<li><strong>Stack Safety Guarantee</strong>: When you absolutely must prevent <code>StackOverflowError</code>.</li>
<li><strong>Large Collections</strong>: When using <code>TrampolineUtils</code> to traverse large collections (&gt;10,000 elements) with custom applicatives.</li>
</ol>
<p><strong>Avoid Trampoline when:</strong></p>
<ol>
<li><strong>Shallow Recursion</strong>: For recursion depth &lt;1,000, the overhead isn't justified.</li>
<li><strong>Performance Critical</strong>: Trampoline adds overhead compared to direct recursion or iteration.</li>
<li><strong>Simple Iteration</strong>: If you can write a simple loop, that's usually clearer and faster.</li>
<li><strong>Standard Collections</strong>: For standard applicatives (Id, Optional, Either, etc.) on moderate-sized lists (&lt;10,000 elements), regular traverse is sufficient.</li>
</ol>
<h2 id="performance-characteristics"><a class="header" href="#performance-characteristics">Performance Characteristics</a></h2>
<ul>
<li><strong>Stack Space</strong>: O(1) - constant stack space regardless of recursion depth</li>
<li><strong>Heap Space</strong>: O(n) - creates data structures for deferred computations</li>
<li><strong>Time Overhead</strong>: Small constant overhead per recursive step compared to direct recursion</li>
<li><strong>Throughput</strong>: Slower than native tail-call optimisation (if it existed in Java) but faster than stack overflow recovery</li>
</ul>
<p><strong>Benchmarks</strong>: The implementation has been verified to handle:</p>
<ul>
<li>100,000+ iterations in factorial computations</li>
<li>1,000,000+ iterations in mutual recursion (isEven/isOdd)</li>
<li>100,000+ element list traversals (via <code>TrampolineUtils</code>)</li>
</ul>
<h2 id="implementation-notes"><a class="header" href="#implementation-notes">Implementation Notes</a></h2>
<p>The <code>run()</code> method uses an iterative algorithm with an explicit continuation stack (implemented with <code>ArrayDeque</code>) to process the trampoline structure. This algorithm:</p>
<ol>
<li>Starts with the current trampoline</li>
<li>If it's <code>More</code>, unwraps it and continues</li>
<li>If it's <code>FlatMap</code>, pushes the function onto the stack and processes the sub-computation</li>
<li>If it's <code>Done</code>, applies any pending continuations from the stack</li>
<li>Repeats until there are no more continuations and we have a final <code>Done</code> value</li>
</ol>
<p>This design ensures that regardless of how deeply nested the recursive calls were in the original algorithm, the execution happens in constant stack space.</p>
<h2 id="type-safety-considerations"><a class="header" href="#type-safety-considerations">Type Safety Considerations</a></h2>
<p>The implementation uses a <code>Continuation</code> wrapper to safely handle heterogeneous types on the continuation stack. This design confines the necessary unsafe cast to a single, controlled location in the code, making the type erasure explicit, documented, and verified to be safe.</p>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>The <code>Trampoline</code> monad provides a practical solution to Java's lack of tail-call optimisation. By converting recursive algorithms into trampolined form, you can:</p>
<ul>
<li>Write naturally recursive code that's guaranteed stack-safe</li>
<li>Compose recursive computations functionally using <code>map</code> and <code>flatMap</code></li>
<li>Leverage <code>TrampolineUtils</code> for stack-safe applicative operations on large collections</li>
<li>Maintain clarity and correctness whilst preventing <code>StackOverflowError</code></li>
</ul>
<p>For detailed implementation examples and more advanced use cases, see the <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/trampoline/TrampolineExample.java">TrampolineExample.java</a> in the examples module.</p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="the-free-monad"><a class="header" href="#the-free-monad">The Free Monad:</a></h1>
<h2 id="building-composable-dsls-and-interpreters"><a class="header" href="#building-composable-dsls-and-interpreters"><em>Building Composable DSLs and Interpreters</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="monads/free_monad.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to build domain-specific languages (DSLs) as data structures</li>
<li>Separating program description from execution</li>
<li>Creating multiple interpreters for the same program</li>
<li>Using <code>pure</code>, <code>suspend</code>, and <code>liftF</code> to construct Free programs</li>
<li>Implementing stack-safe interpreters with <code>foldMap</code></li>
<li>When Free monads solve real architectural problems</li>
<li>Comparing Free monads with traditional Java patterns</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code:</p>
</div>
<a class="admonition-anchor-link" href="monads/free_monad.html#admonition-see-example-code"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/free/ConsoleProgram.java">ConsoleProgram.java</a></li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/test/java/org/higherkindedj/hkt/free/FreeMonadTest.java">FreeMonadTest.java</a></li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/test/java/org/higherkindedj/hkt/free/FreeFactoryTest.java">FreeFactoryTest.java</a> - Demonstrates improved type inference with FreeFactory</li>
</ul>
</div>
</div>
<div id="admonition-further-reading" class="admonition admonish-tip" role="note" aria-labelledby="admonition-further-reading-title">
<div class="admonition-title">
<div id="admonition-further-reading-title">
<p>Further Reading</p>
</div>
<a class="admonition-anchor-link" href="monads/free_monad.html#admonition-further-reading"></a>
</div>
<div>
<p>For deeper exploration of Free monads and their applications:</p>
<ul>
<li><strong>Gabriel Gonzalez</strong>: <a href="http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html">Why free monads matter</a> - An intuitive introduction to the concept</li>
<li><strong>Runar Bjarnason</strong>: <a href="http://blog.higher-order.com/assets/trampolines.pdf">Stackless Scala With Free Monads</a> - Stack-safe execution patterns</li>
<li><strong>Cats Documentation</strong>: <a href="https://typelevel.org/cats/datatypes/freemonad.html">Free Monad</a> - Scala implementation and examples</li>
<li><strong>John A De Goes</strong>: <a href="http://degoes.net/articles/modern-fp-part-2">Modern Functional Programming (Part 2)</a> - Practical applications in real systems</li>
</ul>
</div>
</div>
<h2 id="purpose-7"><a class="header" href="#purpose-7">Purpose</a></h2>
<p>In traditional Java programming, when you want to execute side effects (like printing to the console, reading files, or making database queries), you directly execute them:</p>
<pre><code class="language-java">// Traditional imperative approach
System.out.println("What is your name?");
String name = scanner.nextLine();
System.out.println("Hello, " + name + "!");
</code></pre>
<p>This approach tightly couples <strong>what</strong> you want to do with <strong>how</strong> it's done. The <strong>Free monad</strong> provides a fundamentally different approach: instead of executing effects immediately, you build programs as <strong>data structures</strong> that can be interpreted in different ways.</p>
<p>Think of it like writing a recipe (the data structure) versus actually cooking the meal (the execution). The recipe can be:</p>
<ul>
<li>Executed in a real kitchen (production)</li>
<li>Simulated for testing</li>
<li>Optimised before cooking</li>
<li>Translated to different cuisines</li>
</ul>
<p>The Free monad enables this separation in functional programming. A <code>Free&lt;F, A&gt;</code> represents a program built from instructions of type <code>F</code> that, when interpreted, will produce a value of type <code>A</code>.</p>
<h3 id="key-benefits-1"><a class="header" href="#key-benefits-1">Key Benefits</a></h3>
<ol>
<li><strong>Testability</strong>: Write pure tests without actual side effects. Test database code without a database.</li>
<li><strong>Multiple Interpretations</strong>: One program, many interpreters (production, testing, logging, optimisation).</li>
<li><strong>Composability</strong>: Build complex programs from simple, reusable building blocks.</li>
<li><strong>Inspection</strong>: Programs are data, so you can analyse, optimise, or transform them before execution.</li>
<li><strong>Stack Safety</strong>: Interpretation uses constant stack space, preventing <code>StackOverflowError</code>.</li>
</ol>
<h3 id="comparison-with-traditional-java-patterns"><a class="header" href="#comparison-with-traditional-java-patterns">Comparison with Traditional Java Patterns</a></h3>
<p>If you're familiar with the <strong>Strategy pattern</strong>, Free monads extend this concept:</p>
<p><strong>Strategy Pattern</strong>: Choose algorithm at runtime</p>
<pre><code class="language-java">interface PaymentStrategy {
    void pay(int amount);
}
// Pick one: creditCardStrategy, payPalStrategy, etc.
</code></pre>
<p><strong>Free Monad</strong>: Build an <strong>entire program</strong> as data, then pick how to execute it</p>
<pre><code class="language-java">Free&lt;PaymentOp, Receipt&gt; program = ...;
// Pick interpreter: realPayment, testPayment, loggingPayment, etc.
</code></pre>
<p>Similarly, the <strong>Command pattern</strong> encapsulates actions as objects:</p>
<p><strong>Command Pattern</strong>: Single action as object</p>
<pre><code class="language-java">interface Command {
    void execute();
}
</code></pre>
<p><strong>Free Monad</strong>: Entire workflows with sequencing, branching, and composition</p>
<pre><code class="language-java">Free&lt;Command, Result&gt; workflow =
    sendEmail(...)
        .flatMap(receipt -&gt; saveToDatabase(...))
        .flatMap(id -&gt; sendNotification(...));
// Interpret with real execution or test mock
</code></pre>
<h2 id="core-components-3"><a class="header" href="#core-components-3">Core Components</a></h2>
<p><strong>The Free Structure</strong></p>
<p><img src="monads/../images/puml/free_structure.svg" alt="free_structure.svg" /></p>
<p><strong>The HKT Bridge for Free</strong></p>
<p><img src="monads/../images/puml/free_kind.svg" alt="free_kind.svg" /></p>
<p><strong>Type Classes for Free</strong></p>
<p><img src="monads/../images/puml/free_monad.svg" alt="free_monad.svg" /></p>
<p>The <code>Free</code> functionality is built upon several related components:</p>
<ol>
<li>
<p><strong><code>Free&lt;F, A&gt;</code></strong>: The core sealed interface representing a program. It has three constructors:</p>
<ul>
<li><code>Pure&lt;F, A&gt;</code>: Represents a terminal value‚Äîthe final result.</li>
<li><code>Suspend&lt;F, A&gt;</code>: Represents a suspended computation‚Äîan instruction <code>Kind&lt;F, Free&lt;F, A&gt;&gt;</code> to be interpreted later.</li>
<li><code>FlatMapped&lt;F, X, A&gt;</code>: Represents monadic sequencing‚Äîchains computations together in a stack-safe manner.</li>
</ul>
</li>
<li>
<p><strong><code>FreeKind&lt;F, A&gt;</code></strong>: The HKT marker interface (<code>Kind&lt;FreeKind.Witness&lt;F&gt;, A&gt;</code>) for <code>Free</code>. This allows <code>Free</code> to be treated as a generic type constructor in type classes. The witness type is <code>FreeKind.Witness&lt;F&gt;</code>, where <code>F</code> is the instruction set functor.</p>
</li>
<li>
<p><strong><code>FreeKindHelper</code></strong>: The essential utility class for working with <code>Free</code> in the HKT simulation. It provides:</p>
<ul>
<li><code>widen(Free&lt;F, A&gt;)</code>: Wraps a concrete <code>Free&lt;F, A&gt;</code> instance into its HKT representation.</li>
<li><code>narrow(Kind&lt;FreeKind.Witness&lt;F&gt;, A&gt;)</code>: Unwraps a <code>FreeKind&lt;F, A&gt;</code> back to the concrete <code>Free&lt;F, A&gt;</code>.</li>
</ul>
</li>
<li>
<p><strong><code>FreeFunctor&lt;F&gt;</code></strong>: Implements <code>Functor&lt;FreeKind.Witness&lt;F&gt;&gt;</code>. Provides the <code>map</code> operation to transform result values.</p>
</li>
<li>
<p><strong><code>FreeMonad&lt;F&gt;</code></strong>: Extends <code>FreeFunctor&lt;F&gt;</code> and implements <code>Monad&lt;FreeKind.Witness&lt;F&gt;&gt;</code>. Provides <code>of</code> (to lift a pure value) and <code>flatMap</code> (to sequence Free computations).</p>
</li>
</ol>
<h2 id="purpose-and-usage-4"><a class="header" href="#purpose-and-usage-4">Purpose and Usage</a></h2>
<ul>
<li><strong>Building DSLs</strong>: Create domain-specific languages as composable data structures.</li>
<li><strong>Natural Transformations</strong>: Write interpreters as transformations from your instruction set <code>F</code> to a target monad <code>M</code>.</li>
<li><strong>Stack-Safe Execution</strong>: The <code>foldMap</code> method uses Higher-Kinded-J's own <code>Trampoline</code> monad internally, demonstrating the library's composability whilst preventing stack overflow.</li>
<li><strong>Multiple Interpreters</strong>: Execute the same program with different interpreters (production vs. testing vs. logging).</li>
<li><strong>Programme Inspection</strong>: Since programs are data, you can analyse, optimise, or transform them before execution.</li>
</ul>
<p><strong>Key Methods:</strong></p>
<ul>
<li><code>Free.pure(value)</code>: Creates a terminal computation holding a final value.</li>
<li><code>Free.suspend(computation)</code>: Suspends a computation for later interpretation.</li>
<li><code>Free.liftF(fa, functor)</code>: Lifts a functor value into a Free monad.</li>
<li><code>free.map(f)</code>: Transforms the result value without executing.</li>
<li><code>free.flatMap(f)</code>: Sequences Free computations whilst maintaining stack safety.</li>
<li><code>free.foldMap(transform, monad)</code>: Interprets the Free program using a natural transformation.</li>
</ul>
<p><strong>FreeFactory for Improved Type Inference:</strong></p>
<p>Java's type inference can struggle when chaining operations directly on <code>Free.pure()</code>:</p>
<pre><code class="language-java">// This fails to compile - Java can't infer F
Free&lt;IdKind.Witness, Integer&gt; result = Free.pure(2).map(x -&gt; x * 2); // ERROR

// Workaround: explicit type parameters (verbose)
Free&lt;IdKind.Witness, Integer&gt; result = Free.&lt;IdKind.Witness, Integer&gt;pure(2).map(x -&gt; x * 2);
</code></pre>
<p>The <code>FreeFactory&lt;F&gt;</code> class solves this by capturing the functor type parameter once:</p>
<pre><code class="language-java">// Create a factory with your functor type
FreeFactory&lt;IdKind.Witness&gt; FREE = FreeFactory.of();
// or with a monad instance for clarity:
FreeFactory&lt;IdKind.Witness&gt; FREE = FreeFactory.withMonad(IdMonad.instance());

// Now type inference works perfectly
Free&lt;IdKind.Witness, Integer&gt; result = FREE.pure(2).map(x -&gt; x * 2); // Works!

// Chain operations fluently
Free&lt;IdKind.Witness, Integer&gt; program = FREE.pure(10)
    .map(x -&gt; x + 1)
    .flatMap(x -&gt; FREE.pure(x * 2))
    .map(x -&gt; x - 5);

// Other factory methods
Free&lt;F, A&gt; pure = FREE.pure(value);
Free&lt;F, A&gt; suspended = FREE.suspend(computation);
Free&lt;F, A&gt; lifted = FREE.liftF(fa, functor);
</code></pre>
<p><code>FreeFactory</code> is particularly useful in:</p>
<ul>
<li>Test code where you build many Free programmes</li>
<li>DSL implementations where type inference is important</li>
<li>Any code that chains <code>map</code>/<code>flatMap</code> operations on <code>Free.pure()</code></li>
</ul>
<div id="admonition-example-1-building-a-console-dsl" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-1-building-a-console-dsl-title">
<div class="admonition-title">
<div id="admonition-example-1-building-a-console-dsl-title">
<p>Example 1: Building a Console DSL</p>
</div>
<a class="admonition-anchor-link" href="monads/free_monad.html#admonition-example-1-building-a-console-dsl"></a>
</div>
<div>
<p>Let's build a simple DSL for console interactions. We'll define instructions, build programs, and create multiple interpreters.</p>
<h3 id="step-1-define-your-instruction-set"><a class="header" href="#step-1-define-your-instruction-set">Step 1: Define Your Instruction Set</a></h3>
<p>First, create a sealed interface representing all possible operations in your DSL:</p>
<pre><code class="language-java">public sealed interface ConsoleOp&lt;A&gt; {
    record PrintLine(String text) implements ConsoleOp&lt;Unit&gt; {}
    record ReadLine() implements ConsoleOp&lt;String&gt; {}
}

public record Unit() {
    public static final Unit INSTANCE = new Unit();
}
</code></pre>
<p>This is your vocabulary. <code>PrintLine</code> returns <code>Unit</code> (like <code>void</code>), <code>ReadLine</code> returns <code>String</code>.</p>
<h3 id="step-2-create-hkt-bridge-for-your-dsl"><a class="header" href="#step-2-create-hkt-bridge-for-your-dsl">Step 2: Create HKT Bridge for Your DSL</a></h3>
<p>To use your DSL with the Free monad, you need the HKT simulation components:</p>
<pre><code class="language-java">public interface ConsoleOpKind&lt;A&gt; extends Kind&lt;ConsoleOpKind.Witness, A&gt; {
    final class Witness {
        private Witness() {}
    }
}

public enum ConsoleOpKindHelper {
    CONSOLE;

    record ConsoleOpHolder&lt;A&gt;(ConsoleOp&lt;A&gt; op) implements ConsoleOpKind&lt;A&gt; {}

    public &lt;A&gt; Kind&lt;ConsoleOpKind.Witness, A&gt; widen(ConsoleOp&lt;A&gt; op) {
        return new ConsoleOpHolder&lt;&gt;(op);
    }

    public &lt;A&gt; ConsoleOp&lt;A&gt; narrow(Kind&lt;ConsoleOpKind.Witness, A&gt; kind) {
        return ((ConsoleOpHolder&lt;A&gt;) kind).op();
    }
}
</code></pre>
<h3 id="step-3-create-a-functor-for-your-dsl"><a class="header" href="#step-3-create-a-functor-for-your-dsl">Step 3: Create a Functor for Your DSL</a></h3>
<p>The Free monad requires a <code>Functor</code> for your instruction set:</p>
<pre><code class="language-java">public class ConsoleOpFunctor implements Functor&lt;ConsoleOpKind.Witness&gt; {
    private static final ConsoleOpKindHelper CONSOLE = ConsoleOpKindHelper.CONSOLE;

    @Override
    public &lt;A, B&gt; Kind&lt;ConsoleOpKind.Witness, B&gt; map(
            Function&lt;? super A, ? extends B&gt; f,
            Kind&lt;ConsoleOpKind.Witness, A&gt; fa) {
        ConsoleOp&lt;A&gt; op = CONSOLE.narrow(fa);
        // For immutable operations, mapping is identity
        // (actual mapping happens during interpretation)
        return (Kind&lt;ConsoleOpKind.Witness, B&gt;) fa;
    }
}
</code></pre>
<h3 id="step-4-create-dsl-helper-functions"><a class="header" href="#step-4-create-dsl-helper-functions">Step 4: Create DSL Helper Functions</a></h3>
<p>Provide convenient methods for building Free programs:</p>
<pre><code class="language-java">public class ConsoleOps {
    /** Prints a line to the console. */
    public static Free&lt;ConsoleOpKind.Witness, Unit&gt; printLine(String text) {
        ConsoleOp&lt;Unit&gt; op = new ConsoleOp.PrintLine(text);
        Kind&lt;ConsoleOpKind.Witness, Unit&gt; kindOp =
            ConsoleOpKindHelper.CONSOLE.widen(op);
        return Free.liftF(kindOp, new ConsoleOpFunctor());
    }

    /** Reads a line from the console. */
    public static Free&lt;ConsoleOpKind.Witness, String&gt; readLine() {
        ConsoleOp&lt;String&gt; op = new ConsoleOp.ReadLine();
        Kind&lt;ConsoleOpKind.Witness, String&gt; kindOp =
            ConsoleOpKindHelper.CONSOLE.widen(op);
        return Free.liftF(kindOp, new ConsoleOpFunctor());
    }

    /** Pure value in the Free monad. */
    public static &lt;A&gt; Free&lt;ConsoleOpKind.Witness, A&gt; pure(A value) {
        return Free.pure(value);
    }
}
</code></pre>
<p>Now you can build programs using familiar Java syntax:</p>
<pre><code class="language-java">Free&lt;ConsoleOpKind.Witness, Unit&gt; program =
    ConsoleOps.printLine("What is your name?")
        .flatMap(ignored -&gt;
            ConsoleOps.readLine()
                .flatMap(name -&gt;
                    ConsoleOps.printLine("Hello, " + name + "!")));
</code></pre>
<p><strong>Key Insight</strong>: At this point, <strong>nothing has executed</strong>. You've built a data structure describing what should happen.</p>
</div>
</div>
<div id="admonition-example-2-building-programs-with-map-and-flatmap" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-2-building-programs-with-map-and-flatmap-title">
<div class="admonition-title">
<div id="admonition-example-2-building-programs-with-map-and-flatmap-title">
<p>Example 2: Building Programs with map and flatMap</p>
</div>
<a class="admonition-anchor-link" href="monads/free_monad.html#admonition-example-2-building-programs-with-map-and-flatmap"></a>
</div>
<div>
<p>The Free monad supports <code>map</code> and <code>flatMap</code>, making it easy to compose programs:</p>
<pre><code class="language-java">import static org.higherkindedj.example.free.ConsoleProgram.ConsoleOps.*;

// Simple sequence
Free&lt;ConsoleOpKind.Witness, String&gt; getName =
    printLine("Enter your name:")
        .flatMap(ignored -&gt; readLine());

// Using map to transform results
Free&lt;ConsoleOpKind.Witness, String&gt; getUpperName =
    getName.map(String::toUpperCase);

// Building complex workflows
Free&lt;ConsoleOpKind.Witness, Unit&gt; greetingWorkflow =
    printLine("Welcome to the application!")
        .flatMap(ignored -&gt; getName)
        .flatMap(name -&gt; printLine("Hello, " + name + "!"))
        .flatMap(ignored -&gt; printLine("Have a great day!"));

// Calculator example with error handling
Free&lt;ConsoleOpKind.Witness, Unit&gt; calculator =
    printLine("Enter first number:")
        .flatMap(ignored1 -&gt; readLine())
        .flatMap(num1 -&gt;
            printLine("Enter second number:")
                .flatMap(ignored2 -&gt; readLine())
                .flatMap(num2 -&gt; {
                    try {
                        int sum = Integer.parseInt(num1) + Integer.parseInt(num2);
                        return printLine("Sum: " + sum);
                    } catch (NumberFormatException e) {
                        return printLine("Invalid numbers!");
                    }
                }));
</code></pre>
<p><strong>Composability</strong>: Notice how we can build <code>getName</code> once and reuse it in multiple programmes. This promotes code reuse and testability.</p>
</div>
</div>
<div id="admonition-example-3-io-interpreter-for-real-execution" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-3-io-interpreter-for-real-execution-title">
<div class="admonition-title">
<div id="admonition-example-3-io-interpreter-for-real-execution-title">
<p>Example 3: IO Interpreter for Real Execution</p>
</div>
<a class="admonition-anchor-link" href="monads/free_monad.html#admonition-example-3-io-interpreter-for-real-execution"></a>
</div>
<div>
<p>Now let's create an interpreter that actually executes console operations:</p>
<pre><code class="language-java">public class IOInterpreter {
    private final Scanner scanner = new Scanner(System.in);

    public &lt;A&gt; A run(Free&lt;ConsoleOpKind.Witness, A&gt; program) {
        // Create a natural transformation from ConsoleOp to IO
        Function&lt;Kind&lt;ConsoleOpKind.Witness, ?&gt;, Kind&lt;IOKind.Witness, ?&gt;&gt; transform =
            kind -&gt; {
                ConsoleOp&lt;?&gt; op = ConsoleOpKindHelper.CONSOLE.narrow(
                    (Kind&lt;ConsoleOpKind.Witness, Object&gt;) kind);

                // Execute the instruction and wrap result in Free.pure
                Free&lt;ConsoleOpKind.Witness, ?&gt; freeResult = switch (op) {
                    case ConsoleOp.PrintLine print -&gt; {
                        System.out.println(print.text());
                        yield Free.pure(Unit.INSTANCE);
                    }
                    case ConsoleOp.ReadLine read -&gt; {
                        String line = scanner.nextLine();
                        yield Free.pure(line);
                    }
                };

                // Wrap the Free result in the target monad (IO)
                return IOKindHelper.IO.widen(new IO&lt;&gt;(freeResult));
            };

        // Interpret the program using foldMap
        Kind&lt;IOKind.Witness, A&gt; result = program.foldMap(transform, new IOMonad());
        return IOKindHelper.IO.narrow(result).value();
    }
}

// Simple IO type for the interpreter
record IO&lt;A&gt;(A value) {}

// Run the program
IOInterpreter interpreter = new IOInterpreter();
interpreter.run(greetingProgram());
// Actual console interaction happens here!
</code></pre>
<p><strong>Natural Transformation</strong>: The <code>transform</code> function is a natural transformation‚Äîit converts each <code>ConsoleOp</code> instruction into an <code>IO</code> operation whilst preserving structure.</p>
<p><strong>Critical Detail</strong>: Notice we wrap instruction results in <code>Free.pure()</code>. This is essential‚Äîthe natural transformation receives <code>Kind&lt;F, Free&lt;F, A&gt;&gt;</code> and must return <code>Kind&lt;M, Free&lt;F, A&gt;&gt;</code>, not just the raw result.</p>
</div>
</div>
<div id="admonition-example-4-test-interpreter-for-pure-testing" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-4-test-interpreter-for-pure-testing-title">
<div class="admonition-title">
<div id="admonition-example-4-test-interpreter-for-pure-testing-title">
<p>Example 4: Test Interpreter for Pure Testing</p>
</div>
<a class="admonition-anchor-link" href="monads/free_monad.html#admonition-example-4-test-interpreter-for-pure-testing"></a>
</div>
<div>
<p>One of the most powerful aspects of Free monads is testability. Create a test interpreter that doesn't perform real I/O:</p>
<pre><code class="language-java">public class TestInterpreter {
    private final List&lt;String&gt; input;
    private final List&lt;String&gt; output = new ArrayList&lt;&gt;();
    private int inputIndex = 0;

    public TestInterpreter(List&lt;String&gt; input) {
        this.input = input;
    }

    public &lt;A&gt; A run(Free&lt;ConsoleOpKind.Witness, A&gt; program) {
        // Create natural transformation to TestResult
        Function&lt;Kind&lt;ConsoleOpKind.Witness, ?&gt;, Kind&lt;TestResultKind.Witness, ?&gt;&gt; transform =
            kind -&gt; {
                ConsoleOp&lt;?&gt; op = ConsoleOpKindHelper.CONSOLE.narrow(
                    (Kind&lt;ConsoleOpKind.Witness, Object&gt;) kind);

                // Simulate the instruction
                Free&lt;ConsoleOpKind.Witness, ?&gt; freeResult = switch (op) {
                    case ConsoleOp.PrintLine print -&gt; {
                        output.add(print.text());
                        yield Free.pure(Unit.INSTANCE);
                    }
                    case ConsoleOp.ReadLine read -&gt; {
                        String line = inputIndex &lt; input.size()
                            ? input.get(inputIndex++)
                            : "";
                        yield Free.pure(line);
                    }
                };

                return TestResultKindHelper.TEST.widen(new TestResult&lt;&gt;(freeResult));
            };

        Kind&lt;TestResultKind.Witness, A&gt; result =
            program.foldMap(transform, new TestResultMonad());
        return TestResultKindHelper.TEST.narrow(result).value();
    }

    public List&lt;String&gt; getOutput() {
        return output;
    }
}

// Pure test - no actual I/O!
@Test
void testGreetingProgram() {
    TestInterpreter interpreter = new TestInterpreter(List.of("Alice"));
    interpreter.run(Programs.greetingProgram());

    List&lt;String&gt; output = interpreter.getOutput();
    assertEquals(2, output.size());
    assertEquals("What is your name?", output.get(0));
    assertEquals("Hello, Alice!", output.get(1));
}
</code></pre>
<p><strong>Testability</strong>: The same <code>greetingProgram()</code> can be tested without any actual console I/O. You control inputs and verify outputs deterministically.</p>
</div>
</div>
<div id="admonition-example-5-composing-larger-programmes-from-smaller-ones" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-5-composing-larger-programmes-from-smaller-ones-title">
<div class="admonition-title">
<div id="admonition-example-5-composing-larger-programmes-from-smaller-ones-title">
<p>Example 5: Composing Larger Programmes from Smaller Ones</p>
</div>
<a class="admonition-anchor-link" href="monads/free_monad.html#admonition-example-5-composing-larger-programmes-from-smaller-ones"></a>
</div>
<div>
<p>The real power emerges when building complex programmes from simple, reusable pieces:</p>
<pre><code class="language-java">// Reusable building blocks
Free&lt;ConsoleOpKind.Witness, String&gt; askQuestion(String question) {
    return printLine(question)
        .flatMap(ignored -&gt; readLine());
}

Free&lt;ConsoleOpKind.Witness, Unit&gt; confirmAction(String action) {
    return printLine(action + " - Are you sure? (yes/no)")
        .flatMap(ignored -&gt; readLine())
        .flatMap(response -&gt;
            response.equalsIgnoreCase("yes")
                ? printLine("Confirmed!")
                : printLine("Cancelled."));
}

// Composed programme
Free&lt;ConsoleOpKind.Witness, Unit&gt; userRegistration() {
    return askQuestion("Enter username:")
        .flatMap(username -&gt;
            askQuestion("Enter email:")
                .flatMap(email -&gt;
                    confirmAction("Register user " + username)
                        .flatMap(ignored -&gt;
                            printLine("Registration complete for " + username))));
}

// Even more complex composition
Free&lt;ConsoleOpKind.Witness, List&lt;String&gt;&gt; gatherMultipleInputs(int count) {
    Free&lt;ConsoleOpKind.Witness, List&lt;String&gt;&gt; start = Free.pure(new ArrayList&lt;&gt;());

    for (int i = 0; i &lt; count; i++) {
        final int index = i;
        start = start.flatMap(list -&gt;
            askQuestion("Enter item " + (index + 1) + ":")
                .map(item -&gt; {
                    list.add(item);
                    return list;
                }));
    }

    return start;
}
</code></pre>
<p><strong>Modularity</strong>: Each function returns a <code>Free</code> programme that can be:</p>
<ul>
<li>Tested independently</li>
<li>Composed with others</li>
<li>Interpreted in different ways</li>
<li>Reused across your application</li>
</ul>
</div>
</div>
<div id="admonition-example-6-using-freeliftf-for-single-operations" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-6-using-freeliftf-for-single-operations-title">
<div class="admonition-title">
<div id="admonition-example-6-using-freeliftf-for-single-operations-title">
<p>Example 6: Using Free.liftF for Single Operations</p>
</div>
<a class="admonition-anchor-link" href="monads/free_monad.html#admonition-example-6-using-freeliftf-for-single-operations"></a>
</div>
<div>
<p>The <code>liftF</code> method provides a convenient way to lift single functor operations into Free:</p>
<pre><code class="language-java">// Instead of manually creating Suspend
Free&lt;ConsoleOpKind.Witness, String&gt; createManualReadLine() {
    ConsoleOp&lt;String&gt; op = new ConsoleOp.ReadLine();
    Kind&lt;ConsoleOpKind.Witness, String&gt; kindOp =
        ConsoleOpKindHelper.CONSOLE.widen(op);
    return Free.suspend(
        new ConsoleOpFunctor().map(Free::pure, kindOp)
    );
}

// Using liftF (simpler!)
Free&lt;ConsoleOpKind.Witness, String&gt; createLiftedReadLine() {
    ConsoleOp&lt;String&gt; op = new ConsoleOp.ReadLine();
    Kind&lt;ConsoleOpKind.Witness, String&gt; kindOp =
        ConsoleOpKindHelper.CONSOLE.widen(op);
    return Free.liftF(kindOp, new ConsoleOpFunctor());
}

// Even simpler with helper method
Free&lt;ConsoleOpKind.Witness, String&gt; simpleReadLine =
    ConsoleOps.readLine();
</code></pre>
<p><strong>Best Practice</strong>: Create helper methods (like <code>ConsoleOps.readLine()</code>) that use <code>liftF</code> internally. This provides a clean API for building programmes.</p>
</div>
</div>
<h2 id="when-to-use-free-monad"><a class="header" href="#when-to-use-free-monad">When to Use Free Monad</a></h2>
<h3 id="use-free-monad-when"><a class="header" href="#use-free-monad-when">Use Free Monad When:</a></h3>
<ol>
<li>
<p><strong>Building DSLs</strong>: You need a domain-specific language for your problem domain (financial calculations, workflow orchestration, build systems, etc.).</p>
</li>
<li>
<p><strong>Multiple Interpretations</strong>: The same logic needs different execution modes:</p>
<ul>
<li>Production (real database, real network)</li>
<li>Testing (mocked, pure)</li>
<li>Logging (record all operations)</li>
<li>Optimisation (analyse before execution)</li>
<li>Dry-run (validate without executing)</li>
</ul>
</li>
<li>
<p><strong>Testability is Critical</strong>: You need to test complex logic without actual side effects. Example: testing database transactions without a database.</p>
</li>
<li>
<p><strong>Programme Analysis</strong>: You need to inspect, optimise, or transform programmes before execution:</p>
<ul>
<li>Query optimisation</li>
<li>Batch operations</li>
<li>Caching strategies</li>
<li>Cost analysis</li>
</ul>
</li>
<li>
<p><strong>Separation of Concerns</strong>: Business logic must be decoupled from execution details. Example: workflow definition separate from workflow engine.</p>
</li>
<li>
<p><strong>Stack Safety Required</strong>: Your DSL involves deep recursion or many sequential operations (verified with 10,000+ operations).</p>
</li>
</ol>
<h3 id="avoid-free-monad-when"><a class="header" href="#avoid-free-monad-when">Avoid Free Monad When:</a></h3>
<ol>
<li>
<p><strong>Simple Effects</strong>: For straightforward side effects, use <code>IO</code>, <code>Reader</code>, or <code>State</code> directly. Free adds unnecessary complexity.</p>
</li>
<li>
<p><strong>Performance Critical</strong>: Free monads have overhead:</p>
<ul>
<li>Heap allocation for programme structure</li>
<li>Interpretation overhead</li>
<li>Not suitable for hot paths or tight loops</li>
</ul>
</li>
<li>
<p><strong>Single Interpretation</strong>: If you only ever need one way to execute your programme, traditional imperative code or simpler monads are clearer.</p>
</li>
<li>
<p><strong>Team Unfamiliarity</strong>: Free monads require understanding of:</p>
<ul>
<li>Algebraic data types</li>
<li>Natural transformations</li>
<li>Monadic composition</li>
</ul>
<p>If your team isn't comfortable with these concepts, simpler patterns might be more maintainable.</p>
</li>
<li>
<p><strong>Small Scale</strong>: For small scripts or simple applications, the architectural benefits don't justify the complexity.</p>
</li>
</ol>
<h3 id="comparison-with-alternatives"><a class="header" href="#comparison-with-alternatives">Comparison with Alternatives</a></h3>
<p><strong>Free Monad vs. Direct Effects</strong>:</p>
<ul>
<li>Free: Testable, multiple interpreters, programme inspection</li>
<li>Direct: Simpler, better performance, easier to understand</li>
</ul>
<p><strong>Free Monad vs. Tagless Final</strong>:</p>
<ul>
<li>Free: Programmes are data structures, can be inspected</li>
<li>Tagless Final: Better performance, less boilerplate, but programmes aren't inspectable</li>
</ul>
<p><strong>Free Monad vs. Effect Systems (like ZIO/Cats Effect)</strong>:</p>
<ul>
<li>Free: Simpler concept, custom DSLs</li>
<li>Effect Systems: More powerful, better performance, ecosystem support</li>
</ul>
<h2 id="advanced-topics"><a class="header" href="#advanced-topics">Advanced Topics</a></h2>
<h3 id="free-applicative-vs-free-monad"><a class="header" href="#free-applicative-vs-free-monad">Free Applicative vs. Free Monad</a></h3>
<p>The <strong>Free Applicative</strong> is a related but distinct structure:</p>
<pre><code class="language-java">// Free Monad: Sequential, dependent operations
Free&lt;F, C&gt; sequential =
    operationA()                           // A
        .flatMap(a -&gt;                      // depends on A
            operationB(a)                  // B
                .flatMap(b -&gt;              // depends on B
                    operationC(a, b)));    // C

// Free Applicative: Independent, parallel operations
Applicative&lt;F, C&gt; parallel =
    map3(
        operationA(),                      // A (independent)
        operationB(),                      // B (independent)
        operationC(),                      // C (independent)
        (a, b, c) -&gt; combine(a, b, c)
    );
</code></pre>
<p><strong>When to use Free Applicative</strong>:</p>
<ul>
<li>Operations are <strong>independent</strong> and can run in parallel</li>
<li>You want to <strong>analyse</strong> all operations upfront (batch database queries, parallel API calls)</li>
<li><strong>Optimisation</strong>: Can reorder, batch, or parallelise operations</li>
</ul>
<p><strong>When to use Free Monad</strong>:</p>
<ul>
<li>Operations are <strong>dependent</strong> on previous results</li>
<li>Need full monadic <strong>sequencing</strong> power</li>
<li>Building workflows with conditional logic</li>
</ul>
<p><strong>Example</strong>: Fetching data from multiple independent sources</p>
<pre><code class="language-java">// Free Applicative can batch these into a single round-trip
Applicative&lt;DatabaseQuery, Report&gt; report =
    map3(
        fetchUsers(),           // Independent
        fetchOrders(),          // Independent
        fetchProducts(),        // Independent
        (users, orders, products) -&gt; generateReport(users, orders, products)
    );

// Interpreter can optimise: "SELECT * FROM users, orders, products"
</code></pre>
<h3 id="coyoneda-optimisation"><a class="header" href="#coyoneda-optimisation">Coyoneda Optimisation</a></h3>
<p>The <strong>Coyoneda lemma</strong> states that every type constructor can be made into a Functor. This allows Free monads to work with non-functor instruction sets:</p>
<pre><code class="language-java">// Without Coyoneda: instruction set must be a Functor
public sealed interface DatabaseOp&lt;A&gt; {
    record Query(String sql) implements DatabaseOp&lt;ResultSet&gt; {}
    record Update(String sql) implements DatabaseOp&lt;Integer&gt; {}
}

// Must implement Functor&lt;DatabaseOp&gt; - can be tedious!

// With Coyoneda: automatic functor lifting
class Coyoneda&lt;F, A&gt; {
    Kind&lt;F, Object&gt; fa;
    Function&lt;Object, A&gt; f;

    static &lt;F, A&gt; Coyoneda&lt;F, A&gt; lift(Kind&lt;F, A&gt; fa) {
        return new Coyoneda&lt;&gt;(fa, Function.identity());
    }
}

// Now you can use any F without writing a Functor instance!
Free&lt;Coyoneda&lt;DatabaseOp, ?&gt;, Result&gt; programme = ...;
</code></pre>
<p><strong>Benefits</strong>:</p>
<ul>
<li>Less boilerplate (no manual Functor implementation)</li>
<li>Works with any instruction set</li>
<li><strong>Trade-off</strong>: Slightly more complex interpretation</li>
</ul>
<p><strong>When to use</strong>: Large DSLs where writing Functor instances for every instruction type is burdensome.</p>
<h3 id="tagless-final-style-alternative-approach"><a class="header" href="#tagless-final-style-alternative-approach">Tagless Final Style (Alternative Approach)</a></h3>
<p>An alternative to Free monads is the <strong>Tagless Final</strong> encoding:</p>
<pre><code class="language-java">// Free Monad approach
sealed interface ConsoleOp&lt;A&gt; { ... }
Free&lt;ConsoleOp, Result&gt; programme = ...;

// Tagless Final approach
interface Console&lt;F&gt; {
    Kind&lt;F, Unit&gt; printLine(String text);
    Kind&lt;F, String&gt; readLine();
}

&lt;F&gt; Kind&lt;F, Unit&gt; programme(Console&lt;F&gt; console, Monad&lt;F&gt; monad) {
    Kind&lt;F, Unit&gt; printName = console.printLine("What is your name?");
    Kind&lt;F, String&gt; readName = monad.flatMap(ignored -&gt; console.readLine(), printName);
    return monad.flatMap(name -&gt; console.printLine("Hello, " + name + "!"), readName);
}

// Different interpreters
Kind&lt;IO.Witness, Unit&gt; prod = programme(ioConsole, ioMonad);
Kind&lt;Test.Witness, Unit&gt; test = programme(testConsole, testMonad);
</code></pre>
<p><strong>Tagless Final vs. Free Monad</strong>:</p>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th>Free Monad</th><th>Tagless Final</th></tr></thead><tbody>
<tr><td><strong>Programmes</strong></td><td>Data structures</td><td>Abstract functions</td></tr>
<tr><td><strong>Inspection</strong></td><td>‚úÖ Can analyse before execution</td><td>‚ùå Cannot inspect</td></tr>
<tr><td><strong>Performance</strong></td><td>Slower (interpretation overhead)</td><td>Faster (direct execution)</td></tr>
<tr><td><strong>Boilerplate</strong></td><td>More (HKT bridges, helpers)</td><td>Less (just interfaces)</td></tr>
<tr><td><strong>Flexibility</strong></td><td>‚úÖ Multiple interpreters, transformations</td><td>‚úÖ Multiple interpreters</td></tr>
<tr><td><strong>Learning Curve</strong></td><td>Steeper</td><td>Moderate</td></tr>
</tbody></table>
</div>
<p><strong>When to use Tagless Final</strong>:</p>
<ul>
<li>Performance matters</li>
<li>Don't need programme inspection</li>
<li>Prefer less boilerplate</li>
</ul>
<p><strong>When to use Free Monad</strong>:</p>
<ul>
<li>Need to analyse/optimise programmes before execution</li>
<li>Want programmes as first-class values</li>
<li>Building complex DSLs with transformations</li>
</ul>
<h2 id="performance-characteristics-1"><a class="header" href="#performance-characteristics-1">Performance Characteristics</a></h2>
<p>Understanding the performance trade-offs of Free monads is crucial for production use:</p>
<p><strong>Stack Safety</strong>: O(1) stack space regardless of programme depth</p>
<ul>
<li>Uses Higher-Kinded-J's <code>Trampoline</code> monad internally for <code>foldMap</code></li>
<li>Demonstrates library composability: Free uses Trampoline for stack safety</li>
<li>Verified with 10,000+ sequential operations without stack overflow</li>
</ul>
<p><strong>Heap Allocation</strong>: O(n) where n is programme size</p>
<ul>
<li>Each <code>flatMap</code> creates a <code>FlatMapped</code> node</li>
<li>Each <code>suspend</code> creates a <code>Suspend</code> node</li>
<li><strong>Consideration</strong>: For very large programmes (millions of operations), this could be significant</li>
</ul>
<p><strong>Interpretation Time</strong>: O(n) where n is programme size</p>
<ul>
<li>Each operation must be pattern-matched and interpreted</li>
<li>Additional indirection compared to direct execution</li>
<li><strong>Rough estimate</strong>: 2-10x slower than direct imperative code (depends on interpreter complexity)</li>
</ul>
<p><strong>Optimisation Strategies</strong>:</p>
<ol>
<li>
<p><strong>Batch Operations</strong>: Accumulate independent operations and execute in bulk</p>
<pre><code class="language-java">// Instead of 1000 individual database inserts
Free&lt;DB, Unit&gt; manyInserts = ...;

// Batch into single multi-row insert
interpreter.optimise(programme); // Detects pattern, batches
</code></pre>
</li>
<li>
<p><strong>Fusion</strong>: Combine consecutive <code>map</code> operations</p>
<pre><code class="language-java">programme.map(f).map(g).map(h)
// Optimiser fuses to: programme.map(f.andThen(g).andThen(h))
</code></pre>
</li>
<li>
<p><strong>Short-Circuiting</strong>: Detect early termination</p>
<pre><code class="language-java">// If programme returns early, skip remaining operations
</code></pre>
</li>
<li>
<p><strong>Caching</strong>: Memoize pure computations</p>
<pre><code class="language-java">// Cache results of expensive pure operations
</code></pre>
</li>
</ol>
<p><strong>Benchmarks</strong> (relative to direct imperative code):</p>
<ul>
<li>Simple programmes (&lt; 100 operations): 2-3x slower</li>
<li>Complex programmes (1000+ operations): 3-5x slower</li>
<li>With optimisation: Can approach parity for batch operations</li>
</ul>
<h2 id="implementation-notes-1"><a class="header" href="#implementation-notes-1">Implementation Notes</a></h2>
<p>The <code>foldMap</code> method leverages Higher-Kinded-J's own <code>Trampoline</code> monad to ensure stack-safe execution. This elegant design demonstrates that the library's abstractions are practical and composable:</p>
<pre><code class="language-java">public &lt;M&gt; Kind&lt;M, A&gt; foldMap(
        Function&lt;Kind&lt;F, ?&gt;, Kind&lt;M, ?&gt;&gt; transform,
        Monad&lt;M&gt; monad) {
    // Delegate to Trampoline for stack-safe execution
    return interpretFree(this, transform, monad).run();
}

private static &lt;F, M, A&gt; Trampoline&lt;Kind&lt;M, A&gt;&gt; interpretFree(
        Free&lt;F, A&gt; free,
        Function&lt;Kind&lt;F, ?&gt;, Kind&lt;M, ?&gt;&gt; transform,
        Monad&lt;M&gt; monad) {

    return switch (free) {
        case Pure&lt;F, A&gt; pure -&gt;
            // Terminal case: lift the pure value into the target monad
            Trampoline.done(monad.of(pure.value()));

        case Suspend&lt;F, A&gt; suspend -&gt; {
            // Transform the suspended computation and recursively interpret
            Kind&lt;M, Free&lt;F, A&gt;&gt; transformed =
                (Kind&lt;M, Free&lt;F, A&gt;&gt;) transform.apply(suspend.computation());

            yield Trampoline.done(
                monad.flatMap(
                    innerFree -&gt; interpretFree(innerFree, transform, monad).run(),
                    transformed));
        }

        case FlatMapped&lt;F, ?, A&gt; flatMapped -&gt; {
            // Handle FlatMapped by deferring the interpretation
            FlatMapped&lt;F, Object, A&gt; fm = (FlatMapped&lt;F, Object, A&gt;) flatMapped;

            yield Trampoline.defer(() -&gt;
                interpretFree(fm.sub(), transform, monad)
                    .map(kindOfX -&gt;
                        monad.flatMap(
                            x -&gt; {
                                Free&lt;F, A&gt; next = fm.continuation().apply(x);
                                return interpretFree(next, transform, monad).run();
                            },
                            kindOfX)));
        }
    };
}
</code></pre>
<p><strong>Key Design Decisions</strong>:</p>
<ol>
<li>
<p><strong>Trampoline Integration</strong>: Uses <code>Trampoline.done()</code> for terminal cases and <code>Trampoline.defer()</code> for recursive cases, ensuring stack safety.</p>
</li>
<li>
<p><strong>Library Composability</strong>: Demonstrates that Higher-Kinded-J's abstractions are practical‚ÄîFree monad uses Trampoline internally.</p>
</li>
<li>
<p><strong>Pattern Matching</strong>: Uses sealed interface with switch expressions for type-safe case handling.</p>
</li>
<li>
<p><strong>Separation of Concerns</strong>: Trampoline handles stack safety; Free handles DSL interpretation.</p>
</li>
<li>
<p><strong>Type Safety</strong>: Uses careful casting to maintain type safety whilst leveraging Trampoline's proven stack-safe execution.</p>
</li>
</ol>
<p><strong>Benefits of Using Trampoline</strong>:</p>
<ul>
<li>Single source of truth for stack-safe recursion</li>
<li>Proven implementation with 100% test coverage</li>
<li>Elegant demonstration of library cohesion</li>
<li>Improvements to Trampoline automatically benefit Free monad</li>
</ul>
<h2 id="comparison-with-traditional-java-patterns-1"><a class="header" href="#comparison-with-traditional-java-patterns-1">Comparison with Traditional Java Patterns</a></h2>
<p>Let's see how Free monads compare to familiar Java patterns:</p>
<h3 id="strategy-pattern"><a class="header" href="#strategy-pattern">Strategy Pattern</a></h3>
<p><strong>Traditional Strategy</strong>:</p>
<pre><code class="language-java">interface SortStrategy {
    void sort(List&lt;Integer&gt; list);
}

class QuickSort implements SortStrategy { ... }
class MergeSort implements SortStrategy { ... }

// Choose algorithm at runtime
SortStrategy strategy = useQuickSort ? new QuickSort() : new MergeSort();
strategy.sort(myList);
</code></pre>
<p><strong>Free Monad Equivalent</strong>:</p>
<pre><code class="language-java">sealed interface SortOp&lt;A&gt; {
    record Compare(int i, int j) implements SortOp&lt;Boolean&gt; {}
    record Swap(int i, int j) implements SortOp&lt;Unit&gt; {}
}

Free&lt;SortOp, Unit&gt; quickSort(List&lt;Integer&gt; list) {
    // Build programme as data
    return ...;
}

// Multiple interpreters
interpreter1.run(programme); // In-memory sort
interpreter2.run(programme); // Log operations
interpreter3.run(programme); // Visualise algorithm
</code></pre>
<p><strong>Advantage of Free</strong>: The <strong>entire algorithm</strong> is a data structure that can be inspected, optimised, or visualised.</p>
<h3 id="command-pattern"><a class="header" href="#command-pattern">Command Pattern</a></h3>
<p><strong>Traditional Command</strong>:</p>
<pre><code class="language-java">interface Command {
    void execute();
}

class SendEmailCommand implements Command { ... }
class SaveToDBCommand implements Command { ... }

List&lt;Command&gt; commands = List.of(
    new SendEmailCommand(...),
    new SaveToDBCommand(...)
);

commands.forEach(Command::execute);
</code></pre>
<p><strong>Free Monad Equivalent</strong>:</p>
<pre><code class="language-java">sealed interface AppOp&lt;A&gt; {
    record SendEmail(String to, String body) implements AppOp&lt;Receipt&gt; {}
    record SaveToDB(Data data) implements AppOp&lt;Id&gt; {}
}

Free&lt;AppOp, Result&gt; workflow =
    sendEmail("user@example.com", "Welcome!")
        .flatMap(receipt -&gt; saveToDatabase(receipt))
        .flatMap(id -&gt; sendNotification(id));

// One programme, many interpreters
productionInterpreter.run(workflow); // Real execution
testInterpreter.run(workflow);       // Pure testing
loggingInterpreter.run(workflow);    // Audit trail
</code></pre>
<p><strong>Advantage of Free</strong>: Commands compose with <code>flatMap</code>, results flow between commands, and you get multiple interpreters for free.</p>
<h3 id="observer-pattern"><a class="header" href="#observer-pattern">Observer Pattern</a></h3>
<p><strong>Traditional Observer</strong>:</p>
<pre><code class="language-java">interface Observer {
    void update(Event event);
}

class Logger implements Observer { ... }
class Notifier implements Observer { ... }

subject.registerObserver(logger);
subject.registerObserver(notifier);
subject.notifyObservers(event);
</code></pre>
<p><strong>Free Monad Equivalent</strong>:</p>
<pre><code class="language-java">sealed interface EventOp&lt;A&gt; {
    record Emit(Event event) implements EventOp&lt;Unit&gt; {}
    record React(Event event) implements EventOp&lt;Unit&gt; {}
}

Free&lt;EventOp, Unit&gt; eventStream =
    emit(userLoggedIn)
        .flatMap(ignored -&gt; emit(pageViewed))
        .flatMap(ignored -&gt; emit(itemPurchased));

// Different observation strategies
loggingInterpreter.run(eventStream);     // Log to file
analyticsInterpreter.run(eventStream);   // Send to analytics
testInterpreter.run(eventStream);        // Collect for assertions
</code></pre>
<p><strong>Advantage of Free</strong>: Event streams are first-class values that can be composed, transformed, and replayed.</p>
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<p>The Free monad provides a powerful abstraction for building domain-specific languages in Java:</p>
<ul>
<li><strong>Separation of Concerns</strong>: Programme description (data) vs. execution (interpreters)</li>
<li><strong>Testability</strong>: Pure testing without actual side effects</li>
<li><strong>Flexibility</strong>: Multiple interpreters for the same programme</li>
<li><strong>Stack Safety</strong>: Handles deep recursion without stack overflow (verified with 10,000+ operations)</li>
<li><strong>Composability</strong>: Build complex programmes from simple building blocks</li>
</ul>
<p><strong>When to use</strong>:</p>
<ul>
<li>Building DSLs</li>
<li>Need multiple interpretations</li>
<li>Testability is critical</li>
<li>Programme analysis/optimisation required</li>
</ul>
<p><strong>When to avoid</strong>:</p>
<ul>
<li>Performance-critical code</li>
<li>Simple, single-interpretation effects</li>
<li>Team unfamiliar with advanced functional programming</li>
</ul>
<p>For detailed implementation examples and complete working code, see:</p>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/free/ConsoleProgram.java">ConsoleProgram.java</a> - Complete DSL with multiple interpreters</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/test/java/org/higherkindedj/hkt/free/FreeMonadTest.java">FreeMonadTest.java</a> - Comprehensive test suite including monad laws and stack safety</li>
</ul>
<p>The Free monad represents a sophisticated approach to building composable, testable, and maintainable programmes in Java. Whilst it requires understanding of advanced functional programming concepts, it pays dividends in large-scale applications where flexibility and testability are paramount.</p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="the-trymonad"><a class="header" href="#the-trymonad">The TryMonad:</a></h1>
<h2 id="typed-error-handling-1"><a class="header" href="#typed-error-handling-1"><em>Typed Error Handling</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="monads/try_monad.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to handle exceptions functionally with Success and Failure cases</li>
<li>Converting exception-throwing code into composable, safe operations</li>
<li>Using <code>recover</code> and <code>recoverWith</code> for graceful error recovery</li>
<li>Building robust parsing and processing pipelines</li>
<li>When to choose Try vs Either for error handling</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code:</p>
</div>
<a class="admonition-anchor-link" href="monads/try_monad.html#admonition-see-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/trymonad/TryExample.java">TryExample.java</a></p>
</div>
</div>
<h2 id="purpose-8"><a class="header" href="#purpose-8">Purpose</a></h2>
<p>The <code>Try&lt;T&gt;</code> type in the <code>Higher-Kinded-J</code> library represents a computation that might result in a value of type <code>T</code> (a <code>Success</code>) or fail with a <code>Throwable</code> (a <code>Failure</code>). It serves as a functional alternative to traditional <code>try-catch</code> blocks for handling exceptions, particularly checked exceptions, within a computation chain.  We can think of it as an <code>Either</code> where the <code>Left</code> is an <code>Exception</code>, but also using try-catch blocks behind the scene, so that we don‚Äôt have to.</p>
<p><strong>Try Type</strong></p>
<p><img src="monads/../images/puml/try_type.svg" alt="try_type.svg" /></p>
<p><strong>Monadic Structure</strong></p>
<p><img src="monads/../images/puml/try_monad.svg" alt="try_monad.svg" /></p>
<p>Key benefits include:</p>
<ul>
<li><strong>Explicit Error Handling:</strong> Makes it clear from the return type (<code>Try&lt;T&gt;</code>) that a computation might fail.</li>
<li><strong>Composability:</strong> Allows chaining operations using methods like <code>map</code> and <code>flatMap</code>, where failures are automatically propagated without interrupting the flow with exceptions.</li>
<li><strong>Integration with HKT:</strong> Provides HKT simulation (<code>TryKind</code>) and type class instances (<code>TryMonad</code>) to work seamlessly with generic functional abstractions operating over <code>Kind&lt;F, A&gt;</code>.</li>
<li><strong>Error Recovery:</strong> Offers methods like <code>recover</code> and <code>recoverWith</code> to handle failures gracefully within the computation chain.</li>
</ul>
<p>It implements <code>MonadError&lt;TryKind&lt;?&gt;, Throwable&gt;</code>, signifying its monadic nature and its ability to handle errors of type <code>Throwable</code>.</p>
<p>Now that we understand the structure and benefits of <code>Try</code>, let's explore how to create and work with <code>Try</code> instances in practice.</p>
<h2 id="how-to-use-tryt"><a class="header" href="#how-to-use-tryt">How to Use <code>Try&lt;T&gt;</code></a></h2>
<div id="admonition-creating-instance" class="admonition admonish-note" role="note" aria-labelledby="admonition-creating-instance-title">
<div class="admonition-title">
<div id="admonition-creating-instance-title">
<p>Creating Instance</p>
</div>
<a class="admonition-anchor-link" href="monads/try_monad.html#admonition-creating-instance"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/trymonad/TryExample.java">TryExample.java</a></li>
</ul>
<p>You can create <code>Try</code> instances in several ways:</p>
<ol>
<li>
<p><strong><code>Try.of(Supplier)</code>:</strong> Executes a <code>Supplier</code> and wraps the result in <code>Success</code> or catches any thrown <code>Throwable</code> (including <code>Error</code> and checked exceptions) and wraps it in <code>Failure</code>.</p>
<pre><code class="language-java">import org.higherkindedj.hkt.trymonad.Try;
import java.io.FileInputStream;

// Success case
Try&lt;String&gt; successResult = Try.of(() -&gt; "This will succeed"); // Success("This will succeed")

// Failure case (checked exception)
Try&lt;FileInputStream&gt; failureResult = Try.of(() -&gt; new FileInputStream("nonexistent.txt")); // Failure(FileNotFoundException)

// Failure case (runtime exception)
Try&lt;Integer&gt; divisionResult = Try.of(() -&gt; 10 / 0); // Failure(ArithmeticException)
</code></pre>
</li>
<li>
<p><strong><code>Try.success(value)</code>:</strong> Directly creates a <code>Success</code> instance holding the given value (which can be null).</p>
<pre><code class="language-java">Try&lt;String&gt; directSuccess = Try.success("Known value");
Try&lt;String&gt; successNull = Try.success(null);
</code></pre>
</li>
<li>
<p><strong><code>Try.failure(throwable)</code>:</strong> Directly creates a <code>Failure</code> instance holding the given non-null <code>Throwable</code>.</p>
<pre><code class="language-java">Try&lt;String&gt; directFailure = Try.failure(new RuntimeException("Something went wrong"));
</code></pre>
</li>
</ol>
</div>
</div>
<div id="admonition-checking-the-state" class="admonition admonish-note" role="note" aria-labelledby="admonition-checking-the-state-title">
<div class="admonition-title">
<div id="admonition-checking-the-state-title">
<p>Checking the State</p>
</div>
<a class="admonition-anchor-link" href="monads/try_monad.html#admonition-checking-the-state"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/trymonad/TryExample.java">TryExample.java</a></li>
</ul>
<ul>
<li><code>isSuccess()</code>: Returns <code>true</code> if it's a <code>Success</code>.</li>
<li><code>isFailure()</code>: Returns <code>true</code> if it's a <code>Failure</code>.</li>
</ul>
<h3 id="getting-the-value-use-with-caution"><a class="header" href="#getting-the-value-use-with-caution">Getting the Value (Use with Caution)</a></h3>
<ul>
<li><code>get()</code>: Returns the value if <code>Success</code>, otherwise throws the contained <code>Throwable</code>. <strong>Avoid using this directly; prefer <code>fold</code>, <code>map</code>, <code>flatMap</code>, or recovery methods.</strong></li>
</ul>
</div>
</div>
<div id="admonition-transforming-values-_map_" class="admonition admonish-note" role="note" aria-labelledby="admonition-transforming-values-_map_-title">
<div class="admonition-title">
<div id="admonition-transforming-values-_map_-title">
<p>Transforming Values (<em>map</em>)</p>
</div>
<a class="admonition-anchor-link" href="monads/try_monad.html#admonition-transforming-values-_map_"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/trymonad/TryExample.java">TryExample.java</a></li>
</ul>
<p>Applies a function to the value inside a <code>Success</code>. If the function throws an exception, the result becomes a <code>Failure</code>. If the original <code>Try</code> was a <code>Failure</code>, <code>map</code> does nothing and returns the original <code>Failure</code>.</p>
<pre><code class="language-java">Try&lt;Integer&gt; initialSuccess = Try.success(5);
Try&lt;String&gt; mappedSuccess = initialSuccess.map(value -&gt; "Value: " + value); // Success("Value: 5")

Try&lt;Integer&gt; initialFailure = Try.failure(new RuntimeException("Fail"));
Try&lt;String&gt; mappedFailure = initialFailure.map(value -&gt; "Value: " + value); // Failure(RuntimeException)

Try&lt;Integer&gt; mapThrows = initialSuccess.map(value -&gt; { throw new NullPointerException(); }); // Failure(NullPointerException)
</code></pre>
</div>
</div>
<div id="admonition-chaining-operations-_flatmap_" class="admonition admonish-note" role="note" aria-labelledby="admonition-chaining-operations-_flatmap_-title">
<div class="admonition-title">
<div id="admonition-chaining-operations-_flatmap_-title">
<p>Chaining Operations (<em>flatMap</em>)</p>
</div>
<a class="admonition-anchor-link" href="monads/try_monad.html#admonition-chaining-operations-_flatmap_"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/trymonad/TryExample.java">TryExample.java</a></li>
</ul>
<p>Applies a function that returns another <code>Try</code> to the value inside a <code>Success</code>. This is used to sequence operations where each step might fail. Failures are propagated.</p>
<pre><code class="language-java">Function&lt;Integer, Try&lt;Double&gt;&gt; safeDivide =
value -&gt; (value == 0) ? Try.failure(new ArithmeticException("Div by zero")) : Try.success(10.0 / value);

Try&lt;Integer&gt; inputSuccess = Try.success(2);
Try&lt;Double&gt; result1 = inputSuccess.flatMap(safeDivide); // Success(5.0)

Try&lt;Integer&gt; inputZero = Try.success(0);
Try&lt;Double&gt; result2 = inputZero.flatMap(safeDivide); // Failure(ArithmeticException)

Try&lt;Integer&gt; inputFailure = Try.failure(new RuntimeException("Initial fail"));
Try&lt;Double&gt; result3 = inputFailure.flatMap(safeDivide); // Failure(RuntimeException) - initial failure propagates
</code></pre>
</div>
</div>
<hr />
<h3 id="handling-failures-fold-recover-recoverwith"><a class="header" href="#handling-failures-fold-recover-recoverwith">Handling Failures (<code>fold</code>, <code>recover</code>, <code>recoverWith</code>)</a></h3>
<div id="admonition-_foldsuccessfunc-failurefunc_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_foldsuccessfunc-failurefunc_-title">
<div class="admonition-title">
<div id="admonition-_foldsuccessfunc-failurefunc_-title">
<p><em>fold(successFunc, failureFunc)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/try_monad.html#admonition-_foldsuccessfunc-failurefunc_"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/trymonad/TryExample.java">TryExample.java</a></li>
</ul>
<p>Safely handles both cases by applying one of two functions.</p>
<pre><code class="language-java">String message = result2.fold(
    successValue -&gt; "Succeeded with " + successValue,
    failureThrowable -&gt; "Failed with " + failureThrowable.getMessage()
); // "Failed with Div by zero"

</code></pre>
</div>
</div>
<div id="admonition-_recoverrecoveryfunc_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_recoverrecoveryfunc_-title">
<div class="admonition-title">
<div id="admonition-_recoverrecoveryfunc_-title">
<p><em>recover(recoveryFunc)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/try_monad.html#admonition-_recoverrecoveryfunc_"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/trymonad/TryExample.java">TryExample.java</a></li>
</ul>
<p>If <code>Failure</code>, applies a function <code>Throwable -&gt; T</code> to produce a new <code>Success</code> value. If the recovery function throws, the result is a <code>Failure</code> containing that new exception.</p>
<pre><code class="language-java">Function&lt;Throwable, Double&gt; recoverHandler = throwable -&gt; -1.0;
Try&lt;Double&gt; recovered1 = result2.recover(recoverHandler); // Success(-1.0)
Try&lt;Double&gt; recovered2 = result1.recover(recoverHandler); // Stays Success(5.0)
</code></pre>
</div>
</div>
<div id="admonition-_recoverwithrecoveryfunc_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_recoverwithrecoveryfunc_-title">
<div class="admonition-title">
<div id="admonition-_recoverwithrecoveryfunc_-title">
<p><em>recoverWith(recoveryFunc)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/try_monad.html#admonition-_recoverwithrecoveryfunc_"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/trymonad/TryExample.java">TryExample.java</a></li>
</ul>
<p>Similar to <code>recover</code>, but the recovery function <code>Throwable -&gt; Try&lt;T&gt;</code> must return a <code>Try</code>. This allows recovery to potentially result in another <code>Failure</code>.</p>
<pre><code class="language-java">Function&lt;Throwable, Try&lt;Double&gt;&gt; recoverWithHandler = throwable -&gt;
    (throwable instanceof ArithmeticException) ? Try.success(Double.POSITIVE_INFINITY) : Try.failure(throwable);

Try&lt;Double&gt; recoveredWith1 = result2.recoverWith(recoverWithHandler); // Success(Infinity)
Try&lt;Double&gt; recoveredWith2 = result3.recoverWith(recoverWithHandler); // Failure(RuntimeException) - re-raised
</code></pre>
</div>
</div>
<hr />
<div id="admonition-example-using-_trymonad_" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-using-_trymonad_-title">
<div class="admonition-title">
<div id="admonition-example-using-_trymonad_-title">
<p>Example: Using <em>TryMonad</em></p>
</div>
<a class="admonition-anchor-link" href="monads/try_monad.html#admonition-example-using-_trymonad_"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/trymonad/TryExample.java">TryExample.java</a></li>
</ul>
<p>To use <code>Try</code> with generic code expecting <code>Kind&lt;F, A&gt;</code>:</p>
<ol>
<li><strong>Get Instance:</strong><code>TryMonad tryMonad = TryMonad.INSTANCE;</code></li>
<li><strong>Wrap(Widen):</strong> Use <code>TRY.widen(myTry)</code> or factories like <code>TRY.tryOf(() -&gt; ...)</code>.</li>
<li><strong>Operate:</strong> Use <code>tryMonad.map(...)</code>, <code>tryMonad.flatMap(...)</code>, <code>tryMonad.handleErrorWith(...)</code> etc.</li>
<li><strong>Unwrap(Narrow):</strong> Use <code>TRY.narrow(tryKind)</code> to get the <code>Try&lt;T&gt;</code> back.</li>
</ol>
<pre><code class="language-java">
TryMonad tryMonad = TryMonad.INSTANCE;

Kind&lt;TryKind.Witness, Integer&gt; tryKind1 = TRY.tryOf(() -&gt; 10 / 2); // Success(5) Kind
Kind&lt;TryKind.Witness, Integer&gt; tryKind2 = TRY.tryOf(() -&gt; 10 / 0); // Failure(...) Kind

// Map using Monad instance
Kind&lt;TryKind.Witness, String&gt; mappedKind = tryMonad.map(Object::toString, tryKind1); // Success("5") Kind

// FlatMap using Monad instance
Function&lt;Integer, Kind&lt;TryKind.Witness, Double&gt;&gt; safeDivideKind =
        i -&gt; TRY.tryOf(() -&gt; 10.0 / i);
Kind&lt;TryKind.Witness, Double&gt; flatMappedKind = tryMonad.flatMap(safeDivideKind, tryKind1); // Success(2.0) Kind

// Handle error using MonadError instance
Kind&lt;TryKind.Witness, Integer&gt; handledKind = tryMonad.handleErrorWith(
        tryKind2, // The Failure Kind
        error -&gt; TRY.success(-1) // Recover to Success(-1) Kind
);

// Unwrap
Try&lt;String&gt; mappedTry = TRY.narrow(mappedKind); // Success("5")
Try&lt;Double&gt; flatMappedTry = TRY.narrow(flatMappedKind); // Success(2.0)
Try&lt;Integer&gt; handledTry = TRY.narrow(handledKind); // Success(-1)

System.out.println(mappedTry);
System.out.println(flatMappedTry);
System.out.println(handledTry);
</code></pre>
</div>
</div><div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="the-validatedmonad"><a class="header" href="#the-validatedmonad">The ValidatedMonad:</a></h1>
<h2 id="handling-valid-or-invalid-operations"><a class="header" href="#handling-valid-or-invalid-operations"><em>Handling Valid or Invalid Operations</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="monads/validated_monad.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to distinguish between valid and invalid data with explicit types</li>
<li>Using Validated as a MonadError for fail-fast error handling</li>
<li>Understanding when to use monadic operations (fail-fast) vs applicative operations (error accumulation)</li>
<li>The difference between fail-fast validation (Monad/MonadError) and error-accumulating validation (Applicative with Semigroup)</li>
<li>Real-world input validation scenarios with detailed error reporting</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code:</p>
</div>
<a class="admonition-anchor-link" href="monads/validated_monad.html#admonition-see-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/validated/ValidatedMonadExample.java">ValidatedMonadExample.java</a></p>
</div>
</div>
<h2 id="purpose-9"><a class="header" href="#purpose-9">Purpose</a></h2>
<p>The <code>Validated&lt;E, A&gt;</code> type in <code>Higher-Kinded-J</code> represents a value that can either be <code>Valid&lt;A&gt;</code> (correct) or <code>Invalid&lt;E&gt;</code> (erroneous). It is commonly used in scenarios like input validation where you want to clearly distinguish between a successful result and an error. Unlike types like <code>Either</code> which are often used for general-purpose sum types, <code>Validated</code> is specifically focused on the valid/invalid dichotomy. Operations like <code>map</code>, <code>flatMap</code>, and <code>ap</code> are right-biased, meaning they operate on the <code>Valid</code> value and propagate <code>Invalid</code> values unchanged.</p>
<p>The <code>ValidatedMonad&lt;E&gt;</code> provides a monadic interface for <code>Validated&lt;E, A&gt;</code> (where the error type <code>E</code> is fixed for the monad instance), allowing for functional composition and integration with the Higher-Kinded-J framework. This facilitates chaining operations that can result in either a valid outcome or an error.</p>
<div id="admonition-key-benefits-include" class="admonition admonish-info" role="note" aria-labelledby="admonition-key-benefits-include-title">
<div class="admonition-title">
<div id="admonition-key-benefits-include-title">
<p>Key benefits include:</p>
</div>
<a class="admonition-anchor-link" href="monads/validated_monad.html#admonition-key-benefits-include"></a>
</div>
<div>
<ul>
<li><strong>Explicit Validation Outcome:</strong> The type signature <code>Validated&lt;E, A&gt;</code> makes it clear that a computation can result in either a success (<code>Valid&lt;A&gt;</code>) or an error (<code>Invalid&lt;E&gt;</code>).</li>
<li><strong>Functional Composition:</strong> Enables chaining of operations using <code>map</code>, <code>flatMap</code>, and <code>ap</code>. If an operation results in an <code>Invalid</code>, subsequent operations in the chain are typically short-circuited, propagating the <code>Invalid</code> state.</li>
<li><strong>HKT Integration:</strong> <code>ValidatedKind&lt;E, A&gt;</code> (the HKT wrapper for <code>Validated&lt;E, A&gt;</code>) and <code>ValidatedMonad&lt;E&gt;</code> allow <code>Validated</code> to be used with generic functions and type classes that expect <code>Kind&lt;F, A&gt;</code>, <code>Functor&lt;F&gt;</code>, <code>Applicative&lt;F&gt;</code>, or <code>Monad&lt;M&gt;</code>.</li>
<li><strong>Clear Error Handling:</strong> Provides methods like <code>fold</code>, <code>ifValid</code>, <code>ifInvalid</code> to handle both <code>Valid</code> and <code>Invalid</code> cases explicitly.</li>
<li><strong>Standardized Error Handling:</strong> As a <code>MonadError&lt;ValidatedKind.Witness&lt;E&gt;, E&gt;</code>, it offers <code>raiseError</code> to construct error states and <code>handleErrorWith</code> for recovery, integrating with generic error-handling combinators.</li>
</ul>
</div>
</div>
<p><code>ValidatedMonad&lt;E&gt;</code> implements <code>MonadError&lt;ValidatedKind.Witness&lt;E&gt;, E&gt;</code>, which transitively includes <code>Monad&lt;ValidatedKind.Witness&lt;E&gt;&gt;</code>, <code>Applicative&lt;ValidatedKind.Witness&lt;E&gt;&gt;</code>, and <code>Functor&lt;ValidatedKind.Witness&lt;E&gt;&gt;</code>.</p>
<h2 id="structure-7"><a class="header" href="#structure-7">Structure</a></h2>
<p><strong>Validated Type</strong> Conceptually, <code>Validated&lt;E, A&gt;</code> has two sub-types:</p>
<ul>
<li><code>Valid&lt;A&gt;</code>: Contains a valid value of type <code>A</code>.</li>
<li><code>Invalid&lt;E&gt;</code>: Contains an error value of type <code>E</code>.
<img src="monads/../images/puml/validated_type.svg" alt="validated_type.svg" /></li>
</ul>
<p><strong>Monadic Structure</strong> The <code>ValidatedMonad&lt;E&gt;</code> enables monadic operations on <code>ValidatedKind.Witness&lt;E&gt;</code>.
<img src="monads/../images/puml/validated_monad.svg" alt="validated_monad.svg" /></p>
<div id="admonition-related-types" class="admonition admonish-note" role="note" aria-labelledby="admonition-related-types-title">
<div class="admonition-title">
<div id="admonition-related-types-title">
<p>Related Types</p>
</div>
<a class="admonition-anchor-link" href="monads/validated_monad.html#admonition-related-types"></a>
</div>
<div>
<p>Unlike <a href="monads/./either_monad.html">Either Monad</a> which is fail-fast in both Monad and Applicative contexts, <code>Validated</code> can be used with <code>Applicative</code> operations for error accumulation (when <code>E</code> has a <code>Semigroup</code> instance). When used as a Monad via <code>ValidatedMonad</code>, it behaves fail-fast like Either.</p>
</div>
</div>
<h2 id="how-to-use-validatedmonade-and-validatede-a"><a class="header" href="#how-to-use-validatedmonade-and-validatede-a">How to Use <code>ValidatedMonad&lt;E&gt;</code> and <code>Validated&lt;E, A&gt;</code></a></h2>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/validated/ValidatedMonadExample.java">ValidatedMonadExample.java</a></li>
</ul>
<h3 id="creating-instances-5"><a class="header" href="#creating-instances-5">Creating Instances</a></h3>
<p><code>Validated&lt;E, A&gt;</code> instances can be created directly using static factory methods on <code>Validated</code>. For HKT integration, <code>ValidatedKindHelper</code> and <code>ValidatedMonad</code> are used. <code>ValidatedKind&lt;E, A&gt;</code> is the HKT wrapper.</p>
<p><strong>Direct <code>Validated</code> Creation &amp; HKT Helpers:</strong> Refer to <code>ValidatedMonadExample.java</code> (Section 1) for runnable examples.</p>
<div id="admonition-creating-_valid_-_invalid_-and-hkt-wrappers" class="admonition admonish-note" role="note" aria-labelledby="admonition-creating-_valid_-_invalid_-and-hkt-wrappers-title">
<div class="admonition-title">
<div id="admonition-creating-_valid_-_invalid_-and-hkt-wrappers-title">
<p>Creating <em>Valid</em>, <em>Invalid</em> and HKT Wrappers</p>
</div>
<a class="admonition-anchor-link" href="monads/validated_monad.html#admonition-creating-_valid_-_invalid_-and-hkt-wrappers"></a>
</div>
<div>
<p>Creates a <code>Valid</code> instance holding a <strong>non-null</strong> value.</p>
<pre><code class="language-java">Validated&lt;List&lt;String&gt;, String&gt; validInstance = Validated.valid("Success!"); // Valid("Success!")
</code></pre>
<p>Creates an <code>Invalid</code> instance holding a <strong>non-null</strong> error.</p>
<pre><code class="language-java">Validated&lt;List&lt;String&gt;, String&gt; invalidInstance = Validated.invalid(Collections.singletonList("Error: Something went wrong.")); // Invalid([Error: Something went wrong.])
</code></pre>
<p>Converts a <code>Validated&lt;E, A&gt;</code> to <code>Kind&lt;ValidatedKind.Witness&lt;E&gt;, A&gt;</code> using <code>VALIDATED.widen()</code>.</p>
<pre><code class="language-java">Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, String&gt; kindValid = VALIDATED.widen(Validated.valid("Wrapped"));
</code></pre>
<p>Converts a <code>Kind&lt;ValidatedKind.Witness&lt;E&gt;, A&gt;</code> back to <code>Validated&lt;E, A&gt;</code> using <code>VALIDATED.narrow()</code>.</p>
<pre><code class="language-java">Validated&lt;List&lt;String&gt;, String&gt; narrowedValidated = VALIDATED.narrow(kindValid);
</code></pre>
<p>Convenience for <code>widen(Validated.valid(value))</code>using <code>VALIDATED.valid()</code>.</p>
<pre><code class="language-java">Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Integer&gt; kindValidInt = VALIDATED.valid(123);
</code></pre>
<p>Convenience for <code>widen(Validated.invalid(error))</code> using <code>VALIDATED.invalid()</code>.</p>
<pre><code class="language-java">Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Integer&gt; kindInvalidInt = VALIDATED.invalid(Collections.singletonList("Bad number"));
</code></pre>
</div>
</div>
<h3 id="validatedmonade-instance-methods"><a class="header" href="#validatedmonade-instance-methods"><code>ValidatedMonad&lt;E&gt;</code> Instance Methods:</a></h3>
<p>Refer to <code>ValidatedMonadExample.java</code> (Sections 1 &amp; 6) for runnable examples.</p>
<div id="admonition-_validatedmonadofa-value_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_validatedmonadofa-value_-title">
<div class="admonition-title">
<div id="admonition-_validatedmonadofa-value_-title">
<p><em>validatedMonad.of(A value)</em></p>
</div>
<a class="admonition-anchor-link" href="monads/validated_monad.html#admonition-_validatedmonadofa-value_"></a>
</div>
<div>
<p>Lifts a value into <code>ValidatedKind.Witness&lt;E&gt;</code>, creating a <code>Valid(value)</code>. This is part of the <code>Applicative</code> interface.</p>
<pre><code class="language-java">ValidatedMonad&lt;List&lt;String&gt;&gt; validatedMonad = ValidatedMonad.instance();
Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, String&gt; kindFromMonadOf = validatedMonad.of("Monadic Valid"); // Valid("Monadic Valid")
System.out.println("From monad.of(): " + VALIDATED.narrow(kindFromMonadOf));
</code></pre>
<p>Lifts an error <code>E</code> into the <code>ValidatedKind</code> context, creating an <code>Invalid(error)</code>. This is part of the <code>MonadError</code> interface.</p>
<pre><code class="language-java">ValidatedMonad&lt;List&lt;String&gt;&gt; validatedMonad = ValidatedMonad.instance();
List&lt;String&gt; errorPayload = Collections.singletonList("Raised error condition");
Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, String&gt; raisedError =
    validatedMonad.raiseError(errorPayload); // Invalid(["Raised error condition"])
System.out.println("From monad.raiseError(): " + VALIDATED.narrow(raisedError));
</code></pre>
</div>
</div>
<h3 id="interacting-with-validatede-a-values"><a class="header" href="#interacting-with-validatede-a-values">Interacting with <code>Validated&lt;E, A&gt;</code> values</a></h3>
<p>The <code>Validated&lt;E, A&gt;</code> interface itself provides useful methods: Refer to <code>ValidatedMonadExample.java</code> (Section 5) for runnable examples of <code>fold</code>, <code>ifValid</code>, <code>ifInvalid</code>.</p>
<ul>
<li><code>isValid()</code>: Returns <code>true</code> if it's a <code>Valid</code>.</li>
<li><code>isInvalid()</code>: Returns <code>true</code> if it's an <code>Invalid</code>.</li>
<li><code>get()</code>: Returns the value if <code>Valid</code>, otherwise throws <code>NoSuchElementException</code>. <em>Use with caution.</em></li>
<li><code>getError()</code>: Returns the error if <code>Invalid</code>, otherwise throws <code>NoSuchElementException</code>. <em>Use with caution.</em></li>
<li><code>orElse(@NonNull A other)</code>: Returns the value if <code>Valid</code>, otherwise returns <code>other</code>.</li>
<li><code>orElseGet(@NonNull Supplier&lt;? extends @NonNull A&gt; otherSupplier)</code>: Returns the value if <code>Valid</code>, otherwise invokes <code>otherSupplier.get()</code>.</li>
<li><code>orElseThrow(@NonNull Supplier&lt;? extends X&gt; exceptionSupplier)</code>: Returns the value if <code>Valid</code>, otherwise throws the exception from the supplier.</li>
<li><code>ifValid(@NonNull Consumer&lt;? super A&gt; consumer)</code>: Performs action if <code>Valid</code>.</li>
<li><code>ifInvalid(@NonNull Consumer&lt;? super E&gt; consumer)</code>: Performs action if <code>Invalid</code>.</li>
<li><code>fold(@NonNull Function&lt;? super E, ? extends T&gt; invalidMapper, @NonNull Function&lt;? super A, ? extends T&gt; validMapper)</code>: Applies one of two functions depending on the state.</li>
<li><code>Validated</code> also has its own <code>map</code>, <code>flatMap</code>, and <code>ap</code> methods that operate directly on <code>Validated</code> instances.</li>
</ul>
<h3 id="key-operations-via-validatedmonade"><a class="header" href="#key-operations-via-validatedmonade">Key Operations (via <code>ValidatedMonad&lt;E&gt;</code>)</a></h3>
<p>These operations are performed on the HKT wrapper <code>Kind&lt;ValidatedKind.Witness&lt;E&gt;, A&gt;</code>. Refer to <code>ValidatedMonadExample.java</code> (Sections 2, 3, 4) for runnable examples of <code>map</code>, <code>flatMap</code>, and <code>ap</code>.</p>
<p>Applies <code>f</code> to the value inside <code>kind</code> if it's <code>Valid</code>. If <code>kind</code> is <code>Invalid</code>, or if <code>f</code> throws an exception (The behaviour depends on <code>Validated.map</code> internal error handling, typically an <code>Invalid</code> from <code>Validated.map</code> would be a new <code>Invalid</code>), the result is <code>Invalid</code>.</p>
<div id="admonition-transforming-values-_map_" class="admonition admonish-note" role="note" aria-labelledby="admonition-transforming-values-_map_-title">
<div class="admonition-title">
<div id="admonition-transforming-values-_map_-title">
<p>Transforming Values (<em>map</em>)</p>
</div>
<a class="admonition-anchor-link" href="monads/validated_monad.html#admonition-transforming-values-_map_"></a>
</div>
<div>
<pre><code class="language-java">// From ValidatedMonadExample.java (Section 2)
ValidatedMonad&lt;List&lt;String&gt;&gt; validatedMonad = ValidatedMonad.instance();
Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Integer&gt; validKindFromOf = validatedMonad.of(42);
Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Integer&gt; invalidIntKind =
    VALIDATED.invalid(Collections.singletonList("Initial error for map"));

Function&lt;Integer, String&gt; intToString = i -&gt; "Value: " + i;

Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, String&gt; mappedValid =
    validatedMonad.map(intToString, validKindFromOf); // Valid("Value: 42")
System.out.println("Map (Valid input): " + VALIDATED.narrow(mappedValid));

Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, String&gt; mappedInvalid =
    validatedMonad.map(intToString, invalidIntKind); // Invalid(["Initial error for map"])
System.out.println("Map (Invalid input): " + VALIDATED.narrow(mappedInvalid));
</code></pre>
</div>
</div>
<div id="admonition-transforming-values-_flatmap_" class="admonition admonish-note" role="note" aria-labelledby="admonition-transforming-values-_flatmap_-title">
<div class="admonition-title">
<div id="admonition-transforming-values-_flatmap_-title">
<p>Transforming Values (<em>flatMap</em>)</p>
</div>
<a class="admonition-anchor-link" href="monads/validated_monad.html#admonition-transforming-values-_flatmap_"></a>
</div>
<div>
<p>If <code>kind</code> is <code>Valid(a)</code>, applies <code>f</code> to <code>a</code>. <code>f</code> must return a <code>Kind&lt;ValidatedKind.Witness&lt;E&gt;, B&gt;</code>. If <code>kind</code> is <code>Invalid</code>, or <code>f</code> returns an <code>Invalid Kind</code>, the result is <code>Invalid</code>.</p>
<pre><code class="language-java">// From ValidatedMonadExample.java (Section 3)
ValidatedMonad&lt;List&lt;String&gt;&gt; validatedMonad = ValidatedMonad.instance();
Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Integer&gt; positiveNumKind = validatedMonad.of(10);
Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Integer&gt; nonPositiveNumKind = validatedMonad.of(-5);
Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Integer&gt; invalidIntKind =
        VALIDATED.invalid(Collections.singletonList("Initial error for flatMap"));


Function&lt;Integer, Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, String&gt;&gt; intToValidatedStringKind =
    i -&gt; {
      if (i &gt; 0) {
        return VALIDATED.valid("Positive: " + i);
      } else {
        return VALIDATED.invalid(Collections.singletonList("Number not positive: " + i));
      }
    };

Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, String&gt; flatMappedToValid =
    validatedMonad.flatMap(intToValidatedStringKind, positiveNumKind); // Valid("Positive: 10")
System.out.println("FlatMap (Valid to Valid): " + VALIDATED.narrow(flatMappedToValid));

Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, String&gt; flatMappedToInvalid =
    validatedMonad.flatMap(intToValidatedStringKind, nonPositiveNumKind); // Invalid(["Number not positive: -5"])
System.out.println("FlatMap (Valid to Invalid): " + VALIDATED.narrow(flatMappedToInvalid));

Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, String&gt; flatMappedFromInvalid =
    validatedMonad.flatMap(intToValidatedStringKind, invalidIntKind); // Invalid(["Initial error for flatMap"])
System.out.println("FlatMap (Invalid input): " + VALIDATED.narrow(flatMappedFromInvalid));
</code></pre>
</div>
</div>
<div id="admonition-applicative-operation-ap" class="admonition admonish-note" role="note" aria-labelledby="admonition-applicative-operation-ap-title">
<div class="admonition-title">
<div id="admonition-applicative-operation-ap-title">
<p>Applicative Operation (ap)</p>
</div>
<a class="admonition-anchor-link" href="monads/validated_monad.html#admonition-applicative-operation-ap"></a>
</div>
<div>
<ul>
<li>If <code>ff</code> is <code>Valid(f)</code> and <code>fa</code> is <code>Valid(a)</code>, applies <code>f</code> to <code>a</code>, resulting in <code>Valid(f(a))</code>.</li>
<li>If either <code>ff</code> or <code>fa</code> is <code>Invalid</code>, the result is <code>Invalid</code>. Specifically, if <code>ff</code> is <code>Invalid</code>, its error is returned.</li>
<li>If <code>ff</code> is <code>Valid</code> but <code>fa</code> is <code>Invalid</code>, then <code>fa</code>'s error is returned. If both are <code>Invalid</code>, <code>ff</code>'s error takes precedence.</li>
</ul>
<p>Note: This <code>ap</code> behaviour is right-biased and does not accumulate errors in the way some applicative validations might; it propagates the first encountered <code>Invalid</code> or the <code>Invalid</code> function.</p>
<pre><code class="language-java">// From ValidatedMonadExample.java (Section 4)
ValidatedMonad&lt;List&lt;String&gt;&gt; validatedMonad = ValidatedMonad.instance();
Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Function&lt;Integer, String&gt;&gt; validFnKind =
    VALIDATED.valid(i -&gt; "Applied: " + (i * 2));
Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Function&lt;Integer, String&gt;&gt; invalidFnKind =
    VALIDATED.invalid(Collections.singletonList("Function is invalid"));

Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Integer&gt; validValueForAp = validatedMonad.of(25);
Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Integer&gt; invalidValueForAp =
    VALIDATED.invalid(Collections.singletonList("Value is invalid"));

// Valid function, Valid value
Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, String&gt; apValidFnValidVal =
    validatedMonad.ap(validFnKind, validValueForAp); // Valid("Applied: 50")
System.out.println("Ap (ValidFn, ValidVal): " + VALIDATED.narrow(apValidFnValidVal));

// Invalid function, Valid value
Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, String&gt; apInvalidFnValidVal =
    validatedMonad.ap(invalidFnKind, validValueForAp); // Invalid(["Function is invalid"])
System.out.println("Ap (InvalidFn, ValidVal): " + VALIDATED.narrow(apInvalidFnValidVal));

// Valid function, Invalid value
Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, String&gt; apValidFnInvalidVal =
    validatedMonad.ap(validFnKind, invalidValueForAp); // Invalid(["Value is invalid"])
System.out.println("Ap (ValidFn, InvalidVal): " + VALIDATED.narrow(apValidFnInvalidVal));

// Invalid function, Invalid value
Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, String&gt; apInvalidFnInvalidVal =
    validatedMonad.ap(invalidFnKind, invalidValueForAp); // Invalid(["Function is invalid"])
System.out.println("Ap (InvalidFn, InvalidVal): " + VALIDATED.narrow(apInvalidFnInvalidVal));
</code></pre>
</div>
</div>
<h3 id="monaderror-operations"><a class="header" href="#monaderror-operations">MonadError Operations</a></h3>
<p>As <code>ValidatedMonad&lt;E&gt;</code> implements <code>MonadError&lt;ValidatedKind.Witness&lt;E&gt;, E&gt;</code>, it provides standardised ways to create and handle errors. Refer to ValidatedMonadExample.java (Section 6) for detailed examples.</p>
<div id="admonition-_recover_-and-_recoverwith_" class="admonition admonish-note" role="note" aria-labelledby="admonition-_recover_-and-_recoverwith_-title">
<div class="admonition-title">
<div id="admonition-_recover_-and-_recoverwith_-title">
<p><em>recover</em> and <em>recoverWith</em></p>
</div>
<a class="admonition-anchor-link" href="monads/validated_monad.html#admonition-_recover_-and-_recoverwith_"></a>
</div>
<div>
<pre><code class="language-java">// From ValidatedMonadExample.java (Section 6)
ValidatedMonad&lt;List&lt;String&gt;&gt; validatedMonad = ValidatedMonad.instance();
List&lt;String&gt; initialError = Collections.singletonList("Initial Failure");

// 1. Create an Invalid Kind using raiseError
Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Integer&gt; invalidKindRaised = // Renamed to avoid conflict
    validatedMonad.raiseError(initialError);
System.out.println("Raised error: " + VALIDATED.narrow(invalidKindRaised)); // Invalid([Initial Failure])

// 2. Handle the error: recover to a Valid state
Function&lt;List&lt;String&gt;, Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Integer&gt;&gt; recoverToValid =
    errors -&gt; {
        System.out.println("MonadError: Recovery handler called with errors: " + errors);
        return validatedMonad.of(0); // Recover with default value 0
    };
Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Integer&gt; recoveredValid =
    validatedMonad.handleErrorWith(invalidKindRaised, recoverToValid);
System.out.println("Recovered to Valid: " + VALIDATED.narrow(recoveredValid)); // Valid(0)

// 3. Handle the error: transform to another Invalid state
Function&lt;List&lt;String&gt;, Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Integer&gt;&gt; transformError =
    errors -&gt; validatedMonad.raiseError(Collections.singletonList("Transformed Error: " + errors.get(0)));
Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Integer&gt; transformedInvalid =
    validatedMonad.handleErrorWith(invalidKindRaised, transformError);
System.out.println("Transformed to Invalid: " + VALIDATED.narrow(transformedInvalid)); // Invalid([Transformed Error: Initial Failure])

// 4. Handle a Valid Kind: handler is not called
Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Integer&gt; validKindOriginal = validatedMonad.of(100);
Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Integer&gt; notHandled =
    validatedMonad.handleErrorWith(validKindOriginal, recoverToValid); // Handler not called
System.out.println("Handling Valid (no change): " + VALIDATED.narrow(notHandled)); // Valid(100)

// 5. Using a default method like handleError
Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Integer&gt; errorForHandle = validatedMonad.raiseError(Collections.singletonList("Error for handleError"));
Function&lt;List&lt;String&gt;, Integer&gt; plainValueRecoveryHandler = errors -&gt; -1; // Returns plain value
Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Integer&gt; recoveredWithHandle = validatedMonad.handleError(errorForHandle, plainValueRecoveryHandler);
System.out.println("Recovered with handleError: " + VALIDATED.narrow(recoveredWithHandle)); // Valid(-1)
</code></pre>
<p>The default <code>recover</code> and <code>recoverWith</code> methods from <code>MonadError</code> are also available.</p>
</div>
</div>
<div id="admonition-combining-operations-for-simple-validation" class="admonition admonish-note" role="note" aria-labelledby="admonition-combining-operations-for-simple-validation-title">
<div class="admonition-title">
<div id="admonition-combining-operations-for-simple-validation-title">
<p>Combining operations for simple validation</p>
</div>
<a class="admonition-anchor-link" href="monads/validated_monad.html#admonition-combining-operations-for-simple-validation"></a>
</div>
<div>
<p>This example demonstrates how <code>ValidatedMonad</code> along with <code>Validated</code> can be used to chain operations that might succeed or fail. With <code>ValidatedMonad</code> now implementing <code>MonadError</code>, operations like <code>raiseError</code> can be used for clearer error signaling, and <code>handleErrorWith</code> (or other <code>MonadError</code> methods) can be used for more robust recovery strategies within such validation flows.</p>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/validated/ValidatedMonadExample.java">ValidatedMonadExample.java</a> <em>see "Combined Validation Scenario"</em>.</li>
</ul>
<pre><code class="language-java">// Simplified from the ValidatedMonadExample.java
public void combinedValidationScenarioWithMonadError() {
  ValidatedMonad&lt;List&lt;String&gt;&gt; validatedMonad = ValidatedMonad.instance();
  Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, String&gt; userInput1 = validatedMonad.of("123");
  Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, String&gt; userInput2 = validatedMonad.of("abc"); // This will lead to an Invalid

  Function&lt;String, Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Integer&gt;&gt; parseToIntKindMonadError =
      (String s) -&gt; {
        try {
          return validatedMonad.of(Integer.parseInt(s)); // Lifts to Valid
        } catch (NumberFormatException e) {
          // Using raiseError for semantic clarity
          return validatedMonad.raiseError(
              Collections.singletonList("'" + s + "' is not a number (via raiseError)."));
        }
      };

  Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Integer&gt; parsed1 =
      validatedMonad.flatMap(parseToIntKindMonadError, userInput1);
  Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Integer&gt; parsed2 =
      validatedMonad.flatMap(parseToIntKindMonadError, userInput2); // Will be Invalid

  System.out.println("Parsed Input 1 (Combined): " + VALIDATED.narrow(parsed1)); // Valid(123)
  System.out.println("Parsed Input 2 (Combined): " + VALIDATED.narrow(parsed2)); // Invalid(['abc' is not a number...])

  // Example of recovering the parse of userInput2 using handleErrorWith
  Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Integer&gt; parsed2Recovered =
      validatedMonad.handleErrorWith(
          parsed2,
          errors -&gt; {
            System.out.println("Combined scenario recovery: " + errors);
            return validatedMonad.of(0); // Default to 0 if parsing failed
          });
  System.out.println(
      "Parsed Input 2 (Recovered to 0): " + VALIDATED.narrow(parsed2Recovered)); // Valid(0)
}
</code></pre>
<p>This example demonstrates how <code>ValidatedMonad</code> along with <code>Validated</code> can be used to chain operations that might succeed or fail, propagating errors and allowing for clear handling of either outcome, further enhanced by <code>MonadError</code> capabilities.</p>
</div>
</div><div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="the-writermonad"><a class="header" href="#the-writermonad">The WriterMonad:</a></h1>
<h2 id="accumulating-output-alongside-computations"><a class="header" href="#accumulating-output-alongside-computations"><em>Accumulating Output Alongside Computations</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="monads/writer_monad.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to accumulate logs or output alongside your main computation</li>
<li>Understanding the role of Monoid in combining accumulated values</li>
<li>Building detailed audit trails and debugging information</li>
<li>Using <code>tell</code> for pure logging and <code>listen</code> for capturing output</li>
<li>Creating calculations that produce both results and comprehensive logs</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code:</p>
</div>
<a class="admonition-anchor-link" href="monads/writer_monad.html#admonition-see-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/writer/WriterExample.java">WriterExample.java</a></p>
</div>
</div>
<h2 id="purpose-10"><a class="header" href="#purpose-10">Purpose</a></h2>
<p>The <strong>Writer monad</strong> is a functional pattern designed for computations that, in addition to producing a primary result value, also need to <strong>accumulate</strong> some secondary output or log along the way. Think of scenarios like:</p>
<ul>
<li>Detailed logging of steps within a complex calculation.</li>
<li>Collecting metrics or events during a process.</li>
<li>Building up a sequence of results or messages.</li>
</ul>
<p>A <code>Writer&lt;W, A&gt;</code> represents a computation that produces a main result of type <code>A</code> and simultaneously accumulates an output of type <code>W</code>. The key requirement is that the accumulated type <code>W</code> must form a <strong>Monoid</strong>.</p>
<h3 id="the-role-of-monoidw"><a class="header" href="#the-role-of-monoidw">The Role of <code>Monoid&lt;W&gt;</code></a></h3>
<p>A <code>Monoid&lt;W&gt;</code> is a type class that defines two things for type <code>W</code>:</p>
<ol>
<li><code>empty()</code>: Provides an identity element (like <code>""</code> for String concatenation, <code>0</code> for addition, or an empty list).</li>
<li><code>combine(W w1, W w2)</code>: Provides an <strong>associative</strong> binary operation to combine two values of type <code>W</code> (like <code>+</code> for strings or numbers, or list concatenation).</li>
</ol>
<p>The Writer monad uses the <code>Monoid&lt;W&gt;</code> to:</p>
<ul>
<li>Provide a starting point (the <code>empty</code> value) for the accumulation.</li>
<li>Combine the accumulated outputs (<code>W</code>) from different steps using the <code>combine</code> operation when sequencing computations with <code>flatMap</code> or <code>ap</code>.</li>
</ul>
<p>Common examples for <code>W</code> include <code>String</code> (using concatenation), <code>Integer</code> (using addition or multiplication), or <code>List</code> (using concatenation).</p>
<h2 id="structure-8"><a class="header" href="#structure-8">Structure</a></h2>
<p>The <code>Writer&lt;W, A&gt;</code> record directly implements <code>WriterKind&lt;W, A&gt;</code>, which in turn extends <code>Kind&lt;WriterKind.Witness&lt;W&gt;, A&gt;</code>.</p>
<p><img src="monads/../images/puml/writer.svg" alt="writer.svg" /></p>
<h2 id="the-writerw-a-type"><a class="header" href="#the-writerw-a-type">The <code>Writer&lt;W, A&gt;</code> Type</a></h2>
<p>The core type is the <code>Writer&lt;W, A&gt;</code> record:</p>
<pre><code class="language-java">// From: org.higherkindedj.hkt.writer.Writer
public record Writer&lt;W, A&gt;(@NonNull W log, @Nullable A value) implements WriterKind&lt;W, A&gt; {
  // Static factories
  public static &lt;W, A&gt; @NonNull Writer&lt;W, A&gt; create(@NonNull W log, @Nullable A value);
  public static &lt;W, A&gt; @NonNull Writer&lt;W, A&gt; value(@NonNull Monoid&lt;W&gt; monoidW, @Nullable A value); // Creates (monoidW.empty(), value)
  public static &lt;W&gt; @NonNull Writer&lt;W, Unit&gt; tell(@NonNull W log); // Creates (log, Unit.INSTANCE) 

  // Instance methods (primarily for direct use, HKT versions via Monad instance)
  public &lt;B&gt; @NonNull Writer&lt;W, B&gt; map(@NonNull Function&lt;? super A, ? extends B&gt; f);
  public &lt;B&gt; @NonNull Writer&lt;W, B&gt; flatMap(
          @NonNull Monoid&lt;W&gt; monoidW, // Monoid needed for combining logs
          @NonNull Function&lt;? super A, ? extends Writer&lt;W, ? extends B&gt;&gt; f
  );
  public @Nullable A run(); // Get the value A, discard log
  public @NonNull W exec(); // Get the log W, discard value
}
</code></pre>
<ul>
<li>It simply holds a pair: the accumulated <code>log</code> (of type <code>W</code>) and the computed <code>value</code> (of type <code>A</code>).</li>
<li><code>create(log, value)</code>: Basic constructor.</li>
<li><code>value(monoid, value)</code>: Creates a Writer with the given value and an <em>empty</em> log according to the provided <code>Monoid</code>.</li>
<li><code>tell(log)</code>: Creates a Writer with the given log, and <code>Unit.INSTANCE</code> as it's  value, signifying that the operation's primary purpose is the accumulation of the log. Useful for just adding to the log. (Note: The original <code>Writer.java</code> might have <code>tell(W log)</code> and infer monoid elsewhere, or <code>WriterMonad</code> handles <code>tell</code>).</li>
<li><code>map(...)</code>: Transforms the computed value <code>A</code> to <code>B</code> while leaving the log <code>W</code> untouched.</li>
<li><code>flatMap(...)</code>: Sequences computations. It runs the first Writer, uses its value <code>A</code> to create a second Writer, and combines the logs from both using the provided <code>Monoid</code>.</li>
<li><code>run()</code>: Extracts only the computed value <code>A</code>, discarding the log.</li>
<li><code>exec()</code>: Extracts only the accumulated log <code>W</code>, discarding the value.</li>
</ul>
<h2 id="writer-components"><a class="header" href="#writer-components">Writer Components</a></h2>
<p>To integrate <code>Writer</code> with Higher-Kinded-J:</p>
<ul>
<li><code>WriterKind&lt;W, A&gt;</code>: The HKT interface. <code>Writer&lt;W, A&gt;</code> itself implements <code>WriterKind&lt;W, A&gt;</code>. <code>WriterKind&lt;W, A&gt;</code> extends <code>Kind&lt;WriterKind.Witness&lt;W&gt;, A&gt;</code>.
<ul>
<li>It contains a nested <code>final class Witness&lt;LOG_W&gt; {}</code> which serves as the phantom type <code>F_WITNESS</code> for <code>Writer&lt;LOG_W, ?&gt;</code>.</li>
</ul>
</li>
<li><strong><code>WriterKindHelper</code></strong>: The utility class with static methods:
<ul>
<li><code>widen(Writer&lt;W, A&gt;)</code>: Converts a <code>Writer</code> to <code>Kind&lt;WriterKind.Witness&lt;W&gt;, A&gt;</code>. Since <code>Writer</code> directly implements <code>WriterKind</code>, this is effectively a checked cast.</li>
<li><code>narrow(Kind&lt;WriterKind.Witness&lt;W&gt;, A&gt;)</code>: Converts <code>Kind</code> back to <code>Writer&lt;W,A&gt;</code>. This is also effectively a checked cast after an <code>instanceof Writer</code> check.</li>
<li><code>value(Monoid&lt;W&gt; monoid, A value)</code>: Factory method for a <code>Kind</code> representing a <code>Writer</code> with an empty log.</li>
<li><code>tell(W log)</code>: Factory method for a <code>Kind</code> representing a <code>Writer</code> that only logs.</li>
<li><code>runWriter(Kind&lt;WriterKind.Witness&lt;W&gt;, A&gt;)</code>: Unwraps to <code>Writer&lt;W,A&gt;</code> and returns the record itself.</li>
<li><code>run(Kind&lt;WriterKind.Witness&lt;W&gt;, A&gt;)</code>: Executes (unwraps) and returns only the value <code>A</code>.</li>
<li><code>exec(Kind&lt;WriterKind.Witness&lt;W&gt;, A&gt;)</code>: Executes (unwraps) and returns only the log <code>W</code>.</li>
</ul>
</li>
</ul>
<h2 id="type-class-instances-writerfunctor-writerapplicative-writermonad"><a class="header" href="#type-class-instances-writerfunctor-writerapplicative-writermonad">Type Class Instances (<code>WriterFunctor</code>, <code>WriterApplicative</code>, <code>WriterMonad</code>)</a></h2>
<p>These classes provide the standard functional operations for <code>Kind&lt;WriterKind.Witness&lt;W&gt;, A&gt;</code>, allowing you to treat <code>Writer</code> computations generically. <strong>Crucially, <code>WriterApplicative&lt;W&gt;</code> and <code>WriterMonad&lt;W&gt;</code> require a <code>Monoid&lt;W&gt;</code> instance during construction.</strong></p>
<ul>
<li><code>WriterFunctor&lt;W&gt;</code>: Implements <code>Functor&lt;WriterKind.Witness&lt;W&gt;&gt;</code>. Provides <code>map</code> (operates only on the value <code>A</code>).</li>
<li><strong><code>WriterApplicative&lt;W&gt;</code></strong>: Extends <code>WriterFunctor&lt;W&gt;</code>, implements <code>Applicative&lt;WriterKind.Witness&lt;W&gt;&gt;</code>. Requires a <code>Monoid&lt;W&gt;</code>. Provides <code>of</code> (lifting a value with an empty log) and <code>ap</code> (applying a wrapped function to a wrapped value, combining logs).</li>
<li><strong><code>WriterMonad&lt;W&gt;</code></strong>: Extends <code>WriterApplicative&lt;W&gt;</code>, implements <code>Monad&lt;WriterKind.Witness&lt;W&gt;&gt;</code>. Requires a <code>Monoid&lt;W&gt;</code>. Provides <code>flatMap</code> for sequencing computations, automatically combining logs using the <code>Monoid</code>.</li>
</ul>
<div id="admonition-example-logging-a-complex-calculation" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-logging-a-complex-calculation-title">
<div class="admonition-title">
<div id="admonition-example-logging-a-complex-calculation-title">
<p>Example: Logging a complex calculation</p>
</div>
<a class="admonition-anchor-link" href="monads/writer_monad.html#admonition-example-logging-a-complex-calculation"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/writer/WriterExample.java">WriterExample.java</a></li>
</ul>
<p>You typically instantiate <code>WriterMonad&lt;W&gt;</code> for the specific log type <code>W</code> and its corresponding <code>Monoid</code>.</p>
<h3 id="1-choose-your-log-type-w-and-monoidw"><a class="header" href="#1-choose-your-log-type-w-and-monoidw">1. Choose Your Log Type <code>W</code> and <code>Monoid&lt;W&gt;</code></a></h3>
<p>Decide what you want to accumulate (e.g., <code>String</code> for logs, <code>List&lt;String&gt;</code> for messages, <code>Integer</code> for counts) and get its <code>Monoid</code>.</p>
<pre><code class="language-java">
class StringMonoid implements Monoid&lt;String&gt; {
  @Override public String empty() { return ""; }
  @Override public String combine(String x, String y) { return x + y; }
}

Monoid&lt;String&gt; stringMonoid = new StringMonoid(); 
</code></pre>
<h3 id="2-get-the-writermonad-instance"><a class="header" href="#2-get-the-writermonad-instance">2. Get the <code>WriterMonad</code> Instance</a></h3>
<p>Instantiate the monad for your chosen log type <code>W</code>, providing its <code>Monoid</code>.</p>
<pre><code class="language-java">import org.higherkindedj.hkt.writer.WriterMonad;

// Monad instance for computations logging Strings
// F_WITNESS here is WriterKind.Witness&lt;String&gt;
WriterMonad&lt;String&gt; writerMonad = new WriterMonad&lt;&gt;(stringMonoid);

</code></pre>
<h3 id="3-create-writer-computations"><a class="header" href="#3-create-writer-computations">3. Create Writer Computations</a></h3>
<p>Use <code>WriterKindHelper</code> factory methods, providing the <code>Monoid</code> where needed. The result is <code>Kind&lt;WriterKind.Witness&lt;W&gt;, A&gt;</code>.</p>
<pre><code class="language-java">
// Writer with an initial value and empty log
Kind&lt;WriterKind.Witness&lt;String&gt;, Integer&gt; initialValue = WRITER.value(stringMonoid, 5); // Log: "", Value: 5

// Writer that just logs a message (value is Unit.INSTANCE)
Kind&lt;WriterKind.Witness&lt;String&gt;, Unit&gt; logStart = WRITER.tell("Starting calculation; "); // Log: "Starting calculation; ", Value: ()

// A function that performs a calculation and logs its step
Function&lt;Integer, Kind&lt;WriterKind.Witness&lt;String&gt;, Integer&gt;&gt; addAndLog =
        x -&gt; {
          int result = x + 10;
          String logMsg = "Added 10 to " + x + " -&gt; " + result + "; ";
          // Create a Writer directly then wrap with helper or use helper factory
          return WRITER.widen(Writer.create(logMsg, result));
        };

Function&lt;Integer, Kind&lt;WriterKind.Witness&lt;String&gt;, String&gt;&gt; multiplyAndLogToString =
        x -&gt; {
          int result = x * 2;
          String logMsg = "Multiplied " + x + " by 2 -&gt; " + result + "; ";
          return WRITER.widen(Writer.create(logMsg, "Final:" + result));
        };

</code></pre>
<h3 id="4-compose-computations-using-map-and-flatmap-2"><a class="header" href="#4-compose-computations-using-map-and-flatmap-2">4. Compose Computations using <code>map</code> and <code>flatMap</code></a></h3>
<p>Use the methods on the <code>writerMonad</code> instance. <code>flatMap</code> automatically combines logs using the <code>Monoid</code>.</p>
<pre><code class="language-java">// Chain the operations:
// Start with a pure value 0 in the Writer context (empty log)
Kind&lt;WriterKind.Witness&lt;String&gt;, Integer&gt; computationStart = writerMonad.of(0);

// 1. Log the start
Kind&lt;WriterKind.Witness&lt;String&gt;, Integer&gt; afterLogStart  = writerMonad.flatMap(ignoredUnit -&gt; initialValue, logStart);

Kind&lt;WriterKind.Witness&lt;String&gt;, Integer&gt; step1Value = WRITER.value(stringMonoid, 5); // ("", 5)
Kind&lt;WriterKind.Witness&lt;String&gt;, Unit&gt; step1Log = WRITER.tell("Initial value set to 5; "); // ("Initial value set to 5; ", ())


// Start -&gt; log -&gt; transform value -&gt; log -&gt; transform value ...
Kind&lt;WriterKind.Witness&lt;String&gt;, Integer&gt; calcPart1 = writerMonad.flatMap(
        ignored -&gt; addAndLog.apply(5), // Apply addAndLog to 5, after logging "start"
        WRITER.tell("Starting with 5; ")
);
// calcPart1: Log: "Starting with 5; Added 10 to 5 -&gt; 15; ", Value: 15

Kind&lt;WriterKind.Witness&lt;String&gt;, String&gt; finalComputation = writerMonad.flatMap(
        intermediateValue -&gt; multiplyAndLogToString.apply(intermediateValue),
        calcPart1
);
// finalComputation: Log: "Starting with 5; Added 10 to 5 -&gt; 15; Multiplied 15 by 2 -&gt; 30; ", Value: "Final:30"


// Using map: Only transforms the value, log remains unchanged from the input Kind
Kind&lt;WriterKind.Witness&lt;String&gt;, Integer&gt; initialValForMap = value(stringMonoid, 100); // Log: "", Value: 100
Kind&lt;WriterKind.Witness&lt;String&gt;, String&gt; mappedVal = writerMonad.map(
        i -&gt; "Value is " + i,
        initialValForMap
); // Log: "", Value: "Value is 100"
</code></pre>
<h3 id="5-run-the-computation-and-extract-results"><a class="header" href="#5-run-the-computation-and-extract-results">5. Run the Computation and Extract Results</a></h3>
<p>Use <code>WRITER.runWriter</code>, <code>WRITER.run</code>, or <code>WRITER.exec</code> from <code>WriterKindHelper</code>.</p>
<pre><code class="language-java">
import org.higherkindedj.hkt.writer.Writer; 

// Get the final Writer record (log and value)
Writer&lt;String, String&gt; finalResultWriter = runWriter(finalComputation);
String finalLog = finalResultWriter.log();
String finalValue = finalResultWriter.value();

System.out.println("Final Log: " + finalLog);
// Output: Final Log: Starting with 5; Added 10 to 5 -&gt; 15; Multiplied 15 by 2 -&gt; 30;
System.out.println("Final Value: " + finalValue);
// Output: Final Value: Final:30

// Or get only the value or log
String justValue = WRITER.run(finalComputation); // Extracts value from finalResultWriter
String justLog = WRITER.exec(finalComputation);  // Extracts log from finalResultWriter

System.out.println("Just Value: " + justValue); // Output: Just Value: Final:30
System.out.println("Just Log: " + justLog);     // Output: Just Log: Starting with 5; Added 10 to 5 -&gt; 15; Multiplied 15 by 2 -&gt; 30;

Writer&lt;String, String&gt; mappedResult = WRITER.runWriter(mappedVal);
System.out.println("Mapped Log: " + mappedResult.log());   // Output: Mapped Log
System.out.println("Mapped Value: " + mappedResult.value()); // Output: Mapped Value: Value is 100
</code></pre>
</div>
</div>
<div id="admonition-key-points" class="admonition admonish-tip" role="note" aria-labelledby="admonition-key-points-title">
<div class="admonition-title">
<div id="admonition-key-points-title">
<p>Key Points:</p>
</div>
<a class="admonition-anchor-link" href="monads/writer_monad.html#admonition-key-points"></a>
</div>
<div>
<p>The Writer monad (<code>Writer&lt;W, A&gt;</code>, <code>WriterKind.Witness&lt;W&gt;</code>, <code>WriterMonad&lt;W&gt;</code>) in <code>Higher-Kinded-J</code> provides a structured way to perform computations that produce a main value (<code>A</code>) while simultaneously accumulating some output (<code>W</code>, like logs or metrics).</p>
<p>It relies on a <code>Monoid&lt;W&gt;</code> instance to combine the accumulated outputs when sequencing steps with <code>flatMap</code>. This pattern helps separate the core computation logic from the logging/accumulation aspect, leading to cleaner, more composable code.</p>
<p>The Higher-Kinded-J enables these operations to be performed generically using standard type class interfaces, with <code>Writer&lt;W,A&gt;</code> directly implementing <code>WriterKind&lt;W,A&gt;</code>.</p>
</div>
</div><div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="the-const-type-constant-functors-with-phantom-types"><a class="header" href="#the-const-type-constant-functors-with-phantom-types">The Const Type: Constant Functors with Phantom Types</a></h1>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="monads/const_type.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>Understanding phantom types and how Const ignores its second type parameter</li>
<li>Using Const for efficient fold implementations and data extraction</li>
<li>Leveraging Const with bifunctor operations to transform constant values</li>
<li>Applying Const in lens and traversal patterns for compositional getters</li>
<li>Real-world use cases in validation, accumulation, and data mining</li>
<li>How Const relates to Scala's Const and van Laarhoven lenses</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code:</p>
</div>
<a class="admonition-anchor-link" href="monads/const_type.html#admonition-see-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/constant/ConstExample.java">ConstExample.java</a></p>
</div>
</div>
<p>The <code>Const</code> type is a constant functor that holds a value of type <code>C</code> whilst treating <code>A</code> as a <strong>phantom type parameter</strong>‚Äîa type that exists only in the type signature but has no runtime representation. This seemingly simple property unlocks powerful patterns for accumulating values, implementing efficient folds, and building compositional getters in the style of van Laarhoven lenses.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="monads/const_type.html#admonition-note"></a>
</div>
<div>
<p>New to phantom types? See the <a href="monads/../glossary.html#phantom-type">Glossary</a> for a detailed explanation with Java-focused examples, or continue reading for practical demonstrations.</p>
</div>
</div>
<hr />
<h2 id="what-is-const"><a class="header" href="#what-is-const">What is Const?</a></h2>
<p>A <code>Const&lt;C, A&gt;</code> is a container that holds a single value of type <code>C</code>. The type parameter <code>A</code> is phantom‚Äîit influences the type signature for composition and type safety but doesn't correspond to any stored data. This asymmetry is the key to Const's utility.</p>
<pre><code class="language-java">// Create a Const holding a String, with Integer as the phantom type
Const&lt;String, Integer&gt; stringConst = new Const&lt;&gt;("Hello");

// The constant value is always accessible
String value = stringConst.value(); // "Hello"

// Create a Const holding a count, with Person as the phantom type
Const&lt;Integer, Person&gt; countConst = new Const&lt;&gt;(42);
int count = countConst.value(); // 42
</code></pre>
<h3 id="key-characteristics"><a class="header" href="#key-characteristics">Key Characteristics</a></h3>
<ul>
<li><strong>Constant value</strong>: Holds a value of type <code>C</code> that can be retrieved via <code>value()</code></li>
<li><strong>Phantom type</strong>: The type parameter <code>A</code> exists only for type-level composition</li>
<li><strong>Bifunctor instance</strong>: Implements <code>Bifunctor&lt;ConstKind2.Witness&gt;</code> where:
<ul>
<li><code>first(f, const)</code> transforms the constant value</li>
<li><code>second(g, const)</code> changes only the phantom type, leaving the constant value unchanged</li>
<li><code>bimap(f, g, const)</code> combines both transformations (but only <code>f</code> affects the constant)</li>
</ul>
</li>
</ul>
<hr />
<h2 id="core-components-4"><a class="header" href="#core-components-4">Core Components</a></h2>
<p><strong>The Const Type</strong></p>
<pre><code class="language-java">public record Const&lt;C, A&gt;(C value) {
  public &lt;D&gt; Const&lt;D, A&gt; mapFirst(Function&lt;? super C, ? extends D&gt; firstMapper);
  public &lt;B&gt; Const&lt;C, B&gt; mapSecond(Function&lt;? super A, ? extends B&gt; secondMapper);
  public &lt;D, B&gt; Const&lt;D, B&gt; bimap(
      Function&lt;? super C, ? extends D&gt; firstMapper,
      Function&lt;? super A, ? extends B&gt; secondMapper);
}
</code></pre>
<p><strong>The HKT Bridge for Const</strong></p>
<ul>
<li><strong><code>ConstKind2&lt;C, A&gt;</code></strong>: The HKT marker interface extending <code>Kind2&lt;ConstKind2.Witness, C, A&gt;</code></li>
<li><strong><code>ConstKind2.Witness</code></strong>: The phantom type witness for Const in the Kind2 system</li>
<li><strong><code>ConstKindHelper</code></strong>: Utility providing <code>widen2</code> and <code>narrow2</code> for Kind2 conversions</li>
</ul>
<p><strong>Type Classes for Const</strong></p>
<ul>
<li><strong><code>ConstBifunctor</code></strong>: The singleton bifunctor instance implementing <code>Bifunctor&lt;ConstKind2.Witness&gt;</code></li>
</ul>
<hr />
<h2 id="the-phantom-type-property"><a class="header" href="#the-phantom-type-property">The Phantom Type Property</a></h2>
<p>The defining characteristic of <code>Const</code> is that mapping over the second type parameter has <strong>no effect</strong> on the constant value. This property is enforced both conceptually and at runtime.</p>
<div id="admonition-example-phantom-type-transformations" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-phantom-type-transformations-title">
<div class="admonition-title">
<div id="admonition-example-phantom-type-transformations-title">
<p>Example: Phantom Type Transformations</p>
</div>
<a class="admonition-anchor-link" href="monads/const_type.html#admonition-example-phantom-type-transformations"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/constant/ConstExample.java">ConstExample.java</a></p>
<pre><code class="language-java">import static org.higherkindedj.hkt.constant.ConstKindHelper.CONST;

Bifunctor&lt;ConstKind2.Witness&gt; bifunctor = ConstBifunctor.INSTANCE;

// Start with a Const holding an integer count
Const&lt;Integer, String&gt; original = new Const&lt;&gt;(42);
System.out.println("Original value: " + original.value());
// Output: 42

// Use second() to change the phantom type from String to Double
Kind2&lt;ConstKind2.Witness, Integer, Double&gt; transformed =
    bifunctor.second(
        s -&gt; s.length() * 2.0, // Function defines phantom type transformation
        CONST.widen2(original));

Const&lt;Integer, Double&gt; result = CONST.narrow2(transformed);
System.out.println("After second(): " + result.value());
// Output: 42 (UNCHANGED!)

// The phantom type changed (String -&gt; Double), but the constant value stayed 42
</code></pre>
<p><strong>Note:</strong> Whilst the mapper function in <code>second()</code> is never applied to actual data (since <code>A</code> is phantom), it is still validated and applied to <code>null</code> for exception propagation. This maintains consistency with bifunctor exception semantics.</p>
</div>
</div>
<hr />
<h2 id="const-as-a-bifunctor"><a class="header" href="#const-as-a-bifunctor">Const as a Bifunctor</a></h2>
<p><code>Const</code> naturally implements the <code>Bifunctor</code> type class, providing three fundamental operations:</p>
<h3 id="1-first---transform-the-constant-value"><a class="header" href="#1-first---transform-the-constant-value">1. <code>first()</code> - Transform the Constant Value</a></h3>
<p>The <code>first</code> operation transforms the <strong>constant value</strong> from type <code>C</code> to type <code>D</code>, leaving the phantom type unchanged.</p>
<pre><code class="language-java">Const&lt;String, Integer&gt; stringConst = new Const&lt;&gt;("hello");

// Transform the constant value from String to Integer
Kind2&lt;ConstKind2.Witness, Integer, Integer&gt; lengthConst =
    bifunctor.first(String::length, CONST.widen2(stringConst));

Const&lt;Integer, Integer&gt; result = CONST.narrow2(lengthConst);
System.out.println(result.value()); // Output: 5
</code></pre>
<h3 id="2-second---transform-only-the-phantom-type"><a class="header" href="#2-second---transform-only-the-phantom-type">2. <code>second()</code> - Transform Only the Phantom Type</a></h3>
<p>The <code>second</code> operation changes the <strong>phantom type</strong> from <code>A</code> to <code>B</code> without affecting the constant value.</p>
<pre><code class="language-java">Const&lt;String, Integer&gt; stringConst = new Const&lt;&gt;("constant");

// Change the phantom type from Integer to Boolean
Kind2&lt;ConstKind2.Witness, String, Boolean&gt; boolConst =
    bifunctor.second(i -&gt; i &gt; 10, CONST.widen2(stringConst));

Const&lt;String, Boolean&gt; result = CONST.narrow2(boolConst);
System.out.println(result.value()); // Output: "constant" (unchanged)
</code></pre>
<h3 id="3-bimap---transform-both-simultaneously"><a class="header" href="#3-bimap---transform-both-simultaneously">3. <code>bimap()</code> - Transform Both Simultaneously</a></h3>
<p>The <code>bimap</code> operation combines both transformations, but remember: only the first function affects the constant value.</p>
<pre><code class="language-java">Const&lt;String, Integer&gt; original = new Const&lt;&gt;("hello");

Kind2&lt;ConstKind2.Witness, Integer, String&gt; transformed =
    bifunctor.bimap(
        String::length,          // Transforms constant: "hello" -&gt; 5
        i -&gt; "Number: " + i,     // Phantom type transformation only
        CONST.widen2(original));

Const&lt;Integer, String&gt; result = CONST.narrow2(transformed);
System.out.println(result.value()); // Output: 5
</code></pre>
<hr />
<h2 id="use-case-1-efficient-fold-implementations"><a class="header" href="#use-case-1-efficient-fold-implementations">Use Case 1: Efficient Fold Implementations</a></h2>
<p>One of the most practical applications of <code>Const</code> is implementing folds that accumulate a single value whilst traversing a data structure. The phantom type represents the "shape" being traversed, whilst the constant value accumulates the result.</p>
<div id="admonition-example-folding-with-const" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-folding-with-const-title">
<div class="admonition-title">
<div id="admonition-example-folding-with-const-title">
<p>Example: Folding with Const</p>
</div>
<a class="admonition-anchor-link" href="monads/const_type.html#admonition-example-folding-with-const"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/constant/ConstExample.java">ConstExample.java</a></p>
<pre><code class="language-java">// Count elements in a list using Const
List&lt;String&gt; items = List.of("apple", "banana", "cherry", "date");

Const&lt;Integer, String&gt; count = items.stream()
    .reduce(
        new Const&lt;&gt;(0),                                           // Initial count
        (acc, item) -&gt; new Const&lt;Integer, String&gt;(acc.value() + 1), // Increment
        (c1, c2) -&gt; new Const&lt;&gt;(c1.value() + c2.value()));        // Combine

System.out.println("Count: " + count.value());
// Output: 4

// Accumulate total length of all strings
Const&lt;Integer, String&gt; totalLength = items.stream()
    .reduce(
        new Const&lt;&gt;(0),
        (acc, item) -&gt; new Const&lt;Integer, String&gt;(acc.value() + item.length()),
        (c1, c2) -&gt; new Const&lt;&gt;(c1.value() + c2.value()));

System.out.println("Total length: " + totalLength.value());
// Output: 23
</code></pre>
<p>In this pattern, the phantom type (<code>String</code>) represents the type of elements we're folding over, whilst the constant value (<code>Integer</code>) accumulates the result. This mirrors the implementation of folds in libraries like <a href="https://typelevel.org/cats/datatypes/const.html">Cats</a> and <a href="https://github.com/scalaz/scalaz">Scalaz</a> in Scala.</p>
</div>
</div>
<hr />
<h2 id="use-case-2-getters-and-van-laarhoven-lenses"><a class="header" href="#use-case-2-getters-and-van-laarhoven-lenses">Use Case 2: Getters and Van Laarhoven Lenses</a></h2>
<p><code>Const</code> is fundamental to the lens pattern pioneered by Edward Kmett and popularised in Scala libraries like <a href="https://www.optics.dev/Monocle/">Monocle</a>. A lens is an abstraction for focusing on a part of a data structure, and <code>Const</code> enables the "getter" half of this abstraction.</p>
<h3 id="the-getter-pattern"><a class="header" href="#the-getter-pattern">The Getter Pattern</a></h3>
<p>A getter extracts a field from a structure without transforming it. Using <code>Const</code>, we represent this as a function that produces a <code>Const</code> where the phantom type tracks the source structure.</p>
<div id="admonition-example-compositional-getters" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-compositional-getters-title">
<div class="admonition-title">
<div id="admonition-example-compositional-getters-title">
<p>Example: Compositional Getters</p>
</div>
<a class="admonition-anchor-link" href="monads/const_type.html#admonition-example-compositional-getters"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/constant/ConstExample.java">ConstExample.java</a></p>
<pre><code class="language-java">record Person(String name, int age, String city) {}
record Company(String name, Person ceo) {}

Person alice = new Person("Alice", 30, "London");
Company acmeCorp = new Company("ACME Corp", alice);

// Define a getter using Const
Function&lt;Person, Const&lt;String, Person&gt;&gt; nameGetter =
    person -&gt; new Const&lt;&gt;(person.name());

// Extract the name
Const&lt;String, Person&gt; nameConst = nameGetter.apply(alice);
System.out.println("CEO name: " + nameConst.value());
// Output: Alice

// Define a getter for the CEO from a Company
Function&lt;Company, Const&lt;Person, Company&gt;&gt; ceoGetter =
    company -&gt; new Const&lt;&gt;(company.ceo());

// Compose getters: get CEO name from Company using mapFirst
Function&lt;Company, Const&lt;String, Company&gt;&gt; ceoNameGetter = company -&gt;
    ceoGetter.apply(company)
        .mapFirst(person -&gt; nameGetter.apply(person).value());

Const&lt;String, Company&gt; result = ceoNameGetter.apply(acmeCorp);
System.out.println("Company CEO name: " + result.value());
// Output: Alice
</code></pre>
<p>This pattern is the foundation of van Laarhoven lenses, where <code>Const</code> is used with <code>Functor</code> or <code>Applicative</code> to implement compositional getters. For a deeper dive, see <a href="https://www.twanvl.nl/blog/haskell/cps-functional-references">Van Laarhoven Lenses</a> and <a href="https://www.optics.dev/Monocle/docs/focus">Scala Monocle</a>.</p>
</div>
</div>
<hr />
<h2 id="use-case-3-data-extraction-from-validation-results"><a class="header" href="#use-case-3-data-extraction-from-validation-results">Use Case 3: Data Extraction from Validation Results</a></h2>
<p>When traversing validation results, you often want to extract accumulated errors or valid data without transforming the individual results. <code>Const</code> provides a clean way to express this pattern.</p>
<div id="admonition-example-validation-data-mining" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-validation-data-mining-title">
<div class="admonition-title">
<div id="admonition-example-validation-data-mining-title">
<p>Example: Validation Data Mining</p>
</div>
<a class="admonition-anchor-link" href="monads/const_type.html#admonition-example-validation-data-mining"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/constant/ConstExample.java">ConstExample.java</a></p>
<pre><code class="language-java">record ValidationResult(boolean isValid, List&lt;String&gt; errors, Object data) {}

List&lt;ValidationResult&gt; results = List.of(
    new ValidationResult(true, List.of(), "Valid data 1"),
    new ValidationResult(false, List.of("Error A", "Error B"), null),
    new ValidationResult(true, List.of(), "Valid data 2"),
    new ValidationResult(false, List.of("Error C"), null)
);

// Extract all errors using Const
List&lt;String&gt; allErrors = new ArrayList&lt;&gt;();

for (ValidationResult result : results) {
    // Use Const to extract errors, phantom type represents ValidationResult
    Const&lt;List&lt;String&gt;, ValidationResult&gt; errorConst = new Const&lt;&gt;(result.errors());
    allErrors.addAll(errorConst.value());
}

System.out.println("All errors: " + allErrors);
// Output: [Error A, Error B, Error C]

// Count valid results
Const&lt;Integer, ValidationResult&gt; validCount = results.stream()
    .reduce(
        new Const&lt;&gt;(0),
        (acc, result) -&gt; new Const&lt;Integer, ValidationResult&gt;(
            result.isValid() ? acc.value() + 1 : acc.value()),
        (c1, c2) -&gt; new Const&lt;&gt;(c1.value() + c2.value()));

System.out.println("Valid results: " + validCount.value());
// Output: 2
</code></pre>
<p>The phantom type maintains the "context" of what we're extracting from (ValidationResult), whilst the constant value accumulates the data we care about (errors or counts).</p>
</div>
</div>
<hr />
<h2 id="const-vs-other-types"><a class="header" href="#const-vs-other-types">Const vs Other Types</a></h2>
<p>Understanding how <code>Const</code> relates to similar types clarifies its unique role:</p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>First Parameter</th><th>Second Parameter</th><th>Primary Use</th></tr></thead><tbody>
<tr><td><code>Const&lt;C, A&gt;</code></td><td>Constant value (stored)</td><td>Phantom (not stored)</td><td>Folds, getters, extraction</td></tr>
<tr><td><code>Tuple2&lt;A, B&gt;</code></td><td>First element (stored)</td><td>Second element (stored)</td><td>Pairing related values</td></tr>
<tr><td><code>Identity&lt;A&gt;</code></td><td>Value (stored)</td><td>N/A (single parameter)</td><td>Pure computation wrapper</td></tr>
<tr><td><code>Either&lt;L, R&gt;</code></td><td>Error (sum type)</td><td>Success (sum type)</td><td>Error handling</td></tr>
</tbody></table>
</div>
<p><strong>Use Const when:</strong></p>
<ul>
<li>You need to accumulate a single value during traversal</li>
<li>You're implementing getters or read-only lenses</li>
<li>You want to extract data without transformation</li>
<li>The phantom type provides useful type-level information for composition</li>
</ul>
<p><strong>Use Tuple2 when:</strong></p>
<ul>
<li>You need to store and work with both values</li>
<li>Both parameters represent actual data</li>
</ul>
<p><strong>Use Identity when:</strong></p>
<ul>
<li>You need a minimal monad wrapper with no additional effects</li>
</ul>
<hr />
<h2 id="exception-propagation-note"><a class="header" href="#exception-propagation-note">Exception Propagation Note</a></h2>
<p>Although <code>mapSecond</code> doesn't transform the constant value, the mapper function is still applied to <code>null</code> to ensure exception propagation. This maintains consistency with bifunctor semantics.</p>
<pre><code class="language-java">Const&lt;String, Integer&gt; const_ = new Const&lt;&gt;("value");

// This will throw NullPointerException from the mapper
Const&lt;String, Double&gt; result = const_.mapSecond(i -&gt; {
    if (i == null) throw new NullPointerException("Expected non-null");
    return i * 2.0;
});
</code></pre>
<p>This behaviour ensures that invalid mappers are detected, even though the mapper's result isn't used. For null-safe mappers, simply avoid dereferencing the parameter:</p>
<pre><code class="language-java">// Null-safe phantom type transformation
Const&lt;String, Double&gt; safe = const_.mapSecond(i -&gt; 3.14);
</code></pre>
<hr />
<h2 id="summary-3"><a class="header" href="#summary-3">Summary</a></h2>
<ul>
<li><strong>Const&lt;C, A&gt;</strong> holds a constant value of type <code>C</code> with a phantom type parameter <code>A</code></li>
<li><strong>Phantom types</strong> exist only in type signatures, enabling type-safe composition without runtime overhead</li>
<li><strong>Bifunctor operations</strong>:
<ul>
<li><code>first</code> transforms the constant value</li>
<li><code>second</code> changes only the phantom type</li>
<li><code>bimap</code> combines both (but only affects the constant via the first function)</li>
</ul>
</li>
<li><strong>Use cases</strong>:
<ul>
<li>Efficient fold implementations that accumulate a single value</li>
<li>Compositional getters in lens and traversal patterns</li>
<li>Data extraction from complex structures without transformation</li>
</ul>
</li>
<li><strong>Scala heritage</strong>: Mirrors <code>Const</code> in Cats, Scalaz, and Monocle</li>
<li><strong>External resources</strong>:
<ul>
<li><a href="https://typelevel.org/cats/datatypes/const.html">Cats Const Documentation</a></li>
<li><a href="https://www.optics.dev/Monocle/docs/optics/getter">Monocle Getter Optics</a></li>
<li><a href="https://www.twanvl.nl/blog/haskell/cps-functional-references">Van Laarhoven Lenses</a></li>
</ul>
</li>
</ul>
<p>Understanding <code>Const</code> empowers you to write efficient, compositional code for data extraction and accumulation, leveraging patterns battle-tested in the Scala functional programming ecosystem.</p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="the-transformers"><a class="header" href="#the-transformers">The Transformers:</a></h1>
<p><em>Combining Monadic Effects</em></p>
<p><img src="transformers/../images/stand_back_monad_transformers.jpg" alt="stand_back_monad_transformers.jpg" /></p>
<h2 id="the-problem"><a class="header" href="#the-problem">The Problem</a></h2>
<p>When building applications, we often encounter scenarios where we need to combine different computational contexts or effects. For example:</p>
<ul>
<li>An operation might be <strong>asynchronous</strong> (represented by <code>CompletableFuture</code>).</li>
<li>The same operation might also <strong>fail with specific domain errors</strong> (represented by <code>Either&lt;DomainError, Result&gt;</code>).</li>
<li>An operation might need <strong>access to a configuration</strong> (using <code>Reader</code>) and also be <strong>asynchronous</strong>.</li>
<li>A computation might <strong>accumulate logs</strong> (using <code>Writer</code>) and also <strong>potentially fail</strong> (using <code>Maybe</code> or <code>Either</code>).</li>
</ul>
<h3 id="monads-stack-poorly"><a class="header" href="#monads-stack-poorly">Monads Stack Poorly</a></h3>
<p>Directly nesting these monadic types, like <code>CompletableFuture&lt;Either&lt;DomainError, Result&gt;&gt;</code> or <code>Reader&lt;Config, Optional&lt;Data&gt;&gt;</code>, leads to complex, deeply nested code ("callback hell" or nested <code>flatMap</code>/<code>map</code> calls). It becomes difficult to sequence operations and handle errors or contexts uniformly.</p>
<p>For instance, an operation might need to be both asynchronous <em>and</em> handle potential domain-specific errors. Representing this naively leads to nested types like:</p>
<pre><code class="language-java">// A future that, when completed, yields either a DomainError or a SuccessValue
Kind&lt;CompletableFutureKind.Witness, Either&lt;DomainError, SuccessValue&gt;&gt; nestedResult;
</code></pre>
<p>But now, how do we <code>map</code> or <code>flatMap</code> over this stack  without lots of boilerplate?</p>
<h2 id="monad-transformers-a-wrapper-to-simplify-nested-monads"><a class="header" href="#monad-transformers-a-wrapper-to-simplify-nested-monads">Monad Transformers: A <em>wrapper</em> to simplify nested Monads</a></h2>
<p><strong>Monad Transformers</strong> are a design pattern in functional programming used to combine the effects of two different monads into a single, new monad. They provide a standard way to "stack" monadic contexts, allowing you to work with the combined structure more easily using familiar monadic operations like <code>map</code> and <code>flatMap</code>.</p>
<p>A monad transformer <code>T</code> takes a monad <code>M</code> and produces a new monad <code>T&lt;M&gt;</code> that combines the effects of both <code>T</code> (conceptually) and <code>M</code>.</p>
<h4 id="for-example"><a class="header" href="#for-example">For example:</a></h4>
<ul>
<li><code>MaybeT m a</code> wraps a monad <code>m</code> and adds <code>Maybe</code>-like failure</li>
<li><code>StateT s m a</code> wraps a monad <code>m</code> and adds state-handling capability</li>
<li><code>ReaderT r m a</code> adds dependency injection (read-only environment)</li>
</ul>
<p>They allow you to <strong>stack</strong> monadic behaviours.</p>
<p>Key characteristics:</p>
<ol>
<li><strong>Stacking:</strong> They allow "stacking" monadic effects in a standard way.</li>
<li><strong>Unified Interface:</strong> The resulting transformed monad (e.g., <code>EitherT&lt;CompletableFutureKind, ...&gt;</code>) itself implements the <code>Monad</code> (and often <code>MonadError</code>, etc.) interface.</li>
<li><strong>Abstraction:</strong> They hide the complexity of manually managing the nested structure. You can use standard <code>map</code>, <code>flatMap</code>, <code>handleErrorWith</code> operations on the transformed monad, and it automatically handles the logic for both underlying monads correctly.</li>
</ol>
<h2 id="transformers-in-higher-kinded-j"><a class="header" href="#transformers-in-higher-kinded-j">Transformers in Higher-Kinded-J</a></h2>
<p><img src="transformers/../images/puml/supported_transformers.svg" alt="supported_transformers.svg" /></p>
<h3 id="1-eithertf-l-r-monad-transformer"><a class="header" href="#1-eithertf-l-r-monad-transformer">1. <code>EitherT&lt;F, L, R&gt;</code> (Monad Transformer)</a></h3>
<p><img src="transformers/../images/puml/transformers.svg" alt="transformers.svg" /></p>
<ul>
<li><strong>Definition:</strong> A monad transformer (<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/either_t/EitherT.java"><code>EitherT</code></a>) that combines an outer monad <code>F</code> with an inner <code>Either&lt;L, R&gt;</code>. Implemented as a record wrapping <code>Kind&lt;F, Either&lt;L, R&gt;&gt;</code>.</li>
<li><strong>Kind Interface:</strong> <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/either_t/EitherTKind.java"><code>EitherTKind&lt;F, L, R&gt;</code></a></li>
<li><strong>Witness Type <code>G</code>:</strong> <code>EitherTKind.Witness&lt;F, L&gt;</code> (where <code>F</code> and <code>L</code> are fixed for a given type class instance)</li>
<li><strong>Helper:</strong> <code>EitherTKindHelper</code> (<code>wrap</code>, <code>unwrap</code>). Instances are primarily created via <code>EitherT</code> static factories (<code>fromKind</code>, <code>right</code>, <code>left</code>, <code>fromEither</code>, <code>liftF</code>).</li>
<li><strong>Type Class Instances:</strong>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/either_t/EitherT.java"><code>EitherTMonad&lt;F, L&gt;</code></a> (<code>MonadError&lt;EitherTKind.Witness&lt;F, L&gt;, L&gt;</code>)</li>
</ul>
</li>
<li><strong>Notes:</strong> Simplifies working with nested structures like <code>F&lt;Either&lt;L, R&gt;&gt;</code>. Requires a <code>Monad&lt;F&gt;</code> instance for the outer monad <code>F</code> passed to its constructor. Implements <code>MonadError</code> for the <em>inner</em> <code>Either</code>'s <code>Left</code> type <code>L</code>. See the <a href="transformers/../hkts/order-walkthrough.html">Order Processing Example Walkthrough</a> for practical usage with <code>CompletableFuture</code> as <code>F</code>.</li>
<li><strong>Usage:</strong> <a href="transformers/eithert_transformer.html">How to use the EitherT Monad Transformer</a></li>
</ul>
<hr />
<h3 id="2-maybetf-a-monad-transformer"><a class="header" href="#2-maybetf-a-monad-transformer">2. <code>MaybeT&lt;F, A&gt;</code> (Monad Transformer)</a></h3>
<ul>
<li><strong>Definition:</strong> A monad transformer (<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt/maybe_t/MaybeT.java"><code>MaybeT</code></a>) that combines an outer monad <code>F</code> with an inner <code>Maybe&lt;A&gt;</code>. Implemented as a record wrapping <code>Kind&lt;F, Maybe&lt;A&gt;&gt;</code>.</li>
<li><strong>Kind Interface:</strong> <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt//maybe_t/MaybeTKind.java"><code>MaybeTKind&lt;F, A&gt;</code></a></li>
<li><strong>Witness Type <code>G</code>:</strong> <code>MaybeTKind.Witness&lt;F&gt;</code> (where <code>F</code> is fixed for a given type class instance)</li>
<li><strong>Helper:</strong> <code>MaybeTKindHelper</code> (<code>wrap</code>, <code>unwrap</code>). Instances are primarily created via <code>MaybeT</code> static factories (<code>fromKind</code>, <code>just</code>, <code>nothing</code>, <code>fromMaybe</code>, <code>liftF</code>).</li>
<li><strong>Type Class Instances:</strong>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt//maybe_t/MaybeTMonad.java"><code>MaybeTMonad&lt;F&gt;</code></a> (<code>MonadError&lt;MaybeTKind.Witness&lt;F&gt;, Void&gt;</code>)</li>
</ul>
</li>
<li><strong>Notes:</strong> Simplifies working with nested structures like <code>F&lt;Maybe&lt;A&gt;&gt;</code>. Requires a <code>Monad&lt;F&gt;</code> instance for the outer monad <code>F</code>. Implements <code>MonadError</code> where the error type is <code>Void</code>, corresponding to the <code>Nothing</code> state from the inner <code>Maybe</code>.</li>
<li><strong>Usage:</strong> <a href="transformers/./maybet_transformer.html">How to use the MaybeT Monad Transformer</a></li>
</ul>
<hr />
<h3 id="3-optionaltf-a-monad-transformer"><a class="header" href="#3-optionaltf-a-monad-transformer">3. <code>OptionalT&lt;F, A&gt;</code> (Monad Transformer)</a></h3>
<ul>
<li><strong>Definition:</strong> A monad transformer (<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt//optional_t/OptionalT.java"><code>OptionalT</code></a>) that combines an outer monad <code>F</code> with an inner <code>java.util.Optional&lt;A&gt;</code>. Implemented as a record wrapping <code>Kind&lt;F, Optional&lt;A&gt;&gt;</code>.</li>
<li><strong>Kind Interface:</strong> <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt//optional_t/OptionalTKind.java"><code>OptionalTKind&lt;F, A&gt;</code></a></li>
<li><strong>Witness Type <code>G</code>:</strong> <code>OptionalTKind.Witness&lt;F&gt;</code> (where <code>F</code> is fixed for a given type class instance)</li>
<li><strong>Helper:</strong> <code>OptionalTKindHelper</code> (<code>wrap</code>, <code>unwrap</code>). Instances are primarily created via <code>OptionalT</code> static factories (<code>fromKind</code>, <code>some</code>, <code>none</code>, <code>fromOptional</code>, <code>liftF</code>).</li>
<li><strong>Type Class Instances:</strong>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt//optional_t/OptionalTMonad.java"><code>OptionalTMonad&lt;F&gt;</code></a> (<code>MonadError&lt;OptionalTKind.Witness&lt;F&gt;, Void&gt;</code>)</li>
</ul>
</li>
<li><strong>Notes:</strong> Simplifies working with nested structures like <code>F&lt;Optional&lt;A&gt;&gt;</code>. Requires a <code>Monad&lt;F&gt;</code> instance for the outer monad <code>F</code>. Implements <code>MonadError</code> where the error type is <code>Void</code>, corresponding to the <code>Optional.empty()</code> state from the inner <code>Optional</code>.</li>
<li><strong>Usage:</strong> <a href="transformers/./optionalt_transformer.html">How to use the OptionalT Monad Transformer</a></li>
</ul>
<hr />
<h3 id="4-readertf-r-a-monad-transformer"><a class="header" href="#4-readertf-r-a-monad-transformer">4. <code>ReaderT&lt;F, R, A&gt;</code> (Monad Transformer)</a></h3>
<ul>
<li><strong>Definition:</strong> A monad transformer (<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt//reader_t/ReaderT.java"><code>ReaderT</code></a>) that combines an outer monad <code>F</code> with an inner <code>Reader&lt;R, A&gt;</code>-like behaviour (dependency on environment <code>R</code>). Implemented as a record wrapping a function <code>R -&gt; Kind&lt;F, A&gt;</code>.</li>
<li><strong>Kind Interface:</strong> <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt//reader_t/ReaderTKind.java"><code>ReaderTKind&lt;F, R, A&gt;</code></a></li>
<li><strong>Witness Type <code>G</code>:</strong> <code>ReaderTKind.Witness&lt;F, R&gt;</code> (where <code>F</code> and <code>R</code> are fixed for a given type class instance)</li>
<li><strong>Helper:</strong> <code>ReaderTKindHelper</code> (<code>wrap</code>, <code>unwrap</code>). Instances are primarily created via <code>ReaderT</code> static factories (<code>of</code>, <code>lift</code>, <code>reader</code>, <code>ask</code>).</li>
<li><strong>Type Class Instances:</strong>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt//reader_t/ReaderTMonad.java"><code>ReaderTMonad&lt;F, R&gt;</code></a> (<code>Monad&lt;ReaderTKind&lt;F, R, ?&gt;&gt;</code>)</li>
</ul>
</li>
<li><strong>Notes:</strong> Simplifies managing computations that depend on a read-only environment <code>R</code> while also involving other monadic effects from <code>F</code>. Requires a <code>Monad&lt;F&gt;</code> instance for the outer monad. The <code>run()</code> method of <code>ReaderT</code> takes <code>R</code> and returns <code>Kind&lt;F, A&gt;</code>.</li>
<li><strong>Usage:</strong> <a href="transformers/./readert_transformer.html">How to use the ReaderT Monad Transformer</a></li>
</ul>
<h3 id="5-statets-f-a-monad-transformer"><a class="header" href="#5-statets-f-a-monad-transformer">5. <code>StateT&lt;S, F, A&gt;</code> (Monad Transformer)</a></h3>
<ul>
<li><strong>Definition:</strong> A monad transformer (<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt//state_t/StateT.java"><code>StateT</code></a>) that adds stateful computation (type <code>S</code>) to an underlying monad <code>F</code>. It represents a function <code>S -&gt; Kind&lt;F, StateTuple&lt;S, A&gt;&gt;</code>.</li>
<li><strong>Kind Interface:</strong><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt//state_t/StateTKind.java"><code>StateTKind&lt;S, F, A&gt;</code></a></li>
<li><strong>Witness Type <code>G</code>:</strong><code>StateTKind.Witness&lt;S, F&gt;</code> (where <code>S</code> for state and <code>F</code> for the underlying monad witness are fixed for a given type class instance; <code>A</code> is the value type parameter)</li>
<li><strong>Helper:</strong><code>StateTKindHelper</code> (<code>narrow</code>, <code>wrap</code>, <code>runStateT</code>, <code>evalStateT</code>, <code>execStateT</code>, <code>lift</code>). Instances are created via <code>StateT.create()</code>, <code>StateTMonad.of()</code>, or <code>StateTKind.lift()</code>.</li>
<li><strong>Type Class Instances:</strong>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-core/src/main/java/org/higherkindedj/hkt//state_t/StateTMonad.java"><code>StateTMonad&lt;S, F&gt;</code></a> (<code>Monad&lt;StateTKind.Witness&lt;S, F&gt;&gt;</code>)</li>
</ul>
</li>
<li><strong>Notes:</strong> Allows combining stateful logic with other monadic effects from <code>F</code>. Requires a <code>Monad&lt;F&gt;</code> instance for the underlying monad. The <code>runStateT(initialState)</code> method executes the computation, returning <code>Kind&lt;F, StateTuple&lt;S, A&gt;&gt;</code>.</li>
<li><strong>Usage:</strong><a href="transformers/./statet_transformer.html">How to use the StateT Monad Transformer</a></li>
</ul>
<hr />
<h2 id="further-reading"><a class="header" href="#further-reading">Further Reading</a></h2>
<div id="admonition-learning-path" class="admonition admonish-tip" role="note" aria-labelledby="admonition-learning-path-title">
<div class="admonition-title">
<div id="admonition-learning-path-title">
<p>Learning Path</p>
</div>
<a class="admonition-anchor-link" href="transformers/transformers.html#admonition-learning-path"></a>
</div>
<div>
<p>Start with the <strong>Java-focused</strong> articles to understand why transformers matter in Java, then explore the <strong>General FP</strong> theory, and finally examine how other libraries implement these patterns.</p>
</div>
</div>
<h3 id="java-focused-resources"><a class="header" href="#java-focused-resources">Java-Focused Resources</a></h3>
<p><strong>Beginner Level:</strong></p>
<ul>
<li>üìö <a href="https://medium.com/@johnmcclean/monad-transformers-in-java-e6f6b7e0f76d">Monad Transformers in Java: A Practical Guide</a> - John McClean's clear explanation with Cyclops examples (15 min read)</li>
<li>üé• <a href="https://www.youtube.com/watch?v=rPSL1alFIjI">Functional Programming in Java: Beyond Streams</a> - Venkat Subramaniam discusses composition patterns (45 min watch)</li>
<li>üìÑ <a href="https://www.baeldung.com/java-combine-optional-completablefuture">Combining CompletableFuture with Optional: The Problem</a> - Baeldung's treatment of nested monads (10 min read)</li>
</ul>
<p><strong>Intermediate Level:</strong></p>
<ul>
<li>üìÑ <a href="https://medium.com/att-israel/stacking-monads-in-functional-java-c3c8a9c9c6e">Stacking Monads in Functional Java</a> - ATT Israel Engineering team's practical examples (20 min read)</li>
<li>üìÑ <a href="https://www.vavr.io/">Vavr's Approach to Composition</a> - Explore how Vavr handles similar challenges (interactive docs)</li>
</ul>
<p><strong>Advanced:</strong></p>
<ul>
<li>üî¨ <a href="https://blog.rockthejvm.com/free-monad/">Free Monads and Monad Transformers</a> - Rock the JVM's Scala-based but Java-applicable deep dive (30 min read)</li>
</ul>
<h3 id="general-fp-concepts"><a class="header" href="#general-fp-concepts">General FP Concepts</a></h3>
<ul>
<li>üìñ <a href="https://page.mi.fu-berlin.de/scravy/realworldhaskell/materialien/monad-transformers-step-by-step.pdf">Monad Transformers Step by Step</a> - Martin Grabm√ºller's classic paper, accessible even for Java developers (PDF, 40 min read)</li>
<li>üåê <a href="https://wiki.haskell.org/Monad_Transformers_Explained">Monad Transformer - HaskellWiki</a> - Formal definitions with clear examples</li>
<li>üìñ <a href="https://www.fpcomplete.com/haskell/tutorial/monad-transformers/">What is a Monad Transformer?</a> - FP Complete's tutorial with interactive examples</li>
</ul>
<h3 id="related-libraries--comparisons"><a class="header" href="#related-libraries--comparisons">Related Libraries &amp; Comparisons</a></h3>
<ul>
<li>üîó <a href="https://github.com/aol/cyclops">Cyclops-React Transformers</a> - AOL's comprehensive Java FP library</li>
<li>üîó <a href="https://www.vavr.io/vavr-docs/#_composition">Vavr Composition Patterns</a> - Alternative approach to the same problems</li>
<li>üîó <a href="https://arrow-kt.io/docs/apidocs/arrow-fx-coroutines/arrow.fx.coroutines/-resource/">Arrow-kt Transformers</a> - Kotlin's excellent documentation</li>
<li>üîó <a href="https://typelevel.org/cats-mtl/">Cats MTL</a> - Scala's monad transformer library (advanced)</li>
</ul>
<h3 id="community--discussion"><a class="header" href="#community--discussion">Community &amp; Discussion</a></h3>
<ul>
<li>üí¨ <a href="https://stackoverflow.com/questions/32579133/when-to-use-monad-transformers">Why are Monad Transformers useful?</a> - Stack Overflow discussion with practical examples</li>
<li>üí¨ <a href="https://www.reddit.com/r/java/comments/8qhxzv/monad_transformers_in_production_code/">Monad Transformers in Production</a> - Real-world experiences from Java developers</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="the-eithert-transformer"><a class="header" href="#the-eithert-transformer">The EitherT Transformer:</a></h1>
<h2 id="combining-monadic-effects"><a class="header" href="#combining-monadic-effects"><em>Combining Monadic Effects</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="transformers/eithert_transformer.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to combine async operations (CompletableFuture) with typed error handling (Either)</li>
<li>Building workflows that can fail with specific domain errors while remaining async</li>
<li>Using <code>fromKind</code>, <code>fromEither</code>, and <code>liftF</code> to construct EitherT values</li>
<li>Real-world order processing with validation, inventory checks, and payment processing</li>
<li>Why EitherT eliminates "callback hell" in complex async workflows</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code:</p>
</div>
<a class="admonition-anchor-link" href="transformers/eithert_transformer.html#admonition-see-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/either_t/EitherTExample.java">EitherTExample.java</a></p>
</div>
</div>
<h2 id="eithert-monad-transformer"><a class="header" href="#eithert-monad-transformer"><code>EitherT</code> Monad Transformer.</a></h2>
<p><img src="transformers/../images/puml/eithert_transformer.svg" alt="eithert_transformer.svg" /></p>
<h2 id="eithertf-l-r-combining-any-monad-f-with-eitherl-r"><a class="header" href="#eithertf-l-r-combining-any-monad-f-with-eitherl-r"><code>EitherT&lt;F, L, R&gt;</code>: Combining any Monad <code>F</code> with <code>Either&lt;L, R&gt;</code></a></h2>
<p>The <code>EitherT</code> monad transformer allows you to combine the error-handling capabilities of <code>Either&lt;L, R&gt;</code> with another outer monad <code>F</code>. It transforms a computation that results in <code>Kind&lt;F, Either&lt;L, R&gt;&gt;</code> into a single monadic structure that can be easily composed. This is particularly useful when dealing with operations that can fail (represented by <code>Left&lt;L&gt;</code>) within an effectful context <code>F</code> (like asynchronous operations using <code>CompletableFutureKind</code> or computations involving state with <code>StateKind</code>).</p>
<ul>
<li><strong><code>F</code></strong>: The witness type of the <strong>outer monad</strong> (e.g., <code>CompletableFutureKind.Witness</code>, <code>OptionalKind.Witness</code>). This monad handles the primary effect (e.g., asynchronicity, optionality).</li>
<li><strong><code>L</code></strong>: The <strong>Left type</strong> of the inner <code>Either</code>. This typically represents the <em>error</em> type for the computation or alternative result.</li>
<li><strong><code>R</code></strong>: The <strong>Right type</strong> of the inner <code>Either</code>. This typically represents the <em>success</em> value type.</li>
</ul>
<pre><code class="language-java">public record EitherT&lt;F, L, R&gt;(@NonNull Kind&lt;F, Either&lt;L, R&gt;&gt; value) { 
  /* ... static factories ... */ }
</code></pre>
<p>It holds a value of type <code>Kind&lt;F, Either&lt;L, R&gt;&gt;</code>. The real power comes from its associated type class instance, <code>EitherTMonad</code>.</p>
<p>Essentially, <code>EitherT&lt;F, L, R&gt;</code> wraps a value of type <code>Kind&lt;F, Either&lt;L, R&gt;&gt;</code>. It represents a computation within the context <code>F</code> that will eventually yield an <code>Either&lt;L, R&gt;</code>.</p>
<p>The primary goal of <code>EitherT</code> is to provide a unified <code>Monad</code> interface (specifically <code>MonadError</code> for the <code>L</code> type) for this nested structure, hiding the complexity of manually handling both the outer <code>F</code> context and the inner <code>Either</code> context.</p>
<h2 id="eithertkindf-l-r-the-witness-type"><a class="header" href="#eithertkindf-l-r-the-witness-type"><code>EitherTKind&lt;F, L, R&gt;</code>: The Witness Type</a></h2>
<p>Just like other types in the Higher-Kinded-J, <code>EitherT</code> needs a corresponding <code>Kind</code> interface to act as its witness type in generic functions. This is <code>EitherTKind&lt;F, L, R&gt;</code>.</p>
<ul>
<li>It extends <code>Kind&lt;G, R&gt;</code> where <code>G</code> (the witness for the combined monad) is <code>EitherTKind.Witness&lt;F, L&gt;</code>.</li>
<li><code>F</code> and <code>L</code> are fixed for a specific <code>EitherT</code> context, while <code>R</code> is the variable type parameter <code>A</code> in <code>Kind&lt;G, A&gt;</code>.</li>
</ul>
<p>You'll primarily interact with this type when providing type signatures or receiving results from <code>EitherTMonad</code> methods.</p>
<h2 id="eithertkindhelper"><a class="header" href="#eithertkindhelper"><code>EitherTKindHelper</code></a></h2>
<ul>
<li>Provides widen and narrow methods to safely convert between the concrete <code>EitherT&lt;F, L, R&gt;</code> and its Kind representation (<code>Kind&lt;EitherTKind&lt;F, L, ?&gt;, R&gt;</code>).</li>
</ul>
<h2 id="eithertmonadf-l-operating-on-eithert"><a class="header" href="#eithertmonadf-l-operating-on-eithert"><code>EitherTMonad&lt;F, L&gt;</code>: Operating on <code>EitherT</code></a></h2>
<ul>
<li>The EitherTMonad class implements <code>MonadError&lt;EitherTKind.Witness&lt;F, L&gt;, L&gt;</code>.</li>
</ul>
<ul>
<li>It requires a Monad<F> instance for the outer monad F to be provided during construction. This outer monad instance is used internally to handle the effects of <code>F</code>.</li>
<li>It uses <code>EITHER_T.widen</code> and <code>EITHER_T.narrow</code> internally to manage the conversion between the <code>Kind</code> and the concrete <code>EitherT</code>.</li>
<li>The error type E for MonadError is fixed to L, the 'Left' type of the inner Either. Error handling operations like <code>raiseError(L l)</code> will create an <code>EitherT</code> representing <code>F&lt;Left(l)&gt;</code>, and <code>handleErrorWith</code> allows recovering from such Left states.</li>
</ul>
<pre><code class="language-java">// Example: F = CompletableFutureKind.Witness, L = DomainError
// 1. Get the MonadError instance for the outer monad F
MonadError&lt;CompletableFutureKind.Witness, Throwable&gt; futureMonad = CompletableFutureMonad.INSTANCE;

// 2. Create the EitherTMonad, providing the outer monad instance
//    This EitherTMonad handles DomainError for the inner Either.
MonadError&lt;EitherTKind.Witness&lt;CompletableFutureKind.Witness, DomainError&gt;, DomainError&gt; eitherTMonad =
    new EitherTMonad&lt;&gt;(futureMonad);

// Now 'eitherTMonad' can be used to operate on Kind&lt;EitherTKind.Witness&lt;CompletableFutureKind.Witness, DomainError&gt;, A&gt; values.
</code></pre>
<div id="admonition-key-operations-with-_eithertmonad_" class="admonition admonish-info" role="note" aria-labelledby="admonition-key-operations-with-_eithertmonad_-title">
<div class="admonition-title">
<div id="admonition-key-operations-with-_eithertmonad_-title">
<p>Key Operations with <em>EitherTMonad</em>:</p>
</div>
<a class="admonition-anchor-link" href="transformers/eithert_transformer.html#admonition-key-operations-with-_eithertmonad_"></a>
</div>
<div>
<ul>
<li><strong><code>eitherTMonad.of(value)</code>:</strong> Lifts a pure value <code>A</code> into the <code>EitherT</code> context. Result: <code>F&lt;Right(A)&gt;</code>.</li>
<li><strong><code>eitherTMonad.map(f, eitherTKind)</code>:</strong> Applies function <code>A -&gt; B</code> to the <code>Right</code> value inside the nested structure, preserving both <code>F</code> and <code>Either</code> contexts (if Right). Result: <code>F&lt;Either&lt;L, B&gt;&gt;</code>.</li>
<li><strong><code>eitherTMonad.flatMap(f, eitherTKind)</code>:</strong> The core sequencing operation. Takes a function <code>A -&gt; Kind&lt;EitherTKind.Witness&lt;F, L&gt;, B&gt;</code> (i.e., <code>A -&gt; EitherT&lt;F, L, B&gt;</code>). It unwraps the input <code>EitherT</code>, handles the <code>F</code> context, checks the inner <code>Either</code>:
<ul>
<li>If <code>Left(l)</code>, it propagates <code>F&lt;Left(l)&gt;</code>.</li>
<li>If <code>Right(a)</code>, it applies <code>f(a)</code> to get the next <code>EitherT&lt;F, L, B&gt;</code>, and extracts its inner <code>Kind&lt;F, Either&lt;L, B&gt;&gt;</code>, effectively chaining the <code>F</code> contexts and the <code>Either</code> logic.</li>
</ul>
</li>
<li><strong><code>eitherTMonad.raiseError(errorL)</code>:</strong> Creates an <code>EitherT</code> representing a failure in the inner <code>Either</code>. Result: <code>F&lt;Left(L)&gt;</code>.</li>
<li><strong><code>eitherTMonad.handleErrorWith(eitherTKind, handler)</code>:</strong> Handles a failure <code>L</code> from the <em>inner</em> <code>Either</code>. Takes a handler <code>L -&gt; Kind&lt;EitherTKind.Witness&lt;F, L&gt;, A&gt;</code>. It unwraps the input <code>EitherT</code>, checks the inner <code>Either</code>:
<ul>
<li>If <code>Right(a)</code>, propagates <code>F&lt;Right(a)&gt;</code>.</li>
<li>If <code>Left(l)</code>, applies <code>handler(l)</code> to get a recovery <code>EitherT&lt;F, L, A&gt;</code>, and extracts its inner <code>Kind&lt;F, Either&lt;L, A&gt;&gt;</code>.</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="admonition-creating-_eithert_-instances" class="admonition admonish-note" role="note" aria-labelledby="admonition-creating-_eithert_-instances-title">
<div class="admonition-title">
<div id="admonition-creating-_eithert_-instances-title">
<p>Creating <em>EitherT</em> Instances</p>
</div>
<a class="admonition-anchor-link" href="transformers/eithert_transformer.html#admonition-creating-_eithert_-instances"></a>
</div>
<div>
<p>You typically create <code>EitherT</code> instances using its static factory methods, providing the necessary outer <code>Monad&lt;F&gt;</code> instance:</p>
<pre><code class="language-java">// Assume:
Monad&lt;OptionalKind.Witness&gt; optMonad = OptionalMonad.INSTANCE; // Outer Monad F=Optional
String errorL = "FAILED";
String successR = "OK";
Integer otherR = 123;

// 1. Lifting a pure 'Right' value: Optional&lt;Right(R)&gt;
EitherT&lt;OptionalKind.Witness, String, String&gt; etRight = EitherT.right(optMonad, successR);
// Resulting wrapped value: Optional.of(Either.right("OK"))

// 2. Lifting a pure 'Left' value: Optional&lt;Left(L)&gt;
EitherT&lt;OptionalKind.Witness, String, Integer&gt; etLeft = EitherT.left(optMonad, errorL);
// Resulting wrapped value: Optional.of(Either.left("FAILED"))

// 3. Lifting a plain Either: Optional&lt;Either(input)&gt;
Either&lt;String, String&gt; plainEither = Either.left(errorL);
EitherT&lt;OptionalKind.Witness, String, String&gt; etFromEither = EitherT.fromEither(optMonad, plainEither);
// Resulting wrapped value: Optional.of(Either.left("FAILED"))

// 4. Lifting an outer monad value F&lt;R&gt;: Optional&lt;Right(R)&gt;
Kind&lt;OptionalKind.Witness, Integer&gt; outerOptional = OPTIONAL.widen(Optional.of(otherR));
EitherT&lt;OptionalKind.Witness, String, Integer&gt; etLiftF = EitherT.liftF(optMonad, outerOptional);
// Resulting wrapped value: Optional.of(Either.right(123))

// 5. Wrapping an existing nested Kind: F&lt;Either&lt;L, R&gt;&gt;
Kind&lt;OptionalKind.Witness, Either&lt;String, String&gt;&gt; nestedKind =
    OPTIONAL.widen(Optional.of(Either.right(successR)));
EitherT&lt;OptionalKind.Witness, String, String&gt; etFromKind = EitherT.fromKind(nestedKind);
// Resulting wrapped value: Optional.of(Either.right("OK"))

// Accessing the wrapped value:
Kind&lt;OptionalKind.Witness, Either&lt;String, String&gt;&gt; wrappedValue = etRight.value();
Optional&lt;Either&lt;String, String&gt;&gt; unwrappedOptional = OPTIONAL.narrow(wrappedValue);
// unwrappedOptional is Optional.of(Either.right("OK"))
</code></pre>
</div>
</div>
<hr />
<div id="admonition-async-workflow-with-error-handling" class="admonition admonish-note" role="note" aria-labelledby="admonition-async-workflow-with-error-handling-title">
<div class="admonition-title">
<div id="admonition-async-workflow-with-error-handling-title">
<p>Async Workflow with Error Handling</p>
</div>
<a class="admonition-anchor-link" href="transformers/eithert_transformer.html#admonition-async-workflow-with-error-handling"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/either_t/EitherTExample.java">EitherTExample.java</a></li>
</ul>
<p>The most common use case for <code>EitherT</code> is combining asynchronous operations (<code>CompletableFuture</code>) with domain error handling (<code>Either</code>).  The <code>OrderWorkflowRunner</code> class provides a detailed example.</p>
<p>Here's a simplified conceptual structure based on that example:</p>
<pre><code class="language-java">public class EitherTExample {

  // --- Setup ---

  // Assume DomainError is a sealed interface for specific errors
  // Re-defining a local DomainError to avoid dependency on the full DomainError hierarchy for this isolated example.
  // In a real scenario, you would use the shared DomainError.
  record DomainError(String message) {}
  record ValidatedData(String data) {}
  record ProcessedData(String data) {}

  MonadError&lt;CompletableFutureKind.Witness, Throwable&gt; futureMonad = CompletableFutureMonad.INSTANCE;
  MonadError&lt;EitherTKind.Witness&lt;CompletableFutureKind.Witness, DomainError&gt;, DomainError&gt; eitherTMonad =
          new EitherTMonad&lt;&gt;(futureMonad);

  // --- Workflow Steps (returning Kinds) ---

  // Simulates a sync validation returning Either
  Kind&lt;EitherKind.Witness&lt;DomainError&gt;, ValidatedData&gt; validateSync(String input) {
    System.out.println("Validating synchronously...");
    if (input.isEmpty()) {
      return EITHER.widen(Either.left(new DomainError("Input empty")));
    }
    return EITHER.widen(Either.right(new ValidatedData("Validated:" + input)));
  }

  // Simulates an async processing step returning Future&lt;Either&gt;
  Kind&lt;CompletableFutureKind.Witness, Either&lt;DomainError, ProcessedData&gt;&gt; processAsync(ValidatedData vd) {
    System.out.println("Processing asynchronously for: " + vd.data());
    CompletableFuture&lt;Either&lt;DomainError, ProcessedData&gt;&gt; future =
            CompletableFuture.supplyAsync(() -&gt; {
              try {
                Thread.sleep(50);
              } catch (InterruptedException e) { /* ignore */ }
              if (vd.data().contains("fail")) {
                return Either.left(new DomainError("Processing failed"));
              }
              return Either.right(new ProcessedData("Processed:" + vd.data()));
            });
    return FUTURE.widen(future);
  }

  // Function to run the workflow for given input
  Kind&lt;CompletableFutureKind.Witness, Either&lt;DomainError, ProcessedData&gt;&gt; runWorkflow(String initialInput) {

    // Start with initial data lifted into EitherT
    Kind&lt;EitherTKind.Witness&lt;CompletableFutureKind.Witness, DomainError&gt;, String&gt; initialET = eitherTMonad.of(initialInput);

    // Step 1: Validate (Sync Either lifted into EitherT)
    Kind&lt;EitherTKind.Witness&lt;CompletableFutureKind.Witness, DomainError&gt;, ValidatedData&gt; validatedET =
            eitherTMonad.flatMap(
                    input -&gt; {
                      // Call sync step returning Kind&lt;EitherKind.Witness,...&gt;
                      // Correction 1: Use EitherKind.Witness here
                      Kind&lt;EitherKind.Witness&lt;DomainError&gt;, ValidatedData&gt; validationResult = validateSync(input);
                      // Lift the Either result into EitherT using fromEither
                      return EitherT.fromEither(futureMonad, EITHER.narrow(validationResult));
                    },
                    initialET
            );

    // Step 2: Check Inventory (Asynchronous - returns Future&lt;Either&lt;DomainError, Unit&gt;&gt;) 
    Kind&lt;EitherTKind.Witness&lt;CompletableFutureKind.Witness, DomainError&gt;, WorkflowContext&gt; inventoryET =
        eitherTMonad.flatMap( // Chain from validation result
            ctx -&gt; { // Executed only if validatedET was F&lt;Right(...)&gt;
                // Call async step -&gt; Kind&lt;CompletableFutureKind.Witness, Either&lt;DomainError, Unit&gt;&gt; 
                Kind&lt;CompletableFutureKind.Witness, Either&lt;DomainError, Unit&gt;&gt; inventoryCheckFutureKind =
                    steps.checkInventoryAsync(ctx.validatedOrder().productId(), ctx.validatedOrder().quantity());
    
                // Lift the F&lt;Either&gt; directly into EitherT using fromKind
                Kind&lt;EitherTKind.Witness&lt;CompletableFutureKind.Witness, DomainError&gt;, Unit&gt; inventoryCheckET = 
                    EitherT.fromKind(inventoryCheckFutureKind);
    
                // If inventory check resolves to Right (now Right(Unit.INSTANCE)), update context.
 
                return eitherTMonad.map(unitInstance -&gt; ctx.withInventoryChecked(), inventoryCheckET);
            },
            validatedET // Input is result of validation step
        );

    // Unwrap the final EitherT to get the underlying Future&lt;Either&gt;
    return ((EitherT&lt;CompletableFutureKind.Witness, DomainError, ProcessedData&gt;) processedET).value();
  }

  public void asyncWorkflowErrorHandlingExample(){
    // --- Workflow Definition using EitherT ---

    // Input data
    String inputData = "Data";
    String badInputData = "";
    String processingFailData = "Data-fail";

    // --- Execution ---
    System.out.println("--- Running Good Workflow ---");

    Kind&lt;CompletableFutureKind.Witness, Either&lt;DomainError, ProcessedData&gt;&gt; resultGoodKind = runWorkflow(inputData);
    System.out.println("Good Result: "+FUTURE.join(resultGoodKind));
    // Expected: Right(ProcessedData[data=Processed:Validated:Data])

    System.out.println("\n--- Running Bad Input Workflow ---");

    Kind&lt;CompletableFutureKind.Witness, Either&lt;DomainError, ProcessedData&gt;&gt; resultBadInputKind = runWorkflow(badInputData);
    System.out.println("Bad Input Result: "+ FUTURE.join(resultBadInputKind));
    // Expected: Left(DomainError[message=Input empty])

    System.out.println("\n--- Running Processing Failure Workflow ---");

    Kind&lt;CompletableFutureKind.Witness, Either&lt;DomainError, ProcessedData&gt;&gt; resultProcFailKind = runWorkflow(processingFailData);
    System.out.println("Processing Fail Result: "+FUTURE.join(resultProcFailKind));
    // Expected: Left(DomainError[message=Processing failed])

  }
  public static void main(String[] args){
    EitherTExample example = new EitherTExample();
    example.asyncWorkflowErrorHandlingExample();

  }

}

</code></pre>
<p>This example demonstrates:</p>
<ol>
<li>Instantiating <code>EitherTMonad</code> with the outer <code>CompletableFutureMonad</code>.</li>
<li>Lifting the initial value using <code>eitherTMonad.of</code>.</li>
<li>Using <code>eitherTMonad.flatMap</code> to sequence steps.</li>
<li>Lifting a synchronous <code>Either</code> result into <code>EitherT</code> using <code>EitherT.fromEither</code>.</li>
<li>Lifting an asynchronous <code>Kind&lt;F, Either&lt;L,R&gt;&gt;</code> result using <code>EitherT.fromKind</code>.</li>
<li>Automatic short-circuiting: If validation returns <code>Left</code>, the processing step is skipped.</li>
<li>Unwrapping the final <code>EitherT</code> using <code>.value()</code> to get the <code>Kind&lt;CompletableFutureKind.Witness, Either&lt;DomainError, ProcessedData&gt;&gt;</code> result.</li>
</ol>
</div>
</div>
<div id="admonition-using-_eithertmonad_-for-sequencing-and-error-handling" class="admonition admonish-note" role="note" aria-labelledby="admonition-using-_eithertmonad_-for-sequencing-and-error-handling-title">
<div class="admonition-title">
<div id="admonition-using-_eithertmonad_-for-sequencing-and-error-handling-title">
<p>Using <em>EitherTMonad</em> for Sequencing and Error Handling</p>
</div>
<a class="admonition-anchor-link" href="transformers/eithert_transformer.html#admonition-using-_eithertmonad_-for-sequencing-and-error-handling"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/order/workflow/OrderWorkflowRunner.java">OrderWorkflowRunner.java</a></li>
</ul>
<p>The primary use is chaining operations using <code>flatMap</code> and handling errors using <code>handleErrorWith</code> or related methods. The <code>OrderWorkflowRunner</code> is the best example. Let's break down a key part:</p>
<pre><code class="language-java">// --- From OrderWorkflowRunner.java ---
// Assume setup:
// F = CompletableFutureKind&lt;?&gt;
// L = DomainError
// futureMonad = CompletableFutureMonad.INSTANCE;
// eitherTMonad = new EitherTMonad&lt;&gt;(futureMonad);
// steps = new OrderWorkflowSteps(dependencies); // Contains workflow logic

// Initial Context (lifted)
WorkflowContext initialContext = WorkflowContext.start(orderData);
Kind&lt;EitherTKind.Witness&lt;CompletableFutureKind.Witness, DomainError&gt;, WorkflowContext&gt; initialET =
    eitherTMonad.of(initialContext); // F&lt;Right(initialContext)&gt;

// Step 1: Validate Order (Synchronous - returns Either)
Kind&lt;EitherTKind.Witness&lt;CompletableFutureKind.Witness, DomainError&gt;, WorkflowContext&gt; validatedET =
    eitherTMonad.flatMap( // Use flatMap on EitherTMonad
        ctx -&gt; { // Lambda receives WorkflowContext if initialET was Right
            // Call sync step -&gt; Either&lt;DomainError, ValidatedOrder&gt;
            Either&lt;DomainError, ValidatedOrder&gt; syncResultEither =
                EITHER.narrow(steps.validateOrder(ctx.initialData()));

            // Lift sync Either into EitherT: -&gt; F&lt;Either&lt;DomainError, ValidatedOrder&gt;&gt;
            Kind&lt;EitherTKind.Witness&lt;CompletableFutureKind.Witness, DomainError&gt;, ValidatedOrder&gt;
                validatedOrderET = EitherT.fromEither(futureMonad, syncResultEither);

            // If validation produced Left, map is skipped.
            // If validation produced Right(vo), map updates the context: F&lt;Right(ctx.withValidatedOrder(vo))&gt;
            return eitherTMonad.map(ctx::withValidatedOrder, validatedOrderET);
        },
        initialET // Input to the flatMap
    );

// Step 2: Check Inventory (Asynchronous - returns Future&lt;Either&lt;DomainError, Void&gt;&gt;)
Kind&lt;EitherTKind.Witness&lt;CompletableFutureKind.Witness, DomainError&gt;, WorkflowContext&gt; inventoryET =
    eitherTMonad.flatMap( // Chain from validation result
        ctx -&gt; { // Executed only if validatedET was F&lt;Right(...)&gt;
            // Call async step -&gt; Kind&lt;CompletableFutureKind.Witness, Either&lt;DomainError, Void&gt;&gt;
            Kind&lt;CompletableFutureKind.Witness, Either&lt;DomainError, Void&gt;&gt; inventoryCheckFutureKind =
                steps.checkInventoryAsync(ctx.validatedOrder().productId(), ctx.validatedOrder().quantity());

            // Lift the F&lt;Either&gt; directly into EitherT using fromKind
            Kind&lt;EitherTKind.Witness&lt;CompletableFutureKind.Witness, DomainError&gt;, Void&gt; inventoryCheckET =
                EitherT.fromKind(inventoryCheckFutureKind);

            // If inventory check resolves to Right, update context. If Left, map is skipped.
            return eitherTMonad.map(ignored -&gt; ctx.withInventoryChecked(), inventoryCheckET);
        },
        validatedET // Input is result of validation step
    );

// Step 4: Create Shipment (Asynchronous with Recovery)
Kind&lt;EitherTKind.Witness&lt;CompletableFutureKind.Witness, DomainError&gt;, WorkflowContext&gt; shipmentET =
    eitherTMonad.flatMap( // Chain from previous step
        ctx -&gt; {
            // Call async shipment step -&gt; F&lt;Either&lt;DomainError, ShipmentInfo&gt;&gt;
            Kind&lt;CompletableFutureKind.Witness, Either&lt;DomainError, ShipmentInfo&gt;&gt; shipmentAttemptFutureKind =
                steps.createShipmentAsync(ctx.validatedOrder().orderId(), ctx.validatedOrder().shippingAddress());

            // Lift into EitherT
            Kind&lt;EitherTKind.Witness&lt;CompletableFutureKind.Witness, DomainError&gt;, ShipmentInfo&gt; shipmentAttemptET =
                 EitherT.fromKind(shipmentAttemptFutureKind);

            // *** Error Handling using MonadError ***
            Kind&lt;EitherTKind.Witness&lt;CompletableFutureKind.Witness, DomainError&gt;, ShipmentInfo&gt; recoveredShipmentET =
                eitherTMonad.handleErrorWith( // Operates on the EitherT value
                    shipmentAttemptET,
                    error -&gt; { // Lambda receives DomainError if shipmentAttemptET resolves to Left(error)
                        if (error instanceof DomainError.ShippingError se &amp;&amp; "Temporary Glitch".equals(se.reason())) {
                           // Specific recoverable error: Return a *successful* EitherT
                           return eitherTMonad.of(new ShipmentInfo("DEFAULT_SHIPPING_USED"));
                        } else {
                           // Non-recoverable error: Re-raise it within EitherT
                           return eitherTMonad.raiseError(error); // Returns F&lt;Left(error)&gt;
                        }
                    });

            // Map the potentially recovered result to update context
            return eitherTMonad.map(ctx::withShipmentInfo, recoveredShipmentET);
        },
        paymentET // Assuming paymentET was the previous step
    );

// ... rest of workflow ...

// Final unwrap
// EitherT&lt;CompletableFutureKind.Witness, DomainError, FinalResult&gt; finalET = ...;
// Kind&lt;CompletableFutureKind.Witness, Either&lt;DomainError, FinalResult&gt;&gt; finalResultKind = finalET.value();
</code></pre>
<p>This demonstrates how <code>EitherTMonad.flatMap</code> sequences the steps, while <code>EitherT.fromEither</code>, <code>EitherT.fromKind</code>, and <code>eitherTMonad.of/raiseError/handleErrorWith</code> manage the lifting and error handling within the combined <code>Future&lt;Either&lt;...&gt;&gt;</code> context.</p>
</div>
</div>
<div id="admonition-key-points" class="admonition admonish-tip" role="note" aria-labelledby="admonition-key-points-title">
<div class="admonition-title">
<div id="admonition-key-points-title">
<p>Key Points:</p>
</div>
<a class="admonition-anchor-link" href="transformers/eithert_transformer.html#admonition-key-points"></a>
</div>
<div>
<p>The <code>Higher-Kinded-J</code> library simplifies the implementation and usage of concepts like monad transformers (e.g., <code>EitherT</code>) in Java precisely <em>because</em> it simulates Higher-Kinded Types (HKTs). Here's how:</p>
<ol>
<li>
<p><strong>The Core Problem Without HKTs:</strong> Java's type system doesn't allow you to directly parameterize a type by a <em>type constructor</em> like <code>List</code>, <code>Optional</code>, or <code>CompletableFuture</code>. You can write <code>List&lt;String&gt;</code>, but you cannot easily write a generic class <code>Transformer&lt;F, A&gt;</code> where <code>F</code> itself represents <em>any</em> container type (like <code>List&lt;_&gt;</code>) and <code>A</code> is the value type.
This limitation makes defining <em>general</em> monad transformers rather difficult. A monad transformer like <code>EitherT</code> needs to combine an <em>arbitrary</em> outer monad <code>F</code> with the inner <code>Either</code> monad. Without HKTs, you would typically have to:</p>
<ul>
<li>Create separate, specific transformers for each outer monad (e.g., <code>EitherTOptional</code>, <code>EitherTFuture</code>, <code>EitherTIO</code>). This leads to significant code duplication.</li>
<li>Resort to complex, often unsafe casting or reflection.</li>
<li>Write extremely verbose code manually handling the nested structure for every combination.</li>
</ul>
</li>
<li>
<p><strong>How this helps with simulating HKTs):</strong> <code>Higher-Kinded-J</code> introduces the <code>Kind&lt;F, A&gt;</code> interface. This interface, along with specific "witness types" (like <code>OptionalKind.Witness</code>, <code>CompletableFutureKind.Witness</code>, <code>EitherKind.Witness&lt;L&gt;</code>), simulates the concept of <code>F&lt;A&gt;</code>. It allows you to pass <code>F</code> (the type constructor, represented by its witness type) as a type parameter, even though Java doesn't support it natively.</p>
</li>
<li>
<p><strong>Simplifying Transformer Definition (<code>EitherT&lt;F, L, R&gt;</code>):</strong> Because we can now simulate <code>F&lt;A&gt;</code> using <code>Kind&lt;F, A&gt;</code>, we can define the <code>EitherT</code> data structure generically:</p>
<pre><code class="language-java">// Simplified from EitherT.java
public record EitherT&lt;F, L, R&gt;(@NonNull Kind&lt;F, Either&lt;L, R&gt;&gt; value)
    implements EitherTKind&lt;F, L, R&gt; { /* ... */ }
</code></pre>
<p>Here, <code>F</code> is a type parameter representing the <em>witness type</em> of the outer monad. <code>EitherT</code> doesn't need to know <em>which</em> specific monad <code>F</code> is at compile time; it just knows it holds a <code>Kind&lt;F, ...&gt;</code>. This makes the <code>EitherT</code> structure itself general-purpose.</p>
</li>
<li>
<p><strong>Simplifying Transformer Operations (<code>EitherTMonad&lt;F, L&gt;</code>):</strong> The real benefit comes with the type class instance <code>EitherTMonad</code>. This class implements <code>MonadError&lt;EitherTKind.Witness&lt;F, L&gt;, L&gt;</code>, providing the standard monadic operations (<code>map</code>, <code>flatMap</code>, <code>of</code>, <code>ap</code>, <code>raiseError</code>, <code>handleErrorWith</code>) for the combined <code>EitherT</code> structure.</p>
<p>Critically, <code>EitherTMonad</code> takes the <code>Monad&lt;F&gt;</code> instance for the <em>specific outer monad</em><code>F</code> as a constructor argument:</p>
<pre><code class="language-java">// From EitherTMonad.java
public class EitherTMonad&lt;F, L&gt; implements MonadError&lt;EitherTKind.Witness&lt;F, L&gt;, L&gt; {
    private final @NonNull Monad&lt;F&gt; outerMonad; // &lt;-- Holds the specific outer monad instance

    public EitherTMonad(@NonNull Monad&lt;F&gt; outerMonad) {
        this.outerMonad = Objects.requireNonNull(outerMonad, "Outer Monad instance cannot be null");
    }
    // ... implementation of map, flatMap etc. ...
}
</code></pre>
<p>Inside its <code>map</code>, <code>flatMap</code>, etc., implementations, <code>EitherTMonad</code> uses the provided <code>outerMonad</code> instance (via its <code>map</code> and <code>flatMap</code> methods) to handle the outer context <code>F</code>, while also managing the inner <code>Either</code> logic (checking for <code>Left</code>/<code>Right</code>, applying functions, propagating <code>Left</code>).
<strong>This is where the Higher-Kinded-J drastically simplifies things:</strong></p>
</li>
</ol>
<ul>
<li>You only need <strong>one</strong><code>EitherTMonad</code> implementation.</li>
<li>It works <strong>generically</strong> for any outer monad <code>F</code><em>for which you have a <code>Monad&lt;F&gt;</code> instance</em> (like <code>OptionalMonad</code>, <code>CompletableFutureMonad</code>, <code>IOMonad</code>, etc.).</li>
<li>The complex logic of combining the two monads' behaviours (e.g., how <code>flatMap</code> should work on <code>F&lt;Either&lt;L, R&gt;&gt;</code>) is encapsulated <em>within</em><code>EitherTMonad</code>, leveraging the simulated HKTs and the provided <code>outerMonad</code> instance.</li>
<li>As a user, you just instantiate <code>EitherTMonad</code> with the appropriate outer monad instance and then use its standard methods (<code>map</code>, <code>flatMap</code>, etc.) on your <code>EitherT</code> values, as seen in the <code>OrderWorkflowRunner</code> example. You don't need to manually handle the nesting.</li>
</ul>
<p>In essence, the HKT simulation provided by <code>Higher-Kinded-J</code> allows defining the structure (<code>EitherT</code>) and the operations (<code>EitherTMonad</code>) generically over the outer monad <code>F</code>, overcoming Java's native limitations and making monad transformers feasible and much less boilerplate-heavy than they would otherwise be.</p>
</div>
</div>
<hr />
<h2 id="further-reading-1"><a class="header" href="#further-reading-1">Further Reading</a></h2>
<div id="admonition-learning-path" class="admonition admonish-tip" role="note" aria-labelledby="admonition-learning-path-title">
<div class="admonition-title">
<div id="admonition-learning-path-title">
<p>Learning Path</p>
</div>
<a class="admonition-anchor-link" href="transformers/eithert_transformer.html#admonition-learning-path"></a>
</div>
<div>
<p>Start with the <strong>Java-focused</strong> resources to see practical applications, then explore <strong>General FP concepts</strong> for deeper understanding, and finally check <strong>Related Libraries</strong> to see alternative approaches.</p>
</div>
</div>
<h3 id="java-focused-resources-1"><a class="header" href="#java-focused-resources-1">Java-Focused Resources</a></h3>
<p><strong>Beginner Level:</strong></p>
<ul>
<li>üìö <a href="https://www.baeldung.com/java-either">Error Handling with Either in Java</a> - Baeldung's introduction to Either (10 min read)</li>
<li>üìÑ <a href="https://www.nurkiewicz.com/2013/05/java-8-completablefuture-in-practice.html">CompletableFuture Error Handling Patterns</a> - Tomasz Nurkiewicz's comparison to traditional async error handling (15 min read)</li>
<li>üé• <a href="https://vimeo.com/113707214">Railway Oriented Programming in Java</a> - Scott Wlaschin's classic talk adapted to Java contexts (60 min watch)</li>
</ul>
<p><strong>Intermediate Level:</strong></p>
<ul>
<li>üìÑ <a href="https://medium.com/@johnmcclean/reactive-error-handling-with-cyclops-e2e82a3e5f5">Combining Async and Error Handling in Java</a> - Real-world async error workflows (20 min read)</li>
<li>üìÑ <a href="https://www.vavr.io/vavr-docs/#_either">Vavr's Either vs Java's Optional</a> - When to choose what (15 min read)</li>
</ul>
<p><strong>Advanced:</strong></p>
<ul>
<li>üî¨ <a href="https://www.youtube.com/watch?v=3VSdGPQXoZ0">Type-Safe Error Handling at Scale</a> - Zalando's production experience (conference talk, 40 min)</li>
</ul>
<h3 id="general-fp-concepts-1"><a class="header" href="#general-fp-concepts-1">General FP Concepts</a></h3>
<ul>
<li>üìñ <a href="https://fsharpforfunandprofit.com/rop/">Railway Oriented Programming</a> - F# for Fun and Profit's accessible explanation (20 min read)</li>
<li>üìñ <a href="https://www.manning.com/books/functional-programming-in-scala">Handling Errors Without Exceptions</a> - Chapter 4 from "Functional Programming in Scala" (free excerpt)</li>
<li>üåê <a href="https://en.wikipedia.org/wiki/Either_type">Either Type - Wikipedia</a> - Formal definition and language comparisons</li>
</ul>
<h3 id="related-libraries--comparisons-1"><a class="header" href="#related-libraries--comparisons-1">Related Libraries &amp; Comparisons</a></h3>
<ul>
<li>üîó <a href="https://www.vavr.io/vavr-docs/#_either">Vavr Either Documentation</a> - Mature Java FP library's approach</li>
<li>üîó <a href="https://arrow-kt.io/docs/apidocs/arrow-core/arrow.core/-either/">Arrow Either</a> - Kotlin's excellent API design</li>
<li>üîó <a href="https://doc.rust-lang.org/std/result/">Result Type in Rust</a> - See how a systems language solves this problem</li>
</ul>
<h3 id="community--discussion-1"><a class="header" href="#community--discussion-1">Community &amp; Discussion</a></h3>
<ul>
<li>üí¨ <a href="https://stackoverflow.com/questions/39868580/either-vs-exceptions-in-java">Either vs Exceptions in Java</a> - Stack Overflow debate with practical insights</li>
<li>üí¨ <a href="https://news.ycombinator.com/item?id=15716149">Using Either in Production Java Code</a> - Hacker News discussion with war stories</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="the-optionalt-transformer"><a class="header" href="#the-optionalt-transformer">The OptionalT Transformer:</a></h1>
<h2 id="combining-monadic-effects-with-javautiloptional"><a class="header" href="#combining-monadic-effects-with-javautiloptional"><em>Combining Monadic Effects with <code>java.util.Optional</code></em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="transformers/optionalt_transformer.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to integrate Java's Optional with other monadic contexts</li>
<li>Building async workflows where each step might return empty results</li>
<li>Using <code>some</code>, <code>none</code>, and <code>fromOptional</code> to construct OptionalT values</li>
<li>Creating multi-step data retrieval with graceful failure handling</li>
<li>Providing default values when optional chains result in empty</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code:</p>
</div>
<a class="admonition-anchor-link" href="transformers/optionalt_transformer.html#admonition-see-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/optional_t/OptionalTExample.java">OptionalTExample.java</a></p>
</div>
</div>
<h2 id="optionalt-monad-transformer"><a class="header" href="#optionalt-monad-transformer"><code>OptionalT</code> Monad Transformer</a></h2>
<p>The <code>OptionalT</code> monad transformer (short for Optional Transformer) is designed to combine the semantics of <code>java.util.Optional&lt;A&gt;</code> (representing a value that might be present or absent) with an arbitrary outer monad <code>F</code>. It effectively allows you to work with computations of type <code>Kind&lt;F, Optional&lt;A&gt;&gt;</code> as a single, unified monadic structure.</p>
<p>This is particularly useful when operations within an effectful context <code>F</code> (such as asynchronicity with <code>CompletableFutureKind</code>, non-determinism with <code>ListKind</code>, or dependency injection with <code>ReaderKind</code>) can also result in an absence of a value (represented by <code>Optional.empty()</code>).</p>
<h2 id="structure-9"><a class="header" href="#structure-9">Structure</a></h2>
<p><img src="transformers/../images/puml/optional_t_transformer.svg" alt="optional_t_transformer.svg" /></p>
<h2 id="optionaltf-a-the-core-data-type"><a class="header" href="#optionaltf-a-the-core-data-type"><code>OptionalT&lt;F, A&gt;</code>: The Core Data Type</a></h2>
<p><code>OptionalT&lt;F, A&gt;</code> is a record that wraps a computation yielding <code>Kind&lt;F, Optional&lt;A&gt;&gt;</code>.</p>
<pre><code class="language-java">public record OptionalT&lt;F, A&gt;(@NonNull Kind&lt;F, Optional&lt;A&gt;&gt; value)
    implements OptionalTKind&lt;F, A&gt; {
  // ... static factory methods ...
}
</code></pre>
<ul>
<li><strong><code>F</code></strong>: The witness type of the <strong>outer monad</strong> (e.g., <code>CompletableFutureKind.Witness</code>, <code>ListKind.Witness</code>). This monad encapsulates the primary effect of the computation.</li>
<li><strong><code>A</code></strong>: The type of the value that might be present within the **<code>Optional</code>, which itself is within the context of <code>F</code>.</li>
<li><strong><code>value</code></strong>: The core wrapped value of type **<code>Kind&lt;F, Optional&lt;A&gt;&gt;</code>. This represents an effectful computation <code>F</code> that, upon completion, yields a <code>java.util.Optional&lt;A&gt;</code>.</li>
</ul>
<h2 id="optionaltkindf-a-the-witness-type"><a class="header" href="#optionaltkindf-a-the-witness-type"><code>OptionalTKind&lt;F, A&gt;</code>: The Witness Type</a></h2>
<p><strong>For integration with Higher-Kinded-J's generic programming model,</strong> <code>OptionalTKind&lt;F, A&gt;</code> acts as the higher-kinded type witness.</p>
<ul>
<li><strong>It extends</strong> <code>Kind&lt;G, A&gt;</code>, where <code>G</code> (the witness for the combined <code>OptionalT</code> monad) is <code>OptionalTKind.Witness&lt;F&gt;</code>.</li>
<li><strong>The outer monad</strong> <code>F</code> is fixed for a particular <code>OptionalT</code> context, while <code>A</code> is the variable type parameter representing the value inside the <code>Optional</code>.</li>
</ul>
<pre><code class="language-java">public interface OptionalTKind&lt;F, A&gt; extends Kind&lt;OptionalTKind.Witness&lt;F&gt;, A&gt; {
  // Witness type G = OptionalTKind.Witness&lt;F&gt;
  // Value type A = A (from Optional&lt;A&gt;)
}
</code></pre>
<h2 id="optionaltkindhelper-utility-for-wrapping-and-unwrapping"><a class="header" href="#optionaltkindhelper-utility-for-wrapping-and-unwrapping"><code>OptionalTKindHelper</code>: Utility for Wrapping and Unwrapping</a></h2>
<p><code>OptionalTKindHelper</code> is a final utility class providing static methods to seamlessly convert between the concrete <code>OptionalT&lt;F, A&gt;</code> type and its <code>Kind</code> representation (<code>Kind&lt;OptionalTKind.Witness&lt;F&gt;, A&gt;</code>).</p>
<pre><code class="language-java">
public enum OptionalTKindHelper {
   
  OPTIONAL_T;
  
    // Unwraps Kind&lt;OptionalTKind.Witness&lt;F&gt;, A&gt; to OptionalT&lt;F, A&gt;
    public  &lt;F, A&gt; @NonNull OptionalT&lt;F, A&gt; narrow(
        @Nullable Kind&lt;OptionalTKind.Witness&lt;F&gt;, A&gt; kind);

    // Wraps OptionalT&lt;F, A&gt; into OptionalTKind&lt;F, A&gt;
    public  &lt;F, A&gt; @NonNull OptionalTKind&lt;F, A&gt; widen(
        @NonNull OptionalT&lt;F, A&gt; optionalT);
}
</code></pre>
<p><strong>Internally, it uses a private record</strong> <code>OptionalTHolder</code> to implement <code>OptionalTKind</code>, but this is an implementation detail.</p>
<h2 id="optionaltmonadf-operating-on-optionalt"><a class="header" href="#optionaltmonadf-operating-on-optionalt"><code>OptionalTMonad&lt;F&gt;</code>: Operating on <code>OptionalT</code></a></h2>
<p><strong>The</strong> <code>OptionalTMonad&lt;F&gt;</code> class implements <code>MonadError&lt;OptionalTKind.Witness&lt;F&gt;, Unit&gt;</code>. This provides the standard monadic operations (<code>of</code>, <code>map</code>, <code>flatMap</code>, <code>ap</code>) and error handling capabilities for the <code>OptionalT</code> structure. The error type <code>E</code> for <code>MonadError</code> is fixed to <code>Unit</code> signifying that an "error" in this context is the <code>Optional.empty()</code> state within <code>F&lt;Optional&lt;A&gt;&gt;</code>.</p>
<ul>
<li><strong>It requires a</strong> <code>Monad&lt;F&gt;</code> instance for the outer monad <code>F</code>, which must be supplied during construction. This <code>outerMonad</code> is used to manage and sequence the effects of <code>F</code>.</li>
</ul>
<pre><code class="language-java">// Example: F = CompletableFutureKind.Witness
// 1. Get the Monad instance for the outer monad F
Monad&lt;CompletableFutureKind.Witness&gt; futureMonad = CompletableFutureMonad.INSTANCE;

// 2. Create the OptionalTMonad
OptionalTMonad&lt;CompletableFutureKind.Witness&gt; optionalTFutureMonad =
    new OptionalTMonad&lt;&gt;(futureMonad);

// Now 'optionalTFutureMonad' can be used to operate on
// Kind&lt;OptionalTKind.Witness&lt;CompletableFutureKind.Witness&gt;, A&gt; values.

</code></pre>
<div id="admonition-key-operations-with-_optionaltmonad_" class="admonition admonish-info" role="note" aria-labelledby="admonition-key-operations-with-_optionaltmonad_-title">
<div class="admonition-title">
<div id="admonition-key-operations-with-_optionaltmonad_-title">
<p>Key Operations with <em>OptionalTMonad</em>:</p>
</div>
<a class="admonition-anchor-link" href="transformers/optionalt_transformer.html#admonition-key-operations-with-_optionaltmonad_"></a>
</div>
<div>
<ul>
<li><strong><code>optionalTMonad.of(value)</code></strong>: Lifts a (nullable) value <code>A</code> into the <code>OptionalT</code> context. The underlying operation is <code>r -&gt; outerMonad.of(Optional.ofNullable(value))</code>. Result: <code>OptionalT(F&lt;Optional&lt;A&gt;&gt;)</code>.</li>
<li><strong><code>optionalTMonad.map(func, optionalTKind)</code></strong>: Applies a function <code>A -&gt; B</code> to the value <code>A</code> if it's present within the <code>Optional</code> and the <code>F</code> context is successful. The transformation occurs within <code>outerMonad.map</code>. If <code>func</code> returns <code>null</code>, the result becomes <code>F&lt;Optional.empty()&gt;</code>. Result: <code>OptionalT(F&lt;Optional&lt;B&gt;&gt;)</code>.</li>
<li><strong><code>optionalTMonad.flatMap(func, optionalTKind)</code></strong>: The primary sequencing operation. It takes a function <code>A -&gt; Kind&lt;OptionalTKind.Witness&lt;F&gt;, B&gt;</code> (which effectively means <code>A -&gt; OptionalT&lt;F, B&gt;</code>). It runs the initial <code>OptionalT</code> to get <code>Kind&lt;F, Optional&lt;A&gt;&gt;</code>. Using <code>outerMonad.flatMap</code>, if this yields an <code>Optional.of(a)</code>, <code>func</code> is applied to <code>a</code> to get the next <code>OptionalT&lt;F, B&gt;</code>. The <code>value</code> of this new <code>OptionalT</code> (<code>Kind&lt;F, Optional&lt;B&gt;&gt;</code>) becomes the result. If at any point an <code>Optional.empty()</code> is encountered within <code>F</code>, it short-circuits and propagates <code>F&lt;Optional.empty()&gt;</code>. Result: <code>OptionalT(F&lt;Optional&lt;B&gt;&gt;)</code>.</li>
<li><strong><code>optionalTMonad.raiseError(error)</code></strong> (where error is <code>Unit</code>): Creates an <code>OptionalT</code> representing absence. Result: <code>OptionalT(F&lt;Optional.empty()&gt;)</code>.</li>
<li><strong><code>optionalTMonad.handleErrorWith(optionalTKind, handler)</code></strong>: Handles an empty state from the <em>inner</em> <code>Optional</code>. Takes a handler <code>Function&lt;Unit, Kind&lt;OptionalTKind.Witness&lt;F&gt;, A&gt;&gt;</code>.</li>
</ul>
</div>
</div>
<hr />
<div id="admonition-creating-_optionalt_-instances" class="admonition admonish-note" role="note" aria-labelledby="admonition-creating-_optionalt_-instances-title">
<div class="admonition-title">
<div id="admonition-creating-_optionalt_-instances-title">
<p>Creating <em>OptionalT</em> Instances</p>
</div>
<a class="admonition-anchor-link" href="transformers/optionalt_transformer.html#admonition-creating-_optionalt_-instances"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/optional_t/OptionalTExample.java">OptionalTExample.java</a></li>
</ul>
<p><code>OptionalT</code> instances are typically created using its static factory methods. These often require a <code>Monad&lt;F&gt;</code> instance for the outer monad.</p>
<pre><code class="language-java">public void createExample() {
    // --- Setup ---
    // Outer Monad F = CompletableFutureKind.Witness
    Monad&lt;CompletableFutureKind.Witness&gt; futureMonad = CompletableFutureMonad.INSTANCE;
    String presentValue = "Data";
    Integer numericValue = 123;

    // 1. `OptionalT.fromKind(Kind&lt;F, Optional&lt;A&gt;&gt; value)`
    //    Wraps an existing F&lt;Optional&lt;A&gt;&gt;.
    Kind&lt;CompletableFutureKind.Witness, Optional&lt;String&gt;&gt; fOptional =
        FUTURE.widen(CompletableFuture.completedFuture(Optional.of(presentValue)));
    OptionalT&lt;CompletableFutureKind.Witness, String&gt; ot1 = OptionalT.fromKind(fOptional);
    // Value: CompletableFuture&lt;Optional.of("Data")&gt;

    // 2. `OptionalT.some(Monad&lt;F&gt; monad, A a)`
    //    Creates an OptionalT with a present value, F&lt;Optional.of(a)&gt;.
    OptionalT&lt;CompletableFutureKind.Witness, String&gt; ot2 = OptionalT.some(futureMonad, presentValue);
    // Value: CompletableFuture&lt;Optional.of("Data")&gt;

    // 3. `OptionalT.none(Monad&lt;F&gt; monad)`
    //    Creates an OptionalT representing an absent value, F&lt;Optional.empty()&gt;.
    OptionalT&lt;CompletableFutureKind.Witness, String&gt; ot3 = OptionalT.none(futureMonad);
    // Value: CompletableFuture&lt;Optional.empty()&gt;

    // 4. `OptionalT.fromOptional(Monad&lt;F&gt; monad, Optional&lt;A&gt; optional)`
    //    Lifts a plain java.util.Optional into OptionalT, F&lt;Optional&lt;A&gt;&gt;.
    Optional&lt;Integer&gt; optInt = Optional.of(numericValue);
    OptionalT&lt;CompletableFutureKind.Witness, Integer&gt; ot4 = OptionalT.fromOptional(futureMonad, optInt);
    // Value: CompletableFuture&lt;Optional.of(123)&gt;


    Optional&lt;Integer&gt; optEmpty = Optional.empty();
    OptionalT&lt;CompletableFutureKind.Witness, Integer&gt; ot4Empty = OptionalT.fromOptional(futureMonad, optEmpty);
    // Value: CompletableFuture&lt;Optional.empty()&gt;


    // 5. `OptionalT.liftF(Monad&lt;F&gt; monad, Kind&lt;F, A&gt; fa)`
    //    Lifts an F&lt;A&gt; into OptionalT. If A is null, it becomes F&lt;Optional.empty()&gt;, otherwise F&lt;Optional.of(A)&gt;.
    Kind&lt;CompletableFutureKind.Witness, String&gt; fValue =
        FUTURE.widen(CompletableFuture.completedFuture(presentValue));
    OptionalT&lt;CompletableFutureKind.Witness, String&gt; ot5 = OptionalT.liftF(futureMonad, fValue);
    // Value: CompletableFuture&lt;Optional.of("Data   ")&gt;

    Kind&lt;CompletableFutureKind.Witness, String&gt; fNullValue =
        FUTURE.widen(CompletableFuture.completedFuture(null)); // F&lt;null&gt;
    OptionalT&lt;CompletableFutureKind.Witness, String&gt; ot5Null = OptionalT.liftF(futureMonad, fNullValue);
    // Value: CompletableFuture&lt;Optional.empty()&gt; (because the value inside F was null)


    // Accessing the wrapped value:
    Kind&lt;CompletableFutureKind.Witness, Optional&lt;String&gt;&gt; wrappedFVO = ot1.value();
    CompletableFuture&lt;Optional&lt;String&gt;&gt; futureOptional = FUTURE.narrow(wrappedFVO);
    futureOptional.thenAccept(optStr -&gt; System.out.println("ot1 result: " + optStr));
  }
</code></pre>
</div>
</div>
<div id="admonition-asynchronous-multi-step-data-retrieval" class="admonition admonish-note" role="note" aria-labelledby="admonition-asynchronous-multi-step-data-retrieval-title">
<div class="admonition-title">
<div id="admonition-asynchronous-multi-step-data-retrieval-title">
<p>Asynchronous Multi-Step Data Retrieval</p>
</div>
<a class="admonition-anchor-link" href="transformers/optionalt_transformer.html#admonition-asynchronous-multi-step-data-retrieval"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/optional_t/OptionalTExample.java">OptionalTExample.java</a></li>
</ul>
<p>Consider a scenario where you need to fetch a userLogin, then their profile, and finally their preferences. Each step is asynchronous (<code>CompletableFuture</code>) and might return an empty <code>Optional</code> if the data is not found. <code>OptionalT</code> helps manage this composition cleanly.</p>
<pre><code class="language-java">public static class OptionalTAsyncExample {

    // --- Monad Setup ---
    static final Monad&lt;CompletableFutureKind.Witness&gt; futureMonad = CompletableFutureMonad.INSTANCE;
    static final OptionalTMonad&lt;CompletableFutureKind.Witness&gt; optionalTFutureMonad =
        new OptionalTMonad&lt;&gt;(futureMonad);
    static final ExecutorService executor = Executors.newFixedThreadPool(2);

    public static Kind&lt;CompletableFutureKind.Witness, Optional&lt;User&gt;&gt; fetchUserAsync(String userId) {
      return FUTURE.widen(CompletableFuture.supplyAsync(() -&gt; {
        System.out.println("Fetching userLogin " + userId + " on " + Thread.currentThread().getName());
        try {
          TimeUnit.MILLISECONDS.sleep(50);
        } catch (InterruptedException e) { /* ignore */ }
        return "user1".equals(userId) ? Optional.of(new User(userId, "Alice")) : Optional.empty();
      }, executor));
    }

    public static Kind&lt;CompletableFutureKind.Witness, Optional&lt;UserProfile&gt;&gt; fetchProfileAsync(String userId) {
      return FUTURE.widen(CompletableFuture.supplyAsync(() -&gt; {
        System.out.println("Fetching profile for " + userId + " on " + Thread.currentThread().getName());
        try {
          TimeUnit.MILLISECONDS.sleep(50);
        } catch (InterruptedException e) { /* ignore */ }
        return "user1".equals(userId) ? Optional.of(new UserProfile(userId, "Loves HKJ")) : Optional.empty();
      }, executor));
    }

    public static Kind&lt;CompletableFutureKind.Witness, Optional&lt;UserPreferences&gt;&gt; fetchPrefsAsync(String userId) {
      return FUTURE.widen(CompletableFuture.supplyAsync(() -&gt; {
        System.out.println("Fetching preferences for " + userId + " on " + Thread.currentThread().getName());
        try {
          TimeUnit.MILLISECONDS.sleep(50);
        } catch (InterruptedException e) { /* ignore */ }
        // Simulate preferences sometimes missing even for a valid userLogin
        return "user1".equals(userId) &amp;&amp; Math.random() &gt; 0.3 ? Optional.of(new UserPreferences(userId, "dark")) : Optional.empty();
      }, executor));
    }

    // --- Service Stubs (simulating async calls returning Future&lt;Optional&lt;T&gt;&gt;) ---

    // --- Workflow using OptionalT ---
    public static OptionalT&lt;CompletableFutureKind.Witness, UserPreferences&gt; getFullUserPreferences(String userId) {
      // Start by fetching the userLogin, lifting into OptionalT
      OptionalT&lt;CompletableFutureKind.Witness, User&gt; userOT =
          OptionalT.fromKind(fetchUserAsync(userId));

      // If userLogin exists, fetch profile
      OptionalT&lt;CompletableFutureKind.Witness, UserProfile&gt; profileOT =
          OPTIONAL_T.narrow(
              optionalTFutureMonad.flatMap(
                  userLogin -&gt; OPTIONAL_T.widen(OptionalT.fromKind(fetchProfileAsync(userLogin.id()))),
                  OPTIONAL_T.widen(userOT)
              )
          );

      // If profile exists, fetch preferences
      OptionalT&lt;CompletableFutureKind.Witness, UserPreferences&gt; preferencesOT =
          OPTIONAL_T.narrow(
              optionalTFutureMonad.flatMap(
                  profile -&gt; OPTIONAL_T.widen(OptionalT.fromKind(fetchPrefsAsync(profile.userId()))),
                  OPTIONAL_T.widen(profileOT)
              )
          );
      return preferencesOT;
    }

    // Workflow with recovery / default
    public static OptionalT&lt;CompletableFutureKind.Witness, UserPreferences&gt; getPrefsWithDefault(String userId) {
      OptionalT&lt;CompletableFutureKind.Witness, UserPreferences&gt; prefsAttemptOT = getFullUserPreferences(userId);

      Kind&lt;OptionalTKind.Witness&lt;CompletableFutureKind.Witness&gt;, UserPreferences&gt; recoveredPrefsOTKind =
          optionalTFutureMonad.handleErrorWith(
              OPTIONAL_T.widen(prefsAttemptOT),
              (Unit v) -&gt; { // This lambda is called if prefsAttemptOT results in F&lt;Optional.empty()&gt;
                System.out.println("Preferences not found for " + userId + ", providing default.");
                // Lift a default preference into OptionalT
                UserPreferences defaultPrefs = new UserPreferences(userId, "default-light");
                return OPTIONAL_T.widen(OptionalT.some(futureMonad, defaultPrefs));
              }
          );
      return OPTIONAL_T.narrow(recoveredPrefsOTKind);
    }

    public static void main(String[] args) {
      System.out.println("--- Attempting to get preferences for existing userLogin (user1) ---");
      OptionalT&lt;CompletableFutureKind.Witness, UserPreferences&gt; resultUser1OT = getFullUserPreferences("user1");
      CompletableFuture&lt;Optional&lt;UserPreferences&gt;&gt; future1 =
          FUTURE.narrow(resultUser1OT.value());

      future1.whenComplete((optPrefs, ex) -&gt; {
        if (ex != null) {
          System.err.println("Error for user1: " + ex.getMessage());
        } else {
          System.out.println("User1 Preferences: " + optPrefs.map(UserPreferences::toString).orElse("NOT FOUND"));
        }
      });


      System.out.println("\n--- Attempting to get preferences for non-existing userLogin (user2) ---");
      OptionalT&lt;CompletableFutureKind.Witness, UserPreferences&gt; resultUser2OT = getFullUserPreferences("user2");
      CompletableFuture&lt;Optional&lt;UserPreferences&gt;&gt; future2 =
          FUTURE.narrow(resultUser2OT.value());

      future2.whenComplete((optPrefs, ex) -&gt; {
        if (ex != null) {
          System.err.println("Error for user2: " + ex.getMessage());
        } else {
          System.out.println("User2 Preferences: " + optPrefs.map(UserPreferences::toString).orElse("NOT FOUND (as expected)"));
        }
      });

      System.out.println("\n--- Attempting to get preferences for user1 WITH DEFAULT ---");
      OptionalT&lt;CompletableFutureKind.Witness, UserPreferences&gt; resultUser1WithDefaultOT = getPrefsWithDefault("user1");
      CompletableFuture&lt;Optional&lt;UserPreferences&gt;&gt; future3 =
          FUTURE.narrow(resultUser1WithDefaultOT.value());

      future3.whenComplete((optPrefs, ex) -&gt; {
        if (ex != null) {
          System.err.println("Error for user1 (with default): " + ex.getMessage());
        } else {
          // This will either be the fetched prefs or the default.
          System.out.println("User1 Preferences (with default): " + optPrefs.map(UserPreferences::toString).orElse("THIS SHOULD NOT HAPPEN if default works"));
        }
        // Wait for async operations to complete for demonstration
        try {
          TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
          Thread.currentThread().interrupt();
        }
        executor.shutdown();
      });
    }

    // --- Domain Model ---
    record User(String id, String name) {
    }

    record UserProfile(String userId, String bio) {
    }

    record UserPreferences(String userId, String theme) {
    }
  }
</code></pre>
<p><strong>This example demonstrates:</strong></p>
<ol>
<li><strong>Setting up</strong> <code>OptionalTMonad</code> with <code>CompletableFutureMonad</code>.</li>
<li><strong>Using</strong> <code>OptionalT.fromKind</code> to lift an existing <code>Kind&lt;F, Optional&lt;A&gt;&gt;</code> (the result of async service calls) into the <code>OptionalT</code> context.</li>
<li><strong>Sequencing operations with</strong> <code>optionalTFutureMonad.flatMap</code>. If any step in the chain (e.g., <code>fetchUserAsync</code>) results in <code>F&lt;Optional.empty()&gt;</code>, subsequent <code>flatMap</code> lambdas are short-circuited, and the overall result becomes <code>F&lt;Optional.empty()&gt;</code>.</li>
<li><strong>Using</strong> <code>handleErrorWith</code> to provide a default <code>UserPreferences</code> if the chain of operations results in an empty <code>Optional</code>.</li>
<li><strong>Finally,</strong> <code>.value()</code> is used to extract the underlying <code>Kind&lt;CompletableFutureKind.Witness, Optional&lt;UserPreferences&gt;&gt;</code> to interact with the <code>CompletableFuture</code> directly.</li>
</ol>
<p><code>OptionalT</code> simplifies managing sequences of operations where each step might not yield a value.</p>
</div>
</div>
<hr />
<h2 id="further-reading-2"><a class="header" href="#further-reading-2">Further Reading</a></h2>
<div id="admonition-learning-path" class="admonition admonish-tip" role="note" aria-labelledby="admonition-learning-path-title">
<div class="admonition-title">
<div id="admonition-learning-path-title">
<p>Learning Path</p>
</div>
<a class="admonition-anchor-link" href="transformers/optionalt_transformer.html#admonition-learning-path"></a>
</div>
<div>
<p>Start with the <strong>Java-focused</strong> resources to understand Optional patterns, then explore <strong>General FP concepts</strong> for deeper understanding, and finally check <strong>Related Libraries</strong> to see alternative approaches.</p>
</div>
</div>
<h3 id="java-focused-resources-2"><a class="header" href="#java-focused-resources-2">Java-Focused Resources</a></h3>
<p><strong>Beginner Level:</strong></p>
<ul>
<li>üìö <a href="https://www.baeldung.com/java-optional">Java Optional Best Practices</a> - Comprehensive Baeldung guide (20 min read)</li>
<li>üìÑ <a href="https://www.nurkiewicz.com/2013/08/optional-in-java-8-cheat-sheet.html">The Mother of All Bikesheds: Optional.orElse vs orElseGet</a> - Tomasz Nurkiewicz's practical guide (10 min read)</li>
<li>üé• <a href="https://www.youtube.com/watch?v=vKVzRbsMnTQ">Java Optional - A Practical Guide</a> - Stuart Marks (Oracle) on proper Optional usage (60 min watch)</li>
</ul>
<p><strong>Intermediate Level:</strong></p>
<ul>
<li>üìÑ <a href="https://www.baeldung.com/java-optional-chaining">Chaining Optional in Java</a> - flatMap patterns and composition (15 min read)</li>
<li>üìÑ <a href="https://blog.softwaremill.com/12-recipes-for-using-the-optional-class-as-its-meant-to-be-used-2da0d7f0b6a8">Optional Anti-Patterns</a> - What NOT to do (12 min read)</li>
</ul>
<h3 id="general-fp-concepts-2"><a class="header" href="#general-fp-concepts-2">General FP Concepts</a></h3>
<ul>
<li>üìñ <a href="https://wiki.haskell.org/Maybe">Maybe Monad Explained</a> - Haskell's Maybe (Java's Optional equivalent)</li>
<li>üìñ <a href="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/">Null References: The Billion Dollar Mistake</a> - Tony Hoare's historic talk on why Optional matters (10 min read)</li>
</ul>
<h3 id="related-libraries--comparisons-2"><a class="header" href="#related-libraries--comparisons-2">Related Libraries &amp; Comparisons</a></h3>
<ul>
<li>üîó <a href="https://www.vavr.io/vavr-docs/#_option">Vavr Option</a> - More functional than Java's Optional</li>
<li>üîó <a href="https://github.com/google/guava/wiki/UsingAndAvoidingNullExplained">Guava's Optional</a> - Pre-Java 8 approach, still relevant</li>
<li>üîó <a href="https://kotlinlang.org/docs/null-safety.html">Kotlin Null Safety</a> - Language-level solution to the same problem</li>
</ul>
<h3 id="community--discussion-2"><a class="header" href="#community--discussion-2">Community &amp; Discussion</a></h3>
<ul>
<li>üí¨ <a href="https://stackoverflow.com/questions/39754106/when-to-return-optional-instead-of-throwing-an-exception">When to Return Optional vs Throw Exception</a> - Stack Overflow debate</li>
<li>üí¨ <a href="https://shipilev.net/jvm/anatomy-quarks/11-optional-sequential-guards/">Optional Performance Considerations</a> - Aleksey Shipil√´v's JVM deep dive</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="the-maybet-transformer"><a class="header" href="#the-maybet-transformer">The MaybeT Transformer:</a></h1>
<h2 id="combining-monadic-effects-with-optionality"><a class="header" href="#combining-monadic-effects-with-optionality"><em>Combining Monadic Effects with Optionality</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="transformers/maybet_transformer.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to combine Maybe's optionality with other monadic effects</li>
<li>Building workflows where operations might produce Nothing within async contexts</li>
<li>Understanding the difference between MaybeT and OptionalT</li>
<li>Using <code>just</code>, <code>nothing</code>, and <code>fromMaybe</code> to construct MaybeT values</li>
<li>Handling Nothing states with Unit as the error type in MonadError</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code:</p>
</div>
<a class="admonition-anchor-link" href="transformers/maybet_transformer.html#admonition-see-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/maybe_t/MaybeTExample.java">MaybeTExample.java</a></p>
</div>
</div>
## `MaybeT` Monad Transformer.
<p><img src="transformers/../images/puml/maybet_transformer.svg" alt="maybet_transformer.svg" /></p>
<h2 id="maybetf-a-combining-any-monad-f-with-maybea"><a class="header" href="#maybetf-a-combining-any-monad-f-with-maybea"><code>MaybeT&lt;F, A&gt;</code>: Combining Any Monad <code>F</code> with <code>Maybe&lt;A&gt;</code></a></h2>
<p>The <code>MaybeT</code> monad transformer allows you to combine the optionality of <code>Maybe&lt;A&gt;</code> (representing a value that might be
<code>Just&lt;A&gt;</code> or <code>Nothing</code>) with another outer monad <code>F</code>. It transforms a computation that results in <code>Kind&lt;F, Maybe&lt;A&gt;&gt;</code>
into a single monadic structure. This is useful for operations within an effectful context <code>F</code> (like
<code>CompletableFutureKind</code> for async operations or <code>ListKind</code> for non-deterministic computations) that can also result in
an absence of a value.</p>
<ul>
<li><strong><code>F</code></strong>: The witness type of the <strong>outer monad</strong> (e.g., <code>CompletableFutureKind.Witness</code>, <code>ListKind.Witness</code>). This
monad handles the primary effect (e.g., asynchronicity, non-determinism).</li>
<li><strong><code>A</code></strong>: The type of the value potentially held by the inner <code>Maybe</code>.</li>
</ul>
<pre><code>// From: org.higherkindedj.hkt.maybe_t.MaybeT
public record MaybeT&lt;F, A&gt;(@NonNull Kind&lt;F, Maybe&lt;A&gt;&gt; value) { 
/* ... static factories ... */ }
</code></pre>
<p><code>MaybeT&lt;F, A&gt;</code> wraps a value of type <code>Kind&lt;F, Maybe&lt;A&gt;&gt;</code>. It signifies a computation in the context of <code>F</code> that will
eventually produce a <code>Maybe&lt;A&gt;</code>. The main benefit comes from its associated type class instance, <code>MaybeTMonad</code>, which
provides monadic operations for this combined structure.</p>
<h2 id="maybetkindf-a-the-witness-type"><a class="header" href="#maybetkindf-a-the-witness-type"><code>MaybeTKind&lt;F, A&gt;</code>: The Witness Type</a></h2>
<p>Similar to other HKTs in Higher-Kinded-J, <code>MaybeT</code> uses <code>MaybeTKind&lt;F, A&gt;</code> as its witness type for use in generic
functions.</p>
<ul>
<li>It extends <code>Kind&lt;G, A&gt;</code> where <code>G</code> (the witness for the combined monad) is <code>MaybeTKind.Witness&lt;F&gt;</code>.</li>
<li><code>F</code> is fixed for a specific <code>MaybeT</code> context, while <code>A</code> is the variable type parameter.</li>
</ul>
<pre><code class="language-java">public interface MaybeTKind&lt;F, A&gt; extends Kind&lt;MaybeTKind.Witness&lt;F&gt;, A&gt; {
  // Witness type G = MaybeTKind.Witness&lt;F&gt;
  // Value type A = A (from Maybe&lt;A&gt;)
}
</code></pre>
<h2 id="maybetkindhelper"><a class="header" href="#maybetkindhelper"><code>MaybeTKindHelper</code></a></h2>
<ul>
<li>This utility class provides static <code>wrap</code> and <code>unwrap</code> methods for safe conversion between the concrete <code>MaybeT&lt;F, A&gt;</code>
and its <code>Kind</code> representation (<code>Kind&lt;MaybeTKind.Witness&lt;F&gt;, A&gt;</code>).</li>
</ul>
<pre><code class="language-java">// To wrap:
// MaybeT&lt;F, A&gt; maybeT = ...;
Kind&lt;MaybeTKind.Witness&lt;F&gt;, A&gt; kind = MAYBE_T.widen(maybeT);
// To unwrap:
MaybeT&lt;F, A&gt; unwrappedMaybeT = MAYBE_T.narrow(kind);
</code></pre>
<h2 id="maybetmonadf-operating-on-maybet"><a class="header" href="#maybetmonadf-operating-on-maybet"><code>MaybeTMonad&lt;F&gt;</code>: Operating on <code>MaybeT</code></a></h2>
<p>The <code>MaybeTMonad&lt;F&gt;</code> class implements <code>MonadError&lt;MaybeTKind.Witness&lt;F&gt;, Unit&gt;</code>. The error type <code>E</code> for <code>MonadError</code> is fixed to <code>Unit</code>, signifying that an "error" in this context is the <code>Maybe.nothing()</code> state within the <code>F&lt;Maybe&lt;A&gt;&gt;</code> structure.
<code>MaybeT</code> represents failure (or absence) as <code>Nothing</code>, which doesn't carry an error value itself.</p>
<ul>
<li>It requires a <code>Monad&lt;F&gt;</code> instance for the outer monad <code>F</code>, provided during construction. This instance is used to
manage the effects of <code>F</code>.</li>
<li>It uses <code>MaybeTKindHelper.wrap</code> and <code>MaybeTKindHelper.unwrap</code> for conversions.</li>
<li>Operations like <code>raiseError(Unit.INSTANCE)</code> will create a <code>MaybeT</code> representing <code>F&lt;Nothing&gt;</code>.
The <code>Unit.INSTANCE</code> signifies the <code>Nothing</code> state without carrying a separate error value.</li>
<li><code>handleErrorWith</code> allows "recovering" from a <code>Nothing</code> state by providing an alternative <code>MaybeT</code>. The handler function passed to <code>handleErrorWith</code> will receive <code>Unit.INSTANCE</code> if a <code>Nothing</code> state is encountered.</li>
</ul>
<pre><code class="language-java">// Example: F = CompletableFutureKind.Witness, Error type for MonadError is Unit
// 1. Get the Monad instance for the outer monad F
Monad&lt;CompletableFutureKind.Witness&gt; futureMonad = CompletableFutureMonad.INSTANCE; 

// 2. Create the MaybeTMonad, providing the outer monad instance
MonadError&lt;MaybeTKind.Witness&lt;CompletableFutureKind.Witness&gt;, Unit&gt; maybeTMonad =
    new MaybeTMonad&lt;&gt;(futureMonad);

// Now 'maybeTMonad' can be used to operate on Kind&lt;MaybeTKind.Witness&lt;CompletableFutureKind.Witness&gt;, A&gt; values.
</code></pre>
<div id="admonition-key-operations-with-_maybetmonad_" class="admonition admonish-info" role="note" aria-labelledby="admonition-key-operations-with-_maybetmonad_-title">
<div class="admonition-title">
<div id="admonition-key-operations-with-_maybetmonad_-title">
<p>Key Operations with <em>MaybeTMonad</em>:</p>
</div>
<a class="admonition-anchor-link" href="transformers/maybet_transformer.html#admonition-key-operations-with-_maybetmonad_"></a>
</div>
<div>
<ul>
<li><strong><code>maybeTMonad.of(value)</code>:</strong> Lifts a nullable value <code>A</code> into the <code>MaybeT</code> context. Result:
<code>F&lt;Maybe.fromNullable(value)&gt;</code>.</li>
<li><strong><code>maybeTMonad.map(f, maybeTKind)</code>:</strong> Applies function <code>A -&gt; B</code> to the <code>Just</code> value inside the nested structure. If
it's <code>Nothing</code>, or <code>f</code> returns <code>null</code>, it propagates <code>F&lt;Nothing&gt;</code>.</li>
<li><strong><code>maybeTMonad.flatMap(f, maybeTKind)</code>:</strong> Sequences operations. Takes <code>A -&gt; Kind&lt;MaybeTKind.Witness&lt;F&gt;, B&gt;</code>. If the
input is <code>F&lt;Just(a)&gt;</code>, it applies <code>f(a)</code> to get the next <code>MaybeT&lt;F, B&gt;</code> and extracts its <code>Kind&lt;F, Maybe&lt;B&gt;&gt;</code>. If
<code>F&lt;Nothing&gt;</code>, it propagates <code>F&lt;Nothing&gt;</code>.</li>
<li><strong><code>maybeTMonad.raiseError(Unit.INSTANCE)</code>:</strong> Creates <code>MaybeT</code> representing <code>F&lt;Nothing&gt;</code>.</li>
<li><strong><code>maybeTMonad.handleErrorWith(maybeTKind, handler)</code>:</strong> Handles a <code>Nothing</code> state. The handler
<code>Unit -&gt; Kind&lt;MaybeTKind.Witness&lt;F&gt;, A&gt;</code> is invoked with <code>null</code>.</li>
</ul>
</div>
</div>
<hr />
<div id="admonition-creating-_maybet_-instances" class="admonition admonish-note" role="note" aria-labelledby="admonition-creating-_maybet_-instances-title">
<div class="admonition-title">
<div id="admonition-creating-_maybet_-instances-title">
<p>Creating <em>MaybeT</em> Instances</p>
</div>
<a class="admonition-anchor-link" href="transformers/maybet_transformer.html#admonition-creating-_maybet_-instances"></a>
</div>
<div>
<p><code>MaybeT</code> instances are typically created using its static factory methods, often requiring the outer <code>Monad&lt;F&gt;</code>
instance:</p>
<pre><code class="language-java">public void createExample() {
    Monad&lt;OptionalKind.Witness&gt; optMonad = OptionalMonad.INSTANCE; // Outer Monad F=Optional
    String presentValue = "Hello";

    // 1. Lifting a non-null value: Optional&lt;Just(value)&gt;
    MaybeT&lt;OptionalKind.Witness, String&gt; mtJust = MaybeT.just(optMonad, presentValue);
    // Resulting wrapped value: Optional.of(Maybe.just("Hello"))

    // 2. Creating a 'Nothing' state: Optional&lt;Nothing&gt;
    MaybeT&lt;OptionalKind.Witness, String&gt; mtNothing = MaybeT.nothing(optMonad);
    // Resulting wrapped value: Optional.of(Maybe.nothing())

    // 3. Lifting a plain Maybe: Optional&lt;Maybe(input)&gt;
    Maybe&lt;Integer&gt; plainMaybe = Maybe.just(123);
    MaybeT&lt;OptionalKind.Witness, Integer&gt; mtFromMaybe = MaybeT.fromMaybe(optMonad, plainMaybe);
    // Resulting wrapped value: Optional.of(Maybe.just(123))

    Maybe&lt;Integer&gt; plainNothing = Maybe.nothing();
    MaybeT&lt;OptionalKind.Witness, Integer&gt; mtFromMaybeNothing = MaybeT.fromMaybe(optMonad, plainNothing);
    // Resulting wrapped value: Optional.of(Maybe.nothing())


    // 4. Lifting an outer monad value F&lt;A&gt;: Optional&lt;Maybe&lt;A&gt;&gt; (using fromNullable)
    Kind&lt;OptionalKind.Witness, String&gt; outerOptional = OPTIONAL.widen(Optional.of("World"));
    MaybeT&lt;OptionalKind.Witness, String&gt; mtLiftF = MaybeT.liftF(optMonad, outerOptional);
    // Resulting wrapped value: Optional.of(Maybe.just("World"))

    Kind&lt;OptionalKind.Witness, String&gt; outerEmptyOptional = OPTIONAL.widen(Optional.empty());
    MaybeT&lt;OptionalKind.Witness, String&gt; mtLiftFEmpty = MaybeT.liftF(optMonad, outerEmptyOptional);
    // Resulting wrapped value: Optional.of(Maybe.nothing())


    // 5. Wrapping an existing nested Kind: F&lt;Maybe&lt;A&gt;&gt;
    Kind&lt;OptionalKind.Witness, Maybe&lt;String&gt;&gt; nestedKind =
        OPTIONAL.widen(Optional.of(Maybe.just("Present")));
    MaybeT&lt;OptionalKind.Witness, String&gt; mtFromKind = MaybeT.fromKind(nestedKind);
    // Resulting wrapped value: Optional.of(Maybe.just("Present"))

    // Accessing the wrapped value:
    Kind&lt;OptionalKind.Witness, Maybe&lt;String&gt;&gt; wrappedValue = mtJust.value();
    Optional&lt;Maybe&lt;String&gt;&gt; unwrappedOptional = OPTIONAL.narrow(wrappedValue);
    // unwrappedOptional is Optional.of(Maybe.just("Hello"))
  }
</code></pre>
</div>
</div>
<div id="admonition-asynchronous-optional-resource-fetching" class="admonition admonish-note" role="note" aria-labelledby="admonition-asynchronous-optional-resource-fetching-title">
<div class="admonition-title">
<div id="admonition-asynchronous-optional-resource-fetching-title">
<p>Asynchronous Optional Resource Fetching</p>
</div>
<a class="admonition-anchor-link" href="transformers/maybet_transformer.html#admonition-asynchronous-optional-resource-fetching"></a>
</div>
<div>
<p>Let's consider fetching a userLogin and then their preferences, where each step is asynchronous and might not return a value.</p>
<pre><code class="language-java">public static class MaybeTAsyncExample {
  // --- Setup ---
  Monad&lt;CompletableFutureKind.Witness&gt; futureMonad = CompletableFutureMonad.INSTANCE;
  MonadError&lt;MaybeTKind.Witness&lt;CompletableFutureKind.Witness&gt;, Unit&gt; maybeTMonad =
      new MaybeTMonad&lt;&gt;(futureMonad);

  // Simulates fetching a userLogin asynchronously
  Kind&lt;CompletableFutureKind.Witness, Maybe&lt;User&gt;&gt; fetchUserAsync(String userId) {
    System.out.println("Fetching userLogin: " + userId);
    CompletableFuture&lt;Maybe&lt;User&gt;&gt; future = CompletableFuture.supplyAsync(() -&gt; {
      try {
        TimeUnit.MILLISECONDS.sleep(50);
      } catch (InterruptedException e) { /* ignore */ }
      if ("user123".equals(userId)) {
        return Maybe.just(new User(userId, "Alice"));
      }
      return Maybe.nothing();
    });
    return FUTURE.widen(future);
  }

  // Simulates fetching userLogin preferences asynchronously
  Kind&lt;CompletableFutureKind.Witness, Maybe&lt;UserPreferences&gt;&gt; fetchPreferencesAsync(String userId) {
    System.out.println("Fetching preferences for userLogin: " + userId);
    CompletableFuture&lt;Maybe&lt;UserPreferences&gt;&gt; future = CompletableFuture.supplyAsync(() -&gt; {
      try {
        TimeUnit.MILLISECONDS.sleep(30);
      } catch (InterruptedException e) { /* ignore */ }
      if ("user123".equals(userId)) {
        return Maybe.just(new UserPreferences(userId, "dark-mode"));
      }
      return Maybe.nothing(); // No preferences for other users or if userLogin fetch failed
    });
    return FUTURE.widen(future);
  }

  // --- Service Stubs (returning Future&lt;Maybe&lt;T&gt;&gt;) ---

  // Function to run the workflow for a given userId
  Kind&lt;CompletableFutureKind.Witness, Maybe&lt;UserPreferences&gt;&gt; getUserPreferencesWorkflow(String userIdToFetch) {

    // Step 1: Fetch User
    // Directly use MaybeT.fromKind as fetchUserAsync already returns F&lt;Maybe&lt;User&gt;&gt;
    Kind&lt;MaybeTKind.Witness&lt;CompletableFutureKind.Witness&gt;, User&gt; userMT =
        MAYBE_T.widen(MaybeT.fromKind(fetchUserAsync(userIdToFetch)));

    // Step 2: Fetch Preferences if User was found
    Kind&lt;MaybeTKind.Witness&lt;CompletableFutureKind.Witness&gt;, UserPreferences&gt; preferencesMT =
        maybeTMonad.flatMap(
            userLogin -&gt; { // This lambda is only called if userMT contains F&lt;Just(userLogin)&gt;
              System.out.println("User found: " + userLogin.name() + ". Now fetching preferences.");
              // fetchPreferencesAsync returns Kind&lt;CompletableFutureKind.Witness, Maybe&lt;UserPreferences&gt;&gt;
              // which is F&lt;Maybe&lt;A&gt;&gt;, so we can wrap it directly.
              return MAYBE_T.widen(MaybeT.fromKind(fetchPreferencesAsync(userLogin.id())));
            },
            userMT // Input to flatMap
        );

    // Try to recover if preferences are Nothing, but userLogin was found (conceptual)
    Kind&lt;MaybeTKind.Witness&lt;CompletableFutureKind.Witness&gt;, UserPreferences&gt; preferencesWithDefaultMT =
        maybeTMonad.handleErrorWith(preferencesMT, (Unit v) -&gt; { // Handler for Nothing
          System.out.println("Preferences not found, attempting to use default.");
          // We need userId here. For simplicity, let's assume we could get it or just return nothing.
          // This example shows returning nothing again if we can't provide a default.
          // A real scenario might try to fetch default preferences or construct one.
          return maybeTMonad.raiseError(Unit.INSTANCE); // Still Nothing, or could be MaybeT.just(defaultPrefs)
        });


    // Unwrap the final MaybeT to get the underlying Future&lt;Maybe&lt;UserPreferences&gt;&gt;
    MaybeT&lt;CompletableFutureKind.Witness, UserPreferences&gt; finalMaybeT =
        MAYBE_T.narrow(preferencesWithDefaultMT); // or preferencesMT if no recovery
    return finalMaybeT.value();
  }

  public void asyncExample() {
    System.out.println("--- Fetching preferences for known userLogin (user123) ---");
    Kind&lt;CompletableFutureKind.Witness, Maybe&lt;UserPreferences&gt;&gt; resultKnownUserKind =
        getUserPreferencesWorkflow("user123");
    Maybe&lt;UserPreferences&gt; resultKnownUser = FUTURE.join(resultKnownUserKind);
    System.out.println("Known User Result: " + resultKnownUser);
    // Expected: Just(UserPreferences[userId=user123, theme=dark-mode])

    System.out.println("\n--- Fetching preferences for unknown userLogin (user999) ---");
    Kind&lt;CompletableFutureKind.Witness, Maybe&lt;UserPreferences&gt;&gt; resultUnknownUserKind =
        getUserPreferencesWorkflow("user999");
    Maybe&lt;UserPreferences&gt; resultUnknownUser = FUTURE.join(resultUnknownUserKind);
    System.out.println("Unknown User Result: " + resultUnknownUser);
    // Expected: Nothing
  }

  // --- Workflow Definition using MaybeT ---

  // --- Domain Model ---
  record User(String id, String name) {
  }

  record UserPreferences(String userId, String theme) {
  }
}
</code></pre>
<p>This example illustrates:</p>
<ol>
<li>Setting up <code>MaybeTMonad</code> with <code>CompletableFutureMonad</code>and <code>Unit</code> as the error type.</li>
<li>Using <code>MaybeT.fromKind</code> to lift an existing <code>Kind&lt;F, Maybe&lt;A&gt;&gt;</code> into the <code>MaybeT</code> context.</li>
<li>Sequencing operations with <code>maybeTMonad.flatMap</code>. If <code>WorkspaceUserAsync</code> results in <code>F&lt;Nothing&gt;</code>, the lambda for
fetching preferences is skipped.</li>
<li>The <code>handleErrorWith</code> shows a way to potentially recover from a <code>Nothing</code> state using <code>Unit</code> in the handler and <code>raiseError(Unit.INSTANCE)</code>.</li>
<li>Finally, <code>.value()</code> is used to extract the underlying <code>Kind&lt;CompletableFutureKind.Witness, Maybe&lt;UserPreferences&gt;&gt;</code>.</li>
</ol>
</div>
</div>
<div id="admonition-key-points" class="admonition admonish-tip" role="note" aria-labelledby="admonition-key-points-title">
<div class="admonition-title">
<div id="admonition-key-points-title">
<p>Key Points:</p>
</div>
<a class="admonition-anchor-link" href="transformers/maybet_transformer.html#admonition-key-points"></a>
</div>
<div>
<ul>
<li>The <code>MaybeT</code> transformer simplifies working with nested optional values within other monadic contexts by providing a
unified monadic interface, abstracting away the manual checks and propagation of <code>Nothing</code> states.</li>
<li>When <code>MaybeTMonad</code> is used as a <code>MonadError</code>, the error type is <code>Unit</code>, indicating that the "error" (a <code>Nothing</code> state) doesn't carry a specific value beyond its occurrence.</li>
</ul>
</div>
</div>
<hr />
<h2 id="maybet-vs-optionalt-when-to-use-which"><a class="header" href="#maybet-vs-optionalt-when-to-use-which">MaybeT vs OptionalT: When to Use Which?</a></h2>
<p>Both <code>MaybeT</code> and <code>OptionalT</code> serve similar purposes‚Äîcombining optionality with other monadic effects. Here's when to choose each:</p>
<h3 id="use-maybet-when"><a class="header" href="#use-maybet-when">Use <strong>MaybeT</strong> when:</a></h3>
<ul>
<li>You're working within the higher-kinded-j ecosystem and want consistency with the <code>Maybe</code> type</li>
<li>You need a type that's explicitly designed for functional composition (more FP-native)</li>
<li>You want to avoid Java's <code>Optional</code> and its quirks (e.g., serialisation warnings, identity-sensitive operations)</li>
<li>You're building a system where <code>Maybe</code> is used throughout</li>
</ul>
<h3 id="use-optionalt-when"><a class="header" href="#use-optionalt-when">Use <strong>OptionalT</strong> when:</a></h3>
<ul>
<li>You're integrating with existing Java code that uses <code>java.util.Optional</code></li>
<li>You want to leverage familiar Java 8+ Optional APIs</li>
<li>Your team is more comfortable with standard Java types</li>
<li>You're wrapping external libraries that return <code>Optional</code></li>
</ul>
<p><strong>In practice:</strong> The choice often comes down to consistency with your existing codebase. Both offer equivalent functionality through their <code>MonadError</code> instances.</p>
<hr />
<h2 id="further-reading-3"><a class="header" href="#further-reading-3">Further Reading</a></h2>
<div id="admonition-learning-path" class="admonition admonish-tip" role="note" aria-labelledby="admonition-learning-path-title">
<div class="admonition-title">
<div id="admonition-learning-path-title">
<p>Learning Path</p>
</div>
<a class="admonition-anchor-link" href="transformers/maybet_transformer.html#admonition-learning-path"></a>
</div>
<div>
<p>Start with the <strong>Java-focused</strong> resources to understand Maybe/Option patterns, then explore <strong>General FP concepts</strong> for deeper understanding, and finally check <strong>Related Libraries</strong> to see alternative approaches.</p>
</div>
</div>
<h3 id="java-focused-resources-3"><a class="header" href="#java-focused-resources-3">Java-Focused Resources</a></h3>
<p><strong>Beginner Level:</strong></p>
<ul>
<li>üìö <a href="https://medium.com/@johnmcclean/maybe-monad-in-java-8-2e0b7d8e3e5a">Maybe vs Optional: Understanding the Difference</a> - When to use custom Maybe over Java's Optional (10 min read)</li>
<li>üìÑ <a href="https://www.baeldung.com/java-avoid-null-check">Null Handling Patterns in Modern Java</a> - Comprehensive guide to null safety (15 min read)</li>
</ul>
<p><strong>Intermediate Level:</strong></p>
<ul>
<li>üìÑ <a href="https://bartoszmilewski.com/2013/09/10/monoids-monads-and-monad-zero/">MonadZero and Failure</a> - Understanding failure representation (20 min read)</li>
<li>üìÑ <a href="https://dzone.com/articles/functional-java-handling-optionals-in-completable">Handling Nothing in Asynchronous Code</a> - DZone's practical patterns (12 min read)</li>
</ul>
<h3 id="general-fp-concepts-3"><a class="header" href="#general-fp-concepts-3">General FP Concepts</a></h3>
<ul>
<li>üìñ <a href="https://en.wikipedia.org/wiki/Option_type">Maybe/Option Type</a> - Wikipedia's cross-language overview</li>
<li>üìñ <a href="http://learnyouahaskell.com/a-fistful-of-monads">A Fistful of Monads (Haskell)</a> - Accessible introduction to Maybe (30 min read)</li>
</ul>
<h3 id="related-libraries--comparisons-3"><a class="header" href="#related-libraries--comparisons-3">Related Libraries &amp; Comparisons</a></h3>
<ul>
<li>üîó <a href="https://www.vavr.io/vavr-docs/#_option">Vavr Option vs Java Optional</a> - Feature comparison</li>
<li>üîó <a href="https://www.scala-lang.org/api/2.13.3/scala/Option.html">Scala Option</a> - Scala's battle-tested implementation</li>
<li>üîó <a href="https://arrow-kt.io/docs/apidocs/arrow-core/arrow.core/-option/">Arrow Option (Kotlin)</a> - Kotlin FP approach</li>
</ul>
<h3 id="community--discussion-3"><a class="header" href="#community--discussion-3">Community &amp; Discussion</a></h3>
<ul>
<li>üí¨ <a href="https://stackoverflow.com/questions/48280735/maybe-vs-either-for-error-handling">Maybe vs Either for Error Handling</a> - Stack Overflow comparison</li>
<li>üí¨ <a href="https://www.reddit.com/r/java/comments/7t3q6k/why_implement_maybe_when_java_has_optional/">Why Use Maybe When We Have Optional?</a> - Reddit discussion on use cases</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="the-readert-transformer"><a class="header" href="#the-readert-transformer">The ReaderT Transformer:</a></h1>
<h2 id="combining-monadic-effects-with-a-read-only-environment"><a class="header" href="#combining-monadic-effects-with-a-read-only-environment"><em>Combining Monadic Effects with a Read-Only Environment</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="transformers/readert_transformer.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to combine dependency injection (Reader) with other effects like async operations</li>
<li>Building configuration-dependent workflows that are also async or failable</li>
<li>Using <code>ask</code>, <code>reader</code>, and <code>lift</code> to work with environment-dependent computations</li>
<li>Creating testable microservice clients with injected configuration</li>
<li>Managing database connections, API keys, and other contextual dependencies</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code:</p>
</div>
<a class="admonition-anchor-link" href="transformers/readert_transformer.html#admonition-see-example-code"></a>
</div>
<div>
<ul>
<li>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/reader_t/ReaderTExample.java">ReaderTExample.java</a></p>
</li>
<li>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/reader_t/ReaderTAsyncExample.java">ReaderTAsyncExample.java</a></p>
</li>
<li>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/reader_t/ReaderTAsyncUnitExample.java">ReaderTAsyncUnitExample.java</a></p>
</li>
</ul>
</div>
</div>
<h2 id="readert-monad-transformer"><a class="header" href="#readert-monad-transformer"><code>ReaderT</code> Monad Transformer</a></h2>
<p>The <code>ReaderT</code> monad transformer (short for Reader Transformer) allows you to combine the capabilities of the <code>Reader</code> monad (providing a read-only environment <code>R</code>) with another outer monad <code>F</code>. It encapsulates a computation that, given an environment <code>R</code>, produces a result within the monadic context <code>F</code> (i.e., <code>Kind&lt;F, A&gt;</code>).</p>
<p>This is particularly useful when you have operations that require some configuration or context (<code>R</code>) and also involve other effects managed by <code>F</code>, such as asynchronicity (<code>CompletableFutureKind</code>), optionality (<code>OptionalKind</code>, <code>MaybeKind</code>), or error handling (<code>EitherKind</code>).</p>
<p>The <code>ReaderT&lt;F, R, A&gt;</code> structure essentially wraps a function <code>R -&gt; Kind&lt;F, A&gt;</code>.</p>
<h2 id="structure-10"><a class="header" href="#structure-10">Structure</a></h2>
<p><img src="transformers/../images/puml/readert_transformer.svg" alt="readert_transformer.svg" /></p>
<h2 id="readertf-r-a-the-core-data-type"><a class="header" href="#readertf-r-a-the-core-data-type"><code>ReaderT&lt;F, R, A&gt;</code>: The Core Data Type</a></h2>
<p><code>ReaderT&lt;F, R, A&gt;</code> is a record that encapsulates the core computation.</p>
<pre><code class="language-java">public record ReaderT&lt;F, R, A&gt;(@NonNull Function&lt;R, Kind&lt;F, A&gt;&gt; run)
    implements ReaderTKind&lt;F, R, A&gt; {
  // ... static factory methods ...
}
</code></pre>
<ul>
<li><strong><code>F</code></strong>: The witness type of the <strong>outer monad</strong> (e.g., <code>OptionalKind.Witness</code>, <code>CompletableFutureKind.Witness</code>). This monad handles an effect such as optionality or asynchronicity.</li>
<li><strong><code>R</code></strong>: The type of the <strong>read-only environment</strong> (context or configuration) that the computation depends on.</li>
<li><strong><code>A</code></strong>: The type of the value produced by the computation, wrapped within the outer monad <code>F</code>.</li>
<li><strong><code>run</code></strong>: The essential function <code>R -&gt; Kind&lt;F, A&gt;</code>. When this function is applied to an environment of type <code>R</code>, it yields a monadic value <code>Kind&lt;F, A&gt;</code>.</li>
</ul>
<h2 id="readertkindf-r-a-the-witness-type"><a class="header" href="#readertkindf-r-a-the-witness-type"><code>ReaderTKind&lt;F, R, A&gt;</code>: The Witness Type</a></h2>
<p>To integrate with Higher-Kinded-J's generic programming capabilities, <code>ReaderTKind&lt;F, R, A&gt;</code> serves as the witness type.</p>
<ul>
<li>It extends <code>Kind&lt;G, A&gt;</code>, where <code>G</code> (the witness for the combined <code>ReaderT</code> monad) is <code>ReaderTKind.Witness&lt;F, R&gt;</code>.</li>
<li>The types <code>F</code> (outer monad) and <code>R</code> (environment) are fixed for a specific <code>ReaderT</code> context, while <code>A</code> is the variable value type.</li>
</ul>
<pre><code class="language-java">public interface ReaderTKind&lt;F, R, A&gt; extends Kind&lt;ReaderTKind.Witness&lt;F, R&gt;, A&gt; {
  // Witness type G = ReaderTKind.Witness&lt;F, R&gt;
  // Value type A = A
}
</code></pre>
<h2 id="readertkindhelper-utility-for-wrapping-and-unwrapping"><a class="header" href="#readertkindhelper-utility-for-wrapping-and-unwrapping"><code>ReaderTKindHelper</code>: Utility for Wrapping and Unwrapping</a></h2>
<p><code>ReaderTKindHelper</code> provides READER_T enum essential utility methods to convert between the concrete <code>ReaderT&lt;F, R, A&gt;</code> type and its <code>Kind</code> representation (<code>Kind&lt;ReaderTKind.Witness&lt;F, R&gt;, A&gt;</code>).</p>
<pre><code class="language-java">public enum ReaderTKindHelper {
   READER_T;
  
    // Unwraps Kind&lt;ReaderTKind.Witness&lt;F, R&gt;, A&gt; to ReaderT&lt;F, R, A&gt;
    public &lt;F, R, A&gt; @NonNull ReaderT&lt;F, R, A&gt; narrow(
        @Nullable Kind&lt;ReaderTKind.Witness&lt;F, R&gt;, A&gt; kind);

    // Wraps ReaderT&lt;F, R, A&gt; into ReaderTKind&lt;F, R, A&gt;
    public &lt;F, R, A&gt; @NonNull ReaderTKind&lt;F, R, A&gt; widen(
        @NonNull ReaderT&lt;F, R, A&gt; readerT);
}
</code></pre>
<h2 id="readertmonadf-r-operating-on-readert"><a class="header" href="#readertmonadf-r-operating-on-readert"><code>ReaderTMonad&lt;F, R&gt;</code>: Operating on <code>ReaderT</code></a></h2>
<p>The <code>ReaderTMonad&lt;F, R&gt;</code> class implements the <code>Monad&lt;ReaderTKind.Witness&lt;F, R&gt;&gt;</code> interface, providing the standard monadic operations (<code>of</code>, <code>map</code>, <code>flatMap</code>, <code>ap</code>) for the <code>ReaderT</code> structure.</p>
<ul>
<li>It requires a <code>Monad&lt;F&gt;</code> instance for the outer monad <code>F</code> to be provided during its construction. This <code>outerMonad</code> is used internally to sequence operations within the <code>F</code> context.</li>
<li><code>R</code> is the fixed environment type for this monad instance.</li>
</ul>
<pre><code class="language-java">// Example: F = OptionalKind.Witness, R = AppConfig
// 1. Get the Monad instance for the outer monad F
OptionalMonad optionalMonad = OptionalMonad.INSTANCE;

// 2. Define your environment type
record AppConfig(String apiKey) {}

// 3. Create the ReaderTMonad
ReaderTMonad&lt;OptionalKind.Witness, AppConfig&gt; readerTOptionalMonad =
    new ReaderTMonad&lt;&gt;(optionalMonad);

// Now 'readerTOptionalMonad' can be used to operate on 
// Kind&lt;ReaderTKind.Witness&lt;OptionalKind.Witness, AppConfig&gt;, A&gt; values.
</code></pre>
<div id="admonition-key-operations-with-_readertmonad_" class="admonition admonish-info" role="note" aria-labelledby="admonition-key-operations-with-_readertmonad_-title">
<div class="admonition-title">
<div id="admonition-key-operations-with-_readertmonad_-title">
<p>Key Operations with <em>ReaderTMonad</em></p>
</div>
<a class="admonition-anchor-link" href="transformers/readert_transformer.html#admonition-key-operations-with-_readertmonad_"></a>
</div>
<div>
<ul>
<li><strong><code>readerTMonad.of(value)</code></strong>: Lifts a pure value <code>A</code> into the <code>ReaderT</code> context. The underlying function becomes <code>r -&gt; outerMonad.of(value)</code>. Result: <code>ReaderT(r -&gt; F&lt;A&gt;)</code>.</li>
<li><strong><code>readerTMonad.map(func, readerTKind)</code></strong>: Applies a function <code>A -&gt; B</code> to the value <code>A</code> inside the <code>ReaderT</code> structure, if present and successful within the <code>F</code> context. The transformation <code>A -&gt; B</code> happens within the <code>outerMonad.map</code> call. Result: <code>ReaderT(r -&gt; F&lt;B&gt;)</code>.</li>
<li><strong><code>readerTMonad.flatMap(func, readerTKind)</code></strong>: The core sequencing operation. Takes a function <code>A -&gt; Kind&lt;ReaderTKind.Witness&lt;F, R&gt;, B&gt;</code> (which is effectively <code>A -&gt; ReaderT&lt;F, R, B&gt;</code>). It runs the initial <code>ReaderT</code> with the environment <code>R</code> to get <code>Kind&lt;F, A&gt;</code>. Then, it uses <code>outerMonad.flatMap</code> to process this. If <code>Kind&lt;F, A&gt;</code> yields an <code>A</code>, <code>func</code> is applied to <code>a</code> to get a new <code>ReaderT&lt;F, R, B&gt;</code>. This new <code>ReaderT</code> is then also run with the <em>same original environment</em><code>R</code> to yield <code>Kind&lt;F, B&gt;</code>. This allows composing computations that all depend on the same environment <code>R</code> while also managing the effects of <code>F</code>. Result: <code>ReaderT(r -&gt; F&lt;B&gt;)</code>.</li>
</ul>
</div>
</div>
<div id="admonition-creating-_readert_-instances" class="admonition admonish-note" role="note" aria-labelledby="admonition-creating-_readert_-instances-title">
<div class="admonition-title">
<div id="admonition-creating-_readert_-instances-title">
<p>Creating <em>ReaderT</em> Instances</p>
</div>
<a class="admonition-anchor-link" href="transformers/readert_transformer.html#admonition-creating-_readert_-instances"></a>
</div>
<div>
<p>You typically create <code>ReaderT</code> instances using its static factory methods. These methods often require an instance of <code>Monad&lt;F&gt;</code> for the outer monad.</p>
<pre><code class="language-java"> public void createExample(){
  // --- Setup ---
  // Outer Monad F = OptionalKind.Witness
  OptionalMonad optMonad = OptionalMonad.INSTANCE;

  // Environment Type R
  record Config(String setting) {
  }
  Config testConfig = new Config("TestValue");

  // --- Factory Methods ---

  // 1. `ReaderT.of(Function&lt;R, Kind&lt;F, A&gt;&gt; runFunction)`
  //    Constructs directly from the R -&gt; F&lt;A&gt; function.
  Function&lt;Config, Kind&lt;OptionalKind.Witness, String&gt;&gt; runFn1 =
      cfg -&gt; OPTIONAL.widen(Optional.of("Data based on " + cfg.setting()));
  ReaderT&lt;OptionalKind.Witness, Config, String&gt; rt1 = ReaderT.of(runFn1);
  // To run: OPTIONAL.narrow(rt1.run().apply(testConfig)) is Optional.of("Data based on TestValue")
  System.out.println(OPTIONAL.narrow(rt1.run().apply(testConfig)));

  // 2. `ReaderT.lift(Monad&lt;F&gt; outerMonad, Kind&lt;F, A&gt; fa)`
  //    Lifts an existing monadic value `Kind&lt;F, A&gt;` into ReaderT.
  //    The resulting ReaderT ignores the environment R and always returns `fa`.
  Kind&lt;OptionalKind.Witness, Integer&gt; optionalValue = OPTIONAL.widen(Optional.of(123));
  ReaderT&lt;OptionalKind.Witness, Config, Integer&gt; rt2 = ReaderT.lift(optMonad, optionalValue);
  // To run: OPTIONAL.narrow(rt2.run().apply(testConfig)) is Optional.of(123)
  System.out.println(OPTIONAL.narrow(rt2.run().apply(testConfig)));

  Kind&lt;OptionalKind.Witness, Integer&gt; emptyOptional = OPTIONAL.widen(Optional.empty());
  ReaderT&lt;OptionalKind.Witness, Config, Integer&gt; rt2Empty = ReaderT.lift(optMonad, emptyOptional);
  // To run: OPTIONAL.narrow(rt2Empty.run().apply(testConfig)) is Optional.empty()


  // 3. `ReaderT.reader(Monad&lt;F&gt; outerMonad, Function&lt;R, A&gt; f)`
  //    Creates a ReaderT from a function R -&gt; A. The result A is then lifted into F using outerMonad.of(A).
  Function&lt;Config, String&gt; simpleReaderFn = cfg -&gt; "Hello from " + cfg.setting();
  ReaderT&lt;OptionalKind.Witness, Config, String&gt; rt3 = ReaderT.reader(optMonad, simpleReaderFn);
  // To run: OPTIONAL.narrow(rt3.run().apply(testConfig)) is Optional.of("Hello from TestValue")
  System.out.println(OPTIONAL.narrow(rt3.run().apply(testConfig)));

  // 4. `ReaderT.ask(Monad&lt;F&gt; outerMonad)`
  //    Creates a ReaderT that, when run, provides the environment R itself as the result, lifted into F.
  //    The function is r -&gt; outerMonad.of(r).
  ReaderT&lt;OptionalKind.Witness, Config, Config&gt; rt4 = ReaderT.ask(optMonad);
  // To run: OPTIONAL.narrow(rt4.run().apply(testConfig)) is Optional.of(new Config("TestValue"))
  System.out.println(OPTIONAL.narrow(rt4.run().apply(testConfig)));

  // --- Using ReaderTKindHelper.READER_T to widen/narrow for Monad operations ---
  //    Avoid a cast with var ReaderTKind&lt;OptionalKind.Witness, Config, String&gt; kindRt1 =
  //        (ReaderTKind&lt;OptionalKind.Witness, Config, String&gt;) READER_T.widen(rt1);
  var kindRt1 = READER_T.widen(rt1);
  ReaderT&lt;OptionalKind.Witness, Config, String&gt; unwrappedRt1 = READER_T.narrow(kindRt1);
}
</code></pre>
</div>
</div>
<div id="admonition-example-readert-for-actions-returning-unit" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-readert-for-actions-returning-unit-title">
<div class="admonition-title">
<div id="admonition-example-readert-for-actions-returning-unit-title">
<p>Example: <code>ReaderT</code> for Actions Returning <code>Unit</code></p>
</div>
<a class="admonition-anchor-link" href="transformers/readert_transformer.html#admonition-example-readert-for-actions-returning-unit"></a>
</div>
<div>
<p>Sometimes, a computation dependent on an environment <code>R</code> and involving an outer monad <code>F</code> might perform an action (e.g., logging, initializing a resource, sending a fire-and-forget message) without producing a specific data value. In such cases, the result type <code>A</code> of <code>ReaderT&lt;F, R, A&gt;</code> can be <code>org.higherkindedj.hkt.Unit</code>.</p>
<p>Let's extend the asynchronous example to include an action that logs a message using the <code>AppConfig</code> and completes asynchronously, returning <code>Unit</code>.</p>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/reader_t/ReaderTAsyncUnitExample.java">ReaderTAsyncUnitExample.java</a></li>
</ul>
<pre><code class="language-java">    // Action: Log a message using AppConfig, complete asynchronously returning F&lt;Unit&gt;
    public static Kind&lt;CompletableFutureKind.Witness, Unit&gt; logInitialisationAsync(AppConfig config) {
        CompletableFuture&lt;Unit&gt; future = CompletableFuture.runAsync(() -&gt; {
            System.out.println("Thread: " + Thread.currentThread().getName() +
                " - Initialising component with API Key: " + config.apiKey() +
                " for Service URL: " + config.serviceUrl());
            // Simulate some work
            try {
                TimeUnit.MILLISECONDS.sleep(50);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                throw new RuntimeException(e);
            }
            System.out.println("Thread: " + Thread.currentThread().getName() +
                " - Initialisation complete for: " + config.serviceUrl());
        }, config.executor()).thenApply(v -&gt; Unit.INSTANCE); // Ensure CompletableFuture&lt;Unit&gt;
        return FUTURE.widen(future);
    }

    // Wrap the action in ReaderT: R -&gt; F&lt;Unit&gt;
    public static ReaderT&lt;CompletableFutureKind.Witness, AppConfig, Unit&gt; initialiseComponentRT() {
        return ReaderT.of(ReaderTAsyncUnitExample::logInitialisationAsync);
    }

    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(2);
        AppConfig prodConfig = new AppConfig("prod_secret_for_init", "[https://init.prod.service](https://init.prod.service)", executor);

        // Get the ReaderT for the initialisation action
        ReaderT&lt;CompletableFutureKind.Witness, AppConfig, Unit&gt; initAction = initialiseComponentRT();

        System.out.println("--- Running Initialisation Action with Prod Config ---");
        // Run the action by providing the prodConfig environment
        // This returns Kind&lt;CompletableFutureKind.Witness, Unit&gt;
        Kind&lt;CompletableFutureKind.Witness, Unit&gt; futureUnit = initAction.run().apply(prodConfig);

        // Wait for completion and get the Unit result (which is just Unit.INSTANCE)
        Unit result = FUTURE.join(futureUnit);
        System.out.println("Initialisation Result: " + result); // Expected: Initialisation Result: ()

        executor.shutdown();
        try {
            if (!executor.awaitTermination(5, TimeUnit.SECONDS)) {
                executor.shutdownNow();
            }
        } catch (InterruptedException e) {
            executor.shutdownNow();
            Thread.currentThread().interrupt();
        }
    }
</code></pre>
<p>This example illustrates:</p>
<ul>
<li>An asynchronous action (<code>logInitialisationAsync</code>) that depends on <code>AppConfig</code> but logically returns no specific data, so its result is <code>CompletableFuture&lt;Unit&gt;</code>.</li>
<li>This action is wrapped into a <code>ReaderT&lt;CompletableFutureKind.Witness, AppConfig, Unit&gt;</code>.</li>
<li>When this <code>ReaderT</code> is run with an <code>AppConfig</code>, it yields a <code>Kind&lt;CompletableFutureKind.Witness, Unit&gt;</code>.</li>
<li>The final result of joining such a future is <code>Unit.INSTANCE</code>, signifying successful completion of the effectful, environment-dependent action.</li>
</ul>
</div>
</div>
<div id="admonition-example-configuration-dependent-asynchronous-service-calls" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-configuration-dependent-asynchronous-service-calls-title">
<div class="admonition-title">
<div id="admonition-example-configuration-dependent-asynchronous-service-calls-title">
<p>Example: Configuration-Dependent Asynchronous Service Calls</p>
</div>
<a class="admonition-anchor-link" href="transformers/readert_transformer.html#admonition-example-configuration-dependent-asynchronous-service-calls"></a>
</div>
<div>
<p>Let's illustrate <code>ReaderT</code> by combining an environment dependency (<code>AppConfig</code>) with an asynchronous operation (<code>CompletableFuture</code>).</p>
<pre><code class="language-java">
public class ReaderTAsyncExample {
  // --- Monad Setup ---
  // Outer Monad F = CompletableFutureKind.Witness
  static final Monad&lt;CompletableFutureKind.Witness&gt; futureMonad = CompletableFutureMonad.INSTANCE;
  // ReaderTMonad for AppConfig and CompletableFutureKind
  static final ReaderTMonad&lt;CompletableFutureKind.Witness, AppConfig&gt; cfReaderTMonad =
      new ReaderTMonad&lt;&gt;(futureMonad);

  // Simulates an async call to an external service
  public static Kind&lt;CompletableFutureKind.Witness, ServiceData&gt; fetchExternalData(AppConfig config, String itemId) {
    System.out.println("Thread: " + Thread.currentThread().getName() + " - Fetching external data for " + itemId + " using API key: " + config.apiKey() + " from " + config.serviceUrl());
    CompletableFuture&lt;ServiceData&gt; future = CompletableFuture.supplyAsync(() -&gt; {
      try {
        TimeUnit.MILLISECONDS.sleep(100); // Simulate network latency
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        throw new RuntimeException(e);
      }
      return new ServiceData("Raw data for " + itemId + " from " + config.serviceUrl());
    }, config.executor());
    return FUTURE.widen(future);
  }

  // Operation 1: Fetch data, wrapped in ReaderT
  // This is R -&gt; F&lt;A&gt; which is the core of ReaderT
  public static ReaderT&lt;CompletableFutureKind.Witness, AppConfig, ServiceData&gt; fetchServiceDataRT(String itemId) {
    return ReaderT.of(appConfig -&gt; fetchExternalData(appConfig, itemId));
  }

  // Operation 2: Process data (sync part, depends on AppConfig, then lifts to ReaderT)
  // This uses ReaderT.reader: R -&gt; A, then A is lifted to F&lt;A&gt;
  public static ReaderT&lt;CompletableFutureKind.Witness, AppConfig, ProcessedData&gt; processDataRT(ServiceData sData) {
    return ReaderT.reader(futureMonad, // Outer monad to lift the result
        appConfig -&gt; { // Function R -&gt; A (Config -&gt; ProcessedData)
          System.out.println("Thread: " + Thread.currentThread().getName() + " - Processing data with config: " + appConfig.apiKey());
          return new ProcessedData("Processed: " + sData.rawData().toUpperCase() + " (API Key Suffix: " + appConfig.apiKey().substring(Math.max(0, appConfig.apiKey().length() - 3)) + ")");
        });
  }


  // --- Service Logic (depends on AppConfig, returns Future&lt;ServiceData&gt;) ---

  public static void main(String[] args) throws Exception {
    ExecutorService executor = Executors.newFixedThreadPool(2);
    AppConfig prodConfig = new AppConfig("prod_secret_key_xyz", "https://api.prod.example.com", executor);
    AppConfig stagingConfig = new AppConfig("stag_test_key_123", "https://api.staging.example.com", executor);

    // --- Composing with ReaderTMonad.flatMap ---
    // Define a workflow: fetch data, then process it.
    // The AppConfig is threaded through automatically by ReaderT.
    Kind&lt;ReaderTKind.Witness&lt;CompletableFutureKind.Witness, AppConfig&gt;, ProcessedData&gt; workflowRTKind =
        cfReaderTMonad.flatMap(
            serviceData -&gt; READER_T.widen(processDataRT(serviceData)), // ServiceData -&gt; ReaderTKind&lt;..., ProcessedData&gt;
            READER_T.widen(fetchServiceDataRT("item123")) // Initial ReaderTKind&lt;..., ServiceData&gt;
        );

    // Unwrap to the concrete ReaderT to run it
    ReaderT&lt;CompletableFutureKind.Witness, AppConfig, ProcessedData&gt; composedWorkflow =
        READER_T.narrow(workflowRTKind);

    // --- Running the workflow with different configurations ---

    System.out.println("--- Running with Production Config ---");
    // Run the workflow by providing the 'prodConfig' environment
    // This returns Kind&lt;CompletableFutureKind.Witness, ProcessedData&gt;
    Kind&lt;CompletableFutureKind.Witness, ProcessedData&gt; futureResultProd = composedWorkflow.run().apply(prodConfig);
    ProcessedData resultProd = FUTURE.join(futureResultProd); // Blocks for result
    System.out.println("Prod Result: " + resultProd);
    // Expected output will show "prod_secret_key_xyz", "[https://api.prod.example.com](https://api.prod.example.com)" in logs
    // and "Processed: RAW DATA FOR ITEM123 FROM [https://api.prod.example.com](https://api.prod.example.com) (API Key Suffix: xyz)"


    System.out.println("\n--- Running with Staging Config ---");
    // Run the same workflow with 'stagingConfig'
    Kind&lt;CompletableFutureKind.Witness, ProcessedData&gt; futureResultStaging = composedWorkflow.run().apply(stagingConfig);
    ProcessedData resultStaging = FUTURE.join(futureResultStaging); // Blocks for result
    System.out.println("Staging Result: " + resultStaging);
    // Expected output will show "stag_test_key_123", "[https://api.staging.example.com](https://api.staging.example.com)" in logs
    // and "Processed: RAW DATA FOR ITEM123 FROM [https://api.staging.example.com](https://api.staging.example.com) (API Key Suffix: 123)"


    // --- Another example: Using ReaderT.ask ---
    ReaderT&lt;CompletableFutureKind.Witness, AppConfig, AppConfig&gt; getConfigSettingRT =
        ReaderT.ask(futureMonad); // Provides the whole AppConfig

    Kind&lt;ReaderTKind.Witness&lt;CompletableFutureKind.Witness, AppConfig&gt;, String&gt; getServiceUrlRT =
        cfReaderTMonad.map(
            (AppConfig cfg) -&gt; "Service URL from ask: " + cfg.serviceUrl(),
            READER_T.widen(getConfigSettingRT)
        );

    String stagingServiceUrl = FUTURE.join(
        READER_T.narrow(getServiceUrlRT).run().apply(stagingConfig)
    );
    System.out.println("\nStaging Service URL via ask: " + stagingServiceUrl);


    executor.shutdown();
    try {
      if (!executor.awaitTermination(5, TimeUnit.SECONDS)) {
        executor.shutdownNow();
      }
    } catch (InterruptedException e) {
      executor.shutdownNow();
      Thread.currentThread().interrupt();
    }
  }

  // --- ReaderT-based Service Operations ---

  // --- Environment ---
  record AppConfig(String apiKey, String serviceUrl, ExecutorService executor) {
  }

  // --- Service Response ---
  record ServiceData(String rawData) {
  }

  record ProcessedData(String info) {
  }
}
</code></pre>
<p><strong>This</strong> example demonstrates:</p>
<ol>
<li>Defining an <code>AppConfig</code> environment.</li>
<li>Creating service operations (<code>WorkspaceServiceDataRT</code>, <code>processDataRT</code>) that return <code>ReaderT&lt;CompletableFutureKind, AppConfig, A&gt;</code>. These operations implicitly depend on <code>AppConfig</code>.</li>
<li>Using <code>cfReaderTMonad.flatMap</code> to chain these operations. The <code>AppConfig</code> is passed implicitly through the chain.</li>
<li>Executing the composed workflow (<code>composedWorkflow.run().apply(config)</code>) by providing a specific <code>AppConfig</code>. This "injects" the dependency at the very end.</li>
<li>The asynchronicity from <code>CompletableFuture</code> is handled by the <code>futureMonad</code> within <code>ReaderTMonad</code> and <code>ReaderT</code>'s factories.</li>
<li>Using <code>ReaderT.ask</code> to directly access the configuration within a <code>ReaderT</code> computation.</li>
</ol>
</div>
</div>
<div id="admonition-key-points" class="admonition admonish-tip" role="note" aria-labelledby="admonition-key-points-title">
<div class="admonition-title">
<div id="admonition-key-points-title">
<p>Key Points:</p>
</div>
<a class="admonition-anchor-link" href="transformers/readert_transformer.html#admonition-key-points"></a>
</div>
<div>
<p><code>ReaderT</code> simplifies managing computations that require a shared, read-only environment while also dealing with other monadic effects, leading to cleaner, more composable, and testable code by deferring environment injection.</p>
</div>
</div>
<hr />
<h2 id="further-reading-4"><a class="header" href="#further-reading-4">Further Reading</a></h2>
<div id="admonition-learning-path" class="admonition admonish-tip" role="note" aria-labelledby="admonition-learning-path-title">
<div class="admonition-title">
<div id="admonition-learning-path-title">
<p>Learning Path</p>
</div>
<a class="admonition-anchor-link" href="transformers/readert_transformer.html#admonition-learning-path"></a>
</div>
<div>
<p>Start with the <strong>Java-focused</strong> resources to understand dependency injection patterns, then explore <strong>General FP concepts</strong> for deeper understanding, and finally check <strong>Related Libraries</strong> to see alternative approaches.</p>
</div>
</div>
<h3 id="java-focused-resources-4"><a class="header" href="#java-focused-resources-4">Java-Focused Resources</a></h3>
<p><strong>Beginner Level:</strong></p>
<ul>
<li>üìö <a href="https://www.baeldung.com/java-dependency-injection-functional">Dependency Injection the Functional Way</a> - Baeldung's introduction to Reader (15 min read)</li>
<li>üìÑ <a href="https://medium.com/@johnmcclean/reader-monad-for-dependency-injection-in-java-9056d9501c75">Reader Monad for Dependency Injection</a> - Practical examples without frameworks (12 min read)</li>
<li>üé• <a href="https://www.youtube.com/watch?v=ZasXwtTRkio">Functional Dependency Injection</a> - Conference talk on Reader pattern (40 min watch)</li>
</ul>
<p><strong>Intermediate Level:</strong></p>
<ul>
<li>üìÑ <a href="https://blog.rockthejvm.com/reader-monad/">Configuration as Code with Reader</a> - Rock the JVM's practical guide (20 min read)</li>
<li>üìÑ <a href="https://medium.com/@olxc/reader-monad-for-dependency-injection-4c5700c4c148">Reader vs Dependency Injection Frameworks</a> - When to use what (15 min read)</li>
</ul>
<p><strong>Advanced:</strong></p>
<ul>
<li>üî¨ <a href="https://www.fpcomplete.com/blog/readert-design-pattern/">ReaderT Design Pattern</a> - FP Complete's production patterns (30 min read)</li>
</ul>
<h3 id="general-fp-concepts-4"><a class="header" href="#general-fp-concepts-4">General FP Concepts</a></h3>
<ul>
<li>üìñ <a href="https://wiki.haskell.org/Reader_monad">Reader Monad Explained</a> - HaskellWiki's clear explanation</li>
<li>üìñ <a href="https://en.wikipedia.org/wiki/Environment_passing_style">Environment Passing Style</a> - Wikipedia on the underlying concept</li>
<li>üìñ <a href="https://bartoszmilewski.com/2014/01/14/functors-are-containers/">Functions as Context</a> - Bartosz Milewski's blog on function contexts</li>
</ul>
<h3 id="related-libraries--comparisons-4"><a class="header" href="#related-libraries--comparisons-4">Related Libraries &amp; Comparisons</a></h3>
<ul>
<li>üîó <a href="https://typelevel.org/cats/datatypes/kleisli.html">Cats Reader</a> - Scala's implementation (called Kleisli)</li>
<li>üîó <a href="https://arrow-kt.io/docs/apidocs/arrow-core/arrow.core/-reader/">Arrow Reader (Kotlin)</a> - Kotlin FP approach</li>
<li>üîó <a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader.html">Haskell's ReaderT</a> - Original inspiration</li>
</ul>
<h3 id="community--discussion-4"><a class="header" href="#community--discussion-4">Community &amp; Discussion</a></h3>
<ul>
<li>üí¨ <a href="https://stackoverflow.com/questions/14301361/why-is-the-reader-monad-useful">Reader Monad vs Constructor Injection</a> - Stack Overflow debate</li>
<li>üí¨ <a href="https://www.reddit.com/r/functionalprogramming/comments/5qvzwq/reader_monad_in_production/">Using Reader in Production</a> - Real-world experiences</li>
<li>üí¨ <a href="https://news.ycombinator.com/item?id=16743608">ReaderT Pattern at Scale</a> - HN discussion from production teams</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="the-statet-transformer"><a class="header" href="#the-statet-transformer">The StateT Transformer:</a></h1>
<h2 id="monad-transformer"><a class="header" href="#monad-transformer"><em>Monad Transformer</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="transformers/statet_transformer.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to add stateful computation to any existing monad</li>
<li>Building stack operations that can fail (StateT with Optional)</li>
<li>Understanding the relationship between State and StateT&lt;S, Identity, A&gt;</li>
<li>Creating complex workflows that manage both state and other effects</li>
<li>Using <code>get</code>, <code>set</code>, <code>modify</code> operations within transformer contexts</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code:</p>
</div>
<a class="admonition-anchor-link" href="transformers/statet_transformer.html#admonition-see-example-code"></a>
</div>
<div>
<ul>
<li>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/state_t/StateTExample.java">StateTExample.java</a></p>
</li>
<li>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/state_t/StateTStackExample.java">StateTStackExample</a></p>
</li>
</ul>
</div>
</div>
<p>The <code>StateT</code> monad transformer is a powerful construct that allows you to add state-management capabilities to an existing monadic context. Think of it as taking the <a href="transformers/../monads/state_monad.html">State Monad</a> and making it work on top of <em>another</em> monad, like <code>OptionalKind</code>, <code>EitherKind</code>, or <code>IOKind</code>.</p>
<p>This is incredibly useful when you have computations that are both stateful and involve other effects, such as:</p>
<ul>
<li>Potentially missing values (<code>Optional</code>)</li>
<li>Operations that can fail (<code>Either</code>, <code>Try</code>)</li>
<li>Side-effecting computations (<code>IO</code>)</li>
</ul>
<h2 id="what-is-statet"><a class="header" href="#what-is-statet">What is StateT?</a></h2>
<p>At its core, a <code>StateT&lt;S, F, A&gt;</code> represents a computation that:</p>
<ol>
<li>Takes an initial state of type <code>S</code>.</li>
<li>Produces a result of type <code>A</code> along with a new state of type <code>S</code>.</li>
<li>And this entire process of producing the <code>(newState, value)</code> pair is itself wrapped in an underlying monadic context <code>F</code>.</li>
</ol>
<p>So, the fundamental structure of a <code>StateT</code> computation can be thought of as a function:
<code>S -&gt; F&lt;StateTuple&lt;S, A&gt;&gt;</code></p>
<p>Where:</p>
<ul>
<li><code>S</code>: The type of the state.</li>
<li><code>F</code>: The witness type for the underlying monad (e.g., <code>OptionalKind.Witness</code>, <code>IOKind.Witness</code>).</li>
<li><code>A</code>: The type of the computed value.</li>
<li><code>StateTuple&lt;S, A&gt;</code>: A simple container holding a pair of <code>(state, value)</code>.</li>
</ul>
<p><img src="transformers/../images/puml/statet_transformer.svg" alt="statet_transformer.svg" /></p>
<h2 id="key-classes-and-concepts-1"><a class="header" href="#key-classes-and-concepts-1">Key Classes and Concepts</a></h2>
<ul>
<li><strong><code>StateT&lt;S, F, A&gt;</code></strong>: The primary data type representing the stateful computation stacked on monad <code>F</code>. It holds the function <code>S -&gt; Kind&lt;F, StateTuple&lt;S, A&gt;&gt;</code>.</li>
<li><strong><code>StateTKind&lt;S, F, A&gt;</code></strong>: The <code>Kind</code> representation for <code>StateT</code>, allowing it to be used with <code>higher-kinded-j</code>'s typeclasses like <code>Monad</code>. This is what you'll mostly interact with when using <code>StateT</code> in a generic monadic context.</li>
<li><strong><code>StateTKind.Witness&lt;S, F&gt;</code></strong>: The higher-kinded type witness for <code>StateT&lt;S, F, _&gt;</code>. Note that both the state type <code>S</code> and the underlying monad witness <code>F</code> are part of the <code>StateT</code> witness.</li>
<li><strong><code>StateTMonad&lt;S, F&gt;</code></strong>: The <code>Monad</code> instance for <code>StateT&lt;S, F, _&gt;</code>. It requires a <code>Monad</code> instance for the underlying monad <code>F</code> to function.</li>
<li><strong><code>StateTKindHelper</code></strong>: A utility class providing static methods for working with <code>StateTKind</code>, such as <code>narrow</code> (to convert <code>Kind&lt;StateTKind.Witness&lt;S, F&gt;, A&gt;</code> back to <code>StateT&lt;S, F, A&gt;</code>), <code>runStateT</code>, <code>evalStateT</code>, and <code>execStateT</code>.</li>
<li><strong><code>StateTuple&lt;S, A&gt;</code></strong>: A simple record-like class holding the pair <code>(S state, A value)</code>.</li>
</ul>
<h2 id="motivation-why-use-statet"><a class="header" href="#motivation-why-use-statet">Motivation: Why Use StateT?</a></h2>
<p>Imagine you're processing a sequence of items, and for each item:</p>
<ol>
<li>You need to update some running total (state).</li>
<li>The processing of an item might fail or return no result (e.g., <code>Optional</code>).</li>
</ol>
<p>Without <code>StateT</code>, you might end up with deeply nested <code>Optional&lt;StateTuple&lt;S, A&gt;&gt;</code> and manually manage both the optionality and the state threading. <code>StateT&lt;S, OptionalKind.Witness, A&gt;</code> elegantly combines these concerns.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/state_t/StateTExample.java">StateTExample.java</a></li>
</ul>
<h3 id="creating-statet-instances"><a class="header" href="#creating-statet-instances">Creating StateT Instances</a></h3>
<p>You typically create <code>StateT</code> instances in a few ways:</p>
<ol>
<li>
<p><strong>Directly with <code>StateT.create()</code></strong>:
This is the most fundamental way, providing the state function and the underlying monad instance.</p>
<pre><code class="language-java">

// Assume S = Integer (state type), F = OptionalKind.Witness, A = String (value type)
 OptionalMonad optionalMonad = OptionalMonad.INSTANCE;

 Function&lt;Integer, Kind&lt;OptionalKind.Witness, StateTuple&lt;Integer, String&gt;&gt;&gt; runFn =
     currentState -&gt; {
       if (currentState &lt; 0) {
         return OPTIONAL.widen(Optional.empty());
       }
       return OPTIONAL.widen(Optional.of(StateTuple.of(currentState + 1, "Value: " + currentState)));
     };

 StateT&lt;Integer, OptionalKind.Witness, String&gt; stateTExplicit =
     StateT.create(runFn, optionalMonad);

 Kind&lt;StateTKind.Witness&lt;Integer, OptionalKind.Witness&gt;, String&gt; stateTKind =
     stateTExplicit;
</code></pre>
</li>
<li>
<p><strong>Lifting values with <code>StateTMonad.of()</code></strong>:
This lifts a pure value <code>A</code> into the <code>StateT</code> context. The state remains unchanged, and the underlying monad <code>F</code> will wrap the result using its own <code>of</code> method.</p>
<pre><code class="language-java"> StateTMonad&lt;Integer, OptionalKind.Witness&gt; stateTMonad = StateTMonad.instance(optionalMonad);

 Kind&lt;StateTKind.Witness&lt;Integer, OptionalKind.Witness&gt;, String&gt; pureStateT =
     stateTMonad.of("pure value");


 Optional&lt;StateTuple&lt;Integer, String&gt;&gt; pureResult =
     OPTIONAL.narrow(STATE_T.runStateT(pureStateT, 10));
 System.out.println("Pure StateT result: " + pureResult);
// When run with state 10, this will result in Optional.of(StateTuple(10, "pure value"))
</code></pre>
</li>
</ol>
<h3 id="running-statet-computations"><a class="header" href="#running-statet-computations">Running StateT Computations</a></h3>
<p>To execute a <code>StateT</code> computation and extract the result, you use methods from <code>StateTKindHelper</code> or directly from the <code>StateT</code> object:</p>
<ul>
<li>
<p><strong><code>runStateT(initialState)</code></strong>: Executes the computation with an <code>initialState</code> and returns the result wrapped in the underlying monad: <code>Kind&lt;F, StateTuple&lt;S, A&gt;&gt;</code>.</p>
<pre><code class="language-java">// Continuing the stateTKind from above:
Kind&lt;OptionalKind.Witness, StateTuple&lt;Integer, String&gt;&gt; resultOptionalTuple =
      StateTKindHelper.runStateT(stateTKind, 10);

  Optional&lt;StateTuple&lt;Integer, String&gt;&gt; actualOptional = OPTIONAL.narrow(resultOptionalTuple);

  if (actualOptional.isPresent()) {
    StateTuple&lt;Integer, String&gt; tuple = actualOptional.get();
    System.out.println("New State (from stateTExplicit): " + tuple.state());
    System.out.println("Value (from stateTExplicit): " + tuple.value());
  } else {
    System.out.println("actualOptional was empty for initial state 10");
  }

  // Example with negative initial state (expecting empty Optional)
  Kind&lt;OptionalKind.Witness, StateTuple&lt;Integer, String&gt;&gt; resultEmptyOptional =
      StateTKindHelper.runStateT(stateTKind, -5);
  Optional&lt;StateTuple&lt;Integer, String&gt;&gt; actualEmpty = OPTIONAL.narrow(resultEmptyOptional);
  // Output: Is empty: true
  System.out.println("Is empty (for initial state -5): " + actualEmpty.isEmpty());

</code></pre>
</li>
<li>
<p><strong><code>evalStateT(initialState)</code></strong>: Executes and gives you <code>Kind&lt;F, A&gt;</code> (the value, discarding the final state).</p>
</li>
<li>
<p><strong><code>execStateT(initialState)</code></strong>: Executes and gives you <code>Kind&lt;F, S&gt;</code> (the final state, discarding the value).</p>
</li>
</ul>
<h3 id="composing-statet-actions"><a class="header" href="#composing-statet-actions">Composing StateT Actions</a></h3>
<p>Like any monad, <code>StateT</code> computations can be composed using <code>map</code> and <code>flatMap</code>.</p>
<ul>
<li>
<p><strong><code>map(Function&lt;A, B&gt; fn)</code></strong>: Transforms the value <code>A</code> to <code>B</code> within the <code>StateT</code> context, leaving the state transformation logic and the underlying monad <code>F</code>'s effect untouched for that step.</p>
<pre><code class="language-java">    Kind&lt;StateTKind.Witness&lt;Integer, OptionalKind.Witness&gt;, Integer&gt; initialComputation =
      StateT.create(s -&gt; OPTIONAL.widen(Optional.of(StateTuple.of(s + 1, s * 2))), optionalMonad);

  Kind&lt;StateTKind.Witness&lt;Integer, OptionalKind.Witness&gt;, String&gt; mappedComputation =
      stateTMonad.map(
          val -&gt; "Computed: " + val,
          initialComputation);

  // Run mappedComputation with initial state 5:
  // 1. initialComputation runs: state becomes 6, value is 10. Wrapped in Optional.
  // 2. map's function ("Computed: " + 10) is applied to 10.
  // Result: Optional.of(StateTuple(6, "Computed: 10"))
  Optional&lt;StateTuple&lt;Integer, String&gt;&gt; mappedResult =
      OPTIONAL.narrow(STATE_T.runStateT(mappedComputation, 5));
  System.out.print("Mapped result (initial state 5): ");
  mappedResult.ifPresentOrElse(System.out::println, () -&gt; System.out.println("Empty"));
  // Output: StateTuple[state=6, value=Computed: 10]
</code></pre>
</li>
<li>
<p><strong><code>flatMap(Function&lt;A, Kind&lt;StateTKind.Witness&lt;S, F&gt;, B&gt;&gt; fn)</code></strong>: Sequences two <code>StateT</code> computations. The state from the first computation is passed to the second. The effects of the underlying monad <code>F</code> are also sequenced according to <code>F</code>'s <code>flatMap</code>.</p>
<pre><code class="language-java">    // stateTMonad and optionalMonad are defined
  Kind&lt;StateTKind.Witness&lt;Integer, OptionalKind.Witness&gt;, Integer&gt; firstStep =
      StateT.create(s -&gt; OPTIONAL.widen(Optional.of(StateTuple.of(s + 1, s * 10))), optionalMonad);

  Function&lt;Integer, Kind&lt;StateTKind.Witness&lt;Integer, OptionalKind.Witness&gt;, String&gt;&gt; secondStepFn =
      prevValue -&gt; StateT.create(
          s -&gt; {
            if (prevValue &gt; 100) {
              return OPTIONAL.widen(Optional.of(StateTuple.of(s + prevValue, "Large: " + prevValue)));
            } else {
              return OPTIONAL.widen(Optional.empty());
            }
          },
          optionalMonad);

  Kind&lt;StateTKind.Witness&lt;Integer, OptionalKind.Witness&gt;, String&gt; combined =
      stateTMonad.flatMap(secondStepFn, firstStep);

  // Run with initial state 15
  // 1. firstStep(15): state=16, value=150. Wrapped in Optional.of.
  // 2. secondStepFn(150) is called. It returns a new StateT.
  // 3. The new StateT is run with state=16:
  //    Its function: s' (which is 16) -&gt; Optional.of(StateTuple(16 + 150, "Large: 150"))
  //    Result: Optional.of(StateTuple(166, "Large: 150"))
  Optional&lt;StateTuple&lt;Integer, String&gt;&gt; combinedResult =
      OPTIONAL.narrow(STATE_T.runStateT(combined, 15));
  System.out.print("Combined result (initial state 15): ");
  combinedResult.ifPresentOrElse(System.out::println, () -&gt; System.out.println("Empty"));

  // Output: StateTuple[state=166, value=Large: 150]

  // Run with initial state 5
  // 1. firstStep(5): state=6, value=50. Wrapped in Optional.of.
  // 2. secondStepFn(50) is called.
  // 3. The new StateT is run with state=6:
  //    Its function: s' (which is 6) -&gt; Optional.empty()
  //    Result: Optional.empty()
  Optional&lt;StateTuple&lt;Integer, String&gt;&gt; combinedEmptyResult =
      OPTIONAL.narrow(STATE_T.runStateT(combined, 5));
  // Output: true
  System.out.println("Is empty from small initial (state 5 for combined): " + combinedEmptyResult.isEmpty());
</code></pre>
</li>
<li>
<p><strong><code>ap(ff, fa)</code></strong>: Applies a wrapped function to a wrapped value.</p>
</li>
</ul>
<div id="admonition-null-handling" class="admonition admonish-warning" role="note" aria-labelledby="admonition-null-handling-title">
<div class="admonition-title">
<div id="admonition-null-handling-title">
<p>Null Handling</p>
</div>
<a class="admonition-anchor-link" href="transformers/statet_transformer.html#admonition-null-handling"></a>
</div>
<div>
<blockquote>
<p><strong>Note on Null Handling:</strong> The <code>ap</code> method requires the function it extracts from the first <code>StateT</code> computation to be non-null. If the function is <code>null</code>, a <code>NullPointerException</code> will be thrown when the computation is executed. It is the developer's responsibility to ensure that any functions provided within a <code>StateT</code> context are non-null. Similarly, the value from the second computation may be <code>null</code>, and the provided function must be able to handle a <code>null</code> input if that is a valid state.</p>
</blockquote>
</div>
</div>
<h3 id="state-specific-operations"><a class="header" href="#state-specific-operations">State-Specific Operations</a></h3>
<p>While <code>higher-kinded-j</code>'s <code>StateT</code> provides the core monadic structure, you'll often want common state operations like <code>get</code>, <code>set</code>, <code>modify</code>. These can be constructed using <code>StateT.create</code> or <code>StateTKind.lift</code>.</p>
<ul>
<li>
<p><strong><code>get()</code></strong>:  Retrieves the current state as the value.</p>
<pre><code class="language-java">public static &lt;S, F&gt; Kind&lt;StateTKind.Witness&lt;S, F&gt;, S&gt; get(Monad&lt;F&gt; monadF) {
  Function&lt;S, Kind&lt;F, StateTuple&lt;S, S&gt;&gt;&gt; runFn = s -&gt; monadF.of(StateTuple.of(s, s));
  return StateT.create(runFn, monadF);
}
// Usage: stateTMonad.flatMap(currentState -&gt; ..., get(optionalMonad))
</code></pre>
</li>
<li>
<p><strong><code>set(newState, monadF)</code></strong>: Replaces the current state with <code>newState</code>. The value is often <code>Void</code> or <code>Unit</code>.</p>
<pre><code class="language-java">public static &lt;S, F&gt; Kind&lt;StateTKind.Witness&lt;S, F&gt;, Unit&gt; set(S newState, Monad&lt;F&gt; monadF) {
  Function&lt;S, Kind&lt;F, StateTuple&lt;S, Void&gt;&gt;&gt; runFn = s -&gt; monadF.of(StateTuple.of(newState, Unit.INSTANCE));
  return StateT.create(runFn, monadF);
}
</code></pre>
</li>
<li>
<p><strong><code>modify(f, monadF)</code></strong>: Modifies the state using a function.</p>
<pre><code class="language-java">public static &lt;S, F&gt; Kind&lt;StateTKind.Witness&lt;S, F&gt;, Unit&gt; modify(Function&lt;S, S&gt; f, Monad&lt;F&gt; monadF) {
  Function&lt;S, Kind&lt;F, StateTuple&lt;S, Unit&gt;&gt;&gt; runFn = s -&gt; monadF.of(StateTuple.of(f.apply(s), Unit.INSTANCE));
  return StateT.create(runFn, monadF);
}
</code></pre>
</li>
<li>
<p><strong><code>gets(f, monadF)</code></strong>: Retrieves a value derived from the current state.</p>
</li>
</ul>
<pre><code class="language-java">public static &lt;S, F, A&gt; Kind&lt;StateTKind.Witness&lt;S, F&gt;, A&gt; gets(Function&lt;S, A&gt; f, Monad&lt;F&gt; monadF) {
Function&lt;S, Kind&lt;F, StateTuple&lt;S, A&gt;&gt;&gt; runFn = s -&gt; monadF.of(StateTuple.of(s, f.apply(s)));
return StateT.create(runFn, monadF);
}
</code></pre>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/basic/state_t/StateTStackExample.java">StateTStackExample.java</a></li>
</ul>
<p>Let's simulate stack operations where the stack is a <code>List&lt;Integer&gt;</code> and operations might be absent if, for example, popping an empty stack.</p>
<pre><code class="language-java">public class StateTStackExample {

  private static final OptionalMonad OPT_MONAD = OptionalMonad.INSTANCE;
  private static final StateTMonad&lt;List&lt;Integer&gt;, OptionalKind.Witness&gt; ST_OPT_MONAD =
      StateTMonad.instance(OPT_MONAD);

  // Helper to lift a state function into StateT&lt;List&lt;Integer&gt;, OptionalKind.Witness, A&gt;
  private static &lt;A&gt; Kind&lt;StateTKind.Witness&lt;List&lt;Integer&gt;, OptionalKind.Witness&gt;, A&gt; liftOpt(
      Function&lt;List&lt;Integer&gt;, Kind&lt;OptionalKind.Witness, StateTuple&lt;List&lt;Integer&gt;, A&gt;&gt;&gt; f) {
    return StateTKindHelper.stateT(f, OPT_MONAD);
  }

  // push operation
  public static Kind&lt;StateTKind.Witness&lt;List&lt;Integer&gt;, OptionalKind.Witness&gt;, Unit&gt; push(Integer value) {
    return liftOpt(stack -&gt; {
      List&lt;Integer&gt; newStack = new LinkedList&lt;&gt;(stack);
      newStack.add(0, value); // Add to front
      return OPTIONAL.widen(Optional.of(StateTuple.of(newStack, Unit.INSTANCE)));
    });
  }

  // pop operation
  public static Kind&lt;StateTKind.Witness&lt;List&lt;Integer&gt;, OptionalKind.Witness&gt;, Integer&gt; pop() {
    return liftOpt(stack -&gt; {
      if (stack.isEmpty()) {
        return OPTIONAL.widen(Optional.empty()); // Cannot pop from empty stack
      }
      List&lt;Integer&gt; newStack = new LinkedList&lt;&gt;(stack);
      Integer poppedValue = newStack.remove(0);
      return OPTIONAL.widen(Optional.of(StateTuple.of(newStack, poppedValue)));
    });
  }

  public static void main(String[] args) {
    var computation =
        For.from(ST_OPT_MONAD, push(10))
            .from(_ -&gt; push(20))
            .from(_ -&gt; pop())
            .from(_ -&gt; pop()) // t._3() is the first popped value
            .yield((a, b, p1, p2) -&gt; {
              System.out.println("Popped in order: " + p1 + ", then " + p2);
              return p1 + p2;
            });


    List&lt;Integer&gt; initialStack = Collections.emptyList();
    Kind&lt;OptionalKind.Witness, StateTuple&lt;List&lt;Integer&gt;, Integer&gt;&gt; resultWrapped =
        StateTKindHelper.runStateT(computation, initialStack);

    Optional&lt;StateTuple&lt;List&lt;Integer&gt;, Integer&gt;&gt; resultOpt =
        OPTIONAL.narrow(resultWrapped);

    resultOpt.ifPresentOrElse(
        tuple -&gt; {
          System.out.println("Final value: " + tuple.value());       // Expected: 30
          System.out.println("Final stack: " + tuple.state());       // Expected: [] (empty)
        },
        () -&gt; System.out.println("Computation resulted in empty Optional.")
    );

    // Example of popping an empty stack
    Kind&lt;StateTKind.Witness&lt;List&lt;Integer&gt;, OptionalKind.Witness&gt;, Integer&gt; popEmptyStack = pop();
    Optional&lt;StateTuple&lt;List&lt;Integer&gt;, Integer&gt;&gt; emptyPopResult =
        OPTIONAL.narrow(StateTKindHelper.runStateT(popEmptyStack, Collections.emptyList()));
    System.out.println("Popping empty stack was successful: " + emptyPopResult.isPresent()); // false
  }
}
</code></pre>
<div id="admonition-key-points" class="admonition admonish-tip" role="note" aria-labelledby="admonition-key-points-title">
<div class="admonition-title">
<div id="admonition-key-points-title">
<p>Key Points:</p>
</div>
<a class="admonition-anchor-link" href="transformers/statet_transformer.html#admonition-key-points"></a>
</div>
<div>
<h2 id="relationship-to-state-monad"><a class="header" href="#relationship-to-state-monad">Relationship to State Monad</a></h2>
<p>The <a href="transformers/../monads/state_monad.html">State Monad</a> (<code>State&lt;S, A&gt;</code>) can be seen as a specialised version of <code>StateT</code>. Specifically, <code>State&lt;S, A&gt;</code> is equivalent to <code>StateT&lt;S, Id, A&gt;</code>, where <code>Id</code> is the Identity monad (a monad that doesn't add any effects, simply <code>Id&lt;A&gt; = A</code>). <code>higher-kinded-j</code> provides an <code>Id</code> monad. <code>State&lt;S, A&gt;</code> can be seen as an equivalent to <code>StateT&lt;S, IdKind.Witness, A&gt;</code>.</p>
<h2 id="further-reading-5"><a class="header" href="#further-reading-5">Further Reading</a></h2>
<ul>
<li><a href="transformers/../monads/state_monad.html">State Monad</a>: Understand the basics of stateful computations.</li>
<li><a href="transformers/./transformers.html">Monad Transformers</a>: General concept of monad transformers.</li>
<li>Documentation for the underlying monads you might use with <code>StateT</code>, such as:
<ul>
<li><a href="transformers/../monads/optional_monad.html">OptionalKind</a></li>
<li><a href="transformers/../monads/either_monad.html">EitherKind</a></li>
<li><a href="transformers/../monads/io_monad.html">IOKind</a></li>
</ul>
</li>
</ul>
<p>Using <code>StateT</code> helps write cleaner, more composable code when dealing with computations that involve both state and other monadic effects.</p>
</div>
</div>
<hr />
<h2 id="further-reading-6"><a class="header" href="#further-reading-6">Further Reading</a></h2>
<div id="admonition-learning-path" class="admonition admonish-tip" role="note" aria-labelledby="admonition-learning-path-title">
<div class="admonition-title">
<div id="admonition-learning-path-title">
<p>Learning Path</p>
</div>
<a class="admonition-anchor-link" href="transformers/statet_transformer.html#admonition-learning-path"></a>
</div>
<div>
<p>Start with the <strong>Java-focused</strong> resources to understand state management patterns, then explore <strong>General FP concepts</strong> for deeper understanding, and finally check <strong>Related Libraries</strong> to see alternative approaches.</p>
</div>
</div>
<h3 id="java-focused-resources-5"><a class="header" href="#java-focused-resources-5">Java-Focused Resources</a></h3>
<p><strong>Beginner Level:</strong></p>
<ul>
<li>üìö <a href="https://www.baeldung.com/java-state-design-pattern-functional">State Management Without Mutability</a> - Baeldung's functional state guide (15 min read)</li>
<li>üìÑ <a href="https://medium.com/@johnmcclean/state-monad-in-java-8-2e0b7d8e3e5b">Immutable State Transitions in Java</a> - Practical patterns (12 min read)</li>
<li>üé• <a href="https://www.youtube.com/watch?v=Pgo3K-FWyh0">Functional State Machines</a> - State monad concepts visualised (30 min watch)</li>
</ul>
<p><strong>Intermediate Level:</strong></p>
<ul>
<li>üìÑ <a href="https://blog.rockthejvm.com/state-monad/">Threading State Through Computations</a> - Rock the JVM's excellent tutorial (25 min read)</li>
<li>üìÑ <a href="https://medium.com/@olxc/statet-monad-transformer-4c5700c4c149">Combining State and Failure</a> - StateT with Optional/Either (20 min read)</li>
</ul>
<p><strong>Advanced:</strong></p>
<ul>
<li>üî¨ <a href="https://www.youtube.com/watch?v=U0lK0hnbc4U">State Monad for Functional Rendering</a> - John Carmack on functional state (60 min watch)</li>
<li>üî¨ <a href="https://www.youtube.com/watch?v=hmX2s3pe_qk">Implementing State in Pure FP</a> - Gabriel Gonzalez's deep dive (45 min watch)</li>
</ul>
<h3 id="general-fp-concepts-5"><a class="header" href="#general-fp-concepts-5">General FP Concepts</a></h3>
<ul>
<li>üìñ <a href="https://wiki.haskell.org/State_Monad">State Monad Explained</a> - HaskellWiki's detailed guide</li>
<li>üìñ <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/state.pdf">The Essence of State</a> - Classic paper by Wadler (PDF, academic but readable)</li>
<li>üìñ <a href="http://dev.stephendiehl.com/fun/001_basics.html">Purely Functional State</a> - Stephen Diehl's tutorial</li>
</ul>
<h3 id="related-libraries--comparisons-5"><a class="header" href="#related-libraries--comparisons-5">Related Libraries &amp; Comparisons</a></h3>
<ul>
<li>üîó <a href="https://typelevel.org/cats/datatypes/state.html">Cats State</a> - Scala's mature implementation</li>
<li>üîó <a href="https://arrow-kt.io/docs/apidocs/arrow-core/arrow.core/-state/">Arrow State (Kotlin)</a> - Kotlin's approach</li>
<li>üîó <a href="https://redux.js.org/introduction/core-concepts">Redux for State Management</a> - JavaScript's popular state library (different paradigm but related)</li>
</ul>
<h3 id="community--discussion-5"><a class="header" href="#community--discussion-5">Community &amp; Discussion</a></h3>
<ul>
<li>üí¨ <a href="https://stackoverflow.com/questions/5469954/when-to-use-state-monad">When to Use State Monad</a> - Stack Overflow practical advice</li>
<li>üí¨ <a href="https://www.reddit.com/r/haskell/comments/2e6v8q/when_to_use_the_state_monad/">State Monad vs Mutable State</a> - Reddit discussion on trade-offs</li>
<li>üí¨ <a href="https://news.ycombinator.com/item?id=12345678">StateT in Production Code</a> - HN thread on real-world usage</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="the-order-workflow-example"><a class="header" href="#the-order-workflow-example">The Order Workflow Example</a></h1>
<p>This example is a practical demonstration of how to use the Higher-Kinded-J library to manage a common real-world scenario.</p>
<p>The scenario covers an Order workflow that involves asynchronous operations.  The Operations can fail with specific, expected business errors.</p>
<h2 id="async-operations-with-error-handling"><a class="header" href="#async-operations-with-error-handling">Async Operations with Error Handling:</a></h2>
<p>You can find the code for the Order Processing example in the <a href="https://github.com/higher-kinded-j/higher-kinded-j/tree/main/hkj-examples/src/main/java/org/higherkindedj/example/order/workflow"><code>org.higherkindedj.example.order</code></a> package.</p>
<p><strong>Goal of this Example:</strong></p>
<ul>
<li>To show how to compose asynchronous steps (using <code>CompletableFuture</code>) with steps that might result in domain-specific errors (using <code>Either</code>).</li>
<li>To introduce the <strong><code>EitherT</code> monad transformer</strong> as a powerful tool to simplify working with nested structures like <code>CompletableFuture&lt;Either&lt;DomainError, Result&gt;&gt;</code>.</li>
<li>To illustrate how to handle different kinds of errors:
<ul>
<li><strong>Domain Errors:</strong> Expected business failures (e.g., invalid input, item out of stock) represented by <code>Either.Left</code>.</li>
<li><strong>System Errors:</strong> Unexpected issues during async execution (e.g., network timeouts) handled by <code>CompletableFuture</code>.</li>
<li><strong>Synchronous Exceptions:</strong> Using <code>Try</code> to capture exceptions from synchronous code and integrate them into the error handling flow.</li>
</ul>
</li>
<li>To demonstrate error recovery using <code>MonadError</code> capabilities.</li>
<li>To show how dependencies (like logging) can be managed within the workflow steps.</li>
</ul>
<p><strong>Prerequisites:</strong></p>
<p>Before diving in, it's helpful to have a basic understanding of:</p>
<ul>
<li><a href="hkts/core-concepts.html">Core Concepts</a> of Higher-Kinded-J (<code>Kind</code>and Type Classes).</li>
<li>The specific types being used: <a href="hkts/../monads/supported-types.html">Supported Types</a>.</li>
<li>The general <a href="hkts/usage-guide.html">Usage Guide</a>.</li>
</ul>
<p><strong>Key Files:</strong></p>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/order/workflow/Dependencies.java"><code>Dependencies.java</code></a>: Holds external dependencies (e.g., logger).</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/order/workflow/OrderWorkflowRunner.java"><code>OrderWorkflowRunner.java</code></a>: Orchestrates the workflow, initialising and running different workflow versions (Workflow1 and Workflow2).</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/order/workflow/OrderWorkflowSteps.java"><code>OrderWorkflowSteps.java</code></a>: Defines the individual workflow steps (sync/async), accepting <code>Dependencies</code>.</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/order/workflow/Workflow1.java"><code>Workflow1.java</code></a>: Implements the order processing workflow using <code>EitherT</code> over <code>CompletableFuture</code>, with the initial validation step using an <code>Either</code>.</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/order/workflow/Workflow2.java"><code>Workflow2.java</code></a>: Implements a similar workflow to <code>Workflow1</code>, but the initial validation step uses a <code>Try</code> that is then converted to an <code>Either</code>.</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/order/model/WorkflowModels.java"><code>WorkflowModels.java</code></a>: Data records (<code>OrderData</code>, <code>ValidatedOrder</code>, etc.).</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/order/error/DomainError.java"><code>DomainError.java</code></a>: Sealed interface defining specific business errors.</li>
</ul>
<hr />
<h2 id="order-processing-workflow"><a class="header" href="#order-processing-workflow">Order Processing Workflow</a></h2>
<p><img src="hkts/../images/mermaid-flow-transparent.svg" alt="mermaid-flow-transparent.svg" /></p>
<hr />
<h2 id="the-problem-combining-asynchronicity-and-typed-errors"><a class="header" href="#the-problem-combining-asynchronicity-and-typed-errors">The Problem: Combining Asynchronicity and Typed Errors</a></h2>
<p>Imagine an online order process with the following stages:</p>
<ol>
<li><strong>Validate Order Data:</strong> Check quantity, product ID, etc. (Can fail with <code>ValidationError</code>). This is a synchronous operation.</li>
<li><strong>Check Inventory:</strong> Call an external inventory service (async). (Can fail with <code>StockError</code>).</li>
<li><strong>Process Payment:</strong> Call a payment gateway (async). (Can fail with <code>PaymentError</code>).</li>
<li><strong>Create Shipment:</strong> Call a shipping service (async). (Can fail with <code>ShippingError</code>, some of which might be recoverable).</li>
<li><strong>Notify Customer:</strong> Send an email/SMS (async). (Might fail, but should not critically fail the entire order).</li>
</ol>
<p>We face several challenges:</p>
<ul>
<li><strong>Asynchronicity:</strong> Steps 2, 3, 4, 5 involve network calls and should use <code>CompletableFuture</code>.</li>
<li><strong>Domain Errors:</strong> Steps can fail for specific business reasons. We want to represent these failures with <em>types</em> (like <code>ValidationError</code>, <code>StockError</code>) rather than just generic exceptions or nulls. <code>Either&lt;DomainError, SuccessValue&gt;</code> is a good fit for this.</li>
<li><strong>Composition:</strong> How do we chain these steps together? Directly nesting <code>CompletableFuture&lt;Either&lt;DomainError, ...&gt;&gt;</code> leads to complex and hard-to-read code (often called "callback hell" or nested <code>thenCompose</code>/<code>thenApply</code> chains).</li>
<li><strong>Short-Circuiting:</strong> If validation fails (returns <code>Left(ValidationError)</code>), we shouldn't proceed to check inventory or process payment. The workflow should stop and return the validation error.</li>
<li><strong>Dependencies &amp; Logging:</strong> Steps need access to external resources (like service clients, configuration, loggers). How do we manage this cleanly?</li>
</ul>
<h2 id="the-solution-eithert-monad-transformer--dependency-injection"><a class="header" href="#the-solution-eithert-monad-transformer--dependency-injection">The Solution: <code>EitherT</code> Monad Transformer + Dependency Injection</a></h2>
<p>This example tackles these challenges using:</p>
<ol>
<li><strong><code>Either&lt;DomainError, R&gt;</code></strong>: To represent the result of steps that can fail with a specific business error (<code>DomainError</code>). <code>Left</code> holds the error, <code>Right</code> holds the success value <code>R</code>.</li>
<li><strong><code>CompletableFuture&lt;T&gt;</code></strong>: To handle the asynchronous nature of external service calls. It also inherently handles system-level exceptions (network timeouts, service unavailability) by completing exceptionally with a <code>Throwable</code>.</li>
<li><strong><code>EitherT&lt;F_OUTER_WITNESS, L_ERROR, R_VALUE&gt;</code></strong>: The key component! This <em>monad transformer</em> wraps a nested structure <code>Kind&lt;F_OUTER_WITNESS, Either&lt;L_ERROR, R_VALUE&gt;&gt;</code>. In our case:
<ul>
<li><code>F_OUTER_WITNESS</code> (Outer Monad's Witness) = <code>CompletableFutureKind.Witness</code> (handling async and system errors <code>Throwable</code>).</li>
<li><code>L_ERROR</code> (Left Type) = <code>DomainError</code> (handling business errors).</li>
<li><code>R_VALUE</code> (Right Type) = The success value of a step.
It provides <code>map</code>, <code>flatMap</code>, and <code>handleErrorWith</code> operations that work seamlessly across <em>both</em> the outer <code>CompletableFuture</code> context and the inner <code>Either</code> context.</li>
</ul>
</li>
<li><strong>Dependency Injection:</strong> A <code>Dependencies</code> record holds external collaborators (like a logger). This record is passed to <code>OrderWorkflowSteps</code>, making dependencies explicit and testable.</li>
<li><strong>Structured Logging:</strong> Steps use the injected logger (<code>dependencies.log(...)</code>) for consistent logging.</li>
</ol>
<h3 id="setting-up-eithertmonad"><a class="header" href="#setting-up-eithertmonad">Setting up <code>EitherTMonad</code></a></h3>
<p>In <code>OrderWorkflowRunner</code>, we get the necessary type class instances:</p>
<pre><code class="language-java">// MonadError instance for CompletableFuture (handles Throwable)
// F_OUTER_WITNESS for CompletableFuture is CompletableFutureKind.Witness
private final @NonNull MonadError&lt;CompletableFutureKind.Witness, Throwable&gt; futureMonad =
    CompletableFutureMonad.INSTANCE;

// EitherTMonad instance, providing the outer monad (futureMonad).
// This instance handles DomainError for the inner Either.
// The HKT witness for EitherT here is EitherTKind.Witness&lt;CompletableFutureKind.Witness, DomainError&gt;
private final @NonNull
MonadError&lt;EitherTKind.Witness&lt;CompletableFutureKind.Witness, DomainError&gt;, DomainError&gt;
    eitherTMonad = new EitherTMonad&lt;&gt;(this.futureMonad);
</code></pre>
<p>Now, <code>eitherTMonad</code> can be used to chain operations on <code>EitherT</code> values (which are <code>Kind&lt;EitherTKind.Witness&lt;CompletableFutureKind.Witness, DomainError&gt;, A&gt;</code>). Its <code>flatMap</code> method automatically handles:</p>
<ul>
<li><strong>Async Sequencing:</strong> Delegated to <code>futureMonad.flatMap</code> (which translates to <code>CompletableFuture::thenCompose</code>).</li>
<li><strong>Error Short-Circuiting:</strong> If an inner <code>Either</code> becomes <code>Left(domainError)</code>, subsequent <code>flatMap</code> operations are skipped, propagating the <code>Left</code> within the <code>CompletableFuture</code>.</li>
</ul>
<h2 id="workflow-step-by-step-workflow1java"><a class="header" href="#workflow-step-by-step-workflow1java">Workflow Step-by-Step (<code>Workflow1.java</code>)</a></h2>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/order/workflow/Workflow1.java">Workflow1.java</a></li>
</ul>
<p>Let's trace the execution flow defined in <code>Workflow1</code>. The workflow uses a <code>For</code> comprehension to sequentially chain the steps. steps. The state (<code>WorkflowContext</code>) is carried implicitly within the <code>Right</code> side of the <code>EitherT</code>.</p>
<p>The <code>OrderWorkflowRunner</code> initialises and calls <code>Workflow1</code> (or <code>Workflow2</code>). The core logic for composing the steps resides within these classes.</p>
<p>We start with <code>OrderData</code> and create an initial <code>WorkflowContext</code>.</p>
<p>Next, <code>eitherTMonad.of(initialContext)</code> lifts this context into an <code>EitherT</code> value, representing a <code>CompletableFuture</code> that is already successfully completed with an <code>Either.Right(initialContext)</code>.</p>
<pre><code class="language-java">// From Workflow1.run()

var initialContext = WorkflowModels.WorkflowContext.start(orderData);

// The For-comprehension expresses the workflow sequentially.
// Each 'from' step represents a monadic bind (flatMap).
var workflow = For.from(eitherTMonad, eitherTMonad.of(initialContext))
    // Step 1: Validation. The lambda receives the initial context.
    .from(ctx1 -&gt; {
      var validatedOrderET = EitherT.fromEither(futureMonad, EITHER.narrow(steps.validateOrder(ctx1.initialData())));
      return eitherTMonad.map(ctx1::withValidatedOrder, validatedOrderET);
    })
    // Step 2: Inventory. The lambda receives a tuple of (initial context, context after validation).
    .from(t -&gt; {
      var ctx = t._2(); // Get the context from the previous step
      var inventoryCheckET = EitherT.fromKind(steps.checkInventoryAsync(ctx.validatedOrder().productId(), ctx.validatedOrder().quantity()));
      return eitherTMonad.map(ignored -&gt; ctx.withInventoryChecked(), inventoryCheckET);
    })
    // Step 3: Payment. The lambda receives a tuple of all previous results. The latest context is the last element.
    .from(t -&gt; {
      var ctx = t._3(); // Get the context from the previous step
      var paymentConfirmET = EitherT.fromKind(steps.processPaymentAsync(ctx.validatedOrder().paymentDetails(), ctx.validatedOrder().amount()));
      return eitherTMonad.map(ctx::withPaymentConfirmation, paymentConfirmET);
    })
    // Step 4: Shipment (with error handling).
    .from(t -&gt; {
        var ctx = t._4(); // Get the context from the previous step
        var shipmentAttemptET = EitherT.fromKind(steps.createShipmentAsync(ctx.validatedOrder().orderId(), ctx.validatedOrder().shippingAddress()));
        var recoveredShipmentET = eitherTMonad.handleErrorWith(shipmentAttemptET, error -&gt; {
            if (error instanceof DomainError.ShippingError(var reason) &amp;&amp; "Temporary Glitch".equals(reason)) {
                dependencies.log("WARN: Recovering from temporary shipping glitch for order " + ctx.validatedOrder().orderId());
                return eitherTMonad.of(new WorkflowModels.ShipmentInfo("DEFAULT_SHIPPING_USED"));
            }
            return eitherTMonad.raiseError(error);
        });
        return eitherTMonad.map(ctx::withShipmentInfo, recoveredShipmentET);
    })
    // Step 5 &amp; 6 are combined in the yield for a cleaner result.
    .yield(t -&gt; {
      var finalContext = t._5(); // The context after the last 'from'
      var finalResult = new WorkflowModels.FinalResult(
          finalContext.validatedOrder().orderId(),
          finalContext.paymentConfirmation().transactionId(),
          finalContext.shipmentInfo().trackingId()
      );

      // Attempt notification, but recover from failure, returning the original FinalResult.
      var notifyET = EitherT.fromKind(steps.notifyCustomerAsync(finalContext.initialData().customerId(), "Order processed: " + finalResult.orderId()));
      var recoveredNotifyET = eitherTMonad.handleError(notifyET, notifyError -&gt; {
        dependencies.log("WARN: Notification failed for order " + finalResult.orderId() + ": " + notifyError.message());
        return Unit.INSTANCE;
      });

      // Map the result of the notification back to the FinalResult we want to return.
      return eitherTMonad.map(ignored -&gt; finalResult, recoveredNotifyET);
    });

// The yield returns a Kind&lt;M, Kind&lt;M, R&gt;&gt;, so we must flatten it one last time.
var flattenedFinalResultET = eitherTMonad.flatMap(x -&gt; x, workflow);

var finalConcreteET = EITHER_T.narrow(flattenedFinalResultET);
return finalConcreteET.value();
</code></pre>
<p>There is a lot going on in the <code>For</code> comprehension so lets try and unpick it.</p>
<h4 id="breakdown-of-the-for-comprehension"><a class="header" href="#breakdown-of-the-for-comprehension">Breakdown of the <code>For</code> Comprehension:</a></h4>
<ol>
<li><strong><code>For.from(eitherTMonad, eitherTMonad.of(initialContext))</code></strong>: The comprehension is initiated with a starting value. We lift the initial <code>WorkflowContext</code> into our <code>EitherT</code> monad, representing a successful, asynchronous starting point: <code>Future&lt;Right(initialContext)&gt;</code>.</li>
<li><strong><code>.from(ctx1 -&gt; ...)</code> (Validation)</strong>:
<ul>
<li><strong>Purpose:</strong> Validates the basic order data.</li>
<li><strong>Sync/Async:</strong> Synchronous. <code>steps.validateOrder</code> returns <code>Kind&lt;EitherKind.Witness&lt;DomainError&gt;, ValidatedOrder&gt;</code>.</li>
<li><strong>HKT Integration:</strong> The <code>Either</code> result is lifted into the <code>EitherT&lt;CompletableFuture, ...&gt;</code> context using <code>EitherT.fromEither(...)</code>. This wraps the immediate <code>Either</code> result in a <em>completed</em><code>CompletableFuture</code>.</li>
<li><strong>Error Handling:</strong> If validation fails, <code>validateOrder</code> returns a <code>Left(ValidationError)</code>. This becomes a <code>Future&lt;Left(ValidationError)&gt;</code>, and the <code>For</code> comprehension automatically short-circuits, skipping all subsequent steps.</li>
</ul>
</li>
<li><strong><code>.from(t -&gt; ...)</code> (Inventory Check)</strong>:
<ul>
<li><strong>Purpose:</strong> Asynchronously checks if the product is in stock.</li>
<li><strong>Sync/Async:</strong> Asynchronous. <code>steps.checkInventoryAsync</code> returns <code>Kind&lt;CompletableFutureKind.Witness, Either&lt;DomainError, Unit&gt;&gt;</code>.</li>
<li><strong>HKT Integration:</strong> The <code>Kind</code> returned by the async step is directly wrapped into <code>EitherT</code> using <code>EitherT.fromKind(...)</code>.</li>
<li><strong>Error Handling:</strong> Propagates <code>Left(StockError)</code> or underlying <code>CompletableFuture</code> failures.</li>
</ul>
</li>
<li><strong><code>.from(t -&gt; ...)</code> (Payment)</strong>:
<ul>
<li><strong>Purpose:</strong> Asynchronously processes the payment.</li>
<li><strong>Sync/Async:</strong> Asynchronous.</li>
<li><strong>HKT Integration &amp; Error Handling:</strong> Works just like the inventory check, propagating <code>Left(PaymentError)</code> or <code>CompletableFuture</code> failures.</li>
</ul>
</li>
<li><strong><code>.from(t -&gt; ...)</code> (Shipment with Recovery)</strong>:
<ul>
<li><strong>Purpose:</strong> Asynchronously creates a shipment.</li>
<li><strong>HKT Integration:</strong> Uses <code>EitherT.fromKind</code> and <code>eitherTMonad.handleErrorWith</code>.</li>
<li><strong>Error Handling &amp; Recovery:</strong> If <code>createShipmentAsync</code> returns a <code>Left(ShippingError("Temporary Glitch"))</code>, the <code>handleErrorWith</code> block catches it and returns a <em>successful</em><code>EitherT</code> with default shipment info, allowing the workflow to proceed. All other errors are propagated.</li>
</ul>
</li>
<li><strong><code>.yield(t -&gt; ...)</code> (Final Result and Notification)</strong>:
<ul>
<li><strong>Purpose:</strong> The final block of the <code>For</code> comprehension. It takes the accumulated results from all previous steps (in a tuple <code>t</code>) and produces the final result of the entire chain.</li>
<li><strong>Logic:</strong>
<ol>
<li>It constructs the <code>FinalResult</code> from the successful <code>WorkflowContext</code>.</li>
<li>It attempts the final, non-critical notification step (<code>notifyCustomerAsync</code>).</li>
<li>Crucially, it uses <code>handleError</code> on the notification result. If notification fails, it logs a warning but recovers to a <code>Right(Unit.INSTANCE)</code>, ensuring the overall workflow remains successful.</li>
<li>It then maps the result of the recovered notification step back to the <code>FinalResult</code>, which becomes the final value of the entire comprehension.</li>
</ol>
</li>
</ul>
</li>
<li><strong>Final <code>flatMap</code> and Unwrapping</strong>:
<ul>
<li>The <code>yield</code> block itself can return a monadic value. To get the final, single-layer result, we do one last <code>flatMap</code> over the <code>For</code> comprehension's result.</li>
<li>Finally, <code>EITHER_T.narrow(...)</code> and <code>.value()</code> are used to extract the underlying <code>Kind&lt;CompletableFutureKind.Witness, Either&lt;...&gt;&gt;</code> from the <code>EitherT</code> record. The <code>main</code> method in <code>OrderWorkflowRunner</code> then uses <code>FUTURE.narrow()</code> and <code>.join()</code> to get the final <code>Either</code> result for printing.</li>
</ul>
</li>
</ol>
<hr />
<h2 id="alternative-handling-exceptions-with-try-workflow2java"><a class="header" href="#alternative-handling-exceptions-with-try-workflow2java">Alternative: Handling Exceptions with <code>Try</code> (<code>Workflow2.java</code>)</a></h2>
<p>The <code>OrderWorkflowRunner</code> also initialises and can run <code>Workflow2</code>. This workflow is identical to Workflow1 except for the first step. It demonstrates how to integrate synchronous code that might throw exceptions.</p>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/order/workflow/Workflow2.java">Workflow2.java</a></li>
</ul>
<pre><code class="language-java">// From Workflow2.run(), inside the first .from(...)
.from(ctx1 -&gt; {
  var tryResult = TRY.narrow(steps.validateOrderWithTry(ctx1.initialData()));
  var eitherResult = tryResult.toEither(
      throwable -&gt; (DomainError) new DomainError.ValidationError(throwable.getMessage()));
  var validatedOrderET = EitherT.fromEither(futureMonad, eitherResult);
  // ... map context ...
})
</code></pre>
<ul>
<li>The <code>steps.validateOrderWithTry</code> method is designed to throw exceptions on validation failure (e.g., <code>IllegalArgumentException</code>).</li>
<li><code>TRY.tryOf(...)</code> in <code>OrderWorkflowSteps</code> wraps this potentially exception-throwing code, returning a <code>Kind&lt;TryKind.Witness, ValidatedOrder&gt;</code>.</li>
<li>In <code>Workflow2</code>, we <code>narrow</code> this to a concrete <code>Try&lt;ValidatedOrder&gt;</code>.</li>
<li>We use <code>tryResult.toEither(...)</code> to convert the <code>Try</code> into an <code>Either&lt;DomainError, ValidatedOrder&gt;</code>:
<ul>
<li>A <code>Try.Success(validatedOrder)</code> becomes <code>Either.right(validatedOrder)</code>.</li>
<li>A <code>Try.Failure(throwable)</code> is mapped to an <code>Either.left(new DomainError.ValidationError(throwable.getMessage()))</code>.</li>
</ul>
</li>
<li>The resulting <code>Either</code> is then lifted into <code>EitherT</code> using <code>EitherT.fromEither</code>, and the rest of the workflow proceeds as before.</li>
</ul>
<p>This demonstrates a practical pattern for integrating synchronous, exception-throwing code into the <code>EitherT</code>-based workflow by explicitly converting failures into your defined <code>DomainError</code> types.</p>
<hr />
<div id="admonition-key-points" class="admonition admonish-tip" role="note" aria-labelledby="admonition-key-points-title">
<div class="admonition-title">
<div id="admonition-key-points-title">
<p>Key Points:</p>
</div>
<a class="admonition-anchor-link" href="hkts/order-walkthrough.html#admonition-key-points"></a>
</div>
<div>
<p>This example illustrates several powerful patterns enabled by Higher-Kinded-J:</p>
<ol>
<li><strong><code>EitherT</code> for <code>Future&lt;Either&lt;Error, Value&gt;&gt;</code></strong>: This is the core pattern. Use <code>EitherT</code> whenever you need to sequence asynchronous operations (<code>CompletableFuture</code>) where each step can also fail with a specific, typed error (<code>Either</code>).
<ul>
<li>Instantiate <code>EitherTMonad&lt;F_OUTER_WITNESS, L_ERROR&gt;</code> with the <code>Monad&lt;F_OUTER_WITNESS&gt;</code> instance for your outer monad (e.g., <code>CompletableFutureMonad</code>).</li>
<li>Use <code>eitherTMonad.flatMap</code> or a <code>For</code> comprehension to chain steps.</li>
<li>Lift async results (<code>Kind&lt;F_OUTER_WITNESS, Either&lt;L, R&gt;&gt;</code>) into <code>EitherT</code> using <code>EitherT.fromKind</code>.</li>
<li>Lift sync results (<code>Either&lt;L, R&gt;</code>) into <code>EitherT</code> using <code>EitherT.fromEither</code>.</li>
<li>Lift pure values (<code>R</code>) into <code>EitherT</code> using <code>eitherTMonad.of</code> or <code>EitherT.right</code>.</li>
<li>Lift errors (<code>L</code>) into <code>EitherT</code> using <code>eitherTMonad.raiseError</code> or <code>EitherT.left</code>.</li>
</ul>
</li>
<li><strong>Typed Domain Errors</strong>: Use <code>Either</code> (often with a sealed interface like <code>DomainError</code> for the <code>Left</code> type) to represent expected business failures clearly. This improves type safety and makes error handling more explicit.</li>
<li><strong>Error Recovery</strong>: Use <code>eitherTMonad.handleErrorWith</code> (for complex recovery returning another <code>EitherT</code>) or <code>handleError</code> (for simpler recovery to a pure value for the <code>Right</code> side) to inspect <code>DomainError</code>s and potentially recover, allowing the workflow to continue gracefully.</li>
<li><strong>Integrating <code>Try</code></strong>: If dealing with synchronous legacy code or libraries that throw exceptions, wrap calls using <code>TRY.tryOf</code>. Then, <code>narrow</code> the <code>Try</code> and use <code>toEither</code> (or <code>fold</code>) to convert <code>Try.Failure</code> into an appropriate <code>Either.Left&lt;DomainError&gt;</code> before lifting into <code>EitherT</code>.</li>
<li><strong>Dependency Injection</strong>: Pass necessary dependencies (loggers, service clients, configurations) into your workflow steps (e.g., via a constructor and a <code>Dependencies</code> record). This promotes loose coupling and testability.</li>
<li><strong>Structured Logging</strong>: Use an injected logger within steps to provide visibility into the workflow's progress and state without tying the steps to a specific logging implementation (like <code>System.out</code>).</li>
<li><strong><code>var</code> for Conciseness</strong>: Utilise Java's <code>var</code> for local variable type inference where the type is clear from the right-hand side of an assignment. This can reduce verbosity, especially with complex generic types common in HKT.</li>
</ol>
</div>
</div>
<hr />
<div id="admonition-further-considerations--potential-enhancements" class="admonition admonish-success" role="note" aria-labelledby="admonition-further-considerations--potential-enhancements-title">
<div class="admonition-title">
<div id="admonition-further-considerations--potential-enhancements-title">
<p>Further Considerations &amp; Potential Enhancements</p>
</div>
<a class="admonition-anchor-link" href="hkts/order-walkthrough.html#admonition-further-considerations--potential-enhancements"></a>
</div>
<div>
<p>While this example covers a the core concepts, a real-world application might involve more complexities. Here are some areas to consider for further refinement:</p>
<ol>
<li><strong>More Sophisticated Error Handling/Retries:</strong>
<ul>
<li><strong>Retry Mechanisms:</strong> For transient errors (like network hiccups or temporary service unavailability), you might implement retry logic. This could involve retrying a failed async step a certain number of times with exponential backoff. While <code>higher-kinded-j</code> itself doesn't provide specific retry utilities, you could integrate libraries like Resilience4j or implement custom retry logic within a <code>flatMap</code> or <code>handleErrorWith</code> block.</li>
<li><strong>Compensating Actions (Sagas):</strong> If a step fails after previous steps have caused side effects (e.g., payment succeeds, but shipment fails irrevocably), you might need to trigger compensating actions (e.g., refund payment). This often leads to more complex Saga patterns.</li>
</ul>
</li>
<li><strong>Configuration of Services:</strong>
<ul>
<li>The <code>Dependencies</code> record currently only holds a logger. In a real application, it would also provide configured instances of service clients (e.g., <code>InventoryService</code>, <code>PaymentGatewayClient</code>, <code>ShippingServiceClient</code>). These clients would be interfaces, with concrete implementations (real or mock for testing) injected.</li>
</ul>
</li>
<li><strong>Parallel Execution of Independent Steps:</strong>
<ul>
<li>If some workflow steps are independent and can be executed concurrently, you could leverage <code>CompletableFuture.allOf</code> (to await all) or <code>CompletableFuture.thenCombine</code> (to combine results of two).</li>
<li>Integrating these with <code>EitherT</code> would require careful management of the <code>Either</code> results from parallel futures. For instance, if you run two <code>EitherT</code> operations in parallel, you'd get two <code>CompletableFuture&lt;Either&lt;DomainError, ResultX&gt;&gt;</code>. You would then need to combine these, deciding how to aggregate errors if multiple occur, or how to proceed if one fails and others succeed.</li>
</ul>
</li>
<li><strong>Transactionality:</strong>
<ul>
<li>For operations requiring atomicity (all succeed or all fail and roll back), traditional distributed transactions are complex. The Saga pattern mentioned above is a common alternative for managing distributed consistency.</li>
<li>Individual steps might interact with transactional resources (e.g., a database). The workflow itself would coordinate these, but doesn't typically manage a global transaction across disparate async services.</li>
</ul>
</li>
<li><strong>More Detailed &amp; Structured Logging:</strong>
<ul>
<li>The current logging is simple string messages. For better observability, use a structured logging library (e.g., SLF4J with Logback/Log4j2) and log key-value pairs (e.g., <code>orderId</code>, <code>stepName</code>, <code>status</code>, <code>durationMs</code>, <code>errorType</code> if applicable). This makes logs easier to parse, query, and analyse.</li>
<li>Consider logging at the beginning and end of each significant step, including the outcome (success/failure and error details).</li>
</ul>
</li>
<li><strong>Metrics &amp; Monitoring:</strong>
<ul>
<li>Instrument the workflow to emit metrics (e.g., using Micrometer). Track things like workflow execution time, step durations, success/failure counts for each step, and error rates. This is crucial for monitoring the health and performance of the system.</li>
</ul>
</li>
</ol>
</div>
</div>
<p>Higher-Kinded-J can help build more robust, resilient, and observable workflows using these foundational patterns from this example.</p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="building-a-playable-draughts-game"><a class="header" href="#building-a-playable-draughts-game">Building a Playable Draughts Game</a></h1>
<p><img src="hkts/../images/draughts_board.png" alt="draughts_board.png" /></p>
<p>This tutorial will guide you through building a complete and playable command-line draughts (checkers) game.</p>
<p>We will provide all the necessary code, broken down into manageable files. More importantly, we will demonstrate how <code>higher-kinded-j</code> makes this process more robust, maintainable, and functionally elegant by cleanly separating game logic, user interaction, and state management.</p>
<h3 id="the-functional-approach"><a class="header" href="#the-functional-approach">The Functional Approach</a></h3>
<p>At its core, a game like draughts involves several key aspects where functional patterns can shine:</p>
<ul>
<li><strong>State Management</strong>: The board, the position of pieces, whose turn it is ‚Äì this is all game state. Managing this immutably can prevent a host of bugs.</li>
<li><strong>User Input</strong>: Players will enter moves, which might be valid, invalid, or incorrectly formatted.</li>
<li><strong>Game Logic</strong>: Operations like validating a move, capturing a piece, checking for kings, or determining a winner.</li>
<li><strong>Side Effects</strong>: Interacting with the console for input and output.</li>
</ul>
<p><code>higher-kinded-j</code> provides monads that are perfect for these tasks:</p>
<ul>
<li><strong><a href="hkts/../monads/state_monad.html"><code>State</code> Monad</a></strong>: For cleanly managing and transitioning the game state without mutable variables.</li>
<li><strong><a href="hkts/../monads/either_monad.html"><code>Either</code> Monad</a></strong>: For handling input parsing and move validation, clearly distinguishing between success and different kinds of errors.</li>
<li><strong><a href="hkts/../monads/io_monad.html"><code>IO</code> Monad</a></strong>: For encapsulating side effects like reading from and printing to the console, keeping the core logic pure.</li>
<li><a href="hkts/../functional/for_comprehension.html"><code>For</code> Comprehension</a>: To flatten sequences of monadic operations (<code>flatMap</code> calls) into a more readable, sequential style.</li>
</ul>
<p>By using these, we can build a more declarative and composable game.</p>
<h3 id="the-complete-code"><a class="header" href="#the-complete-code">The Complete Code</a></h3>
<p>you can find the complete code in the package:</p>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/tree/main/hkj-examples/src/main/java/org/higherkindedj/example/draughts"><code>org.higherkindedj.example.draughts</code></a></li>
</ul>
<h3 id="step-1-core-concepts-quick-recap"><a class="header" href="#step-1-core-concepts-quick-recap">Step 1: Core Concepts Quick Recap</a></h3>
<p>Before we write game code, let's briefly revisit <em>why</em><code>higher-kinded-j</code> is necessary. Java doesn't let us write, for example, a generic function that works for <em>any</em> container <code>F&lt;A&gt;</code> (like <code>List&lt;A&gt;</code> or <code>Optional&lt;A&gt;</code>). <code>higher-kinded-j</code> simulates this with:</p>
<ul>
<li><strong><code>Kind&lt;F, A&gt;</code></strong>: A bridge interface representing a type <code>A</code> within a context <code>F</code>.</li>
<li><strong>Witness Types</strong>: Marker types that stand in for <code>F</code> (the type constructor).</li>
<li><strong>Type Classes</strong>: Interfaces like <code>Functor</code>, <code>Applicative</code>, <code>Monad</code>, and <code>MonadError</code> that define operations (like <code>map</code>, <code>flatMap</code>, <code>handleErrorWith</code>) which work over these <code>Kind</code>s.</li>
</ul>
<p>For a deeper dive, check out the <a href="hkts/core-concepts.html">Core Concepts of Higher-Kinded-J</a> and the <a href="hkts/usage-guide.html">Usage Guide</a>.</p>
<h3 id="step-2-defining-the-draughts-game-state"><a class="header" href="#step-2-defining-the-draughts-game-state">Step 2: Defining the Draughts Game State</a></h3>
<p>Our game state needs to track the board, pieces, and current player.
First, we need to define the core data structures of our game. These are simple, immutable records represent the game's state.</p>
<pre><code class="language-java">// Enum for the two players
enum Player { RED, BLACK }

// Enum for the type of piece
enum PieceType { MAN, KING }

// A piece on the board, owned by a player with a certain type
record Piece(Player owner, PieceType type) {}

// A square on the 8x8 board, identified by row and column
record Square(int row, int col) {
  @Override
  public @NonNull String toString() {
    return "" + (char)('a' + col) + (row + 1);
  }
}

// Represents an error during move parsing or validation
record GameError(String description) {}

// The command to make a move from one square to another
record MoveCommand(Square from, Square to) {}

// The outcome of a move attempt
enum MoveOutcome { SUCCESS, INVALID_MOVE, CAPTURE_MADE, GAME_WON }
record MoveResult(MoveOutcome outcome, String message) {}

</code></pre>
<p>We can define a <code>GameState</code> record:</p>
<pre><code class="language-java">// The complete, immutable state of the game at any point in time
public record GameState(Map&lt;Square, Piece&gt; board, Player currentPlayer, String message, boolean isGameOver) {

  public static GameState initial() {
    Map&lt;Square, Piece&gt; startingBoard = new HashMap&lt;&gt;();
    // Place BLACK pieces
    for (int r = 0; r &lt; 3; r++) {
      for (int c = (r % 2 != 0) ? 0 : 1; c &lt; 8; c += 2) {
        startingBoard.put(new Square(r, c), new Piece(Player.BLACK, PieceType.MAN));
      }
    }
    // Place RED pieces
    for (int r = 5; r &lt; 8; r++) {
      for (int c = (r % 2 != 0) ? 0 : 1; c &lt; 8; c += 2) {
        startingBoard.put(new Square(r, c), new Piece(Player.RED, PieceType.MAN));
      }
    }
    return new GameState(Collections.unmodifiableMap(startingBoard), Player.RED, "Game started. RED's turn.", false);
  }

   GameState withBoard(Map&lt;Square, Piece&gt; newBoard) {
    return new GameState(Collections.unmodifiableMap(newBoard), this.currentPlayer, this.message, this.isGameOver);
  }

   GameState withCurrentPlayer(Player nextPlayer) {
    return new GameState(this.board, nextPlayer, this.message, this.isGameOver);
  }

   GameState withMessage(String newMessage) {
    return new GameState(this.board, this.currentPlayer, newMessage, this.isGameOver);
  }

  GameState withGameOver() {
    return new GameState(this.board, this.currentPlayer, this.message, true);
  }

   GameState togglePlayer() {
    Player next = (this.currentPlayer == Player.RED) ? Player.BLACK : Player.RED;
    return withCurrentPlayer(next).withMessage(next + "'s turn.");
  }
}

</code></pre>
<p>We'll use the <code>State&lt;S, A&gt;</code> monad from <code>higher-kinded-j</code> to manage this <code>GameState</code>. A <code>State&lt;GameState, A&gt;</code> represents a computation that takes an initial <code>GameState</code> and produces a result <code>A</code> along with a new, updated <code>GameState</code>. Explore the <a href="hkts/../monads/state_monad.html">State Monad documentation</a> for more.</p>
<h3 id="step-3-handling-user-input-with-io-and-either"><a class="header" href="#step-3-handling-user-input-with-io-and-either">Step 3: Handling User Input with <code>IO</code> and <code>Either</code></a></h3>
<p>This class handles reading user input from the console. The <code>readMoveCommand</code> method returns an <code>IO&lt;Either&lt;GameError, MoveCommand&gt;&gt;</code>. This type signature is very descriptive: it tells us the action is an <code>IO</code> side effect, and its result will be either a <code>GameError</code> or a valid <code>MoveCommand</code>.</p>
<pre><code class="language-java">class InputHandler {
  private static final Scanner scanner = new Scanner(System.in);

   static Kind&lt;IOKind.Witness, Either&lt;GameError, MoveCommand&gt;&gt; readMoveCommand() {
    return IOKindHelper.IO_OP.delay(() -&gt; {
      System.out.print("Enter move for " + " (e.g., 'a3 b4') or 'quit': ");
      String line = scanner.nextLine();

      if ("quit".equalsIgnoreCase(line.trim())) {
        return Either.left(new GameError("Player quit the game."));
      }

      String[] parts = line.trim().split("\\s+");
      if (parts.length != 2) {
        return Either.left(new GameError("Invalid input. Use 'from to' format (e.g., 'c3 d4')."));
      }
      try {
        Square from = parseSquare(parts[0]);
        Square to = parseSquare(parts[1]);
        return Either.right(new MoveCommand(from, to));
      } catch (IllegalArgumentException e) {
        return Either.left(new GameError(e.getMessage()));
      }
    });
  }

  private static Square parseSquare(String s) throws IllegalArgumentException {
    if (s == null || s.length() != 2) throw new IllegalArgumentException("Invalid square format: " + s);
    char colChar = s.charAt(0);
    char rowChar = s.charAt(1);
    if (colChar &lt; 'a' || colChar &gt; 'h' || rowChar &lt; '1' || rowChar &gt; '8') {
      throw new IllegalArgumentException("Square out of bounds (a1-h8): " + s);
    }
    int col = colChar - 'a';
    int row = rowChar - '1';
    return new Square(row, col);
  }
}

</code></pre>
<p>Learn more about the <a href="hkts/../monads/io_monad.html">IO Monad</a> and <a href="hkts/../monads/either_monad.html">Either Monad</a>.</p>
<hr />
<h3 id="step-4-game-logic-as-state-transitions"><a class="header" href="#step-4-game-logic-as-state-transitions">Step 4: Game Logic as State Transitions</a></h3>
<p>This is the heart of our application, containing the complete rules of draughts. The <code>applyMove</code> method takes a <code>MoveCommand</code> and returns a <code>State</code> computation. This computation, when run, will validate the move against the current <code>GameState</code>, and if valid, produce a <code>MoveResult</code> and the new <code>GameState</code>. <em>This entire class has no side effects.</em></p>
<pre><code class="language-java">public class GameLogicSimple {

  static Kind&lt;StateKind.Witness&lt;GameState&gt;, MoveResult&gt; applyMove(MoveCommand command) {
    return StateKindHelper.STATE.widen(
        State.of(
            currentState -&gt; {
              // Unpack command for easier access
              Square from = command.from();
              Square to = command.to();
              Piece piece = currentState.board().get(from);
              String invalidMsg; // To hold error messages

              // Validate the move based on currentState and command
              //    - Is it the current player's piece?
              //    - Is the move diagonal?
              //    - Is the destination square empty or an opponent's piece for a jump?

              if (piece == null) {
                invalidMsg = "No piece at " + from;
                return new StateTuple&lt;&gt;(
                    new MoveResult(MoveOutcome.INVALID_MOVE, invalidMsg),
                    currentState.withMessage(invalidMsg));
              }
              if (piece.owner() != currentState.currentPlayer()) {
                invalidMsg = "Not your piece.";
                return new StateTuple&lt;&gt;(
                    new MoveResult(MoveOutcome.INVALID_MOVE, invalidMsg),
                    currentState.withMessage(invalidMsg));
              }
              if (currentState.board().containsKey(to)) {
                invalidMsg = "Destination square " + to + " is occupied.";
                return new StateTuple&lt;&gt;(
                    new MoveResult(MoveOutcome.INVALID_MOVE, invalidMsg),
                    currentState.withMessage(invalidMsg));
              }

              int rowDiff = to.row() - from.row();
              int colDiff = to.col() - from.col();

              // Simple move or jump?
              if (Math.abs(rowDiff) == 1 &amp;&amp; Math.abs(colDiff) == 1) { // Simple move
                if (piece.type() == PieceType.MAN) {
                  if ((piece.owner() == Player.RED &amp;&amp; rowDiff &gt; 0)
                      || (piece.owner() == Player.BLACK &amp;&amp; rowDiff &lt; 0)) {
                    invalidMsg = "Men can only move forward.";
                    return new StateTuple&lt;&gt;(
                        new MoveResult(MoveOutcome.INVALID_MOVE, invalidMsg),
                        currentState.withMessage(invalidMsg));
                  }
                }
                return performMove(currentState, command, piece);
              } else if (Math.abs(rowDiff) == 2 &amp;&amp; Math.abs(colDiff) == 2) { // Jump move
                Square jumpedSquare =
                    new Square(from.row() + rowDiff / 2, from.col() + colDiff / 2);
                Piece jumpedPiece = currentState.board().get(jumpedSquare);

                if (jumpedPiece == null || jumpedPiece.owner() == currentState.currentPlayer()) {
                  invalidMsg = "Invalid jump. Must jump over an opponent's piece.";
                  return new StateTuple&lt;&gt;(
                      new MoveResult(MoveOutcome.INVALID_MOVE, invalidMsg),
                      currentState.withMessage(invalidMsg));
                }

                return performJump(currentState, command, piece, jumpedSquare);
              } else {
                invalidMsg = "Move must be diagonal by 1 or 2 squares.";
                return new StateTuple&lt;&gt;(
                    new MoveResult(MoveOutcome.INVALID_MOVE, invalidMsg),
                    currentState.withMessage(invalidMsg));
              }
            }));
  }

  private static StateTuple&lt;GameState, MoveResult&gt; performMove(
      GameState state, MoveCommand command, Piece piece) {
    Map&lt;Square, Piece&gt; newBoard = new HashMap&lt;&gt;(state.board());
    newBoard.remove(command.from());
    newBoard.put(command.to(), piece);

    GameState movedState = state.withBoard(newBoard);
    GameState finalState = checkAndKingPiece(movedState, command.to());

    return new StateTuple&lt;&gt;(
        new MoveResult(MoveOutcome.SUCCESS, "Move successful."), finalState.togglePlayer());
  }

  private static StateTuple&lt;GameState, MoveResult&gt; performJump(
      GameState state, MoveCommand command, Piece piece, Square jumpedSquare) {
    Map&lt;Square, Piece&gt; newBoard = new HashMap&lt;&gt;(state.board());
    newBoard.remove(command.from());
    newBoard.remove(jumpedSquare);
    newBoard.put(command.to(), piece);

    GameState jumpedState = state.withBoard(newBoard);
    GameState finalState = checkAndKingPiece(jumpedState, command.to());

    // Check for win condition
    boolean blackWins =
        finalState.board().values().stream().noneMatch(p -&gt; p.owner() == Player.RED);
    boolean redWins =
        finalState.board().values().stream().noneMatch(p -&gt; p.owner() == Player.BLACK);

    if (blackWins || redWins) {
      String winner = blackWins ? "BLACK" : "RED";
      return new StateTuple&lt;&gt;(
          new MoveResult(MoveOutcome.GAME_WON, winner + " wins!"),
          finalState.withGameOver().withMessage(winner + " has captured all pieces!"));
    }

    return new StateTuple&lt;&gt;(
        new MoveResult(MoveOutcome.CAPTURE_MADE, "Capture successful."), finalState.togglePlayer());
  }

  private static GameState checkAndKingPiece(GameState state, Square to) {
    Piece piece = state.board().get(to);
    if (piece != null &amp;&amp; piece.type() == PieceType.MAN) {
      // A RED piece is kinged on row index 0 (the "1st" row).
      // A BLACK piece is kinged on row index 7 (the "8th" row).
      if ((piece.owner() == Player.RED &amp;&amp; to.row() == 0)
          || (piece.owner() == Player.BLACK &amp;&amp; to.row() == 7)) {
        Map&lt;Square, Piece&gt; newBoard = new HashMap&lt;&gt;(state.board());
        newBoard.put(to, new Piece(piece.owner(), PieceType.KING));
        return state
            .withBoard(newBoard)
            .withMessage(piece.owner() + "'s piece at " + to + " has been kinged!");
      }
    }
    return state;
  }
}
</code></pre>
<p>This uses <code>State.of</code> to create a stateful computation. <code>State.get()</code>, <code>State.set()</code>, and <code>State.modify()</code> are other invaluable tools from the State monad.</p>
<hr />
<h3 id="step-5-composing-with-flatmap---the-monadic-power"><a class="header" href="#step-5-composing-with-flatmap---the-monadic-power">Step 5: Composing with <code>flatMap</code> - The Monadic Power</a></h3>
<p>Now, we combine these pieces. The main loop needs to:</p>
<ol>
<li>Display the board (<code>IO</code>).</li>
<li>Read user input (<code>IO</code>).</li>
<li>If the input is valid, apply it to the game logic (<code>State</code>).</li>
<li>Loop with the new game state.</li>
</ol>
<p>This sequence of operations is a good use case for a <code>For</code> comprehension to improve on nested <code>flatMap</code> calls.</p>
<p>Here's how we compose these pieces together in the main game loop:</p>
<pre><code class="language-java">
public class Draughts {

  private static final IOMonad ioMonad = IOMonad.INSTANCE;
  
  // Processes a single turn of the game
  private static Kind&lt;IOKind.Witness, GameState&gt; processTurn(GameState currentGameState) {
  
    // 1. Use 'For' to clearly sequence the display and read actions.
    var sequence = For.from(ioMonad, BoardDisplay.displayBoard(currentGameState))
        .from(ignored -&gt; InputHandler.readMoveCommand())
        .yield((ignored, eitherResult) -&gt; eitherResult); // Yield the result of the read action

    // 2. The result of the 'For' is an IO&lt;Either&lt;...&gt;&gt;.
    //    Now, flatMap that single result to handle the branching.
    return ioMonad.flatMap(
        eitherResult -&gt;
            eitherResult.fold(
                error -&gt; { // Left case: Input error
                  return IOKindHelper.IO_OP.delay(
                      () -&gt; {
                        System.out.println("Error: " + error.description());
                        return currentGameState;
                      });
                },
                moveCommand -&gt; { // Right case: Valid input
                  var stateComputation = GameLogic.applyMove(moveCommand);
                  var resultTuple = StateKindHelper.STATE.runState(stateComputation, currentGameState);
                  return ioMonad.of(resultTuple.state());
                }),
        sequence);
  }

  
  // other methods....
}

</code></pre>
<p>The <code>For</code> comprehension flattens the <code>display -&gt; read</code> sequence, making the primary workflow more declarative and easier to read than nested callbacks.</p>
<p>The <a href="hkts/order-walkthrough.html">Order Processing Example</a> in the <code>higher-kinded-j</code> docs shows a more complex scenario using <code>CompletableFuture</code> and <code>EitherT</code>, which is a great reference for getting started with monad transformers.</p>
<hr />
<h3 id="step-6-the-game-loop"><a class="header" href="#step-6-the-game-loop">Step 6: The Game Loop</a></h3>
<pre><code class="language-java">
public class Draughts {

  private static final IOMonad ioMonad = IOMonad.INSTANCE;

  // The main game loop as a single, recursive IO computation
  private static Kind&lt;IOKind.Witness, Unit&gt; gameLoop(GameState gameState) {
    if (gameState.isGameOver()) {
      // Base case: game is over, just display the final board and message.
      return BoardDisplay.displayBoard(gameState);
    }

    // Recursive step: process one turn and then loop with the new state
    return ioMonad.flatMap(Draughts::gameLoop, processTurn(gameState));
  }

  // processTurn as before....

  public static void main(String[] args) {
    // Get the initial state
    GameState initialState = GameState.initial();
    // Create the full game IO program
    Kind&lt;IOKind.Witness, Unit&gt; fullGame = gameLoop(initialState);
    // Execute the program. This is the only place where side effects are actually run.
    IOKindHelper.IO_OP.unsafeRunSync(fullGame);
    System.out.println("Thank you for playing!");
  }
}

</code></pre>
<p>Key methods like <code>IOKindHelper.IO_OP.unsafeRunSync()</code> and <code>StateKindHelper.STATE.runState()</code> are used to execute the monadic computations at the "edge" of the application.</p>
<h3 id="step-7-displaying-the-board"><a class="header" href="#step-7-displaying-the-board">Step 7: Displaying the Board</a></h3>
<p>A simple text representation will do the trick.
This class is responsible for rendering the GameState to the console. Notice how the displayBoard method doesn't perform the printing directly; it returns an <code>IO&lt;Unit&gt;</code> which is a description of the printing action. This keeps the method pure.</p>
<pre><code class="language-java">
public class BoardDisplay {

  public static Kind&lt;IOKind.Witness, Unit&gt; displayBoard(GameState gameState) {
    return IOKindHelper.IO_OP.delay(
        () -&gt; {
          System.out.println("\n  a b c d e f g h");
          System.out.println(" +-----------------+");
          for (int r = 7; r &gt;= 0; r--) { // Print from row 8 down to 1
            System.out.print((r + 1) + "| ");
            for (int c = 0; c &lt; 8; c++) {
              Piece p = gameState.board().get(new Square(r, c));
              if (p == null) {
                System.out.print(". ");
              } else {
                char pieceChar = (p.owner() == Player.RED) ? 'r' : 'b';
                if (p.type() == PieceType.KING) pieceChar = Character.toUpperCase(pieceChar);
                System.out.print(pieceChar + " ");
              }
            }
            System.out.println("|" + (r + 1));
          }
          System.out.println(" +-----------------+");
          System.out.println("  a b c d e f g h");
          System.out.println("\n" + gameState.message());
          if (!gameState.isGameOver()) {
            System.out.println("Current Player: " + gameState.currentPlayer());
          }
          return Unit.INSTANCE;
        });
  }
}

</code></pre>
<h3 id="playing-the-game"><a class="header" href="#playing-the-game">Playing the game</a></h3>
<p><img src="hkts/../images/draughts_game.png" alt="draughts_game.png" /></p>
<p>In the game we can see the black has "kinged" a piece by reaching <code>e8</code>.</p>
<h3 id="step-8-refactoring-for-multiple-captures"><a class="header" href="#step-8-refactoring-for-multiple-captures">Step 8: Refactoring for Multiple Captures</a></h3>
<p>A key rule in draughts is that if a capture is available, it must be taken, and if a capture leads to another possible capture for the same piece, that jump must also be taken.</p>
<p>The beauty of our functional approach is that we only need to modify the core rules in <code>GameLogic.java</code>. <code>The Draughts.java</code> game loop, the IO handlers, and the data models don't need to change at all.</p>
<p>The core idea is to modify the <code>performJump</code> method. After a jump is completed, we will check if the piece that just moved can make another jump from its new position.</p>
<p>We do this by adding a helper <code>canPieceJump</code> and modify <code>performJump</code> to check for subsequent jumps.</p>
<p>If another jump is possible, the player's turn does not end., we will update the board state but not switch the current player, forcing them to make another capture.
If another jump is not possible, we will switch the player as normal.</p>
<pre><code class="language-java">
/** Check if a piece at a given square has any valid jumps. */
  private static boolean canPieceJump(GameState state, Square from) {
    Piece piece = state.board().get(from);
    if (piece == null) return false;

    int[] directions = {-2, 2};
    for (int rowOffset : directions) {
      for (int colOffset : directions) {
        if (piece.type() == PieceType.MAN) {
          if ((piece.owner() == Player.RED &amp;&amp; rowOffset &gt; 0)
              || (piece.owner() == Player.BLACK &amp;&amp; rowOffset &lt; 0)) {
            continue; // Invalid forward direction for man
          }
        }

        Square to = new Square(from.row() + rowOffset, from.col() + colOffset);
        if (to.row() &lt; 0
            || to.row() &gt; 7
            || to.col() &lt; 0
            || to.col() &gt; 7
            || state.board().containsKey(to)) {
          continue; // Off board or destination occupied
        }

        Square jumpedSquare = new Square(from.row() + rowOffset / 2, from.col() + colOffset / 2);
        Piece jumpedPiece = state.board().get(jumpedSquare);
        if (jumpedPiece != null &amp;&amp; jumpedPiece.owner() != piece.owner()) {
          return true; // Found a valid jump
        }
      }
    }
    return false;
  }

  /** Now it checks for further jumps after a capture. */
  private static StateTuple&lt;GameState, MoveResult&gt; performJump(
      GameState state, MoveCommand command, Piece piece, Square jumpedSquare) {
    // Perform the jump and update board
    Map&lt;Square, Piece&gt; newBoard = new HashMap&lt;&gt;(state.board());
    newBoard.remove(command.from());
    newBoard.remove(jumpedSquare);
    newBoard.put(command.to(), piece);
    GameState jumpedState = state.withBoard(newBoard);

    // Check for kinging after the jump
    GameState stateAfterKinging = checkAndKingPiece(jumpedState, command.to());

    // Check for win condition after the capture
    boolean blackWins =
        !stateAfterKinging.board().values().stream().anyMatch(p -&gt; p.owner() == Player.RED);
    boolean redWins =
        !stateAfterKinging.board().values().stream().anyMatch(p -&gt; p.owner() == Player.BLACK);
    if (blackWins || redWins) {
      String winner = blackWins ? "BLACK" : "RED";
      return new StateTuple&lt;&gt;(
          new MoveResult(MoveOutcome.GAME_WON, winner + " wins!"),
          stateAfterKinging.withGameOver().withMessage(winner + " has captured all pieces!"));
    }

    // Check if the same piece can make another jump
    boolean anotherJumpPossible = canPieceJump(stateAfterKinging, command.to());

    if (anotherJumpPossible) {
      // If another jump exists, DO NOT toggle the player.
      // Update the message to prompt for the next jump.
      String msg = "Capture successful. You must jump again with the same piece.";
      return new StateTuple&lt;&gt;(
          new MoveResult(MoveOutcome.CAPTURE_MADE, msg), stateAfterKinging.withMessage(msg));
    } else {
      // No more jumps, so end the turn and toggle the player.
      return new StateTuple&lt;&gt;(
          new MoveResult(MoveOutcome.CAPTURE_MADE, "Capture successful."),
          stateAfterKinging.togglePlayer());
    }
  }

</code></pre>
<h3 id="why-this-functional-approach-is-better"><a class="header" href="#why-this-functional-approach-is-better">Why This Functional Approach is Better</a></h3>
<p>Having seen the complete code, let's reflect on the benefits:</p>
<ul>
<li><strong>Testability</strong>: The <code>GameLogic</code> class is completely pure, that is to say it has no side effects and doesn't depend on <code>System.in</code> or <code>System.out</code>. You can test the entire rules engine simply by providing a <code>GameState</code> and a <code>MoveCommand</code>, then asserting on the resulting <code>GameState</code> and <code>MoveResult</code>. This is significantly easier than testing code that's tangled with console I/O.</li>
<li><strong>Composability</strong>: The <code>gameLoop</code> in <code>Draughts.java</code> is a beautiful example of composition. It clearly and declaratively lays out the sequence of events for a game turn: <code>display -&gt; read -&gt; process</code>. The <code>flatMap</code> calls hide all the messy details of passing state and results from one step to the next.</li>
<li><strong>Reasoning</strong>: The type signatures tell a story. <code>IO&lt;Either&lt;GameError, MoveCommand&gt;&gt;</code> is far more descriptive than a method that returns a <code>MoveCommand</code> but might throw an exception or return <code>null</code>. It explicitly forces the caller to handle both the success and error cases.</li>
<li><strong>Maintainability</strong>: If you want to change from a command-line interface to a graphical one, you only need to replace <code>BoardDisplay</code> and <code>InputHandler</code>. The entire core <code>GameLogic</code> remains untouched because it's completely decoupled from the presentation layer.</li>
</ul>
<p>This tutorial has only scratched the surface. You could extend this by exploring other constructs from the library, like using <code>Validated</code> to accumulate multiple validation errors or using the <code>Reader</code> monad to inject different sets of game rules.</p>
<p>Java may not have native HKTs, but with <a href="https://higher-kinded-j.github.io/home.html"><strong>Higher-Kinded-J</strong></a>, you can absolutely utilise these powerful and elegant functional patterns to write better, more robust applications.</p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="an-introduction-to-optics"><a class="header" href="#an-introduction-to-optics">An Introduction to Optics</a></h1>
<p><img src="optics/../images/optics.jpg" alt="Diagram showing optics as composable lenses focusing on nested data structures" /></p>
<p>As Java developers, we appreciate the safety and predictability of immutable objects, especially with the introduction of records. However, this safety comes at a cost: updating nested immutable data can be a verbose and error-prone nightmare.</p>
<p>Consider a simple nested record structure:</p>
<pre><code class="language-java">record Street(String name, int number) {}
record Address(Street street, String city) {}
record User(String name, Address address) {}
</code></pre>
<p>How do you update the user's street name? In standard Java, you're forced into a "copy-and-update" cascade:</p>
<pre><code class="language-java">// What most Java developers actually write
public User updateStreetName(User user, String newStreetName) {
    var address = user.address();
    var street = address.street();
    var newStreet = new Street(newStreetName, street.number());
    var newAddress = new Address(newStreet, address.city());
    return new User(user.name(), newAddress);
}
</code></pre>
<p>This is tedious, hard to read, and gets exponentially worse with deeper nesting. What if there was a way to "zoom in" on the data you want to change, update it, and get a new copy of the top-level object back, all in one clean operation?</p>
<p>This is the problem that <strong>Optics</strong> solve.</p>
<h2 id="what-are-optics"><a class="header" href="#what-are-optics">What Are Optics?</a></h2>
<p>At their core, optics are simply <strong>composable, functional getters and setters</strong> for immutable data structures.</p>
<p>Think of an optic as a <em>zoom lens</em> for your data. It's a first-class object that represents a path from a whole structure (like <code>User</code>) to a specific part (like the street <code>name</code>). Because it's an object, you can pass it around, compose it with other optics, and use it to perform functional updates.</p>
<h2 id="think-of-optics-like"><a class="header" href="#think-of-optics-like">Think of Optics Like...</a></h2>
<ul>
<li><strong>Lens</strong>: A magnifying glass that focuses on one specific part üîé</li>
<li><strong>Prism</strong>: A tool that splits light, but only works with certain types of light üî¨</li>
<li><strong>Iso</strong>: A universal translator between equivalent languages üîÑ</li>
<li><strong>Traversal</strong>: A spotlight that can illuminate many targets at once üó∫Ô∏è</li>
<li><strong>Fold</strong>: A read-only query tool that extracts and aggregates data üìä</li>
</ul>
<p>Every optic provides two basic capabilities:</p>
<ol>
<li><strong><code>get</code></strong>: Focus on a structure <code>S</code> and retrieve a part <code>A</code>.</li>
<li><strong><code>set</code></strong>: Focus on a structure <code>S</code>, provide a new part <code>A</code>, and receive a new <code>S</code> with the part updated. This is always an immutable operation ‚Äî&gt; a new copy of <code>S</code> is returned.</li>
</ol>
<p>The real power comes from their <strong>composability</strong>. You can chain optics together to peer deeply into nested structures and perform targeted updates with ease.</p>
<h2 id="the-optics-family-in-higher-kinded-j"><a class="header" href="#the-optics-family-in-higher-kinded-j">The Optics Family in Higher-Kinded-J</a></h2>
<p>The <code>higher-kinded-j</code> library provides the foundation for a rich optics library, primarily focused on three main types. Each is designed to solve a specific kind of data access problem.</p>
<h3 id="1-lens-for-has-a-relationships-"><a class="header" href="#1-lens-for-has-a-relationships-">1. Lens: For "Has-A" Relationships üîé</a></h3>
<p>A <strong>Lens</strong> is the most common optic. It focuses on a single, required piece of data within a larger "product type" (a <code>record</code> or class with fields). It's for data that is guaranteed to exist.</p>
<ul>
<li>
<p><strong>Problem it solves</strong>: Getting and setting a field within an object, especially a deeply nested one.</p>
</li>
<li>
<p><strong>Generated Code</strong>: Annotating a record with <code>@GenerateLenses</code> produces a companion class (e.g., <code>UserLenses</code>) that contains:</p>
<ol>
<li>A <strong>lens</strong> for each field (e.g., <code>UserLenses.address()</code>).</li>
<li>Convenient <strong><code>with*</code> helper methods</strong> for easy updates (e.g., <code>UserLenses.withAddress(...)</code>).</li>
</ol>
</li>
<li>
<p><strong>Example (Deep Update with Lenses)</strong>:</p>
<ul>
<li>To solve our initial problem of updating the user's street name, we compose lenses:</li>
</ul>
</li>
</ul>
<pre><code class="language-java">    // Compose lenses to create a direct path to the nested data
    var userToStreetName = UserLenses.address()
        .andThen(AddressLenses.street())
        .andThen(StreetLenses.name());
  
    // Perform the deep update in a single, readable line
    User updatedUser = userToStreetName.set("New Street", userLogin);
</code></pre>
<ul>
<li>
<p><strong>Example (Shallow Update with <code>with*</code> Helpers)</strong>:</p>
<ul>
<li>For simple, top-level updates, the <code>with*</code> methods are more direct and discoverable.</li>
</ul>
</li>
</ul>
<pre><code class="language-java">// Before: Using the lens directly
User userWithNewName = UserLenses.name().set("Bob", userLogin);

// After: Using the generated helper method
User userWithNewName = UserLenses.withName(userLogin, "Bob");
</code></pre>
<h3 id="2-iso-for-is-equivalent-to-relationships-"><a class="header" href="#2-iso-for-is-equivalent-to-relationships-">2. Iso: For "Is-Equivalent-To" Relationships üîÑ</a></h3>
<p>An <strong>Iso</strong> (Isomorphism) is a special, reversible optic. It represents a lossless, two-way conversion between two types that hold the exact same information. Think of it as a type-safe, composable adapter.</p>
<ul>
<li>
<p><strong>Problem it solves</strong>: Swapping between different representations of the same data, such as a wrapper class and its raw value, or between two structurally different but informationally equivalent records.</p>
</li>
<li>
<p><strong>Example</strong>: Suppose you have a <code>Point</code> record and a <code>Tuple2&lt;Integer, Integer&gt;</code>, which are structurally different but hold the same data.</p>
<pre><code class="language-java">public record Point(int x, int y) {}
</code></pre>
<p>You can define an <code>Iso</code> to convert between them:</p>
<pre><code class="language-java">@GenerateIsos
public static Iso&lt;Point, Tuple2&lt;Integer, Integer&gt;&gt; pointToTuple() {
  return Iso.of(
      point -&gt; Tuple.of(point.x(), point.y()), // get
      tuple -&gt; new Point(tuple._1(), tuple._2())  // reverseGet
  );
}
</code></pre>
<p>This <code>Iso</code> can now be composed with other optics to, for example, create a <code>Lens</code> that goes from a <code>Point</code> directly to its first element inside a <code>Tuple</code> representation.</p>
</li>
</ul>
<h3 id="3-prism-for-is-a-relationships-"><a class="header" href="#3-prism-for-is-a-relationships-">3. Prism: For "Is-A" Relationships üî¨</a></h3>
<p>A <strong>Prism</strong> is like a Lens, but for "sum types" (<code>sealed interface</code> or <code>enum</code>). It focuses on a single, <em>possible case</em> of a type. A Prism's <code>get</code> operation can fail (it returns an <code>Optional</code>), because the data might not be the case you're looking for. Think of it as a type-safe, functional <code>instanceof</code> and cast.</p>
<ul>
<li><strong>Problem it solves</strong>: Safely operating on one variant of a sealed interface.</li>
<li><strong>Example</strong>: Instead of using an <code>if-instanceof</code> chain to handle a specific <code>DomainError</code>:</li>
</ul>
<pre><code class="language-java">// Using a generated Prism for a sealed interface
DomainErrorPrisms.shippingError()
   .getOptional(error) // Safely gets a ShippingError if it matches
   .filter(ShippingError::isRecoverable)
   .ifPresent(this::handleRecovery); // Perform action only if it's the right type
</code></pre>
<h3 id="4-traversal-for-has-many-relationships-"><a class="header" href="#4-traversal-for-has-many-relationships-">4. Traversal: For "Has-Many" Relationships üó∫Ô∏è</a></h3>
<p>A <strong>Traversal</strong> is an optic that can focus on multiple targets at once‚Äîtypically all the items within a collection inside a larger structure.</p>
<ul>
<li>
<p><strong>Problem it solves</strong>: Applying an operation to every element in a <code>List</code>, <code>Set</code>, or other collection that is a field within an object.</p>
</li>
<li>
<p><strong>Example</strong>: To validate a list of promo codes in an order with <code>Validated</code>:</p>
<pre><code class="language-java">@GenerateTraversals
public record OrderData(..., List&lt;String&gt; promoCodes) {}
var codesTraversal = OrderDataTraversals.promoCodes();
// returns Validated&lt;Error, Code&gt;
var validationFunction = (String code) -&gt; validate(code); 

// Use the traversal to apply the function to every code.
// The Applicative for Validated handles the error accumulation automatically.
Validated&lt;Error, OrderData&gt; result = codesTraversal.modifyF(
    validationFunction, orderData, validatedApplicative
);
</code></pre>
</li>
</ul>
<h3 id="5-fold-for-has-many-queries-"><a class="header" href="#5-fold-for-has-many-queries-">5. Fold: For "Has-Many" Queries üìä</a></h3>
<p>A <strong>Fold</strong> is a read-only optic designed specifically for querying and extracting data without modification. Think of it as a <code>Traversal</code> that has given up the ability to modify in exchange for a clearer expression of intent and additional query-focused operations.</p>
<ul>
<li>
<p><strong>Problem it solves</strong>: Extracting information from complex data structures‚Äîfinding items, checking conditions, aggregating values, or collecting data without modifying the original structure.</p>
</li>
<li>
<p><strong>Generated Code</strong>: Annotating a record with <code>@GenerateFolds</code> produces a companion class (e.g., <code>OrderFolds</code>) with a <code>Fold</code> for each field.</p>
</li>
<li>
<p><strong>Example (Querying Product Catalogue)</strong>:</p>
<ul>
<li>To find all products in an order that cost more than ¬£50:</li>
</ul>
</li>
</ul>
<pre><code class="language-java">    // Get the generated fold
    Fold&lt;Order, Product&gt; orderToProducts = OrderFolds.items();

    // Find all matching products
    List&lt;Product&gt; expensiveItems = orderToProducts.getAll(order).stream()
        .filter(product -&gt; product.price() &gt; 50.00)
        .collect(toList());

    // Or check if any exist
    boolean hasExpensiveItems = orderToProducts.exists(
        product -&gt; product.price() &gt; 50.00,
        order
    );
</code></pre>
<ul>
<li><strong>Key Operations</strong>:
<ul>
<li><code>getAll(source)</code>: Extract all focused values into a <code>List</code></li>
<li><code>preview(source)</code>: Get the first value as an <code>Optional</code></li>
<li><code>find(predicate, source)</code>: Find first matching value</li>
<li><code>exists(predicate, source)</code>: Check if any value matches</li>
<li><code>all(predicate, source)</code>: Check if all values match</li>
<li><code>isEmpty(source)</code>: Check if there are zero focused values</li>
<li><code>length(source)</code>: Count the number of focused values</li>
</ul>
</li>
</ul>
<p><strong>Why Fold is Important</strong>: While <code>Traversal</code> can do everything <code>Fold</code> can do, using <code>Fold</code> makes your code's intent crystal clear‚Äî"I'm only reading this data, not modifying it." This is valuable for code reviewers, for preventing accidental mutations, and for expressing domain logic where queries should be separated from commands (<a href="https://martinfowler.com/bliki/CQRS.html">CQRS pattern</a>).</p>
<h2 id="advanced-capabilities-profunctor-adaptations"><a class="header" href="#advanced-capabilities-profunctor-adaptations">Advanced Capabilities: Profunctor Adaptations</a></h2>
<p>One of the most powerful features of <code>higher-kinded-j</code> optics is their <strong>profunctor</strong> nature. Every optic can be adapted to work with different source and target types using three key operations:</p>
<ul>
<li><strong><code>contramap</code></strong>: Adapt an optic to work with a different source type</li>
<li><strong><code>map</code></strong>: Transform the result type of an optic</li>
<li><strong><code>dimap</code></strong>: Adapt both source and target types simultaneously</li>
</ul>
<p>This makes optics incredibly flexible for real-world scenarios like API integration, legacy system support, and working with different data representations. For a detailed exploration of these capabilities, see the <a href="optics/profunctor_optics.html">Profunctor Optics Guide</a>.</p>
<h2 id="how-higher-kinded-j-provides-optics"><a class="header" href="#how-higher-kinded-j-provides-optics">How <code>higher-kinded-j</code> Provides Optics</a></h2>
<p>This brings us to the unique advantages <code>higher-kinded-j</code> offers for optics in Java.</p>
<ol>
<li><strong>An Annotation-Driven Workflow</strong>: Manually writing optics is boilerplate. The <code>higher-kinded-j</code> approach automates this. By simply adding an annotation (<code>@GenerateLenses</code>, <code>@GeneratePrisms</code>, etc.) to your data classes, you get fully-functional, type-safe optics for free. This is a massive productivity boost and eliminates a major barrier to using optics in Java.</li>
<li><strong>Higher-Kinded Types for Effectful Updates</strong>: This is the most powerful feature. Because <code>higher-kinded-j</code> provides an HKT abstraction (<code>Kind&lt;F, A&gt;</code>) and type classes like <code>Functor</code> and <code>Applicative</code>, the optics can perform <em>effectful</em> modifications. The <code>modifyF</code> method is generic over an <code>Applicative</code> effect <code>F</code>. This means you can perform an update within the context of any data type that has an <code>Applicative</code> instance:
<ul>
<li>Want to perform an update that might fail? Use <code>Optional</code> or <code>Either</code> as your <code>F</code>.</li>
<li>Want to perform an asynchronous update? Use <code>CompletableFuture</code> as your <code>F</code>.</li>
<li>Want to accumulate validation errors? Use <code>Validated</code> as your <code>F</code>.</li>
</ul>
</li>
<li><strong>Profunctor Adaptability</strong>: Every optic is fundamentally a profunctor, meaning it can be adapted to work with different data types and structures. This provides incredible flexibility for integrating with external systems, handling legacy data formats, and working with strongly-typed wrappers.</li>
</ol>
<h2 id="common-patterns"><a class="header" href="#common-patterns">Common Patterns</a></h2>
<h3 id="when-to-use-with-helpers-vs-manual-lenses"><a class="header" href="#when-to-use-with-helpers-vs-manual-lenses">When to Use <code>with*</code> Helpers vs Manual Lenses</a></h3>
<ul>
<li><strong>Use <code>with*</code> helpers</strong> for simple, top-level field updates</li>
<li><strong>Use composed lenses</strong> for deep updates or when you need to reuse the path</li>
<li><strong>Use manual lens creation</strong> for computed properties or complex transformations</li>
</ul>
<h3 id="decision-guide-1"><a class="header" href="#decision-guide-1">Decision Guide</a></h3>
<ul>
<li><strong>Need to focus on a required field?</strong> ‚Üí <strong>Lens</strong></li>
<li><strong>Need to work with optional variants?</strong> ‚Üí <strong>Prism</strong></li>
<li><strong>Need to convert between equivalent types?</strong> ‚Üí <strong>Iso</strong></li>
<li><strong>Need to modify collections?</strong> ‚Üí <strong>Traversal</strong></li>
<li><strong>Need to query or extract data without modification?</strong> ‚Üí <strong>Fold</strong></li>
<li><strong>Need to adapt existing optics?</strong> ‚Üí <strong>Profunctor operations</strong></li>
</ul>
<h2 id="common-pitfalls"><a class="header" href="#common-pitfalls">Common Pitfalls</a></h2>
<p><strong>‚ùå Don't do this:</strong></p>
<p>java</p>
<pre><code class="language-java">// Calling get() multiple times is inefficient
var street = employeeToStreet.get(employee);
var newEmployee = employeeToStreet.set(street.toUpperCase(), employee);
</code></pre>
<p><strong>‚úÖ Do this instead:</strong></p>
<p>java</p>
<pre><code class="language-java">// Use modify() for transformations
var newEmployee = employeeToStreet.modify(String::toUpperCase, employee);
</code></pre>
<p>This level of abstraction enables you to write highly reusable and testable business logic that is completely decoupled from the details of state management, asynchrony, or error handling.</p>
<h2 id="making-optics-feel-natural-in-java"><a class="header" href="#making-optics-feel-natural-in-java">Making Optics Feel Natural in Java</a></h2>
<p>While optics are powerful, their functional programming origins can make them feel foreign to Java developers. To bridge this gap, <code>higher-kinded-j</code> provides two complementary approaches for working with optics:</p>
<h3 id="fluent-api-for-optics"><a class="header" href="#fluent-api-for-optics">Fluent API for Optics</a></h3>
<p>The <strong><a href="optics/fluent_api.html">Fluent API</a></strong> provides Java-friendly syntax for optic operations, offering both concise static methods and discoverable fluent builders:</p>
<pre><code class="language-java">// Static method style - concise
int age = OpticOps.get(person, PersonLenses.age());

// Fluent builder style - explicit and discoverable
int age = OpticOps.getting(person).through(PersonLenses.age());
</code></pre>
<p>This makes optics feel natural in Java whilst preserving all their functional power. Learn more in the <a href="optics/fluent_api.html">Fluent API Guide</a>.</p>
<h3 id="free-monad-dsl-for-optics"><a class="header" href="#free-monad-dsl-for-optics">Free Monad DSL for Optics</a></h3>
<p>The <strong><a href="optics/free_monad_dsl.html">Free Monad DSL</a></strong> separates program description from execution, enabling you to:</p>
<ul>
<li>Build optic programs as composable values</li>
<li>Execute programs with different strategies (direct, logging, validation)</li>
<li>Create audit trails for compliance</li>
<li>Validate operations before applying them</li>
</ul>
<pre><code class="language-java">// Build a program
Free&lt;OpticOpKind.Witness, Person&gt; program =
    OpticPrograms.get(person, PersonLenses.age())
        .flatMap(age -&gt;
            OpticPrograms.set(person, PersonLenses.age(), age + 1));

// Execute with different interpreters
Person result = OpticInterpreters.direct().run(program);                     // Production
LoggingOpticInterpreter logger = OpticInterpreters.logging();
logger.run(program);                                                          // Audit trail
ValidationOpticInterpreter.ValidationResult validation = OpticInterpreters.validating().validate(program);  // Dry-run
</code></pre>
<p>This powerful pattern is explored in detail in the <a href="optics/free_monad_dsl.html">Free Monad DSL Guide</a> and <a href="optics/interpreters.html">Optic Interpreters Guide</a>.</p>
<hr />
<p><strong>Next:</strong> <a href="optics/lenses.html">Lenses: Working with Product Types</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="nested-updates-with-lenses-a-practical-guide"><a class="header" href="#nested-updates-with-lenses-a-practical-guide">Nested Updates with Lenses: A Practical Guide</a></h1>
<h2 id="working-with-product-types"><a class="header" href="#working-with-product-types"><em>Working with Product Types</em></a></h2>
<p><img src="optics/../images/lens2.jpg" alt="Visual representation of a lens focusing on a single field within nested immutable data structures" /></p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="optics/lenses.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to safely access and update fields in immutable data structures</li>
<li>Using <code>@GenerateLenses</code> to automatically create type-safe field accessors</li>
<li>Composing lenses to navigate deeply nested records</li>
<li>The difference between <code>get</code>, <code>set</code>, and <code>modify</code> operations</li>
<li>Building reusable, composable data access patterns</li>
<li>When to use lenses vs direct field access</li>
</ul>
</div>
</div>
<div id="admonition-example-code" class="admonition admonish-note" role="note" aria-labelledby="admonition-example-code-title">
<div class="admonition-title">
<div id="admonition-example-code-title">
<p>Example Code</p>
</div>
<a class="admonition-anchor-link" href="optics/lenses.html#admonition-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/LensUsageExample.java">LensesExample</a></p>
</div>
</div>
<p>In the introduction to optics, we saw how updating nested immutable data can be verbose and why optics provide a clean, functional solution. We identified the <code>Lens</code> as the primary tool for working with "has-a" relationships, like a field within a record.</p>
<p>This guide provides a complete, step-by-step walkthrough of how to solve the nested update problem using a composable Lens and its generated helper methods.</p>
<hr />
<h2 id="the-scenario-updating-an-employees-address"><a class="header" href="#the-scenario-updating-an-employees-address">The Scenario: Updating an Employee's Address</a></h2>
<p>Let's use a common business scenario involving a deeply nested data structure. Our goal is to update the <code>street</code> of an <code>Employee</code>'s <code>Company``Address</code>.</p>
<p><strong>The Data Model:</strong></p>
<pre><code class="language-java">public record Address(String street, String city) {}
public record Company(String name, Address address) {}
public record Employee(String name, Company company) {}
</code></pre>
<p>Without optics, changing the street requires manually rebuilding the entire <code>Employee</code> object graph. With optics, we can define a direct path to the <code>street</code> and perform the update in a single, declarative line.</p>
<hr />
<h2 id="a-step-by-step-walkthrough"><a class="header" href="#a-step-by-step-walkthrough">A Step-by-Step Walkthrough</a></h2>
<h3 id="step-1-generating-the-lenses"><a class="header" href="#step-1-generating-the-lenses">Step 1: Generating the Lenses</a></h3>
<p>Manually writing <code>Lens</code> implementations is tedious boilerplate. The <code>hkj-optics</code> library automates this with an annotation processor. To begin, we simply annotate our records with <strong><code>@GenerateLenses</code></strong>.</p>
<p>This process creates a companion class for each record (e.g., <code>EmployeeLenses</code>, <code>CompanyLenses</code>) that contains two key features:</p>
<ol>
<li><strong>Lens Factories</strong>: Static methods that create a <code>Lens</code> for each field (e.g., <code>EmployeeLenses.company()</code>).</li>
<li><strong><code>with*</code> Helpers</strong>: Static convenience methods for easy, shallow updates (e.g., <code>EmployeeLenses.withCompany(...)</code>).</li>
</ol>
<pre><code class="language-java">import org.higherkindedj.optics.annotations.GenerateLenses;

@GenerateLenses
public record Address(String street, String city) {}

@GenerateLenses
public record Company(String name, Address address) {}

@GenerateLenses
public record Employee(String name, Company company) {}
</code></pre>
<h3 id="step-2-composing-a-deep-lens"><a class="header" href="#step-2-composing-a-deep-lens">Step 2: Composing a Deep Lens</a></h3>
<p>With the lenses generated, we can now compose them using the <strong><code>andThen</code></strong> method. We'll chain the individual lenses together to create a single, new <code>Lens</code> that represents the complete path from the top-level object (<code>Employee</code>) to the deeply nested field (<code>street</code>).</p>
<p>The result is a new, powerful, and reusable <code>Lens&lt;Employee, String&gt;</code>.</p>
<pre><code class="language-java">// Get the generated lenses
Lens&lt;Employee, Company&gt; employeeToCompany = EmployeeLenses.company();
Lens&lt;Company, Address&gt; companyToAddress = CompanyLenses.address();
Lens&lt;Address, String&gt; addressToStreet = AddressLenses.street();

// Compose them to create a single, deep lens
Lens&lt;Employee, String&gt; employeeToStreet =
    employeeToCompany
        .andThen(companyToAddress)
        .andThen(addressToStreet);
</code></pre>
<h3 id="step-3-performing-updates-with-the-composed-lens"><a class="header" href="#step-3-performing-updates-with-the-composed-lens">Step 3: Performing Updates with the Composed Lens</a></h3>
<p>With our optics generated, we have two primary ways to perform updates.</p>
<h4 id="a-simple-shallow-updates-with-with-helpers"><a class="header" href="#a-simple-shallow-updates-with-with-helpers">A) Simple, Shallow Updates with <code>with*</code> Helpers</a></h4>
<p>For simple updates to a top-level field, the generated <code>with*</code> methods are the most convenient and readable option.</p>
<pre><code class="language-java">// Create an employee instance
var employee = new Employee("Alice", ...);

// Use the generated helper to create an updated copy
var updatedEmployee = EmployeeLenses.withName(employee, "Bob");
</code></pre>
<p>This is a cleaner, more discoverable alternative to using the lens directly (<code>EmployeeLenses.name().set("Bob", employee)</code>).</p>
<h4 id="b-deep-updates-with-a-composed-lens"><a class="header" href="#b-deep-updates-with-a-composed-lens">B) Deep Updates with a Composed Lens</a></h4>
<p>For deep updates into nested structures, the composed lens is the perfect tool. The <code>Lens</code> interface provides two primary methods for this:</p>
<ul>
<li><code>set(newValue, object)</code>: Replaces the focused value with a new one.</li>
<li><code>modify(function, object)</code>: Applies a function to the focused value to compute the new value.</li>
</ul>
<p>Both methods handle the "copy-and-update" cascade for you, returning a completely new top-level object.</p>
<pre><code class="language-java">// Use the composed lens from Step 2
Employee updatedEmployee = employeeToStreet.set("456 Main St", initialEmployee);
</code></pre>
<hr />
<h2 id="when-to-use-with-helpers-vs-manual-lenses-1"><a class="header" href="#when-to-use-with-helpers-vs-manual-lenses-1">When to Use <code>with*</code> Helpers vs Manual Lenses</a></h2>
<p>Understanding when to use each approach will help you write cleaner, more maintainable code:</p>
<h3 id="use-with-helpers-when"><a class="header" href="#use-with-helpers-when">Use <code>with*</code> Helpers When:</a></h3>
<ul>
<li><strong>Simple, top-level field updates</strong> - Direct field replacement on the immediate object</li>
<li><strong>One-off updates</strong> - You don't need to reuse the update logic</li>
<li><strong>API clarity</strong> - You want the most discoverable, IDE-friendly approach</li>
</ul>
<pre><code class="language-java">// Perfect for simple updates
var promotedEmployee = EmployeeLenses.withName(employee, "Senior " + employee.name());
</code></pre>
<h3 id="use-composed-lenses-when"><a class="header" href="#use-composed-lenses-when">Use Composed Lenses When:</a></h3>
<ul>
<li><strong>Deep updates</strong> - Navigating multiple levels of nesting</li>
<li><strong>Reusable paths</strong> - The same update pattern will be used multiple times</li>
<li><strong>Complex transformations</strong> - Using <code>modify()</code> with functions</li>
<li><strong>Conditional updates</strong> - Part of larger optic compositions</li>
</ul>
<pre><code class="language-java">// Ideal for reusable deep updates
Lens&lt;Employee, String&gt; streetLens = employeeToCompany
    .andThen(companyToAddress)
    .andThen(addressToStreet);

// Can be reused across your application
Employee moved = streetLens.set("New Office Street", employee);
Employee uppercased = streetLens.modify(String::toUpperCase, employee);
</code></pre>
<h3 id="use-manual-lens-creation-when"><a class="header" href="#use-manual-lens-creation-when">Use Manual Lens Creation When:</a></h3>
<ul>
<li><strong>Computed properties</strong> - The lens represents derived data</li>
<li><strong>Complex transformations</strong> - Custom getter/setter logic</li>
<li><strong>Legacy integration</strong> - Working with existing APIs</li>
</ul>
<pre><code class="language-java">// For computed or derived properties
Lens&lt;Employee, String&gt; fullAddressLens = Lens.of(
    emp -&gt; emp.company().address().street() + ", " + emp.company().address().city(),
    (emp, fullAddr) -&gt; {
        String[] parts = fullAddr.split(", ");
        return employeeToCompany.andThen(companyToAddress).set(
            new Address(parts[0], parts[1]), emp);
    }
);
</code></pre>
<hr />
<h2 id="common-pitfalls-1"><a class="header" href="#common-pitfalls-1">Common Pitfalls</a></h2>
<h3 id="-dont-do-this"><a class="header" href="#-dont-do-this">‚ùå Don't Do This:</a></h3>
<pre><code class="language-java">// Inefficient: Calling get() multiple times
var currentStreet = employeeToStreet.get(employee);
var newEmployee = employeeToStreet.set(currentStreet.toUpperCase(), employee);

// Verbose: Rebuilding lenses repeatedly
var street1 = EmployeeLenses.company().andThen(CompanyLenses.address()).andThen(AddressLenses.street()).get(emp1);
var street2 = EmployeeLenses.company().andThen(CompanyLenses.address()).andThen(AddressLenses.street()).get(emp2);

// Mixing approaches unnecessarily
var tempCompany = EmployeeLenses.company().get(employee);
var updatedCompany = CompanyLenses.withName(tempCompany, "New Company");
var finalEmployee = EmployeeLenses.withCompany(employee, updatedCompany);
</code></pre>
<h3 id="-do-this-instead"><a class="header" href="#-do-this-instead">‚úÖ Do This Instead:</a></h3>
<pre><code class="language-java">// Efficient: Use modify() for transformations
var newEmployee = employeeToStreet.modify(String::toUpperCase, employee);

// Reusable: Create the lens once, use many times
var streetLens = EmployeeLenses.company().andThen(CompanyLenses.address()).andThen(AddressLenses.street());
var street1 = streetLens.get(emp1);
var street2 = streetLens.get(emp2);

// Consistent: Use one approach for the entire update
var finalEmployee = EmployeeLenses.company()
    .andThen(CompanyLenses.name())
    .set("New Company", employee);
</code></pre>
<hr />
<h2 id="performance-notes-1"><a class="header" href="#performance-notes-1">Performance Notes</a></h2>
<p>Lenses are optimised for immutable updates:</p>
<ul>
<li><strong>Memory efficient</strong>: Only creates new objects along the path that changes</li>
<li><strong>Reusable</strong>: Composed lenses can be stored and reused across your application</li>
<li><strong>Type-safe</strong>: All operations are checked at compile time</li>
<li><strong>Lazy</strong>: Operations are only performed when needed</li>
</ul>
<p><strong>Best Practice</strong>: For frequently used paths, create the composed lens once and store it as a static field:</p>
<pre><code class="language-java">public class EmployeeOptics {
    public static final Lens&lt;Employee, String&gt; STREET = 
        EmployeeLenses.company()
            .andThen(CompanyLenses.address())
            .andThen(AddressLenses.street());
        
    public static final Lens&lt;Employee, String&gt; COMPANY_NAME = 
        EmployeeLenses.company()
            .andThen(CompanyLenses.name());
}
</code></pre>
<hr />
<h2 id="complete-runnable-example"><a class="header" href="#complete-runnable-example">Complete, Runnable Example</a></h2>
<p>The following standalone example puts all these steps together. You can run it to see the output and the immutability in action.</p>
<pre><code class="language-java">package org.higherkindedj.example.lens;

// Imports for the generated classes would be automatically resolved by your IDE
import org.higherkindedj.example.lens.LensUsageExampleLenses.AddressLenses;
import org.higherkindedj.example.lens.LensUsageExampleLenses.CompanyLenses;
import org.higherkindedj.example.lens.LensUsageExampleLenses.EmployeeLenses;
import org.higherkindedj.optics.Lens;
import org.higherkindedj.optics.annotations.GenerateLenses;

public class LensUsageExample {

    // 1. Define a nested, immutable data model.
    @GenerateLenses
    public record Address(String street, String city) {}

    @GenerateLenses
    public record Company(String name, Address address) {}

    @GenerateLenses
    public record Employee(String name, Company company) {}


    public static void main(String[] args) {
        // 2. Create an initial, nested immutable object.
        var initialAddress = new Address("123 Fake St", "Anytown");
        var initialCompany = new Company("Initech Inc.", initialAddress);
        var initialEmployee = new Employee("Alice", initialCompany);

        System.out.println("Original Employee: " + initialEmployee);
        System.out.println("------------------------------------------");


        // --- SCENARIO 1: Simple update with a `with*` helper ---
        System.out.println("--- Scenario 1: Using `with*` Helper ---");
        var employeeWithNewName = EmployeeLenses.withName(initialEmployee, "Bob");
        System.out.println("After `withName`:    " + employeeWithNewName);
        System.out.println("------------------------------------------");

        // --- SCENARIO 2: Deep update with a composed Lens ---
        System.out.println("--- Scenario 2: Using Composed Lens ---");
        Lens&lt;Employee, String&gt; employeeToStreet =
            EmployeeLenses.company()
                .andThen(CompanyLenses.address())
                .andThen(AddressLenses.street());

        // Use `set` to replace a value
        Employee updatedEmployeeSet = employeeToStreet.set("456 Main St", initialEmployee);
        System.out.println("After deep `set`:       " + updatedEmployeeSet);

        // Use `modify` to apply a function
        Employee updatedEmployeeModify = employeeToStreet.modify(String::toUpperCase, initialEmployee);
        System.out.println("After deep `modify`:    " + updatedEmployeeModify);
        System.out.println("Original is unchanged:  " + initialEmployee);
      
        // --- SCENARIO 3: Demonstrating reusability ---
        System.out.println("--- Scenario 3: Reusing Composed Lens ---");
        var employee2 = new Employee("Charlie", new Company("Tech Corp", new Address("789 Oak Ave", "Tech City")));
      
        // Same lens works on different employee instances
        var bothUpdated = List.of(initialEmployee, employee2)
            .stream()
            .map(emp -&gt; employeeToStreet.modify(street -&gt; "Remote: " + street, emp))
            .toList();
          
        System.out.println("Batch updated: " + bothUpdated);
    }
}
</code></pre>
<p><strong>Expected Output:</strong></p>
<pre><code>Original Employee: Employee[name=Alice, company=Company[name=Initech Inc., address=Address[street=123 Fake St, city=Anytown]]]
------------------------------------------
--- Scenario 1: Using `with*` Helper ---
After `withName`:    Employee[name=Bob, company=Company[name=Initech Inc., address=Address[street=123 Fake St, city=Anytown]]]
------------------------------------------
--- Scenario 2: Using Composed Lens ---
After deep `set`:       Employee[name=Alice, company=Company[name=Initech Inc., address=Address[street=456 Main St, city=Anytown]]]
After deep `modify`:    Employee[name=Alice, company=Company[name=Initech Inc., address=Address[street=123 FAKE ST, city=Anytown]]]
Original is unchanged:  Employee[name=Alice, company=Company[name=Initech Inc., address=Address[street=123 Fake St, city=Anytown]]]
------------------------------------------
--- Scenario 3: Reusing Composed Lens ---
Batch updated: [Employee[name=Alice, company=Company[name=Initech Inc., address=Address[street=Remote: 123 Fake St, city=Anytown]]], Employee[name=Charlie, company=Company[name=Tech Corp, address=Address[street=Remote: 789 Oak Ave, city=Tech City]]]]
</code></pre>
<p>As you can see, the generated optics provide a clean, declarative, and type-safe API for working with immutable data, whether your updates are simple and shallow or complex and deep.</p>
<hr />
<h2 id="beyond-the-basics-effectful-updates-with-modifyf"><a class="header" href="#beyond-the-basics-effectful-updates-with-modifyf">Beyond the Basics: Effectful Updates with <code>modifyF</code></a></h2>
<p>While <code>set</code> and <code>modify</code> are for simple, pure updates, the <code>Lens</code> interface also supports effectful operations through <code>modifyF</code>. This method allows you to perform updates within a context like an <code>Optional</code>, <code>Validated</code>, or <code>CompletableFuture</code>.</p>
<p>This means you can use the same <code>employeeToStreet</code> lens to perform a street name update that involves failable validation or an asynchronous API call, making your business logic incredibly reusable and robust.</p>
<pre><code class="language-java">// Example: Street validation that might fail
Function&lt;String, Kind&lt;ValidatedKind.Witness&lt;String&gt;, String&gt;&gt; validateStreet = 
    street -&gt; street.length() &gt; 0 &amp;&amp; street.length() &lt; 100 
        ? VALIDATED.widen(Validated.valid(street))
        : VALIDATED.widen(Validated.invalid("Street name must be between 1 and 100 characters"));

// Use the same lens with effectful validation
Kind&lt;ValidatedKind.Witness&lt;String&gt;, Employee&gt; result = 
    employeeToStreet.modifyF(validateStreet, employee, validatedApplicative);
</code></pre>
<hr />
<p><strong>Previous:</strong> <a href="optics/optics_intro.html">An Introduction to Optics</a>
<strong>Next:</strong> <a href="optics/prisms.html">Prisms: Working with Sum Types</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="prisms-a-practical-guide"><a class="header" href="#prisms-a-practical-guide">Prisms: A Practical Guide</a></h1>
<h2 id="working-with-sum-types"><a class="header" href="#working-with-sum-types"><em>Working with Sum Types</em></a></h2>
<p><img src="optics/../images/prism.jpeg" alt="Visual representation of a prism safely extracting one variant from a sum type" /></p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="optics/prisms.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to safely work with sum types and sealed interfaces</li>
<li>Using <code>@GeneratePrisms</code> to create type-safe variant accessors</li>
<li>The difference between <code>getOptional</code> and <code>build</code> operations</li>
<li>Composing prisms with other optics for deep conditional access</li>
<li>Handling optional data extraction without <code>instanceof</code> chains</li>
<li>When to use prisms vs pattern matching vs traditional type checking</li>
</ul>
</div>
</div>
<div id="admonition-example-code" class="admonition admonish-note" role="note" aria-labelledby="admonition-example-code-title">
<div class="admonition-title">
<div id="admonition-example-code-title">
<p>Example Code</p>
</div>
<a class="admonition-anchor-link" href="optics/prisms.html#admonition-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/PrismUsageExample.java">PrismUsageExample</a>
<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/PrismConvenienceMethodsExample.java">PrismConvenienceMethodsExample</a>
<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/PrismsUtilityExample.java">PrismsUtilityExample</a></p>
</div>
</div>
<p>The previous guide demonstrated how a <strong><code>Lens</code></strong> gives us a powerful, composable way to work with "has-a" relationships‚Äîa field that is guaranteed to exist within a record.</p>
<p>But what happens when the data doesn't have a guaranteed structure? What if a value can be one of <em>several different types</em>? This is the domain of "is-a" relationships, or <strong>sum types</strong>, commonly modeled in Java using <code>sealed interface</code> or <code>enum</code>.</p>
<p>For this, we need a different kind of optic: the <strong>Prism</strong>.</p>
<hr />
<h2 id="the-scenario-working-with-json-like-data"><a class="header" href="#the-scenario-working-with-json-like-data">The Scenario: Working with JSON-like Data</a></h2>
<p>A <code>Lens</code> is like a sniper rifle, targeting a single, known field. A <strong><code>Prism</code></strong> is like a safe-cracker's tool; it attempts to open a specific "lock" (a particular type) and only succeeds if it has the right key.</p>
<p>Consider a common scenario: modelling a JSON structure. A value can be a string, a number, a boolean, or a nested object.</p>
<p><strong>The Data Model:</strong> We can represent this with a <code>sealed interface</code>.</p>
<pre><code class="language-java">import org.higherkindedj.optics.annotations.GeneratePrisms;
import org.higherkindedj.optics.annotations.GenerateLenses;
import java.util.Map;

@GeneratePrisms // Generates Prisms for each case of the sealed interface
public sealed interface JsonValue {}

public record JsonString(String value) implements JsonValue {}
public record JsonNumber(double value) implements JsonValue {}

@GenerateLenses // We can still use Lenses on the product types within the sum type
public record JsonObject(Map&lt;String, JsonValue&gt; fields) implements JsonValue {}
</code></pre>
<p><strong>Our Goal:</strong> We need to safely access and update the <code>value</code> of a <code>JsonString</code> that is deeply nested within another <code>JsonObject</code>. An <code>instanceof</code> and casting approach would be unsafe and verbose. A <code>Lens</code> won't work because a <code>JsonValue</code> might be a <code>JsonNumber</code>, not the <code>JsonObject</code> we expect.</p>
<hr />
<h2 id="think-of-prisms-like"><a class="header" href="#think-of-prisms-like">Think of Prisms Like...</a></h2>
<ul>
<li><strong>A type-safe filter</strong>: Only "lets through" values that match a specific shape</li>
<li><strong>A safe cast</strong>: Like <code>instanceof</code> + cast, but functional and composable</li>
<li><strong>A conditional lens</strong>: Works like a lens, but might return empty if the type doesn't match</li>
<li><strong>A pattern matcher</strong>: Focuses on one specific case of a sum type</li>
</ul>
<hr />
<h2 id="a-step-by-step-walkthrough-1"><a class="header" href="#a-step-by-step-walkthrough-1">A Step-by-Step Walkthrough</a></h2>
<h3 id="step-1-generating-the-prisms"><a class="header" href="#step-1-generating-the-prisms">Step 1: Generating the Prisms</a></h3>
<p>Just as with lenses, we annotate our <code>sealed interface</code> with <strong><code>@GeneratePrisms</code></strong>. This automatically creates a companion class (e.g., <code>JsonValuePrisms</code>) with a <code>Prism</code> for each permitted subtype.</p>
<pre><code class="language-java">// Generated automatically:
// JsonValuePrisms.jsonString() -&gt; Prism&lt;JsonValue, JsonString&gt;
// JsonValuePrisms.jsonNumber() -&gt; Prism&lt;JsonValue, JsonNumber&gt;
// JsonValuePrisms.jsonBoolean() -&gt; Prism&lt;JsonValue, JsonBoolean&gt;
// JsonValuePrisms.jsonObject() -&gt; Prism&lt;JsonValue, JsonObject&gt;
</code></pre>
<h3 id="step-2-the-core-prism-operations"><a class="header" href="#step-2-the-core-prism-operations">Step 2: The Core Prism Operations</a></h3>
<p>A <code>Prism</code> is defined by two unique, failable operations:</p>
<ul>
<li><strong><code>getOptional(source)</code></strong>: Attempts to focus on the target. It returns an <code>Optional</code> which is non-empty only if the <code>source</code> matches the Prism's specific case. This is the safe alternative to an <code>instanceof</code> check and cast.</li>
<li><strong><code>build(value)</code></strong>: Constructs the top-level type from a part. This is the reverse operation, used to wrap a value back into its specific case (e.g., taking a <code>String</code> and building a <code>JsonString</code>).</li>
</ul>
<pre><code class="language-java">Prism&lt;JsonValue, JsonString&gt; jsonStringPrism = JsonValuePrisms.jsonString();

// --- Using getOptional (the safe "cast") ---
Optional&lt;JsonString&gt; result1 = jsonStringPrism.getOptional(new JsonString("hello")); 
// -&gt; Optional.of(JsonString("hello"))

Optional&lt;JsonString&gt; result2 = jsonStringPrism.getOptional(new JsonNumber(123));   
// -&gt; Optional.empty()

// --- Using build (construct the sum type from a part) ---
JsonValue result3 = jsonStringPrism.build(new JsonString("world")); 
// -&gt; JsonString("world") (as JsonValue)
</code></pre>
<h3 id="step-3-composing-prisms-for-deep-access"><a class="header" href="#step-3-composing-prisms-for-deep-access">Step 3: Composing Prisms for Deep Access</a></h3>
<p>The true power is composing <code>Prism</code>s with other optics. When a composition might fail (any time a <code>Prism</code> is involved), the result is a <code>Traversal</code>. To ensure type-safety during composition, we convert each optic in the chain to a <code>Traversal</code> using <code>.asTraversal()</code>.</p>
<pre><code class="language-java">
// Create all the optics we need
Prism&lt;JsonValue, JsonObject&gt; jsonObjectPrism = JsonValuePrisms.jsonObject();
Prism&lt;JsonValue, JsonString&gt; jsonStringPrism = JsonValuePrisms.jsonString();
Lens&lt;JsonObject, Map&lt;String, JsonValue&gt;&gt; fieldsLens = JsonObjectLenses.fields();


// The composed optic: safely navigate from JsonObject -&gt; userLogin field -&gt; name field -&gt; string value
Traversal&lt;JsonObject, String&gt; userNameTraversal =
    fieldsLens.asTraversal()                      // JsonObject -&gt; Map&lt;String, JsonValue&gt;
        .andThen(mapValue("userLogin"))                // -&gt; JsonValue (if "userLogin" key exists)
        .andThen(jsonObjectPrism.asTraversal())   // -&gt; JsonObject (if it's an object)
        .andThen(fieldsLens.asTraversal())        // -&gt; Map&lt;String, JsonValue&gt;
         .andThen(Traversals.forMap("name"))     // -&gt; JsonValue (if "name" key exists)
        .andThen(jsonStringPrism.asTraversal())   // -&gt; JsonString (if it's a string)
        .andThen(JsonStringLenses.value().asTraversal()); // -&gt; String
</code></pre>
<p>This composed <code>Traversal</code> now represents a safe, deep path that will only succeed if every step in the chain matches.</p>
<hr />
<h2 id="when-to-use-prisms-vs-other-approaches"><a class="header" href="#when-to-use-prisms-vs-other-approaches">When to Use Prisms vs Other Approaches</a></h2>
<h3 id="use-prisms-when"><a class="header" href="#use-prisms-when">Use Prisms When:</a></h3>
<ul>
<li><strong>Type-safe variant handling</strong> - Working with <code>sealed interface</code> or <code>enum</code> cases</li>
<li><strong>Optional data extraction</strong> - You need to safely "try" to get a specific type</li>
<li><strong>Composable type checking</strong> - Building reusable type-safe paths</li>
<li><strong>Functional pattern matching</strong> - Avoiding <code>instanceof</code> chains</li>
</ul>
<pre><code class="language-java">// Perfect for safe type extraction
Optional&lt;String&gt; errorMessage = DomainErrorPrisms.validationError()
    .andThen(ValidationErrorLenses.message())
    .getOptional(someError);
</code></pre>
<h3 id="use-traditional-instanceof-when"><a class="header" href="#use-traditional-instanceof-when">Use Traditional instanceof When:</a></h3>
<ul>
<li><strong>One-off type checks</strong> - Not building reusable logic</li>
<li><strong>Imperative control flow</strong> - You need if/else branching</li>
<li><strong>Performance critical paths</strong> - Minimal abstraction overhead needed</li>
</ul>
<pre><code class="language-java">// Sometimes instanceof is clearer for simple cases
if (jsonValue instanceof JsonString jsonStr) {
    return jsonStr.value().toUpperCase();
}
</code></pre>
<h3 id="use-pattern-matching-when"><a class="header" href="#use-pattern-matching-when">Use Pattern Matching When:</a></h3>
<ul>
<li><strong>Exhaustive case handling</strong> - You need to handle all variants</li>
<li><strong>Complex extraction logic</strong> - Multiple levels of pattern matching</li>
<li><strong>Modern codebases</strong> - Using recent Java features</li>
</ul>
<pre><code class="language-java">// Pattern matching for comprehensive handling
return switch (jsonValue) {
    case JsonString(var str) -&gt; str.toUpperCase();
    case JsonNumber(var num) -&gt; String.valueOf(num);
    case JsonBoolean(var bool) -&gt; String.valueOf(bool);
    case JsonObject(var fields) -&gt; "Object with " + fields.size() + " fields";
};
</code></pre>
<hr />
<h2 id="common-pitfalls-2"><a class="header" href="#common-pitfalls-2">Common Pitfalls</a></h2>
<h3 id="-dont-do-this-1"><a class="header" href="#-dont-do-this-1">‚ùå Don't Do This:</a></h3>
<pre><code class="language-java">// Unsafe: Assuming the cast will succeed
JsonString jsonStr = (JsonString) jsonValue; // Can throw ClassCastException!

// Verbose: Repeated instanceof checks
if (jsonValue instanceof JsonObject obj1) {
    var userValue = obj1.fields().get("userLogin");
    if (userValue instanceof JsonObject obj2) {
        var nameValue = obj2.fields().get("name");
        if (nameValue instanceof JsonString str) {
            return str.value().toUpperCase();
        }
    }
}

// Inefficient: Creating prisms repeatedly
var name1 = JsonValuePrisms.jsonString().getOptional(value1);
var name2 = JsonValuePrisms.jsonString().getOptional(value2);
var name3 = JsonValuePrisms.jsonString().getOptional(value3);
</code></pre>
<h3 id="-do-this-instead-1"><a class="header" href="#-do-this-instead-1">‚úÖ Do This Instead:</a></h3>
<pre><code class="language-java">// Safe: Use prism's getOptional
Optional&lt;JsonString&gt; maybeJsonStr = JsonValuePrisms.jsonString().getOptional(jsonValue);

// Composable: Build reusable safe paths
var userNamePath = JsonValuePrisms.jsonObject()
    .andThen(JsonObjectLenses.fields())
    .andThen(mapValue("userLogin"))
    .andThen(JsonValuePrisms.jsonObject())
    // ... continue composition

// Efficient: Reuse prisms and composed paths
var stringPrism = JsonValuePrisms.jsonString();
var name1 = stringPrism.getOptional(value1);
var name2 = stringPrism.getOptional(value2);
var name3 = stringPrism.getOptional(value3);
</code></pre>
<hr />
<h2 id="performance-notes-2"><a class="header" href="#performance-notes-2">Performance Notes</a></h2>
<p>Prisms are optimised for type safety and composability:</p>
<ul>
<li><strong>Fast type checking</strong>: Prisms use <code>instanceof</code> under the hood, which is optimised by the JVM</li>
<li><strong>Lazy evaluation</strong>: Composed prisms only perform checks when needed</li>
<li><strong>Memory efficient</strong>: No boxing or wrapper allocation for failed matches</li>
<li><strong>Composable</strong>: Complex type-safe paths can be built once and reused</li>
</ul>
<p><strong>Best Practice</strong>: For frequently used prism combinations, create them once and store as constants:</p>
<pre><code class="language-java">public class JsonOptics {
    public static final Prism&lt;JsonValue, JsonString&gt; STRING = 
        JsonValuePrisms.jsonString();
  
    public static final Traversal&lt;JsonValue, String&gt; STRING_VALUE = 
        STRING.andThen(JsonStringLenses.value());
  
    public static final Traversal&lt;JsonObject, String&gt; USER_NAME = 
        fieldsLens.asTraversal()
            .andThen(Traversals.forMap("userLogin"))
            .andThen(JsonValuePrisms.jsonObject().asTraversal())
            .andThen(fieldsLens.asTraversal())
            .andThen(Traversals.forMap("name"))
            .andThen(STRING.asTraversal())
            .andThen(JsonStringLenses.value().asTraversal());
}
</code></pre>
<h2 id="real-world-example-api-response-handling"><a class="header" href="#real-world-example-api-response-handling">Real-World Example: API Response Handling</a></h2>
<p>Here's a practical example of using prisms to handle different API response types safely:</p>
<pre><code class="language-java">@GeneratePrisms
public sealed interface ApiResponse {}
public record SuccessResponse(String data, int statusCode) implements ApiResponse {}
public record ErrorResponse(String message, String errorCode) implements ApiResponse {}
public record TimeoutResponse(long timeoutMs) implements ApiResponse {}

public class ApiHandler {
    // Reusable prisms for different response types
    private static final Prism&lt;ApiResponse, SuccessResponse&gt; SUCCESS = 
        ApiResponsePrisms.successResponse();
    private static final Prism&lt;ApiResponse, ErrorResponse&gt; ERROR = 
        ApiResponsePrisms.errorResponse();
    private static final Prism&lt;ApiResponse, TimeoutResponse&gt; TIMEOUT = 
        ApiResponsePrisms.timeoutResponse();
  
    public String handleResponse(ApiResponse response) {
        // Type-safe extraction and handling
        return SUCCESS.getOptional(response)
            .map(success -&gt; "Success: " + success.data())
            .or(() -&gt; ERROR.getOptional(response)
                .map(error -&gt; "Error " + error.errorCode() + ": " + error.message()))
            .or(() -&gt; TIMEOUT.getOptional(response)
                .map(timeout -&gt; "Request timed out after " + timeout.timeoutMs() + "ms"))
            .orElse("Unknown response type");
    }
  
    // Use prisms for conditional processing
    public boolean isRetryable(ApiResponse response) {
        return ERROR.getOptional(response)
            .map(error -&gt; "RATE_LIMIT".equals(error.errorCode()) || "TEMPORARY".equals(error.errorCode()))
            .or(() -&gt; TIMEOUT.getOptional(response).map(t -&gt; true))
            .orElse(false);
    }
}
</code></pre>
<h2 id="complete-runnable-example-1"><a class="header" href="#complete-runnable-example-1">Complete, Runnable Example</a></h2>
<p>This example puts it all together, showing how to use the composed <code>Traversal</code> to perform a safe update.</p>
<pre><code class="language-java">package org.higherkindedj.example.prism;

import org.higherkindedj.optics.Lens;
import org.higherkindedj.optics.Prism;
import org.higherkindedj.optics.Traversal;
import org.higherkindedj.optics.annotations.GenerateLenses;
import org.higherkindedj.optics.annotations.GeneratePrisms;
import org.higherkindedj.optics.util.Traversals;
import java.util.*;

public class PrismUsageExample {

    // 1. Define the nested data model with sum types.
    @GeneratePrisms
    public sealed interface JsonValue {}
    public record JsonString(String value) implements JsonValue {}
    public record JsonNumber(double value) implements JsonValue {}
  
    @GenerateLenses
    public record JsonObject(Map&lt;String, JsonValue&gt; fields) implements JsonValue {}


    public static void main(String[] args) {
        // 2. Create the initial nested structure.
        var userData = Map.of(
            "userLogin", new JsonObject(Map.of(
                "name", new JsonString("Alice"),
                "age", new JsonNumber(30),
                "active", new JsonBoolean(true)
            )),
            "metadata", new JsonObject(Map.of(
                "version", new JsonString("1.0")
            ))
        );
        var data = new JsonObject(userData);
    
        System.out.println("Original Data: " + data);
        System.out.println("------------------------------------------");


        // 3. Get the generated and manually created optics.
        Prism&lt;JsonValue, JsonObject&gt; jsonObjectPrism = JsonValuePrisms.jsonObject();
        Prism&lt;JsonValue, JsonString&gt; jsonStringPrism = JsonValuePrisms.jsonString();
        Lens&lt;JsonObject, Map&lt;String, JsonValue&gt;&gt; fieldsLens = JsonObjectLenses.fields();
        Lens&lt;JsonString, String&gt; jsonStringValueLens = Lens.of(JsonString::value, (js, s) -&gt; new JsonString(s));
    
        // 4. Demonstrate individual prism operations
        System.out.println("--- Individual Prism Operations ---");
    
        // Safe type extraction
        JsonValue userValue = data.fields().get("userLogin");
        Optional&lt;JsonObject&gt; userObject = jsonObjectPrism.getOptional(userValue);
        System.out.println("User object: " + userObject);
    
        // Attempting to extract wrong type
        JsonValue nameValue = ((JsonObject) userValue).fields().get("name");
        Optional&lt;JsonNumber&gt; nameAsNumber = JsonValuePrisms.jsonNumber().getOptional(nameValue);
        System.out.println("Name as number (should be empty): " + nameAsNumber);
    
        // Building new values
        JsonValue newString = jsonStringPrism.build(new JsonString("Bob"));
        System.out.println("Built new string: " + newString);
        System.out.println("------------------------------------------");
    
        // 5. Compose the full traversal.
        Traversal&lt;JsonObject, String&gt; userToJsonName =
            fieldsLens.asTraversal()
                .andThen(Traversals.forMap("userLogin")) 
                .andThen(jsonObjectPrism.asTraversal())
                .andThen(fieldsLens.asTraversal())
                .andThen(Traversals.forMap("name"))
                .andThen(jsonStringPrism.asTraversal())
                .andThen(jsonStringValueLens.asTraversal());

          // 6. Use the composed traversal to perform safe updates
        JsonObject updatedData = Traversals.modify(userNameTraversal, String::toUpperCase, data);
        System.out.println("After safe `modify`:  " + updatedData);
    
        // 7. Demonstrate that the traversal safely handles missing paths
        var dataWithoutUser = new JsonObject(Map.of("metadata", new JsonString("test")));
        JsonObject safeUpdate = Traversals.modify(userNameTraversal, String::toUpperCase, dataWithoutUser);
        System.out.println("Safe update on missing path: " + safeUpdate);
    
        System.out.println("Original is unchanged: " + data);
        System.out.println("------------------------------------------");
    
        // 8. Demonstrate error-resistant operations
        System.out.println("--- Error-Resistant Operations ---");
    
        // Get all string values safely
        List&lt;String&gt; allStrings = List.of(
            new JsonString("hello"),
            new JsonNumber(42),
            new JsonString("world"),
            new JsonBoolean(true)
        ).stream()
        .map(jsonStringPrism::getOptional)
        .filter(Optional::isPresent)
        .map(Optional::get)
        .map(JsonString::value)
        .toList();
    
        System.out.println("Extracted strings only: " + allStrings);
    }
}
</code></pre>
<p><strong>Expected Output:</strong></p>
<pre><code>Original Data: JsonObject[fields={userLogin=JsonObject[fields={name=JsonString[value=Alice], age=JsonNumber[value=30.0], active=JsonBoolean[value=true]}], metadata=JsonObject[fields={version=JsonString[value=1.0]}]}]
------------------------------------------
--- Individual Prism Operations ---
User object: Optional[JsonObject[fields={name=JsonString[value=Alice], age=JsonNumber[value=30.0], active=JsonBoolean[value=true]}]]
Name as number (should be empty): Optional.empty
Built new string: JsonString[value=Bob]
------------------------------------------
--- Composed Traversal Operations ---
After safe `modify`:  JsonObject[fields={userLogin=JsonObject[fields={name=JsonString[value=ALICE], age=JsonNumber[value=30.0], active=JsonBoolean[value=true]}], metadata=JsonObject[fields={version=JsonString[value=1.0]}]}]
Safe update on missing path: JsonObject[fields={metadata=JsonString[value=test]}]
Original is unchanged: JsonObject[fields={userLogin=JsonObject[fields={name=JsonString[value=Alice], age=JsonNumber[value=30.0], active=JsonBoolean[value=true]}], metadata=JsonObject[fields={version=JsonString[value=1.0]}]}]
------------------------------------------
--- Error-Resistant Operations ---
Extracted strings only: [hello, world]
</code></pre>
<hr />
<h2 id="prism-convenience-methods"><a class="header" href="#prism-convenience-methods">Prism Convenience Methods</a></h2>
<h3 id="streamlined-operations-for-common-patterns"><a class="header" href="#streamlined-operations-for-common-patterns"><em>Streamlined Operations for Common Patterns</em></a></h3>
<p>Whilst <code>getOptional()</code> and <code>build()</code> are the core operations, the <code>Prism</code> interface provides several convenience methods that make everyday tasks more ergonomic and expressive.</p>
<p><strong>Quick Reference:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Purpose</th><th>Returns</th></tr></thead><tbody>
<tr><td><code>matches(S source)</code></td><td>Check if prism matches without extraction</td><td><code>boolean</code></td></tr>
<tr><td><code>getOrElse(A default, S source)</code></td><td>Extract value or return default</td><td><code>A</code></td></tr>
<tr><td><code>mapOptional(Function&lt;A, B&gt; f, S source)</code></td><td>Transform matched value</td><td><code>Optional&lt;B&gt;</code></td></tr>
<tr><td><code>modify(Function&lt;A, A&gt; f, S source)</code></td><td>Modify if matches, else return original</td><td><code>S</code></td></tr>
<tr><td><code>modifyWhen(Predicate&lt;A&gt; p, Function&lt;A, A&gt; f, S source)</code></td><td>Modify only when predicate satisfied</td><td><code>S</code></td></tr>
<tr><td><code>setWhen(Predicate&lt;A&gt; p, A value, S source)</code></td><td>Set only when predicate satisfied</td><td><code>S</code></td></tr>
<tr><td><code>orElse(Prism&lt;S, A&gt; other)</code></td><td>Try this prism, then fallback</td><td><code>Prism&lt;S, A&gt;</code></td></tr>
</tbody></table>
</div>
<h3 id="type-checking-with-matches"><a class="header" href="#type-checking-with-matches">Type Checking with <code>matches()</code></a></h3>
<p>The <code>matches()</code> method provides a clean alternative to <code>getOptional(source).isPresent()</code>:</p>
<pre><code class="language-java">Prism&lt;JsonValue, JsonString&gt; stringPrism = JsonValuePrisms.jsonString();

// Clear, declarative type checking
if (stringPrism.matches(value)) {
    // Process as string
}

// Useful in streams and filters
List&lt;JsonValue&gt; onlyStrings = values.stream()
    .filter(stringPrism::matches)
    .collect(Collectors.toList());
</code></pre>
<p><strong>Real-World Example</strong>: Filtering polymorphic domain events:</p>
<pre><code class="language-java">@GeneratePrisms
sealed interface DomainEvent permits UserEvent, OrderEvent, PaymentEvent {}

// Business logic: process only payment events
public void processPayments(List&lt;DomainEvent&gt; events) {
    Prism&lt;DomainEvent, PaymentEvent&gt; paymentPrism =
        DomainEventPrisms.paymentEvent();

    long paymentCount = events.stream()
        .filter(paymentPrism::matches)
        .count();

    logger.info("Processing {} payment events", paymentCount);

    events.stream()
        .filter(paymentPrism::matches)
        .map(paymentPrism::getOptional)
        .flatMap(Optional::stream)
        .forEach(this::processPayment);
}
</code></pre>
<h3 id="default-values-with-getorelse"><a class="header" href="#default-values-with-getorelse">Default Values with <code>getOrElse()</code></a></h3>
<p>When you need fallback values, <code>getOrElse()</code> is more concise than <code>getOptional().orElse()</code>:</p>
<pre><code class="language-java">Prism&lt;ApiResponse, SuccessResponse&gt; successPrism =
    ApiResponsePrisms.successResponse();

// Extract success data or use default
String data = successPrism.getOrElse(
    new SuccessResponse("fallback", 200),
    response
).data();

// Particularly useful for configuration
Config config = Prisms.some()
    .getOrElse(Config.DEFAULT, optionalConfig);
</code></pre>
<p><strong>Real-World Example</strong>: Parsing user input with graceful degradation:</p>
<pre><code class="language-java">@GeneratePrisms
sealed interface ParsedValue permits IntValue, StringValue, InvalidValue {}

public int parseUserQuantity(String input, int defaultQty) {
    ParsedValue parsed = parseInput(input);

    Prism&lt;ParsedValue, IntValue&gt; intPrism = ParsedValuePrisms.intValue();

    // Extract integer or use sensible default
    return intPrism.getOrElse(
        new IntValue(defaultQty),
        parsed
    ).value();
}

// Application settings with fallback
public DatabaseConfig getDatabaseConfig(ApplicationConfig config) {
    Prism&lt;ConfigSource, DatabaseConfig&gt; dbConfigPrism =
        ConfigSourcePrisms.databaseConfig();

    return dbConfigPrism.getOrElse(
        DatabaseConfig.DEFAULT_POSTGRES,
        config.source()
    );
}
</code></pre>
<h3 id="transforming-matches-with-mapoptional"><a class="header" href="#transforming-matches-with-mapoptional">Transforming Matches with <code>mapOptional()</code></a></h3>
<p>The <code>mapOptional()</code> method transforms matched values without building them back into the source type:</p>
<pre><code class="language-java">Prism&lt;JsonValue, JsonNumber&gt; numberPrism = JsonValuePrisms.jsonNumber();

// Extract and transform in one operation
Optional&lt;String&gt; formatted = numberPrism.mapOptional(
    num -&gt; String.format("%.2f", num.value()),
    jsonValue
);

// Compose transformations
Optional&lt;Boolean&gt; isLarge = numberPrism.mapOptional(
    num -&gt; num.value() &gt; 1000,
    jsonValue
);
</code></pre>
<p><strong>Real-World Example</strong>: ETL data transformation pipeline:</p>
<pre><code class="language-java">@GeneratePrisms
sealed interface SourceData permits CsvRow, JsonObject, XmlNode {}

public List&lt;CustomerRecord&gt; extractCustomers(List&lt;SourceData&gt; sources) {
    Prism&lt;SourceData, CsvRow&gt; csvPrism = SourceDataPrisms.csvRow();

    return sources.stream()
        .map(source -&gt; csvPrism.mapOptional(
            csv -&gt; new CustomerRecord(
                csv.column("customer_id"),
                csv.column("name"),
                csv.column("email")
            ),
            source
        ))
        .flatMap(Optional::stream)
        .collect(Collectors.toList());
}

// Extract business metrics from polymorphic events
public Optional&lt;BigDecimal&gt; extractRevenue(DomainEvent event) {
    Prism&lt;DomainEvent, OrderCompleted&gt; orderPrism =
        DomainEventPrisms.orderCompleted();

    return orderPrism.mapOptional(
        order -&gt; order.lineItems().stream()
            .map(LineItem::totalPrice)
            .reduce(BigDecimal.ZERO, BigDecimal::add),
        event
    );
}
</code></pre>
<h3 id="simple-modifications-with-modify"><a class="header" href="#simple-modifications-with-modify">Simple Modifications with <code>modify()</code></a></h3>
<p>Instead of manually calling <code>getOptional().map(f).map(build)</code>, use <code>modify()</code>:</p>
<pre><code class="language-java">Prism&lt;JsonValue, JsonString&gt; stringPrism = JsonValuePrisms.jsonString();

// ‚úÖ Clean modification
JsonValue uppercased = stringPrism.modify(
    str -&gt; new JsonString(str.value().toUpperCase()),
    jsonValue
);

// ‚ùå Verbose alternative
JsonValue verboseResult = stringPrism.getOptional(jsonValue)
    .map(str -&gt; new JsonString(str.value().toUpperCase()))
    .map(stringPrism::build)
    .orElse(jsonValue);
</code></pre>
<p>If the prism doesn't match, <code>modify()</code> safely returns the original structure unchanged.</p>
<h3 id="conditional-operations-with-modifywhen-and-setwhen"><a class="header" href="#conditional-operations-with-modifywhen-and-setwhen">Conditional Operations with <code>modifyWhen()</code> and <code>setWhen()</code></a></h3>
<p>These methods combine matching with predicate-based filtering:</p>
<pre><code class="language-java">Prism&lt;ConfigValue, StringConfig&gt; stringConfig =
    ConfigValuePrisms.stringConfig();

// Only modify non-empty strings
ConfigValue sanitised = stringConfig.modifyWhen(
    str -&gt; !str.value().isEmpty(),
    str -&gt; new StringConfig(str.value().trim()),
    configValue
);

// Only update if validation passes
ConfigValue validated = stringConfig.setWhen(
    str -&gt; str.value().length() &lt;= 255,
    new StringConfig("validated"),
    configValue
);
</code></pre>
<p><strong>Real-World Example</strong>: Business rule enforcement in order processing:</p>
<pre><code class="language-java">@GeneratePrisms
sealed interface OrderStatus permits Draft, Submitted, Approved, Rejected {}

public class OrderProcessor {
    private static final Prism&lt;OrderStatus, Submitted&gt; SUBMITTED =
        OrderStatusPrisms.submitted();

    // Only approve orders above minimum value
    public OrderStatus approveIfEligible(
        OrderStatus status,
        BigDecimal orderValue,
        BigDecimal minValue
    ) {
        return SUBMITTED.setWhen(
            submitted -&gt; orderValue.compareTo(minValue) &gt;= 0,
            new Approved(Instant.now(), "AUTO_APPROVED"),
            status
        );
    }

    // Apply discount only to high-value draft orders
    public OrderStatus applyVipDiscount(OrderStatus status, Order order) {
        Prism&lt;OrderStatus, Draft&gt; draftPrism = OrderStatusPrisms.draft();

        return draftPrism.modifyWhen(
            draft -&gt; order.totalValue().compareTo(VIP_THRESHOLD) &gt; 0,
            draft -&gt; draft.withDiscount(VIP_DISCOUNT_RATE),
            status
        );
    }
}
</code></pre>
<p><strong>Use Cases:</strong></p>
<ul>
<li><strong>Conditional validation</strong>: Update only if current value meets criteria</li>
<li><strong>Guarded transformations</strong>: Apply changes only to valid states</li>
<li><strong>Business rules</strong>: Enforce constraints during updates</li>
<li><strong>Workflow automation</strong>: Apply state transitions based on business logic</li>
</ul>
<h3 id="fallback-matching-with-orelse"><a class="header" href="#fallback-matching-with-orelse">Fallback Matching with <code>orElse()</code></a></h3>
<p>The <code>orElse()</code> method chains prisms to try multiple matches:</p>
<pre><code class="language-java">Prism&lt;JsonValue, JsonNumber&gt; intPrism = JsonValuePrisms.jsonInt();
Prism&lt;JsonValue, JsonNumber&gt; doublePrism = JsonValuePrisms.jsonDouble();

// Try int first, fall back to double
Prism&lt;JsonValue, JsonNumber&gt; anyNumber = intPrism.orElse(doublePrism);

Optional&lt;JsonNumber&gt; result = anyNumber.getOptional(jsonValue);
// Matches either integer or double JSON values

// Building always uses the first prism's constructor
JsonValue built = anyNumber.build(new JsonNumber(42)); // Uses intPrism.build
</code></pre>
<p><strong>Real-World Example</strong>: Handling multiple error types in API responses:</p>
<pre><code class="language-java">Prism&lt;ApiResponse, String&gt; errorMessage =
    ApiResponsePrisms.validationError()
        .andThen(ValidationErrorLenses.message())
        .orElse(
            ApiResponsePrisms.serverError()
                .andThen(ServerErrorLenses.message())
        );

// Extracts error message from either error type
Optional&lt;String&gt; message = errorMessage.getOptional(response);
</code></pre>
<div id="admonition-when-to-use-convenience-methods" class="admonition admonish-tip" role="note" aria-labelledby="admonition-when-to-use-convenience-methods-title">
<div class="admonition-title">
<div id="admonition-when-to-use-convenience-methods-title">
<p>When to Use Convenience Methods</p>
</div>
<a class="admonition-anchor-link" href="optics/prisms.html#admonition-when-to-use-convenience-methods"></a>
</div>
<div>
<ul>
<li><strong>matches()</strong>: Type guards, stream filters, conditional logic</li>
<li><strong>getOrElse()</strong>: Configuration, default values, fallback data</li>
<li><strong>mapOptional()</strong>: Projections, transformations without reconstruction</li>
<li><strong>modify()</strong>: Simple transformations of matching cases</li>
<li><strong>modifyWhen()</strong>: Conditional updates based on current state</li>
<li><strong>setWhen()</strong>: Guarded updates with validation</li>
<li><strong>orElse()</strong>: Handling multiple variants, fallback strategies</li>
</ul>
</div>
</div>
<hr />
<h2 id="common-prism-patterns-with-the-prisms-utility"><a class="header" href="#common-prism-patterns-with-the-prisms-utility">Common Prism Patterns with the Prisms Utility</a></h2>
<h3 id="ready-made-prisms-for-standard-types"><a class="header" href="#ready-made-prisms-for-standard-types"><em>Ready-Made Prisms for Standard Types</em></a></h3>
<p>The <code>Prisms</code> utility class (in <code>org.higherkindedj.optics.util</code>) provides factory methods for common prism patterns, saving you from writing boilerplate for standard Java types.</p>
<p><strong>Quick Reference:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Factory Method</th><th>Type Signature</th><th>Use Case</th></tr></thead><tbody>
<tr><td><code>some()</code></td><td><code>Prism&lt;Optional&lt;A&gt;, A&gt;</code></td><td>Extract present Optional values</td></tr>
<tr><td><code>left()</code></td><td><code>Prism&lt;Either&lt;L, R&gt;, L&gt;</code></td><td>Focus on Left case</td></tr>
<tr><td><code>right()</code></td><td><code>Prism&lt;Either&lt;L, R&gt;, R&gt;</code></td><td>Focus on Right case</td></tr>
<tr><td><code>only(A value)</code></td><td><code>Prism&lt;A, Unit&gt;</code></td><td>Match specific value</td></tr>
<tr><td><code>notNull()</code></td><td><code>Prism&lt;@Nullable A, A&gt;</code></td><td>Filter null values</td></tr>
<tr><td><code>instanceOf(Class&lt;A&gt;)</code></td><td><code>Prism&lt;S, A&gt;</code></td><td>Safe type-based casting</td></tr>
<tr><td><code>listHead()</code></td><td><code>Prism&lt;List&lt;A&gt;, A&gt;</code></td><td>First element (if exists)</td></tr>
<tr><td><code>listLast()</code></td><td><code>Prism&lt;List&lt;A&gt;, A&gt;</code></td><td>Last element (if exists)</td></tr>
<tr><td><code>listAt(int)</code></td><td><code>Prism&lt;List&lt;A&gt;, A&gt;</code></td><td>Element at index (read-only)</td></tr>
</tbody></table>
</div>
<h3 id="working-with-optional-prismssome"><a class="header" href="#working-with-optional-prismssome">Working with Optional: <code>Prisms.some()</code></a></h3>
<pre><code class="language-java">import org.higherkindedj.optics.util.Prisms;

Prism&lt;Optional&lt;String&gt;, String&gt; somePrism = Prisms.some();

Optional&lt;String&gt; present = Optional.of("hello");
Optional&lt;String&gt; value = somePrism.getOptional(present); // Optional.of("hello")

Optional&lt;String&gt; empty = Optional.empty();
Optional&lt;String&gt; noMatch = somePrism.getOptional(empty); // Optional.empty()

// Useful for nested Optionals
Optional&lt;Optional&lt;Config&gt;&gt; nestedConfig = loadConfig();
Optional&lt;Config&gt; flattened = somePrism.getOptional(nestedConfig)
    .flatMap(Function.identity());
</code></pre>
<h3 id="either-case-handling-prismsleft-and-prismsright"><a class="header" href="#either-case-handling-prismsleft-and-prismsright">Either Case Handling: <code>Prisms.left()</code> and <code>Prisms.right()</code></a></h3>
<pre><code class="language-java">Prism&lt;Either&lt;String, Integer&gt;, String&gt; leftPrism = Prisms.left();
Prism&lt;Either&lt;String, Integer&gt;, Integer&gt; rightPrism = Prisms.right();

Either&lt;String, Integer&gt; error = Either.left("Failed");
Optional&lt;String&gt; errorMsg = leftPrism.getOptional(error); // Optional.of("Failed")
Optional&lt;Integer&gt; noValue = rightPrism.getOptional(error); // Optional.empty()

// Compose with lenses for deep access
record ValidationError(String code, String message) {}
Lens&lt;ValidationError, String&gt; messageLens = ValidationErrorLenses.message();

Prism&lt;Either&lt;ValidationError, Data&gt;, String&gt; errorMessage =
    Prisms.&lt;ValidationError, Data&gt;left()
        .andThen(messageLens);

Either&lt;ValidationError, Data&gt; result = validate(data);
Optional&lt;String&gt; msg = errorMessage.getOptional(result);
</code></pre>
<h3 id="sentinel-values-prismsonly"><a class="header" href="#sentinel-values-prismsonly">Sentinel Values: <code>Prisms.only()</code></a></h3>
<p>Perfect for matching specific constant values:</p>
<pre><code class="language-java">Prism&lt;String, Unit&gt; httpOkPrism = Prisms.only("200 OK");

// Check for specific status
if (httpOkPrism.matches(statusCode)) {
    // Handle success case
}

// Filter for specific values
List&lt;String&gt; onlyErrors = statusCodes.stream()
    .filter(Prisms.only("500 ERROR")::matches)
    .collect(Collectors.toList());

// Null sentinel handling
Prism&lt;String, Unit&gt; nullPrism = Prisms.only(null);
boolean isNull = nullPrism.matches(value);
</code></pre>
<h3 id="null-safety-prismsnotnull"><a class="header" href="#null-safety-prismsnotnull">Null Safety: <code>Prisms.notNull()</code></a></h3>
<pre><code class="language-java">Prism&lt;String, String&gt; notNullPrism = Prisms.notNull();

// Safe extraction
@Nullable String nullable = getDatabaseValue();
Optional&lt;String&gt; safe = notNullPrism.getOptional(nullable);

// Compose to filter null values in pipelines
Traversal&lt;List&lt;String&gt;, String&gt; nonNullStrings =
    Traversals.&lt;String&gt;forList()
        .andThen(Prisms.&lt;String&gt;notNull().asTraversal());

List&lt;@Nullable String&gt; mixedList = List.of("hello", null, "world", null);
List&lt;String&gt; filtered = Traversals.getAll(nonNullStrings, mixedList);
// Result: ["hello", "world"]
</code></pre>
<h3 id="type-safe-casting-prismsinstanceof"><a class="header" href="#type-safe-casting-prismsinstanceof">Type-Safe Casting: <code>Prisms.instanceOf()</code></a></h3>
<p>Elegant alternative to <code>instanceof</code> checks in type hierarchies:</p>
<pre><code class="language-java">sealed interface Animal permits Dog, Cat, Bird {}
record Dog(String name, String breed) implements Animal {}
record Cat(String name, int lives) implements Animal {}
record Bird(String name, boolean canFly) implements Animal {}

Prism&lt;Animal, Dog&gt; dogPrism = Prisms.instanceOf(Dog.class);

Animal animal = new Dog("Buddy", "Labrador");
Optional&lt;Dog&gt; maybeDog = dogPrism.getOptional(animal); // Optional.of(Dog(...))

// Compose with lenses for deep access
Lens&lt;Dog, String&gt; breedLens = DogLenses.breed();
Traversal&lt;Animal, String&gt; dogBreed =
    dogPrism.asTraversal().andThen(breedLens.asTraversal());

List&lt;Animal&gt; animals = List.of(
    new Dog("Rex", "German Shepherd"),
    new Cat("Whiskers", 9),
    new Dog("Max", "Beagle")
);

List&lt;String&gt; breeds = Traversals.getAll(
    Traversals.&lt;Animal&gt;forList().andThen(dogBreed),
    animals
);
// Result: ["German Shepherd", "Beagle"]
</code></pre>
<h3 id="collection-element-access"><a class="header" href="#collection-element-access">Collection Element Access</a></h3>
<pre><code class="language-java">// First element (if list is non-empty)
Prism&lt;List&lt;String&gt;, String&gt; headPrism = Prisms.listHead();
List&lt;String&gt; names = List.of("Alice", "Bob", "Charlie");
Optional&lt;String&gt; first = headPrism.getOptional(names); // Optional.of("Alice")

// Last element
Prism&lt;List&lt;String&gt;, String&gt; lastPrism = Prisms.listLast();
Optional&lt;String&gt; last = lastPrism.getOptional(names); // Optional.of("Charlie")

// Element at specific index (read-only for queries)
Prism&lt;List&lt;String&gt;, String&gt; secondPrism = Prisms.listAt(1);
Optional&lt;String&gt; second = secondPrism.getOptional(names); // Optional.of("Bob")

// Safe access patterns
String firstOrDefault = headPrism.getOrElse("Unknown", names);
boolean hasList = headPrism.matches(names);
</code></pre>
<div id="admonition-list-prism-limitations" class="admonition admonish-warning" role="note" aria-labelledby="admonition-list-prism-limitations-title">
<div class="admonition-title">
<div id="admonition-list-prism-limitations-title">
<p>List Prism Limitations</p>
</div>
<a class="admonition-anchor-link" href="optics/prisms.html#admonition-list-prism-limitations"></a>
</div>
<div>
<p>The <code>listHead()</code> and <code>listLast()</code> prisms have limited <code>build()</code> operations‚Äîthey create singleton lists. The <code>listAt(int)</code> prism throws <code>UnsupportedOperationException</code> on <code>build()</code> since there's no meaningful way to construct a complete list from a single indexed element.</p>
<p><strong>Use these prisms for:</strong></p>
<ul>
<li>Safe element extraction</li>
<li>Conditional checks (with <code>matches()</code>)</li>
<li>Query operations (with <code>getOptional()</code>)</li>
</ul>
<p><strong>For list modification</strong>, use <code>Traversal</code> or <code>Lens</code> instead:</p>
<pre><code class="language-java">// ‚úÖ For modifications, use proper traversals
Lens&lt;List&lt;String&gt;, String&gt; firstLens = listFirstElementLens();
List&lt;String&gt; updated = firstLens.modify(String::toUpperCase, names);
</code></pre>
</div>
</div>
<h3 id="composing-utility-prisms"><a class="header" href="#composing-utility-prisms">Composing Utility Prisms</a></h3>
<p>The real power emerges when composing these utility prisms with your domain optics:</p>
<pre><code class="language-java">record Config(Optional&lt;Either&lt;String, DatabaseSettings&gt;&gt; database) {}
record DatabaseSettings(String host, int port) {}

// Build a path through Optional -&gt; Either -&gt; Settings -&gt; host
Prism&lt;Config, String&gt; databaseHost =
    ConfigLenses.database()                    // Lens&lt;Config, Optional&lt;Either&lt;...&gt;&gt;&gt;
        .asTraversal()
        .andThen(Prisms.some().asTraversal())  // -&gt; Either&lt;String, DatabaseSettings&gt;
        .andThen(Prisms.right().asTraversal()) // -&gt; DatabaseSettings
        .andThen(DatabaseSettingsLenses.host().asTraversal()); // -&gt; String

Config config = loadConfig();
Optional&lt;String&gt; host = Traversals.getAll(databaseHost, config)
    .stream().findFirst();
</code></pre>
<div id="admonition-performance-considerations" class="admonition admonish-tip" role="note" aria-labelledby="admonition-performance-considerations-title">
<div class="admonition-title">
<div id="admonition-performance-considerations-title">
<p>Performance Considerations</p>
</div>
<a class="admonition-anchor-link" href="optics/prisms.html#admonition-performance-considerations"></a>
</div>
<div>
<p>Utility prisms are lightweight and stateless‚Äîthey're safe to create on-demand or cache as constants:</p>
<pre><code class="language-java">public class AppPrisms {
    public static final Prism&lt;Optional&lt;User&gt;, User&gt; SOME_USER = Prisms.some();
    public static final Prism&lt;Response, SuccessResponse&gt; SUCCESS =
        Prisms.instanceOf(SuccessResponse.class);
}
</code></pre>
</div>
</div>
<hr />
<h2 id="why-prisms-are-essential"><a class="header" href="#why-prisms-are-essential">Why Prisms are Essential</a></h2>
<p><code>Lens</code> handles the "what" and <code>Prism</code> handles the "what if." Together, they allow you to model and operate on virtually any immutable data structure you can design. Prisms are essential for:</p>
<ul>
<li><strong>Safety</strong>: Eliminating <code>instanceof</code> checks and unsafe casts.</li>
<li><strong>Clarity</strong>: Expressing failable focus in a clean, functional way.</li>
<li><strong>Composability</strong>: Combining checks for different data shapes into a single, reusable optic.</li>
<li><strong>Maintainability</strong>: Creating type-safe paths that won't break when data structures evolve.</li>
</ul>
<p>By adding Prisms to your toolkit, you can write even more robust, declarative, and maintainable code that gracefully handles the complexity of real-world data structures.</p>
<div id="admonition-ready-for-more" class="admonition admonish-tip" role="note" aria-labelledby="admonition-ready-for-more-title">
<div class="admonition-title">
<div id="admonition-ready-for-more-title">
<p>Ready for More?</p>
</div>
<a class="admonition-anchor-link" href="optics/prisms.html#admonition-ready-for-more"></a>
</div>
<div>
<p>Once you're comfortable with these prism fundamentals, explore <a href="optics/advanced_prism_patterns.html">Advanced Prism Patterns</a> for production-ready patterns including:</p>
<ul>
<li>Configuration management with layered prism composition</li>
<li>API response handling with type-safe error recovery</li>
<li>Data validation pipelines and event processing systems</li>
<li>State machine implementations and plugin architectures</li>
<li>Performance optimisation and testing strategies</li>
</ul>
</div>
</div>
<hr />
<h2 id="further-reading-7"><a class="header" href="#further-reading-7">Further Reading</a></h2>
<p>For deeper understanding of prisms and optics theory:</p>
<ul>
<li><a href="https://arxiv.org/abs/1703.10857">Profunctor Optics: Modular Data Accessors</a> - Academic foundation for modern optics</li>
<li><a href="https://page.mi.fu-berlin.de/scravy/realworldhaskell/materialien/the-essence-of-functional-programming.pdf">The Essence of Functional Programming</a> - Wadler's seminal paper on monads and functors</li>
<li><a href="https://www.optics.dev/Monocle/">Lens in Scala (Monocle)</a> - Production-ready Scala optics library with extensive examples</li>
<li><a href="https://hackage.haskell.org/package/lens">Haskell Lens Library</a> - Canonical reference implementation</li>
<li><a href="https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial">A Little Lens Starter Tutorial</a> - Beginner-friendly introduction to optics concepts</li>
</ul>
<hr />
<p><strong>Previous:</strong> <a href="optics/lenses.html">Lenses: Working with Product Types</a>
<strong>Next:</strong> <a href="optics/advanced_prism_patterns.html">Advanced Prism Patterns</a> | <a href="optics/iso.html">Isomorphisms: Data Equivalence</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="advanced-prism-patterns"><a class="header" href="#advanced-prism-patterns">Advanced Prism Patterns</a></h1>
<h2 id="real-world-applications-of-prisms-in-production-systems"><a class="header" href="#real-world-applications-of-prisms-in-production-systems"><em>Real-World Applications of Prisms in Production Systems</em></a></h2>
<p><img src="optics/../images/prism.jpeg" alt="prism-advanced.jpeg" /></p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="optics/advanced_prism_patterns.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>Configuration management with layered prism composition</li>
<li>API response handling with type-safe error recovery</li>
<li>Data validation pipelines using prisms for conditional processing</li>
<li>Event processing systems with prism-based routing</li>
<li>State machine implementations using prisms for transitions</li>
<li>Plugin architectures with type-safe variant handling</li>
<li>Performance optimisation patterns for production systems</li>
<li>Testing strategies for prism-heavy codebases</li>
</ul>
</div>
</div>
<div id="admonition-example-code" class="admonition admonish-note" role="note" aria-labelledby="admonition-example-code-title">
<div class="admonition-title">
<div id="admonition-example-code-title">
<p>Example Code</p>
</div>
<a class="admonition-anchor-link" href="optics/advanced_prism_patterns.html#admonition-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/ConfigurationManagementExample.java">ConfigurationManagementExample</a>
<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/ApiResponseHandlingExample.java">ApiResponseHandlingExample</a>
<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/DataValidationPipelineExample.java">DataValidationPipelineExample</a>
<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/EventProcessingExample.java">EventProcessingExample</a>
<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/StateMachineExample.java">StateMachineExample</a>
<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/PluginSystemExample.java">PluginSystemExample</a></p>
</div>
</div>
<p>This guide explores sophisticated prism patterns encountered in production Java applications. We'll move beyond basic type matching to examine how prisms enable elegant solutions to complex architectural problems.</p>
<div id="admonition-prerequisites" class="admonition admonish-note" role="note" aria-labelledby="admonition-prerequisites-title">
<div class="admonition-title">
<div id="admonition-prerequisites-title">
<p>Prerequisites</p>
</div>
<a class="admonition-anchor-link" href="optics/advanced_prism_patterns.html#admonition-prerequisites"></a>
</div>
<div>
<p>This guide assumes familiarity with prism fundamentals including <code>getOptional()</code>, <code>build()</code>, convenience methods (<code>matches()</code>, <code>modify()</code>, <code>modifyWhen()</code>, etc.), and the <code>Prisms</code> utility class. If you're new to prisms, start with <a href="optics/prisms.html">Prisms: A Practical Guide</a> which covers:</p>
<ul>
<li>Core prism operations and type-safe variant handling</li>
<li>The 7 convenience methods for streamlined operations</li>
<li>The <code>Prisms</code> utility class for common patterns</li>
<li>Composition with lenses and traversals</li>
</ul>
</div>
</div>
<hr />
<h2 id="pattern-1-configuration-management"><a class="header" href="#pattern-1-configuration-management">Pattern 1: Configuration Management</a></h2>
<h3 id="type-safe-layered-configuration-resolution"><a class="header" href="#type-safe-layered-configuration-resolution"><em>Type-Safe, Layered Configuration Resolution</em></a></h3>
<p>Configuration systems often deal with multiple sources (environment variables, files, defaults) and various data types. Prisms provide a type-safe way to navigate this complexity.</p>
<h3 id="the-challenge"><a class="header" href="#the-challenge">The Challenge</a></h3>
<pre><code class="language-java">// Traditional approach: brittle and verbose
Object rawValue = config.get("database.connection.pool.size");
if (rawValue instanceof Integer i) {
    return i &gt; 0 ? i : DEFAULT_POOL_SIZE;
} else if (rawValue instanceof String s) {
    try {
        int parsed = Integer.parseInt(s);
        return parsed &gt; 0 ? parsed : DEFAULT_POOL_SIZE;
    } catch (NumberFormatException e) {
        return DEFAULT_POOL_SIZE;
    }
}
return DEFAULT_POOL_SIZE;
</code></pre>
<h3 id="the-prism-solution"><a class="header" href="#the-prism-solution">The Prism Solution</a></h3>
<pre><code class="language-java">@GeneratePrisms
sealed interface ConfigValue permits StringValue, IntValue, BoolValue, NestedConfig {}

record StringValue(String value) implements ConfigValue {}
record IntValue(int value) implements ConfigValue {}
record BoolValue(boolean value) implements ConfigValue {}
record NestedConfig(Map&lt;String, ConfigValue&gt; values) implements ConfigValue {}

public class ConfigResolver {
    private static final Prism&lt;ConfigValue, IntValue&gt; INT =
        ConfigValuePrisms.intValue();
    private static final Prism&lt;ConfigValue, StringValue&gt; STRING =
        ConfigValuePrisms.stringValue();

    public static int getPoolSize(ConfigValue value) {
        // Try integer first, fall back to parsing string
        return INT.mapOptional(IntValue::value, value)
            .filter(i -&gt; i &gt; 0)
            .or(() -&gt; STRING.mapOptional(StringValue::value, value)
                .flatMap(ConfigResolver::safeParseInt)
                .filter(i -&gt; i &gt; 0))
            .orElse(DEFAULT_POOL_SIZE);
    }

    private static Optional&lt;Integer&gt; safeParseInt(String s) {
        try {
            return Optional.of(Integer.parseInt(s));
        } catch (NumberFormatException e) {
            return Optional.empty();
        }
    }
}
</code></pre>
<h3 id="nested-configuration-access"><a class="header" href="#nested-configuration-access">Nested Configuration Access</a></h3>
<pre><code class="language-java">// Build a type-safe path through nested configuration
Prism&lt;ConfigValue, NestedConfig&gt; nested = ConfigValuePrisms.nestedConfig();
Lens&lt;NestedConfig, Map&lt;String, ConfigValue&gt;&gt; values = NestedConfigLenses.values();

Traversal&lt;ConfigValue, ConfigValue&gt; databaseConfig =
    nested.asTraversal()
        .andThen(values.asTraversal())
        .andThen(Traversals.forMap("database"))
        .andThen(nested.asTraversal())
        .andThen(values.asTraversal())
        .andThen(Traversals.forMap("connection"));

// Extract with fallback
ConfigValue rootConfig = loadConfiguration(); // Top-level configuration object
Optional&lt;ConfigValue&gt; connConfig = Traversals.getAll(databaseConfig, rootConfig)
    .stream().findFirst();
</code></pre>
<div id="admonition-configuration-best-practices" class="admonition admonish-tip" role="note" aria-labelledby="admonition-configuration-best-practices-title">
<div class="admonition-title">
<div id="admonition-configuration-best-practices-title">
<p>Configuration Best Practices</p>
</div>
<a class="admonition-anchor-link" href="optics/advanced_prism_patterns.html#admonition-configuration-best-practices"></a>
</div>
<div>
<ul>
<li><strong>Cache composed prisms</strong>: Configuration paths don't change at runtime</li>
<li><strong>Use <code>orElse()</code> chains</strong>: Handle type coercion gracefully</li>
<li><strong>Validate at load time</strong>: Use <code>modifyWhen()</code> to enforce constraints</li>
<li><strong>Provide clear defaults</strong>: Always have fallback values</li>
</ul>
</div>
</div>
<hr />
<h2 id="pattern-2-api-response-handling"><a class="header" href="#pattern-2-api-response-handling">Pattern 2: API Response Handling</a></h2>
<h3 id="type-safe-http-response-processing"><a class="header" href="#type-safe-http-response-processing"><em>Type-Safe HTTP Response Processing</em></a></h3>
<p>Modern APIs return varying response types based on status codes. Prisms provide elegant error handling and recovery strategies.</p>
<h3 id="the-challenge-1"><a class="header" href="#the-challenge-1">The Challenge</a></h3>
<pre><code class="language-java">// Traditional approach: error-prone branching
if (response.status() == 200) {
    return processSuccess((SuccessResponse) response);
} else if (response.status() == 400) {
    ValidationError err = (ValidationError) response;
    return handleValidation(err);
} else if (response.status() == 500) {
    return handleServerError((ServerError) response);
} else if (response.status() == 429) {
    return retryWithBackoff((RateLimitError) response);
}
// What about 401, 403, 404, ...?
</code></pre>
<h3 id="the-prism-solution-1"><a class="header" href="#the-prism-solution-1">The Prism Solution</a></h3>
<pre><code class="language-java">@GeneratePrisms
@GenerateLenses
sealed interface ApiResponse permits Success, ValidationError, ServerError,
                                     RateLimitError, AuthError, NotFoundError {}

record Success(JsonValue data, int statusCode) implements ApiResponse {}
record ValidationError(List&lt;String&gt; errors, String field) implements ApiResponse {}
record ServerError(String message, String traceId) implements ApiResponse {}
record RateLimitError(long retryAfterMs) implements ApiResponse {}
record AuthError(String realm) implements ApiResponse {}
record NotFoundError(String resource) implements ApiResponse {}

public class ApiHandler {
    // Reusable prisms for each response type
    private static final Prism&lt;ApiResponse, Success&gt; SUCCESS =
        ApiResponsePrisms.success();
    private static final Prism&lt;ApiResponse, ValidationError&gt; VALIDATION =
        ApiResponsePrisms.validationError();
    private static final Prism&lt;ApiResponse, RateLimitError&gt; RATE_LIMIT =
        ApiResponsePrisms.rateLimitError();
    private static final Prism&lt;ApiResponse, ServerError&gt; SERVER_ERROR =
        ApiResponsePrisms.serverError();

    public Either&lt;String, JsonValue&gt; handleResponse(ApiResponse response) {
        // Try success first
        return SUCCESS.mapOptional(Success::data, response)
            .map(Either::&lt;String, JsonValue&gt;right)
            // Then validation errors
            .or(() -&gt; VALIDATION.mapOptional(
                err -&gt; Either.&lt;String, JsonValue&gt;left(
                    "Validation failed: " + String.join(", ", err.errors())
                ),
                response
            ))
            // Then server errors
            .or(() -&gt; SERVER_ERROR.mapOptional(
                err -&gt; Either.&lt;String, JsonValue&gt;left(
                    "Server error: " + err.message() + " [" + err.traceId() + "]"
                ),
                response
            ))
            .orElse(Either.left("Unknown error type"));
    }

    public boolean isRetryable(ApiResponse response) {
        return RATE_LIMIT.matches(response) || SERVER_ERROR.matches(response);
    }

    public Optional&lt;Long&gt; getRetryDelay(ApiResponse response) {
        return RATE_LIMIT.mapOptional(RateLimitError::retryAfterMs, response);
    }
}
</code></pre>
<h3 id="advanced-response-pipeline-with-fallbacks"><a class="header" href="#advanced-response-pipeline-with-fallbacks">Advanced: Response Pipeline with Fallbacks</a></h3>
<pre><code class="language-java">public class ResilientApiClient {
    public CompletableFuture&lt;JsonValue&gt; fetchWithFallbacks(String endpoint) {
        return primaryApi.call(endpoint)
            .thenCompose(response -&gt;
                SUCCESS.mapOptional(Success::data, response)
                    .map(CompletableFuture::completedFuture)
                    .or(() -&gt; RATE_LIMIT.mapOptional(
                        err -&gt; CompletableFuture.supplyAsync(
                            () -&gt; callSecondaryApi(endpoint),
                            delayedExecutor(err.retryAfterMs(), TimeUnit.MILLISECONDS)
                        ),
                        response
                    ))
                    .orElseGet(() -&gt; CompletableFuture.failedFuture(
                        new ApiException("Unrecoverable error")
                    ))
            );
    }
}
</code></pre>
<div id="admonition-production-considerations" class="admonition admonish-warning" role="note" aria-labelledby="admonition-production-considerations-title">
<div class="admonition-title">
<div id="admonition-production-considerations-title">
<p>Production Considerations</p>
</div>
<a class="admonition-anchor-link" href="optics/advanced_prism_patterns.html#admonition-production-considerations"></a>
</div>
<div>
<p>When using prisms for API handling:</p>
<ul>
<li><strong>Log unmatched cases</strong>: Track responses that don't match any prism</li>
<li><strong>Metrics</strong>: Count matches per prism type for monitoring</li>
<li><strong>Circuit breakers</strong>: Integrate retry logic with circuit breaker patterns</li>
<li><strong>Structured logging</strong>: Use <code>mapOptional()</code> to extract error details</li>
</ul>
</div>
</div>
<hr />
<h2 id="pattern-3-data-validation-pipelines"><a class="header" href="#pattern-3-data-validation-pipelines">Pattern 3: Data Validation Pipelines</a></h2>
<h3 id="composable-type-safe-validation-logic"><a class="header" href="#composable-type-safe-validation-logic"><em>Composable, Type-Safe Validation Logic</em></a></h3>
<p>Validation often requires checking different data types and applying conditional rules. Prisms make validation logic declarative and reusable.</p>
<h3 id="the-challenge-2"><a class="header" href="#the-challenge-2">The Challenge</a></h3>
<p>ETL pipelines process heterogeneous data where validation rules depend on data types:</p>
<pre><code class="language-java">// Traditional approach: imperative branching
List&lt;ValidationError&gt; errors = new ArrayList&lt;&gt;();
for (Object value : row.values()) {
    if (value instanceof String s) {
        if (s.length() &gt; MAX_STRING_LENGTH) {
            errors.add(new ValidationError("String too long: " + s));
        }
    } else if (value instanceof Integer i) {
        if (i &lt; 0) {
            errors.add(new ValidationError("Negative integer: " + i));
        }
    }
    // ... more type checks
}
</code></pre>
<h3 id="the-prism-solution-2"><a class="header" href="#the-prism-solution-2">The Prism Solution</a></h3>
<pre><code class="language-java">@GeneratePrisms
sealed interface DataValue permits StringData, IntData, DoubleData, NullData {}

record StringData(String value) implements DataValue {}
record IntData(int value) implements DataValue {}
record DoubleData(double value) implements DataValue {}
record NullData() implements DataValue {}

public class ValidationPipeline {
    // Validation rules as prism transformations
    private static final Prism&lt;DataValue, StringData&gt; STRING =
        DataValuePrisms.stringData();
    private static final Prism&lt;DataValue, IntData&gt; INT =
        DataValuePrisms.intData();

    public static List&lt;String&gt; validate(List&lt;DataValue&gt; row) {
        return row.stream()
            .flatMap(value -&gt; Stream.concat(
                // Validate strings
                STRING.mapOptional(
                    s -&gt; s.value().length() &gt; MAX_STRING_LENGTH
                        ? Optional.of("String too long: " + s.value())
                        : Optional.empty(),
                    value
                ).stream(),
                // Validate integers
                INT.mapOptional(
                    i -&gt; i.value() &lt; 0
                        ? Optional.of("Negative integer: " + i.value())
                        : Optional.empty(),
                    value
                ).stream()
            ))
            .collect(Collectors.toList());
    }

    // Sanitise data by modifying only invalid values
    public static List&lt;DataValue&gt; sanitise(List&lt;DataValue&gt; row) {
        return row.stream()
            .map(value -&gt;
                // Truncate long strings
                STRING.modifyWhen(
                    s -&gt; s.value().length() &gt; MAX_STRING_LENGTH,
                    s -&gt; new StringData(s.value().substring(0, MAX_STRING_LENGTH)),
                    value
                )
            )
            .map(value -&gt;
                // Clamp negative integers to zero
                INT.modifyWhen(
                    i -&gt; i.value() &lt; 0,
                    i -&gt; new IntData(0),
                    value
                )
            )
            .collect(Collectors.toList());
    }
}
</code></pre>
<h3 id="advanced-validation-with-accumulation"><a class="header" href="#advanced-validation-with-accumulation">Advanced: Validation with Accumulation</a></h3>
<p>Using <code>Either</code> and prisms for validation that accumulates errors:</p>
<pre><code class="language-java">public class AccumulatingValidator {
    public static Either&lt;List&lt;String&gt;, List&lt;DataValue&gt;&gt; validateAll(List&lt;DataValue&gt; row) {
        List&lt;String&gt; errors = new ArrayList&lt;&gt;();
        List&lt;DataValue&gt; sanitised = new ArrayList&lt;&gt;();

        for (DataValue value : row) {
            // Validate and potentially sanitise each value
            DataValue processed = value;

            // Check strings
            processed = STRING.modifyWhen(
                s -&gt; s.value().length() &gt; MAX_STRING_LENGTH,
                s -&gt; {
                    errors.add("Truncated: " + s.value());
                    return new StringData(s.value().substring(0, MAX_STRING_LENGTH));
                },
                processed
            );

            // Check integers
            processed = INT.modifyWhen(
                i -&gt; i.value() &lt; 0,
                i -&gt; {
                    errors.add("Clamped negative: " + i.value());
                    return new IntData(0);
                },
                processed
            );

            sanitised.add(processed);
        }

        return errors.isEmpty()
            ? Either.right(sanitised)
            : Either.left(errors);
    }
}
</code></pre>
<div id="admonition-validation-pipeline-best-practices" class="admonition admonish-tip" role="note" aria-labelledby="admonition-validation-pipeline-best-practices-title">
<div class="admonition-title">
<div id="admonition-validation-pipeline-best-practices-title">
<p>Validation Pipeline Best Practices</p>
</div>
<a class="admonition-anchor-link" href="optics/advanced_prism_patterns.html#admonition-validation-pipeline-best-practices"></a>
</div>
<div>
<ul>
<li><strong>Compose validators</strong>: Build complex validation from simple prism rules</li>
<li><strong>Use <code>modifyWhen()</code> for sanitisation</strong>: Fix values whilst tracking changes</li>
<li><strong>Accumulate errors</strong>: Don't fail-fast; collect all validation issues</li>
<li><strong>Type-specific rules</strong>: Let prisms dispatch to appropriate validators</li>
</ul>
</div>
</div>
<hr />
<h2 id="pattern-4-event-processing"><a class="header" href="#pattern-4-event-processing">Pattern 4: Event Processing</a></h2>
<h3 id="type-safe-event-routing-and-handling"><a class="header" href="#type-safe-event-routing-and-handling"><em>Type-Safe Event Routing and Handling</em></a></h3>
<p>Event-driven systems receive heterogeneous event types that require different processing logic. Prisms provide type-safe routing without <code>instanceof</code> cascades.</p>
<h3 id="the-challenge-3"><a class="header" href="#the-challenge-3">The Challenge</a></h3>
<pre><code class="language-java">// Traditional approach: brittle event dispatching
public void handleEvent(Event event) {
    if (event instanceof UserCreated uc) {
        sendWelcomeEmail(uc.userId(), uc.email());
        provisionResources(uc.userId());
    } else if (event instanceof UserDeleted ud) {
        cleanupResources(ud.userId());
        archiveData(ud.userId());
    } else if (event instanceof OrderPlaced op) {
        processPayment(op.orderId());
        updateInventory(op.items());
    }
    // Grows with each new event type
}
</code></pre>
<h3 id="the-prism-solution-3"><a class="header" href="#the-prism-solution-3">The Prism Solution</a></h3>
<pre><code class="language-java">@GeneratePrisms
@GenerateLenses
sealed interface DomainEvent permits UserCreated, UserDeleted, UserUpdated,
                                     OrderPlaced, OrderCancelled, PaymentProcessed {}

record UserCreated(String userId, String email, Instant timestamp) implements DomainEvent {}
record UserDeleted(String userId, Instant timestamp) implements DomainEvent {}
record UserUpdated(String userId, Map&lt;String, String&gt; changes, Instant timestamp) implements DomainEvent {}
record OrderPlaced(String orderId, List&lt;LineItem&gt; items, Instant timestamp) implements DomainEvent {}
record OrderCancelled(String orderId, String reason, Instant timestamp) implements DomainEvent {}
record PaymentProcessed(String orderId, double amount, Instant timestamp) implements DomainEvent {}

public class EventRouter {
    private static final Prism&lt;DomainEvent, UserCreated&gt; USER_CREATED =
        DomainEventPrisms.userCreated();
    private static final Prism&lt;DomainEvent, UserDeleted&gt; USER_DELETED =
        DomainEventPrisms.userDeleted();
    private static final Prism&lt;DomainEvent, OrderPlaced&gt; ORDER_PLACED =
        DomainEventPrisms.orderPlaced();

    // Declarative event handler registry
    private final Map&lt;Prism&lt;DomainEvent, ?&gt;, Consumer&lt;DomainEvent&gt;&gt; handlers = Map.of(
        USER_CREATED, event -&gt; USER_CREATED.mapOptional(
            uc -&gt; {
                sendWelcomeEmail(uc.userId(), uc.email());
                provisionResources(uc.userId());
                return uc;
            },
            event
        ),
        USER_DELETED, event -&gt; USER_DELETED.mapOptional(
            ud -&gt; {
                cleanupResources(ud.userId());
                archiveData(ud.userId());
                return ud;
            },
            event
        ),
        ORDER_PLACED, event -&gt; ORDER_PLACED.mapOptional(
            op -&gt; {
                processPayment(op.orderId());
                updateInventory(op.items());
                return op;
            },
            event
        )
    );

    public void route(DomainEvent event) {
        handlers.entrySet().stream()
            .filter(entry -&gt; entry.getKey().matches(event))
            .findFirst()
            .ifPresentOrElse(
                entry -&gt; entry.getValue().accept(event),
                () -&gt; log.warn("Unhandled event type: {}", event.getClass())
            );
    }
}
</code></pre>
<h3 id="advanced-event-filtering-and-transformation"><a class="header" href="#advanced-event-filtering-and-transformation">Advanced: Event Filtering and Transformation</a></h3>
<pre><code class="language-java">public class EventProcessor {
    // Process only recent user events
    public List&lt;DomainEvent&gt; getRecentUserEvents(
        List&lt;DomainEvent&gt; events,
        Instant since
    ) {
        Prism&lt;DomainEvent, UserCreated&gt; userCreated = USER_CREATED;
        Prism&lt;DomainEvent, UserDeleted&gt; userDeleted = USER_DELETED;

        return events.stream()
            .filter(e -&gt;
                // Match user events with timestamp filter
                userCreated.mapOptional(
                    uc -&gt; uc.timestamp().isAfter(since) ? uc : null,
                    e
                ).isPresent()
                ||
                userDeleted.mapOptional(
                    ud -&gt; ud.timestamp().isAfter(since) ? ud : null,
                    e
                ).isPresent()
            )
            .collect(Collectors.toList());
    }

    // Transform events for audit log
    public List&lt;AuditEntry&gt; toAuditLog(List&lt;DomainEvent&gt; events) {
        return events.stream()
            .flatMap(event -&gt;
                // Extract audit entries from different event types
                USER_CREATED.mapOptional(
                    uc -&gt; new AuditEntry("USER_CREATED", uc.userId(), uc.timestamp()),
                    event
                ).or(() -&gt;
                    ORDER_PLACED.mapOptional(
                        op -&gt; new AuditEntry("ORDER_PLACED", op.orderId(), op.timestamp()),
                        event
                    )
                ).stream()
            )
            .collect(Collectors.toList());
    }
}
</code></pre>
<div id="admonition-event-processing-best-practices" class="admonition admonish-tip" role="note" aria-labelledby="admonition-event-processing-best-practices-title">
<div class="admonition-title">
<div id="admonition-event-processing-best-practices-title">
<p>Event Processing Best Practices</p>
</div>
<a class="admonition-anchor-link" href="optics/advanced_prism_patterns.html#admonition-event-processing-best-practices"></a>
</div>
<div>
<ul>
<li><strong>Registry pattern</strong>: Map prisms to handlers for extensibility</li>
<li><strong>Metrics</strong>: Track event types processed using <code>matches()</code></li>
<li><strong>Dead letter queue</strong>: Log events that match no prism</li>
<li><strong>Event sourcing</strong>: Use prisms to replay specific event types</li>
</ul>
</div>
</div>
<hr />
<h2 id="pattern-5-state-machines"><a class="header" href="#pattern-5-state-machines">Pattern 5: State Machines</a></h2>
<h3 id="type-safe-state-transitions"><a class="header" href="#type-safe-state-transitions"><em>Type-Safe State Transitions</em></a></h3>
<p>State machines with complex transition rules benefit from prisms' ability to safely match states and transform between them.</p>
<h3 id="the-challenge-4"><a class="header" href="#the-challenge-4">The Challenge</a></h3>
<pre><code class="language-java">// Traditional approach: verbose state management
public Order transition(Order order, OrderEvent event) {
    if (order.state() instanceof Pending &amp;&amp; event instanceof PaymentReceived) {
        return order.withState(new Processing(((PaymentReceived) event).transactionId()));
    } else if (order.state() instanceof Processing &amp;&amp; event instanceof ShippingCompleted) {
        return order.withState(new Shipped(((ShippingCompleted) event).trackingNumber()));
    }
    // Many more transitions...
    throw new IllegalStateException("Invalid transition");
}
</code></pre>
<h3 id="the-prism-solution-4"><a class="header" href="#the-prism-solution-4">The Prism Solution</a></h3>
<pre><code class="language-java">@GeneratePrisms
sealed interface OrderState permits Pending, Processing, Shipped, Delivered, Cancelled {}

record Pending(Instant createdAt) implements OrderState {}
record Processing(String transactionId, Instant startedAt) implements OrderState {}
record Shipped(String trackingNumber, Instant shippedAt) implements OrderState {}
record Delivered(Instant deliveredAt) implements OrderState {}
record Cancelled(String reason, Instant cancelledAt) implements OrderState {}

@GeneratePrisms
sealed interface OrderEvent permits PaymentReceived, ShippingCompleted,
                                    DeliveryConfirmed, CancellationRequested {}

record PaymentReceived(String transactionId) implements OrderEvent {}
record ShippingCompleted(String trackingNumber) implements OrderEvent {}
record DeliveryConfirmed() implements OrderEvent {}
record CancellationRequested(String reason) implements OrderEvent {}

public class OrderStateMachine {
    private static final Prism&lt;OrderState, Pending&gt; PENDING =
        OrderStatePrisms.pending();
    private static final Prism&lt;OrderState, Processing&gt; PROCESSING =
        OrderStatePrisms.processing();
    private static final Prism&lt;OrderState, Shipped&gt; SHIPPED =
        OrderStatePrisms.shipped();

    private static final Prism&lt;OrderEvent, PaymentReceived&gt; PAYMENT =
        OrderEventPrisms.paymentReceived();
    private static final Prism&lt;OrderEvent, ShippingCompleted&gt; SHIPPING =
        OrderEventPrisms.shippingCompleted();
    private static final Prism&lt;OrderEvent, DeliveryConfirmed&gt; DELIVERY =
        OrderEventPrisms.deliveryConfirmed();

    // Define valid transitions as prism combinations
    public Optional&lt;OrderState&gt; transition(OrderState currentState, OrderEvent event) {
        // Pending -&gt; Processing (on payment)
        if (PENDING.matches(currentState) &amp;&amp; PAYMENT.matches(event)) {
            return PAYMENT.mapOptional(
                payment -&gt; new Processing(payment.transactionId(), Instant.now()),
                event
            );
        }

        // Processing -&gt; Shipped (on shipping)
        if (PROCESSING.matches(currentState) &amp;&amp; SHIPPING.matches(event)) {
            return SHIPPING.mapOptional(
                shipping -&gt; new Shipped(shipping.trackingNumber(), Instant.now()),
                event
            );
        }

        // Shipped -&gt; Delivered (on confirmation)
        if (SHIPPED.matches(currentState) &amp;&amp; DELIVERY.matches(event)) {
            return Optional.of(new Delivered(Instant.now()));
        }

        return Optional.empty(); // Invalid transition
    }

    // Guard conditions using prisms
    public boolean canCancel(OrderState state) {
        // Can cancel if Pending or Processing
        return PENDING.matches(state) || PROCESSING.matches(state);
    }

    // Extract state-specific data
    public Optional&lt;String&gt; getTrackingNumber(OrderState state) {
        return SHIPPED.mapOptional(Shipped::trackingNumber, state);
    }
}
</code></pre>
<h3 id="advanced-transition-table"><a class="header" href="#advanced-transition-table">Advanced: Transition Table</a></h3>
<pre><code class="language-java">import org.higherkindedj.optics.util.Pair; // Pair utility from hkj-optics

public class AdvancedStateMachine {
    // Define transitions as a declarative table
    private static final Map&lt;
        Pair&lt;Prism&lt;OrderState, ?&gt;, Prism&lt;OrderEvent, ?&gt;&gt;,
        BiFunction&lt;OrderState, OrderEvent, OrderState&gt;
    &gt; TRANSITIONS = Map.of(
        Pair.of(PENDING, PAYMENT),
        (state, event) -&gt; PAYMENT.mapOptional(
            p -&gt; new Processing(p.transactionId(), Instant.now()),
            event
        ).orElse(state),

        Pair.of(PROCESSING, SHIPPING),
        (state, event) -&gt; SHIPPING.mapOptional(
            s -&gt; new Shipped(s.trackingNumber(), Instant.now()),
            event
        ).orElse(state)
    );

    public OrderState process(OrderState state, OrderEvent event) {
        return TRANSITIONS.entrySet().stream()
            .filter(entry -&gt;
                entry.getKey().first().matches(state) &amp;&amp;
                entry.getKey().second().matches(event)
            )
            .findFirst()
            .map(entry -&gt; entry.getValue().apply(state, event))
            .orElseThrow(() -&gt; new IllegalStateException(
                "Invalid transition: " + state + " -&gt; " + event
            ));
    }
}
</code></pre>
<div id="admonition-state-machine-best-practices" class="admonition admonish-tip" role="note" aria-labelledby="admonition-state-machine-best-practices-title">
<div class="admonition-title">
<div id="admonition-state-machine-best-practices-title">
<p>State Machine Best Practices</p>
</div>
<a class="admonition-anchor-link" href="optics/advanced_prism_patterns.html#admonition-state-machine-best-practices"></a>
</div>
<div>
<ul>
<li><strong>Exhaustive matching</strong>: Ensure all valid transitions are covered</li>
<li><strong>Guard conditions</strong>: Use <code>matches()</code> for pre-condition checks</li>
<li><strong>Immutability</strong>: States are immutable; transitions create new instances</li>
<li><strong>Audit trail</strong>: Log state transitions using prism metadata</li>
</ul>
</div>
</div>
<hr />
<h2 id="pattern-6-plugin-systems"><a class="header" href="#pattern-6-plugin-systems">Pattern 6: Plugin Systems</a></h2>
<h3 id="type-safe-plugin-discovery-and-execution"><a class="header" href="#type-safe-plugin-discovery-and-execution"><em>Type-Safe Plugin Discovery and Execution</em></a></h3>
<p>Plugin architectures require dynamic dispatch to various plugin types whilst maintaining type safety.</p>
<h3 id="the-challenge-5"><a class="header" href="#the-challenge-5">The Challenge</a></h3>
<pre><code class="language-java">// Traditional approach: reflection and casting
public void executePlugin(Plugin plugin, Object context) {
    if (plugin.getClass().getName().equals("DatabasePlugin")) {
        ((DatabasePlugin) plugin).execute((DatabaseContext) context);
    } else if (plugin.getClass().getName().equals("FileSystemPlugin")) {
        ((FileSystemPlugin) plugin).execute((FileSystemContext) context);
    }
    // Fragile and unsafe
}
</code></pre>
<h3 id="the-prism-solution-5"><a class="header" href="#the-prism-solution-5">The Prism Solution</a></h3>
<pre><code class="language-java">@GeneratePrisms
sealed interface Plugin permits DatabasePlugin, FileSystemPlugin,
                                 NetworkPlugin, ComputePlugin {}

record DatabasePlugin(String query, DatabaseConfig config) implements Plugin {
    public Result execute(DatabaseContext ctx) {
        return ctx.executeQuery(query, config);
    }
}

record FileSystemPlugin(Path path, FileOperation operation) implements Plugin {
    public Result execute(FileSystemContext ctx) {
        return ctx.performOperation(path, operation);
    }
}

record NetworkPlugin(URL endpoint, HttpMethod method) implements Plugin {
    public Result execute(NetworkContext ctx) {
        return ctx.makeRequest(endpoint, method);
    }
}

record ComputePlugin(String script, Runtime runtime) implements Plugin {
    public Result execute(ComputeContext ctx) {
        return ctx.runScript(script, runtime);
    }
}

public class PluginExecutor {
    private static final Prism&lt;Plugin, DatabasePlugin&gt; DB =
        PluginPrisms.databasePlugin();
    private static final Prism&lt;Plugin, FileSystemPlugin&gt; FS =
        PluginPrisms.fileSystemPlugin();
    private static final Prism&lt;Plugin, NetworkPlugin&gt; NET =
        PluginPrisms.networkPlugin();
    private static final Prism&lt;Plugin, ComputePlugin&gt; COMPUTE =
        PluginPrisms.computePlugin();

    public Either&lt;String, Result&gt; execute(
        Plugin plugin,
        ExecutionContext context
    ) {
        // Type-safe dispatch to appropriate handler
        return DB.mapOptional(
            dbPlugin -&gt; context.getDatabaseContext()
                .map(dbPlugin::execute)
                .map(Either::&lt;String, Result&gt;right)
                .orElse(Either.left("Database context not available")),
            plugin
        ).or(() -&gt;
            FS.mapOptional(
                fsPlugin -&gt; context.getFileSystemContext()
                    .map(fsPlugin::execute)
                    .map(Either::&lt;String, Result&gt;right)
                    .orElse(Either.left("FileSystem context not available")),
                plugin
            )
        ).or(() -&gt;
            NET.mapOptional(
                netPlugin -&gt; context.getNetworkContext()
                    .map(netPlugin::execute)
                    .map(Either::&lt;String, Result&gt;right)
                    .orElse(Either.left("Network context not available")),
                plugin
            )
        ).or(() -&gt;
            COMPUTE.mapOptional(
                computePlugin -&gt; context.getComputeContext()
                    .map(computePlugin::execute)
                    .map(Either::&lt;String, Result&gt;right)
                    .orElse(Either.left("Compute context not available")),
                plugin
            )
        ).orElse(Either.left("Unknown plugin type"));
    }

    // Validate plugin before execution
    public List&lt;String&gt; validate(Plugin plugin) {
        List&lt;String&gt; errors = new ArrayList&lt;&gt;();

        DB.mapOptional(p -&gt; {
            if (p.query().isEmpty()) {
                errors.add("Database query cannot be empty");
            }
            return p;
        }, plugin);

        FS.mapOptional(p -&gt; {
            if (!Files.exists(p.path())) {
                errors.add("File path does not exist: " + p.path());
            }
            return p;
        }, plugin);

        return errors;
    }
}
</code></pre>
<h3 id="advanced-plugin-composition"><a class="header" href="#advanced-plugin-composition">Advanced: Plugin Composition</a></h3>
<pre><code class="language-java">public class CompositePlugin {
    // Combine multiple plugins into a pipeline
    public static Plugin pipeline(List&lt;Plugin&gt; plugins) {
        return new CompositePluginImpl(plugins);
    }

    // Filter plugins by type for batch operations
    public static List&lt;DatabasePlugin&gt; getAllDatabasePlugins(List&lt;Plugin&gt; plugins) {
        Prism&lt;Plugin, DatabasePlugin&gt; dbPrism = DB;
        return plugins.stream()
            .flatMap(p -&gt; dbPrism.getOptional(p).stream())
            .collect(Collectors.toList());
    }

    // Transform plugins based on environment
    public static List&lt;Plugin&gt; adaptForEnvironment(
        List&lt;Plugin&gt; plugins,
        Environment env
    ) {
        return plugins.stream()
            .map(plugin -&gt;
                // Modify database plugins for different environments
                DB.modifyWhen(
                    db -&gt; env == Environment.PRODUCTION,
                    db -&gt; new DatabasePlugin(
                        db.query(),
                        db.config().withReadReplica()
                    ),
                    plugin
                )
            )
            .collect(Collectors.toList());
    }
}
</code></pre>
<div id="admonition-plugin-architecture-best-practices" class="admonition admonish-tip" role="note" aria-labelledby="admonition-plugin-architecture-best-practices-title">
<div class="admonition-title">
<div id="admonition-plugin-architecture-best-practices-title">
<p>Plugin Architecture Best Practices</p>
</div>
<a class="admonition-anchor-link" href="optics/advanced_prism_patterns.html#admonition-plugin-architecture-best-practices"></a>
</div>
<div>
<ul>
<li><strong>Capability detection</strong>: Use <code>matches()</code> to check plugin capabilities</li>
<li><strong>Fail-safe execution</strong>: Always handle unmatched plugin types</li>
<li><strong>Plugin validation</strong>: Use prisms to validate configuration before execution</li>
<li><strong>Metrics</strong>: Track plugin execution by type using prism-based routing</li>
</ul>
</div>
</div>
<hr />
<h2 id="performance-optimisation-patterns"><a class="header" href="#performance-optimisation-patterns">Performance Optimisation Patterns</a></h2>
<h3 id="caching-composed-prisms"><a class="header" href="#caching-composed-prisms">Caching Composed Prisms</a></h3>
<pre><code class="language-java">public class OptimisedPrismCache {
    // Cache expensive optic compositions
    private static final Map&lt;String, Object&gt; OPTIC_CACHE =
        new ConcurrentHashMap&lt;&gt;();

    @SuppressWarnings("unchecked")
    public static &lt;T&gt; T getCached(
        String key,
        Supplier&lt;T&gt; factory
    ) {
        return (T) OPTIC_CACHE.computeIfAbsent(key, k -&gt; factory.get());
    }

    // Example usage: caching a composed traversal
    private static final Traversal&lt;Config, String&gt; DATABASE_HOST =
        getCached("config.database.host", () -&gt;
            ConfigLenses.database()
                .asTraversal()
                .andThen(Prisms.some().asTraversal())
                .andThen(Prisms.right().asTraversal())
                .andThen(DatabaseSettingsLenses.host().asTraversal())
        );
}
</code></pre>
<h3 id="bulk-operations-with-prisms"><a class="header" href="#bulk-operations-with-prisms">Bulk Operations with Prisms</a></h3>
<pre><code class="language-java">public class BulkProcessor {
    // Process multiple items efficiently
    public static &lt;S, A&gt; List&lt;A&gt; extractAll(
        Prism&lt;S, A&gt; prism,
        List&lt;S&gt; items
    ) {
        return items.stream()
            .flatMap(item -&gt; prism.getOptional(item).stream())
            .collect(Collectors.toList());
    }

    // Partition items by prism match
    public static &lt;S, A&gt; Map&lt;Boolean, List&lt;S&gt;&gt; partitionByMatch(
        Prism&lt;S, A&gt; prism,
        List&lt;S&gt; items
    ) {
        return items.stream()
            .collect(Collectors.partitioningBy(prism::matches));
    }
}
</code></pre>
<hr />
<h2 id="testing-strategies"><a class="header" href="#testing-strategies">Testing Strategies</a></h2>
<h3 id="testing-prism-based-logic"><a class="header" href="#testing-prism-based-logic">Testing Prism-Based Logic</a></h3>
<pre><code class="language-java">public class PrismTestPatterns {
    @Test
    void testPrismMatching() {
        Prism&lt;ApiResponse, Success&gt; success = ApiResponsePrisms.success();

        ApiResponse successResponse = new Success(jsonData, 200);
        ApiResponse errorResponse = new ServerError("Error", "trace123");

        // Verify matching behaviour
        assertTrue(success.matches(successResponse));
        assertFalse(success.matches(errorResponse));

        // Verify extraction
        assertThat(success.getOptional(successResponse))
            .isPresent()
            .get()
            .extracting(Success::statusCode)
            .isEqualTo(200);
    }

    @Test
    void testComposedPrisms() {
        // Test deep prism compositions
        Prism&lt;Config, String&gt; hostPrism = buildHostPrism();

        Config validConfig = createValidConfig();
        Config invalidConfig = createInvalidConfig();

        assertThat(hostPrism.getOptional(validConfig)).isPresent();
        assertThat(hostPrism.getOptional(invalidConfig)).isEmpty();
    }

    @Test
    void testConditionalOperations() {
        Prism&lt;ConfigValue, IntValue&gt; intPrism = ConfigValuePrisms.intValue();

        ConfigValue value = new IntValue(42);

        // Test modifyWhen
        ConfigValue result = intPrism.modifyWhen(
            i -&gt; i.value() &gt; 0,
            i -&gt; new IntValue(i.value() * 2),
            value
        );

        assertThat(intPrism.getOptional(result))
            .isPresent()
            .get()
            .extracting(IntValue::value)
            .isEqualTo(84);
    }
}
</code></pre>
<hr />
<h2 id="further-reading-8"><a class="header" href="#further-reading-8">Further Reading</a></h2>
<p>For deeper understanding of optics theory and applications:</p>
<ul>
<li><a href="https://arxiv.org/abs/1703.10857">Profunctor Optics: Modular Data Accessors</a> - Academic foundations</li>
<li><a href="https://www.optics.dev/Monocle/">Lens in Scala (Monocle)</a> - Scala implementation and patterns</li>
<li><a href="https://hackage.haskell.org/package/lens">Haskell Lens Library</a> - Canonical reference</li>
<li><a href="https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial">A Little Lens Starter Tutorial</a> - Beginner-friendly introduction</li>
</ul>
<hr />
<p><strong>Previous:</strong> <a href="optics/prisms.html">Prisms: A Practical Guide</a>
<strong>Next:</strong> <a href="optics/iso.html">Isomorphisms: Data Equivalence</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="isomorphisms-a-practical-guide"><a class="header" href="#isomorphisms-a-practical-guide">Isomorphisms: A Practical Guide</a></h1>
<h2 id="data-equivalence-with-isos"><a class="header" href="#data-equivalence-with-isos"><em>Data Equivalence with Isos</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="optics/iso.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to define lossless, reversible conversions between equivalent types</li>
<li>Creating isomorphisms with <code>Iso.of(get, reverseGet)</code></li>
<li>Using <code>reverse()</code> to flip conversion directions</li>
<li>Step-by-step transformation workflows for data format conversion</li>
<li>Testing round-trip properties to ensure conversion correctness</li>
<li>When to use isos vs direct conversion methods vs manual adapters</li>
</ul>
</div>
</div>
<div id="admonition-example-code" class="admonition admonish-note" role="note" aria-labelledby="admonition-example-code-title">
<div class="admonition-title">
<div id="admonition-example-code-title">
<p>Example Code</p>
</div>
<a class="admonition-anchor-link" href="optics/iso.html#admonition-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/IsoUsageExample.java">IsoUsageExample</a></p>
</div>
</div>
<p>In the previous guides, we explored two essential optics: the <strong><code>Lens</code></strong>, for targeting data that <em>must</em> exist (a "has-a" relationship), and the <strong><code>Prism</code></strong>, for safely targeting data that <em>might</em> exist in a specific shape (an "is-a" relationship).</p>
<p>This leaves one final, fundamental question: what if you have two data types that are different in structure but hold the exact same information? How do you switch between them losslessly? For this, we need our final core optic: the <strong><code>Iso</code></strong>.</p>
<hr />
<h2 id="the-scenario-translating-between-equivalent-types"><a class="header" href="#the-scenario-translating-between-equivalent-types">The Scenario: Translating Between Equivalent Types</a></h2>
<p>An <strong><code>Iso</code></strong> (Isomorphism) is a "two-way street." It's an optic that represents a perfectly reversible, lossless conversion between two equivalent types. Think of it as a <strong>universal translator</strong> üîÑ or a type-safe adapter that you can compose with other optics.</p>
<p>An <code>Iso</code> is the right tool when you need to:</p>
<ul>
<li>Convert a wrapper type to its raw value (e.g., <code>UserId(long id)</code> &lt;-&gt; <code>long</code>).</li>
<li>Handle data encoding and decoding (e.g., <code>byte[]</code> &lt;-&gt; <code>Base64 String</code>).</li>
<li>Bridge two data structures that are informationally identical (e.g., a custom record and a generic tuple).</li>
</ul>
<p>Let's explore that last case. Imagine we have a <code>Point</code> record and want to convert it to a generic <code>Tuple2</code> to use with a library that operates on tuples.</p>
<p><strong>The Data Model:</strong></p>
<pre><code class="language-java">public record Point(int x, int y) {}

public record Tuple2&lt;A, B&gt;(A _1, B _2) {}
</code></pre>
<p>These two records can hold the same information. An <code>Iso</code> is the perfect way to formalize this relationship.</p>
<hr />
<h2 id="think-of-isos-like"><a class="header" href="#think-of-isos-like">Think of Isos Like...</a></h2>
<ul>
<li><strong>A universal translator</strong>: Perfect two-way conversion between equivalent representations</li>
<li><strong>A reversible adapter</strong>: Converts between formats without losing information</li>
<li><strong>A bridge</strong>: Connects two different structures that represent the same data</li>
<li><strong>A currency exchange</strong>: Converts between equivalent values at a 1:1 rate</li>
</ul>
<hr />
<h2 id="a-step-by-step-walkthrough-2"><a class="header" href="#a-step-by-step-walkthrough-2">A Step-by-Step Walkthrough</a></h2>
<h3 id="step-1-defining-an-iso"><a class="header" href="#step-1-defining-an-iso">Step 1: Defining an Iso</a></h3>
<p>Unlike Lenses and Prisms, which are often generated from annotations, Isos are almost always defined manually. This is because the logic for converting between two types is unique to your specific domain.</p>
<p>You create an <code>Iso</code> using the static <code>Iso.of(get, reverseGet)</code> constructor.</p>
<pre><code class="language-java">import org.higherkindedj.optics.Iso;
import org.higherkindedj.hkt.tuple.Tuple;
import org.higherkindedj.hkt.tuple.Tuple2;

public class Converters {
    public static Iso&lt;Point, Tuple2&lt;Integer, Integer&gt;&gt; pointToTuple() {
      return Iso.of(
          // Function to get the Tuple from the Point
          point -&gt; Tuple.of(point.x(), point.y()),
          // Function to get the Point from the Tuple
          tuple -&gt; new Point(tuple._1(), tuple._2())
      );
    }
}
</code></pre>
<h3 id="step-2-the-core-iso-operations"><a class="header" href="#step-2-the-core-iso-operations">Step 2: The Core Iso Operations</a></h3>
<p>An <code>Iso</code> provides two fundamental, lossless operations:</p>
<ul>
<li><strong><code>get(source)</code></strong>: The "forward" conversion (e.g., from <code>Point</code> to <code>Tuple2</code>).</li>
<li><strong><code>reverseGet(target)</code></strong>: The "backward" conversion (e.g., from <code>Tuple2</code> back to <code>Point</code>).</li>
</ul>
<p>Furthermore, every <code>Iso</code> is trivially reversible using the <strong><code>.reverse()</code></strong> method, which returns a new <code>Iso</code> with the "get" and "reverseGet" functions swapped.</p>
<pre><code class="language-java">var pointToTupleIso = Converters.pointToTuple();
var myPoint = new Point(10, 20);

// Forward conversion
Tuple2&lt;Integer, Integer&gt; myTuple = pointToTupleIso.get(myPoint); // -&gt; Tuple2[10, 20]

// Backward conversion using the reversed Iso
Point convertedBack = pointToTupleIso.reverse().get(myTuple); // -&gt; Point[10, 20]

// Demonstrate perfect round-trip
assert myPoint.equals(convertedBack); // Always true for lawful Isos
</code></pre>
<h3 id="step-3-composing-isos-as-a-bridge"><a class="header" href="#step-3-composing-isos-as-a-bridge">Step 3: Composing Isos as a Bridge</a></h3>
<p>The most powerful feature of an <code>Iso</code> is its ability to act as an adapter or "glue" between other optics. Because the conversion is lossless, an <code>Iso</code> preserves the "shape" of the optic it's composed with.</p>
<ul>
<li><code>Iso + Iso = Iso</code></li>
<li><strong><code>Iso + Lens = Lens</code></strong></li>
<li><strong><code>Iso + Prism = Prism</code></strong></li>
<li><strong><code>Iso + Traversal = Traversal</code></strong></li>
</ul>
<p>This second rule is incredibly useful. We can compose our <code>Iso&lt;Point, Tuple2&gt;</code> with a <code>Lens</code> that operates on a <code>Tuple2</code> to create a brand new <code>Lens</code> that operates directly on our <code>Point</code>!</p>
<pre><code class="language-java">// A standard Lens that gets the first element of any Tuple2
Lens&lt;Tuple2&lt;Integer, Integer&gt;, Integer&gt; tupleFirstElementLens = ...;

// The composition: Iso&lt;Point, Tuple2&gt; + Lens&lt;Tuple2, Integer&gt; = Lens&lt;Point, Integer&gt;
Lens&lt;Point, Integer&gt; pointToX = pointToTupleIso.andThen(tupleFirstElementLens);

// We can now use this new Lens to modify the 'x' coordinate of our Point
Point movedPoint = pointToX.modify(x -&gt; x + 5, myPoint); // -&gt; Point[15, 20]
</code></pre>
<p>The <code>Iso</code> acted as a bridge, allowing a generic <code>Lens</code> for tuples to work on our specific <code>Point</code> record.</p>
<hr />
<h2 id="when-to-use-isos-vs-other-approaches"><a class="header" href="#when-to-use-isos-vs-other-approaches">When to Use Isos vs Other Approaches</a></h2>
<h3 id="use-isos-when"><a class="header" href="#use-isos-when">Use Isos When:</a></h3>
<ul>
<li><strong>Data format conversion</strong> - Converting between equivalent representations</li>
<li><strong>Legacy system integration</strong> - Bridging old and new data formats</li>
<li><strong>Library interoperability</strong> - Adapting your types to work with external libraries</li>
<li><strong>Composable adapters</strong> - Building reusable conversion components</li>
</ul>
<pre><code class="language-java">// Perfect for format conversion
Iso&lt;LocalDate, String&gt; dateStringIso = Iso.of(
    date -&gt; date.format(DateTimeFormatter.ISO_LOCAL_DATE),
    dateStr -&gt; LocalDate.parse(dateStr, DateTimeFormatter.ISO_LOCAL_DATE)
);

// Use with any date-focused lens
Lens&lt;Person, String&gt; birthDateStringLens = 
    PersonLenses.birthDate().andThen(dateStringIso);
</code></pre>
<h3 id="use-direct-conversion-methods-when"><a class="header" href="#use-direct-conversion-methods-when">Use Direct Conversion Methods When:</a></h3>
<ul>
<li><strong>One-way conversion</strong> - You don't need the reverse operation</li>
<li><strong>Non-lossless conversion</strong> - Information is lost in the conversion</li>
<li><strong>Performance critical paths</strong> - Minimal abstraction overhead needed</li>
</ul>
<pre><code class="language-java">// Simple one-way conversion
String pointDescription = point.x() + "," + point.y();
</code></pre>
<h3 id="use-manual-adapters-when"><a class="header" href="#use-manual-adapters-when">Use Manual Adapters When:</a></h3>
<ul>
<li><strong>Complex conversion logic</strong> - Multi-step or conditional conversions</li>
<li><strong>Validation required</strong> - Conversion might fail</li>
<li><strong>Side effects needed</strong> - Logging, caching, etc.</li>
</ul>
<pre><code class="language-java">// Complex conversion that might fail
public Optional&lt;Point&gt; parsePoint(String input) {
    try {
        String[] parts = input.split(",");
        return Optional.of(new Point(
            Integer.parseInt(parts[0].trim()),
            Integer.parseInt(parts[1].trim())
        ));
    } catch (Exception e) {
        return Optional.empty();
    }
}
</code></pre>
<hr />
<h2 id="common-pitfalls-3"><a class="header" href="#common-pitfalls-3">Common Pitfalls</a></h2>
<h3 id="-dont-do-this-2"><a class="header" href="#-dont-do-this-2">‚ùå Don't Do This:</a></h3>
<pre><code class="language-java">// Lossy conversion - not a true isomorphism
Iso&lt;Double, Integer&gt; lossyIso = Iso.of(
    d -&gt; d.intValue(),    // Loses decimal precision!
    i -&gt; i.doubleValue()  // Can't recover original value
);

// One-way thinking - forgetting about reverseGet
Iso&lt;Point, String&gt; badPointIso = Iso.of(
    point -&gt; point.x() + "," + point.y(),
    str -&gt; new Point(0, 0)  // Ignores the input!
);

// Creating Isos repeatedly instead of reusing
var iso1 = Iso.of(Point::x, x -&gt; new Point(x, 0));
var iso2 = Iso.of(Point::x, x -&gt; new Point(x, 0));
var iso3 = Iso.of(Point::x, x -&gt; new Point(x, 0));
</code></pre>
<h3 id="-do-this-instead-2"><a class="header" href="#-do-this-instead-2">‚úÖ Do This Instead:</a></h3>
<pre><code class="language-java">// True isomorphism - perfect round-trip
Iso&lt;Point, String&gt; goodPointIso = Iso.of(
    point -&gt; point.x() + "," + point.y(),
    str -&gt; {
        String[] parts = str.split(",");
        return new Point(Integer.parseInt(parts[0]), Integer.parseInt(parts[1]));
    }
);

// Test your isomorphisms
public static &lt;A, B&gt; void testIsomorphism(Iso&lt;A, B&gt; iso, A original) {
    B converted = iso.get(original);
    A roundTrip = iso.reverse().get(converted);
    assert original.equals(roundTrip) : "Iso failed round-trip test";
}

// Reuse Isos as constants
public static final Iso&lt;Point, Tuple2&lt;Integer, Integer&gt;&gt; POINT_TO_TUPLE = 
    Iso.of(
        point -&gt; Tuple.of(point.x(), point.y()),
        tuple -&gt; new Point(tuple._1(), tuple._2())
    );
</code></pre>
<hr />
<h2 id="performance-notes-3"><a class="header" href="#performance-notes-3">Performance Notes</a></h2>
<p>Isos are designed for efficient, lossless conversion:</p>
<ul>
<li><strong>Zero overhead composition</strong>: Multiple Iso compositions are fused into single operations</li>
<li><strong>Lazy evaluation</strong>: Conversions only happen when needed</li>
<li><strong>Type safety</strong>: All conversions are checked at compile time</li>
<li><strong>Reusable</strong>: Isos can be stored and reused across your application</li>
</ul>
<p><strong>Best Practice</strong>: For frequently used conversions, create Isos as constants and test them:</p>
<pre><code class="language-java">public class DataIsos {
    public static final Iso&lt;UserId, Long&gt; USER_ID_LONG = 
        Iso.of(UserId::value, UserId::new);
    
    public static final Iso&lt;Money, BigDecimal&gt; MONEY_DECIMAL = 
        Iso.of(Money::amount, Money::new);
    
    // Test your isos
    static {
        testIsomorphism(USER_ID_LONG, new UserId(12345L));
        testIsomorphism(MONEY_DECIMAL, new Money(new BigDecimal("99.99")));
    }
  
    private static &lt;A, B&gt; void testIsomorphism(Iso&lt;A, B&gt; iso, A original) {
        B converted = iso.get(original);
        A roundTrip = iso.reverse().get(converted);
        if (!original.equals(roundTrip)) {
            throw new AssertionError("Iso failed round-trip test: " + original + " -&gt; " + converted + " -&gt; " + roundTrip);
        }
    }
}
</code></pre>
<hr />
<h2 id="real-world-examples"><a class="header" href="#real-world-examples">Real-World Examples</a></h2>
<h3 id="1-api-data-transformation"><a class="header" href="#1-api-data-transformation">1. API Data Transformation</a></h3>
<pre><code class="language-java">// Internal model
public record Customer(String name, String email, LocalDate birthDate) {}

// External API model
public record CustomerDto(String fullName, String emailAddress, String birthDateString) {}

public class CustomerIsos {
    public static final Iso&lt;Customer, CustomerDto&gt; CUSTOMER_DTO = Iso.of(
        // Convert to DTO
        customer -&gt; new CustomerDto(
            customer.name(),
            customer.email(),
            customer.birthDate().format(DateTimeFormatter.ISO_LOCAL_DATE)
        ),
        // Convert from DTO
        dto -&gt; new Customer(
            dto.fullName(),
            dto.emailAddress(),
            LocalDate.parse(dto.birthDateString(), DateTimeFormatter.ISO_LOCAL_DATE)
        )
    );
  
    // Now any Customer lens can work with DTOs
    public static final Lens&lt;CustomerDto, String&gt; DTO_NAME = 
        CUSTOMER_DTO.reverse().andThen(CustomerLenses.name()).andThen(CUSTOMER_DTO);
}
</code></pre>
<h3 id="2-configuration-format-conversion"><a class="header" href="#2-configuration-format-conversion">2. Configuration Format Conversion</a></h3>
<pre><code class="language-java">// Different configuration representations
public record DatabaseConfig(String host, int port, String database) {}
public record ConnectionString(String value) {}

public class ConfigIsos {
    public static final Iso&lt;DatabaseConfig, ConnectionString&gt; DB_CONNECTION = Iso.of(
        // To connection string
        config -&gt; new ConnectionString(
            "jdbc:postgresql://" + config.host() + ":" + config.port() + "/" + config.database()
        ),
        // From connection string
        conn -&gt; {
            // Simple parser for this example
            String url = conn.value();
            String[] parts = url.replace("jdbc:postgresql://", "").split("[:/]");
            return new DatabaseConfig(parts[0], Integer.parseInt(parts[1]), parts[2]);
        }
    );
  
    // Use with existing configuration lenses
    public static final Lens&lt;DatabaseConfig, String&gt; CONNECTION_STRING_HOST = 
        DB_CONNECTION.andThen(
            Lens.of(
                cs -&gt; cs.value().split("//")[1].split(":")[0],
                (cs, host) -&gt; new ConnectionString(cs.value().replaceFirst("//[^:]+:", "//" + host + ":"))
            )
        ).andThen(DB_CONNECTION.reverse());
}
</code></pre>
<h3 id="3-wrapper-type-integration"><a class="header" href="#3-wrapper-type-integration">3. Wrapper Type Integration</a></h3>
<pre><code class="language-java">// Strongly-typed wrappers
public record ProductId(UUID value) {}
public record CategoryId(UUID value) {}

public class WrapperIsos {
    public static final Iso&lt;ProductId, UUID&gt; PRODUCT_ID_UUID = 
        Iso.of(ProductId::value, ProductId::new);
  
    public static final Iso&lt;CategoryId, UUID&gt; CATEGORY_ID_UUID = 
        Iso.of(CategoryId::value, CategoryId::new);
  
    // Use with any UUID-based operations
    public static String formatProductId(ProductId id) {
        return PRODUCT_ID_UUID
            .andThen(Iso.of(UUID::toString, UUID::fromString))
            .get(id);
    }
}
</code></pre>
<h2 id="complete-runnable-example-2"><a class="header" href="#complete-runnable-example-2">Complete, Runnable Example</a></h2>
<p>This example puts all the steps together to show both direct conversion and composition.</p>
<pre><code class="language-java">public class IsoUsageExample {

    @GenerateLenses
    public record Point(int x, int y) {}

    @GenerateLenses
    public record Circle(Point centre, int radius) {}

    public static class Converters {
        @GenerateIsos
        public static Iso&lt;Point, Tuple2&lt;Integer, Integer&gt;&gt; pointToTuple() {
            return Iso.of(
                    point -&gt; Tuple.of(point.x(), point.y()),
                    tuple -&gt; new Point(tuple._1(), tuple._2()));
        }

        // Additional useful Isos
        public static final Iso&lt;Point, String&gt; POINT_STRING = Iso.of(
                point -&gt; point.x() + "," + point.y(),
                str -&gt; {
                    String[] parts = str.split(",");
                    return new Point(Integer.parseInt(parts[0]), Integer.parseInt(parts[1]));
                }
        );
    }

    // Test helper
    private static &lt;A, B&gt; void testRoundTrip(Iso&lt;A, B&gt; iso, A original, String description) {
        B converted = iso.get(original);
        A roundTrip = iso.reverse().get(converted);
        System.out.println(description + ":");
        System.out.println("  Original:  " + original);
        System.out.println("  Converted: " + converted);
        System.out.println("  Round-trip: " + roundTrip);
        System.out.println("  Success: " + original.equals(roundTrip));
        System.out.println();
    }

    public static void main(String[] args) {
        // 1. Define a point and circle.
        var myPoint = new Point(10, 20);
        var myCircle = new Circle(myPoint, 5);

        System.out.println("=== ISO USAGE EXAMPLE ===");
        System.out.println("Original Point: " + myPoint);
        System.out.println("Original Circle: " + myCircle);
        System.out.println("------------------------------------------");

        // 2. Get the generated Iso.
        var pointToTupleIso = ConvertersIsos.pointToTuple;

        // --- SCENARIO 1: Direct conversions and round-trip testing ---
        System.out.println("--- Scenario 1: Direct Conversions ---");
        testRoundTrip(pointToTupleIso, myPoint, "Point to Tuple conversion");
        testRoundTrip(Converters.POINT_STRING, myPoint, "Point to String conversion");

        // --- SCENARIO 2: Using reverse() ---
        System.out.println("--- Scenario 2: Reverse Operations ---");
        var tupleToPointIso = pointToTupleIso.reverse();
        var myTuple = Tuple.of(30, 40);
        Point pointFromTuple = tupleToPointIso.get(myTuple);
        System.out.println("Tuple: " + myTuple + " -&gt; Point: " + pointFromTuple);
        System.out.println();

        // --- SCENARIO 3: Composition with lenses ---
        System.out.println("--- Scenario 3: Composition with Lenses ---");

        // Create a lens manually that works with Point directly
        Lens&lt;Point, Integer&gt; pointToXLens = Lens.of(
                Point::x,
                (point, newX) -&gt; new Point(newX, point.y())
        );

        // Use the lens
        Point movedPoint = pointToXLens.modify(x -&gt; x + 5, myPoint);
        System.out.println("Original point: " + myPoint);
        System.out.println("After moving X by 5: " + movedPoint);
        System.out.println();

        // --- SCENARIO 4: Demonstrating Iso composition ---
        System.out.println("--- Scenario 4: Iso Composition ---");

        // Show how the Iso can be used to convert and work with tuples
        Tuple2&lt;Integer, Integer&gt; tupleRepresentation = pointToTupleIso.get(myPoint);
        System.out.println("Point as tuple: " + tupleRepresentation);

        // Modify the tuple using tuple operations
        Lens&lt;Tuple2&lt;Integer, Integer&gt;, Integer&gt; tupleFirstLens = Tuple2Lenses._1();
        Tuple2&lt;Integer, Integer&gt; modifiedTuple = tupleFirstLens.modify(x -&gt; x * 2, tupleRepresentation);

        // Convert back to Point
        Point modifiedPoint = pointToTupleIso.reverse().get(modifiedTuple);
        System.out.println("Modified tuple: " + modifiedTuple);
        System.out.println("Back to point: " + modifiedPoint);
        System.out.println();

        // --- SCENARIO 5: String format conversions ---
        System.out.println("--- Scenario 5: String Format Conversions ---");

        String pointAsString = Converters.POINT_STRING.get(myPoint);
        System.out.println("Point as string: " + pointAsString);

        Point recoveredFromString = Converters.POINT_STRING.reverse().get(pointAsString);
        System.out.println("Recovered from string: " + recoveredFromString);
        System.out.println("Perfect round-trip: " + myPoint.equals(recoveredFromString));

        // --- SCENARIO 6: Working with Circle centre through Iso ---
        System.out.println("--- Scenario 6: Circle Centre Manipulation ---");

        // Get the centre as a tuple, modify it, and put it back
        Point originalCentre = myCircle.centre();
        Tuple2&lt;Integer, Integer&gt; centreAsTuple = pointToTupleIso.get(originalCentre);
        Tuple2&lt;Integer, Integer&gt; shiftedCentre = Tuple.of(centreAsTuple._1() + 10, centreAsTuple._2() + 10);
        Point newCentre = pointToTupleIso.reverse().get(shiftedCentre);
        Circle newCircle = CircleLenses.centre().set(newCentre, myCircle);

        System.out.println("Original circle: " + myCircle);
        System.out.println("Centre as tuple: " + centreAsTuple);
        System.out.println("Shifted centre tuple: " + shiftedCentre);
        System.out.println("New circle: " + newCircle);
    }
</code></pre>
<p><strong>Expected Output:</strong></p>
<pre><code>=== ISO USAGE EXAMPLE ===
Original Point: Point[x=10, y=20]
Original Circle: Circle[centre=Point[x=10, y=20], radius=5]
------------------------------------------
--- Scenario 1: Direct Conversions ---
Point to Tuple conversion:
  Original:  Point[x=10, y=20]
  Converted: Tuple2[_1=10, _2=20]
  Round-trip: Point[x=10, y=20]
  Success: true

Point to String conversion:
  Original:  Point[x=10, y=20]
  Converted: 10,20
  Round-trip: Point[x=10, y=20]
  Success: true

--- Scenario 2: Reverse Operations ---
Tuple: Tuple2[_1=30, _2=40] -&gt; Point: Point[x=30, y=40]

--- Scenario 3: Working with Different Representations ---
Original point: Point[x=10, y=20]
After moving X by 5: Point[x=15, y=20]

--- Scenario 4: Conversion Workflows ---
Point as tuple: Tuple2[_1=10, _2=20]
Modified tuple: Tuple2[_1=20, _2=20]
Back to point: Point[x=20, y=20]

--- Scenario 5: String Format Conversions ---
Point as string: 10,20
Recovered from string: Point[x=10, y=20]
Perfect round-trip: true

--- Scenario 6: Circle Centre Manipulation ---
Original circle: Circle[centre=Point[x=10, y=20], radius=5]
Centre as tuple: Tuple2[_1=10, _2=20]
Shifted centre tuple: Tuple2[_1=20, _2=30]
New circle: Circle[centre=Point[x=20, y=30], radius=5]
</code></pre>
<hr />
<h2 id="why-isos-are-a-powerful-bridge"><a class="header" href="#why-isos-are-a-powerful-bridge">Why Isos are a Powerful Bridge</a></h2>
<p><code>Lens</code>, <code>Prism</code>, and <code>Iso</code> form a powerful trio for modelling any data operation. An <code>Iso</code> is the essential bridge that enables you to:</p>
<ul>
<li><strong>Work with the Best Representation</strong>: Convert data to the most suitable format for each operation, then convert back when needed.</li>
<li><strong>Enable Library Integration</strong>: Adapt your internal data types to work seamlessly with external libraries without changing your core domain model.</li>
<li><strong>Maintain Type Safety</strong>: All conversions are checked at compile time, eliminating runtime conversion errors.</li>
<li><strong>Build Reusable Converters</strong>: Create tested, reusable conversion components that can be used throughout your application.</li>
</ul>
<p>The step-by-step conversion approach shown in the examples is the most practical way to use Isos in real applications, providing clear, maintainable code that leverages the strengths of different data representations.</p>
<hr />
<p><strong>Previous:</strong> <a href="optics/advanced_prism_patterns.html">Advanced Prism Patterns</a>
<strong>Next:</strong> <a href="optics/traversals.html">Traversals: Handling Bulk Updates</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="traversals-practical-guide"><a class="header" href="#traversals-practical-guide">Traversals: Practical Guide</a></h1>
<h2 id="handling-bulk-updates"><a class="header" href="#handling-bulk-updates"><em>Handling Bulk Updates</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="optics/traversals.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to perform bulk operations on collections within immutable structures</li>
<li>Using <code>@GenerateTraversals</code> for automatic collection optics</li>
<li>Composing traversals with lenses and prisms for deep bulk updates</li>
<li>The <code>Traversals.modify()</code> and <code>Traversals.getAll()</code> utility methods</li>
<li>Understanding zero-or-more target semantics</li>
<li>When to use traversals vs streams vs manual loops for collection processing</li>
</ul>
</div>
</div>
<div id="admonition-example-code" class="admonition admonish-note" role="note" aria-labelledby="admonition-example-code-title">
<div class="admonition-title">
<div id="admonition-example-code-title">
<p>Example Code</p>
</div>
<a class="admonition-anchor-link" href="optics/traversals.html#admonition-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/TraversalUsageExample.java">TraversalUsageExample</a></p>
</div>
</div>
<p>So far, our journey through optics has shown us how to handle singular focus:</p>
<ul>
<li>A <strong><code>Lens</code></strong> targets a part that <em>must</em> exist.</li>
<li>A <strong><code>Prism</code></strong> targets a part that <em>might</em> exist in one specific shape.</li>
<li>An <strong><code>Iso</code></strong> provides a two-way bridge between <em>equivalent</em> types.</li>
</ul>
<p>But what about operating on <em>many</em> items at once? How do we apply a single change to every element in a nested list? For this, we need the most general and powerful optic in our toolkit: the <strong>Traversal</strong>.</p>
<h2 id="the-scenario-updating-an-entire-league-"><a class="header" href="#the-scenario-updating-an-entire-league-">The Scenario: Updating an Entire League üó∫Ô∏è</a></h2>
<p>A <code>Traversal</code> is a functional "search-and-replace." It gives you a single tool to focus on zero or more items within a larger structure, allowing you to <code>get</code>, <code>set</code>, or <code>modify</code> all of them in one go.</p>
<p>This makes it the perfect optic for working with collections. Consider this data model of a sports league:</p>
<p><strong>The Data Model:</strong></p>
<pre><code class="language-java">public record Player(String name, int score) {}
public record Team(String name, List&lt;Player&gt; players) {}
public record League(String name, List&lt;Team&gt; teams) {}
</code></pre>
<p><strong>Our Goal:</strong> We need to give every single player in the entire league 5 bonus points. The traditional approach involves nested loops or streams, forcing us to manually reconstruct each immutable object along the way.</p>
<pre><code class="language-java">// Manual, verbose bulk update
List&lt;Team&gt; newTeams = league.teams().stream()
    .map(team -&gt; {
        List&lt;Player&gt; newPlayers = team.players().stream()
            .map(player -&gt; new Player(player.name(), player.score() + 5))
            .collect(Collectors.toList());
        return new Team(team.name(), newPlayers);
    })
    .collect(Collectors.toList());
League updatedLeague = new League(league.name(), newTeams);
</code></pre>
<p>This code is deeply nested and mixes the <em>what</em> (add 5 to a score) with the <em>how</em> (looping, collecting, and reconstructing). A <code>Traversal</code> lets us abstract away the "how" completely.</p>
<h2 id="think-of-traversals-like"><a class="header" href="#think-of-traversals-like">Think of Traversals Like...</a></h2>
<ul>
<li><strong>A spotlight</strong>: Illuminates many targets at once within a structure</li>
<li><strong>A search-and-replace tool</strong>: Finds all matching items and transforms them</li>
<li><strong>A bulk editor</strong>: Applies the same operation to multiple items efficiently</li>
<li><strong>A magnifying glass array</strong>: Like a lens, but for zero-to-many targets instead of exactly one</li>
</ul>
<h2 id="a-step-by-step-walkthrough-3"><a class="header" href="#a-step-by-step-walkthrough-3">A Step-by-Step Walkthrough</a></h2>
<h3 id="step-1-generating-traversals"><a class="header" href="#step-1-generating-traversals">Step 1: Generating Traversals</a></h3>
<p>The library provides a rich set of tools for creating <code>Traversal</code> instances, found in the <strong><code>Traversals</code></strong> utility class and through annotations.</p>
<ul>
<li><strong><code>@GenerateTraversals</code></strong>: Annotating a record will automatically generate a <code>Traversal</code> for any <code>Iterable</code> field (like <code>List</code> or <code>Set</code>).</li>
<li><strong><code>Traversals.forList()</code></strong>: A static helper that creates a traversal for the elements of a <code>List</code>.</li>
<li><strong><code>Traversals.forMap(key)</code></strong>: A static helper that creates a traversal focusing on the value for a specific key in a <code>Map</code>.</li>
</ul>
<pre><code class="language-java">import org.higherkindedj.optics.annotations.GenerateTraversals;
import java.util.List;

// We also add @GenerateLenses to get access to player fields
@GenerateLenses
public record Player(String name, int score) {}

@GenerateLenses
@GenerateTraversals // Traversal for List&lt;Player&gt;
public record Team(String name, List&lt;Player&gt; players) {}

@GenerateLenses
@GenerateTraversals // Traversal for List&lt;Team&gt;
public record League(String name, List&lt;Team&gt; teams) {}
</code></pre>
<h3 id="step-2-composing-a-deep-traversal"><a class="header" href="#step-2-composing-a-deep-traversal">Step 2: Composing a Deep Traversal</a></h3>
<p>Just like other optics, <code>Traversal</code>s can be composed with <code>andThen</code>. We can chain them together to create a single, deep traversal from the <code>League</code> all the way down to each player's <code>score</code>.</p>
<pre><code class="language-java">// Get generated optics
Traversal&lt;League, Team&gt; leagueToTeams = LeagueTraversals.teams();
Traversal&lt;Team, Player&gt; teamToPlayers = TeamTraversals.players();
Lens&lt;Player, Integer&gt; playerToScore = PlayerLenses.score();

// Compose them to create a single, deep traversal.
Traversal&lt;League, Integer&gt; leagueToAllPlayerScores =
    leagueToTeams
        .andThen(teamToPlayers)
        .andThen(playerToScore.asTraversal()); // Convert the final Lens
</code></pre>
<p>The result is a single <code>Traversal&lt;League, Integer&gt;</code> that declaratively represents the path to all player scores.</p>
<h3 id="step-3-using-the-traversal-with-helper-methods"><a class="header" href="#step-3-using-the-traversal-with-helper-methods">Step 3: Using the Traversal with Helper Methods</a></h3>
<p>The <code>Traversals</code> utility class provides convenient helper methods to perform the most common operations.</p>
<ul>
<li><strong><code>Traversals.modify(traversal, function, source)</code></strong>: Applies a pure function to all targets of a traversal.</li>
</ul>
<pre><code class="language-java">  // Use the composed traversal to add 5 bonus points to every score.
  League updatedLeague = Traversals.modify(leagueToAllPlayerScores, score -&gt; score + 5, league);
</code></pre>
<ul>
<li><strong><code>Traversals.getAll(traversal, source)</code></strong>: Extracts all targets of a traversal into a <code>List</code>.</li>
</ul>
<pre><code class="language-java">  // Get a flat list of all player scores in the league.
  List&lt;Integer&gt; allScores = Traversals.getAll(leagueToAllPlayerScores, league);
  // Result: [100, 90, 110, 120]
</code></pre>
<h2 id="when-to-use-traversals-vs-other-approaches"><a class="header" href="#when-to-use-traversals-vs-other-approaches">When to Use Traversals vs Other Approaches</a></h2>
<h3 id="use-traversals-when"><a class="header" href="#use-traversals-when">Use Traversals When:</a></h3>
<ul>
<li><strong>Bulk operations on nested collections</strong> - Applying the same operation to many items</li>
<li><strong>Type-safe collection manipulation</strong> - Working with collections inside immutable structures</li>
<li><strong>Reusable bulk logic</strong> - Creating operations that can be applied across different instances</li>
<li><strong>Effectful operations</strong> - Using <code>modifyF</code> for operations that might fail or have side effects</li>
</ul>
<pre><code class="language-java">// Perfect for bulk updates with type safety
Traversal&lt;Company, String&gt; allEmails = CompanyTraversals.employees()
    .andThen(EmployeeTraversals.contacts())
    .andThen(ContactLenses.email().asTraversal());

Company withNormalisedEmails = Traversals.modify(allEmails, String::toLowerCase, company);
</code></pre>
<h3 id="use-streams-when"><a class="header" href="#use-streams-when">Use Streams When:</a></h3>
<ul>
<li><strong>Complex transformations</strong> - Multiple operations that don't map cleanly to traversals</li>
<li><strong>Filtering and collecting</strong> - You need to change the collection structure</li>
<li><strong>Performance critical paths</strong> - Minimal abstraction overhead needed</li>
</ul>
<pre><code class="language-java">// Better with streams for complex logic
List&lt;String&gt; activePlayerNames = league.teams().stream()
    .flatMap(team -&gt; team.players().stream())
    .filter(player -&gt; player.score() &gt; 50)
    .map(Player::name)
    .sorted()
    .collect(toList());
</code></pre>
<h3 id="use-manual-loops-when"><a class="header" href="#use-manual-loops-when">Use Manual Loops When:</a></h3>
<ul>
<li><strong>Early termination needed</strong> - You might want to stop processing early</li>
<li><strong>Complex control flow</strong> - Multiple conditions and branches</li>
<li><strong>Imperative mindset</strong> - The operation is inherently procedural</li>
</ul>
<pre><code class="language-java">// Sometimes a loop is clearest
for (Team team : league.teams()) {
    for (Player player : team.players()) {
        if (player.score() &lt; 0) {
            throw new IllegalStateException("Negative score found: " + player);
        }
    }
}
</code></pre>
<hr />
<h2 id="common-pitfalls-4"><a class="header" href="#common-pitfalls-4">Common Pitfalls</a></h2>
<h3 id="-dont-do-this-3"><a class="header" href="#-dont-do-this-3">‚ùå Don't Do This:</a></h3>
<pre><code class="language-java">// Inefficient: Creating traversals repeatedly
teams.forEach(team -&gt; {
    var traversal = TeamTraversals.players().andThen(PlayerLenses.score().asTraversal());
    Traversals.modify(traversal, score -&gt; score + 1, team);
});

// Over-engineering: Using traversals for simple cases
Traversal&lt;Player, String&gt; playerName = PlayerLenses.name().asTraversal();
String name = Traversals.getAll(playerName, player).get(0); // Just use player.name()!

// Type confusion: Forgetting that traversals work on zero-or-more targets
League emptyLeague = new League("Empty", List.of());
List&lt;Integer&gt; scores = Traversals.getAll(leagueToAllPlayerScores, emptyLeague); // Returns empty list
</code></pre>
<h3 id="-do-this-instead-3"><a class="header" href="#-do-this-instead-3">‚úÖ Do This Instead:</a></h3>
<pre><code class="language-java">// Efficient: Create traversals once, use many times
var scoreTraversal = LeagueTraversals.teams()
    .andThen(TeamTraversals.players())
    .andThen(PlayerLenses.score().asTraversal());

League bonusLeague = Traversals.modify(scoreTraversal, score -&gt; score + 5, league);
League doubledLeague = Traversals.modify(scoreTraversal, score -&gt; score * 2, league);

// Right tool for the job: Use direct access for single items
String playerName = player.name(); // Simple and clear

// Defensive: Handle empty collections gracefully  
List&lt;Integer&gt; allScores = Traversals.getAll(scoreTraversal, league);
OptionalDouble average = allScores.stream().mapToInt(Integer::intValue).average();
</code></pre>
<hr />
<h2 id="performance-notes-4"><a class="header" href="#performance-notes-4">Performance Notes</a></h2>
<p>Traversals are optimised for immutable updates:</p>
<ul>
<li><strong>Memory efficient</strong>: Only creates new objects along the path that changes</li>
<li><strong>Lazy evaluation</strong>: Stops early if no changes are needed</li>
<li><strong>Batch operations</strong>: <code>modifyF</code> processes all targets in a single pass</li>
<li><strong>Structural sharing</strong>: Unchanged parts of the data structure are reused</li>
</ul>
<p><strong>Best Practice</strong>: For frequently used traversal combinations, create them once and store as constants:</p>
<pre><code class="language-java">public class LeagueOptics {
    public static final Traversal&lt;League, Integer&gt; ALL_PLAYER_SCORES = 
        LeagueTraversals.teams()
            .andThen(TeamTraversals.players())
            .andThen(PlayerLenses.score().asTraversal());
      
    public static final Traversal&lt;League, String&gt; ALL_PLAYER_NAMES = 
        LeagueTraversals.teams()
            .andThen(TeamTraversals.players())
            .andThen(PlayerLenses.name().asTraversal());
}
</code></pre>
<hr />
<h2 id="common-patterns-1"><a class="header" href="#common-patterns-1">Common Patterns</a></h2>
<h3 id="validation-with-error-accumulation"><a class="header" href="#validation-with-error-accumulation">Validation with Error Accumulation</a></h3>
<pre><code class="language-java">// Validate all email addresses in a userLogin list
Traversal&lt;Company, String&gt; allEmails = CompanyTraversals.employees()
    .andThen(EmployeeTraversals.contactInfo())
    .andThen(ContactInfoLenses.email().asTraversal());

Function&lt;String, Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, String&gt;&gt; validateEmail = 
    email -&gt; email.contains("@") 
        ? VALIDATED.widen(Validated.valid(email))
        : VALIDATED.widen(Validated.invalid(List.of("Invalid email: " + email)));

Validated&lt;List&lt;String&gt;, Company&gt; result = VALIDATED.narrow(
    allEmails.modifyF(validateEmail, company, validatedApplicative)
);
</code></pre>
<h3 id="conditional-updates"><a class="header" href="#conditional-updates">Conditional Updates</a></h3>
<pre><code class="language-java">// Give bonus points only to high-performing players
Function&lt;Integer, Integer&gt; conditionalBonus = score -&gt; 
    score &gt;= 80 ? score + 10 : score;

League bonusLeague = Traversals.modify(
    LeagueOptics.ALL_PLAYER_SCORES, 
    conditionalBonus, 
    league
);
</code></pre>
<h3 id="data-transformation"><a class="header" href="#data-transformation">Data Transformation</a></h3>
<pre><code class="language-java">// Normalise all player names to title case
Function&lt;String, String&gt; titleCase = name -&gt; 
    Arrays.stream(name.toLowerCase().split(" "))
        .map(word -&gt; word.substring(0, 1).toUpperCase() + word.substring(1))
        .collect(joining(" "));

League normalisedLeague = Traversals.modify(
    LeagueOptics.ALL_PLAYER_NAMES,
    titleCase,
    league
);
</code></pre>
<h3 id="asynchronous-operations"><a class="header" href="#asynchronous-operations">Asynchronous Operations</a></h3>
<pre><code class="language-java">// Fetch additional player statistics asynchronously
Function&lt;Integer, CompletableFuture&lt;Integer&gt;&gt; fetchBonusPoints = 
    playerId -&gt; statsService.getBonusPoints(playerId);

CompletableFuture&lt;League&gt; enrichedLeague = CF.narrow(
    LeagueOptics.ALL_PLAYER_SCORES.modifyF(
        score -&gt; CF.widen(fetchBonusPoints.apply(score)),
        league,
        CompletableFutureMonad.INSTANCE
    )
);
</code></pre>
<hr />
<h2 id="list-manipulation-with-partsof"><a class="header" href="#list-manipulation-with-partsof">List Manipulation with <code>partsOf</code></a></h2>
<h3 id="treating-traversal-focuses-as-collections"><a class="header" href="#treating-traversal-focuses-as-collections"><em>Treating Traversal Focuses as Collections</em></a></h3>
<div id="admonition-what-youll-learn-1" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-1-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-1-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="optics/traversals.html#admonition-what-youll-learn-1"></a>
</div>
<div>
<ul>
<li>Converting a Traversal into a Lens on a List of elements</li>
<li>Using <code>partsOf</code> for sorting, reversing, and deduplicating focused elements</li>
<li>Convenience methods: <code>sorted</code>, <code>reversed</code>, <code>distinct</code></li>
<li>Understanding size mismatch behaviour and graceful degradation</li>
<li>When list-level operations on traversal targets are appropriate</li>
</ul>
</div>
</div>
<div id="admonition-example-code-1" class="admonition admonish-note" role="note" aria-labelledby="admonition-example-code-1-title">
<div class="admonition-title">
<div id="admonition-example-code-1-title">
<p>Example Code</p>
</div>
<a class="admonition-anchor-link" href="optics/traversals.html#admonition-example-code-1"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/PartsOfTraversalExample.java">PartsOfTraversalExample</a></p>
</div>
</div>
<p>So far, we've seen how traversals excel at applying the <em>same</em> operation to every focused element individually. But what if you need to perform operations that consider <em>all</em> focuses as a group? Sorting, reversing, or removing duplicates are inherently list-level operations‚Äîthey require knowledge of the entire collection, not just individual elements.</p>
<p>This is where <code>partsOf</code> becomes invaluable. It bridges the gap between element-wise traversal operations and collection-level algorithms.</p>
<h3 id="think-of-partsof-like"><a class="header" href="#think-of-partsof-like">Think of partsOf Like...</a></h3>
<ul>
<li><strong>A "collect and redistribute" operation</strong>: Gather all targets, transform them as a group, then put them back</li>
<li><strong>A camera taking a snapshot</strong>: Capture all focused elements, edit the photo, then overlay the changes</li>
<li><strong>A postal sorting centre</strong>: Collect all parcels, sort them efficiently, then redistribute to addresses</li>
<li><strong>The bridge between trees and lists</strong>: Temporarily flatten a structure for list operations, then restore the shape</li>
</ul>
<h3 id="the-problem-element-wise-limitations"><a class="header" href="#the-problem-element-wise-limitations">The Problem: Element-Wise Limitations</a></h3>
<p>Consider this scenario: you have a catalogue of products across multiple categories, and you want to sort all prices from lowest to highest. With standard traversal operations, you're stuck:</p>
<pre><code class="language-java">// This doesn't work - modify operates on each element independently
Traversal&lt;Catalogue, Double&gt; allPrices = CatalogueTraversals.categories()
    .andThen(CategoryTraversals.products())
    .andThen(ProductLenses.price().asTraversal());

// ‚ùå This sorts nothing - each price is transformed in isolation
Catalogue result = Traversals.modify(allPrices, price -&gt; price, catalogue);
// Prices remain in original order!
</code></pre>
<p>The traversal has no way to "see" all prices simultaneously. Each element is processed independently, making sorting impossible.</p>
<h3 id="the-solution-partsof"><a class="header" href="#the-solution-partsof">The Solution: <code>partsOf</code></a></h3>
<p>The <code>partsOf</code> combinator transforms a <code>Traversal&lt;S, A&gt;</code> into a <code>Lens&lt;S, List&lt;A&gt;&gt;</code>, allowing you to:</p>
<ol>
<li><strong>Get</strong>: Extract all focused elements as a single list</li>
<li><strong>Manipulate</strong>: Apply any list operation (sort, reverse, filter, etc.)</li>
<li><strong>Set</strong>: Distribute the modified elements back to their original positions</li>
</ol>
<pre><code class="language-java">// Convert traversal to a lens on the list of all prices
Lens&lt;Catalogue, List&lt;Double&gt;&gt; pricesLens = Traversals.partsOf(allPrices);

// Get all prices as a list
List&lt;Double&gt; allPricesList = pricesLens.get(catalogue);
// Result: [999.99, 499.99, 799.99, 29.99, 49.99, 19.99]

// Sort the list
List&lt;Double&gt; sortedPrices = new ArrayList&lt;&gt;(allPricesList);
Collections.sort(sortedPrices);
// Result: [19.99, 29.99, 49.99, 499.99, 799.99, 999.99]

// Set the sorted prices back
Catalogue sortedCatalogue = pricesLens.set(sortedPrices, catalogue);
</code></pre>
<p><strong>The Magic</strong>: The sorted prices are distributed back to the <em>original positions</em> in the structure. The first product gets the lowest price, the second product gets the second-lowest, and so on‚Äîregardless of which category they belong to.</p>
<h3 id="convenience-methods"><a class="header" href="#convenience-methods">Convenience Methods</a></h3>
<p>The <code>Traversals</code> utility class provides convenience methods that combine <code>partsOf</code> with common list operations:</p>
<h4 id="sorted---natural-ordering"><a class="header" href="#sorted---natural-ordering"><code>sorted</code> - Natural Ordering</a></h4>
<pre><code class="language-java">Traversal&lt;List&lt;Product&gt;, Double&gt; priceTraversal =
    Traversals.&lt;Product&gt;forList().andThen(ProductLenses.price().asTraversal());

// Sort prices in ascending order
List&lt;Product&gt; sortedProducts = Traversals.sorted(priceTraversal, products);
</code></pre>
<h4 id="sorted---custom-comparator"><a class="header" href="#sorted---custom-comparator"><code>sorted</code> - Custom Comparator</a></h4>
<pre><code class="language-java">Traversal&lt;List&lt;Product&gt;, String&gt; nameTraversal =
    Traversals.&lt;Product&gt;forList().andThen(ProductLenses.name().asTraversal());

// Sort names case-insensitively
List&lt;Product&gt; sortedByName = Traversals.sorted(
    nameTraversal,
    String.CASE_INSENSITIVE_ORDER,
    products
);

// Sort by name length
List&lt;Product&gt; sortedByLength = Traversals.sorted(
    nameTraversal,
    Comparator.comparingInt(String::length),
    products
);
</code></pre>
<h4 id="reversed---invert-order"><a class="header" href="#reversed---invert-order"><code>reversed</code> - Invert Order</a></h4>
<pre><code class="language-java">Traversal&lt;Project, Integer&gt; priorityTraversal =
    ProjectTraversals.tasks().andThen(TaskLenses.priority().asTraversal());

// Reverse all priorities
Project reversedProject = Traversals.reversed(priorityTraversal, project);

// Useful for: inverting priority schemes, LIFO ordering, undo stacks
</code></pre>
<h4 id="distinct---remove-duplicates"><a class="header" href="#distinct---remove-duplicates"><code>distinct</code> - Remove Duplicates</a></h4>
<pre><code class="language-java">Traversal&lt;List&lt;Product&gt;, String&gt; tagTraversal =
    Traversals.&lt;Product&gt;forList().andThen(ProductLenses.tag().asTraversal());

// Remove duplicate tags (preserves first occurrence)
List&lt;Product&gt; deduplicatedProducts = Traversals.distinct(tagTraversal, products);
</code></pre>
<h3 id="understanding-size-mismatch-behaviour"><a class="header" href="#understanding-size-mismatch-behaviour">Understanding Size Mismatch Behaviour</a></h3>
<p>A crucial aspect of <code>partsOf</code> is how it handles size mismatches between the new list and the number of target positions:</p>
<p><strong>Fewer elements than positions</strong>: Original values are preserved in remaining positions.</p>
<pre><code class="language-java">// Original: 5 products with prices [100, 200, 300, 400, 500]
List&lt;Double&gt; partialPrices = List.of(10.0, 20.0, 30.0); // Only 3 values

List&lt;Product&gt; result = pricesLens.set(partialPrices, products);
// Result prices: [10.0, 20.0, 30.0, 400, 500]
// First 3 updated, last 2 unchanged
</code></pre>
<p><strong>More elements than positions</strong>: Extra elements are ignored.</p>
<pre><code class="language-java">// Original: 3 products
List&lt;Double&gt; extraPrices = List.of(10.0, 20.0, 30.0, 40.0, 50.0); // 5 values

List&lt;Product&gt; result = pricesLens.set(extraPrices, products);
// Result: Only first 3 prices used, 40.0 and 50.0 ignored
</code></pre>
<p>This graceful degradation makes <code>partsOf</code> safe to use even when you're not certain about the exact number of targets.</p>
<h3 id="lens-laws-compliance"><a class="header" href="#lens-laws-compliance">Lens Laws Compliance</a></h3>
<p>The <code>partsOf</code> combinator produces a lawful <code>Lens</code> when the list sizes match:</p>
<ul>
<li><strong>Get-Set Law</strong>: <code>set(get(s), s) = s</code> ‚úì</li>
<li><strong>Set-Get Law</strong>: <code>get(set(a, s)) = a</code> ‚úì (when <code>a.size() = targets</code>)</li>
<li><strong>Set-Set Law</strong>: <code>set(b, set(a, s)) = set(b, s)</code> ‚úì</li>
</ul>
<p>When sizes don't match, the laws still hold for the elements that <em>are</em> provided.</p>
<h3 id="advanced-use-cases"><a class="header" href="#advanced-use-cases">Advanced Use Cases</a></h3>
<h4 id="combining-with-filtered-traversals"><a class="header" href="#combining-with-filtered-traversals">Combining with Filtered Traversals</a></h4>
<pre><code class="language-java">// Sort only in-stock product prices
Traversal&lt;List&lt;Product&gt;, Double&gt; inStockPrices =
    Traversals.&lt;Product&gt;forList()
        .filtered(p -&gt; p.stockLevel() &gt; 0)
        .andThen(ProductLenses.price().asTraversal());

List&lt;Product&gt; result = Traversals.sorted(inStockPrices, products);
// Out-of-stock products unchanged, in-stock prices sorted
</code></pre>
<h4 id="custom-list-algorithms"><a class="header" href="#custom-list-algorithms">Custom List Algorithms</a></h4>
<pre><code class="language-java">Lens&lt;Catalogue, List&lt;Double&gt;&gt; pricesLens = Traversals.partsOf(allPrices);
List&lt;Double&gt; prices = new ArrayList&lt;&gt;(pricesLens.get(catalogue));

// Apply any list algorithm:
Collections.shuffle(prices);              // Randomise
Collections.rotate(prices, 3);            // Circular rotation
prices.sort(Comparator.reverseOrder());   // Descending sort
prices.removeIf(p -&gt; p &lt; 10.0);          // Filter (with caveats)
</code></pre>
<h3 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h3>
<p><code>partsOf</code> operations traverse the structure twice:</p>
<ol>
<li><strong>Once for <code>get</code></strong>: Collect all focused elements</li>
<li><strong>Once for <code>set</code></strong>: Distribute modified elements back</li>
</ol>
<p>For very large structures with thousands of focuses, consider:</p>
<ul>
<li>Caching the lens if used repeatedly</li>
<li>Using direct stream operations if structure preservation isn't required</li>
<li>Profiling to ensure the abstraction overhead is acceptable</li>
</ul>
<p><strong>Best Practice</strong>: Create the <code>partsOf</code> lens once and reuse it:</p>
<pre><code class="language-java">public class CatalogueOptics {
    private static final Traversal&lt;Catalogue, Double&gt; ALL_PRICES =
        CatalogueTraversals.categories()
            .andThen(CategoryTraversals.products())
            .andThen(ProductLenses.price().asTraversal());

    public static final Lens&lt;Catalogue, List&lt;Double&gt;&gt; PRICES_AS_LIST =
        Traversals.partsOf(ALL_PRICES);
}
</code></pre>
<h3 id="common-pitfalls-with-partsof"><a class="header" href="#common-pitfalls-with-partsof">Common Pitfalls with partsOf</a></h3>
<h4 id="-dont-do-this-4"><a class="header" href="#-dont-do-this-4">‚ùå Don't Do This:</a></h4>
<pre><code class="language-java">// Expecting distinct to reduce structure size
List&lt;Product&gt; products = List.of(
    new Product("Widget", 25.99),
    new Product("Gadget", 49.99),
    new Product("Widget", 30.00)  // Duplicate name
);

// This doesn't remove the third product!
List&lt;Product&gt; result = Traversals.distinct(nameTraversal, products);
// The new list of distinct names is shorter, so the third product keeps its original name.

// Wrong: Using partsOf when you need element-wise operations
Lens&lt;List&lt;Product&gt;, List&lt;Double&gt;&gt; lens = Traversals.partsOf(priceTraversal);
List&lt;Double&gt; prices = lens.get(products);
prices.forEach(p -&gt; System.out.println(p)); // Just use Traversals.getAll()!
</code></pre>
<h4 id="-do-this-instead-4"><a class="header" href="#-do-this-instead-4">‚úÖ Do This Instead:</a></h4>
<pre><code class="language-java">// Understand that structure is preserved, only values redistribute
List&lt;Product&gt; result = Traversals.distinct(nameTraversal, products);
// Third product keeps original price, gets redistributed unique name

// Use partsOf when you need list-level operations
Lens&lt;List&lt;Product&gt;, List&lt;Double&gt;&gt; lens = Traversals.partsOf(priceTraversal);
List&lt;Double&gt; prices = new ArrayList&lt;&gt;(lens.get(products));
Collections.sort(prices); // True list operation
lens.set(prices, products);

// For simple iteration, use getAll
Traversals.getAll(priceTraversal, products).forEach(System.out::println);
</code></pre>
<h3 id="when-to-use-partsof"><a class="header" href="#when-to-use-partsof">When to Use partsOf</a></h3>
<p><strong>Use partsOf when:</strong></p>
<ul>
<li>Sorting focused elements by their values</li>
<li>Reversing the order of focused elements</li>
<li>Removing duplicates whilst preserving structure</li>
<li>Applying list algorithms that require seeing all elements at once</li>
<li>Redistributing values across positions (e.g., load balancing)</li>
</ul>
<p><strong>Avoid partsOf when:</strong></p>
<ul>
<li>Simple iteration suffices (use <code>getAll</code>)</li>
<li>Element-wise transformation is needed (use <code>modify</code>)</li>
<li>You need to change the structure itself (use streams/filtering)</li>
<li>Performance is critical and structure is very large</li>
</ul>
<hr />
<h2 id="real-world-example-configuration-validation"><a class="header" href="#real-world-example-configuration-validation">Real-World Example: Configuration Validation</a></h2>
<pre><code class="language-java">// Configuration model
@GenerateLenses
@GenerateTraversals
public record ServerConfig(String name, List&lt;DatabaseConfig&gt; databases) {}

@GenerateLenses  
public record DatabaseConfig(String host, int port, String name) {}

// Validation traversal
public class ConfigValidation {
    private static final Traversal&lt;ServerConfig, Integer&gt; ALL_DB_PORTS = 
        ServerConfigTraversals.databases()
            .andThen(DatabaseConfigLenses.port().asTraversal());
  
    public static Validated&lt;List&lt;String&gt;, ServerConfig&gt; validateConfig(ServerConfig config) {
        Function&lt;Integer, Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Integer&gt;&gt; validatePort = 
            port -&gt; {
                if (port &gt;= 1024 &amp;&amp; port &lt;= 65535) {
                    return VALIDATED.widen(Validated.valid(port));
                } else {
                    return VALIDATED.widen(Validated.invalid(
                        List.of("Port " + port + " is out of valid range (1024-65535)")
                    ));
                }
            };
  
        return VALIDATED.narrow(
            ALL_DB_PORTS.modifyF(
                validatePort, 
                config, 
                ValidatedMonad.instance(Semigroups.list())
            )
        );
    }
}
</code></pre>
<h2 id="complete-runnable-example-3"><a class="header" href="#complete-runnable-example-3">Complete, Runnable Example</a></h2>
<p>This example demonstrates how to use the <code>with*</code> helpers for a targeted update and how to use a composed <code>Traversal</code> with the new utility methods for bulk operations.</p>
<pre><code class="language-java">package org.higherkindedj.example.optics;

import java.util.ArrayList;
import java.util.List;
import org.higherkindedj.optics.Lens;
import org.higherkindedj.optics.Traversal;
import org.higherkindedj.optics.annotations.GenerateLenses;
import org.higherkindedj.optics.annotations.GenerateTraversals;
import org.higherkindedj.optics.util.Traversals;

public class TraversalUsageExample {

    @GenerateLenses
    public record Player(String name, int score) {}
  
    @GenerateLenses
    @GenerateTraversals
    public record Team(String name, List&lt;Player&gt; players) {}
  
    @GenerateLenses
    @GenerateTraversals
    public record League(String name, List&lt;Team&gt; teams) {}
  
    public static void main(String[] args) {
        var team1 = new Team("Team Alpha", List.of(
            new Player("Alice", 100), 
            new Player("Bob", 90)
        ));
        var team2 = new Team("Team Bravo", List.of(
            new Player("Charlie", 110), 
            new Player("Diana", 120)
        ));
        var league = new League("Pro League", List.of(team1, team2));
  
        System.out.println("=== TRAVERSAL USAGE EXAMPLE ===");
        System.out.println("Original League: " + league);
        System.out.println("------------------------------------------");
  
        // --- SCENARIO 1: Using `with*` helpers for a targeted, shallow update ---
        System.out.println("--- Scenario 1: Shallow Update with `with*` Helpers ---");
        var teamToUpdate = league.teams().get(0);
        var updatedTeam = TeamLenses.withName(teamToUpdate, "Team Omega");
        var newTeamsList = new ArrayList&lt;&gt;(league.teams());
        newTeamsList.set(0, updatedTeam);
        var leagueWithUpdatedTeam = LeagueLenses.withTeams(league, newTeamsList);
  
        System.out.println("After updating one team's name:");
        System.out.println(leagueWithUpdatedTeam);
        System.out.println("------------------------------------------");
  
        // --- SCENARIO 2: Using composed Traversals for deep, bulk updates ---
        System.out.println("--- Scenario 2: Bulk Updates with Composed Traversals ---");
    
        // Create the composed traversal
        Traversal&lt;League, Integer&gt; leagueToAllPlayerScores =
            LeagueTraversals.teams()
                .andThen(TeamTraversals.players())
                .andThen(PlayerLenses.score().asTraversal());
  
        // Use the `modify` helper to add 5 bonus points to every score.
        League updatedLeague = Traversals.modify(leagueToAllPlayerScores, score -&gt; score + 5, league);
        System.out.println("After adding 5 bonus points to all players:");
        System.out.println(updatedLeague);
        System.out.println();
    
        // --- SCENARIO 3: Extracting data with `getAll` ---
        System.out.println("--- Scenario 3: Data Extraction ---");
    
        List&lt;Integer&gt; allScores = Traversals.getAll(leagueToAllPlayerScores, league);
        System.out.println("All player scores: " + allScores);
        System.out.println("Total players: " + allScores.size());
        System.out.println("Average score: " + allScores.stream().mapToInt(Integer::intValue).average().orElse(0.0));
        System.out.println();
    
        // --- SCENARIO 4: Conditional updates ---
        System.out.println("--- Scenario 4: Conditional Updates ---");
    
        // Give bonus points only to players with scores &gt;= 100
        League bonusLeague = Traversals.modify(
            leagueToAllPlayerScores, 
            score -&gt; score &gt;= 100 ? score + 20 : score, 
            league
        );
        System.out.println("After conditional bonus (20 points for scores &gt;= 100):");
        System.out.println(bonusLeague);
        System.out.println();
    
        // --- SCENARIO 5: Multiple traversals ---
        System.out.println("--- Scenario 5: Multiple Traversals ---");
    
        // Create a traversal for player names
        Traversal&lt;League, String&gt; leagueToAllPlayerNames =
            LeagueTraversals.teams()
                .andThen(TeamTraversals.players())
                .andThen(PlayerLenses.name().asTraversal());
    
        // Normalise all names to uppercase
        League upperCaseLeague = Traversals.modify(leagueToAllPlayerNames, String::toUpperCase, league);
        System.out.println("After converting all names to uppercase:");
        System.out.println(upperCaseLeague);
        System.out.println();
    
        // --- SCENARIO 6: Working with empty collections ---
        System.out.println("--- Scenario 6: Empty Collections ---");
    
        League emptyLeague = new League("Empty League", List.of());
        List&lt;Integer&gt; emptyScores = Traversals.getAll(leagueToAllPlayerScores, emptyLeague);
        League emptyAfterUpdate = Traversals.modify(leagueToAllPlayerScores, score -&gt; score + 100, emptyLeague);
    
        System.out.println("Empty league: " + emptyLeague);
        System.out.println("Scores from empty league: " + emptyScores);
        System.out.println("Empty league after update: " + emptyAfterUpdate);
    
        System.out.println("------------------------------------------");
        System.out.println("Original league unchanged: " + league);
    }
}
</code></pre>
<p><strong>Expected Output:</strong></p>
<pre><code>=== TRAVERSAL USAGE EXAMPLE ===
Original League: League[name=Pro League, teams=[Team[name=Team Alpha, players=[Player[name=Alice, score=100], Player[name=Bob, score=90]]], Team[name=Team Bravo, players=[Player[name=Charlie, score=110], Player[name=Diana, score=120]]]]]
------------------------------------------
--- Scenario 1: Shallow Update with `with*` Helpers ---
After updating one team's name:
League[name=Pro League, teams=[Team[name=Team Omega, players=[Player[name=Alice, score=100], Player[name=Bob, score=90]]], Team[name=Team Bravo, players=[Player[name=Charlie, score=110], Player[name=Diana, score=120]]]]]
------------------------------------------
--- Scenario 2: Bulk Updates with Composed Traversals ---
After adding 5 bonus points to all players:
League[name=Pro League, teams=[Team[name=Team Alpha, players=[Player[name=Alice, score=105], Player[name=Bob, score=95]]], Team[name=Team Bravo, players=[Player[name=Charlie, score=115], Player[name=Diana, score=125]]]]]

--- Scenario 3: Data Extraction ---
All player scores: [100, 90, 110, 120]
Total players: 4
Average score: 105.0

--- Scenario 4: Conditional Updates ---
After conditional bonus (20 points for scores &gt;= 100):
League[name=Pro League, teams=[Team[name=Team Alpha, players=[Player[name=Alice, score=120], Player[name=Bob, score=90]]], Team[name=Team Bravo, players=[Player[name=Charlie, score=130], Player[name=Diana, score=140]]]]]

--- Scenario 5: Multiple Traversals ---
After converting all names to uppercase:
League[name=Pro League, teams=[Team[name=Team Alpha, players=[Player[name=ALICE, score=100], Player[name=BOB, score=90]]], Team[name=Team Bravo, players=[Player[name=CHARLIE, score=110], Player[name=DIANA, score=120]]]]]

--- Scenario 6: Working with Empty Collections ---
Empty league: League[name=Empty League, teams=[]]
Scores from empty league: []
Empty league after update: League[name=Empty League, teams=[]]
------------------------------------------
Original league unchanged: League[name=Pro League, teams=[Team[name=Team Alpha, players=[Player[name=Alice, score=100], Player[name=Bob, score=90]]], Team[name=Team Bravo, players=[Player[name=Charlie, score=110], Player[name=Diana, score=120]]]]]
</code></pre>
<hr />
<h2 id="unifying-the-concepts"><a class="header" href="#unifying-the-concepts">Unifying the Concepts</a></h2>
<p>A <code>Traversal</code> is the most general of the core optics. In fact, all other optics can be seen as specialised <code>Traversal</code>s:</p>
<ul>
<li>A <code>Lens</code> is just a <code>Traversal</code> that always focuses on <strong>exactly one</strong> item.</li>
<li>A <code>Prism</code> is just a <code>Traversal</code> that focuses on <strong>zero or one</strong> item.</li>
<li>An <code>Iso</code> is just a <code>Traversal</code> that focuses on <strong>exactly one</strong> item and is reversible.</li>
</ul>
<p>This is the reason they can all be composed together so seamlessly. By mastering <code>Traversal</code>, you complete your understanding of the core optics family, enabling you to build powerful, declarative, and safe data transformations that work efficiently across any number of targets.</p>
<hr />
<p><strong>Previous:</strong> <a href="optics/iso.html">Isomorphisms: Data Equivalence</a>
<strong>Next:</strong> <a href="optics/folds.html">Folds: Querying Immutable Data</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="folds-a-practical-guide"><a class="header" href="#folds-a-practical-guide">Folds: A Practical Guide</a></h1>
<h2 id="querying-immutable-data"><a class="header" href="#querying-immutable-data"><em>Querying Immutable Data</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="optics/folds.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to query and extract data from complex structures without modification</li>
<li>Using <code>@GenerateFolds</code> to create type-safe query optics automatically</li>
<li>Understanding the relationship between Fold and the Foldable type class</li>
<li>Aggregating data with monoids for sums, products, and custom combiners</li>
<li>Composing folds with other optics for deep, conditional queries</li>
<li>The difference between <code>getAll</code>, <code>preview</code>, <code>find</code>, <code>exists</code>, <code>all</code>, and <code>length</code></li>
<li>Maybe-based extensions for functional optional handling (<code>previewMaybe</code>, <code>findMaybe</code>, <code>getAllMaybe</code>)</li>
<li>When to use Fold vs Traversal vs direct field access vs Stream API</li>
<li>Building read-only data processing pipelines with clear intent</li>
</ul>
</div>
</div>
<div id="admonition-example-code" class="admonition admonish-note" role="note" aria-labelledby="admonition-example-code-title">
<div class="admonition-title">
<div id="admonition-example-code-title">
<p>Example Code</p>
</div>
<a class="admonition-anchor-link" href="optics/folds.html#admonition-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/FoldUsageExample.java">FoldUsageExample</a></p>
</div>
</div>
<p>In previous guides, we explored optics that allow both reading and writing: <strong><code>Lens</code></strong> for required fields, <strong><code>Prism</code></strong> for conditional variants, <strong><code>Iso</code></strong> for lossless conversions, and <strong><code>Traversal</code></strong> for bulk operations on collections.</p>
<p>But what if you need to perform read-only operations? What if you want to query, search, filter, or aggregate data without any possibility of modification? This is where <strong><code>Fold</code></strong> shines.</p>
<hr />
<h2 id="the-scenario-analysing-e-commerce-orders"><a class="header" href="#the-scenario-analysing-e-commerce-orders">The Scenario: Analysing E-Commerce Orders</a></h2>
<p>A <strong><code>Fold</code></strong> is a read-only optic designed specifically for querying and data extraction. Think of it as a <strong>database query tool</strong> üîç or a <strong>telescope</strong> üî≠ that lets you peer into your data structures, extract information, and aggregate results‚Äîall without the ability to modify anything.</p>
<p>Consider an e-commerce system where you need to analyse orders:</p>
<p><strong>The Data Model:</strong></p>
<pre><code class="language-java">@GenerateLenses
public record Product(String name, double price, String category, boolean inStock) {}

@GenerateLenses
@GenerateFolds  // Generate Folds for querying
public record Order(String orderId, List&lt;Product&gt; items, String customerName) {}

@GenerateLenses
@GenerateFolds
public record OrderHistory(List&lt;Order&gt; orders) {}
</code></pre>
<p><strong>Common Query Needs:</strong></p>
<ul>
<li>"Find all products in this order"</li>
<li>"Get the first product or empty if none"</li>
<li>"Check if any product is out of stock"</li>
<li>"Count how many items are in the order"</li>
<li>"Calculate the total price of all items"</li>
<li>"Check if all items are under ¬£100"</li>
</ul>
<p>A <code>Fold</code> makes these queries type-safe, composable, and expressive.</p>
<hr />
<h2 id="think-of-folds-like"><a class="header" href="#think-of-folds-like">Think of Folds Like...</a></h2>
<ul>
<li><strong>A database query</strong>: Extracting specific data from complex structures</li>
<li><strong>A read-only telescope</strong>: Magnifying and examining data without touching it</li>
<li><strong>A search engine</strong>: Finding and collecting information efficiently</li>
<li><strong>An aggregation pipeline</strong>: Combining values according to rules (via monoids)</li>
<li><strong>A reporter</strong>: Summarising data into useful metrics</li>
</ul>
<hr />
<h2 id="fold-vs-traversal-understanding-the-difference"><a class="header" href="#fold-vs-traversal-understanding-the-difference">Fold vs Traversal: Understanding the Difference</a></h2>
<p>Before we dive deeper, it's crucial to understand how <code>Fold</code> relates to <code>Traversal</code>:</p>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th>Traversal</th><th>Fold</th></tr></thead><tbody>
<tr><td><strong>Purpose</strong></td><td>Read and modify collections</td><td>Read-only queries</td></tr>
<tr><td><strong>Can modify?</strong></td><td>‚úÖ Yes (<code>set</code>, <code>modify</code>)</td><td>‚ùå No</td></tr>
<tr><td><strong>Query operations</strong></td><td>‚úÖ Yes (via <code>getAll</code>, but not primary purpose)</td><td>‚úÖ Yes (designed for this)</td></tr>
<tr><td><strong>Intent clarity</strong></td><td>"I might modify this"</td><td>"I'm only reading this"</td></tr>
<tr><td><strong>Conversion</strong></td><td>Can be converted to Fold via <code>asFold()</code></td><td>Cannot be converted to Traversal</td></tr>
<tr><td><strong>Use cases</strong></td><td>Bulk updates, validation with modifications</td><td>Queries, searches, aggregations</td></tr>
</tbody></table>
</div>
<p><strong>Key Insight</strong>: Every <code>Traversal</code> can be viewed as a <code>Fold</code> (read-only subset), but not every <code>Fold</code> can be a <code>Traversal</code>. By choosing <code>Fold</code> when you only need reading, you make your code's intent clear and prevent accidental modifications.</p>
<hr />
<h2 id="a-step-by-step-walkthrough-4"><a class="header" href="#a-step-by-step-walkthrough-4">A Step-by-Step Walkthrough</a></h2>
<h3 id="step-1-generating-folds"><a class="header" href="#step-1-generating-folds">Step 1: Generating Folds</a></h3>
<p>Just like with other optics, we use annotations to trigger automatic code generation. Annotating a record with <strong><code>@GenerateFolds</code></strong> creates a companion class (e.g., <code>OrderFolds</code>) containing a <code>Fold</code> for each field.</p>
<pre><code class="language-java">import org.higherkindedj.optics.annotations.GenerateFolds;
import org.higherkindedj.optics.annotations.GenerateLenses;
import java.util.List;

@GenerateLenses
public record Product(String name, double price, String category, boolean inStock) {}

@GenerateLenses
@GenerateFolds
public record Order(String orderId, List&lt;Product&gt; items, String customerName) {}
</code></pre>
<p>This generates:</p>
<ul>
<li><code>OrderFolds.items()</code> ‚Üí <code>Fold&lt;Order, Product&gt;</code> (focuses on all products)</li>
<li><code>OrderFolds.orderId()</code> ‚Üí <code>Fold&lt;Order, String&gt;</code> (focuses on the order ID)</li>
<li><code>OrderFolds.customerName()</code> ‚Üí <code>Fold&lt;Order, String&gt;</code> (focuses on customer name)</li>
</ul>
<h3 id="step-2-the-core-fold-operations"><a class="header" href="#step-2-the-core-fold-operations">Step 2: The Core Fold Operations</a></h3>
<p>A <code>Fold&lt;S, A&gt;</code> provides these essential query operations:</p>
<h4 id="getallsource-extract-all-focused-values"><a class="header" href="#getallsource-extract-all-focused-values"><strong><code>getAll(source)</code></strong>: Extract All Focused Values</a></h4>
<p>Returns a <code>List&lt;A&gt;</code> containing all the values the Fold focuses on.</p>
<pre><code class="language-java">Fold&lt;Order, Product&gt; itemsFold = OrderFolds.items();
Order order = new Order("ORD-123", List.of(
    new Product("Laptop", 999.99, "Electronics", true),
    new Product("Mouse", 25.00, "Electronics", true),
    new Product("Desk", 350.00, "Furniture", false)
), "Alice");

List&lt;Product&gt; allProducts = itemsFold.getAll(order);
// Result: [Product[Laptop, 999.99, ...], Product[Mouse, 25.00, ...], Product[Desk, 350.00, ...]]
</code></pre>
<h4 id="previewsource-get-the-first-value"><a class="header" href="#previewsource-get-the-first-value"><strong><code>preview(source)</code></strong>: Get the First Value</a></h4>
<p>Returns an <code>Optional&lt;A&gt;</code> containing the first focused value, or <code>Optional.empty()</code> if none exist.</p>
<pre><code class="language-java">Optional&lt;Product&gt; firstProduct = itemsFold.preview(order);
// Result: Optional[Product[Laptop, 999.99, ...]]

Order emptyOrder = new Order("ORD-456", List.of(), "Bob");
Optional&lt;Product&gt; noProduct = itemsFold.preview(emptyOrder);
// Result: Optional.empty
</code></pre>
<h4 id="findpredicate-source-find-first-matching-value"><a class="header" href="#findpredicate-source-find-first-matching-value"><strong><code>find(predicate, source)</code></strong>: Find First Matching Value</a></h4>
<p>Returns an <code>Optional&lt;A&gt;</code> containing the first value that matches the predicate.</p>
<pre><code class="language-java">Optional&lt;Product&gt; expensiveProduct = itemsFold.find(
    product -&gt; product.price() &gt; 500.00,
    order
);
// Result: Optional[Product[Laptop, 999.99, ...]]
</code></pre>
<h4 id="existspredicate-source-check-if-any-match"><a class="header" href="#existspredicate-source-check-if-any-match"><strong><code>exists(predicate, source)</code></strong>: Check If Any Match</a></h4>
<p>Returns <code>true</code> if at least one focused value matches the predicate.</p>
<pre><code class="language-java">boolean hasOutOfStock = itemsFold.exists(
    product -&gt; !product.inStock(),
    order
);
// Result: true (Desk is out of stock)
</code></pre>
<h4 id="allpredicate-source-check-if-all-match"><a class="header" href="#allpredicate-source-check-if-all-match"><strong><code>all(predicate, source)</code></strong>: Check If All Match</a></h4>
<p>Returns <code>true</code> if all focused values match the predicate (returns <code>true</code> for empty collections).</p>
<pre><code class="language-java">boolean allInStock = itemsFold.all(
    product -&gt; product.inStock(),
    order
);
// Result: false (Desk is out of stock)
</code></pre>
<h4 id="isemptysource-check-for-empty"><a class="header" href="#isemptysource-check-for-empty"><strong><code>isEmpty(source)</code></strong>: Check for Empty</a></h4>
<p>Returns <code>true</code> if there are zero focused values.</p>
<pre><code class="language-java">boolean hasItems = !itemsFold.isEmpty(order);
// Result: true
</code></pre>
<h4 id="lengthsource-count-values"><a class="header" href="#lengthsource-count-values"><strong><code>length(source)</code></strong>: Count Values</a></h4>
<p>Returns the number of focused values as an <code>int</code>.</p>
<pre><code class="language-java">int itemCount = itemsFold.length(order);
// Result: 3
</code></pre>
<h3 id="step-25-maybe-based-fold-extensions"><a class="header" href="#step-25-maybe-based-fold-extensions">Step 2.5: Maybe-Based Fold Extensions</a></h3>
<div id="admonition-extension-methods" class="admonition admonish-note" role="note" aria-labelledby="admonition-extension-methods-title">
<div class="admonition-title">
<div id="admonition-extension-methods-title">
<p>Extension Methods</p>
</div>
<a class="admonition-anchor-link" href="optics/folds.html#admonition-extension-methods"></a>
</div>
<div>
<p>Higher-kinded-j provides extension methods that integrate <code>Fold</code> with the <code>Maybe</code> type, offering a more functional approach to handling absent values compared to Java's <code>Optional</code>. These extensions are available via static imports from <code>FoldExtensions</code>.</p>
</div>
</div>
<h4 id="the-challenge-working-with-nullable-values"><a class="header" href="#the-challenge-working-with-nullable-values">The Challenge: Working with Nullable Values</a></h4>
<p>Standard Fold operations use <code>Optional&lt;A&gt;</code> for operations that might not find a value (like <code>preview</code> and <code>find</code>). While <code>Optional</code> works well, functional programming often prefers <code>Maybe</code> because it:</p>
<ul>
<li>Integrates seamlessly with Higher-Kinded Types (HKT)</li>
<li>Works consistently with other monadic operations (<code>flatMap</code>, <code>map</code>, <code>fold</code>)</li>
<li>Provides better composition with validation and error handling types</li>
<li>Offers a more principled functional API</li>
</ul>
<p>Think of <code>Maybe</code> as <code>Optional</code>'s more functional cousin‚Äîthey both represent "a value or nothing", but <code>Maybe</code> plays more nicely with the rest of the functional toolkit.</p>
<h4 id="think-of-maybe-based-extensions-like"><a class="header" href="#think-of-maybe-based-extensions-like">Think of Maybe-Based Extensions Like...</a></h4>
<ul>
<li><strong>A search that returns "found" or "not found"</strong> - <code>Maybe</code> explicitly models presence or absence</li>
<li><strong>A safe lookup in a dictionary</strong> - Either you get the value wrapped in <code>Just</code>, or you get <code>Nothing</code></li>
<li><strong>A nullable pointer that can't cause NPE</strong> - You must explicitly check before unwrapping</li>
<li><strong>Optional's functional sibling</strong> - Same concept, better integration with functional patterns</li>
</ul>
<h4 id="the-three-extension-methods"><a class="header" href="#the-three-extension-methods">The Three Extension Methods</a></h4>
<p>All three methods are static imports from <code>org.higherkindedj.optics.extensions.FoldExtensions</code>:</p>
<pre><code class="language-java">import static org.higherkindedj.optics.extensions.FoldExtensions.*;
</code></pre>
<h5 id="1-previewmaybefold-source---get-first-value-as-maybe"><a class="header" href="#1-previewmaybefold-source---get-first-value-as-maybe">1. <code>previewMaybe(fold, source)</code> - Get First Value as Maybe</a></h5>
<p>The <code>previewMaybe</code> method is the <code>Maybe</code>-based equivalent of <code>preview()</code>. It returns the first focused value wrapped in <code>Maybe</code>, or <code>Maybe.nothing()</code> if none exist.</p>
<pre><code class="language-java">import org.higherkindedj.hkt.maybe.Maybe;
import static org.higherkindedj.optics.extensions.FoldExtensions.previewMaybe;

Fold&lt;Order, Product&gt; itemsFold = OrderFolds.items();
Order order = new Order("ORD-123", List.of(
    new Product("Laptop", 999.99, "Electronics", true),
    new Product("Mouse", 25.00, "Electronics", true)
), "Alice");

Maybe&lt;Product&gt; firstProduct = previewMaybe(itemsFold, order);
// Result: Just(Product[Laptop, 999.99, ...])

Order emptyOrder = new Order("ORD-456", List.of(), "Bob");
Maybe&lt;Product&gt; noProduct = previewMaybe(itemsFold, emptyOrder);
// Result: Nothing
</code></pre>
<p><strong>When to use <code>previewMaybe</code> vs <code>preview</code>:</strong></p>
<ul>
<li>Use <code>previewMaybe</code> when working in a functional pipeline with other <code>Maybe</code> values</li>
<li>Use <code>preview</code> when interoperating with standard Java code expecting <code>Optional</code></li>
<li>Use <code>previewMaybe</code> when you need HKT compatibility for generic functional abstractions</li>
</ul>
<h5 id="2-findmaybefold-predicate-source---find-first-match-as-maybe"><a class="header" href="#2-findmaybefold-predicate-source---find-first-match-as-maybe">2. <code>findMaybe(fold, predicate, source)</code> - Find First Match as Maybe</a></h5>
<p>The <code>findMaybe</code> method is the <code>Maybe</code>-based equivalent of <code>find()</code>. It returns the first focused value matching the predicate, or <code>Maybe.nothing()</code> if no match is found.</p>
<pre><code class="language-java">import static org.higherkindedj.optics.extensions.FoldExtensions.findMaybe;

Fold&lt;Order, Product&gt; itemsFold = OrderFolds.items();

Maybe&lt;Product&gt; expensiveProduct = findMaybe(
    itemsFold,
    product -&gt; product.price() &gt; 500.00,
    order
);
// Result: Just(Product[Laptop, 999.99, ...])

Maybe&lt;Product&gt; luxuryProduct = findMaybe(
    itemsFold,
    product -&gt; product.price() &gt; 5000.00,
    order
);
// Result: Nothing
</code></pre>
<p><strong>Common Use Cases:</strong></p>
<ul>
<li><strong>Product search</strong>: Find first available item matching criteria</li>
<li><strong>Validation</strong>: Locate the first invalid field in a form</li>
<li><strong>Configuration</strong>: Find the first matching configuration option</li>
<li><strong>Inventory</strong>: Locate first in-stock item in a category</li>
</ul>
<h5 id="3-getallmaybefold-source---get-all-values-as-maybe-wrapped-list"><a class="header" href="#3-getallmaybefold-source---get-all-values-as-maybe-wrapped-list">3. <code>getAllMaybe(fold, source)</code> - Get All Values as Maybe-Wrapped List</a></h5>
<p>The <code>getAllMaybe</code> method returns all focused values as <code>Maybe&lt;List&lt;A&gt;&gt;</code>. If the Fold finds at least one value, you get <code>Just(List&lt;A&gt;)</code>. If it finds nothing, you get <code>Nothing</code>.</p>
<p>This is particularly useful when you want to distinguish between "found an empty collection" and "found no results".</p>
<pre><code class="language-java">import static org.higherkindedj.optics.extensions.FoldExtensions.getAllMaybe;

Fold&lt;Order, Product&gt; itemsFold = OrderFolds.items();

Maybe&lt;List&lt;Product&gt;&gt; allProducts = getAllMaybe(itemsFold, order);
// Result: Just([Product[Laptop, ...], Product[Mouse, ...]])

Order emptyOrder = new Order("ORD-456", List.of(), "Bob");
Maybe&lt;List&lt;Product&gt;&gt; noProducts = getAllMaybe(itemsFold, emptyOrder);
// Result: Nothing
</code></pre>
<p><strong>When to use <code>getAllMaybe</code> vs <code>getAll</code>:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Scenario</th><th>Use <code>getAll()</code></th><th>Use <code>getAllMaybe()</code></th></tr></thead><tbody>
<tr><td>You need the list regardless of emptiness</td><td>‚úÖ Returns <code>List&lt;A&gt;</code> (possibly empty)</td><td>‚ùå Overkill</td></tr>
<tr><td>You want to treat empty results as a failure case</td><td>‚ùå Must check <code>isEmpty()</code> manually</td><td>‚úÖ Returns <code>Nothing</code> for empty results</td></tr>
<tr><td>You're chaining functional operations with Maybe</td><td>‚ùå Requires conversion</td><td>‚úÖ Directly composable</td></tr>
<tr><td>Performance-critical batch processing</td><td>‚úÖ Direct list access</td><td>‚ùå Extra Maybe wrapping</td></tr>
</tbody></table>
</div>
<h4 id="real-world-scenario-product-search-with-maybe"><a class="header" href="#real-world-scenario-product-search-with-maybe">Real-World Scenario: Product Search with Maybe</a></h4>
<p>Here's a practical example showing how Maybe-based extensions simplify null-safe querying:</p>
<pre><code class="language-java">import org.higherkindedj.optics.Fold;
import org.higherkindedj.optics.annotations.GenerateFolds;
import org.higherkindedj.hkt.maybe.Maybe;
import static org.higherkindedj.optics.extensions.FoldExtensions.*;

@GenerateFolds
public record ProductCatalog(List&lt;Product&gt; products) {}

public class ProductSearchService {
    private static final Fold&lt;ProductCatalog, Product&gt; ALL_PRODUCTS =
        ProductCatalogFolds.products();

    // Find the cheapest in-stock product in a category
    public Maybe&lt;Product&gt; findCheapestInCategory(
        ProductCatalog catalog,
        String category
    ) {
        return getAllMaybe(ALL_PRODUCTS, catalog)
            .map(products -&gt; products.stream()
                .filter(p -&gt; category.equals(p.category()))
                .filter(Product::inStock)
                .min(Comparator.comparing(Product::price))
                .orElse(null)
            )
            .flatMap(Maybe::fromNullable);  // Convert null to Nothing
    }

    // Get first premium product (&gt;¬£1000)
    public Maybe&lt;Product&gt; findPremiumProduct(ProductCatalog catalog) {
        return findMaybe(
            ALL_PRODUCTS,
            product -&gt; product.price() &gt; 1000.00,
            catalog
        );
    }

    // Check if any products are available
    public boolean hasAvailableProducts(ProductCatalog catalog) {
        return getAllMaybe(ALL_PRODUCTS, catalog)
            .map(products -&gt; products.stream().anyMatch(Product::inStock))
            .getOrElse(false);
    }

    // Extract all product names (or empty message)
    public String getProductSummary(ProductCatalog catalog) {
        return getAllMaybe(ALL_PRODUCTS, catalog)
            .map(products -&gt; products.stream()
                .map(Product::name)
                .collect(Collectors.joining(", "))
            )
            .getOrElse("No products available");
    }
}
</code></pre>
<h4 id="optional-vs-maybe-a-comparison"><a class="header" href="#optional-vs-maybe-a-comparison">Optional vs Maybe: A Comparison</a></h4>
<p>Understanding when to use each type helps you make informed decisions:</p>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th><code>Optional&lt;A&gt;</code></th><th><code>Maybe&lt;A&gt;</code></th></tr></thead><tbody>
<tr><td><strong>Purpose</strong></td><td>Standard Java optional values</td><td>Functional optional values with HKT support</td></tr>
<tr><td><strong>Package</strong></td><td><code>java.util.Optional</code></td><td><code>org.higherkindedj.hkt.maybe.Maybe</code></td></tr>
<tr><td><strong>HKT Support</strong></td><td>‚ùå No</td><td>‚úÖ Yes (integrates with <code>Kind&lt;F, A&gt;</code>)</td></tr>
<tr><td><strong>Monadic Operations</strong></td><td>Limited (<code>map</code>, <code>flatMap</code>, <code>filter</code>)</td><td>Full (<code>map</code>, <code>flatMap</code>, <code>filter</code>, <code>fold</code>, <code>getOrElse</code>, etc.)</td></tr>
<tr><td><strong>Java Interop</strong></td><td>‚úÖ Native support</td><td>‚ùå Requires conversion</td></tr>
<tr><td><strong>Functional Composition</strong></td><td>Basic</td><td>‚úÖ Excellent (works with Applicative, Monad, etc.)</td></tr>
<tr><td><strong>Pattern Matching</strong></td><td><code>ifPresent()</code>, <code>orElse()</code></td><td><code>isJust()</code>, <code>isNothing()</code>, <code>fold()</code></td></tr>
<tr><td><strong>Use Cases</strong></td><td>Standard Java APIs, interop</td><td>Functional pipelines, HKT abstractions</td></tr>
<tr><td><strong>Conversion</strong></td><td><code>Maybe.fromOptional(opt)</code></td><td><code>maybe.toOptional()</code></td></tr>
</tbody></table>
</div>
<p><strong>Best Practice</strong>: Use <code>Optional</code> at API boundaries (public methods, external libraries) and <code>Maybe</code> internally in functional pipelines.</p>
<h4 id="when-to-use-each-extension-method"><a class="header" href="#when-to-use-each-extension-method">When to Use Each Extension Method</a></h4>
<p>Here's a decision matrix to help you choose the right method:</p>
<p><strong>Use <code>previewMaybe</code> when:</strong></p>
<ul>
<li>You need the first value from a Fold</li>
<li>You're working in a functional pipeline with other <code>Maybe</code> values</li>
<li>You want to chain operations (<code>map</code>, <code>flatMap</code>, <code>fold</code>) on the result</li>
<li>You need HKT compatibility</li>
</ul>
<pre><code class="language-java">// Example: Get first expensive product and calculate discount
Maybe&lt;Double&gt; discountedPrice = previewMaybe(productsFold, order)
    .filter(p -&gt; p.price() &gt; 100)
    .map(p -&gt; p.price() * 0.9);
</code></pre>
<p><strong>Use <code>findMaybe</code> when:</strong></p>
<ul>
<li>You need to locate a specific value matching a predicate</li>
<li>You want to avoid the verbosity of <code>getAll().stream().filter().findFirst()</code></li>
<li>You're building search functionality</li>
<li>You want to short-circuit on the first match (performance)</li>
</ul>
<pre><code class="language-java">// Example: Find first out-of-stock item
Maybe&lt;Product&gt; outOfStock = findMaybe(
    productsFold,
    p -&gt; !p.inStock(),
    order
);
</code></pre>
<p><strong>Use <code>getAllMaybe</code> when:</strong></p>
<ul>
<li>You want to treat empty results as a "nothing" case</li>
<li>You want to chain functional operations on the entire result set</li>
<li>You're building batch processing pipelines</li>
<li>You need to propagate "nothing found" through your computation</li>
</ul>
<pre><code class="language-java">// Example: Process all products or provide default behaviour
String report = getAllMaybe(productsFold, order)
    .map(products -&gt; generateReport(products))
    .getOrElse("No products to report");
</code></pre>
<h4 id="integration-with-existing-fold-operations"><a class="header" href="#integration-with-existing-fold-operations">Integration with Existing Fold Operations</a></h4>
<p>Maybe-based extensions work seamlessly alongside standard Fold operations. You can mix and match based on your needs:</p>
<pre><code class="language-java">Fold&lt;Order, Product&gt; itemsFold = OrderFolds.items();

// Standard Fold operations
List&lt;Product&gt; allItems = itemsFold.getAll(order);           // Always returns list
Optional&lt;Product&gt; firstOpt = itemsFold.preview(order);     // Optional-based
int count = itemsFold.length(order);                        // Primitive int

// Maybe-based extensions
Maybe&lt;Product&gt; firstMaybe = previewMaybe(itemsFold, order);     // Maybe-based
Maybe&lt;Product&gt; matchMaybe = findMaybe(itemsFold, p -&gt; ..., order);  // Maybe-based
Maybe&lt;List&lt;Product&gt;&gt; allMaybe = getAllMaybe(itemsFold, order);      // Maybe-wrapped list
</code></pre>
<p><strong>Conversion Between Optional and Maybe:</strong></p>
<pre><code class="language-java">// Convert Optional to Maybe
Optional&lt;Product&gt; optional = itemsFold.preview(order);
Maybe&lt;Product&gt; maybe = Maybe.fromOptional(optional);

// Convert Maybe to Optional
Maybe&lt;Product&gt; maybe = previewMaybe(itemsFold, order);
Optional&lt;Product&gt; optional = maybe.toOptional();
</code></pre>
<h4 id="performance-considerations-1"><a class="header" href="#performance-considerations-1">Performance Considerations</a></h4>
<p>Maybe-based extensions have minimal overhead:</p>
<ul>
<li><strong><code>previewMaybe</code></strong>: Same performance as <code>preview()</code>, just wraps in <code>Maybe</code> instead of <code>Optional</code></li>
<li><strong><code>findMaybe</code></strong>: Identical to <code>find()</code> - short-circuits on first match</li>
<li><strong><code>getAllMaybe</code></strong>: Adds one extra <code>Maybe</code> wrapping over <code>getAll()</code> - negligible cost</li>
</ul>
<p><strong>Optimisation Tip</strong>: For performance-critical code, prefer <code>getAll()</code> if you don't need the Maybe semantics. The extra wrapping and pattern matching adds a small but measurable cost in tight loops.</p>
<h4 id="practical-example-safe-navigation-with-maybe"><a class="header" href="#practical-example-safe-navigation-with-maybe">Practical Example: Safe Navigation with Maybe</a></h4>
<p>Combining <code>getAllMaybe</code> with composed folds creates powerful null-safe query pipelines:</p>
<pre><code class="language-java">import org.higherkindedj.optics.Fold;
import org.higherkindedj.hkt.maybe.Maybe;
import static org.higherkindedj.optics.extensions.FoldExtensions.*;

@GenerateFolds
public record OrderHistory(List&lt;Order&gt; orders) {}

public class OrderAnalytics {
    private static final Fold&lt;OrderHistory, Order&gt; ORDERS =
        OrderHistoryFolds.orders();
    private static final Fold&lt;Order, Product&gt; PRODUCTS =
        OrderFolds.items();

    // Calculate total revenue, handling empty history gracefully
    public double calculateRevenue(OrderHistory history) {
        return getAllMaybe(ORDERS, history)
            .flatMap(orders -&gt; {
                List&lt;Double&gt; prices = orders.stream()
                    .flatMap(order -&gt; getAllMaybe(PRODUCTS, order)
                        .map(products -&gt; products.stream().map(Product::price))
                        .getOrElse(Stream.empty()))
                    .toList();
                return prices.isEmpty() ? Maybe.nothing() : Maybe.just(prices);
            })
            .map(prices -&gt; prices.stream().mapToDouble(Double::doubleValue).sum())
            .getOrElse(0.0);
    }

    // Find most expensive product across all orders
    public Maybe&lt;Product&gt; findMostExpensive(OrderHistory history) {
        return getAllMaybe(ORDERS, history)
            .flatMap(orders -&gt; {
                List&lt;Product&gt; allProducts = orders.stream()
                    .flatMap(order -&gt; getAllMaybe(PRODUCTS, order)
                        .map(List::stream)
                        .getOrElse(Stream.empty()))
                    .toList();
                return allProducts.isEmpty()
                    ? Maybe.nothing()
                    : Maybe.fromNullable(allProducts.stream()
                        .max(Comparator.comparing(Product::price))
                        .orElse(null));
            });
    }
}
</code></pre>
<div id="admonition-complete-example" class="admonition admonish-note" role="note" aria-labelledby="admonition-complete-example-title">
<div class="admonition-title">
<div id="admonition-complete-example-title">
<p>Complete Example</p>
</div>
<a class="admonition-anchor-link" href="optics/folds.html#admonition-complete-example"></a>
</div>
<div>
<p>See <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/extensions/FoldExtensionsExample.java">FoldExtensionsExample.java</a> for a runnable demonstration of all Maybe-based Fold extensions.</p>
</div>
</div>
<hr />
<h3 id="step-3-composing-folds-for-deep-queries"><a class="header" href="#step-3-composing-folds-for-deep-queries">Step 3: Composing Folds for Deep Queries</a></h3>
<p>Folds can be composed with other optics to create deep query paths. When composing with <code>Lens</code>, <code>Prism</code>, or other <code>Fold</code> instances, use <code>andThen()</code>.</p>
<pre><code class="language-java">// Get all product names from all orders in history
Fold&lt;OrderHistory, Order&gt; historyToOrders = OrderHistoryFolds.orders();
Fold&lt;Order, Product&gt; orderToProducts = OrderFolds.items();
Lens&lt;Product, String&gt; productToName = ProductLenses.name();

Fold&lt;OrderHistory, String&gt; historyToAllProductNames =
    historyToOrders
        .andThen(orderToProducts)
        .andThen(productToName.asFold());

OrderHistory history = new OrderHistory(List.of(order1, order2, order3));
List&lt;String&gt; allProductNames = historyToAllProductNames.getAll(history);
// Result: ["Laptop", "Mouse", "Desk", "Keyboard", "Monitor", ...]
</code></pre>
<h3 id="step-4-aggregation-with-foldmap-and-monoids"><a class="header" href="#step-4-aggregation-with-foldmap-and-monoids">Step 4: Aggregation with <code>foldMap</code> and Monoids</a></h3>
<p>The most powerful feature of <code>Fold</code> is its ability to aggregate data using <strong>monoids</strong>. This is where Fold truly shines for combining values in flexible, reusable ways.</p>
<h4 id="understanding-monoids-the-simple-explanation"><a class="header" href="#understanding-monoids-the-simple-explanation">Understanding Monoids: The Simple Explanation</a></h4>
<p>Think of a monoid as a recipe for combining things. It needs two ingredients:</p>
<ol>
<li><strong>A starting value</strong> (called <code>empty</code>) - like starting with 0 when adding numbers, or "" when joining strings</li>
<li><strong>A combining rule</strong> (called <code>combine</code>) - like "add these two numbers" or "concatenate these two strings"</li>
</ol>
<p><strong>Simple Examples:</strong></p>
<ul>
<li><strong>Adding numbers</strong>: Start with 0, combine by adding ‚Üí <code>0 + 5 + 10 + 3 = 18</code></li>
<li><strong>Joining strings</strong>: Start with "", combine by concatenating ‚Üí <code>"" + "Hello" + " " + "World" = "Hello World"</code></li>
<li><strong>Finding maximum</strong>: Start with negative infinity, combine by taking larger value</li>
<li><strong>Checking all conditions</strong>: Start with <code>true</code>, combine with AND (&amp;&amp;) ‚Üí all must be true</li>
</ul>
<h4 id="the-power-of-foldmap"><a class="header" href="#the-power-of-foldmap">The Power of <code>foldMap</code></a></h4>
<p>The <code>foldMap</code> method lets you:</p>
<ol>
<li>Transform each focused value into a "combinable" type</li>
<li>Automatically merge all those values using a monoid</li>
</ol>
<p><strong>Example: Calculate Total Price</strong></p>
<pre><code class="language-java">import org.higherkindedj.hkt.Monoid;

Fold&lt;Order, Product&gt; products = OrderFolds.items();

// Define how to combine prices (addition)
Monoid&lt;Double&gt; sumMonoid = new Monoid&lt;&gt;() {
    @Override
    public Double empty() { return 0.0; }  // Start with zero
    @Override
    public Double combine(Double a, Double b) { return a + b; }  // Add them
};

// Extract each product's price and sum them all
double totalPrice = products.foldMap(
    sumMonoid,
    product -&gt; product.price(),  // Extract price from each product
    order
);
// Result: 1374.99 (999.99 + 25.00 + 350.00)
</code></pre>
<p><strong>What's happening here?</strong></p>
<ol>
<li>For each <code>Product</code> in the order, extract its <code>price</code> ‚Üí <code>[999.99, 25.00, 350.00]</code></li>
<li>Start with <code>0.0</code> (the empty value)</li>
<li>Combine them: <code>0.0 + 999.99 + 25.00 + 350.00 = 1374.99</code></li>
</ol>
<h4 id="common-monoid-patterns"><a class="header" href="#common-monoid-patterns">Common Monoid Patterns</a></h4>
<p>Here are the most useful monoid patterns for everyday use. <strong>Best Practice</strong>: Use the standard implementations from the <code>Monoids</code> utility class whenever possible:</p>
<pre><code class="language-java">import org.higherkindedj.hkt.Monoids;

// Standard monoids available out of the box:
Monoid&lt;Double&gt; sumDouble = Monoids.doubleAddition();
Monoid&lt;Double&gt; productDouble = Monoids.doubleMultiplication();
Monoid&lt;Integer&gt; sumInt = Monoids.integerAddition();
Monoid&lt;Integer&gt; productInt = Monoids.integerMultiplication();
Monoid&lt;Long&gt; sumLong = Monoids.longAddition();
Monoid&lt;Boolean&gt; andMonoid = Monoids.booleanAnd();
Monoid&lt;Boolean&gt; orMonoid = Monoids.booleanOr();
Monoid&lt;String&gt; stringConcat = Monoids.string();
Monoid&lt;List&lt;A&gt;&gt; listConcat = Monoids.list();
Monoid&lt;Set&lt;A&gt;&gt; setUnion = Monoids.set();
Monoid&lt;Optional&lt;A&gt;&gt; firstWins = Monoids.firstOptional();
Monoid&lt;Optional&lt;A&gt;&gt; lastWins = Monoids.lastOptional();
Monoid&lt;Optional&lt;A&gt;&gt; maxValue = Monoids.maximum();
Monoid&lt;Optional&lt;A&gt;&gt; minValue = Monoids.minimum();
</code></pre>
<p><strong>Sum (Adding Numbers)</strong></p>
<pre><code class="language-java">// Use standard monoid from Monoids class
Monoid&lt;Double&gt; sumMonoid = Monoids.doubleAddition();

// Calculate total revenue
double revenue = productsFold.foldMap(sumMonoid, ProductItem::price, order);
</code></pre>
<p><strong>Product (Multiplying Numbers)</strong></p>
<pre><code class="language-java">Monoid&lt;Double&gt; productMonoid = Monoids.doubleMultiplication();

// Calculate compound discount (e.g., 0.9 * 0.95 * 0.85)
double finalMultiplier = discountsFold.foldMap(productMonoid, d -&gt; d, discounts);
</code></pre>
<p><strong>String Concatenation</strong></p>
<pre><code class="language-java">Monoid&lt;String&gt; stringMonoid = Monoids.string();

// Join all product names
String allNames = productsFold.foldMap(stringMonoid, ProductItem::name, order);
</code></pre>
<p><strong>List Accumulation</strong></p>
<pre><code class="language-java">Monoid&lt;List&lt;String&gt;&gt; listMonoid = Monoids.list();

// Collect all categories (with duplicates)
List&lt;String&gt; categories = productsFold.foldMap(listMonoid,
    p -&gt; List.of(p.category()), order);
</code></pre>
<p><strong>Boolean AND (All Must Be True)</strong></p>
<pre><code class="language-java">Monoid&lt;Boolean&gt; andMonoid = Monoids.booleanAnd();

// Check if all products are in stock
boolean allInStock = productsFold.foldMap(andMonoid, ProductItem::inStock, order);
</code></pre>
<p><strong>Boolean OR (Any Can Be True)</strong></p>
<pre><code class="language-java">Monoid&lt;Boolean&gt; orMonoid = Monoids.booleanOr();

// Check if any product is expensive
boolean hasExpensive = productsFold.foldMap(orMonoid,
    p -&gt; p.price() &gt; 1000.0, order);
</code></pre>
<p><strong>Maximum Value</strong></p>
<pre><code class="language-java">// Use Optional-based maximum from Monoids
Monoid&lt;Optional&lt;Double&gt;&gt; maxMonoid = Monoids.maximum();

// Find highest price (returns Optional to handle empty collections)
Optional&lt;Double&gt; maxPrice = productsFold.foldMap(maxMonoid,
    p -&gt; Optional.of(p.price()), order);

// Or create a custom one for raw doubles:
Monoid&lt;Double&gt; rawMaxMonoid = new Monoid&lt;&gt;() {
    @Override public Double empty() { return Double.NEGATIVE_INFINITY; }
    @Override public Double combine(Double a, Double b) { return Math.max(a, b); }
};

double maxPriceRaw = productsFold.foldMap(rawMaxMonoid, ProductItem::price, order);
</code></pre>
<h4 id="why-monoids-matter"><a class="header" href="#why-monoids-matter">Why Monoids Matter</a></h4>
<p>Monoids give you:</p>
<ul>
<li><strong>Composability</strong>: Combine complex aggregations from simple building blocks</li>
<li><strong>Reusability</strong>: Define a monoid once, use it everywhere</li>
<li><strong>Correctness</strong>: The monoid laws guarantee consistent behaviour</li>
<li><strong>Flexibility</strong>: Create custom aggregations for your domain</li>
</ul>
<p><strong>Pro Tip</strong>: You can create custom monoids for any domain-specific aggregation logic, like calculating weighted averages, combining validation results, or merging configuration objects.</p>
<hr />
<h2 id="when-to-use-folds-vs-other-approaches"><a class="header" href="#when-to-use-folds-vs-other-approaches">When to Use Folds vs Other Approaches</a></h2>
<h3 id="use-fold-when"><a class="header" href="#use-fold-when">Use Fold When:</a></h3>
<ul>
<li><strong>Read-only queries</strong> - You only need to extract or check data</li>
<li><strong>Intent matters</strong> - You want to express "this is a query, not a modification"</li>
<li><strong>Composable searches</strong> - Building reusable query paths</li>
<li><strong>Aggregations</strong> - Using monoids for custom combining logic</li>
<li><strong>CQRS patterns</strong> - Separating queries from commands</li>
</ul>
<pre><code class="language-java">// Perfect for read-only analysis
Fold&lt;OrderHistory, Product&gt; allProducts =
    OrderHistoryFolds.orders()
        .andThen(OrderFolds.items());

boolean hasElectronics = allProducts.exists(
    p -&gt; "Electronics".equals(p.category()),
    history
);
</code></pre>
<h3 id="use-traversal-when"><a class="header" href="#use-traversal-when">Use Traversal When:</a></h3>
<ul>
<li><strong>Modifications needed</strong> - You need to update the data</li>
<li><strong>Effectful updates</strong> - Using <code>modifyF</code> for validation or async operations</li>
<li><strong>Bulk transformations</strong> - Changing multiple values at once</li>
</ul>
<pre><code class="language-java">// Use Traversal for modifications
Traversal&lt;Order, Product&gt; productTraversal = OrderTraversals.items();
Order discountedOrder = Traversals.modify(
    productTraversal.andThen(ProductLenses.price().asTraversal()),
    price -&gt; price * 0.9,
    order
);
</code></pre>
<h3 id="use-stream-api-when"><a class="header" href="#use-stream-api-when">Use Stream API When:</a></h3>
<ul>
<li><strong>Complex filtering</strong> - Multiple filter/map/reduce operations</li>
<li><strong>Parallel processing</strong> - Taking advantage of parallel streams</li>
<li><strong>Standard Java collections</strong> - Working with flat collections</li>
<li><strong>Stateful operations</strong> - Operations that require maintaining state</li>
</ul>
<pre><code class="language-java">// Better with streams for complex pipelines
List&lt;String&gt; topExpensiveItems = order.items().stream()
    .filter(p -&gt; p.price() &gt; 100)
    .sorted(Comparator.comparing(Product::price).reversed())
    .limit(5)
    .map(Product::name)
    .collect(toList());
</code></pre>
<h3 id="use-direct-field-access-when"><a class="header" href="#use-direct-field-access-when">Use Direct Field Access When:</a></h3>
<ul>
<li><strong>Simple cases</strong> - Single, straightforward field read</li>
<li><strong>Performance critical</strong> - Minimal abstraction overhead</li>
<li><strong>One-off operations</strong> - Not building reusable logic</li>
</ul>
<pre><code class="language-java">// Just use direct access for simple cases
String customerName = order.customerName();
</code></pre>
<hr />
<h2 id="common-pitfalls-5"><a class="header" href="#common-pitfalls-5">Common Pitfalls</a></h2>
<h3 id="-dont-do-this-5"><a class="header" href="#-dont-do-this-5">‚ùå Don't Do This:</a></h3>
<pre><code class="language-java">// Inefficient: Creating folds repeatedly in loops
for (Order order : orders) {
    Fold&lt;Order, Product&gt; fold = OrderFolds.items();
    List&lt;Product&gt; products = fold.getAll(order);
    // ... process products
}

// Over-engineering: Using Fold for trivial single-field access
Fold&lt;Order, String&gt; customerFold = OrderFolds.customerName();
String name = customerFold.getAll(order).get(0); // Just use order.customerName()!

// Wrong tool: Trying to modify data with a Fold
// Folds are read-only - this won't compile
// Fold&lt;Order, Product&gt; items = OrderFolds.items();
// Order updated = items.set(newProduct, order); // ‚ùå No 'set' method!

// Verbose: Unnecessary conversion when Traversal is already available
Traversal&lt;Order, Product&gt; traversal = OrderTraversals.items();
Fold&lt;Order, Product&gt; fold = traversal.asFold();
List&lt;Product&gt; products = fold.getAll(order); // Just use Traversals.getAll() directly!
</code></pre>
<h3 id="-do-this-instead-5"><a class="header" href="#-do-this-instead-5">‚úÖ Do This Instead:</a></h3>
<pre><code class="language-java">// Efficient: Create fold once, reuse many times
Fold&lt;Order, Product&gt; itemsFold = OrderFolds.items();
for (Order order : orders) {
    List&lt;Product&gt; products = itemsFold.getAll(order);
    // ... process products
}

// Right tool: Direct access for simple cases
String name = order.customerName();

// Clear intent: Use Traversal when you need modifications
Traversal&lt;Order, Product&gt; itemsTraversal = OrderTraversals.items();
Order updated = Traversals.modify(itemsTraversal, this::applyDiscount, order);

// Clear purpose: Use Fold when expressing query intent
Fold&lt;Order, Product&gt; queryItems = OrderFolds.items();
boolean hasExpensive = queryItems.exists(p -&gt; p.price() &gt; 1000, order);
</code></pre>
<hr />
<h2 id="performance-notes-5"><a class="header" href="#performance-notes-5">Performance Notes</a></h2>
<p>Folds are optimised for query operations:</p>
<ul>
<li><strong>Memory efficient</strong>: Uses iterators internally, no intermediate collections for most operations</li>
<li><strong>Lazy evaluation</strong>: Short-circuits on operations like <code>find</code> and <code>exists</code> (stops at first match)</li>
<li><strong>Reusable</strong>: Composed folds can be stored and reused across your application</li>
<li><strong>Type-safe</strong>: All operations checked at compile time</li>
<li><strong>Zero allocation</strong>: <code>foldMap</code> with monoids avoids creating intermediate collections</li>
</ul>
<p><strong>Best Practice</strong>: For frequently used query paths, create them once and store as constants:</p>
<pre><code class="language-java">public class OrderQueries {
    public static final Fold&lt;OrderHistory, Product&gt; ALL_PRODUCTS =
        OrderHistoryFolds.orders()
            .andThen(OrderFolds.items());

    public static final Fold&lt;OrderHistory, Double&gt; ALL_PRICES =
        ALL_PRODUCTS.andThen(ProductLenses.price().asFold());

    public static final Fold&lt;Order, Product&gt; ELECTRONICS =
        OrderFolds.items(); // Can filter with exists/find/getAll + stream filter
}
</code></pre>
<hr />
<h2 id="real-world-example-order-analytics"><a class="header" href="#real-world-example-order-analytics">Real-World Example: Order Analytics</a></h2>
<p>Here's a practical example showing comprehensive use of Fold for business analytics:</p>
<pre><code class="language-java">import org.higherkindedj.optics.Fold;
import org.higherkindedj.optics.Lens;
import org.higherkindedj.optics.annotations.GenerateFolds;
import org.higherkindedj.optics.annotations.GenerateLenses;
import org.higherkindedj.hkt.Monoid;
import java.time.LocalDate;
import java.util.*;

@GenerateLenses
@GenerateFolds
public record Product(String name, double price, String category, boolean inStock) {}

@GenerateLenses
@GenerateFolds
public record Order(String orderId, List&lt;Product&gt; items, String customerName, LocalDate orderDate) {}

@GenerateLenses
@GenerateFolds
public record OrderHistory(List&lt;Order&gt; orders) {}

public class OrderAnalytics {
    private static final Fold&lt;Order, Product&gt; ORDER_ITEMS = OrderFolds.items();
    private static final Fold&lt;OrderHistory, Order&gt; HISTORY_ORDERS = OrderHistoryFolds.orders();
    private static final Fold&lt;OrderHistory, Product&gt; ALL_PRODUCTS =
        HISTORY_ORDERS.andThen(ORDER_ITEMS);

    private static final Monoid&lt;Double&gt; SUM_MONOID = new Monoid&lt;&gt;() {
        @Override public Double empty() { return 0.0; }
        @Override public Double combine(Double a, Double b) { return a + b; }
    };

    // Calculate total revenue across all orders
    public static double calculateRevenue(OrderHistory history) {
        return ALL_PRODUCTS.foldMap(SUM_MONOID, Product::price, history);
    }

    // Find most expensive product across all orders
    public static Optional&lt;Product&gt; findMostExpensiveProduct(OrderHistory history) {
        return ALL_PRODUCTS.getAll(history).stream()
            .max(Comparator.comparing(Product::price));
    }

    // Check if any order has out-of-stock items
    public static boolean hasOutOfStockIssues(OrderHistory history) {
        return ALL_PRODUCTS.exists(p -&gt; !p.inStock(), history);
    }

    // Get all unique categories
    public static Set&lt;String&gt; getAllCategories(OrderHistory history) {
        Fold&lt;OrderHistory, String&gt; categories =
            ALL_PRODUCTS.andThen(ProductLenses.category().asFold());
        return new HashSet&lt;&gt;(categories.getAll(history));
    }

    // Count products in a specific category
    public static int countByCategory(OrderHistory history, String category) {
        return (int) ALL_PRODUCTS.getAll(history).stream()
            .filter(p -&gt; category.equals(p.category()))
            .count();
    }

    // Calculate average order value
    public static double calculateAverageOrderValue(OrderHistory history) {
        List&lt;Order&gt; allOrders = HISTORY_ORDERS.getAll(history);
        if (allOrders.isEmpty()) return 0.0;

        double totalRevenue = calculateRevenue(history);
        return totalRevenue / allOrders.size();
    }

    // Find orders with specific product
    public static List&lt;Order&gt; findOrdersContaining(OrderHistory history, String productName) {
        return HISTORY_ORDERS.getAll(history).stream()
            .filter(order -&gt; ORDER_ITEMS.exists(
                p -&gt; productName.equals(p.name()),
                order
            ))
            .toList();
    }
}
</code></pre>
<hr />
<h2 id="the-relationship-to-foldable"><a class="header" href="#the-relationship-to-foldable">The Relationship to Foldable</a></h2>
<h3 id="quick-summary"><a class="header" href="#quick-summary">Quick Summary</a></h3>
<p>If you're just getting started, here's what you need to know: A <code>Fold&lt;S, A&gt;</code> is closely related to the <code>Foldable</code> type class from functional programming. While <code>Foldable&lt;F&gt;</code> works with any container type <code>F</code> (like <code>List</code>, <code>Optional</code>, <code>Tree</code>), a <code>Fold&lt;S, A&gt;</code> lets you treat any structure <code>S</code> as if it were a foldable container of <code>A</code> values‚Äîeven when <code>S</code> isn't actually a collection.</p>
<p><strong>Key Connection</strong>: Both use <code>foldMap</code> to aggregate values using monoids. The <code>Fold</code> optic brings this powerful abstraction to arbitrary data structures, not just collections.</p>
<h3 id="in-depth-explanation"><a class="header" href="#in-depth-explanation">In-Depth Explanation</a></h3>
<p>For those familiar with functional programming or interested in the deeper theory:</p>
<h4 id="the-foldable-type-class"><a class="header" href="#the-foldable-type-class">The Foldable Type Class</a></h4>
<p>The <a href="optics/../functional/foldable_and_traverse.html"><code>Foldable&lt;F&gt;</code> type class</a> in higher-kinded-j represents any data structure <code>F</code> that can be "folded up" or reduced to a summary value. It's defined with this signature:</p>
<pre><code class="language-java">public interface Foldable&lt;F&gt; {
  &lt;A, M&gt; M foldMap(
      Monoid&lt;M&gt; monoid,
      Function&lt;? super A, ? extends M&gt; f,
      Kind&lt;F, A&gt; fa
  );
}
</code></pre>
<p>Common instances include:</p>
<ul>
<li><code>List&lt;A&gt;</code> - fold over all elements</li>
<li><code>Optional&lt;A&gt;</code> - fold over zero or one element</li>
<li><code>Either&lt;E, A&gt;</code> - fold over the right value if present</li>
<li><code>Tree&lt;A&gt;</code> - fold over all nodes in a tree</li>
</ul>
<h4 id="how-fold-relates-to-foldable"><a class="header" href="#how-fold-relates-to-foldable">How Fold Relates to Foldable</a></h4>
<p>A <code>Fold&lt;S, A&gt;</code> can be thought of as a <strong>first-class, composable lens into a Foldable structure</strong>. More precisely:</p>
<ol>
<li><strong>Virtualization</strong>: <code>Fold&lt;S, A&gt;</code> lets you "view" any structure <code>S</code> as a virtual <code>Foldable</code> container of <code>A</code> values, even if <code>S</code> is not inherently a collection</li>
<li><strong>Composition</strong>: Unlike <code>Foldable&lt;F&gt;</code>, which is fixed to a specific container type <code>F</code>, <code>Fold&lt;S, A&gt;</code> can be composed with other optics to create deep query paths</li>
<li><strong>Reification</strong>: A <code>Fold</code> reifies (makes concrete) the act of folding, turning it into a first-class value you can pass around, store, and combine</li>
</ol>
<p><strong>Example Comparison</strong>:</p>
<pre><code class="language-java">// Using Foldable directly on a List
Foldable&lt;ListKind.Witness&gt; listFoldable = ListTraverse.INSTANCE;
List&lt;Integer&gt; numbers = List.of(1, 2, 3, 4, 5);
int sum = listFoldable.foldMap(sumMonoid, Function.identity(), LIST.widen(numbers));

// Using a Fold optic to query nested structure
Fold&lt;Order, Integer&gt; quantities = OrderFolds.items()
    .andThen(ProductLenses.quantity().asFold());
int totalQuantity = quantities.foldMap(sumMonoid, Function.identity(), order);
</code></pre>
<p>The <code>Fold</code> optic gives you the power of <code>Foldable</code>, but for <strong>arbitrary access paths</strong> through your domain model, not just direct containers.</p>
<h4 id="fold-laws-and-foldable-laws"><a class="header" href="#fold-laws-and-foldable-laws">Fold Laws and Foldable Laws</a></h4>
<p>Both <code>Fold</code> and <code>Foldable</code> obey the same monoid laws:</p>
<ol>
<li><strong>Left identity</strong>: <code>combine(empty, x) = x</code></li>
<li><strong>Right identity</strong>: <code>combine(x, empty) = x</code></li>
<li><strong>Associativity</strong>: <code>combine(combine(x, y), z) = combine(x, combine(y, z))</code></li>
</ol>
<p>This means <code>foldMap</code> produces consistent, predictable results regardless of how the fold is internally structured.</p>
<h4 id="practical-implications"><a class="header" href="#practical-implications">Practical Implications</a></h4>
<p>Understanding this relationship helps you:</p>
<ul>
<li><strong>Transfer knowledge</strong>: If you learn <code>Foldable</code>, you understand the core of <code>Fold</code></li>
<li><strong>Recognise patterns</strong>: Monoid aggregation is universal across both abstractions</li>
<li><strong>Build intuition</strong>: A <code>Fold</code> is like having a custom <code>Foldable</code> instance for each access path in your domain</li>
<li><strong>Compose freely</strong>: You can convert between optics and type classes when needed (e.g., <code>Lens.asFold()</code>)</li>
</ul>
<p><strong>Further Reading</strong>:</p>
<ul>
<li><a href="optics/../functional/foldable_and_traverse.html">Foldable and Traverse in higher-kinded-j</a> - Deep dive into the type class</li>
<li><a href="https://hackage.haskell.org/package/lens-5.2.3/docs/Control-Lens-Fold.html">Haskell Lens Library - Folds</a> - The original inspiration</li>
<li><a href="https://leanpub.com/optics-by-example">Optics By Example (Book)</a> - Comprehensive treatment of folds in Haskell</li>
</ul>
<hr />
<h2 id="complete-runnable-example-4"><a class="header" href="#complete-runnable-example-4">Complete, Runnable Example</a></h2>
<p>This example demonstrates all major Fold operations in a single, cohesive application:</p>
<pre><code class="language-java">package org.higherkindedj.example.optics;

import org.higherkindedj.optics.Fold;
import org.higherkindedj.optics.Lens;
import org.higherkindedj.optics.annotations.GenerateFolds;
import org.higherkindedj.optics.annotations.GenerateLenses;
import org.higherkindedj.hkt.Monoid;
import org.higherkindedj.hkt.Monoids;
import java.util.*;

public class FoldUsageExample {

    @GenerateLenses
    @GenerateFolds
    public record ProductItem(String name, double price, String category, boolean inStock) {}

    @GenerateLenses
    @GenerateFolds
    public record Order(String orderId, List&lt;ProductItem&gt; items, String customerName) {}

    @GenerateLenses
    @GenerateFolds
    public record OrderHistory(List&lt;Order&gt; orders) {}

    public static void main(String[] args) {
        // Create sample data
        var order1 = new Order("ORD-001", List.of(
            new ProductItem("Laptop", 999.99, "Electronics", true),
            new ProductItem("Mouse", 25.00, "Electronics", true),
            new ProductItem("Desk", 350.00, "Furniture", false)
        ), "Alice");

        var order2 = new Order("ORD-002", List.of(
            new ProductItem("Keyboard", 75.00, "Electronics", true),
            new ProductItem("Monitor", 450.00, "Electronics", true),
            new ProductItem("Chair", 200.00, "Furniture", true)
        ), "Bob");

        var history = new OrderHistory(List.of(order1, order2));

        System.out.println("=== FOLD USAGE EXAMPLE ===\n");

        // --- SCENARIO 1: Basic Query Operations ---
        System.out.println("--- Scenario 1: Basic Query Operations ---");
        Fold&lt;Order, ProductItem&gt; itemsFold = OrderFolds.items();

        List&lt;ProductItem&gt; allItems = itemsFold.getAll(order1);
        System.out.println("All items: " + allItems.size() + " products");

        Optional&lt;ProductItem&gt; firstItem = itemsFold.preview(order1);
        System.out.println("First item: " + firstItem.map(ProductItem::name).orElse("none"));

        int count = itemsFold.length(order1);
        System.out.println("Item count: " + count);

        boolean isEmpty = itemsFold.isEmpty(order1);
        System.out.println("Is empty: " + isEmpty + "\n");

        // --- SCENARIO 2: Conditional Queries ---
        System.out.println("--- Scenario 2: Conditional Queries ---");

        boolean hasOutOfStock = itemsFold.exists(p -&gt; !p.inStock(), order1);
        System.out.println("Has out of stock items: " + hasOutOfStock);

        boolean allInStock = itemsFold.all(ProductItem::inStock, order1);
        System.out.println("All items in stock: " + allInStock);

        Optional&lt;ProductItem&gt; expensiveItem = itemsFold.find(p -&gt; p.price() &gt; 500, order1);
        System.out.println("First expensive item: " + expensiveItem.map(ProductItem::name).orElse("none") + "\n");

        // --- SCENARIO 3: Composition ---
        System.out.println("--- Scenario 3: Composed Folds ---");

        Fold&lt;OrderHistory, ProductItem&gt; allProducts =
            OrderHistoryFolds.orders().andThen(OrderFolds.items());

        List&lt;ProductItem&gt; allProductsFromHistory = allProducts.getAll(history);
        System.out.println("Total products across all orders: " + allProductsFromHistory.size());

        Fold&lt;OrderHistory, String&gt; allCategories =
            allProducts.andThen(ProductItemLenses.category().asFold());

        Set&lt;String&gt; uniqueCategories = new HashSet&lt;&gt;(allCategories.getAll(history));
        System.out.println("Unique categories: " + uniqueCategories + "\n");

        // --- SCENARIO 4: Monoid Aggregation ---
        System.out.println("--- Scenario 4: Monoid-Based Aggregation ---");

        // Use standard monoids from Monoids utility class
        Monoid&lt;Double&gt; sumMonoid = Monoids.doubleAddition();

        double orderTotal = itemsFold.foldMap(sumMonoid, ProductItem::price, order1);
        System.out.println("Order 1 total: ¬£" + String.format("%.2f", orderTotal));

        double historyTotal = allProducts.foldMap(sumMonoid, ProductItem::price, history);
        System.out.println("All orders total: ¬£" + String.format("%.2f", historyTotal));

        // Boolean AND monoid for checking conditions
        Monoid&lt;Boolean&gt; andMonoid = Monoids.booleanAnd();

        boolean allAffordable = itemsFold.foldMap(andMonoid, p -&gt; p.price() &lt; 1000, order1);
        System.out.println("All items under ¬£1000: " + allAffordable);

        // Boolean OR monoid for checking any condition
        Monoid&lt;Boolean&gt; orMonoid = Monoids.booleanOr();

        boolean hasElectronics = allProducts.foldMap(orMonoid,
            p -&gt; "Electronics".equals(p.category()), history);
        System.out.println("Has electronics: " + hasElectronics + "\n");

        // --- SCENARIO 5: Analytics ---
        System.out.println("--- Scenario 5: Real-World Analytics ---");

        // Most expensive product
        Optional&lt;ProductItem&gt; mostExpensive = allProducts.getAll(history).stream()
            .max(Comparator.comparing(ProductItem::price));
        System.out.println("Most expensive product: " +
            mostExpensive.map(p -&gt; p.name() + " (¬£" + p.price() + ")").orElse("none"));

        // Average price
        List&lt;ProductItem&gt; allProds = allProducts.getAll(history);
        double avgPrice = allProds.isEmpty() ? 0.0 :
            historyTotal / allProds.size();
        System.out.println("Average product price: ¬£" + String.format("%.2f", avgPrice));

        // Count by category
        long electronicsCount = allProducts.getAll(history).stream()
            .filter(p -&gt; "Electronics".equals(p.category()))
            .count();
        System.out.println("Electronics count: " + electronicsCount);

        System.out.println("\n=== END OF EXAMPLE ===");
    }
}
</code></pre>
<p><strong>Expected Output:</strong></p>
<pre><code>=== FOLD USAGE EXAMPLE ===

--- Scenario 1: Basic Query Operations ---
All items: 3 products
First item: Laptop
Item count: 3
Is empty: false

--- Scenario 2: Conditional Queries ---
Has out of stock items: true
All items in stock: false
First expensive item: Laptop

--- Scenario 3: Composed Folds ---
Total products across all orders: 6
Unique categories: [Electronics, Furniture]

--- Scenario 4: Monoid-Based Aggregation ---
Order 1 total: ¬£1374.99
All orders total: ¬£2099.99
All items under ¬£1000: true
Has electronics: true

--- Scenario 5: Real-World Analytics ---
Most expensive product: Laptop (¬£999.99)
Average product price: ¬£349.99
Electronics count: 4

=== END OF EXAMPLE ===
</code></pre>
<hr />
<h2 id="why-folds-are-essential"><a class="header" href="#why-folds-are-essential">Why Folds Are Essential</a></h2>
<p><code>Fold</code> completes the optics toolkit by providing:</p>
<ul>
<li><strong>Clear Intent</strong>: Explicitly read-only operations prevent accidental modifications</li>
<li><strong>Composability</strong>: Chain folds with other optics for deep queries</li>
<li><strong>Aggregation Power</strong>: Use monoids for flexible, reusable combining logic</li>
<li><strong>Type Safety</strong>: All queries checked at compile time</li>
<li><strong>Reusability</strong>: Build query libraries tailored to your domain</li>
<li><strong>CQRS Support</strong>: Separate query models from command models cleanly</li>
<li><strong>Performance</strong>: Optimised for read-only access with short-circuiting and lazy evaluation</li>
</ul>
<p>By adding <code>Fold</code> to your arsenal alongside <code>Lens</code>, <code>Prism</code>, <code>Iso</code>, and <code>Traversal</code>, you have complete coverage for both reading and writing immutable data structures in a type-safe, composable way.</p>
<p>The key insight: <strong>Folds make queries first-class citizens in your codebase</strong>, just as valuable and well-designed as the commands that modify state.</p>
<hr />
<p><strong>Previous:</strong> <a href="optics/traversals.html">Traversals: Handling Bulk Updates</a>
<strong>Next:</strong> <a href="optics/filtered_optics.html">Filtered Optics: Predicate-Based Composition</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="filtered-optics-predicate-based-composition"><a class="header" href="#filtered-optics-predicate-based-composition">Filtered Optics: Predicate-Based Composition</a></h1>
<h2 id="declarative-filtering-for-targeted-operations"><a class="header" href="#declarative-filtering-for-targeted-operations"><em>Declarative Filtering for Targeted Operations</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="optics/filtered_optics.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to filter elements within traversals and folds using predicates</li>
<li>Using <code>filtered()</code> for declarative, composable filtering as part of optic composition</li>
<li>The difference between filtering during modification vs filtering during queries</li>
<li>Advanced filtering with <code>filterBy()</code> for query-based predicates</li>
<li>The static <code>Traversals.filtered()</code> combinator for affine traversals</li>
<li>Understanding lazy evaluation semantics (preserved structure vs excluded queries)</li>
<li>When to use filtered optics vs Stream API vs conditional logic</li>
<li>Real-world patterns for customer segmentation, inventory management, and analytics</li>
</ul>
</div>
</div>
<div id="admonition-example-code" class="admonition admonish-note" role="note" aria-labelledby="admonition-example-code-title">
<div class="admonition-title">
<div id="admonition-example-code-title">
<p>Example Code</p>
</div>
<a class="admonition-anchor-link" href="optics/filtered_optics.html#admonition-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/FilteredTraversalExample.java">FilteredTraversalExample</a></p>
</div>
</div>
<p>In our journey through optics, we've seen how <strong>Traversal</strong> handles bulk operations on collections and how <strong>Fold</strong> provides read-only queries. But what happens when you need to operate on only <em>some</em> elements‚Äîthose that satisfy a specific condition?</p>
<p>Traditionally, filtering requires breaking out of your optic composition to use streams or loops, mixing the <em>what</em> (your transformation logic) with the <em>how</em> (iteration and filtering). <strong>Filtered optics</strong> solve this elegantly by making filtering a first-class part of your optic composition.</p>
<hr />
<h2 id="the-scenario-customer-segmentation-in-a-saas-platform"><a class="header" href="#the-scenario-customer-segmentation-in-a-saas-platform">The Scenario: Customer Segmentation in a SaaS Platform</a></h2>
<p>Imagine you're building a Software-as-a-Service platform where you need to:</p>
<ul>
<li>Grant bonuses only to <strong>active</strong> users</li>
<li>Send notifications to users with <strong>overdue invoices</strong></li>
<li>Analyse spending patterns for customers with <strong>high-value orders</strong></li>
<li>Update pricing only for products <strong>in specific categories</strong></li>
</ul>
<p><strong>The Data Model:</strong></p>
<pre><code class="language-java">@GenerateLenses
public record User(String name, boolean active, int score, SubscriptionTier tier) {
    User grantBonus() {
        return new User(name, active, score + 100, tier);
    }
}

@GenerateLenses
@GenerateFolds
public record Invoice(String id, double amount, boolean overdue) {}

@GenerateLenses
@GenerateFolds
public record Customer(String name, List&lt;Invoice&gt; invoices, SubscriptionTier tier) {}

@GenerateLenses
@GenerateFolds
public record Platform(List&lt;User&gt; users, List&lt;Customer&gt; customers) {}

public enum SubscriptionTier { FREE, BASIC, PREMIUM, ENTERPRISE }
</code></pre>
<p><strong>The Traditional Approach:</strong></p>
<pre><code class="language-java">// Verbose: Manual filtering breaks optic composition
List&lt;User&gt; updatedUsers = platform.users().stream()
    .map(user -&gt; user.active() ? user.grantBonus() : user)
    .collect(Collectors.toList());
Platform updatedPlatform = new Platform(updatedUsers, platform.customers());

// Even worse with nested structures
List&lt;Customer&gt; customersWithOverdue = platform.customers().stream()
    .filter(customer -&gt; customer.invoices().stream()
        .anyMatch(Invoice::overdue))
    .collect(Collectors.toList());
</code></pre>
<p>This approach forces you to abandon the declarative power of optics, manually managing iteration and reconstruction. <strong>Filtered optics</strong> let you express this intent directly within your optic composition.</p>
<hr />
<h2 id="think-of-filtered-optics-like"><a class="header" href="#think-of-filtered-optics-like">Think of Filtered Optics Like...</a></h2>
<ul>
<li><strong>A SQL WHERE clause</strong>: <code>SELECT * FROM users WHERE active = true</code></li>
<li><strong>A spotlight with a mask</strong>: Illuminates only the items that match your criteria</li>
<li><strong>A sieve</strong>: Allows matching elements to pass through whilst blocking others</li>
<li><strong>A conditional lens</strong>: Focuses only on elements satisfying a predicate</li>
<li><strong>A smart selector</strong>: Like CSS selectors that target specific elements based on attributes</li>
</ul>
<p>The key insight: filtering becomes part of your optic's <em>identity</em>, not an external operation applied afterwards.</p>
<hr />
<h2 id="three-ways-to-filter"><a class="header" href="#three-ways-to-filter">Three Ways to Filter</a></h2>
<p>Higher-kinded-j provides three complementary approaches to filtered optics:</p>
<div class="table-wrapper"><table><thead><tr><th>Approach</th><th>Signature</th><th>Use Case</th></tr></thead><tbody>
<tr><td><strong>Instance method</strong></td><td><code>traversal.filtered(predicate)</code></td><td>Filter within an existing traversal</td></tr>
<tr><td><strong>Static combinator</strong></td><td><code>Traversals.filtered(predicate)</code></td><td>Create a reusable affine traversal</td></tr>
<tr><td><strong>Query-based filter</strong></td><td><code>traversal.filterBy(fold, predicate)</code></td><td>Filter based on nested properties</td></tr>
</tbody></table>
</div>
<p>Each serves different needs, and they can be combined for powerful compositions.</p>
<hr />
<h2 id="a-step-by-step-walkthrough-5"><a class="header" href="#a-step-by-step-walkthrough-5">A Step-by-Step Walkthrough</a></h2>
<h3 id="step-1-instance-method--filteredpredicate"><a class="header" href="#step-1-instance-method--filteredpredicate">Step 1: Instance Method ‚Äî <code>filtered(Predicate)</code></a></h3>
<p>The most intuitive approach: call <code>filtered()</code> on any <code>Traversal</code> or <code>Fold</code> to create a new optic that only focuses on matching elements.</p>
<h4 id="on-traversals-read--write"><a class="header" href="#on-traversals-read--write">On Traversals (Read + Write)</a></h4>
<pre><code class="language-java">// Create a traversal for all users
Traversal&lt;List&lt;User&gt;, User&gt; allUsers = Traversals.forList();

// Filter to active users only
Traversal&lt;List&lt;User&gt;, User&gt; activeUsers = allUsers.filtered(User::active);

// Grant bonus ONLY to active users
List&lt;User&gt; result = Traversals.modify(activeUsers, User::grantBonus, users);
// Active users get bonus; inactive users preserved unchanged

// Extract ONLY active users
List&lt;User&gt; actives = Traversals.getAll(activeUsers, users);
// Returns only those matching the predicate
</code></pre>
<p><strong>Critical Semantic</strong>: During <strong>modification</strong>, non-matching elements are <em>preserved unchanged</em> in the structure. During <strong>queries</strong> (like <code>getAll</code>), they are <em>excluded</em> from the results. This preserves the overall structure whilst focusing operations on the subset you care about.</p>
<h4 id="on-folds-read-only"><a class="header" href="#on-folds-read-only">On Folds (Read-Only)</a></h4>
<pre><code class="language-java">// Fold from Order to Items
Fold&lt;Order, Item&gt; itemsFold = Fold.of(Order::items);

// Filter to expensive items only
Fold&lt;Order, Item&gt; expensiveItems = itemsFold.filtered(item -&gt; item.price() &gt; 100);

// Query operations work on filtered subset
int count = expensiveItems.length(order);           // Count expensive items
List&lt;Item&gt; expensive = expensiveItems.getAll(order); // Get expensive items
double total = expensiveItems.foldMap(sumMonoid, Item::price, order); // Sum expensive
boolean allPremium = expensiveItems.all(Item::isPremium, order);  // Check expensive items
</code></pre>
<h3 id="step-2-composing-filtered-traversals"><a class="header" href="#step-2-composing-filtered-traversals">Step 2: Composing Filtered Traversals</a></h3>
<p>The real power emerges when you compose filtered optics with other optics:</p>
<pre><code class="language-java">// Compose: list ‚Üí filtered users ‚Üí user name
Traversal&lt;List&lt;User&gt;, String&gt; activeUserNames =
    Traversals.&lt;User&gt;forList()
        .filtered(User::active)
        .andThen(UserLenses.name().asTraversal());

List&lt;User&gt; users = List.of(
    new User("alice", true, 100, PREMIUM),
    new User("bob", false, 200, FREE),
    new User("charlie", true, 150, BASIC)
);

// Get only active user names
List&lt;String&gt; names = Traversals.getAll(activeUserNames, users);
// Result: ["alice", "charlie"]

// Uppercase only active user names
List&lt;User&gt; result = Traversals.modify(activeUserNames, String::toUpperCase, users);
// Result: [User("ALICE", true, 100), User("bob", false, 200), User("CHARLIE", true, 150)]
// Notice: bob remains unchanged because he's inactive
</code></pre>
<h3 id="step-3-chaining-multiple-filters"><a class="header" href="#step-3-chaining-multiple-filters">Step 3: Chaining Multiple Filters</a></h3>
<p>Filters can be chained to create complex predicates:</p>
<pre><code class="language-java">// Active users with high scores (AND logic)
Traversal&lt;List&lt;User&gt;, User&gt; activeHighScorers =
    Traversals.&lt;User&gt;forList()
        .filtered(User::active)
        .filtered(user -&gt; user.score() &gt; 120);

// Premium or Enterprise tier users
Traversal&lt;List&lt;User&gt;, User&gt; premiumUsers =
    Traversals.&lt;User&gt;forList()
        .filtered(user -&gt; user.tier() == PREMIUM || user.tier() == ENTERPRISE);
</code></pre>
<h3 id="step-4-static-combinator--traversalsfiltered"><a class="header" href="#step-4-static-combinator--traversalsfiltered">Step 4: Static Combinator ‚Äî <code>Traversals.filtered()</code></a></h3>
<p>The static method creates an <strong>affine traversal</strong> (0 or 1 focus) that can be composed anywhere in a chain:</p>
<pre><code class="language-java">// Create a reusable filter
Traversal&lt;User, User&gt; activeFilter = Traversals.filtered(User::active);

// Use standalone
User user = new User("Alice", true, 100, BASIC);
User result = Traversals.modify(activeFilter, User::grantBonus, user);
// If active, grants bonus; otherwise returns unchanged

// Compose into a pipeline
Traversal&lt;List&lt;User&gt;, String&gt; activeUserNames =
    Traversals.&lt;User&gt;forList()
        .andThen(Traversals.filtered(User::active))  // Static combinator
        .andThen(UserLenses.name().asTraversal());
</code></pre>
<p><strong>When to use the static combinator vs instance method:</strong></p>
<ul>
<li><strong>Static combinator</strong>: When you want a reusable filter that can be inserted into different compositions</li>
<li><strong>Instance method</strong>: When filtering is a natural part of a specific traversal's behaviour</li>
</ul>
<p>Both approaches are semantically equivalent‚Äîchoose based on readability and reusability:</p>
<pre><code class="language-java">// These are equivalent:
Traversal&lt;List&lt;User&gt;, User&gt; approach1 = Traversals.&lt;User&gt;forList().filtered(User::active);
Traversal&lt;List&lt;User&gt;, User&gt; approach2 = Traversals.&lt;User&gt;forList().andThen(Traversals.filtered(User::active));
</code></pre>
<h3 id="step-5-advanced-filtering--filterbyfold-predicate"><a class="header" href="#step-5-advanced-filtering--filterbyfold-predicate">Step 5: Advanced Filtering ‚Äî <code>filterBy(Fold, Predicate)</code></a></h3>
<p>Sometimes you need to filter based on <em>nested</em> properties or aggregated queries. The <code>filterBy</code> method accepts a <code>Fold</code> that queries each element, including only those where at least one queried value matches the predicate.</p>
<p><strong>Example: Customers with Overdue Invoices</strong></p>
<pre><code class="language-java">Traversal&lt;List&lt;Customer&gt;, Customer&gt; allCustomers = Traversals.forList();
Fold&lt;Customer, Invoice&gt; customerInvoices = Fold.of(Customer::invoices);

// Filter customers who have ANY overdue invoice
Traversal&lt;List&lt;Customer&gt;, Customer&gt; customersWithOverdue =
    allCustomers.filterBy(customerInvoices, Invoice::overdue);

// Update tier for customers with overdue invoices
Lens&lt;Customer, SubscriptionTier&gt; tierLens = CustomerLenses.tier();
List&lt;Customer&gt; updated = Traversals.modify(
    customersWithOverdue.andThen(tierLens.asTraversal()),
    tier -&gt; SubscriptionTier.BASIC,  // Downgrade tier
    customers
);
</code></pre>
<p><strong>Example: Orders with High-Value Items</strong></p>
<pre><code class="language-java">Traversal&lt;List&lt;Order&gt;, Order&gt; allOrders = Traversals.forList();
Fold&lt;Order, Item&gt; orderItems = Fold.of(Order::items);

// Orders containing at least one item over ¬£500
Traversal&lt;List&lt;Order&gt;, Order&gt; highValueOrders =
    allOrders.filterBy(orderItems, item -&gt; item.price() &gt; 500);

List&lt;Order&gt; result = Traversals.getAll(highValueOrders, orders);
// Returns orders that have at least one expensive item
</code></pre>
<p><strong>Example: Using Composed Folds</strong></p>
<pre><code class="language-java">Traversal&lt;List&lt;Customer&gt;, Customer&gt; allCustomers = Traversals.forList();
Fold&lt;Customer, Order&gt; customerOrders = Fold.of(Customer::orders);
Fold&lt;Order, Item&gt; orderItems = Fold.of(Order::items);

// Fold from Customer to all their Items (across all orders)
Fold&lt;Customer, Item&gt; customerItems = customerOrders.andThen(orderItems);

// Customers who have purchased any premium product
Traversal&lt;List&lt;Customer&gt;, Customer&gt; premiumBuyers =
    allCustomers.filterBy(customerItems, Item::isPremium);

// Mark them as VIP
Lens&lt;Customer, String&gt; nameLens = CustomerLenses.name();
Traversal&lt;List&lt;Customer&gt;, String&gt; premiumBuyerNames =
    premiumBuyers.andThen(nameLens.asTraversal());

List&lt;Customer&gt; result = Traversals.modify(
    premiumBuyerNames,
    name -&gt; name + " [VIP]",
    customers
);
</code></pre>
<hr />
<h2 id="understanding-the-semantics-preserved-vs-excluded"><a class="header" href="#understanding-the-semantics-preserved-vs-excluded">Understanding the Semantics: Preserved vs Excluded</a></h2>
<p>A crucial aspect of filtered optics is understanding what happens to non-matching elements:</p>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Non-Matching Elements</th></tr></thead><tbody>
<tr><td><strong><code>modify</code></strong> / <strong><code>modifyF</code></strong></td><td><strong>Preserved unchanged</strong> in the structure</td></tr>
<tr><td><strong><code>getAll</code></strong></td><td><strong>Excluded</strong> from results</td></tr>
<tr><td><strong><code>foldMap</code></strong> / <strong><code>exists</code></strong> / <strong><code>all</code></strong></td><td><strong>Excluded</strong> from aggregation</td></tr>
<tr><td><strong><code>length</code></strong></td><td><strong>Not counted</strong></td></tr>
</tbody></table>
</div>
<p><strong>Visual Example:</strong></p>
<pre><code class="language-java">List&lt;User&gt; users = List.of(
    new User("Alice", true, 100),   // active
    new User("Bob", false, 200),    // inactive
    new User("Charlie", true, 150)  // active
);

Traversal&lt;List&lt;User&gt;, User&gt; activeUsers = forList().filtered(User::active);

// MODIFY: Structure preserved, only matching modified
List&lt;User&gt; modified = Traversals.modify(activeUsers, User::grantBonus, users);
// [User(Alice, true, 200), User(Bob, false, 200), User(Charlie, true, 250)]
//  ‚Üë modified               ‚Üë UNCHANGED           ‚Üë modified

// QUERY: Only matching elements returned
List&lt;User&gt; gotten = Traversals.getAll(activeUsers, users);
// [User(Alice, true, 100), User(Charlie, true, 150)]
// Bob is EXCLUDED entirely
</code></pre>
<p>This behaviour is intentional: it allows you to <strong>transform selectively</strong> whilst maintaining referential integrity, and <strong>query selectively</strong> without polluting results.</p>
<hr />
<h2 id="when-to-use-filtered-optics-vs-other-approaches"><a class="header" href="#when-to-use-filtered-optics-vs-other-approaches">When to Use Filtered Optics vs Other Approaches</a></h2>
<h3 id="use-filtered-optics-when"><a class="header" href="#use-filtered-optics-when">Use Filtered Optics When:</a></h3>
<ul>
<li><strong>Declarative composition</strong> - You want filtering to be part of the optic's definition</li>
<li><strong>Selective modifications</strong> - Modify only elements matching criteria</li>
<li><strong>Reusable filters</strong> - Define once, compose everywhere</li>
<li><strong>Type-safe pipelines</strong> - Filter as part of a larger optic chain</li>
<li><strong>Intent clarity</strong> - Express "active users" as a single concept</li>
</ul>
<pre><code class="language-java">// Perfect: Declarative, composable, reusable
Traversal&lt;Platform, User&gt; activeEnterpriseUsers =
    PlatformTraversals.users()
        .filtered(User::active)
        .filtered(user -&gt; user.tier() == ENTERPRISE);

Platform updated = Traversals.modify(activeEnterpriseUsers, User::grantBonus, platform);
</code></pre>
<h3 id="use-stream-api-when-1"><a class="header" href="#use-stream-api-when-1">Use Stream API When:</a></h3>
<ul>
<li><strong>Complex transformations</strong> - Multiple map/filter/reduce operations</li>
<li><strong>Collecting to different structures</strong> - Need to change the collection type</li>
<li><strong>Statistical operations</strong> - Sorting, limiting, grouping</li>
<li><strong>One-off queries</strong> - Not building reusable logic</li>
</ul>
<pre><code class="language-java">// Better with streams: Complex pipeline with sorting and limiting
List&lt;String&gt; topActiveUserNames = users.stream()
    .filter(User::active)
    .sorted(Comparator.comparing(User::score).reversed())
    .limit(10)
    .map(User::name)
    .collect(toList());
</code></pre>
<h3 id="use-conditional-logic-when"><a class="header" href="#use-conditional-logic-when">Use Conditional Logic When:</a></h3>
<ul>
<li><strong>Control flow</strong> - Early returns, exceptions, complex branching</li>
<li><strong>Side effects</strong> - Logging, metrics, external calls based on conditions</li>
<li><strong>Performance critical</strong> - Minimal abstraction overhead needed</li>
</ul>
<pre><code class="language-java">// Sometimes explicit logic is clearest
for (User user : users) {
    if (user.active() &amp;&amp; user.score() &lt; 0) {
        throw new IllegalStateException("Active user with negative score: " + user);
    }
}
</code></pre>
<hr />
<h2 id="common-pitfalls-6"><a class="header" href="#common-pitfalls-6">Common Pitfalls</a></h2>
<h3 id="-dont-do-this-6"><a class="header" href="#-dont-do-this-6">‚ùå Don't Do This:</a></h3>
<pre><code class="language-java">// Inefficient: Recreating filtered traversals in loops
for (Platform platform : platforms) {
    var activeUsers = Traversals.&lt;User&gt;forList().filtered(User::active);
    Traversals.modify(activeUsers, User::grantBonus, platform.users());
}

// Confusing: Mixing filtering approaches
List&lt;User&gt; activeUsers = Traversals.getAll(userTraversal, users).stream()
    .filter(User::active)  // Filtering AFTER optic extraction defeats the purpose
    .collect(toList());

// Wrong mental model: Expecting structure change
Traversal&lt;List&lt;User&gt;, User&gt; active = forList().filtered(User::active);
List&lt;User&gt; result = Traversals.modify(active, User::grantBonus, users);
// result still has same LENGTH as users! Non-matching preserved, not removed

// Over-engineering: Filtering for trivial cases
Fold&lt;User, Boolean&gt; isActiveFold = UserLenses.active().asFold();
boolean active = isActiveFold.getAll(user).get(0); // Just use user.active()!
</code></pre>
<h3 id="-do-this-instead-6"><a class="header" href="#-do-this-instead-6">‚úÖ Do This Instead:</a></h3>
<pre><code class="language-java">// Efficient: Create filtered optic once, reuse many times
Traversal&lt;List&lt;User&gt;, User&gt; activeUsers = Traversals.&lt;User&gt;forList().filtered(User::active);
for (Platform platform : platforms) {
    Traversals.modify(activeUsers, User::grantBonus, platform.users());
}

// Clear: Filter is part of the optic definition
Traversal&lt;List&lt;User&gt;, User&gt; activeUsers = forList().filtered(User::active);
List&lt;User&gt; result = Traversals.getAll(activeUsers, users);
// Returns only active users

// Correct expectation: Use getAll for extraction, modify for transformation
List&lt;User&gt; onlyActives = Traversals.getAll(activeUsers, users);  // Filters results
List&lt;User&gt; allWithActivesBonused = Traversals.modify(activeUsers, User::grantBonus, users);  // Preserves structure

// Simple: Use direct access for trivial cases
boolean isActive = user.active();
</code></pre>
<hr />
<h2 id="performance-notes-6"><a class="header" href="#performance-notes-6">Performance Notes</a></h2>
<p>Filtered optics are optimised for efficiency:</p>
<ul>
<li><strong>Lazy evaluation</strong>: The predicate is only called when needed</li>
<li><strong>Short-circuiting</strong>: Operations like <code>exists</code> and <code>find</code> stop at first match</li>
<li><strong>No intermediate collections</strong>: Filtering happens during traversal, not before</li>
<li><strong>Structural sharing</strong>: Unmodified parts of the structure are reused</li>
<li><strong>Single pass</strong>: Both filtering and transformation occur in one traversal</li>
</ul>
<p><strong>Best Practice</strong>: Store frequently-used filtered traversals as constants:</p>
<pre><code class="language-java">public class PlatformOptics {
    public static final Traversal&lt;Platform, User&gt; ACTIVE_USERS =
        PlatformTraversals.users().filtered(User::active);

    public static final Traversal&lt;Platform, User&gt; PREMIUM_ACTIVE_USERS =
        ACTIVE_USERS.filtered(user -&gt; user.tier() == PREMIUM);

    public static final Traversal&lt;Platform, Customer&gt; CUSTOMERS_WITH_OVERDUE =
        PlatformTraversals.customers()
            .filterBy(CustomerFolds.invoices(), Invoice::overdue);

    public static final Fold&lt;Platform, Invoice&gt; ALL_OVERDUE_INVOICES =
        PlatformFolds.customers()
            .andThen(CustomerFolds.invoices())
            .filtered(Invoice::overdue);
}
</code></pre>
<hr />
<h2 id="real-world-example-customer-analytics-dashboard"><a class="header" href="#real-world-example-customer-analytics-dashboard">Real-World Example: Customer Analytics Dashboard</a></h2>
<p>Here's a comprehensive example demonstrating filtered optics in a business context:</p>
<pre><code class="language-java">package org.higherkindedj.example.optics;

import org.higherkindedj.optics.*;
import org.higherkindedj.optics.util.Traversals;
import org.higherkindedj.hkt.Monoids;
import java.util.*;

public class CustomerAnalytics {

    public record Item(String name, int price, String category, boolean premium) {}
    public record Order(String id, List&lt;Item&gt; items, double total) {}
    public record Customer(String name, List&lt;Order&gt; orders, boolean vip) {}

    // Reusable optics
    private static final Fold&lt;Customer, Order&gt; CUSTOMER_ORDERS = Fold.of(Customer::orders);
    private static final Fold&lt;Order, Item&gt; ORDER_ITEMS = Fold.of(Order::items);
    private static final Fold&lt;Customer, Item&gt; ALL_CUSTOMER_ITEMS =
        CUSTOMER_ORDERS.andThen(ORDER_ITEMS);

    public static void main(String[] args) {
        List&lt;Customer&gt; customers = createSampleData();

        System.out.println("=== CUSTOMER ANALYTICS WITH FILTERED OPTICS ===\n");

        // --- Analysis 1: High-Value Customer Identification ---
        System.out.println("--- Analysis 1: High-Value Customers ---");

        Traversal&lt;List&lt;Customer&gt;, Customer&gt; allCustomers = Traversals.forList();
        Fold&lt;Customer, Double&gt; orderTotals = CUSTOMER_ORDERS.andThen(
            Getter.of(Order::total).asFold()
        );

        // Customers with any order over ¬£500
        Traversal&lt;List&lt;Customer&gt;, Customer&gt; bigSpenders =
            allCustomers.filterBy(orderTotals, total -&gt; total &gt; 500);

        List&lt;Customer&gt; highValue = Traversals.getAll(bigSpenders, customers);
        System.out.println("Customers with orders over ¬£500: " +
            highValue.stream().map(Customer::name).toList());

        // --- Analysis 2: Premium Product Buyers ---
        System.out.println("\n--- Analysis 2: Premium Product Buyers ---");

        Fold&lt;Customer, Item&gt; premiumItems = ALL_CUSTOMER_ITEMS.filtered(Item::premium);

        for (Customer customer : customers) {
            int premiumCount = premiumItems.length(customer);
            if (premiumCount &gt; 0) {
                double premiumSpend = premiumItems.foldMap(Monoids.doubleAddition(),
                    item -&gt; (double) item.price(), customer);
                System.out.printf("%s: %d premium items, ¬£%.2f total%n",
                    customer.name(), premiumCount, premiumSpend);
            }
        }

        // --- Analysis 3: Category-Specific Queries ---
        System.out.println("\n--- Analysis 3: Electronics Spending ---");

        Fold&lt;Customer, Item&gt; electronicsItems =
            ALL_CUSTOMER_ITEMS.filtered(item -&gt; "Electronics".equals(item.category()));

        for (Customer customer : customers) {
            double electronicsSpend = electronicsItems.foldMap(Monoids.doubleAddition(),
                item -&gt; (double) item.price(), customer);
            if (electronicsSpend &gt; 0) {
                System.out.printf("%s spent ¬£%.2f on Electronics%n",
                    customer.name(), electronicsSpend);
            }
        }

        // --- Analysis 4: Mark VIP Customers ---
        System.out.println("\n--- Analysis 4: Auto-Mark VIP Customers ---");

        // Customers who bought premium items AND have any order over ¬£300
        Traversal&lt;List&lt;Customer&gt;, Customer&gt; potentialVIPs =
            allCustomers
                .filterBy(ALL_CUSTOMER_ITEMS, Item::premium)  // Has premium items
                .filterBy(orderTotals, total -&gt; total &gt; 300); // Has high-value orders

        Lens&lt;Customer, Boolean&gt; vipLens =
            Lens.of(Customer::vip, (c, v) -&gt; new Customer(c.name(), c.orders(), v));

        List&lt;Customer&gt; updatedCustomers = Traversals.modify(
            potentialVIPs.andThen(vipLens.asTraversal()),
            _ -&gt; true,
            customers
        );

        for (Customer c : updatedCustomers) {
            if (c.vip()) {
                System.out.println(c.name() + " is now VIP");
            }
        }

        // --- Analysis 5: Aggregated Statistics ---
        System.out.println("\n--- Analysis 5: Platform Statistics ---");

        Fold&lt;List&lt;Customer&gt;, Customer&gt; customerFold = Fold.of(list -&gt; list);
        Fold&lt;List&lt;Customer&gt;, Item&gt; allItems = customerFold.andThen(ALL_CUSTOMER_ITEMS);

        Fold&lt;List&lt;Customer&gt;, Item&gt; expensiveItems = allItems.filtered(i -&gt; i.price() &gt; 100);
        Fold&lt;List&lt;Customer&gt;, Item&gt; cheapItems = allItems.filtered(i -&gt; i.price() &lt;= 100);

        int totalExpensive = expensiveItems.length(customers);
        int totalCheap = cheapItems.length(customers);
        double expensiveRevenue = expensiveItems.foldMap(Monoids.doubleAddition(),
            i -&gt; (double) i.price(), customers);

        System.out.printf("Expensive items (&gt;¬£100): %d items, ¬£%.2f revenue%n",
            totalExpensive, expensiveRevenue);
        System.out.printf("Budget items (‚â§¬£100): %d items%n", totalCheap);

        System.out.println("\n=== END OF ANALYTICS ===");
    }

    private static List&lt;Customer&gt; createSampleData() {
        return List.of(
            new Customer("Alice", List.of(
                new Order("A1", List.of(
                    new Item("Laptop", 999, "Electronics", true),
                    new Item("Mouse", 25, "Electronics", false)
                ), 1024.0),
                new Order("A2", List.of(
                    new Item("Desk", 350, "Furniture", false)
                ), 350.0)
            ), false),
            new Customer("Bob", List.of(
                new Order("B1", List.of(
                    new Item("Book", 20, "Books", false),
                    new Item("Pen", 5, "Stationery", false)
                ), 25.0)
            ), false),
            new Customer("Charlie", List.of(
                new Order("C1", List.of(
                    new Item("Phone", 800, "Electronics", true),
                    new Item("Case", 50, "Accessories", false)
                ), 850.0),
                new Order("C2", List.of(
                    new Item("Headphones", 250, "Electronics", true)
                ), 250.0)
            ), false)
        );
    }
}
</code></pre>
<p><strong>Expected Output:</strong></p>
<pre><code>=== CUSTOMER ANALYTICS WITH FILTERED OPTICS ===

--- Analysis 1: High-Value Customers ---
Customers with orders over ¬£500: [Alice, Charlie]

--- Analysis 2: Premium Product Buyers ---
Alice: 1 premium items, ¬£999.00 total
Charlie: 2 premium items, ¬£1050.00 total

--- Analysis 3: Electronics Spending ---
Alice spent ¬£1024.00 on Electronics
Charlie spent ¬£1050.00 on Electronics

--- Analysis 4: Auto-Mark VIP Customers ---
Alice is now VIP
Charlie is now VIP

--- Analysis 5: Platform Statistics ---
Expensive items (&gt;¬£100): 5 items, ¬£3149.00 revenue
Budget items (‚â§¬£100): 4 items

=== END OF ANALYTICS ===
</code></pre>
<hr />
<h2 id="the-relationship-to-haskells-lens-library"><a class="header" href="#the-relationship-to-haskells-lens-library">The Relationship to Haskell's Lens Library</a></h2>
<p>For those familiar with functional programming, higher-kinded-j's filtered optics are inspired by Haskell's <a href="https://hackage.haskell.org/package/lens">lens library</a>, specifically the <a href="https://hackage.haskell.org/package/lens-5.2.3/docs/Control-Lens-Traversal.html#v:filtered"><code>filtered</code></a> combinator.</p>
<p>In Haskell:</p>
<pre><code class="language-haskell">filtered :: (a -&gt; Bool) -&gt; Traversal' a a
</code></pre>
<p>This creates a traversal that focuses on the value only if it satisfies the predicate‚Äîexactly what our <code>Traversals.filtered(Predicate)</code> does.</p>
<p><strong>Key differences:</strong></p>
<ul>
<li>Higher-kinded-j uses explicit <code>Applicative</code> instances rather than implicit type class resolution</li>
<li>Java's type system requires more explicit composition steps</li>
<li>The <code>filterBy</code> method is an extension not present in standard lens</li>
</ul>
<p><strong>Further Reading:</strong></p>
<ul>
<li><a href="https://hackage.haskell.org/package/lens-tutorial-1.0.4/docs/Control-Lens-Tutorial.html">Haskell Lens Tutorial: Traversal</a> - Original inspiration</li>
<li><a href="https://leanpub.com/optics-by-example">Optics By Example</a> by Chris Penner - Comprehensive book on optics</li>
<li><a href="https://www.optics.dev/Monocle/">Monocle (Scala)</a> - Similar library for Scala with <code>filtered</code> support</li>
</ul>
<hr />
<h2 id="summary-the-power-of-filtered-optics"><a class="header" href="#summary-the-power-of-filtered-optics">Summary: The Power of Filtered Optics</a></h2>
<p>Filtered optics bring <strong>declarative filtering</strong> into the heart of your optic compositions:</p>
<ul>
<li><strong><code>filtered(Predicate)</code></strong>: Focus on elements matching a condition</li>
<li><strong><code>filterBy(Fold, Predicate)</code></strong>: Focus on elements where a nested query matches</li>
<li><strong><code>Traversals.filtered(Predicate)</code></strong>: Create reusable affine filter combinators</li>
</ul>
<p>These tools transform how you work with collections in immutable data structures:</p>
<div class="table-wrapper"><table><thead><tr><th>Before (Imperative)</th><th>After (Declarative)</th></tr></thead><tbody>
<tr><td>Manual loops with conditionals</td><td>Single filtered traversal</td></tr>
<tr><td>Stream pipelines breaking composition</td><td>Filters as part of optic chain</td></tr>
<tr><td>Logic scattered across codebase</td><td>Reusable, composable filter optics</td></tr>
<tr><td>Mix of "what" and "how"</td><td>Pure expression of intent</td></tr>
</tbody></table>
</div>
<p>By incorporating filtered optics into your toolkit, you gain:</p>
<ul>
<li><strong>Expressiveness</strong>: Say "active users" once, use everywhere</li>
<li><strong>Composability</strong>: Chain filters, compose with lenses, build complex paths</li>
<li><strong>Type safety</strong>: All operations checked at compile time</li>
<li><strong>Immutability</strong>: Structure preserved, only targets modified</li>
<li><strong>Performance</strong>: Single-pass, lazy evaluation, no intermediate collections</li>
</ul>
<p>Filtered optics represent the pinnacle of declarative data manipulation in Java‚Äîwhere the <em>what</em> (your business logic) is cleanly separated from the <em>how</em> (iteration, filtering, reconstruction), all whilst maintaining full type safety and referential transparency.</p>
<hr />
<p><strong>Previous:</strong> <a href="optics/folds.html">Folds: Querying Immutable Data</a>
<strong>Next:</strong> <a href="optics/indexed_optics.html">Indexed Optics: Position-Aware Operations</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="indexed-optics-position-aware-operations"><a class="header" href="#indexed-optics-position-aware-operations">Indexed Optics: Position-Aware Operations</a></h1>
<h2 id="tracking-indices-during-transformations"><a class="header" href="#tracking-indices-during-transformations"><em>Tracking Indices During Transformations</em></a></h2>
<p><img src="optics/../images/indexed-optics.jpg" alt="indexed-optics.jpg" /></p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="optics/indexed_optics.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to access both index and value during optic operations</li>
<li>Using IndexedTraversal for position-aware bulk updates</li>
<li>Using IndexedFold for queries that need position information</li>
<li>Using IndexedLens for field name tracking and debugging</li>
<li>Creating indexed traversals for Lists and Maps with IndexedTraversals utility</li>
<li>Composing indexed optics with paired indices (Pair&lt;I, J&gt;)</li>
<li>Converting between indexed and non-indexed optics</li>
<li>When to use indexed optics vs standard optics</li>
<li>Real-world patterns for debugging, audit trails, and position-based logic</li>
</ul>
</div>
</div>
<div id="admonition-example-code" class="admonition admonish-note" role="note" aria-labelledby="admonition-example-code-title">
<div class="admonition-title">
<div id="admonition-example-code-title">
<p>Example Code</p>
</div>
<a class="admonition-anchor-link" href="optics/indexed_optics.html#admonition-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/IndexedOpticsExample.java">IndexedOpticsExample</a></p>
</div>
</div>
<p>In our journey through optics, we've mastered how to focus on parts of immutable data structures‚Äîwhether it's a single field with <strong>Lens</strong>, an optional value with <strong>Prism</strong>, or multiple elements with <strong>Traversal</strong>. But sometimes, knowing <em>where</em> you are is just as important as knowing <em>what</em> you're looking at.</p>
<p>Consider these scenarios:</p>
<ul>
<li><strong>Numbering items</strong> in a packing list: "Item 1: Laptop, Item 2: Mouse..."</li>
<li><strong>Tracking field names</strong> for audit logs: "User modified field 'email' from..."</li>
<li><strong>Processing map entries</strong> where both key and value matter: "For metadata key 'priority', set value to..."</li>
<li><strong>Debugging nested updates</strong> by seeing the complete path: "Changed scores[2] from 100 to 150"</li>
</ul>
<p>Standard optics give you the <em>value</em>. <strong>Indexed optics</strong> give you both the <em>index</em> and the <em>value</em>.</p>
<hr />
<h2 id="the-scenario-e-commerce-order-processing"><a class="header" href="#the-scenario-e-commerce-order-processing">The Scenario: E-Commerce Order Processing</a></h2>
<p>Imagine building an order fulfilment system where position information drives business logic.</p>
<p><strong>The Data Model:</strong></p>
<pre><code class="language-java">@GenerateLenses
public record LineItem(String productName, int quantity, double price) {}

@GenerateLenses
@GenerateTraversals
public record Order(String orderId, List&lt;LineItem&gt; items, Map&lt;String, String&gt; metadata) {}

@GenerateLenses
public record Customer(String name, String email) {}
</code></pre>
<p><strong>Business Requirements:</strong></p>
<ol>
<li><strong>Generate packing slips</strong> with numbered items: "Item 1: Laptop (¬£999.99)"</li>
<li><strong>Process metadata</strong> with key awareness: "Set shipping method based on 'priority' key"</li>
<li><strong>Audit trail</strong> showing which fields were modified: "Updated Customer.email at 2025-01-15 10:30"</li>
<li><strong>Position-based pricing</strong> for bulk orders: "Items at even positions get 10% discount"</li>
</ol>
<p><strong>The Traditional Approach:</strong></p>
<pre><code class="language-java">// Verbose: Manual index tracking
List&lt;String&gt; packingSlip = new ArrayList&lt;&gt;();
for (int i = 0; i &lt; order.items().size(); i++) {
    LineItem item = order.items().get(i);
    packingSlip.add("Item " + (i + 1) + ": " + item.productName());
}

// Or with streams, losing type-safety
AtomicInteger counter = new AtomicInteger(1);
order.items().stream()
    .map(item -&gt; "Item " + counter.getAndIncrement() + ": " + item.productName())
    .collect(toList());

// Map processing requires breaking into entries
order.metadata().entrySet().stream()
    .map(entry -&gt; processWithKey(entry.getKey(), entry.getValue()))
    .collect(toMap(Entry::getKey, Entry::getValue));
</code></pre>
<p>This approach forces manual index management, mixing the <em>what</em> (transformation logic) with the <em>how</em> (index tracking). <strong>Indexed optics</strong> provide a declarative, type-safe solution.</p>
<hr />
<h2 id="think-of-indexed-optics-like"><a class="header" href="#think-of-indexed-optics-like">Think of Indexed Optics Like...</a></h2>
<ul>
<li><strong>GPS coordinates</strong>: Not just the destination, but the latitude and longitude</li>
<li><strong>Line numbers in an editor</strong>: Every line knows its position in the file</li>
<li><strong>Map.Entry</strong>: Provides both key and value instead of just the value</li>
<li><strong>Breadcrumbs in a file system</strong>: Showing the complete path to each file</li>
<li><strong>A numbered list</strong>: Each element has both content and a position</li>
<li><strong>Spreadsheet cells</strong>: Both the cell reference (A1, B2) and the value</li>
</ul>
<p>The key insight: indexed optics make <em>position</em> a first-class citizen, accessible during every operation.</p>
<hr />
<h2 id="part-i-the-basics"><a class="header" href="#part-i-the-basics">Part I: The Basics</a></h2>
<h3 id="the-three-indexed-optics"><a class="header" href="#the-three-indexed-optics">The Three Indexed Optics</a></h3>
<p>Higher-kinded-j provides three indexed optics that mirror their standard counterparts:</p>
<div class="table-wrapper"><table><thead><tr><th>Standard Optic</th><th>Indexed Variant</th><th>Index Type</th><th>Use Case</th></tr></thead><tbody>
<tr><td><strong>Traversal&lt;S, A&gt;</strong></td><td><strong>IndexedTraversal&lt;I, S, A&gt;</strong></td><td><code>I</code> (any type)</td><td>Position-aware bulk updates (List indices, Map keys)</td></tr>
<tr><td><strong>Fold&lt;S, A&gt;</strong></td><td><strong>IndexedFold&lt;I, S, A&gt;</strong></td><td><code>I</code> (any type)</td><td>Position-aware read-only queries</td></tr>
<tr><td><strong>Lens&lt;S, A&gt;</strong></td><td><strong>IndexedLens&lt;I, S, A&gt;</strong></td><td><code>I</code> (any type)</td><td>Field name tracking for single-field access</td></tr>
</tbody></table>
</div>
<p>The additional type parameter <code>I</code> represents the <strong>index type</strong>:</p>
<ul>
<li>For <code>List&lt;A&gt;</code>: <code>I</code> is <code>Integer</code> (position 0, 1, 2...)</li>
<li>For <code>Map&lt;K, V&gt;</code>: <code>I</code> is <code>K</code> (the key type)</li>
<li>For record fields: <code>I</code> is <code>String</code> (field name)</li>
<li>Custom: Any type that makes sense for your domain</li>
</ul>
<hr />
<h2 id="a-step-by-step-walkthrough-6"><a class="header" href="#a-step-by-step-walkthrough-6">A Step-by-Step Walkthrough</a></h2>
<h3 id="step-1-creating-indexed-traversals"><a class="header" href="#step-1-creating-indexed-traversals">Step 1: Creating Indexed Traversals</a></h3>
<p>The <code>IndexedTraversals</code> utility class provides factory methods for common cases.</p>
<h4 id="for-lists-integer-indices"><a class="header" href="#for-lists-integer-indices">For Lists: Integer Indices</a></h4>
<pre><code class="language-java">import org.higherkindedj.optics.indexed.IndexedTraversal;
import org.higherkindedj.optics.util.IndexedTraversals;

// Create an indexed traversal for List elements
IndexedTraversal&lt;Integer, List&lt;LineItem&gt;, LineItem&gt; itemsWithIndex =
    IndexedTraversals.forList();

List&lt;LineItem&gt; items = List.of(
    new LineItem("Laptop", 1, 999.99),
    new LineItem("Mouse", 2, 24.99),
    new LineItem("Keyboard", 1, 79.99)
);
</code></pre>
<p>The <code>forList()</code> factory creates a traversal where each element is paired with its zero-based index.</p>
<h4 id="for-maps-key-based-indices"><a class="header" href="#for-maps-key-based-indices">For Maps: Key-Based Indices</a></h4>
<pre><code class="language-java">// Create an indexed traversal for Map values
IndexedTraversal&lt;String, Map&lt;String, String&gt;, String&gt; metadataWithKeys =
    IndexedTraversals.forMap();

Map&lt;String, String&gt; metadata = Map.of(
    "priority", "express",
    "gift-wrap", "true",
    "delivery-note", "Leave at door"
);
</code></pre>
<p>The <code>forMap()</code> factory creates a traversal where each value is paired with its key.</p>
<hr />
<h3 id="step-2-accessing-index-value-pairs"><a class="header" href="#step-2-accessing-index-value-pairs">Step 2: Accessing Index-Value Pairs</a></h3>
<p>Indexed optics provide specialized methods that give you access to both the index and the value.</p>
<h4 id="extracting-all-index-value-pairs"><a class="header" href="#extracting-all-index-value-pairs">Extracting All Index-Value Pairs</a></h4>
<pre><code class="language-java">import org.higherkindedj.optics.indexed.Pair;

// Get list of (index, item) pairs
List&lt;Pair&lt;Integer, LineItem&gt;&gt; indexedItems = itemsWithIndex.toIndexedList(items);

for (Pair&lt;Integer, LineItem&gt; pair : indexedItems) {
    int position = pair.first();
    LineItem item = pair.second();
    System.out.println("Position " + position + ": " + item.productName());
}
// Output:
// Position 0: Laptop
// Position 1: Mouse
// Position 2: Keyboard
</code></pre>
<h4 id="using-indexedfold-for-queries"><a class="header" href="#using-indexedfold-for-queries">Using IndexedFold for Queries</a></h4>
<pre><code class="language-java">import org.higherkindedj.optics.indexed.IndexedFold;

// Convert to read-only indexed fold
IndexedFold&lt;Integer, List&lt;LineItem&gt;, LineItem&gt; itemsFold =
    itemsWithIndex.asIndexedFold();

// Find item at a specific position
Pair&lt;Integer, LineItem&gt; found = itemsFold.findWithIndex(
    (index, item) -&gt; index == 1,
    items
).orElse(null);

System.out.println("Item at index 1: " + found.second().productName());
// Output: Item at index 1: Mouse

// Check if any even-positioned item is expensive
boolean hasExpensiveEven = itemsFold.existsWithIndex(
    (index, item) -&gt; index % 2 == 0 &amp;&amp; item.price() &gt; 500,
    items
);
</code></pre>
<hr />
<h3 id="step-3-position-aware-modifications"><a class="header" href="#step-3-position-aware-modifications">Step 3: Position-Aware Modifications</a></h3>
<p>The real power emerges when you modify elements based on their position.</p>
<h4 id="numbering-items-in-a-packing-slip"><a class="header" href="#numbering-items-in-a-packing-slip">Numbering Items in a Packing Slip</a></h4>
<pre><code class="language-java">// Modify product names to include position numbers
List&lt;LineItem&gt; numbered = IndexedTraversals.imodify(
    itemsWithIndex,
    (index, item) -&gt; new LineItem(
        "Item " + (index + 1) + ": " + item.productName(),
        item.quantity(),
        item.price()
    ),
    items
);

for (LineItem item : numbered) {
    System.out.println(item.productName());
}
// Output:
// Item 1: Laptop
// Item 2: Mouse
// Item 3: Keyboard
</code></pre>
<h4 id="position-based-discount-logic"><a class="header" href="#position-based-discount-logic">Position-Based Discount Logic</a></h4>
<pre><code class="language-java">// Apply 10% discount to items at even positions (0, 2, 4...)
List&lt;LineItem&gt; discounted = IndexedTraversals.imodify(
    itemsWithIndex,
    (index, item) -&gt; {
        if (index % 2 == 0) {
            double discountedPrice = item.price() * 0.9;
            return new LineItem(item.productName(), item.quantity(), discountedPrice);
        }
        return item;
    },
    items
);

// Position 0 (Laptop): ¬£999.99 ‚Üí ¬£899.99
// Position 1 (Mouse): ¬£24.99 (unchanged)
// Position 2 (Keyboard): ¬£79.99 ‚Üí ¬£71.99
</code></pre>
<h4 id="map-processing-with-key-awareness"><a class="header" href="#map-processing-with-key-awareness">Map Processing with Key Awareness</a></h4>
<pre><code class="language-java">IndexedTraversal&lt;String, Map&lt;String, String&gt;, String&gt; metadataTraversal =
    IndexedTraversals.forMap();

Map&lt;String, String&gt; processed = IndexedTraversals.imodify(
    metadataTraversal,
    (key, value) -&gt; {
        // Add key prefix to all values for debugging
        return "[" + key + "] " + value;
    },
    metadata
);

// Results:
// "priority" ‚Üí "[priority] express"
// "gift-wrap" ‚Üí "[gift-wrap] true"
// "delivery-note" ‚Üí "[delivery-note] Leave at door"
</code></pre>
<hr />
<h3 id="step-4-filtering-with-index-awareness"><a class="header" href="#step-4-filtering-with-index-awareness">Step 4: Filtering with Index Awareness</a></h3>
<p>Indexed traversals support filtering, allowing you to focus on specific positions or keys.</p>
<h4 id="filter-by-index"><a class="header" href="#filter-by-index">Filter by Index</a></h4>
<pre><code class="language-java">// Focus only on even-positioned items
IndexedTraversal&lt;Integer, List&lt;LineItem&gt;, LineItem&gt; evenPositions =
    itemsWithIndex.filterIndex(index -&gt; index % 2 == 0);

List&lt;Pair&lt;Integer, LineItem&gt;&gt; evenItems =
    IndexedTraversals.toIndexedList(evenPositions, items);
// Returns: [(0, Laptop), (2, Keyboard)]

// Modify only even-positioned items
List&lt;LineItem&gt; result = IndexedTraversals.imodify(
    evenPositions,
    (index, item) -&gt; new LineItem(
        item.productName() + " [SALE]",
        item.quantity(),
        item.price()
    ),
    items
);
// Laptop and Keyboard get "[SALE]" suffix, Mouse unchanged
</code></pre>
<h4 id="filter-by-value-with-index-available"><a class="header" href="#filter-by-value-with-index-available">Filter by Value with Index Available</a></h4>
<pre><code class="language-java">// Focus on expensive items, but still track their original positions
IndexedTraversal&lt;Integer, List&lt;LineItem&gt;, LineItem&gt; expensiveItems =
    itemsWithIndex.filteredWithIndex((index, item) -&gt; item.price() &gt; 50);

List&lt;Pair&lt;Integer, LineItem&gt;&gt; expensive =
    IndexedTraversals.toIndexedList(expensiveItems, items);
// Returns: [(0, Laptop), (2, Keyboard)]
// Notice: indices are preserved (0 and 2), not renumbered
</code></pre>
<h4 id="filter-map-by-key-pattern"><a class="header" href="#filter-map-by-key-pattern">Filter Map by Key Pattern</a></h4>
<pre><code class="language-java">// Focus on metadata keys starting with "delivery"
IndexedTraversal&lt;String, Map&lt;String, String&gt;, String&gt; deliveryMetadata =
    metadataTraversal.filterIndex(key -&gt; key.startsWith("delivery"));

List&lt;Pair&lt;String, String&gt;&gt; deliveryEntries =
    deliveryMetadata.toIndexedList(metadata);
// Returns: [("delivery-note", "Leave at door")]
</code></pre>
<hr />
<h3 id="step-5-indexedlens-for-field-tracking"><a class="header" href="#step-5-indexedlens-for-field-tracking">Step 5: IndexedLens for Field Tracking</a></h3>
<p>An <code>IndexedLens</code> focuses on exactly one field whilst providing its name or identifier.</p>
<pre><code class="language-java">import org.higherkindedj.optics.indexed.IndexedLens;

// Create an indexed lens for the customer email field
IndexedLens&lt;String, Customer, String&gt; emailLens = IndexedLens.of(
    "email",                 // The index: field name
    Customer::email,         // Getter
    (customer, newEmail) -&gt; new Customer(customer.name(), newEmail)  // Setter
);

Customer customer = new Customer("Alice", "alice@example.com");

// Get both field name and value
Pair&lt;String, String&gt; fieldInfo = emailLens.iget(customer);
System.out.println("Field: " + fieldInfo.first());      // email
System.out.println("Value: " + fieldInfo.second());     // alice@example.com

// Modify with field name awareness
Customer updated = emailLens.imodify(
    (fieldName, oldValue) -&gt; {
        System.out.println("Updating field '" + fieldName + "' from " + oldValue);
        return "alice.smith@example.com";
    },
    customer
);
// Output: Updating field 'email' from alice@example.com
</code></pre>
<p><strong>Use case</strong>: Audit logging that records <em>which</em> field changed, not just the new value.</p>
<hr />
<h3 id="step-6-converting-between-indexed-and-non-indexed"><a class="header" href="#step-6-converting-between-indexed-and-non-indexed">Step 6: Converting Between Indexed and Non-Indexed</a></h3>
<p>Every indexed optic can be converted to its standard (non-indexed) counterpart.</p>
<pre><code class="language-java">import org.higherkindedj.optics.Traversal;

// Start with indexed traversal
IndexedTraversal&lt;Integer, List&lt;LineItem&gt;, LineItem&gt; indexed =
    IndexedTraversals.forList();

// Drop the index to get a standard traversal
Traversal&lt;List&lt;LineItem&gt;, LineItem&gt; standard = indexed.unindexed();

// Now you can use standard traversal methods
List&lt;LineItem&gt; uppercased = Traversals.modify(
    standard.andThen(Lens.of(
        LineItem::productName,
        (item, name) -&gt; new LineItem(name, item.quantity(), item.price())
    ).asTraversal()),
    String::toUpperCase,
    items
);
</code></pre>
<p><strong>When to convert</strong>: When you need the index for <em>some</em> operations but not others, start indexed and convert as needed.</p>
<hr />
<h3 id="when-to-use-indexed-optics-vs-standard-optics"><a class="header" href="#when-to-use-indexed-optics-vs-standard-optics">When to Use Indexed Optics vs Standard Optics</a></h3>
<p>Understanding when indexed optics add value is crucial for writing clear, maintainable code.</p>
<h4 id="use-indexed-optics-when"><a class="header" href="#use-indexed-optics-when">Use Indexed Optics When:</a></h4>
<ul>
<li><strong>Position-based logic</strong> - Different behaviour for even/odd indices, first/last elements</li>
<li><strong>Numbering or labelling</strong> - Adding sequence numbers, prefixes, or position markers</li>
<li><strong>Map operations</strong> - Both key and value are needed during transformation</li>
<li><strong>Audit trails</strong> - Recording which field or position was modified</li>
<li><strong>Debugging complex updates</strong> - Tracking the path to each change</li>
<li><strong>Index-based filtering</strong> - Operating on specific positions or key patterns</li>
</ul>
<pre><code class="language-java">// Perfect: Position drives the logic
IndexedTraversal&lt;Integer, List&lt;Product&gt;, Product&gt; productsIndexed =
    IndexedTraversals.forList();

List&lt;Product&gt; prioritised = productsIndexed.imodify(
    (index, product) -&gt; {
        // First 3 products get express shipping
        String shipping = index &lt; 3 ? "express" : "standard";
        return product.withShipping(shipping);
    },
    products
);
</code></pre>
<h4 id="use-standard-optics-when"><a class="header" href="#use-standard-optics-when">Use Standard Optics When:</a></h4>
<ul>
<li><strong>Position irrelevant</strong> - Pure value transformations</li>
<li><strong>Simpler code</strong> - Index tracking adds unnecessary complexity</li>
<li><strong>Performance critical</strong> - Minimal overhead needed (though indexed optics are optimised)</li>
<li><strong>No positional logic</strong> - All elements treated identically</li>
</ul>
<pre><code class="language-java">// Better with standard optics: Index not needed
Traversal&lt;List&lt;Product&gt;, Double&gt; prices =
    Traversals.&lt;Product&gt;forList()
        .andThen(ProductLenses.price().asTraversal());

List&lt;Product&gt; inflated = Traversals.modify(prices, price -&gt; price * 1.1, products);
// All prices increased by 10%, position doesn't matter
</code></pre>
<hr />
<h3 id="common-patterns-position-based-operations"><a class="header" href="#common-patterns-position-based-operations">Common Patterns: Position-Based Operations</a></h3>
<h4 id="pattern-1-adding-sequence-numbers"><a class="header" href="#pattern-1-adding-sequence-numbers">Pattern 1: Adding Sequence Numbers</a></h4>
<pre><code class="language-java">// Generate a numbered list for display
IndexedTraversal&lt;Integer, List&lt;String&gt;, String&gt; indexed = IndexedTraversals.forList();

List&lt;String&gt; tasks = List.of("Review PR", "Update docs", "Run tests");

List&lt;String&gt; numbered = IndexedTraversals.imodify(
    indexed,
    (i, task) -&gt; (i + 1) + ". " + task,
    tasks
);
// ["1. Review PR", "2. Update docs", "3. Run tests"]
</code></pre>
<h4 id="pattern-2-firstlast-element-special-handling"><a class="header" href="#pattern-2-firstlast-element-special-handling">Pattern 2: First/Last Element Special Handling</a></h4>
<pre><code class="language-java">IndexedTraversal&lt;Integer, List&lt;LineItem&gt;, LineItem&gt; itemsIndexed =
    IndexedTraversals.forList();

List&lt;LineItem&gt; items = List.of(/* ... */);
int lastIndex = items.size() - 1;

List&lt;LineItem&gt; marked = IndexedTraversals.imodify(
    itemsIndexed,
    (index, item) -&gt; {
        String marker = "";
        if (index == 0) marker = "[FIRST] ";
        if (index == lastIndex) marker = "[LAST] ";
        return new LineItem(
            marker + item.productName(),
            item.quantity(),
            item.price()
        );
    },
    items
);
</code></pre>
<h4 id="pattern-3-map-key-value-transformations"><a class="header" href="#pattern-3-map-key-value-transformations">Pattern 3: Map Key-Value Transformations</a></h4>
<pre><code class="language-java">IndexedTraversal&lt;String, Map&lt;String, Integer&gt;, Integer&gt; mapIndexed =
    IndexedTraversals.forMap();

Map&lt;String, Integer&gt; scores = Map.of(
    "alice", 100,
    "bob", 85,
    "charlie", 92
);

// Create display strings incorporating both key and value
List&lt;String&gt; results = IndexedTraversals.toIndexedList(mapIndexed, scores).stream()
    .map(pair -&gt; pair.first() + " scored " + pair.second())
    .toList();
// ["alice scored 100", "bob scored 85", "charlie scored 92"]
</code></pre>
<h4 id="pattern-4-position-based-filtering"><a class="header" href="#pattern-4-position-based-filtering">Pattern 4: Position-Based Filtering</a></h4>
<pre><code class="language-java">IndexedTraversal&lt;Integer, List&lt;String&gt;, String&gt; indexed = IndexedTraversals.forList();

List&lt;String&gt; values = List.of("a", "b", "c", "d", "e", "f");

// Take only odd positions (1, 3, 5)
IndexedTraversal&lt;Integer, List&lt;String&gt;, String&gt; oddPositions =
    indexed.filterIndex(i -&gt; i % 2 == 1);

List&lt;String&gt; odd = IndexedTraversals.getAll(oddPositions, values);
// ["b", "d", "f"]
</code></pre>
<hr />
<h3 id="common-pitfalls-7"><a class="header" href="#common-pitfalls-7">Common Pitfalls</a></h3>
<h4 id="-dont-do-this-7"><a class="header" href="#-dont-do-this-7">‚ùå Don't Do This:</a></h4>
<pre><code class="language-java">// Inefficient: Recreating indexed traversals in loops
for (Order order : orders) {
    var indexed = IndexedTraversals.&lt;LineItem&gt;forList();
    IndexedTraversals.imodify(indexed, (i, item) -&gt; numberItem(i, item), order.items());
}

// Over-engineering: Using indexed optics when index isn't needed
IndexedTraversal&lt;Integer, List&lt;String&gt;, String&gt; indexed = IndexedTraversals.forList();
List&lt;String&gt; upper = IndexedTraversals.imodify(indexed, (i, s) -&gt; s.toUpperCase(), list);
// Index parameter 'i' is never used! Use standard Traversals.modify()

// Confusing: Manual index tracking alongside indexed optics
AtomicInteger counter = new AtomicInteger(0);
IndexedTraversals.imodify(indexed, (i, item) -&gt; {
    int myIndex = counter.getAndIncrement(); // Redundant!
    return process(myIndex, item);
}, items);

// Wrong: Expecting indices to be renumbered after filtering
IndexedTraversal&lt;Integer, List&lt;String&gt;, String&gt; evenOnly =
    indexed.filterIndex(i -&gt; i % 2 == 0);
List&lt;Pair&lt;Integer, String&gt;&gt; pairs = IndexedTraversals.toIndexedList(evenOnly, list);
// Indices are [0, 2, 4], NOT [0, 1, 2] - original positions preserved!
</code></pre>
<h4 id="-do-this-instead-7"><a class="header" href="#-do-this-instead-7">‚úÖ Do This Instead:</a></h4>
<pre><code class="language-java">// Efficient: Create indexed traversal once, reuse many times
IndexedTraversal&lt;Integer, List&lt;LineItem&gt;, LineItem&gt; itemsIndexed =
    IndexedTraversals.forList();

for (Order order : orders) {
    IndexedTraversals.imodify(itemsIndexed, (i, item) -&gt; numberItem(i, item), order.items());
}

// Simple: Use standard traversals when index isn't needed
Traversal&lt;List&lt;String&gt;, String&gt; standard = Traversals.forList();
List&lt;String&gt; upper = Traversals.modify(standard, String::toUpperCase, list);

// Clear: Trust the indexed optic to provide correct indices
IndexedTraversals.imodify(indexed, (providedIndex, item) -&gt; {
    // Use providedIndex directly, it's correct
    return process(providedIndex, item);
}, items);

// Understand: Filtered indexed traversals preserve original indices
IndexedTraversal&lt;Integer, List&lt;String&gt;, String&gt; evenOnly =
    indexed.filterIndex(i -&gt; i % 2 == 0);
List&lt;Pair&lt;Integer, String&gt;&gt; pairs = IndexedTraversals.toIndexedList(evenOnly, list);
// If you need renumbered indices, transform after extraction:
List&lt;Pair&lt;Integer, String&gt;&gt; renumbered = IntStream.range(0, pairs.size())
    .mapToObj(newIndex -&gt; new Pair&lt;&gt;(newIndex, pairs.get(newIndex).second()))
    .toList();
</code></pre>
<hr />
<h3 id="performance-notes-7"><a class="header" href="#performance-notes-7">Performance Notes</a></h3>
<p>Indexed optics are designed to be efficient:</p>
<ul>
<li><strong>No additional traversals</strong> - Index computed during normal iteration</li>
<li><strong>Lazy index creation</strong> - <code>Pair&lt;I, A&gt;</code> objects only created when needed</li>
<li><strong>Minimal overhead</strong> - Index tracking adds negligible cost</li>
<li><strong>Reusable compositions</strong> - Indexed optics can be composed and cached</li>
<li><strong>No boxing for primitives</strong> - When using integer indices directly</li>
</ul>
<p><strong>Best Practice</strong>: Create indexed optics once and store as constants:</p>
<pre><code class="language-java">public class OrderOptics {
    public static final IndexedTraversal&lt;Integer, List&lt;LineItem&gt;, LineItem&gt;
        ITEMS_WITH_INDEX = IndexedTraversals.forList();

    public static final IndexedTraversal&lt;String, Map&lt;String, String&gt;, String&gt;
        METADATA_WITH_KEYS = IndexedTraversals.forMap();

    // Compose with filtering
    public static final IndexedTraversal&lt;Integer, List&lt;LineItem&gt;, LineItem&gt;
        EVEN_POSITIONED_ITEMS = ITEMS_WITH_INDEX.filterIndex(i -&gt; i % 2 == 0);
}
</code></pre>
<hr />
<h2 id="part-ii-advanced-topics"><a class="header" href="#part-ii-advanced-topics">Part II: Advanced Topics</a></h2>
<h3 id="composing-indexed-optics-with-paired-indices"><a class="header" href="#composing-indexed-optics-with-paired-indices">Composing Indexed Optics with Paired Indices</a></h3>
<p>When you compose two indexed optics, the indices form a <strong>pair</strong> representing the path through nested structures.</p>
<pre><code class="language-java">import org.higherkindedj.optics.indexed.Pair;

// Nested structure: List of Orders, each with List of Items
record Order(String id, List&lt;LineItem&gt; items) {}

// First level: indexed traversal for orders
IndexedTraversal&lt;Integer, List&lt;Order&gt;, Order&gt; ordersIndexed =
    IndexedTraversals.forList();

// Second level: lens to items field
Lens&lt;Order, List&lt;LineItem&gt;&gt; itemsLens =
    Lens.of(Order::items, (order, items) -&gt; new Order(order.id(), items));

// Third level: indexed traversal for items
IndexedTraversal&lt;Integer, List&lt;LineItem&gt;, LineItem&gt; itemsIndexed =
    IndexedTraversals.forList();

// Compose: orders ‚Üí items field ‚Üí each item with PAIRED indices
IndexedTraversal&lt;Pair&lt;Integer, Integer&gt;, List&lt;Order&gt;, LineItem&gt; composed =
    ordersIndexed
        .iandThen(itemsLens)
        .iandThen(itemsIndexed);

List&lt;Order&gt; orders = List.of(
    new Order("ORD-1", List.of(
        new LineItem("Laptop", 1, 999.99),
        new LineItem("Mouse", 1, 24.99)
    )),
    new Order("ORD-2", List.of(
        new LineItem("Keyboard", 1, 79.99),
        new LineItem("Monitor", 1, 299.99)
    ))
);

// Access with paired indices: (order index, item index)
List&lt;Pair&lt;Pair&lt;Integer, Integer&gt;, LineItem&gt;&gt; all = composed.toIndexedList(orders);

for (Pair&lt;Pair&lt;Integer, Integer&gt;, LineItem&gt; entry : all) {
    Pair&lt;Integer, Integer&gt; indices = entry.first();
    LineItem item = entry.second();
    System.out.printf("Order %d, Item %d: %s%n",
        indices.first(), indices.second(), item.productName());
}
// Output:
// Order 0, Item 0: Laptop
// Order 0, Item 1: Mouse
// Order 1, Item 0: Keyboard
// Order 1, Item 1: Monitor
</code></pre>
<p><strong>Use case</strong>: Generating globally unique identifiers like "Order 3, Item 5" or "Row 2, Column 7".</p>
<hr />
<h3 id="index-transformation-and-mapping"><a class="header" href="#index-transformation-and-mapping">Index Transformation and Mapping</a></h3>
<p>You can transform indices whilst preserving the optic composition.</p>
<pre><code class="language-java">// Start with integer indices (0, 1, 2...)
IndexedTraversal&lt;Integer, List&lt;LineItem&gt;, LineItem&gt; zeroIndexed =
    IndexedTraversals.forList();

// Transform to 1-based indices (1, 2, 3...)
IndexedTraversal&lt;Integer, List&lt;LineItem&gt;, LineItem&gt; oneIndexed =
    zeroIndexed.reindex(i -&gt; i + 1);

List&lt;LineItem&gt; items = List.of(/* ... */);

List&lt;String&gt; numbered = oneIndexed.imodify(
    (index, item) -&gt; "Item " + index + ": " + item.productName(),
    items
).stream()
    .map(LineItem::productName)
    .toList();
// ["Item 1: Laptop", "Item 2: Mouse", "Item 3: Keyboard"]
</code></pre>
<p><strong>Note</strong>: The <code>reindex</code> method is conceptual. In practice, you'd transform indices in your <code>imodify</code> function:</p>
<pre><code class="language-java">zeroIndexed.imodify((zeroBasedIndex, item) -&gt; {
    int oneBasedIndex = zeroBasedIndex + 1;
    return new LineItem("Item " + oneBasedIndex + ": " + item.productName(),
                        item.quantity(), item.price());
}, items);
</code></pre>
<hr />
<h3 id="combining-index-filtering-with-value-filtering"><a class="header" href="#combining-index-filtering-with-value-filtering">Combining Index Filtering with Value Filtering</a></h3>
<p>You can layer multiple filters for precise control.</p>
<pre><code class="language-java">IndexedTraversal&lt;Integer, List&lt;LineItem&gt;, LineItem&gt; itemsIndexed =
    IndexedTraversals.forList();

// Filter: even positions AND expensive items
IndexedTraversal&lt;Integer, List&lt;LineItem&gt;, LineItem&gt; targeted =
    itemsIndexed
        .filterIndex(i -&gt; i % 2 == 0)              // Even positions only
        .filtered(item -&gt; item.price() &gt; 50);       // Expensive items only

List&lt;LineItem&gt; items = List.of(
    new LineItem("Laptop", 1, 999.99),    // Index 0, expensive ‚úì
    new LineItem("Pen", 1, 2.99),         // Index 1, cheap ‚úó
    new LineItem("Keyboard", 1, 79.99),   // Index 2, expensive ‚úì
    new LineItem("Mouse", 1, 24.99),      // Index 3, cheap ‚úó
    new LineItem("Monitor", 1, 299.99)    // Index 4, expensive ‚úì
);

List&lt;Pair&lt;Integer, LineItem&gt;&gt; results = targeted.toIndexedList(items);
// Returns: [(0, Laptop), (2, Keyboard), (4, Monitor)]
// All at even positions AND expensive
</code></pre>
<hr />
<h3 id="audit-trail-pattern-field-change-tracking"><a class="header" href="#audit-trail-pattern-field-change-tracking">Audit Trail Pattern: Field Change Tracking</a></h3>
<p>A powerful real-world pattern is tracking <em>which</em> fields change in your domain objects.</p>
<pre><code class="language-java">// Generic field audit logger
public class AuditLog {
    public record FieldChange&lt;A&gt;(
        String fieldName,
        A oldValue,
        A newValue,
        Instant timestamp
    ) {}

    public static &lt;A&gt; Function&lt;Pair&lt;String, A&gt;, A&gt; loggedModification(
        Function&lt;A, A&gt; transformation,
        List&lt;FieldChange&lt;?&gt;&gt; auditLog
    ) {
        return pair -&gt; {
            String fieldName = pair.first();
            A oldValue = pair.second();
            A newValue = transformation.apply(oldValue);

            if (!oldValue.equals(newValue)) {
                auditLog.add(new FieldChange&lt;&gt;(
                    fieldName,
                    oldValue,
                    newValue,
                    Instant.now()
                ));
            }

            return newValue;
        };
    }
}

// Usage with indexed lens
IndexedLens&lt;String, Customer, String&gt; emailLens = IndexedLens.of(
    "email",
    Customer::email,
    (c, email) -&gt; new Customer(c.name(), email)
);

List&lt;AuditLog.FieldChange&lt;?&gt;&gt; audit = new ArrayList&lt;&gt;();

Customer customer = new Customer("Alice", "alice@old.com");

Customer updated = emailLens.imodify(
    AuditLog.loggedModification(
        email -&gt; "alice@new.com",
        audit
    ),
    customer
);

// Check audit log
for (AuditLog.FieldChange&lt;?&gt; change : audit) {
    System.out.printf("Field '%s' changed from %s to %s at %s%n",
        change.fieldName(),
        change.oldValue(),
        change.newValue(),
        change.timestamp()
    );
}
// Output: Field 'email' changed from alice@old.com to alice@new.com at 2025-01-15T10:30:00Z
</code></pre>
<hr />
<h3 id="debugging-pattern-path-tracking-in-nested-updates"><a class="header" href="#debugging-pattern-path-tracking-in-nested-updates">Debugging Pattern: Path Tracking in Nested Updates</a></h3>
<p>When debugging complex nested updates, indexed optics reveal the complete path to each modification.</p>
<pre><code class="language-java">// Nested structure with multiple levels
record Item(String name, double price) {}
record Order(List&lt;Item&gt; items) {}
record Customer(String name, List&lt;Order&gt; orders) {}

// Build an indexed path through the structure
IndexedTraversal&lt;Integer, List&lt;Customer&gt;, Customer&gt; customersIdx =
    IndexedTraversals.forList();

Lens&lt;Customer, List&lt;Order&gt;&gt; ordersLens =
    Lens.of(Customer::orders, (c, o) -&gt; new Customer(c.name(), o));

IndexedTraversal&lt;Integer, List&lt;Order&gt;, Order&gt; ordersIdx =
    IndexedTraversals.forList();

Lens&lt;Order, List&lt;Item&gt;&gt; itemsLens =
    Lens.of(Order::items, (order, items) -&gt; new Order(items));

IndexedTraversal&lt;Integer, List&lt;Item&gt;, Item&gt; itemsIdx =
    IndexedTraversals.forList();

Lens&lt;Item, Double&gt; priceLens =
    Lens.of(Item::price, (item, price) -&gt; new Item(item.name(), price));

// Compose the full indexed path
IndexedTraversal&lt;Pair&lt;Pair&lt;Integer, Integer&gt;, Integer&gt;, List&lt;Customer&gt;, Double&gt; fullPath =
    customersIdx
        .iandThen(ordersLens)
        .iandThen(ordersIdx)
        .iandThen(itemsLens)
        .iandThen(itemsIdx)
        .iandThen(priceLens);

List&lt;Customer&gt; customers = List.of(/* ... */);

// Modify with full path visibility
List&lt;Customer&gt; updated = fullPath.imodify(
    (indices, price) -&gt; {
        int customerIdx = indices.first().first();
        int orderIdx = indices.first().second();
        int itemIdx = indices.second();

        System.out.printf(
            "Updating price at [customer=%d, order=%d, item=%d]: %.2f ‚Üí %.2f%n",
            customerIdx, orderIdx, itemIdx, price, price * 1.1
        );

        return price * 1.1;  // 10% increase
    },
    customers
);
// Output shows complete path to every modified price:
// Updating price at [customer=0, order=0, item=0]: 999.99 ‚Üí 1099.99
// Updating price at [customer=0, order=0, item=1]: 24.99 ‚Üí 27.49
// Updating price at [customer=0, order=1, item=0]: 79.99 ‚Üí 87.99
// ...
</code></pre>
<hr />
<h3 id="working-with-pair-utilities"><a class="header" href="#working-with-pair-utilities">Working with Pair Utilities</a></h3>
<p>The <code>Pair&lt;A, B&gt;</code> type provides utility methods for manipulation.</p>
<pre><code class="language-java">import org.higherkindedj.optics.indexed.Pair;

Pair&lt;Integer, String&gt; pair = new Pair&lt;&gt;(1, "Hello");

// Access components
int first = pair.first();       // 1
String second = pair.second();  // "Hello"

// Transform components
Pair&lt;Integer, String&gt; modified = pair.withSecond("World");
// Result: Pair(1, "World")

Pair&lt;String, String&gt; transformed = pair.withFirst("One");
// Result: Pair("One", "Hello")

// Swap
Pair&lt;String, Integer&gt; swapped = pair.swap();
// Result: Pair("Hello", 1)

// Factory method
Pair&lt;String, Integer&gt; created = Pair.of("Key", 42);
</code></pre>
<p>For converting to/from <code>Tuple2</code> (when working with hkj-core utilities):</p>
<pre><code class="language-java">import org.higherkindedj.hkt.Tuple2;
import org.higherkindedj.optics.util.IndexedTraversals;

Pair&lt;String, Integer&gt; pair = Pair.of("key", 100);

// Convert to Tuple2
Tuple2&lt;String, Integer&gt; tuple = IndexedTraversals.pairToTuple2(pair);

// Convert back to Pair
Pair&lt;String, Integer&gt; converted = IndexedTraversals.tuple2ToPair(tuple);
</code></pre>
<hr />
<h3 id="real-world-example-order-fulfilment-dashboard"><a class="header" href="#real-world-example-order-fulfilment-dashboard">Real-World Example: Order Fulfilment Dashboard</a></h3>
<p>Here's a comprehensive example demonstrating indexed optics in a business context.</p>
<pre><code class="language-java">package org.higherkindedj.example.optics;

import java.time.Instant;
import java.util.*;
import org.higherkindedj.optics.indexed.*;
import org.higherkindedj.optics.util.IndexedTraversals;

public class OrderFulfilmentDashboard {

    public record LineItem(String productName, int quantity, double price) {}

    public record Order(
        String orderId,
        List&lt;LineItem&gt; items,
        Map&lt;String, String&gt; metadata
    ) {}

    public static void main(String[] args) {
        Order order = new Order(
            "ORD-12345",
            List.of(
                new LineItem("Laptop", 1, 999.99),
                new LineItem("Mouse", 2, 24.99),
                new LineItem("Keyboard", 1, 79.99),
                new LineItem("Monitor", 1, 299.99)
            ),
            new LinkedHashMap&lt;&gt;(Map.of(
                "priority", "express",
                "gift-wrap", "true",
                "delivery-note", "Leave at door"
            ))
        );

        System.out.println("=== ORDER FULFILMENT DASHBOARD ===\n");

        // --- Task 1: Generate Packing Slip ---
        System.out.println("--- Packing Slip ---");
        generatePackingSlip(order);

        // --- Task 2: Apply Position-Based Discounts ---
        System.out.println("\n--- Position-Based Discounts ---");
        Order discounted = applyPositionDiscounts(order);
        System.out.println("Original total: ¬£" + calculateTotal(order));
        System.out.println("Discounted total: ¬£" + calculateTotal(discounted));

        // --- Task 3: Process Metadata with Key Awareness ---
        System.out.println("\n--- Metadata Processing ---");
        processMetadata(order);

        // --- Task 4: Identify High-Value Positions ---
        System.out.println("\n--- High-Value Items ---");
        identifyHighValuePositions(order);

        System.out.println("\n=== END OF DASHBOARD ===");
    }

    private static void generatePackingSlip(Order order) {
        IndexedTraversal&lt;Integer, List&lt;LineItem&gt;, LineItem&gt; itemsIndexed =
            IndexedTraversals.forList();

        List&lt;Pair&lt;Integer, LineItem&gt;&gt; indexedItems =
            itemsIndexed.toIndexedList(order.items());

        System.out.println("Order: " + order.orderId());
        for (Pair&lt;Integer, LineItem&gt; pair : indexedItems) {
            int position = pair.first() + 1;  // 1-based for display
            LineItem item = pair.second();
            System.out.printf("  Item %d: %s (Qty: %d) - ¬£%.2f%n",
                position,
                item.productName(),
                item.quantity(),
                item.price() * item.quantity()
            );
        }
    }

    private static Order applyPositionDiscounts(Order order) {
        IndexedTraversal&lt;Integer, List&lt;LineItem&gt;, LineItem&gt; itemsIndexed =
            IndexedTraversals.forList();

        // Every 3rd item gets 15% off (positions 2, 5, 8...)
        List&lt;LineItem&gt; discounted = itemsIndexed.imodify(
            (index, item) -&gt; {
                if ((index + 1) % 3 == 0) {
                    double newPrice = item.price() * 0.85;
                    System.out.printf("  Position %d (%s): ¬£%.2f ‚Üí ¬£%.2f (15%% off)%n",
                        index + 1, item.productName(), item.price(), newPrice);
                    return new LineItem(item.productName(), item.quantity(), newPrice);
                }
                return item;
            },
            order.items()
        );

        return new Order(order.orderId(), discounted, order.metadata());
    }

    private static void processMetadata(Order order) {
        IndexedTraversal&lt;String, Map&lt;String, String&gt;, String&gt; metadataIndexed =
            IndexedTraversals.forMap();

        IndexedFold&lt;String, Map&lt;String, String&gt;, String&gt; fold =
            metadataIndexed.asIndexedFold();

        List&lt;Pair&lt;String, String&gt;&gt; entries = fold.toIndexedList(order.metadata());

        for (Pair&lt;String, String&gt; entry : entries) {
            String key = entry.first();
            String value = entry.second();

            // Process based on key
            switch (key) {
                case "priority" -&gt;
                    System.out.println("  Shipping priority: " + value.toUpperCase());
                case "gift-wrap" -&gt;
                    System.out.println("  Gift wrapping: " +
                        (value.equals("true") ? "Required" : "Not required"));
                case "delivery-note" -&gt;
                    System.out.println("  Special instructions: " + value);
                default -&gt;
                    System.out.println("  " + key + ": " + value);
            }
        }
    }

    private static void identifyHighValuePositions(Order order) {
        IndexedTraversal&lt;Integer, List&lt;LineItem&gt;, LineItem&gt; itemsIndexed =
            IndexedTraversals.forList();

        // Filter to items over ¬£100
        IndexedTraversal&lt;Integer, List&lt;LineItem&gt;, LineItem&gt; highValue =
            itemsIndexed.filteredWithIndex((index, item) -&gt; item.price() &gt; 100);

        List&lt;Pair&lt;Integer, LineItem&gt;&gt; expensive = highValue.toIndexedList(order.items());

        System.out.println("  Items over ¬£100 (require special handling):");
        for (Pair&lt;Integer, LineItem&gt; pair : expensive) {
            System.out.printf("    Position %d: %s (¬£%.2f)%n",
                pair.first() + 1,
                pair.second().productName(),
                pair.second().price()
            );
        }
    }

    private static double calculateTotal(Order order) {
        return order.items().stream()
            .mapToDouble(item -&gt; item.price() * item.quantity())
            .sum();
    }
}
</code></pre>
<p><strong>Expected Output:</strong></p>
<pre><code>=== ORDER FULFILMENT DASHBOARD ===

--- Packing Slip ---
Order: ORD-12345
  Item 1: Laptop (Qty: 1) - ¬£999.99
  Item 2: Mouse (Qty: 2) - ¬£49.98
  Item 3: Keyboard (Qty: 1) - ¬£79.99
  Item 4: Monitor (Qty: 1) - ¬£299.99

--- Position-Based Discounts ---
  Position 3 (Keyboard): ¬£79.99 ‚Üí ¬£67.99 (15% off)
Original total: ¬£1429.95
Discounted total: ¬£1417.95

--- Metadata Processing ---
  Shipping priority: EXPRESS
  Gift wrapping: Required
  Special instructions: Leave at door

--- High-Value Items ---
  Items over ¬£100 (require special handling):
    Position 1: Laptop (¬£999.99)
    Position 4: Monitor (¬£299.99)

=== END OF DASHBOARD ===
</code></pre>
<hr />
<h2 id="the-relationship-to-haskells-lens-library-1"><a class="header" href="#the-relationship-to-haskells-lens-library-1">The Relationship to Haskell's Lens Library</a></h2>
<p>For those familiar with functional programming, higher-kinded-j's indexed optics are inspired by Haskell's <a href="https://hackage.haskell.org/package/lens">lens library</a>, specifically indexed traversals and indexed folds.</p>
<p>In Haskell:</p>
<pre><code class="language-haskell">itraversed :: IndexedTraversal Int ([] a) a
</code></pre>
<p>This creates an indexed traversal over lists where the index is an integer‚Äîexactly what our <code>IndexedTraversals.forList()</code> provides.</p>
<p><strong>Key differences:</strong></p>
<ul>
<li>Higher-kinded-j uses explicit <code>Applicative</code> instances rather than implicit type class resolution</li>
<li>Java's type system requires explicit <code>Pair&lt;I, A&gt;</code> for index-value pairs</li>
<li>The <code>imodify</code> and <code>iget</code> methods provide a more Java-friendly API</li>
<li>Map-based traversals (<code>forMap</code>) are a practical extension for Java's collection library</li>
</ul>
<p><strong>Further Reading:</strong></p>
<ul>
<li><a href="https://hackage.haskell.org/package/lens-tutorial-1.0.4/docs/Control-Lens-Tutorial.html">Haskell Lens Tutorial: Indexed Optics</a> - Original inspiration</li>
<li><a href="https://leanpub.com/optics-by-example">Optics By Example</a> by Chris Penner - Chapter on indexed optics</li>
<li><a href="https://www.optics.dev/Monocle/">Monocle (Scala)</a> - Similar indexed optics for Scala</li>
</ul>
<hr />
<h2 id="summary-the-power-of-indexed-optics"><a class="header" href="#summary-the-power-of-indexed-optics">Summary: The Power of Indexed Optics</a></h2>
<p>Indexed optics bring <strong>position awareness</strong> into your functional data transformations:</p>
<ul>
<li><strong>IndexedTraversal&lt;I, S, A&gt;</strong>: Bulk operations with index tracking</li>
<li><strong>IndexedFold&lt;I, S, A&gt;</strong>: Read-only queries with position information</li>
<li><strong>IndexedLens&lt;I, S, A&gt;</strong>: Single-field access with field name tracking</li>
</ul>
<p>These tools transform how you work with collections and records:</p>
<div class="table-wrapper"><table><thead><tr><th>Before (Manual Index Tracking)</th><th>After (Declarative Indexed Optics)</th></tr></thead><tbody>
<tr><td>Manual loop counters</td><td>Built-in index access</td></tr>
<tr><td>AtomicInteger for streams</td><td>Type-safe <code>imodify</code></td></tr>
<tr><td>Breaking into Map.entrySet()</td><td>Direct key-value processing</td></tr>
<tr><td>Complex audit logging logic</td><td>Field tracking with <code>IndexedLens</code></td></tr>
<tr><td>Scattered position logic</td><td>Composable indexed transformations</td></tr>
</tbody></table>
</div>
<p>By incorporating indexed optics into your toolkit, you gain:</p>
<ul>
<li><strong>Expressiveness</strong>: Say "numbered list items" declaratively</li>
<li><strong>Type safety</strong>: Compile-time checked index types</li>
<li><strong>Composability</strong>: Chain indexed optics, filter by position, compose with standard optics</li>
<li><strong>Debugging power</strong>: Track complete paths through nested structures</li>
<li><strong>Audit trails</strong>: Record which fields changed, not just values</li>
<li><strong>Performance</strong>: Minimal overhead, lazy index computation</li>
</ul>
<p>Indexed optics represent the fusion of position awareness with functional composition‚Äîenabling you to write code that is simultaneously more declarative, more powerful, and more maintainable than traditional index-tracking approaches.</p>
<hr />
<p><strong>Previous:</strong> <a href="optics/common_data_structure_traversals.html">Common Data Structure Traversals</a>
<strong>Next:</strong> <a href="optics/getters.html">Getters: Read-Only Optics</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="limiting-traversals-focusing-on-list-portions"><a class="header" href="#limiting-traversals-focusing-on-list-portions">Limiting Traversals: Focusing on List Portions</a></h1>
<h2 id="declarative-slicing-for-targeted-operations"><a class="header" href="#declarative-slicing-for-targeted-operations"><em>Declarative Slicing for Targeted Operations</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="optics/limiting_traversals.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to focus on specific portions of lists (first n, last n, slices)</li>
<li>Using <code>ListTraversals</code> factory methods for index-based operations</li>
<li>The difference between limiting traversals and Stream's <code>limit()</code>/<code>skip()</code></li>
<li>Composing limiting traversals with lenses, prisms, and filtered optics</li>
<li>Understanding edge case handling (negative indices, bounds exceeding list size)</li>
<li>Real-world patterns for pagination, batch processing, and time-series windowing</li>
<li>When to use limiting traversals vs Stream API vs manual loops</li>
</ul>
</div>
</div>
<div id="admonition-example-code" class="admonition admonish-note" role="note" aria-labelledby="admonition-example-code-title">
<div class="admonition-title">
<div id="admonition-example-code-title">
<p>Example Code</p>
</div>
<a class="admonition-anchor-link" href="optics/limiting_traversals.html#admonition-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/ListTraversalsExample.java">ListTraversalsExample</a></p>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/PaginationExample.java">PaginationExample</a></p>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/BatchProcessingExample.java">BatchProcessingExample</a></p>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/TimeSeriesWindowingExample.java">TimeSeriesWindowingExample</a></p>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/PredicateListTraversalsExample.java">PredicateListTraversalsExample</a></p>
</div>
</div>
<p>In our journey through optics, we've seen how <strong>Traversal</strong> handles bulk operations on all elements of a collection, and how <strong>filtered optics</strong> let us focus on elements matching a predicate. But what about focusing on elements by <em>position</em>‚Äîthe first few items, the last few, or a specific slice?</p>
<p>Traditionally, working with list portions requires breaking out of your optic composition to use streams or manual index manipulation. <strong>Limiting traversals</strong> solve this elegantly by making positional focus a first-class part of your optic composition.</p>
<hr />
<h2 id="the-scenario-product-catalogue-management"><a class="header" href="#the-scenario-product-catalogue-management">The Scenario: Product Catalogue Management</a></h2>
<p>Imagine you're building an e-commerce platform where you need to:</p>
<ul>
<li>Display only the <strong>first 10 products</strong> on a landing page</li>
<li>Apply discounts to <strong>all except the last 3</strong> featured items</li>
<li>Process customer orders in <strong>chunks of 50</strong> for batch shipping</li>
<li>Analyse <strong>the most recent 7 days</strong> of time-series sales data</li>
<li>Update metadata for products <strong>between positions 5 and 15</strong> in a ranked list</li>
</ul>
<p><strong>The Data Model:</strong></p>
<pre><code class="language-java">@GenerateLenses
public record Product(String sku, String name, double price, int stock) {
    Product applyDiscount(double percentage) {
        return new Product(sku, name, price * (1 - percentage), stock);
    }
}

@GenerateLenses
public record Catalogue(String name, List&lt;Product&gt; products) {}

@GenerateLenses
public record Order(String id, List&lt;LineItem&gt; items, LocalDateTime created) {}

@GenerateLenses
public record LineItem(Product product, int quantity) {}

@GenerateLenses
public record SalesMetric(LocalDate date, double revenue, int transactions) {}
</code></pre>
<p><strong>The Traditional Approach:</strong></p>
<pre><code class="language-java">// Verbose: Manual slicing breaks optic composition
List&lt;Product&gt; firstTen = catalogue.products().subList(0, Math.min(10, catalogue.products().size()));
List&lt;Product&gt; discounted = firstTen.stream()
    .map(p -&gt; p.applyDiscount(0.1))
    .collect(Collectors.toList());
// Now reconstruct the full list... tedious!
List&lt;Product&gt; fullList = new ArrayList&lt;&gt;(discounted);
fullList.addAll(catalogue.products().subList(Math.min(10, catalogue.products().size()), catalogue.products().size()));
Catalogue updated = new Catalogue(catalogue.name(), fullList);

// Even worse with nested structures
List&lt;Order&gt; chunk = orders.subList(startIndex, Math.min(startIndex + chunkSize, orders.size()));
// Process chunk... then what? How do we put it back?
</code></pre>
<p>This approach forces you to abandon the declarative power of optics, manually managing indices, bounds checking, and list reconstruction. <strong>Limiting traversals</strong> let you express this intent directly within your optic composition.</p>
<hr />
<h2 id="think-of-limiting-traversals-like"><a class="header" href="#think-of-limiting-traversals-like">Think of Limiting Traversals Like...</a></h2>
<ul>
<li><strong>Java Stream's <code>limit()</code> and <code>skip()</code></strong>: Like <code>stream.limit(n)</code> and <code>stream.skip(n)</code>, but composable with immutable data transformations and integrated into optic pipelines</li>
<li><strong>SQL's LIMIT and OFFSET clauses</strong>: Like database pagination (<code>LIMIT 10 OFFSET 20</code>), but for in-memory immutable structures‚Äîenabling declarative pagination logic</li>
<li><strong>Spring Batch chunk processing</strong>: Similar to Spring Batch's chunk-oriented processing‚Äîdivide a list into manageable segments for targeted transformation whilst preserving the complete dataset</li>
<li><strong>ArrayList.subList() but better</strong>: Like <code>List.subList(from, to)</code>, but instead of a mutable view, you get an immutable optic that composes with lenses, prisms, and filtered traversals</li>
</ul>
<p>The key insight: positional focus becomes part of your optic's <em>identity</em>, not an external slicing operation applied afterwards.</p>
<hr />
<h2 id="five-ways-to-limit-focus"><a class="header" href="#five-ways-to-limit-focus">Five Ways to Limit Focus</a></h2>
<p>Higher-kinded-j's <code>ListTraversals</code> utility class provides five complementary factory methods:</p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Description</th><th>SQL Equivalent</th></tr></thead><tbody>
<tr><td><strong><code>taking(n)</code></strong></td><td>Focus on first n elements</td><td><code>LIMIT n</code></td></tr>
<tr><td><strong><code>dropping(n)</code></strong></td><td>Skip first n, focus on rest</td><td><code>OFFSET n</code> (then all)</td></tr>
<tr><td><strong><code>takingLast(n)</code></strong></td><td>Focus on last n elements</td><td><code>ORDER BY id DESC LIMIT n</code></td></tr>
<tr><td><strong><code>droppingLast(n)</code></strong></td><td>Focus on all except last n</td><td><code>LIMIT (size - n)</code></td></tr>
<tr><td><strong><code>slicing(from, to)</code></strong></td><td>Focus on range [from, to)</td><td><code>LIMIT (to-from) OFFSET from</code></td></tr>
</tbody></table>
</div>
<p>Each serves different needs, and they can be combined with other optics for powerful compositions.</p>
<hr />
<h2 id="a-step-by-step-walkthrough-7"><a class="header" href="#a-step-by-step-walkthrough-7">A Step-by-Step Walkthrough</a></h2>
<h3 id="step-1-basic-usage--takingint-n"><a class="header" href="#step-1-basic-usage--takingint-n">Step 1: Basic Usage ‚Äî <code>taking(int n)</code></a></h3>
<p>The most intuitive method: focus on at most the first <code>n</code> elements.</p>
<pre><code class="language-java">import org.higherkindedj.optics.util.ListTraversals;
import org.higherkindedj.optics.util.Traversals;

// Create a traversal for first 3 products
Traversal&lt;List&lt;Product&gt;, Product&gt; first3 = ListTraversals.taking(3);

List&lt;Product&gt; products = List.of(
    new Product("SKU001", "Widget", 10.0, 100),
    new Product("SKU002", "Gadget", 25.0, 50),
    new Product("SKU003", "Gizmo", 15.0, 75),
    new Product("SKU004", "Doohickey", 30.0, 25),
    new Product("SKU005", "Thingamajig", 20.0, 60)
);

// Apply 10% discount to ONLY first 3 products
List&lt;Product&gt; result = Traversals.modify(first3, p -&gt; p.applyDiscount(0.1), products);
// First 3 discounted; last 2 preserved unchanged

// Extract ONLY first 3 products
List&lt;Product&gt; firstThree = Traversals.getAll(first3, products);
// Returns: [Widget, Gadget, Gizmo]
</code></pre>
<p><strong>Critical Semantic</strong>: During <strong>modification</strong>, non-focused elements are <em>preserved unchanged</em> in the structure. During <strong>queries</strong> (like <code>getAll</code>), they are <em>excluded</em> from the results. This preserves the overall structure whilst focusing operations on the subset you care about.</p>
<h3 id="step-2-skipping-elements--droppingint-n"><a class="header" href="#step-2-skipping-elements--droppingint-n">Step 2: Skipping Elements ‚Äî <code>dropping(int n)</code></a></h3>
<p>Focus on all elements <em>after</em> skipping the first <code>n</code>:</p>
<pre><code class="language-java">// Skip first 2, focus on the rest
Traversal&lt;List&lt;Product&gt;, Product&gt; afterFirst2 = ListTraversals.dropping(2);

List&lt;Product&gt; result = Traversals.modify(afterFirst2, p -&gt; p.applyDiscount(0.15), products);
// First 2 unchanged; last 3 get 15% discount

List&lt;Product&gt; skipped = Traversals.getAll(afterFirst2, products);
// Returns: [Gizmo, Doohickey, Thingamajig]
</code></pre>
<h3 id="step-3-focusing-on-the-end--takinglastint-n"><a class="header" href="#step-3-focusing-on-the-end--takinglastint-n">Step 3: Focusing on the End ‚Äî <code>takingLast(int n)</code></a></h3>
<p>Focus on the last <code>n</code> elements‚Äîperfect for "most recent" scenarios:</p>
<pre><code class="language-java">// Focus on last 2 products
Traversal&lt;List&lt;Product&gt;, Product&gt; last2 = ListTraversals.takingLast(2);

List&lt;Product&gt; result = Traversals.modify(last2, p -&gt; p.applyDiscount(0.2), products);
// First 3 unchanged; last 2 get 20% discount

List&lt;Product&gt; lastTwo = Traversals.getAll(last2, products);
// Returns: [Doohickey, Thingamajig]
</code></pre>
<h3 id="step-4-excluding-from-the-end--droppinglastint-n"><a class="header" href="#step-4-excluding-from-the-end--droppinglastint-n">Step 4: Excluding from the End ‚Äî <code>droppingLast(int n)</code></a></h3>
<p>Focus on all elements <em>except</em> the last <code>n</code>:</p>
<pre><code class="language-java">// Focus on all except last 2
Traversal&lt;List&lt;Product&gt;, Product&gt; exceptLast2 = ListTraversals.droppingLast(2);

List&lt;Product&gt; result = Traversals.modify(exceptLast2, p -&gt; p.applyDiscount(0.05), products);
// First 3 get 5% discount; last 2 unchanged

List&lt;Product&gt; allButLastTwo = Traversals.getAll(exceptLast2, products);
// Returns: [Widget, Gadget, Gizmo]
</code></pre>
<h3 id="step-5-precise-slicing--slicingint-from-int-to"><a class="header" href="#step-5-precise-slicing--slicingint-from-int-to">Step 5: Precise Slicing ‚Äî <code>slicing(int from, int to)</code></a></h3>
<p>Focus on elements within a half-open range <code>[from, to)</code>, exactly like <code>List.subList()</code>:</p>
<pre><code class="language-java">// Focus on indices 1, 2, 3 (0-indexed, exclusive end)
Traversal&lt;List&lt;Product&gt;, Product&gt; slice = ListTraversals.slicing(1, 4);

List&lt;Product&gt; result = Traversals.modify(slice, p -&gt; p.applyDiscount(0.12), products);
// Index 0 unchanged; indices 1-3 discounted; index 4 unchanged

List&lt;Product&gt; sliced = Traversals.getAll(slice, products);
// Returns: [Gadget, Gizmo, Doohickey]
</code></pre>
<hr />
<h2 id="predicate-based-focusing-beyond-fixed-indices"><a class="header" href="#predicate-based-focusing-beyond-fixed-indices">Predicate-Based Focusing: Beyond Fixed Indices</a></h2>
<p>Whilst index-based limiting is powerful, many real-world scenarios require <strong>conditional focusing</strong>‚Äîstopping when a condition is met rather than at a fixed position. <code>ListTraversals</code> provides three predicate-based methods that complement the fixed-index approaches:</p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Description</th><th>Use Case</th></tr></thead><tbody>
<tr><td><strong><code>takingWhile(Predicate)</code></strong></td><td>Focus on longest prefix where predicate holds</td><td>Processing ordered data until threshold</td></tr>
<tr><td><strong><code>droppingWhile(Predicate)</code></strong></td><td>Skip prefix whilst predicate holds</td><td>Ignoring header/preamble sections</td></tr>
<tr><td><strong><code>element(int)</code></strong></td><td>Focus on single element at index (0-1 cardinality)</td><td>Safe indexed access without exceptions</td></tr>
</tbody></table>
</div>
<p>These methods enable <strong>runtime-determined focusing</strong>‚Äîthe number of elements in focus depends on the data itself, not a predetermined count.</p>
<h3 id="step-6-conditional-prefix-with-takingwhilepredicate"><a class="header" href="#step-6-conditional-prefix-with-takingwhilepredicate">Step 6: Conditional Prefix with <code>takingWhile(Predicate)</code></a></h3>
<p>The <code>takingWhile()</code> method focuses on the <strong>longest prefix</strong> of elements satisfying a predicate. Once an element fails the test, traversal stops‚Äîeven if later elements would pass.</p>
<pre><code class="language-java">// Focus on products whilst price &lt; 20
Traversal&lt;List&lt;Product&gt;, Product&gt; affordablePrefix =
    ListTraversals.takingWhile(p -&gt; p.price() &lt; 20.0);

List&lt;Product&gt; products = List.of(
    new Product("SKU001", "Widget", 10.0, 100),
    new Product("SKU002", "Gadget", 15.0, 50),
    new Product("SKU003", "Gizmo", 25.0, 75),   // Stops here
    new Product("SKU004", "Thing", 12.0, 25)    // Not included despite &lt; 20
);

// Apply discount only to initial affordable items
List&lt;Product&gt; result = Traversals.modify(
    affordablePrefix,
    p -&gt; p.applyDiscount(0.1),
    products
);
// Widget and Gadget discounted; Gizmo and Thing unchanged

// Extract the affordable prefix
List&lt;Product&gt; affordable = Traversals.getAll(affordablePrefix, products);
// Returns: [Widget, Gadget]  (stops at first expensive item)
</code></pre>
<p><strong>Key Semantic</strong>: Unlike <code>filtered()</code>, which tests all elements, <code>takingWhile()</code> is <strong>sequential and prefix-oriented</strong>. It's the optics equivalent of Stream's <code>takeWhile()</code>.</p>
<p><strong>Real-World Use Cases</strong>:</p>
<ul>
<li><strong>Time-series data</strong>: Process events before a timestamp threshold</li>
<li><strong>Sorted lists</strong>: Extract items below a value boundary</li>
<li><strong>Log processing</strong>: Capture startup messages before first error</li>
<li><strong>Priority queues</strong>: Handle high-priority items before switching logic</li>
</ul>
<pre><code class="language-java">// Time-series: Process transactions before cutoff
LocalDateTime cutoff = LocalDateTime.of(2025, 1, 1, 0, 0);
Traversal&lt;List&lt;Transaction&gt;, Transaction&gt; beforeCutoff =
    ListTraversals.takingWhile(t -&gt; t.timestamp().isBefore(cutoff));

List&lt;Transaction&gt; processed = Traversals.modify(
    beforeCutoff,
    t -&gt; t.withStatus("PROCESSED"),
    transactions
);
</code></pre>
<h3 id="step-7-skipping-prefix-with-droppingwhilepredicate"><a class="header" href="#step-7-skipping-prefix-with-droppingwhilepredicate">Step 7: Skipping Prefix with <code>droppingWhile(Predicate)</code></a></h3>
<p>The <code>droppingWhile()</code> method is the complement to <code>takingWhile()</code>‚Äîit <strong>skips the prefix</strong> whilst the predicate holds, then focuses on all remaining elements.</p>
<pre><code class="language-java">// Skip low-stock products, focus on well-stocked ones
Traversal&lt;List&lt;Product&gt;, Product&gt; wellStocked =
    ListTraversals.droppingWhile(p -&gt; p.stock() &lt; 50);

List&lt;Product&gt; products = List.of(
    new Product("SKU001", "Widget", 10.0, 20),
    new Product("SKU002", "Gadget", 25.0, 30),
    new Product("SKU003", "Gizmo", 15.0, 75),   // First to pass
    new Product("SKU004", "Thing", 12.0, 25)    // Included despite &lt; 50
);

// Restock only well-stocked items (and everything after)
List&lt;Product&gt; restocked = Traversals.modify(
    wellStocked,
    p -&gt; new Product(p.sku(), p.name(), p.price(), p.stock() + 50),
    products
);
// Widget and Gadget unchanged; Gizmo and Thing restocked

List&lt;Product&gt; focused = Traversals.getAll(wellStocked, products);
// Returns: [Gizmo, Thing]
</code></pre>
<p><strong>Real-World Use Cases</strong>:</p>
<ul>
<li><strong>Skipping headers</strong>: Process CSV data after metadata rows</li>
<li><strong>Log analysis</strong>: Ignore initialisation messages, focus on runtime</li>
<li><strong>Pagination</strong>: Skip already-processed records in batch jobs</li>
<li><strong>Protocol parsing</strong>: Discard handshake, process payload</li>
</ul>
<pre><code class="language-java">// Skip configuration lines in log file
Traversal&lt;String, String&gt; runtimeLogs =
    StringTraversals.lined()
        .filtered(line -&gt; !line.startsWith("[CONFIG]"));

// Apply to log data
String logs = "[CONFIG] Database URL\n[CONFIG] Port\nINFO: System started\nERROR: Connection failed";
String result = Traversals.modify(runtimeLogs, String::toUpperCase, logs);
// Result: "[CONFIG] Database URL\n[CONFIG] Port\nINFO: SYSTEM STARTED\nERROR: CONNECTION FAILED"
</code></pre>
<h3 id="step-8-single-element-access-with-elementint"><a class="header" href="#step-8-single-element-access-with-elementint">Step 8: Single Element Access with <code>element(int)</code></a></h3>
<p>The <code>element()</code> method creates an <strong>affine traversal</strong> (0-1 cardinality) focusing on a single element at the given index. Unlike direct array access, it never throws <code>IndexOutOfBoundsException</code>.</p>
<pre><code class="language-java">// Focus on element at index 2
Traversal&lt;List&lt;Product&gt;, Product&gt; thirdProduct = ListTraversals.element(2);

List&lt;Product&gt; products = List.of(
    new Product("SKU001", "Widget", 10.0, 100),
    new Product("SKU002", "Gadget", 25.0, 50),
    new Product("SKU003", "Gizmo", 15.0, 75)
);

// Modify only the third product
List&lt;Product&gt; updated = Traversals.modify(
    thirdProduct,
    p -&gt; p.applyDiscount(0.2),
    products
);
// Only Gizmo discounted

// Extract the element (if present)
List&lt;Product&gt; element = Traversals.getAll(thirdProduct, products);
// Returns: [Gizmo]

// Out of bounds: gracefully returns empty
List&lt;Product&gt; outOfBounds = Traversals.getAll(
    ListTraversals.element(10),
    products
);
// Returns: [] (no exception)
</code></pre>
<p><strong>When to Use <code>element()</code> vs <code>Ixed</code></strong>:</p>
<ul>
<li><strong><code>element()</code></strong>: For composition with other traversals, when index is known at construction time</li>
<li><strong><code>Ixed</code></strong>: For dynamic indexed access, more general type class approach</li>
</ul>
<pre><code class="language-java">// Compose element() with nested structures
Traversal&lt;List&lt;List&lt;Product&gt;&gt;, Product&gt; secondListThirdProduct =
    ListTraversals.element(1)  // Second list
        .andThen(ListTraversals.element(2));  // Third product in that list

// Ixed for dynamic access
IxedInstances.listIxed().ix(userProvidedIndex).getOptional(products);
</code></pre>
<h3 id="combining-predicate-based-and-index-based-traversals"><a class="header" href="#combining-predicate-based-and-index-based-traversals">Combining Predicate-Based and Index-Based Traversals</a></h3>
<p>The real power emerges when mixing approaches:</p>
<pre><code class="language-java">// Take first 10 products where stock &gt; 0, then filter by price
Traversal&lt;List&lt;Product&gt;, Product&gt; topAffordableInStock =
    ListTraversals.taking(10)
        .andThen(ListTraversals.takingWhile(p -&gt; p.stock() &gt; 0))
        .filtered(p -&gt; p.price() &lt; 30.0);

// Skip warmup period, then take next 100 events
Traversal&lt;List&lt;Event&gt;, Event&gt; steadyState =
    ListTraversals.droppingWhile(e -&gt; e.isWarmup())
        .andThen(ListTraversals.taking(100));
</code></pre>
<hr />
<h2 id="edge-case-handling"><a class="header" href="#edge-case-handling">Edge Case Handling</a></h2>
<p>All limiting traversal methods handle edge cases gracefully and consistently:</p>
<div class="table-wrapper"><table><thead><tr><th>Edge Case</th><th>Behaviour</th><th>Rationale</th></tr></thead><tbody>
<tr><td><strong><code>n &lt; 0</code></strong></td><td>Treated as 0 (identity traversal)</td><td>Graceful degradation, no exceptions</td></tr>
<tr><td><strong><code>n &gt; list.size()</code></strong></td><td>Clamped to list bounds</td><td>Focus on all available elements</td></tr>
<tr><td><strong>Empty list</strong></td><td>Returns empty list unchanged</td><td>No elements to focus on</td></tr>
<tr><td><strong><code>from &gt;= to</code> in slicing</strong></td><td>Identity traversal (no focus)</td><td>Empty range semantics</td></tr>
<tr><td><strong>Negative <code>from</code> in slicing</strong></td><td>Clamped to 0</td><td>Start from beginning</td></tr>
</tbody></table>
</div>
<pre><code class="language-java">// Examples of edge case handling
List&lt;Integer&gt; numbers = List.of(1, 2, 3);

// n &gt; size: focuses on all elements
List&lt;Integer&gt; result1 = Traversals.getAll(ListTraversals.taking(100), numbers);
// Returns: [1, 2, 3]

// Negative n: identity (no focus)
List&lt;Integer&gt; result2 = Traversals.getAll(ListTraversals.taking(-5), numbers);
// Returns: []

// Inverted range: no focus
List&lt;Integer&gt; result3 = Traversals.getAll(ListTraversals.slicing(3, 1), numbers);
// Returns: []

// Empty list: safe operation
List&lt;Integer&gt; result4 = Traversals.modify(ListTraversals.taking(3), x -&gt; x * 2, List.of());
// Returns: []
</code></pre>
<p>This philosophy ensures <strong>no runtime exceptions</strong> from index bounds, making limiting traversals safe for dynamic data.</p>
<hr />
<h2 id="composing-limiting-traversals"><a class="header" href="#composing-limiting-traversals">Composing Limiting Traversals</a></h2>
<p>The real power emerges when you compose limiting traversals with other optics:</p>
<h3 id="with-lenses--deep-updates"><a class="header" href="#with-lenses--deep-updates">With Lenses ‚Äî Deep Updates</a></h3>
<pre><code class="language-java">Traversal&lt;List&lt;Product&gt;, Product&gt; first5 = ListTraversals.taking(5);
Lens&lt;Product, Double&gt; priceLens = ProductLenses.price();

// Compose: first 5 products ‚Üí their prices
Traversal&lt;List&lt;Product&gt;, Double&gt; first5Prices =
    first5.andThen(priceLens.asTraversal());

// Increase prices of first 5 products by 10%
List&lt;Product&gt; result = Traversals.modify(first5Prices, price -&gt; price * 1.1, products);
</code></pre>
<h3 id="with-filtered-traversals--conditional-slicing"><a class="header" href="#with-filtered-traversals--conditional-slicing">With Filtered Traversals ‚Äî Conditional Slicing</a></h3>
<pre><code class="language-java">// First 10 products that are also low stock
Traversal&lt;List&lt;Product&gt;, Product&gt; first10LowStock =
    ListTraversals.taking(10).filtered(p -&gt; p.stock() &lt; 50);

// Restock only first 10 low-stock products
List&lt;Product&gt; restocked = Traversals.modify(
    first10LowStock,
    p -&gt; new Product(p.sku(), p.name(), p.price(), p.stock() + 100),
    products
);
</code></pre>
<h3 id="with-nested-structures--batch-processing"><a class="header" href="#with-nested-structures--batch-processing">With Nested Structures ‚Äî Batch Processing</a></h3>
<pre><code class="language-java">// Focus on first 50 orders
Traversal&lt;List&lt;Order&gt;, Order&gt; first50Orders = ListTraversals.taking(50);

// Focus on all line items in those orders
Traversal&lt;List&lt;Order&gt;, LineItem&gt; first50OrderItems =
    first50Orders.andThen(OrderTraversals.items());

// Apply bulk discount to items in first 50 orders
List&lt;Order&gt; processed = Traversals.modify(
    first50OrderItems,
    item -&gt; new LineItem(item.product().applyDiscount(0.05), item.quantity()),
    orders
);
</code></pre>
<hr />
<h2 id="when-to-use-limiting-traversals-vs-other-approaches"><a class="header" href="#when-to-use-limiting-traversals-vs-other-approaches">When to Use Limiting Traversals vs Other Approaches</a></h2>
<h3 id="use-limiting-traversals-when"><a class="header" href="#use-limiting-traversals-when">Use Limiting Traversals When:</a></h3>
<ul>
<li><strong>Positional focus</strong> - You need to operate on elements by index position</li>
<li><strong>Structural preservation</strong> - Non-focused elements must remain in the list</li>
<li><strong>Composable pipelines</strong> - Building complex optic chains with lenses and prisms</li>
<li><strong>Immutable updates</strong> - Transforming portions whilst keeping data immutable</li>
<li><strong>Reusable logic</strong> - Define once, compose everywhere</li>
</ul>
<pre><code class="language-java">// Perfect: Declarative, composable, reusable
Traversal&lt;Catalogue, Double&gt; first10Prices =
    CatalogueLenses.products().asTraversal()
        .andThen(ListTraversals.taking(10))
        .andThen(ProductLenses.price().asTraversal());

Catalogue updated = Traversals.modify(first10Prices, p -&gt; p * 0.9, catalogue);
</code></pre>
<h3 id="use-stream-api-when-2"><a class="header" href="#use-stream-api-when-2">Use Stream API When:</a></h3>
<ul>
<li><strong>Terminal operations</strong> - Counting, finding, collecting to new structures</li>
<li><strong>Complex transformations</strong> - Multiple chained operations with sorting/grouping</li>
<li><strong>No structural preservation needed</strong> - You're extracting data, not updating in place</li>
<li><strong>Performance-critical paths</strong> - Minimal abstraction overhead</li>
</ul>
<pre><code class="language-java">// Better with streams: Complex aggregation
int totalStock = products.stream()
    .limit(100)
    .mapToInt(Product::stock)
    .sum();
</code></pre>
<h3 id="use-manual-loops-when-1"><a class="header" href="#use-manual-loops-when-1">Use Manual Loops When:</a></h3>
<ul>
<li><strong>Early termination with side effects</strong> - Need to break out of loop</li>
<li><strong>Index-dependent logic</strong> - Processing depends on knowing the exact index</li>
<li><strong>Imperative control flow</strong> - Complex branching based on position</li>
</ul>
<pre><code class="language-java">// Sometimes explicit indexing is clearest
for (int i = 0; i &lt; Math.min(10, products.size()); i++) {
    if (products.get(i).stock() == 0) {
        notifyOutOfStock(products.get(i), i);
        break;
    }
}
</code></pre>
<hr />
<h2 id="common-pitfalls-8"><a class="header" href="#common-pitfalls-8">Common Pitfalls</a></h2>
<h3 id="-dont-do-this-8"><a class="header" href="#-dont-do-this-8">‚ùå Don't Do This:</a></h3>
<pre><code class="language-java">// Inefficient: Recreating traversals in loops
for (int page = 0; page &lt; totalPages; page++) {
    var slice = ListTraversals.slicing(page * 10, (page + 1) * 10);
    processPage(Traversals.getAll(slice, products));
}

// Confusing: Mixing with Stream operations unnecessarily
List&lt;Product&gt; result = Traversals.getAll(ListTraversals.taking(5), products)
    .stream()
    .limit(3)  // Why limit again? Already took 5!
    .collect(toList());

// Wrong expectation: Thinking it removes elements
Traversal&lt;List&lt;Product&gt;, Product&gt; first3 = ListTraversals.taking(3);
List&lt;Product&gt; modified = Traversals.modify(first3, Product::applyDiscount, products);
// modified.size() == products.size()! Structure preserved, not truncated

// Over-engineering: Using slicing for single element
Traversal&lt;List&lt;Product&gt;, Product&gt; atIndex5 = ListTraversals.slicing(5, 6);
// Consider using Ixed type class for single-element access instead
</code></pre>
<h3 id="-do-this-instead-8"><a class="header" href="#-do-this-instead-8">‚úÖ Do This Instead:</a></h3>
<pre><code class="language-java">// Efficient: Create traversal once, vary parameters
Traversal&lt;List&lt;Product&gt;, Product&gt; takeN(int n) {
    return ListTraversals.taking(n);
}
// Or store commonly used ones as constants
static final Traversal&lt;List&lt;Product&gt;, Product&gt; FIRST_PAGE = ListTraversals.taking(10);

// Clear: Keep operations at appropriate abstraction level
List&lt;Product&gt; firstFive = Traversals.getAll(ListTraversals.taking(5), products);
// If you need further processing, do it separately

// Correct expectation: Use getAll for extraction, modify for transformation
List&lt;Product&gt; onlyFirst5 = Traversals.getAll(first5, products);  // Extracts subset
List&lt;Product&gt; allWithFirst5Updated = Traversals.modify(first5, p -&gt; p.applyDiscount(0.1), products);  // Updates in place

// Right tool: Use Ixed for single indexed access
Optional&lt;Product&gt; fifth = IxedInstances.listIxed().ix(4).getOptional(products);
</code></pre>
<hr />
<h2 id="performance-notes-8"><a class="header" href="#performance-notes-8">Performance Notes</a></h2>
<p>Limiting traversals are optimised for efficiency:</p>
<ul>
<li><strong>Single pass</strong>: No intermediate list creation‚Äîslicing happens during traversal</li>
<li><strong>Structural sharing</strong>: Unchanged portions of the list are reused, not copied</li>
<li><strong>Lazy bounds checking</strong>: Index calculations are minimal and performed once</li>
<li><strong>No boxing overhead</strong>: Direct list operations without stream intermediaries</li>
<li><strong>Composable without penalty</strong>: Chaining with other optics adds no extra iteration</li>
</ul>
<p><strong>Best Practice</strong>: Store frequently-used limiting traversals as constants:</p>
<pre><code class="language-java">public class CatalogueOptics {
    // Pagination constants
    public static final int PAGE_SIZE = 20;

    public static Traversal&lt;List&lt;Product&gt;, Product&gt; page(int pageNum) {
        return ListTraversals.slicing(pageNum * PAGE_SIZE, (pageNum + 1) * PAGE_SIZE);
    }

    // Featured products (first 5)
    public static final Traversal&lt;Catalogue, Product&gt; FEATURED =
        CatalogueLenses.products().asTraversal()
            .andThen(ListTraversals.taking(5));

    // Latest additions (last 10)
    public static final Traversal&lt;Catalogue, Product&gt; LATEST =
        CatalogueLenses.products().asTraversal()
            .andThen(ListTraversals.takingLast(10));

    // Exclude promotional items at end
    public static final Traversal&lt;Catalogue, Product&gt; NON_PROMOTIONAL =
        CatalogueLenses.products().asTraversal()
            .andThen(ListTraversals.droppingLast(3));
}
</code></pre>
<hr />
<h2 id="real-world-example-e-commerce-pagination"><a class="header" href="#real-world-example-e-commerce-pagination">Real-World Example: E-Commerce Pagination</a></h2>
<p>Here's a comprehensive example demonstrating limiting traversals in a business context:</p>
<pre><code class="language-java">package org.higherkindedj.example.optics;

import org.higherkindedj.optics.*;
import org.higherkindedj.optics.util.*;
import java.util.*;

public class PaginationExample {

    public record Product(String sku, String name, double price, boolean featured) {
        Product applyDiscount(double pct) {
            return new Product(sku, name, price * (1 - pct), featured);
        }
    }

    public static void main(String[] args) {
        List&lt;Product&gt; catalogue = createCatalogue();

        System.out.println("=== E-COMMERCE PAGINATION WITH LIMITING TRAVERSALS ===\n");

        // --- Scenario 1: Basic Pagination ---
        System.out.println("--- Scenario 1: Paginated Product Display ---");

        int pageSize = 3;
        int totalPages = (int) Math.ceil(catalogue.size() / (double) pageSize);

        for (int page = 0; page &lt; totalPages; page++) {
            Traversal&lt;List&lt;Product&gt;, Product&gt; pageTraversal =
                ListTraversals.slicing(page * pageSize, (page + 1) * pageSize);

            List&lt;Product&gt; pageProducts = Traversals.getAll(pageTraversal, catalogue);
            System.out.printf("Page %d: %s%n", page + 1,
                pageProducts.stream().map(Product::name).toList());
        }

        // --- Scenario 2: Featured Products ---
        System.out.println("\n--- Scenario 2: Featured Products (First 3) ---");

        Traversal&lt;List&lt;Product&gt;, Product&gt; featured = ListTraversals.taking(3);
        List&lt;Product&gt; featuredProducts = Traversals.getAll(featured, catalogue);
        featuredProducts.forEach(p -&gt;
            System.out.printf("  ‚≠ê %s - ¬£%.2f%n", p.name(), p.price()));

        // --- Scenario 3: Apply Discount to Featured ---
        System.out.println("\n--- Scenario 3: 10% Discount on Featured ---");

        List&lt;Product&gt; withDiscount = Traversals.modify(featured, p -&gt; p.applyDiscount(0.1), catalogue);
        System.out.println("After discount on first 3:");
        withDiscount.forEach(p -&gt; System.out.printf("  %s: ¬£%.2f%n", p.name(), p.price()));

        // --- Scenario 4: Exclude Last Items ---
        System.out.println("\n--- Scenario 4: All Except Last 2 (Clearance) ---");

        Traversal&lt;List&lt;Product&gt;, Product&gt; nonClearance = ListTraversals.droppingLast(2);
        List&lt;Product&gt; regularStock = Traversals.getAll(nonClearance, catalogue);
        System.out.println("Regular stock: " + regularStock.stream().map(Product::name).toList());

        System.out.println("\n=== PAGINATION COMPLETE ===");
    }

    private static List&lt;Product&gt; createCatalogue() {
        return List.of(
            new Product("SKU001", "Laptop", 999.99, true),
            new Product("SKU002", "Mouse", 29.99, false),
            new Product("SKU003", "Keyboard", 79.99, true),
            new Product("SKU004", "Monitor", 349.99, true),
            new Product("SKU005", "Webcam", 89.99, false),
            new Product("SKU006", "Headset", 149.99, false),
            new Product("SKU007", "USB Hub", 39.99, false),
            new Product("SKU008", "Desk Lamp", 44.99, false)
        );
    }
}
</code></pre>
<p><strong>Expected Output:</strong></p>
<pre><code>=== E-COMMERCE PAGINATION WITH LIMITING TRAVERSALS ===

--- Scenario 1: Paginated Product Display ---
Page 1: [Laptop, Mouse, Keyboard]
Page 2: [Monitor, Webcam, Headset]
Page 3: [USB Hub, Desk Lamp]

--- Scenario 2: Featured Products (First 3) ---
  ‚≠ê Laptop - ¬£999.99
  ‚≠ê Mouse - ¬£29.99
  ‚≠ê Keyboard - ¬£79.99

--- Scenario 3: 10% Discount on Featured ---
After discount on first 3:
  Laptop: ¬£899.99
  Mouse: ¬£26.99
  Keyboard: ¬£71.99
  Monitor: ¬£349.99
  Webcam: ¬£89.99
  Headset: ¬£149.99
  USB Hub: ¬£39.99
  Desk Lamp: ¬£44.99

--- Scenario 4: All Except Last 2 (Clearance) ---
Regular stock: [Laptop, Mouse, Keyboard, Monitor, Webcam, Headset]

=== PAGINATION COMPLETE ===
</code></pre>
<hr />
<h2 id="the-relationship-to-functional-programming-libraries"><a class="header" href="#the-relationship-to-functional-programming-libraries">The Relationship to Functional Programming Libraries</a></h2>
<p>For those familiar with functional programming, higher-kinded-j's limiting traversals are inspired by similar patterns in:</p>
<h3 id="haskells-lens-library"><a class="header" href="#haskells-lens-library">Haskell's Lens Library</a></h3>
<p>The <a href="https://hackage.haskell.org/package/lens-5.2.3/docs/Control-Lens-Traversal.html"><code>Control.Lens.Traversal</code></a> module provides:</p>
<pre><code class="language-haskell">taking :: Int -&gt; Traversal' [a] a
dropping :: Int -&gt; Traversal' [a] a
</code></pre>
<p>These create traversals that focus on the first/remaining elements‚Äîexactly what our <code>ListTraversals.taking()</code> and <code>dropping()</code> do.</p>
<h3 id="scalas-monocle-library"><a class="header" href="#scalas-monocle-library">Scala's Monocle Library</a></h3>
<p><a href="https://www.optics.dev/Monocle/">Monocle</a> provides similar index-based optics:</p>
<pre><code class="language-scala">import monocle.function.Index._

// Focus on element at index
val atIndex: Optional[List[A], A] = index(3)

// Take first n (via custom combinator)
val firstN: Traversal[List[A], A] = ...
</code></pre>
<h3 id="key-differences-in-higher-kinded-j"><a class="header" href="#key-differences-in-higher-kinded-j">Key Differences in Higher-Kinded-J</a></h3>
<ul>
<li><strong>Explicit Applicative instances</strong> rather than implicit type class resolution</li>
<li><strong>Java's type system</strong> requires more explicit composition steps</li>
<li><strong>Additional methods</strong> like <code>takingLast</code> and <code>droppingLast</code> not standard in Haskell lens</li>
<li><strong>Edge case handling</strong> follows Java conventions (no exceptions, graceful clamping)</li>
</ul>
<p><strong>Further Reading:</strong></p>
<ul>
<li><a href="https://hackage.haskell.org/package/lens-tutorial-1.0.4/docs/Control-Lens-Tutorial.html">Haskell Lens Tutorial</a> - Original inspiration for optics</li>
<li><a href="https://leanpub.com/optics-by-example">Optics By Example</a> by Chris Penner - Comprehensive book on optics in Haskell</li>
<li><a href="https://www.optics.dev/Monocle/">Monocle Documentation</a> - Scala optics library with similar patterns</li>
<li><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/stream/Stream.html">Java Stream API</a> - Comparison with <code>limit()</code> and <code>skip()</code></li>
</ul>
<hr />
<h2 id="summary-the-power-of-limiting-traversals"><a class="header" href="#summary-the-power-of-limiting-traversals">Summary: The Power of Limiting Traversals</a></h2>
<p>Limiting traversals bring <strong>positional focus</strong> into the heart of your optic compositions:</p>
<ul>
<li><strong><code>taking(n)</code></strong>: Focus on first n elements</li>
<li><strong><code>dropping(n)</code></strong>: Skip first n, focus on rest</li>
<li><strong><code>takingLast(n)</code></strong>: Focus on last n elements</li>
<li><strong><code>droppingLast(n)</code></strong>: Focus on all except last n</li>
<li><strong><code>slicing(from, to)</code></strong>: Focus on index range [from, to)</li>
</ul>
<p>These tools transform how you work with list portions in immutable data structures:</p>
<div class="table-wrapper"><table><thead><tr><th>Before (Imperative)</th><th>After (Declarative)</th></tr></thead><tbody>
<tr><td>Manual <code>subList()</code> with bounds checking</td><td>Single limiting traversal</td></tr>
<tr><td>Index manipulation breaking composition</td><td>Positional focus as part of optic chain</td></tr>
<tr><td>Explicit list reconstruction</td><td>Automatic structural preservation</td></tr>
<tr><td>Mix of "what" and "how"</td><td>Pure expression of intent</td></tr>
</tbody></table>
</div>
<p>By incorporating limiting traversals into your toolkit, you gain:</p>
<ul>
<li><strong>Expressiveness</strong>: Say "first 10 products" once, compose with other optics</li>
<li><strong>Safety</strong>: No <code>IndexOutOfBoundsException</code>‚Äîgraceful edge case handling</li>
<li><strong>Composability</strong>: Chain with lenses, prisms, filtered traversals seamlessly</li>
<li><strong>Immutability</strong>: Structure preserved, only focused elements transformed</li>
<li><strong>Clarity</strong>: Business logic separate from index arithmetic</li>
</ul>
<p>Limiting traversals represent the natural evolution of optics for list manipulation‚Äîwhere Stream's <code>limit()</code> and <code>skip()</code> meet the composable, type-safe world of functional optics, all whilst maintaining full referential transparency and structural preservation.</p>
<hr />
<p><strong>Previous:</strong> <a href="optics/filtered_optics.html">Filtered Optics: Predicate-Based Composition</a>
<strong>Next:</strong> <a href="optics/string_traversals.html">String Traversals: Declarative Text Processing</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="getters-a-practical-guide"><a class="header" href="#getters-a-practical-guide">Getters: A Practical Guide</a></h1>
<h2 id="composable-read-only-access"><a class="header" href="#composable-read-only-access"><em>Composable Read-Only Access</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="optics/getters.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to extract values from structures using composable, read-only optics</li>
<li>Using <code>@GenerateGetters</code> to create type-safe value extractors automatically</li>
<li>Understanding the relationship between Getter and Fold</li>
<li>Creating computed and derived values without storing them</li>
<li>Composing Getters with other optics for deep data extraction</li>
<li>Factory methods: <code>of</code>, <code>to</code>, <code>constant</code>, <code>identity</code>, <code>first</code>, <code>second</code></li>
<li>Null-safe navigation with <code>getMaybe</code> for functional optional handling</li>
<li>When to use Getter vs Lens vs direct field access</li>
<li>Building data transformation pipelines with clear read-only intent</li>
</ul>
</div>
</div>
<div id="admonition-example-code" class="admonition admonish-note" role="note" aria-labelledby="admonition-example-code-title">
<div class="admonition-title">
<div id="admonition-example-code-title">
<p>Example Code</p>
</div>
<a class="admonition-anchor-link" href="optics/getters.html#admonition-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/GetterUsageExample.java">GetterUsageExample</a></p>
</div>
</div>
<p>In previous guides, we explored <strong><code>Fold</code></strong> for querying zero or more elements from a structure. But what if you need to extract exactly one value? What if you want a composable accessor for a single, guaranteed-to-exist value? This is where <strong><code>Getter</code></strong> excels.</p>
<p>A <strong><code>Getter</code></strong> is the simplest read-only optic‚Äîit extracts precisely one value from a source. Think of it as a <strong>function wrapped in optic form</strong>, enabling composition with other optics whilst maintaining read-only semantics.</p>
<hr />
<h2 id="the-scenario-employee-reporting-system"><a class="header" href="#the-scenario-employee-reporting-system">The Scenario: Employee Reporting System</a></h2>
<p>Consider a corporate reporting system where you need to extract various pieces of information from employee records:</p>
<p><strong>The Data Model:</strong></p>
<pre><code class="language-java">@GenerateGetters
public record Person(String firstName, String lastName, int age, Address address) {}

@GenerateGetters
public record Address(String street, String city, String zipCode, String country) {}

@GenerateGetters
public record Company(String name, Person ceo, List&lt;Person&gt; employees, Address headquarters) {}
</code></pre>
<p><strong>Common Extraction Needs:</strong></p>
<ul>
<li>"Get the CEO's full name"</li>
<li>"Extract the company's headquarters city"</li>
<li>"Calculate the CEO's age group"</li>
<li>"Generate an employee's email address"</li>
<li>"Compute the length of a person's full name"</li>
</ul>
<p>A <code>Getter</code> makes these extractions type-safe, composable, and expressive.</p>
<hr />
<h2 id="think-of-getters-like"><a class="header" href="#think-of-getters-like">Think of Getters Like...</a></h2>
<ul>
<li><strong>A functional accessor</strong> üìñ: Extracting a specific value from a container</li>
<li><strong>A read-only lens</strong> üîç: Focusing on one element without modification capability</li>
<li><strong>A computed property</strong> üßÆ: Deriving values on-the-fly without storage</li>
<li><strong>A data pipeline stage</strong> üîó: Composable extraction steps</li>
<li><strong>A pure function in optic form</strong> Œª: Wrapping functions for composition</li>
</ul>
<hr />
<h2 id="getter-vs-lens-vs-fold-understanding-the-differences"><a class="header" href="#getter-vs-lens-vs-fold-understanding-the-differences">Getter vs Lens vs Fold: Understanding the Differences</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th>Getter</th><th>Lens</th><th>Fold</th></tr></thead><tbody>
<tr><td><strong>Focus</strong></td><td>Exactly one element</td><td>Exactly one element</td><td>Zero or more elements</td></tr>
<tr><td><strong>Can modify?</strong></td><td>‚ùå No</td><td>‚úÖ Yes</td><td>‚ùå No</td></tr>
<tr><td><strong>Core operation</strong></td><td><code>get(source)</code></td><td><code>get(source)</code>, <code>set(value, source)</code></td><td><code>foldMap(monoid, fn, source)</code></td></tr>
<tr><td><strong>Use case</strong></td><td>Computed/derived values</td><td>Field access with updates</td><td>Queries over collections</td></tr>
<tr><td><strong>Intent</strong></td><td>"Extract this single value"</td><td>"Get or set this field"</td><td>"Query all these values"</td></tr>
</tbody></table>
</div>
<p><strong>Key Insight</strong>: Every <code>Lens</code> can be viewed as a <code>Getter</code> (its read-only half), but not every <code>Getter</code> can be a <code>Lens</code>. A <code>Getter</code> extends <code>Fold</code>, meaning it inherits all query operations (<code>exists</code>, <code>all</code>, <code>find</code>, <code>preview</code>) whilst guaranteeing exactly one focused element.</p>
<hr />
<h2 id="a-step-by-step-walkthrough-8"><a class="header" href="#a-step-by-step-walkthrough-8">A Step-by-Step Walkthrough</a></h2>
<h3 id="step-1-creating-getters"><a class="header" href="#step-1-creating-getters">Step 1: Creating Getters</a></h3>
<h4 id="using-generategetters-annotation"><a class="header" href="#using-generategetters-annotation">Using <code>@GenerateGetters</code> Annotation</a></h4>
<p>Annotating a record with <strong><code>@GenerateGetters</code></strong> creates a companion class (e.g., <code>PersonGetters</code>) containing a <code>Getter</code> for each field:</p>
<pre><code class="language-java">import org.higherkindedj.optics.annotations.GenerateGetters;

@GenerateGetters
public record Person(String firstName, String lastName, int age, Address address) {}
</code></pre>
<p>This generates:</p>
<ul>
<li><code>PersonGetters.firstName()</code> ‚Üí <code>Getter&lt;Person, String&gt;</code></li>
<li><code>PersonGetters.lastName()</code> ‚Üí <code>Getter&lt;Person, String&gt;</code></li>
<li><code>PersonGetters.age()</code> ‚Üí <code>Getter&lt;Person, Integer&gt;</code></li>
<li><code>PersonGetters.address()</code> ‚Üí <code>Getter&lt;Person, Address&gt;</code></li>
</ul>
<p>Plus convenience methods:</p>
<ul>
<li><code>PersonGetters.getFirstName(person)</code> ‚Üí <code>String</code></li>
<li><code>PersonGetters.getLastName(person)</code> ‚Üí <code>String</code></li>
<li>etc.</li>
</ul>
<h4 id="using-factory-methods"><a class="header" href="#using-factory-methods">Using Factory Methods</a></h4>
<p>Create Getters programmatically for computed or derived values:</p>
<pre><code class="language-java">// Simple field extraction
Getter&lt;Person, String&gt; firstName = Getter.of(Person::firstName);

// Computed value
Getter&lt;Person, String&gt; fullName = Getter.of(p -&gt; p.firstName() + " " + p.lastName());

// Derived value
Getter&lt;Person, String&gt; initials = Getter.of(p -&gt;
    p.firstName().charAt(0) + "." + p.lastName().charAt(0) + ".");

// Alternative factory (alias for of)
Getter&lt;String, Integer&gt; stringLength = Getter.to(String::length);
</code></pre>
<h3 id="step-2-core-getter-operations"><a class="header" href="#step-2-core-getter-operations">Step 2: Core Getter Operations</a></h3>
<h4 id="getsource-extract-the-focused-value"><a class="header" href="#getsource-extract-the-focused-value"><strong><code>get(source)</code></strong>: Extract the Focused Value</a></h4>
<p>The fundamental operation‚Äîreturns exactly one value:</p>
<pre><code class="language-java">Person person = new Person("Jane", "Smith", 45, address);

Getter&lt;Person, String&gt; fullName = Getter.of(p -&gt; p.firstName() + " " + p.lastName());
String name = fullName.get(person);
// Result: "Jane Smith"

Getter&lt;Person, Integer&gt; age = Getter.of(Person::age);
int years = age.get(person);
// Result: 45
</code></pre>
<h3 id="step-3-composing-getters"><a class="header" href="#step-3-composing-getters">Step 3: Composing Getters</a></h3>
<p>Chain Getters together to extract deeply nested values:</p>
<pre><code class="language-java">Getter&lt;Person, Address&gt; addressGetter = Getter.of(Person::address);
Getter&lt;Address, String&gt; cityGetter = Getter.of(Address::city);

// Compose: Person ‚Üí Address ‚Üí String
Getter&lt;Person, String&gt; personCity = addressGetter.andThen(cityGetter);

Person person = new Person("Jane", "Smith", 45,
    new Address("123 Main St", "London", "EC1A", "UK"));

String city = personCity.get(person);
// Result: "London"
</code></pre>
<h4 id="deep-composition-chain"><a class="header" href="#deep-composition-chain">Deep Composition Chain</a></h4>
<pre><code class="language-java">Getter&lt;Company, Person&gt; ceoGetter = Getter.of(Company::ceo);
Getter&lt;Person, String&gt; fullNameGetter = Getter.of(p -&gt; p.firstName() + " " + p.lastName());
Getter&lt;String, Integer&gt; lengthGetter = Getter.of(String::length);

// Compose: Company ‚Üí Person ‚Üí String ‚Üí Integer
Getter&lt;Company, Integer&gt; ceoNameLength = ceoGetter
    .andThen(fullNameGetter)
    .andThen(lengthGetter);

Company company = new Company("TechCorp", ceo, employees, headquarters);
int length = ceoNameLength.get(company);
// Result: 10 (length of "Jane Smith")
</code></pre>
<h3 id="step-4-getter-as-a-fold"><a class="header" href="#step-4-getter-as-a-fold">Step 4: Getter as a Fold</a></h3>
<p>Since <code>Getter</code> extends <code>Fold</code>, you inherit all query operations‚Äîbut they operate on exactly one element:</p>
<pre><code class="language-java">Getter&lt;Person, Integer&gt; ageGetter = Getter.of(Person::age);
Person person = new Person("Jane", "Smith", 45, address);

// preview() returns Optional with the single value
Optional&lt;Integer&gt; age = ageGetter.preview(person);
// Result: Optional[45]

// getAll() returns a single-element list
List&lt;Integer&gt; ages = ageGetter.getAll(person);
// Result: [45]

// exists() checks if the single value matches
boolean isExperienced = ageGetter.exists(a -&gt; a &gt; 40, person);
// Result: true

// all() checks the single value (always same as exists for Getter)
boolean isSenior = ageGetter.all(a -&gt; a &gt;= 65, person);
// Result: false

// find() returns the value if it matches
Optional&lt;Integer&gt; foundAge = ageGetter.find(a -&gt; a &gt; 30, person);
// Result: Optional[45]

// length() always returns 1 for Getter
int count = ageGetter.length(person);
// Result: 1

// isEmpty() always returns false for Getter
boolean empty = ageGetter.isEmpty(person);
// Result: false
</code></pre>
<h3 id="step-5-combining-getters-with-folds"><a class="header" href="#step-5-combining-getters-with-folds">Step 5: Combining Getters with Folds</a></h3>
<p>Compose Getters with Folds for powerful queries:</p>
<pre><code class="language-java">Getter&lt;Company, List&lt;Person&gt;&gt; employeesGetter = Getter.of(Company::employees);
Fold&lt;List&lt;Person&gt;, Person&gt; listFold = Fold.of(list -&gt; list);
Getter&lt;Person, String&gt; fullNameGetter = Getter.of(p -&gt; p.firstName() + " " + p.lastName());

// Company ‚Üí List&lt;Person&gt; ‚Üí Person (multiple) ‚Üí String
Fold&lt;Company, String&gt; allEmployeeNames = employeesGetter
    .asFold()  // Convert Getter to Fold
    .andThen(listFold)
    .andThen(fullNameGetter.asFold());

List&lt;String&gt; names = allEmployeeNames.getAll(company);
// Result: ["John Doe", "Alice Johnson", "Bob Williams"]

boolean hasExperienced = listFold.andThen(Getter.of(Person::age).asFold())
    .exists(age -&gt; age &gt; 40, employees);
// Result: depends on employee ages
</code></pre>
<h3 id="step-6-maybe-based-getter-extension"><a class="header" href="#step-6-maybe-based-getter-extension">Step 6: Maybe-Based Getter Extension</a></h3>
<div id="admonition-extension-method" class="admonition admonish-note" role="note" aria-labelledby="admonition-extension-method-title">
<div class="admonition-title">
<div id="admonition-extension-method-title">
<p>Extension Method</p>
</div>
<a class="admonition-anchor-link" href="optics/getters.html#admonition-extension-method"></a>
</div>
<div>
<p>Higher-kinded-j provides the <code>getMaybe</code> extension method that integrates <code>Getter</code> with the <code>Maybe</code> type, enabling null-safe navigation through potentially nullable fields. This extension is available via static import from <code>GetterExtensions</code>.</p>
</div>
</div>
<h4 id="the-challenge-null-safe-navigation"><a class="header" href="#the-challenge-null-safe-navigation">The Challenge: Null-Safe Navigation</a></h4>
<p>When working with nested data structures, intermediate values may be <code>null</code>, leading to <code>NullPointerException</code> if not handled carefully. Traditional approaches require verbose null checks at each level:</p>
<pre><code class="language-java">// Verbose traditional approach with null checks
Person person = company.getCeo();
if (person != null) {
    Address address = person.getAddress();
    if (address != null) {
        String city = address.getCity();
        if (city != null) {
            System.out.println("City: " + city);
        }
    }
}
</code></pre>
<p>The <code>getMaybe</code> extension method provides a more functional approach by wrapping extracted values in <code>Maybe</code>, which explicitly models presence or absence without the risk of NPE.</p>
<h4 id="think-of-getmaybe-like"><a class="header" href="#think-of-getmaybe-like">Think of getMaybe Like...</a></h4>
<ul>
<li><strong>A safe elevator</strong> - Transports you to the desired floor, or tells you it's unavailable</li>
<li><strong>A null-safe wrapper</strong> - Extracts values whilst protecting against null</li>
<li><strong>Optional's functional cousin</strong> - Same safety guarantees, better functional composition</li>
<li><strong>A maybe-monad extractor</strong> - Lifts extraction into the Maybe context</li>
</ul>
<h4 id="how-getmaybe-works"><a class="header" href="#how-getmaybe-works">How getMaybe Works</a></h4>
<p>The <code>getMaybe</code> static method is imported from <code>GetterExtensions</code>:</p>
<pre><code class="language-java">import static org.higherkindedj.optics.extensions.GetterExtensions.getMaybe;
</code></pre>
<p><strong>Signature:</strong></p>
<pre><code class="language-java">public static &lt;S, A&gt; Maybe&lt;A&gt; getMaybe(Getter&lt;S, A&gt; getter, S source)
</code></pre>
<p>It extracts a value using the provided <code>Getter</code> and wraps it in <code>Maybe</code>:</p>
<ul>
<li>If the extracted value is <strong>non-null</strong>, returns <code>Just(value)</code></li>
<li>If the extracted value is <strong>null</strong>, returns <code>Nothing</code></li>
</ul>
<h4 id="basic-usage-example"><a class="header" href="#basic-usage-example">Basic Usage Example</a></h4>
<pre><code class="language-java">import org.higherkindedj.optics.Getter;
import org.higherkindedj.hkt.maybe.Maybe;
import static org.higherkindedj.optics.extensions.GetterExtensions.getMaybe;

public record Person(String firstName, String lastName, Address address) {}
public record Address(String street, String city) {}

Getter&lt;Person, String&gt; firstNameGetter = Getter.of(Person::firstName);
Getter&lt;Person, Address&gt; addressGetter = Getter.of(Person::address);

Person person = new Person("Jane", "Smith", address);

// Extract non-null value
Maybe&lt;String&gt; name = getMaybe(firstNameGetter, person);
// Result: Just("Jane")

// Extract nullable value
Person personWithNullAddress = new Person("Bob", "Jones", null);
Maybe&lt;Address&gt; address = getMaybe(addressGetter, personWithNullAddress);
// Result: Nothing
</code></pre>
<h4 id="safe-navigation-with-composed-getters"><a class="header" href="#safe-navigation-with-composed-getters">Safe Navigation with Composed Getters</a></h4>
<p>The real power of <code>getMaybe</code> emerges when navigating nested structures with potentially null intermediate values. By using <code>flatMap</code>, you can safely chain extractions:</p>
<pre><code class="language-java">Getter&lt;Person, Address&gt; addressGetter = Getter.of(Person::address);
Getter&lt;Address, String&gt; cityGetter = Getter.of(Address::city);

// Safe navigation: Person ‚Üí Maybe&lt;Address&gt; ‚Üí Maybe&lt;String&gt;
Person personWithAddress = new Person("Jane", "Smith",
    new Address("123 Main St", "London"));

Maybe&lt;String&gt; city = getMaybe(addressGetter, personWithAddress)
    .flatMap(addr -&gt; getMaybe(cityGetter, addr));
// Result: Just("London")

// Safe with null intermediate
Person personWithNullAddress = new Person("Bob", "Jones", null);

Maybe&lt;String&gt; noCity = getMaybe(addressGetter, personWithNullAddress)
    .flatMap(addr -&gt; getMaybe(cityGetter, addr));
// Result: Nothing (safely handles null address)
</code></pre>
<p><strong>Key Pattern</strong>: Use <code>flatMap</code> to chain <code>getMaybe</code> calls, creating a null-safe pipeline.</p>
<h4 id="comparison-direct-access-vs-getmaybe"><a class="header" href="#comparison-direct-access-vs-getmaybe">Comparison: Direct Access vs getMaybe</a></h4>
<p>Understanding when to use each approach:</p>
<div class="table-wrapper"><table><thead><tr><th>Approach</th><th>Null Safety</th><th>Composability</th><th>Verbosity</th><th>Use Case</th></tr></thead><tbody>
<tr><td><strong>Direct field access</strong></td><td>‚ùå NPE risk</td><td>‚ùå No</td><td>‚úÖ Minimal</td><td>Known non-null values</td></tr>
<tr><td><strong>Manual null checks</strong></td><td>‚úÖ Safe</td><td>‚ùå No</td><td>‚ùå Very verbose</td><td>Simple cases</td></tr>
<tr><td><strong>Optional chaining</strong></td><td>‚úÖ Safe</td><td>‚ö†Ô∏è Limited</td><td>‚ö†Ô∏è Moderate</td><td>Java interop</td></tr>
<tr><td><strong>getMaybe</strong></td><td>‚úÖ Safe</td><td>‚úÖ Excellent</td><td>‚úÖ Concise</td><td>Functional pipelines</td></tr>
</tbody></table>
</div>
<p><strong>Example Comparison:</strong></p>
<pre><code class="language-java">// Direct access (risky)
String city1 = person.address().city(); // NPE if address is null!

// Manual null checks (verbose)
String city2 = null;
if (person.address() != null &amp;&amp; person.address().city() != null) {
    city2 = person.address().city();
}

// Optional chaining (better)
Optional&lt;String&gt; city3 = Optional.ofNullable(person.address())
    .map(Address::city);

// getMaybe (best for functional code)
Maybe&lt;String&gt; city4 = getMaybe(addressGetter, person)
    .flatMap(addr -&gt; getMaybe(cityGetter, addr));
</code></pre>
<h4 id="integration-with-maybe-operations"><a class="header" href="#integration-with-maybe-operations">Integration with Maybe Operations</a></h4>
<p>Once you've extracted a value into <code>Maybe</code>, you can leverage the full power of monadic operations:</p>
<pre><code class="language-java">Getter&lt;Person, Address&gt; addressGetter = Getter.of(Person::address);
Getter&lt;Address, String&gt; cityGetter = Getter.of(Address::city);

Person person = new Person("Jane", "Smith",
    new Address("123 Main St", "London"));

// Extract and transform
Maybe&lt;String&gt; uppercaseCity = getMaybe(addressGetter, person)
    .flatMap(addr -&gt; getMaybe(cityGetter, addr))
    .map(String::toUpperCase);
// Result: Just("LONDON")

// Extract with default
String cityOrDefault = getMaybe(addressGetter, person)
    .flatMap(addr -&gt; getMaybe(cityGetter, addr))
    .getOrElse("Unknown");
// Result: "London"

// Extract and filter
Maybe&lt;String&gt; longCityName = getMaybe(addressGetter, person)
    .flatMap(addr -&gt; getMaybe(cityGetter, addr))
    .filter(name -&gt; name.length() &gt; 5);
// Result: Just("London") (length is 6)

// Chain multiple operations
String report = getMaybe(addressGetter, person)
    .flatMap(addr -&gt; getMaybe(cityGetter, addr))
    .map(city -&gt; "Person lives in " + city)
    .getOrElse("Address unknown");
// Result: "Person lives in London"
</code></pre>
<h4 id="when-to-use-getmaybe"><a class="header" href="#when-to-use-getmaybe">When to Use getMaybe</a></h4>
<p><strong>Use <code>getMaybe</code> when:</strong></p>
<ul>
<li>Navigating through <strong>potentially null</strong> intermediate values</li>
<li>Building <strong>functional pipelines</strong> with Maybe-based operations</li>
<li>You want <strong>explicit presence/absence</strong> semantics</li>
<li>Composing with other Maybe-returning functions</li>
<li>Working within HKT-based abstractions</li>
</ul>
<pre><code class="language-java">// Perfect for null-safe navigation
Maybe&lt;String&gt; safeCity = getMaybe(addressGetter, person)
    .flatMap(addr -&gt; getMaybe(cityGetter, addr));
</code></pre>
<p><strong>Use standard <code>get()</code> when:</strong></p>
<ul>
<li>You <strong>know</strong> the values are non-null</li>
<li>You're working in <strong>performance-critical</strong> code</li>
<li>You want <strong>immediate NPE</strong> on unexpected nulls (fail-fast)</li>
</ul>
<pre><code class="language-java">// Fine when values are guaranteed non-null
String knownCity = cityGetter.get(knownAddress);
</code></pre>
<p><strong>Use <code>Getter.preview()</code> when:</strong></p>
<ul>
<li>You prefer Java's <code>Optional</code> for <strong>interoperability</strong></li>
<li>Working at API boundaries with standard Java code</li>
</ul>
<pre><code class="language-java">// Good for Java interop
Optional&lt;String&gt; optionalCity = cityGetter.preview(address);
</code></pre>
<h4 id="real-world-scenario-employee-profile-lookup"><a class="header" href="#real-world-scenario-employee-profile-lookup">Real-World Scenario: Employee Profile Lookup</a></h4>
<p>Here's a practical example showing how <code>getMaybe</code> simplifies complex null-safe extractions:</p>
<pre><code class="language-java">import org.higherkindedj.optics.Getter;
import org.higherkindedj.hkt.maybe.Maybe;
import static org.higherkindedj.optics.extensions.GetterExtensions.getMaybe;

public record Employee(String id, PersonalInfo personalInfo) {}
public record PersonalInfo(ContactInfo contactInfo, EmergencyContact emergencyContact) {}
public record ContactInfo(String email, String phone, Address address) {}
public record EmergencyContact(String name, String phone) {}
public record Address(String street, String city, String postcode) {}

public class EmployeeService {
    private static final Getter&lt;Employee, PersonalInfo&gt; PERSONAL_INFO =
        Getter.of(Employee::personalInfo);
    private static final Getter&lt;PersonalInfo, ContactInfo&gt; CONTACT_INFO =
        Getter.of(PersonalInfo::contactInfo);
    private static final Getter&lt;ContactInfo, Address&gt; ADDRESS =
        Getter.of(ContactInfo::address);
    private static final Getter&lt;Address, String&gt; CITY =
        Getter.of(Address::city);

    // Extract employee city with full null safety
    public Maybe&lt;String&gt; getEmployeeCity(Employee employee) {
        return getMaybe(PERSONAL_INFO, employee)
            .flatMap(info -&gt; getMaybe(CONTACT_INFO, info))
            .flatMap(contact -&gt; getMaybe(ADDRESS, contact))
            .flatMap(addr -&gt; getMaybe(CITY, addr));
    }

    // Generate location-based welcome message
    public String generateWelcomeMessage(Employee employee) {
        return getEmployeeCity(employee)
            .map(city -&gt; "Welcome to our " + city + " office!")
            .getOrElse("Welcome to our company!");
    }

    // Check if employee is in specific city
    public boolean isEmployeeInCity(Employee employee, String targetCity) {
        return getEmployeeCity(employee)
            .filter(city -&gt; city.equalsIgnoreCase(targetCity))
            .isJust();
    }

    // Collect all cities from employee list (skipping unknowns)
    public List&lt;String&gt; getAllCities(List&lt;Employee&gt; employees) {
        return employees.stream()
            .map(this::getEmployeeCity)
            .filter(Maybe::isJust)
            .map(Maybe::get)
            .distinct()
            .toList();
    }

    // Get city or fallback to emergency contact location
    public String getAnyCityInfo(Employee employee) {
        Getter&lt;PersonalInfo, EmergencyContact&gt; emergencyGetter =
            Getter.of(PersonalInfo::emergencyContact);

        // Try primary address first
        Maybe&lt;String&gt; primaryCity = getMaybe(PERSONAL_INFO, employee)
            .flatMap(info -&gt; getMaybe(CONTACT_INFO, info))
            .flatMap(contact -&gt; getMaybe(ADDRESS, contact))
            .flatMap(addr -&gt; getMaybe(CITY, addr));

        // If not found, could try emergency contact (simplified example)
        return primaryCity.getOrElse("Location unknown");
    }
}
</code></pre>
<h4 id="performance-considerations-2"><a class="header" href="#performance-considerations-2">Performance Considerations</a></h4>
<p><code>getMaybe</code> adds minimal overhead:</p>
<ul>
<li><strong>One null check</strong>: Checks if the extracted value is null</li>
<li><strong>One Maybe wrapping</strong>: Creates <code>Just</code> or <code>Nothing</code> instance</li>
<li><strong>Same extraction cost</strong>: Uses <code>Getter.get()</code> internally</li>
</ul>
<p><strong>Optimisation Tip</strong>: For performance-critical hot paths where values are guaranteed non-null, use <code>Getter.get()</code> directly. For most business logic, the safety and composability of <code>getMaybe</code> far outweigh the negligible cost.</p>
<pre><code class="language-java">// Hot path with guaranteed non-null (use direct get)
String fastAccess = nameGetter.get(person);

// Business logic with potential nulls (use getMaybe)
Maybe&lt;String&gt; safeAccess = getMaybe(addressGetter, person)
    .flatMap(addr -&gt; getMaybe(cityGetter, addr));
</code></pre>
<h4 id="practical-pattern-building-maybe-safe-composed-getters"><a class="header" href="#practical-pattern-building-maybe-safe-composed-getters">Practical Pattern: Building Maybe-Safe Composed Getters</a></h4>
<p>Create reusable null-safe extraction functions:</p>
<pre><code class="language-java">public class SafeGetters {
    // Create a null-safe composed getter using Maybe
    public static &lt;A, B, C&gt; Function&lt;A, Maybe&lt;C&gt;&gt; safePath(
        Getter&lt;A, B&gt; first,
        Getter&lt;B, C&gt; second
    ) {
        return source -&gt; getMaybe(first, source)
            .flatMap(intermediate -&gt; getMaybe(second, intermediate));
    }

    // Usage example
    private static final Function&lt;Person, Maybe&lt;String&gt;&gt; SAFE_CITY_LOOKUP =
        safePath(
            Getter.of(Person::address),
            Getter.of(Address::city)
        );

    public static void main(String[] args) {
        Person person = new Person("Jane", "Smith", null);
        Maybe&lt;String&gt; city = SAFE_CITY_LOOKUP.apply(person);
        // Result: Nothing (safely handled null address)
    }
}
</code></pre>
<div id="admonition-complete-example" class="admonition admonish-note" role="note" aria-labelledby="admonition-complete-example-title">
<div class="admonition-title">
<div id="admonition-complete-example-title">
<p>Complete Example</p>
</div>
<a class="admonition-anchor-link" href="optics/getters.html#admonition-complete-example"></a>
</div>
<div>
<p>See <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/extensions/GetterExtensionsExample.java">GetterExtensionsExample.java</a> for a runnable demonstration of <code>getMaybe</code> with practical scenarios.</p>
</div>
</div>
<hr />
<h2 id="built-in-helper-getters"><a class="header" href="#built-in-helper-getters">Built-in Helper Getters</a></h2>
<p>Higher-Kinded-J provides several utility Getters:</p>
<h3 id="identity-returns-the-source-itself"><a class="header" href="#identity-returns-the-source-itself"><strong><code>identity()</code></strong>: Returns the Source Itself</a></h3>
<pre><code class="language-java">Getter&lt;String, String&gt; id = Getter.identity();
String result = id.get("Hello");
// Result: "Hello"
</code></pre>
<p>Useful as a base case in composition or for type adaptation.</p>
<h3 id="constantvalue-always-returns-the-same-value"><a class="header" href="#constantvalue-always-returns-the-same-value"><strong><code>constant(value)</code></strong>: Always Returns the Same Value</a></h3>
<pre><code class="language-java">Getter&lt;String, Integer&gt; always42 = Getter.constant(42);
int result = always42.get("anything");
// Result: 42
</code></pre>
<p>Useful for providing default values in pipelines.</p>
<h3 id="first-and-second-pair-element-extractors"><a class="header" href="#first-and-second-pair-element-extractors"><strong><code>first()</code></strong> and <strong><code>second()</code></strong>: Pair Element Extractors</a></h3>
<pre><code class="language-java">Map.Entry&lt;Person, Address&gt; pair = new AbstractMap.SimpleEntry&lt;&gt;(ceo, hqAddress);

Getter&lt;Map.Entry&lt;Person, Address&gt;, Person&gt; firstGetter = Getter.first();
Getter&lt;Map.Entry&lt;Person, Address&gt;, Address&gt; secondGetter = Getter.second();

Person person = firstGetter.get(pair);
// Result: the CEO Person

Address address = secondGetter.get(pair);
// Result: the headquarters Address
</code></pre>
<hr />
<h2 id="when-to-use-getter-vs-other-approaches"><a class="header" href="#when-to-use-getter-vs-other-approaches">When to Use Getter vs Other Approaches</a></h2>
<h3 id="use-getter-when"><a class="header" href="#use-getter-when">Use Getter When:</a></h3>
<ul>
<li>You need <strong>computed or derived values</strong> without storing them</li>
<li>You want <strong>composable extraction</strong> pipelines</li>
<li>You're building <strong>reporting or analytics</strong> features</li>
<li>You need <strong>type-safe accessors</strong> that compose with other optics</li>
<li>You want <strong>clear read-only intent</strong> in your code</li>
</ul>
<pre><code class="language-java">// Good: Computed value without storage overhead
Getter&lt;Person, String&gt; email = Getter.of(p -&gt;
    p.firstName().toLowerCase() + "." + p.lastName().toLowerCase() + "@company.com");

// Good: Composable pipeline
Getter&lt;Company, String&gt; ceoCityUppercase = ceoGetter
    .andThen(addressGetter)
    .andThen(cityGetter)
    .andThen(Getter.of(String::toUpperCase));
</code></pre>
<h3 id="use-lens-when"><a class="header" href="#use-lens-when">Use Lens When:</a></h3>
<ul>
<li>You need <strong>both reading and writing</strong></li>
<li>You're working with <strong>mutable state</strong> (functionally)</li>
</ul>
<pre><code class="language-java">// Use Lens when you need to modify
Lens&lt;Person, String&gt; firstName = Lens.of(
    Person::firstName,
    (p, name) -&gt; new Person(name, p.lastName(), p.age(), p.address()));

Person updated = firstName.set("Janet", person);
</code></pre>
<h3 id="use-fold-when-1"><a class="header" href="#use-fold-when-1">Use Fold When:</a></h3>
<ul>
<li>You're querying <strong>zero or more elements</strong></li>
<li>You need to <strong>aggregate or search</strong> collections</li>
</ul>
<pre><code class="language-java">// Use Fold for collections
Fold&lt;Order, Product&gt; itemsFold = Fold.of(Order::items);
List&lt;Product&gt; all = itemsFold.getAll(order);
</code></pre>
<h3 id="use-direct-field-access-when-1"><a class="header" href="#use-direct-field-access-when-1">Use Direct Field Access When:</a></h3>
<ul>
<li>You need <strong>maximum performance</strong> with no abstraction overhead</li>
<li>You're not composing with other optics</li>
</ul>
<pre><code class="language-java">// Direct access when composition isn't needed
String name = person.firstName();
</code></pre>
<hr />
<h2 id="real-world-use-cases"><a class="header" href="#real-world-use-cases">Real-World Use Cases</a></h2>
<h3 id="data-transformation-pipelines"><a class="header" href="#data-transformation-pipelines">Data Transformation Pipelines</a></h3>
<pre><code class="language-java">Getter&lt;Person, String&gt; email = Getter.of(p -&gt;
    p.firstName().toLowerCase() + "." + p.lastName().toLowerCase() + "@techcorp.com");

Getter&lt;Person, String&gt; badgeId = Getter.of(p -&gt;
    p.lastName().substring(0, Math.min(3, p.lastName().length())).toUpperCase() +
    String.format("%04d", p.age() * 100));

// Generate employee reports
for (Person emp : company.employees()) {
    System.out.println("Employee: " + fullName.get(emp));
    System.out.println("  Email: " + email.get(emp));
    System.out.println("  Badge: " + badgeId.get(emp));
}
</code></pre>
<h3 id="analytics-and-reporting"><a class="header" href="#analytics-and-reporting">Analytics and Reporting</a></h3>
<pre><code class="language-java">Fold&lt;Company, Person&gt; allEmployees = Fold.of(Company::employees);
Getter&lt;Person, Integer&gt; age = Getter.of(Person::age);

// Calculate total age
int totalAge = allEmployees.andThen(age.asFold())
    .foldMap(sumMonoid(), Function.identity(), company);

// Calculate average age
double averageAge = (double) totalAge / company.employees().size();

// Check conditions
boolean allFromUK = allEmployees.andThen(addressGetter.asFold())
    .andThen(countryGetter.asFold())
    .all(c -&gt; c.equals("UK"), company);
</code></pre>
<h3 id="api-response-mapping"><a class="header" href="#api-response-mapping">API Response Mapping</a></h3>
<pre><code class="language-java">// Extract specific fields from nested API responses
Getter&lt;ApiResponse, User&gt; userGetter = Getter.of(ApiResponse::user);
Getter&lt;User, Profile&gt; profileGetter = Getter.of(User::profile);
Getter&lt;Profile, String&gt; displayName = Getter.of(Profile::displayName);

Getter&lt;ApiResponse, String&gt; userName = userGetter
    .andThen(profileGetter)
    .andThen(displayName);

String name = userName.get(response);
</code></pre>
<hr />
<h2 id="common-pitfalls-9"><a class="header" href="#common-pitfalls-9">Common Pitfalls</a></h2>
<h3 id="-dont-use-getter-when-you-need-to-modify"><a class="header" href="#-dont-use-getter-when-you-need-to-modify">‚ùå Don't Use Getter When You Need to Modify</a></h3>
<pre><code class="language-java">// Wrong: Getter can't modify
Getter&lt;Person, String&gt; nameGetter = Getter.of(Person::firstName);
// nameGetter.set("Jane", person); // Compilation error - no set method!
</code></pre>
<h3 id="-use-lens-when-modification-is-required"><a class="header" href="#-use-lens-when-modification-is-required">‚úÖ Use Lens When Modification Is Required</a></h3>
<pre><code class="language-java">// Correct: Use Lens for read-write access
Lens&lt;Person, String&gt; nameLens = Lens.of(Person::firstName, (p, n) -&gt;
    new Person(n, p.lastName(), p.age(), p.address()));

Person updated = nameLens.set("Jane", person);
</code></pre>
<h3 id="-dont-overlook-null-safety"><a class="header" href="#-dont-overlook-null-safety">‚ùå Don't Overlook Null Safety</a></h3>
<pre><code class="language-java">// Risky: Getter doesn't handle null values specially
Getter&lt;NullableRecord, String&gt; getter = Getter.of(NullableRecord::value);
String result = getter.get(new NullableRecord(null)); // Returns null
</code></pre>
<h3 id="-handle-nulls-explicitly"><a class="header" href="#-handle-nulls-explicitly">‚úÖ Handle Nulls Explicitly</a></h3>
<pre><code class="language-java">// Safe: Handle nulls in the getter function
Getter&lt;NullableRecord, String&gt; safeGetter = Getter.of(r -&gt;
    r.value() != null ? r.value() : "default");
</code></pre>
<hr />
<h2 id="performance-considerations-3"><a class="header" href="#performance-considerations-3">Performance Considerations</a></h2>
<p>Getters are <strong>extremely lightweight</strong>:</p>
<ul>
<li><strong>Zero overhead</strong>: Just a function wrapper</li>
<li><strong>No reflection</strong>: Direct method references</li>
<li><strong>Inline-friendly</strong>: JIT can optimise away the abstraction</li>
<li><strong>Lazy evaluation</strong>: Values computed only when <code>get()</code> is called</li>
</ul>
<p><strong>Best Practice</strong>: Use Getters freely‚Äîthey add minimal runtime cost whilst providing excellent composability and type safety.</p>
<pre><code class="language-java">// Efficient: Computed on demand
Getter&lt;Person, String&gt; fullName = Getter.of(p -&gt; p.firstName() + " " + p.lastName());

// No storage overhead, computed each time get() is called
String name1 = fullName.get(person1);
String name2 = fullName.get(person2);
</code></pre>
<hr />
<h2 id="complete-runnable-example-5"><a class="header" href="#complete-runnable-example-5">Complete, Runnable Example</a></h2>
<pre><code class="language-java">import org.higherkindedj.optics.Getter;
import org.higherkindedj.optics.Fold;
import org.higherkindedj.hkt.Monoid;
import java.util.*;
import java.util.function.Function;

public class GetterExample {

    public record Person(String firstName, String lastName, int age, Address address) {}
    public record Address(String street, String city, String zipCode, String country) {}
    public record Company(String name, Person ceo, List&lt;Person&gt; employees, Address headquarters) {}

    public static void main(String[] args) {
        // Create sample data
        Address ceoAddress = new Address("123 Executive Blvd", "London", "EC1A", "UK");
        Person ceo = new Person("Jane", "Smith", 45, ceoAddress);

        List&lt;Person&gt; employees = List.of(
            new Person("John", "Doe", 30, new Address("456 Oak St", "Manchester", "M1", "UK")),
            new Person("Alice", "Johnson", 28, new Address("789 Elm Ave", "Birmingham", "B1", "UK")),
            new Person("Bob", "Williams", 35, new Address("321 Pine Rd", "Leeds", "LS1", "UK"))
        );

        Address hqAddress = new Address("1000 Corporate Way", "London", "EC2A", "UK");
        Company company = new Company("TechCorp", ceo, employees, hqAddress);

        // === Basic Getters ===
        Getter&lt;Person, String&gt; fullName = Getter.of(p -&gt; p.firstName() + " " + p.lastName());
        Getter&lt;Person, Integer&gt; age = Getter.of(Person::age);

        System.out.println("CEO: " + fullName.get(ceo));
        System.out.println("CEO Age: " + age.get(ceo));

        // === Computed Values ===
        Getter&lt;Person, String&gt; initials = Getter.of(p -&gt;
            p.firstName().charAt(0) + "." + p.lastName().charAt(0) + ".");
        Getter&lt;Person, String&gt; email = Getter.of(p -&gt;
            p.firstName().toLowerCase() + "." + p.lastName().toLowerCase() + "@techcorp.com");

        System.out.println("CEO Initials: " + initials.get(ceo));
        System.out.println("CEO Email: " + email.get(ceo));

        // === Composition ===
        Getter&lt;Person, Address&gt; addressGetter = Getter.of(Person::address);
        Getter&lt;Address, String&gt; cityGetter = Getter.of(Address::city);
        Getter&lt;Company, Person&gt; ceoGetter = Getter.of(Company::ceo);

        Getter&lt;Person, String&gt; personCity = addressGetter.andThen(cityGetter);
        Getter&lt;Company, String&gt; companyCeoCity = ceoGetter.andThen(personCity);

        System.out.println("CEO City: " + personCity.get(ceo));
        System.out.println("Company CEO City: " + companyCeoCity.get(company));

        // === Getter as Fold ===
        Optional&lt;Integer&gt; ceoAge = age.preview(ceo);
        boolean isExperienced = age.exists(a -&gt; a &gt; 40, ceo);
        int ageCount = age.length(ceo); // Always 1 for Getter

        System.out.println("CEO Age (Optional): " + ceoAge);
        System.out.println("CEO is Experienced: " + isExperienced);
        System.out.println("Age Count: " + ageCount);

        // === Employee Analysis ===
        Fold&lt;List&lt;Person&gt;, Person&gt; listFold = Fold.of(list -&gt; list);

        List&lt;String&gt; employeeNames = listFold.andThen(fullName.asFold()).getAll(employees);
        System.out.println("Employee Names: " + employeeNames);

        List&lt;String&gt; employeeEmails = listFold.andThen(email.asFold()).getAll(employees);
        System.out.println("Employee Emails: " + employeeEmails);

        // Calculate average age
        int totalAge = listFold.andThen(age.asFold())
            .foldMap(sumMonoid(), Function.identity(), employees);
        double avgAge = (double) totalAge / employees.size();
        System.out.println("Average Employee Age: " + String.format("%.1f", avgAge));

        // Check if all from UK
        Getter&lt;Address, String&gt; countryGetter = Getter.of(Address::country);
        boolean allUK = listFold.andThen(addressGetter.asFold())
            .andThen(countryGetter.asFold())
            .all(c -&gt; c.equals("UK"), employees);
        System.out.println("All Employees from UK: " + allUK);
    }

    private static Monoid&lt;Integer&gt; sumMonoid() {
        return new Monoid&lt;&gt;() {
            @Override public Integer empty() { return 0; }
            @Override public Integer combine(Integer a, Integer b) { return a + b; }
        };
    }
}
</code></pre>
<p><strong>Expected Output:</strong></p>
<pre><code>CEO: Jane Smith
CEO Age: 45
CEO Initials: J.S.
CEO Email: jane.smith@techcorp.com
CEO City: London
Company CEO City: London
CEO Age (Optional): Optional[45]
CEO is Experienced: true
Age Count: 1
Employee Names: [John Doe, Alice Johnson, Bob Williams]
Employee Emails: [john.doe@techcorp.com, alice.johnson@techcorp.com, bob.williams@techcorp.com]
Average Employee Age: 31.0
All Employees from UK: true
</code></pre>
<hr />
<h2 id="why-getters-are-important"><a class="header" href="#why-getters-are-important">Why Getters Are Important</a></h2>
<p><code>Getter</code> completes the read-only optics family by providing:</p>
<ul>
<li><strong>Single-element focus</strong>: Guarantees exactly one value (unlike Fold's zero-or-more)</li>
<li><strong>Composability</strong>: Chains beautifully with other optics</li>
<li><strong>Computed values</strong>: Derive data without storage overhead</li>
<li><strong>Clear intent</strong>: Explicitly read-only, preventing accidental modifications</li>
<li><strong>Type safety</strong>: Compile-time guarantees on extraction paths</li>
<li><strong>Fold inheritance</strong>: Leverages query operations (exists, all, find) for single values</li>
</ul>
<p>By adding <code>Getter</code> to your optics toolkit alongside <code>Lens</code>, <code>Prism</code>, <code>Iso</code>, <code>Traversal</code>, and <code>Fold</code>, you have precise control over read-only access patterns. Use <code>Getter</code> when you need composable value extraction, <code>Fold</code> when you query collections, and <code>Lens</code> when you need both reading and writing.</p>
<p>The key insight: <strong>Getters make pure functions first-class composable citizens</strong>, allowing you to build sophisticated data extraction pipelines with clarity and type safety.</p>
<hr />
<p><strong>Previous:</strong> <a href="optics/indexed_optics.html">Indexed Optics: Position-Aware Operations</a>
<strong>Next:</strong> <a href="optics/setters.html">Setters: Composable Write-Only Modifications</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="setters-a-practical-guide"><a class="header" href="#setters-a-practical-guide">Setters: A Practical Guide</a></h1>
<h2 id="composable-write-only-modifications"><a class="header" href="#composable-write-only-modifications"><em>Composable Write-Only Modifications</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="optics/setters.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to modify data structures using composable, write-only optics</li>
<li>Using <code>@GenerateSetters</code> to create type-safe modifiers automatically</li>
<li>Understanding the relationship between Setter and Traversal</li>
<li>Creating modification pipelines without read access</li>
<li>Effectful modifications using Applicative contexts</li>
<li>Factory methods: <code>of</code>, <code>fromGetSet</code>, <code>forList</code>, <code>forMapValues</code>, <code>identity</code></li>
<li>When to use Setter vs Lens vs Traversal</li>
<li>Building batch update and normalisation pipelines</li>
</ul>
</div>
</div>
<div id="admonition-example-code" class="admonition admonish-note" role="note" aria-labelledby="admonition-example-code-title">
<div class="admonition-title">
<div id="admonition-example-code-title">
<p>Example Code</p>
</div>
<a class="admonition-anchor-link" href="optics/setters.html#admonition-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/SetterUsageExample.java">SetterUsageExample</a></p>
</div>
</div>
<p>In the previous guide, we explored <strong><code>Getter</code></strong> for composable read-only access. Now we turn to its dual: <strong><code>Setter</code></strong>, a write-only optic that modifies data without necessarily reading it first.</p>
<p>A <strong><code>Setter</code></strong> is an optic that focuses on transforming elements within a structure. Unlike a <code>Lens</code>, which provides both getting and setting, a <code>Setter</code> concentrates solely on modification‚Äîmaking it ideal for batch updates, data normalisation, and transformation pipelines where read access isn't required.</p>
<hr />
<h2 id="the-scenario-user-management-system"><a class="header" href="#the-scenario-user-management-system">The Scenario: User Management System</a></h2>
<p>Consider a user management system where you need to perform various modifications:</p>
<p><strong>The Data Model:</strong></p>
<pre><code class="language-java">@GenerateSetters
public record User(String username, String email, int loginCount, UserSettings settings) {}

@GenerateSetters
public record UserSettings(
    String theme, boolean notifications, int fontSize, Map&lt;String, String&gt; preferences) {}

@GenerateSetters
public record Product(String name, double price, int stock, List&lt;String&gt; tags) {}

@GenerateSetters
public record Inventory(List&lt;Product&gt; products, String warehouseId) {}
</code></pre>
<p><strong>Common Modification Needs:</strong></p>
<ul>
<li>"Normalise all usernames to lowercase"</li>
<li>"Increment login count after authentication"</li>
<li>"Apply 10% discount to all products"</li>
<li>"Restock all items by 10 units"</li>
<li>"Convert all product names to title case"</li>
<li>"Set all user themes to dark mode"</li>
</ul>
<p>A <code>Setter</code> makes these modifications type-safe, composable, and expressive.</p>
<hr />
<h2 id="think-of-setters-like"><a class="header" href="#think-of-setters-like">Think of Setters Like...</a></h2>
<ul>
<li><strong>A functional modifier</strong> ‚úèÔ∏è: Transforming values without reading</li>
<li><strong>A write-only lens</strong> üéØ: Focusing on modification only</li>
<li><strong>A batch transformer</strong> üîÑ: Applying changes to multiple elements</li>
<li><strong>A data normalisation tool</strong> üìê: Standardising formats across structures</li>
<li><strong>A pipeline stage</strong> ‚öôÔ∏è: Composable modification steps</li>
</ul>
<hr />
<h2 id="setter-vs-lens-vs-traversal-understanding-the-differences"><a class="header" href="#setter-vs-lens-vs-traversal-understanding-the-differences">Setter vs Lens vs Traversal: Understanding the Differences</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th>Setter</th><th>Lens</th><th>Traversal</th></tr></thead><tbody>
<tr><td><strong>Focus</strong></td><td>One or more elements</td><td>Exactly one element</td><td>Zero or more elements</td></tr>
<tr><td><strong>Can read?</strong></td><td>‚ùå No (typically)</td><td>‚úÖ Yes</td><td>‚úÖ Yes</td></tr>
<tr><td><strong>Can modify?</strong></td><td>‚úÖ Yes</td><td>‚úÖ Yes</td><td>‚úÖ Yes</td></tr>
<tr><td><strong>Core operations</strong></td><td><code>modify</code>, <code>set</code></td><td><code>get</code>, <code>set</code>, <code>modify</code></td><td><code>modifyF</code>, <code>getAll</code></td></tr>
<tr><td><strong>Use case</strong></td><td>Write-only pipelines</td><td>Read-write field access</td><td>Collection traversals</td></tr>
<tr><td><strong>Intent</strong></td><td>"Transform these values"</td><td>"Get or set this field"</td><td>"Update all these elements"</td></tr>
</tbody></table>
</div>
<p><strong>Key Insight</strong>: A <code>Setter</code> can be viewed as the write-only half of a <code>Lens</code>. It extends <code>Optic</code>, enabling composition with other optics and supporting effectful modifications via <code>modifyF</code>. Choose <code>Setter</code> when you want to emphasise write-only intent or when read access isn't needed.</p>
<hr />
<h2 id="a-step-by-step-walkthrough-9"><a class="header" href="#a-step-by-step-walkthrough-9">A Step-by-Step Walkthrough</a></h2>
<h3 id="step-1-creating-setters"><a class="header" href="#step-1-creating-setters">Step 1: Creating Setters</a></h3>
<h4 id="using-generatesetters-annotation"><a class="header" href="#using-generatesetters-annotation">Using <code>@GenerateSetters</code> Annotation</a></h4>
<p>Annotating a record with <strong><code>@GenerateSetters</code></strong> creates a companion class (e.g., <code>UserSetters</code>) containing a <code>Setter</code> for each field:</p>
<pre><code class="language-java">import org.higherkindedj.optics.annotations.GenerateSetters;

@GenerateSetters
public record User(String username, String email, int loginCount, UserSettings settings) {}
</code></pre>
<p>This generates:</p>
<ul>
<li><code>UserSetters.username()</code> ‚Üí <code>Setter&lt;User, String&gt;</code></li>
<li><code>UserSetters.email()</code> ‚Üí <code>Setter&lt;User, String&gt;</code></li>
<li><code>UserSetters.loginCount()</code> ‚Üí <code>Setter&lt;User, Integer&gt;</code></li>
<li><code>UserSetters.settings()</code> ‚Üí <code>Setter&lt;User, UserSettings&gt;</code></li>
</ul>
<p>Plus convenience methods:</p>
<ul>
<li><code>UserSetters.withUsername(user, newUsername)</code> ‚Üí <code>User</code></li>
<li><code>UserSetters.withEmail(user, newEmail)</code> ‚Üí <code>User</code></li>
<li>etc.</li>
</ul>
<h4 id="using-factory-methods-1"><a class="header" href="#using-factory-methods-1">Using Factory Methods</a></h4>
<p>Create Setters programmatically:</p>
<pre><code class="language-java">// Using fromGetSet for single-element focus
Setter&lt;User, String&gt; usernameSetter = Setter.fromGetSet(
    User::username,
    (user, newUsername) -&gt; new User(newUsername, user.email(), user.loginCount(), user.settings()));

// Using of for transformation-based definition
Setter&lt;Person, String&gt; nameSetter = Setter.of(
    f -&gt; person -&gt; new Person(f.apply(person.name()), person.age()));

// Built-in collection setters
Setter&lt;List&lt;Integer&gt;, Integer&gt; listSetter = Setter.forList();
Setter&lt;Map&lt;String, Double&gt;, Double&gt; mapValuesSetter = Setter.forMapValues();
</code></pre>
<h3 id="step-2-core-setter-operations"><a class="header" href="#step-2-core-setter-operations">Step 2: Core Setter Operations</a></h3>
<h4 id="modifyfunction-source-transform-the-focused-value"><a class="header" href="#modifyfunction-source-transform-the-focused-value"><strong><code>modify(function, source)</code></strong>: Transform the Focused Value</a></h4>
<p>Applies a function to modify the focused element:</p>
<pre><code class="language-java">Setter&lt;User, String&gt; usernameSetter = Setter.fromGetSet(
    User::username,
    (u, name) -&gt; new User(name, u.email(), u.loginCount(), u.settings()));

User user = new User("JOHN_DOE", "john@example.com", 10, settings);

// Transform username to lowercase
User normalised = usernameSetter.modify(String::toLowerCase, user);
// Result: User("john_doe", "john@example.com", 10, settings)

// Append suffix
User suffixed = usernameSetter.modify(name -&gt; name + "_admin", user);
// Result: User("JOHN_DOE_admin", "john@example.com", 10, settings)
</code></pre>
<h4 id="setvalue-source-replace-the-focused-value"><a class="header" href="#setvalue-source-replace-the-focused-value"><strong><code>set(value, source)</code></strong>: Replace the Focused Value</a></h4>
<p>Sets all focused elements to a specific value:</p>
<pre><code class="language-java">Setter&lt;User, Integer&gt; loginCountSetter = Setter.fromGetSet(
    User::loginCount,
    (u, count) -&gt; new User(u.username(), u.email(), count, u.settings()));

User user = new User("john", "john@example.com", 10, settings);
User reset = loginCountSetter.set(0, user);
// Result: User("john", "john@example.com", 0, settings)
</code></pre>
<h3 id="step-3-composing-setters"><a class="header" href="#step-3-composing-setters">Step 3: Composing Setters</a></h3>
<p>Chain Setters together for deep modifications:</p>
<pre><code class="language-java">Setter&lt;User, UserSettings&gt; settingsSetter = Setter.fromGetSet(
    User::settings,
    (u, s) -&gt; new User(u.username(), u.email(), u.loginCount(), s));

Setter&lt;UserSettings, String&gt; themeSetter = Setter.fromGetSet(
    UserSettings::theme,
    (s, theme) -&gt; new UserSettings(theme, s.notifications(), s.fontSize(), s.preferences()));

// Compose: User ‚Üí UserSettings ‚Üí String
Setter&lt;User, String&gt; userThemeSetter = settingsSetter.andThen(themeSetter);

User user = new User("john", "john@example.com", 10,
    new UserSettings("light", true, 14, Map.of()));

User darkModeUser = userThemeSetter.set("dark", user);
// Result: User with settings.theme = "dark"
</code></pre>
<h4 id="deep-composition-chain-1"><a class="header" href="#deep-composition-chain-1">Deep Composition Chain</a></h4>
<pre><code class="language-java">Setter&lt;User, UserSettings&gt; settingsSetter = /* ... */;
Setter&lt;UserSettings, Integer&gt; fontSizeSetter = /* ... */;

Setter&lt;User, Integer&gt; userFontSizeSetter = settingsSetter.andThen(fontSizeSetter);

User largerFont = userFontSizeSetter.modify(size -&gt; size + 2, user);
// Result: User with settings.fontSize increased by 2
</code></pre>
<h3 id="step-4-collection-setters"><a class="header" href="#step-4-collection-setters">Step 4: Collection Setters</a></h3>
<p>Higher-Kinded-J provides built-in Setters for collections:</p>
<h4 id="forlist-modify-all-list-elements"><a class="header" href="#forlist-modify-all-list-elements"><strong><code>forList()</code></strong>: Modify All List Elements</a></h4>
<pre><code class="language-java">Setter&lt;List&lt;Integer&gt;, Integer&gt; listSetter = Setter.forList();

List&lt;Integer&gt; numbers = List.of(1, 2, 3, 4, 5);

// Double all values
List&lt;Integer&gt; doubled = listSetter.modify(x -&gt; x * 2, numbers);
// Result: [2, 4, 6, 8, 10]

// Set all to same value
List&lt;Integer&gt; allZeros = listSetter.set(0, numbers);
// Result: [0, 0, 0, 0, 0]
</code></pre>
<h4 id="formapvalues-modify-all-map-values"><a class="header" href="#formapvalues-modify-all-map-values"><strong><code>forMapValues()</code></strong>: Modify All Map Values</a></h4>
<pre><code class="language-java">Setter&lt;Map&lt;String, Integer&gt;, Integer&gt; mapSetter = Setter.forMapValues();

Map&lt;String, Integer&gt; scores = Map.of("Alice", 85, "Bob", 90, "Charlie", 78);

// Add 5 points to all scores
Map&lt;String, Integer&gt; curved = mapSetter.modify(score -&gt; Math.min(100, score + 5), scores);
// Result: {Alice=90, Bob=95, Charlie=83}

// Reset all scores
Map&lt;String, Integer&gt; reset = mapSetter.set(0, scores);
// Result: {Alice=0, Bob=0, Charlie=0}
</code></pre>
<h3 id="step-5-nested-collection-setters"><a class="header" href="#step-5-nested-collection-setters">Step 5: Nested Collection Setters</a></h3>
<p>Compose Setters for complex nested modifications:</p>
<pre><code class="language-java">Setter&lt;Inventory, List&lt;Product&gt;&gt; productsSetter = Setter.fromGetSet(
    Inventory::products,
    (inv, prods) -&gt; new Inventory(prods, inv.warehouseId()));

Setter&lt;List&lt;Product&gt;, Product&gt; productListSetter = Setter.forList();

Setter&lt;Product, Double&gt; priceSetter = Setter.fromGetSet(
    Product::price,
    (p, price) -&gt; new Product(p.name(), price, p.stock(), p.tags()));

// Compose: Inventory ‚Üí List&lt;Product&gt; ‚Üí Product
Setter&lt;Inventory, Product&gt; allProductsSetter = productsSetter.andThen(productListSetter);

Inventory inventory = new Inventory(
    List.of(
        new Product("Laptop", 999.99, 50, List.of("electronics")),
        new Product("Keyboard", 79.99, 100, List.of("accessories")),
        new Product("Monitor", 299.99, 30, List.of("displays"))),
    "WH-001");

// Apply 10% discount to all products
Inventory discounted = allProductsSetter.modify(
    product -&gt; priceSetter.modify(price -&gt; price * 0.9, product),
    inventory);
// Result: All product prices reduced by 10%

// Restock all products
Setter&lt;Product, Integer&gt; stockSetter = Setter.fromGetSet(
    Product::stock,
    (p, stock) -&gt; new Product(p.name(), p.price(), stock, p.tags()));

Inventory restocked = allProductsSetter.modify(
    product -&gt; stockSetter.modify(stock -&gt; stock + 10, product),
    inventory);
// Result: All product stock increased by 10
</code></pre>
<h3 id="step-6-effectful-modifications"><a class="header" href="#step-6-effectful-modifications">Step 6: Effectful Modifications</a></h3>
<p>Setters support effectful modifications via <code>modifyF</code>, allowing you to compose modifications that might fail or have side effects:</p>
<pre><code class="language-java">Setter&lt;User, String&gt; usernameSetter = Setter.fromGetSet(
    User::username,
    (u, name) -&gt; new User(name, u.email(), u.loginCount(), u.settings()));

// Validation: username must be at least 3 characters and lowercase
Function&lt;String, Kind&lt;OptionalKind.Witness, String&gt;&gt; validateUsername = username -&gt; {
    if (username.length() &gt;= 3 &amp;&amp; username.matches("[a-z_]+")) {
        return OptionalKindHelper.OPTIONAL.widen(Optional.of(username));
    } else {
        return OptionalKindHelper.OPTIONAL.widen(Optional.empty());
    }
};

User validUser = new User("john_doe", "john@example.com", 10, settings);
Kind&lt;OptionalKind.Witness, User&gt; result =
    usernameSetter.modifyF(validateUsername, validUser, OptionalMonad.INSTANCE);

Optional&lt;User&gt; validated = OptionalKindHelper.OPTIONAL.narrow(result);
// Result: Optional[User with validated username]

User invalidUser = new User("ab", "a@test.com", 0, settings); // Too short
Kind&lt;OptionalKind.Witness, User&gt; invalidResult =
    usernameSetter.modifyF(validateUsername, invalidUser, OptionalMonad.INSTANCE);

Optional&lt;User&gt; invalidValidated = OptionalKindHelper.OPTIONAL.narrow(invalidResult);
// Result: Optional.empty (validation failed)
</code></pre>
<h4 id="sequencing-effects-in-collections"><a class="header" href="#sequencing-effects-in-collections">Sequencing Effects in Collections</a></h4>
<pre><code class="language-java">Setter&lt;List&lt;Integer&gt;, Integer&gt; listSetter = Setter.forList();

List&lt;Integer&gt; numbers = List.of(1, 2, 3);

Function&lt;Integer, Kind&lt;OptionalKind.Witness, Integer&gt;&gt; doubleIfPositive = n -&gt; {
    if (n &gt; 0) {
        return OptionalKindHelper.OPTIONAL.widen(Optional.of(n * 2));
    } else {
        return OptionalKindHelper.OPTIONAL.widen(Optional.empty());
    }
};

Kind&lt;OptionalKind.Witness, List&lt;Integer&gt;&gt; result =
    listSetter.modifyF(doubleIfPositive, numbers, OptionalMonad.INSTANCE);

Optional&lt;List&lt;Integer&gt;&gt; doubled = OptionalKindHelper.OPTIONAL.narrow(result);
// Result: Optional[[2, 4, 6]]

// With negative number (will fail)
List&lt;Integer&gt; withNegative = List.of(1, -2, 3);
Kind&lt;OptionalKind.Witness, List&lt;Integer&gt;&gt; failedResult =
    listSetter.modifyF(doubleIfPositive, withNegative, OptionalMonad.INSTANCE);

Optional&lt;List&lt;Integer&gt;&gt; failed = OptionalKindHelper.OPTIONAL.narrow(failedResult);
// Result: Optional.empty (validation failed on -2)
</code></pre>
<h3 id="step-7-converting-to-traversal"><a class="header" href="#step-7-converting-to-traversal">Step 7: Converting to Traversal</a></h3>
<p>Setters can be viewed as Traversals, enabling integration with other optics:</p>
<pre><code class="language-java">Setter&lt;User, String&gt; nameSetter = Setter.fromGetSet(
    User::username,
    (u, name) -&gt; new User(name, u.email(), u.loginCount(), u.settings()));

Traversal&lt;User, String&gt; nameTraversal = nameSetter.asTraversal();

// Now you can use Traversal operations
Function&lt;String, Kind&lt;OptionalKind.Witness, String&gt;&gt; toUpper =
    s -&gt; OptionalKindHelper.OPTIONAL.widen(Optional.of(s.toUpperCase()));

Kind&lt;OptionalKind.Witness, User&gt; result =
    nameTraversal.modifyF(toUpper, user, OptionalMonad.INSTANCE);
</code></pre>
<hr />
<h2 id="built-in-helper-setters"><a class="header" href="#built-in-helper-setters">Built-in Helper Setters</a></h2>
<h3 id="identity-modifies-the-source-itself"><a class="header" href="#identity-modifies-the-source-itself"><strong><code>identity()</code></strong>: Modifies the Source Itself</a></h3>
<pre><code class="language-java">Setter&lt;String, String&gt; identitySetter = Setter.identity();

String result = identitySetter.modify(String::toUpperCase, "hello");
// Result: "HELLO"

String replaced = identitySetter.set("world", "hello");
// Result: "world"
</code></pre>
<p>Useful as a base case in composition or for direct value transformation.</p>
<hr />
<h2 id="when-to-use-setter-vs-other-approaches"><a class="header" href="#when-to-use-setter-vs-other-approaches">When to Use Setter vs Other Approaches</a></h2>
<h3 id="use-setter-when"><a class="header" href="#use-setter-when">Use Setter When:</a></h3>
<ul>
<li>You need <strong>write-only access</strong> without reading</li>
<li>You're building <strong>batch transformation</strong> pipelines</li>
<li>You want <strong>clear modification intent</strong> in your code</li>
<li>You need <strong>effectful modifications</strong> with validation</li>
<li>You're performing <strong>data normalisation</strong> across structures</li>
</ul>
<pre><code class="language-java">// Good: Batch normalisation
Setter&lt;List&lt;String&gt;, String&gt; listSetter = Setter.forList();
List&lt;String&gt; normalised = listSetter.modify(String::trim, rawStrings);

// Good: Composable deep modification
Setter&lt;Company, String&gt; employeeNamesSetter = companySetter
    .andThen(employeesSetter)
    .andThen(personNameSetter);
</code></pre>
<h3 id="use-lens-when-1"><a class="header" href="#use-lens-when-1">Use Lens When:</a></h3>
<ul>
<li>You need <strong>both reading and writing</strong></li>
<li>You want to <strong>get and set</strong> the same field</li>
</ul>
<pre><code class="language-java">// Use Lens when you need to read
Lens&lt;User, String&gt; usernameLens = Lens.of(
    User::username,
    (u, name) -&gt; new User(name, u.email(), u.loginCount(), u.settings()));

String current = usernameLens.get(user); // Read
User updated = usernameLens.set("new_name", user); // Write
</code></pre>
<h3 id="use-traversal-when-1"><a class="header" href="#use-traversal-when-1">Use Traversal When:</a></h3>
<ul>
<li>You need <strong>read operations</strong> (<code>getAll</code>) on collections</li>
<li>You're working with <strong>optional</strong> or multiple focuses</li>
</ul>
<pre><code class="language-java">// Use Traversal when you need to extract values too
Traversal&lt;Order, Product&gt; productTraversal = /* ... */;
List&lt;Product&gt; all = Traversals.getAll(productTraversal, order); // Read
</code></pre>
<h3 id="use-direct-mutation-when"><a class="header" href="#use-direct-mutation-when">Use Direct Mutation When:</a></h3>
<ul>
<li>You're working with <strong>mutable objects</strong> (not recommended in FP)</li>
<li><strong>Performance</strong> is absolutely critical</li>
</ul>
<pre><code class="language-java">// Direct mutation (only for mutable objects)
user.setUsername("new_name"); // Avoid in functional programming
</code></pre>
<hr />
<h2 id="real-world-use-cases-1"><a class="header" href="#real-world-use-cases-1">Real-World Use Cases</a></h2>
<h3 id="data-normalisation-pipeline"><a class="header" href="#data-normalisation-pipeline">Data Normalisation Pipeline</a></h3>
<pre><code class="language-java">Setter&lt;List&lt;Product&gt;, Product&gt; productSetter = Setter.forList();
Setter&lt;Product, String&gt; nameSetter = Setter.fromGetSet(
    Product::name,
    (p, name) -&gt; new Product(name, p.price(), p.stock(), p.tags()));

Function&lt;String, String&gt; normalise = name -&gt; {
    String trimmed = name.trim();
    return trimmed.substring(0, 1).toUpperCase() +
           trimmed.substring(1).toLowerCase();
};

List&lt;Product&gt; rawProducts = List.of(
    new Product("  LAPTOP  ", 999.99, 50, List.of()),
    new Product("keyboard", 79.99, 100, List.of()),
    new Product("MONITOR", 299.99, 30, List.of()));

List&lt;Product&gt; normalised = productSetter.modify(
    product -&gt; nameSetter.modify(normalise, product),
    rawProducts);
// Result: [Product("Laptop", ...), Product("Keyboard", ...), Product("Monitor", ...)]
</code></pre>
<h3 id="currency-conversion"><a class="header" href="#currency-conversion">Currency Conversion</a></h3>
<pre><code class="language-java">Setter&lt;Product, Double&gt; priceSetter = /* ... */;
double exchangeRate = 0.92; // USD to EUR

List&lt;Product&gt; euroProducts = productSetter.modify(
    product -&gt; priceSetter.modify(price -&gt; price * exchangeRate, product),
    usdProducts);
</code></pre>
<h3 id="batch-user-updates"><a class="header" href="#batch-user-updates">Batch User Updates</a></h3>
<pre><code class="language-java">Setter&lt;List&lt;User&gt;, User&gt; usersSetter = Setter.forList();
Setter&lt;User, Integer&gt; loginCountSetter = /* ... */;

// Reset all login counts
List&lt;User&gt; resetUsers = usersSetter.modify(
    user -&gt; loginCountSetter.set(0, user),
    users);

// Increment all login counts
List&lt;User&gt; incremented = usersSetter.modify(
    user -&gt; loginCountSetter.modify(count -&gt; count + 1, user),
    users);
</code></pre>
<h3 id="theme-migration"><a class="header" href="#theme-migration">Theme Migration</a></h3>
<pre><code class="language-java">Setter&lt;User, String&gt; userThemeSetter = settingsSetter.andThen(themeSetter);

// Migrate all users to dark mode
List&lt;User&gt; darkModeUsers = usersSetter.modify(
    user -&gt; userThemeSetter.set("dark", user),
    users);
</code></pre>
<hr />
<h2 id="common-pitfalls-10"><a class="header" href="#common-pitfalls-10">Common Pitfalls</a></h2>
<h3 id="-dont-use-setterof-for-effectful-operations"><a class="header" href="#-dont-use-setterof-for-effectful-operations">‚ùå Don't Use <code>Setter.of()</code> for Effectful Operations</a></h3>
<pre><code class="language-java">// Warning: Setter.of() doesn't support modifyF properly
Setter&lt;Person, String&gt; nameSetter = Setter.of(
    f -&gt; person -&gt; new Person(f.apply(person.name()), person.age()));

// This will throw UnsupportedOperationException!
nameSetter.modifyF(validateFn, person, applicative);
</code></pre>
<h3 id="-use-fromgetset-for-effectful-support"><a class="header" href="#-use-fromgetset-for-effectful-support">‚úÖ Use <code>fromGetSet()</code> for Effectful Support</a></h3>
<pre><code class="language-java">// Correct: fromGetSet supports modifyF
Setter&lt;Person, String&gt; nameSetter = Setter.fromGetSet(
    Person::name,
    (p, name) -&gt; new Person(name, p.age()));

// Works correctly
nameSetter.modifyF(validateFn, person, applicative);
</code></pre>
<h3 id="-dont-forget-immutability"><a class="header" href="#-dont-forget-immutability">‚ùå Don't Forget Immutability</a></h3>
<pre><code class="language-java">// Wrong: Modifying in place (if mutable)
setter.modify(obj -&gt; { obj.setValue(newValue); return obj; }, source);
</code></pre>
<h3 id="-always-return-new-instances"><a class="header" href="#-always-return-new-instances">‚úÖ Always Return New Instances</a></h3>
<pre><code class="language-java">// Correct: Return new immutable instance
Setter&lt;Product, Double&gt; priceSetter = Setter.fromGetSet(
    Product::price,
    (p, price) -&gt; new Product(p.name(), price, p.stock(), p.tags()));
</code></pre>
<hr />
<h2 id="performance-considerations-4"><a class="header" href="#performance-considerations-4">Performance Considerations</a></h2>
<p>Setters are <strong>lightweight and efficient</strong>:</p>
<ul>
<li><strong>Minimal overhead</strong>: Just function composition</li>
<li><strong>No reflection</strong>: Direct method calls</li>
<li><strong>Lazy application</strong>: Modifications only applied when executed</li>
<li><strong>JIT-friendly</strong>: Can be inlined by the JVM</li>
<li><strong>O(n) collection operations</strong>: <code>forList()</code> and <code>forMapValues()</code> are optimised to avoid quadratic time complexity</li>
</ul>
<h3 id="optimised-collection-operations"><a class="header" href="#optimised-collection-operations">Optimised Collection Operations</a></h3>
<p>The <code>modifyF</code> implementations in <code>forList()</code> and <code>forMapValues()</code> use efficient algorithms:</p>
<ul>
<li><strong>Right-to-left folding</strong>: Uses <code>LinkedList</code> with O(1) prepending instead of repeated array copying</li>
<li><strong>Single pass construction</strong>: Collects effects first, sequences them, then builds the final collection once</li>
<li><strong>Linear time complexity</strong>: O(n) for lists and maps with n elements</li>
</ul>
<p>This means you can safely use effectful modifications on large collections without performance concerns:</p>
<pre><code class="language-java">// Efficient even for large lists
Setter&lt;List&lt;Integer&gt;, Integer&gt; listSetter = Setter.forList();
List&lt;Integer&gt; largeList = /* thousands of elements */;

// O(n) time complexity, not O(n¬≤)
Kind&lt;OptionalKind.Witness, List&lt;Integer&gt;&gt; result =
    listSetter.modifyF(validateAndTransform, largeList, OptionalMonad.INSTANCE);
</code></pre>
<p><strong>Best Practice</strong>: Compose Setters at initialisation time, then reuse:</p>
<pre><code class="language-java">// Define once
private static final Setter&lt;Company, Double&gt; ALL_PRODUCT_PRICES =
    companySetter.andThen(productsSetter).andThen(priceSetter);

// Reuse many times
Company discounted = ALL_PRODUCT_PRICES.modify(p -&gt; p * 0.9, company);
Company inflated = ALL_PRODUCT_PRICES.modify(p -&gt; p * 1.05, company);
</code></pre>
<hr />
<h2 id="complete-runnable-example-6"><a class="header" href="#complete-runnable-example-6">Complete, Runnable Example</a></h2>
<pre><code class="language-java">import org.higherkindedj.optics.Setter;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.optional.OptionalKind;
import org.higherkindedj.hkt.optional.OptionalKindHelper;
import org.higherkindedj.hkt.optional.OptionalMonad;
import java.util.*;
import java.util.function.Function;

public class SetterExample {

    public record User(String username, String email, int loginCount, UserSettings settings) {}
    public record UserSettings(String theme, boolean notifications, int fontSize) {}
    public record Product(String name, double price, int stock) {}

    public static void main(String[] args) {
        // === Basic Setters ===
        Setter&lt;User, String&gt; usernameSetter = Setter.fromGetSet(
            User::username,
            (u, name) -&gt; new User(name, u.email(), u.loginCount(), u.settings()));

        Setter&lt;User, Integer&gt; loginCountSetter = Setter.fromGetSet(
            User::loginCount,
            (u, count) -&gt; new User(u.username(), u.email(), count, u.settings()));

        UserSettings settings = new UserSettings("light", true, 14);
        User user = new User("JOHN_DOE", "john@example.com", 10, settings);

        // Normalise username
        User normalised = usernameSetter.modify(String::toLowerCase, user);
        System.out.println("Normalised: " + normalised.username());

        // Increment login count
        User incremented = loginCountSetter.modify(count -&gt; count + 1, user);
        System.out.println("Login count: " + incremented.loginCount());

        // === Composition ===
        Setter&lt;User, UserSettings&gt; settingsSetter = Setter.fromGetSet(
            User::settings,
            (u, s) -&gt; new User(u.username(), u.email(), u.loginCount(), s));

        Setter&lt;UserSettings, String&gt; themeSetter = Setter.fromGetSet(
            UserSettings::theme,
            (s, theme) -&gt; new UserSettings(theme, s.notifications(), s.fontSize()));

        Setter&lt;User, String&gt; userThemeSetter = settingsSetter.andThen(themeSetter);

        User darkMode = userThemeSetter.set("dark", user);
        System.out.println("Theme: " + darkMode.settings().theme());

        // === Collection Setters ===
        Setter&lt;List&lt;Integer&gt;, Integer&gt; listSetter = Setter.forList();

        List&lt;Integer&gt; numbers = List.of(1, 2, 3, 4, 5);
        List&lt;Integer&gt; doubled = listSetter.modify(x -&gt; x * 2, numbers);
        System.out.println("Doubled: " + doubled);

        // === Product Batch Update ===
        Setter&lt;Product, Double&gt; priceSetter = Setter.fromGetSet(
            Product::price,
            (p, price) -&gt; new Product(p.name(), price, p.stock()));

        Setter&lt;List&lt;Product&gt;, Product&gt; productsSetter = Setter.forList();

        List&lt;Product&gt; products = List.of(
            new Product("Laptop", 999.99, 50),
            new Product("Keyboard", 79.99, 100),
            new Product("Monitor", 299.99, 30));

        // Apply 10% discount
        List&lt;Product&gt; discounted = productsSetter.modify(
            product -&gt; priceSetter.modify(price -&gt; price * 0.9, product),
            products);

        System.out.println("Discounted prices:");
        for (Product p : discounted) {
            System.out.printf("  %s: ¬£%.2f%n", p.name(), p.price());
        }

        // === Effectful Modification ===
        Function&lt;String, Kind&lt;OptionalKind.Witness, String&gt;&gt; validateUsername =
            username -&gt; {
                if (username.length() &gt;= 3 &amp;&amp; username.matches("[a-z_]+")) {
                    return OptionalKindHelper.OPTIONAL.widen(Optional.of(username));
                } else {
                    return OptionalKindHelper.OPTIONAL.widen(Optional.empty());
                }
            };

        User validUser = new User("john_doe", "john@example.com", 10, settings);
        Kind&lt;OptionalKind.Witness, User&gt; validResult =
            usernameSetter.modifyF(validateUsername, validUser, OptionalMonad.INSTANCE);

        Optional&lt;User&gt; validated = OptionalKindHelper.OPTIONAL.narrow(validResult);
        System.out.println("Valid username: " + validated.map(User::username).orElse("INVALID"));

        User invalidUser = new User("ab", "a@test.com", 0, settings);
        Kind&lt;OptionalKind.Witness, User&gt; invalidResult =
            usernameSetter.modifyF(validateUsername, invalidUser, OptionalMonad.INSTANCE);

        Optional&lt;User&gt; invalidValidated = OptionalKindHelper.OPTIONAL.narrow(invalidResult);
        System.out.println("Invalid username: " + invalidValidated.map(User::username).orElse("INVALID"));

        // === Data Normalisation ===
        Setter&lt;Product, String&gt; nameSetter = Setter.fromGetSet(
            Product::name,
            (p, name) -&gt; new Product(name, p.price(), p.stock()));

        Function&lt;String, String&gt; titleCase = name -&gt; {
            String trimmed = name.trim();
            return trimmed.substring(0, 1).toUpperCase() + trimmed.substring(1).toLowerCase();
        };

        List&lt;Product&gt; rawProducts = List.of(
            new Product("  LAPTOP  ", 999.99, 50),
            new Product("keyboard", 79.99, 100),
            new Product("MONITOR", 299.99, 30));

        List&lt;Product&gt; normalisedProducts = productsSetter.modify(
            product -&gt; nameSetter.modify(titleCase, product),
            rawProducts);

        System.out.println("Normalised product names:");
        for (Product p : normalisedProducts) {
            System.out.println("  - " + p.name());
        }
    }
}
</code></pre>
<p><strong>Expected Output:</strong></p>
<pre><code>Normalised: john_doe
Login count: 11
Theme: dark
Doubled: [2, 4, 6, 8, 10]
Discounted prices:
  Laptop: ¬£899.99
  Keyboard: ¬£71.99
  Monitor: ¬£269.99
Valid username: john_doe
Invalid username: INVALID
Normalised product names:
  - Laptop
  - Keyboard
  - Monitor
</code></pre>
<hr />
<h2 id="why-setters-are-important"><a class="header" href="#why-setters-are-important">Why Setters Are Important</a></h2>
<p><code>Setter</code> provides a focused, write-only approach to data modification:</p>
<ul>
<li><strong>Clear intent</strong>: Explicitly write-only, preventing accidental reads</li>
<li><strong>Composability</strong>: Chains beautifully for deep, nested modifications</li>
<li><strong>Batch operations</strong>: Natural fit for updating collections</li>
<li><strong>Effectful support</strong>: Integrates with validation and error handling via Applicatives</li>
<li><strong>Type safety</strong>: Compile-time guarantees on modification paths</li>
<li><strong>Immutability-friendly</strong>: Designed for functional, immutable data structures</li>
</ul>
<p>By adding <code>Setter</code> to your optics toolkit alongside <code>Getter</code>, <code>Lens</code>, <code>Prism</code>, <code>Iso</code>, <code>Traversal</code>, and <code>Fold</code>, you gain fine-grained control over both reading and writing patterns. Use <code>Setter</code> when you need composable write-only access, <code>Getter</code> for read-only extraction, and <code>Lens</code> when you need both.</p>
<p>The key insight: <strong>Setters make modifications first-class composable operations</strong>, allowing you to build sophisticated data transformation pipelines with clarity, type safety, and clear functional intent.</p>
<hr />
<p><strong>Previous:</strong> <a href="optics/getters.html">Getters: Composable Read-Only Access</a>
<strong>Next:</strong> <a href="optics/profunctor_optics.html">Profunctor Optics: Advanced Data Transformation</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="at-type-class-a-practical-guide"><a class="header" href="#at-type-class-a-practical-guide">At Type Class: A Practical Guide</a></h1>
<h2 id="indexed-crud-operations-on-collections"><a class="header" href="#indexed-crud-operations-on-collections"><em>Indexed CRUD Operations on Collections</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="optics/at.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to insert, update, and delete entries in indexed structures using optics</li>
<li>Understanding the <code>Lens&lt;S, Optional&lt;A&gt;&gt;</code> pattern for CRUD operations</li>
<li>Factory methods: <code>mapAt()</code>, <code>listAt()</code>, <code>listAtWithPadding()</code></li>
<li>Composing At with Lenses for deep access into nested collections</li>
<li>Using <code>Prisms.some()</code> to unwrap Optional for chained modifications</li>
<li>When to use At vs <code>Traversals.forMap()</code> vs direct Map operations</li>
<li>Handling Java's Optional limitations with null values</li>
<li>Building immutable configuration management systems</li>
</ul>
</div>
</div>
<div id="admonition-example-code" class="admonition admonish-note" role="note" aria-labelledby="admonition-example-code-title">
<div class="admonition-title">
<div id="admonition-example-code-title">
<p>Example Code</p>
</div>
<a class="admonition-anchor-link" href="optics/at.html#admonition-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/AtUsageExample.java">AtUsageExample</a></p>
</div>
</div>
<p>In previous guides, we explored <strong><code>Lens</code></strong> for accessing product fields and <strong><code>Traversal</code></strong> for operating over collections. But what happens when you need to <em>insert</em> a new entry into a map, <em>delete</em> an existing key, or <em>update</em> a specific list index? Standard lenses can't express these operations because they focus on values that already exist.</p>
<p>This is where <strong><code>At</code></strong> fills a crucial gap. It provides a <code>Lens</code> that focuses on the <em>optional presence</em> of a value at a given index‚Äîenabling full CRUD (Create, Read, Update, Delete) operations whilst maintaining immutability and composability.</p>
<hr />
<h2 id="the-scenario-application-configuration-management"><a class="header" href="#the-scenario-application-configuration-management">The Scenario: Application Configuration Management</a></h2>
<p>Consider a configuration management system where settings are stored in nested maps and lists:</p>
<p><strong>The Data Model:</strong></p>
<pre><code class="language-java">public record AppConfig(
    String appName,
    Map&lt;String, String&gt; settings,
    Map&lt;String, Map&lt;String, Integer&gt;&gt; featureFlags,
    List&lt;String&gt; enabledModules
) {}

public record UserPreferences(
    String userId,
    Map&lt;String, String&gt; preferences,
    List&lt;String&gt; favouriteFeatures
) {}

public record SystemState(
    AppConfig config,
    Map&lt;String, UserPreferences&gt; userPrefs,
    Map&lt;String, Integer&gt; metrics
) {}
</code></pre>
<p><strong>Common Operations:</strong></p>
<ul>
<li>"Add a new setting to the configuration"</li>
<li>"Remove an outdated feature flag"</li>
<li>"Update a specific user's preference"</li>
<li>"Check if a metric exists before incrementing it"</li>
<li>"Delete a user's preferences entirely"</li>
</ul>
<p>Traditional optics struggle with these operations. <code>Traversals.forMap(key)</code> can modify existing entries but cannot insert new ones or delete them. Direct map manipulation breaks composability. <strong><code>At</code></strong> solves this elegantly.</p>
<hr />
<h2 id="think-of-at-like"><a class="header" href="#think-of-at-like">Think of At Like...</a></h2>
<ul>
<li><strong>A key to a lockbox</strong> üîë: You can open it (read), put something in (insert), replace the contents (update), or empty it (delete)</li>
<li><strong>An index card in a filing cabinet</strong> üìá: You can retrieve the card, file a new one, update its contents, or remove it entirely</li>
<li><strong>A dictionary entry</strong> üìñ: Looking up a word gives you its definition (if present) or nothing (if absent)</li>
<li><strong>A database row accessor</strong> üóÉÔ∏è: SELECT, INSERT, UPDATE, and DELETE operations on a specific key</li>
<li><strong>A nullable field lens</strong> üéØ: Focusing on presence itself, not just the value</li>
</ul>
<hr />
<h2 id="at-vs-lens-vs-traversal-understanding-the-differences"><a class="header" href="#at-vs-lens-vs-traversal-understanding-the-differences">At vs Lens vs Traversal: Understanding the Differences</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th>At</th><th>Lens</th><th>Traversal</th></tr></thead><tbody>
<tr><td><strong>Focus</strong></td><td>Optional presence at index</td><td>Exactly one value</td><td>Zero or more values</td></tr>
<tr><td><strong>Can insert?</strong></td><td>‚úÖ Yes</td><td>‚ùå No</td><td>‚ùå No</td></tr>
<tr><td><strong>Can delete?</strong></td><td>‚úÖ Yes</td><td>‚ùå No</td><td>‚ùå No</td></tr>
<tr><td><strong>Core operation</strong></td><td><code>Lens&lt;S, Optional&lt;A&gt;&gt;</code></td><td><code>get(s)</code>, <code>set(a, s)</code></td><td><code>modifyF(f, s, app)</code></td></tr>
<tr><td><strong>Returns</strong></td><td><code>Lens</code> to Optional</td><td>Direct value</td><td>Modified structure</td></tr>
<tr><td><strong>Use case</strong></td><td>Map/List CRUD</td><td>Product field access</td><td>Bulk modifications</td></tr>
<tr><td><strong>Intent</strong></td><td>"Manage entry at this index"</td><td>"Access this field"</td><td>"Transform all elements"</td></tr>
</tbody></table>
</div>
<p><strong>Key Insight</strong>: <code>At</code> returns a <code>Lens</code> that focuses on <code>Optional&lt;A&gt;</code>, not <code>A</code> directly. This means setting <code>Optional.empty()</code> <em>removes</em> the entry, whilst setting <code>Optional.of(value)</code> <em>inserts or updates</em> it. This simple abstraction enables powerful CRUD semantics within the optics framework.</p>
<hr />
<h2 id="a-step-by-step-walkthrough-10"><a class="header" href="#a-step-by-step-walkthrough-10">A Step-by-Step Walkthrough</a></h2>
<h3 id="step-1-creating-at-instances"><a class="header" href="#step-1-creating-at-instances">Step 1: Creating At Instances</a></h3>
<p>Unlike <code>Lens</code> which can be generated with annotations, <code>At</code> instances are created using factory methods from <code>AtInstances</code>:</p>
<pre><code class="language-java">import org.higherkindedj.optics.At;
import org.higherkindedj.optics.at.AtInstances;

// At instance for Map&lt;String, Integer&gt;
At&lt;Map&lt;String, Integer&gt;, String, Integer&gt; mapAt = AtInstances.mapAt();

// At instance for List&lt;String&gt;
At&lt;List&lt;String&gt;, Integer, String&gt; listAt = AtInstances.listAt();

// At instance for List with auto-padding
At&lt;List&lt;String&gt;, Integer, String&gt; paddedListAt = AtInstances.listAtWithPadding(null);
</code></pre>
<p>Each factory method returns an <code>At</code> instance parameterised by:</p>
<ul>
<li><code>S</code> ‚Äì The structure type (e.g., <code>Map&lt;String, Integer&gt;</code>)</li>
<li><code>I</code> ‚Äì The index type (e.g., <code>String</code> for maps, <code>Integer</code> for lists)</li>
<li><code>A</code> ‚Äì The element type (e.g., <code>Integer</code>)</li>
</ul>
<h3 id="step-2-basic-crud-operations"><a class="header" href="#step-2-basic-crud-operations">Step 2: Basic CRUD Operations</a></h3>
<p>Once you have an <code>At</code> instance, you can perform full CRUD operations:</p>
<h4 id="create--insert"><a class="header" href="#create--insert"><strong>Create / Insert</strong></a></h4>
<pre><code class="language-java">Map&lt;String, Integer&gt; scores = new HashMap&lt;&gt;();
scores.put("alice", 100);

At&lt;Map&lt;String, Integer&gt;, String, Integer&gt; mapAt = AtInstances.mapAt();

// Insert a new entry
Map&lt;String, Integer&gt; withBob = mapAt.insertOrUpdate("bob", 85, scores);
// Result: {alice=100, bob=85}

// Original unchanged (immutability)
System.out.println(scores); // {alice=100}
</code></pre>
<h4 id="read--query"><a class="header" href="#read--query"><strong>Read / Query</strong></a></h4>
<pre><code class="language-java">Optional&lt;Integer&gt; aliceScore = mapAt.get("alice", withBob);
// Result: Optional[100]

Optional&lt;Integer&gt; charlieScore = mapAt.get("charlie", withBob);
// Result: Optional.empty()

boolean hasAlice = mapAt.contains("alice", withBob);
// Result: true
</code></pre>
<h4 id="update--modify"><a class="header" href="#update--modify"><strong>Update / Modify</strong></a></h4>
<pre><code class="language-java">// Update existing value
Map&lt;String, Integer&gt; updatedScores = mapAt.insertOrUpdate("alice", 110, withBob);
// Result: {alice=110, bob=85}

// Modify with function
Map&lt;String, Integer&gt; bonusScores = mapAt.modify("bob", x -&gt; x + 10, updatedScores);
// Result: {alice=110, bob=95}

// Modify non-existent key is a no-op
Map&lt;String, Integer&gt; unchanged = mapAt.modify("charlie", x -&gt; x + 10, bonusScores);
// Result: {alice=110, bob=95} (no charlie key)
</code></pre>
<h4 id="delete--remove"><a class="header" href="#delete--remove"><strong>Delete / Remove</strong></a></h4>
<pre><code class="language-java">Map&lt;String, Integer&gt; afterRemove = mapAt.remove("alice", bonusScores);
// Result: {bob=95}

// Remove non-existent key is a no-op
Map&lt;String, Integer&gt; stillSame = mapAt.remove("charlie", afterRemove);
// Result: {bob=95}
</code></pre>
<h3 id="step-3-the-lens-to-optional-pattern"><a class="header" href="#step-3-the-lens-to-optional-pattern">Step 3: The Lens to Optional Pattern</a></h3>
<p>The core of <code>At</code> is its <code>at(index)</code> method, which returns a <code>Lens&lt;S, Optional&lt;A&gt;&gt;</code>:</p>
<pre><code class="language-java">At&lt;Map&lt;String, Integer&gt;, String, Integer&gt; mapAt = AtInstances.mapAt();
Lens&lt;Map&lt;String, Integer&gt;, Optional&lt;Integer&gt;&gt; aliceLens = mapAt.at("alice");

Map&lt;String, Integer&gt; scores = new HashMap&lt;&gt;(Map.of("alice", 100));

// Get: Returns Optional
Optional&lt;Integer&gt; score = aliceLens.get(scores);
// Result: Optional[100]

// Set with Optional.of(): Insert or update
Map&lt;String, Integer&gt; updated = aliceLens.set(Optional.of(150), scores);
// Result: {alice=150}

// Set with Optional.empty(): Delete
Map&lt;String, Integer&gt; deleted = aliceLens.set(Optional.empty(), scores);
// Result: {}
</code></pre>
<p>This pattern is powerful because the lens composes naturally with other optics:</p>
<pre><code class="language-java">record Config(Map&lt;String, String&gt; settings) {}

Lens&lt;Config, Map&lt;String, String&gt;&gt; settingsLens =
    Lens.of(Config::settings, (c, s) -&gt; new Config(s));

At&lt;Map&lt;String, String&gt;, String, String&gt; mapAt = AtInstances.mapAt();

// Compose: Config ‚Üí Map&lt;String, String&gt; ‚Üí Optional&lt;String&gt;
Lens&lt;Config, Optional&lt;String&gt;&gt; debugSettingLens =
    settingsLens.andThen(mapAt.at("debug"));

Config config = new Config(new HashMap&lt;&gt;());

// Insert new setting through composed lens
Config withDebug = debugSettingLens.set(Optional.of("true"), config);
// Result: Config[settings={debug=true}]

// Delete setting through composed lens
Config withoutDebug = debugSettingLens.set(Optional.empty(), withDebug);
// Result: Config[settings={}]
</code></pre>
<h3 id="step-4-deep-composition-with-prisms"><a class="header" href="#step-4-deep-composition-with-prisms">Step 4: Deep Composition with Prisms</a></h3>
<p>When you need to access the actual value (not the <code>Optional</code> wrapper), compose with <code>Prisms.some()</code>:</p>
<pre><code class="language-java">import org.higherkindedj.optics.prism.Prisms;

Lens&lt;Config, Optional&lt;String&gt;&gt; debugLens =
    settingsLens.andThen(mapAt.at("debug"));

// Prism that unwraps Optional
Prism&lt;Optional&lt;String&gt;, String&gt; somePrism = Prisms.some();

// Compose into a Traversal (0-or-1 focus)
Traversal&lt;Config, String&gt; debugValueTraversal =
    debugLens.asTraversal().andThen(somePrism.asTraversal());

Config config = new Config(new HashMap&lt;&gt;(Map.of("debug", "false")));

// Modify the actual string value
Config modified = Traversals.modify(debugValueTraversal, String::toUpperCase, config);
// Result: Config[settings={debug=FALSE}]

// Get all focused values (0 or 1)
List&lt;String&gt; values = Traversals.getAll(debugValueTraversal, config);
// Result: ["FALSE"]

// If key is absent, traversal focuses on zero elements
Config empty = new Config(new HashMap&lt;&gt;());
List&lt;String&gt; noValues = Traversals.getAll(debugValueTraversal, empty);
// Result: []
</code></pre>
<p>This composition creates an "affine" optic‚Äîfocusing on zero or one element‚Äîwhich correctly models the semantics of optional map access.</p>
<hr />
<h2 id="list-operations-special-considerations"><a class="header" href="#list-operations-special-considerations">List Operations: Special Considerations</a></h2>
<p><code>At</code> for lists has important behavioural differences from maps:</p>
<h3 id="basic-list-operations"><a class="header" href="#basic-list-operations">Basic List Operations</a></h3>
<pre><code class="language-java">At&lt;List&lt;String&gt;, Integer, String&gt; listAt = AtInstances.listAt();

List&lt;String&gt; items = new ArrayList&lt;&gt;(List.of("apple", "banana", "cherry"));

// Read element at index
Optional&lt;String&gt; second = listAt.get(1, items);
// Result: Optional["banana"]

// Out of bounds returns empty
Optional&lt;String&gt; outOfBounds = listAt.get(10, items);
// Result: Optional.empty()

// Update element at valid index
List&lt;String&gt; updated = listAt.insertOrUpdate(1, "BANANA", items);
// Result: ["apple", "BANANA", "cherry"]
</code></pre>
<h3 id="deletion-shifts-indices"><a class="header" href="#deletion-shifts-indices">Deletion Shifts Indices</a></h3>
<p><strong>Important</strong>: Removing a list element shifts all subsequent indices:</p>
<pre><code class="language-java">List&lt;String&gt; afterRemove = listAt.remove(1, items);
// Result: ["apple", "cherry"]
// Note: "cherry" is now at index 1, not 2!

// Original list unchanged
System.out.println(items); // ["apple", "banana", "cherry"]
</code></pre>
<p>This behaviour differs from map deletion, where keys remain stable. Consider this carefully when chaining operations.</p>
<h3 id="bounds-checking"><a class="header" href="#bounds-checking">Bounds Checking</a></h3>
<pre><code class="language-java">// Update at invalid index throws exception
assertThrows(IndexOutOfBoundsException.class, () -&gt;
    listAt.insertOrUpdate(10, "oops", items));

// Use listAtWithPadding for auto-expansion
At&lt;List&lt;String&gt;, Integer, String&gt; paddedAt = AtInstances.listAtWithPadding(null);

List&lt;String&gt; sparse = new ArrayList&lt;&gt;(List.of("a"));
List&lt;String&gt; expanded = paddedAt.insertOrUpdate(4, "e", sparse);
// Result: ["a", null, null, null, "e"]
</code></pre>
<hr />
<h2 id="when-to-use-at-vs-other-approaches"><a class="header" href="#when-to-use-at-vs-other-approaches">When to Use At vs Other Approaches</a></h2>
<h3 id="-use-at-when"><a class="header" href="#-use-at-when">‚úÖ Use <code>At</code> When:</a></h3>
<ul>
<li><strong>You need CRUD semantics</strong>: Insert, update, or delete operations on indexed structures</li>
<li><strong>Composability matters</strong>: You want to chain At with Lenses for deep nested access</li>
<li><strong>Immutability is required</strong>: You need functional, side-effect-free operations</li>
<li><strong>You're building configuration systems</strong>: Dynamic settings management</li>
<li><strong>You want consistent optics patterns</strong>: Keeping your codebase uniformly functional</li>
</ul>
<h3 id="-avoid-at-when"><a class="header" href="#-avoid-at-when">‚ùå Avoid <code>At</code> When:</a></h3>
<ul>
<li><strong>You only modify existing values</strong>: Use <code>Traversals.forMap(key)</code> instead</li>
<li><strong>You need bulk operations</strong>: Use <code>Traversal</code> for all-element modifications</li>
<li><strong>Performance is critical</strong>: Direct Map operations may be faster (measure first!)</li>
<li><strong>You never delete entries</strong>: A simple Lens might suffice</li>
</ul>
<h3 id="comparison-with-direct-map-operations"><a class="header" href="#comparison-with-direct-map-operations">Comparison with Direct Map Operations</a></h3>
<pre><code class="language-java">// Direct Map manipulation (imperative)
Map&lt;String, Integer&gt; scores = new HashMap&lt;&gt;();
scores.put("alice", 100);           // Mutates!
scores.remove("bob");                // Mutates!
Integer value = scores.get("alice"); // May be null

// At approach (functional)
At&lt;Map&lt;String, Integer&gt;, String, Integer&gt; at = AtInstances.mapAt();
Map&lt;String, Integer&gt; scores = new HashMap&lt;&gt;();
Map&lt;String, Integer&gt; with = at.insertOrUpdate("alice", 100, scores);  // New map
Map&lt;String, Integer&gt; without = at.remove("bob", with);                  // New map
Optional&lt;Integer&gt; value = at.get("alice", without);                     // Safe Optional
// Original 'scores' unchanged throughout
</code></pre>
<hr />
<h2 id="common-pitfalls-11"><a class="header" href="#common-pitfalls-11">Common Pitfalls</a></h2>
<h3 id="-dont-assume-null-map-values-are-distinguishable-from-absent-keys"><a class="header" href="#-dont-assume-null-map-values-are-distinguishable-from-absent-keys">‚ùå Don't: Assume null map values are distinguishable from absent keys</a></h3>
<pre><code class="language-java">Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
map.put("nullKey", null);

At&lt;Map&lt;String, Integer&gt;, String, Integer&gt; at = AtInstances.mapAt();
Optional&lt;Integer&gt; result = at.get("nullKey", map);
// Result: Optional.empty() - NOT Optional.of(null)!

// Java's Optional cannot hold null values
// Optional.ofNullable(null) returns Optional.empty()
</code></pre>
<h3 id="-do-avoid-null-values-in-maps-or-use-wrapper-types"><a class="header" href="#-do-avoid-null-values-in-maps-or-use-wrapper-types">‚úÖ Do: Avoid null values in maps, or use wrapper types</a></h3>
<pre><code class="language-java">// Option 1: Use sentinel values
Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
map.put("unset", -1); // Sentinel for "not set"

// Option 2: Use Optional as the value type
Map&lt;String, Optional&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;();
map.put("maybeNull", Optional.empty()); // Explicitly absent
</code></pre>
<hr />
<h3 id="-dont-forget-that-list-removal-shifts-indices"><a class="header" href="#-dont-forget-that-list-removal-shifts-indices">‚ùå Don't: Forget that list removal shifts indices</a></h3>
<pre><code class="language-java">At&lt;List&lt;String&gt;, Integer, String&gt; at = AtInstances.listAt();
List&lt;String&gt; items = new ArrayList&lt;&gt;(List.of("a", "b", "c", "d"));

// Remove "b" at index 1
List&lt;String&gt; step1 = at.remove(1, items); // ["a", "c", "d"]

// Now try to get what was at index 3 ("d")
Optional&lt;String&gt; result = at.get(3, step1);
// Result: Optional.empty() - index 3 is now out of bounds!
// "d" is now at index 2
</code></pre>
<h3 id="-do-recalculate-indices-or-iterate-from-end"><a class="header" href="#-do-recalculate-indices-or-iterate-from-end">‚úÖ Do: Recalculate indices or iterate from end</a></h3>
<pre><code class="language-java">// When removing multiple elements, iterate backwards
List&lt;String&gt; items = new ArrayList&lt;&gt;(List.of("a", "b", "c", "d"));
List&lt;Integer&gt; indicesToRemove = List.of(1, 3); // Remove "b" and "d"

// Sort descending and remove from end
List&lt;String&gt; result = items;
for (int i : indicesToRemove.stream().sorted(Comparator.reverseOrder()).toList()) {
    result = at.remove(i, result);
}
// Result: ["a", "c"]
</code></pre>
<hr />
<h3 id="-dont-ignore-optional-composition-when-you-need-the-actual-value"><a class="header" href="#-dont-ignore-optional-composition-when-you-need-the-actual-value">‚ùå Don't: Ignore Optional composition when you need the actual value</a></h3>
<pre><code class="language-java">Lens&lt;Config, Optional&lt;String&gt;&gt; settingLens = ...;

// This gives you Optional, not the actual value
Optional&lt;String&gt; optValue = settingLens.get(config);

// To modify the actual string, you need to compose with a Prism
// Otherwise you're stuck wrapping/unwrapping manually
</code></pre>
<h3 id="-do-use-prismssome-for-value-level-operations"><a class="header" href="#-do-use-prismssome-for-value-level-operations">‚úÖ Do: Use <code>Prisms.some()</code> for value-level operations</a></h3>
<pre><code class="language-java">Prism&lt;Optional&lt;String&gt;, String&gt; some = Prisms.some();
Traversal&lt;Config, String&gt; valueTraversal =
    settingLens.asTraversal().andThen(some.asTraversal());

// Now you can work with the actual String
Config result = Traversals.modify(valueTraversal, String::trim, config);
</code></pre>
<hr />
<h2 id="performance-considerations-5"><a class="header" href="#performance-considerations-5">Performance Considerations</a></h2>
<h3 id="hashmap-operations"><a class="header" href="#hashmap-operations">HashMap Operations</a></h3>
<p><code>mapAt()</code> creates a new <code>HashMap</code> on every modification:</p>
<pre><code class="language-java">// Each operation copies the entire map
Map&lt;String, Integer&gt; step1 = at.insertOrUpdate("a", 1, map);   // O(n) copy
Map&lt;String, Integer&gt; step2 = at.insertOrUpdate("b", 2, step1); // O(n) copy
Map&lt;String, Integer&gt; step3 = at.remove("c", step2);            // O(n) copy
</code></pre>
<p><strong>Best Practice</strong>: Batch modifications when possible:</p>
<pre><code class="language-java">// ‚ùå Multiple At operations (3 map copies)
Map&lt;String, Integer&gt; result = at.insertOrUpdate("a", 1,
    at.insertOrUpdate("b", 2,
        at.remove("c", original)));

// ‚úÖ Single bulk operation
Map&lt;String, Integer&gt; result = new HashMap&lt;&gt;(original);
result.put("a", 1);
result.put("b", 2);
result.remove("c");
// Then use At for subsequent immutable operations
</code></pre>
<h3 id="list-operations"><a class="header" href="#list-operations">List Operations</a></h3>
<p>List modifications involve array copying:</p>
<pre><code class="language-java">At&lt;List&lt;String&gt;, Integer, String&gt; at = AtInstances.listAt();

// Update is O(n) - copies entire list
List&lt;String&gt; updated = at.insertOrUpdate(0, "new", original);

// Remove is O(n) - copies and shifts
List&lt;String&gt; removed = at.remove(0, original);
</code></pre>
<p>For large lists with frequent modifications, consider alternative data structures (persistent collections, tree-based structures) or batch operations.</p>
<hr />
<h2 id="real-world-example-feature-flag-management"><a class="header" href="#real-world-example-feature-flag-management">Real-World Example: Feature Flag Management</a></h2>
<p>Consider a feature flag system where different environments have different configurations:</p>
<pre><code class="language-java">public class FeatureFlagManager {

    private final At&lt;Map&lt;String, Boolean&gt;, String, Boolean&gt; flagAt = AtInstances.mapAt();
    private Map&lt;String, Boolean&gt; flags;

    public FeatureFlagManager(Map&lt;String, Boolean&gt; initialFlags) {
        this.flags = new HashMap&lt;&gt;(initialFlags);
    }

    public void enableFeature(String featureName) {
        flags = flagAt.insertOrUpdate(featureName, true, flags);
    }

    public void disableFeature(String featureName) {
        flags = flagAt.insertOrUpdate(featureName, false, flags);
    }

    public void removeFeature(String featureName) {
        flags = flagAt.remove(featureName, flags);
    }

    public boolean isEnabled(String featureName) {
        return flagAt.get(featureName, flags).orElse(false);
    }

    public Map&lt;String, Boolean&gt; getFlags() {
        return Collections.unmodifiableMap(flags);
    }
}

// Usage
var manager = new FeatureFlagManager(Map.of("dark_mode", true));
manager.enableFeature("new_dashboard");
manager.disableFeature("legacy_api");
manager.removeFeature("deprecated_feature");

System.out.println(manager.isEnabled("dark_mode"));        // true
System.out.println(manager.isEnabled("new_dashboard"));    // true
System.out.println(manager.isEnabled("nonexistent"));      // false
</code></pre>
<p>This pattern ensures all flag operations maintain immutability internally whilst providing a clean mutable-style API externally.</p>
<hr />
<h2 id="complete-runnable-example-7"><a class="header" href="#complete-runnable-example-7">Complete, Runnable Example</a></h2>
<p>Here's a comprehensive example demonstrating all major At features:</p>
<pre><code class="language-java">package org.higherkindedj.example.optics;

import java.util.*;
import org.higherkindedj.optics.At;
import org.higherkindedj.optics.Lens;
import org.higherkindedj.optics.Prism;
import org.higherkindedj.optics.Traversal;
import org.higherkindedj.optics.annotations.GenerateLenses;
import org.higherkindedj.optics.at.AtInstances;
import org.higherkindedj.optics.prism.Prisms;
import org.higherkindedj.optics.util.Traversals;

public class AtUsageExample {

    @GenerateLenses
    public record UserProfile(
        String username,
        Map&lt;String, String&gt; settings,
        Map&lt;String, Integer&gt; scores,
        List&lt;String&gt; tags
    ) {}

    public static void main(String[] args) {
        System.out.println("=== At Type Class Usage Examples ===\n");

        // 1. Map CRUD Operations
        System.out.println("--- Map CRUD Operations ---");

        At&lt;Map&lt;String, Integer&gt;, String, Integer&gt; mapAt = AtInstances.mapAt();
        Map&lt;String, Integer&gt; scores = new HashMap&lt;&gt;(Map.of("maths", 95, "english", 88));

        System.out.println("Initial scores: " + scores);

        // Insert
        Map&lt;String, Integer&gt; withScience = mapAt.insertOrUpdate("science", 92, scores);
        System.out.println("After insert 'science': " + withScience);

        // Update
        Map&lt;String, Integer&gt; updatedMaths = mapAt.insertOrUpdate("maths", 98, withScience);
        System.out.println("After update 'maths': " + updatedMaths);

        // Read
        System.out.println("Physics score (absent): " + mapAt.get("physics", updatedMaths));
        System.out.println("Maths score (present): " + mapAt.get("maths", updatedMaths));

        // Delete
        Map&lt;String, Integer&gt; afterRemove = mapAt.remove("english", updatedMaths);
        System.out.println("After remove 'english': " + afterRemove);

        // Modify
        Map&lt;String, Integer&gt; bonusMaths = mapAt.modify("maths", x -&gt; x + 5, afterRemove);
        System.out.println("After modify 'maths' (+5): " + bonusMaths);

        System.out.println("Original unchanged: " + scores);
        System.out.println();

        // 2. Lens Composition
        System.out.println("--- Lens Composition with At ---");

        // Use generated lenses from @GenerateLenses annotation
        Lens&lt;UserProfile, Map&lt;String, String&gt;&gt; settingsLens = UserProfileLenses.settings();

        At&lt;Map&lt;String, String&gt;, String, String&gt; stringMapAt = AtInstances.mapAt();

        UserProfile profile = new UserProfile(
            "alice",
            new HashMap&lt;&gt;(Map.of("theme", "dark", "language", "en")),
            new HashMap&lt;&gt;(Map.of("maths", 95)),
            new ArrayList&lt;&gt;(List.of("developer"))
        );

        System.out.println("Initial profile: " + profile);

        // Compose: UserProfile ‚Üí Map ‚Üí Optional&lt;String&gt;
        Lens&lt;UserProfile, Optional&lt;String&gt;&gt; themeLens =
            settingsLens.andThen(stringMapAt.at("theme"));

        System.out.println("Current theme: " + themeLens.get(profile));

        // Update through composed lens
        UserProfile lightTheme = themeLens.set(Optional.of("light"), profile);
        System.out.println("After setting theme: " + lightTheme.settings());

        // Add new setting
        Lens&lt;UserProfile, Optional&lt;String&gt;&gt; notifLens =
            settingsLens.andThen(stringMapAt.at("notifications"));
        UserProfile withNotif = notifLens.set(Optional.of("enabled"), lightTheme);
        System.out.println("After adding notification: " + withNotif.settings());

        // Remove setting
        Lens&lt;UserProfile, Optional&lt;String&gt;&gt; langLens =
            settingsLens.andThen(stringMapAt.at("language"));
        UserProfile noLang = langLens.set(Optional.empty(), withNotif);
        System.out.println("After removing language: " + noLang.settings());
        System.out.println();

        // 3. Deep Composition with Prism
        System.out.println("--- Deep Composition: At + Prism ---");

        Lens&lt;UserProfile, Map&lt;String, Integer&gt;&gt; scoresLens = UserProfileLenses.scores();

        At&lt;Map&lt;String, Integer&gt;, String, Integer&gt; scoresAt = AtInstances.mapAt();
        Prism&lt;Optional&lt;Integer&gt;, Integer&gt; somePrism = Prisms.some();

        // Compose into Traversal (0-or-1 focus)
        Lens&lt;UserProfile, Optional&lt;Integer&gt;&gt; mathsLens = scoresLens.andThen(scoresAt.at("maths"));
        Traversal&lt;UserProfile, Integer&gt; mathsTraversal =
            mathsLens.asTraversal().andThen(somePrism.asTraversal());

        UserProfile bob = new UserProfile(
            "bob",
            new HashMap&lt;&gt;(),
            new HashMap&lt;&gt;(Map.of("maths", 85, "science", 90)),
            new ArrayList&lt;&gt;()
        );

        System.out.println("Bob's profile: " + bob);

        // Get via traversal
        List&lt;Integer&gt; mathsScores = Traversals.getAll(mathsTraversal, bob);
        System.out.println("Maths score via traversal: " + mathsScores);

        // Modify via traversal
        UserProfile boostedBob = Traversals.modify(mathsTraversal, x -&gt; x + 10, bob);
        System.out.println("After boosting maths by 10: " + boostedBob.scores());

        // Missing key = empty traversal
        Traversal&lt;UserProfile, Integer&gt; historyTraversal =
            scoresLens.andThen(scoresAt.at("history"))
                      .asTraversal().andThen(somePrism.asTraversal());

        List&lt;Integer&gt; historyScores = Traversals.getAll(historyTraversal, bob);
        System.out.println("History score (absent): " + historyScores);

        System.out.println("\n=== All operations maintain immutability ===");
    }
}
</code></pre>
<p><strong>Expected Output:</strong></p>
<pre><code>=== At Type Class Usage Examples ===

--- Map CRUD Operations ---
Initial scores: {maths=95, english=88}
After insert 'science': {maths=95, science=92, english=88}
After update 'maths': {maths=98, science=92, english=88}
Physics score (absent): Optional.empty
Maths score (present): Optional[98]
After remove 'english': {maths=98, science=92}
After modify 'maths' (+5): {maths=103, science=92}
Original unchanged: {maths=95, english=88}

--- Lens Composition with At ---
Initial profile: UserProfile[username=alice, settings={theme=dark, language=en}, scores={maths=95}, tags=[developer]]
Current theme: Optional[dark]
After setting theme: {theme=light, language=en}
After adding notification: {theme=light, language=en, notifications=enabled}
After removing language: {theme=light, notifications=enabled}

--- Deep Composition: At + Prism ---
Bob's profile: UserProfile[username=bob, settings={}, scores={maths=85, science=90}, tags=[]]
Maths score via traversal: [85]
After boosting maths by 10: {maths=95, science=90}
History score (absent): []

=== All operations maintain immutability ===
</code></pre>
<hr />
<h2 id="further-reading-9"><a class="header" href="#further-reading-9">Further Reading</a></h2>
<ul>
<li><a href="https://hackage.haskell.org/package/lens/docs/Control-Lens-At.html">Haskell Lens Library - At Type Class</a></li>
<li><a href="https://leanpub.com/optics-by-example">Optics By Example</a> - Comprehensive optics guide</li>
<li><a href="optics/lenses.html">Lenses Guide</a> - Foundation for At composition</li>
<li><a href="optics/prisms.html">Prisms Guide</a> - Unwrapping Optional with Prisms</li>
<li><a href="optics/traversals.html">Traversals Guide</a> - Bulk operations on collections</li>
</ul>
<hr />
<h2 id="summary-4"><a class="header" href="#summary-4">Summary</a></h2>
<p>The <strong>At</strong> type class provides a powerful abstraction for indexed CRUD operations on collections:</p>
<ul>
<li><strong>Lens to Optional</strong>: <code>at(index)</code> returns <code>Lens&lt;S, Optional&lt;A&gt;&gt;</code> enabling insert/update/delete</li>
<li><strong>Immutable by design</strong>: All operations return new structures</li>
<li><strong>Composable</strong>: Chains naturally with other optics for deep access</li>
<li><strong>Type-safe</strong>: Leverages Java's type system for safety</li>
</ul>
<p>At bridges the gap between pure functional optics and practical collection manipulation, enabling you to build robust, immutable data pipelines that handle the full lifecycle of indexed data.</p>
<p><strong>Related</strong>: For read/update-only operations without insert/delete semantics, see the <a href="optics/ixed.html">Ixed Type Class</a> guide, which provides safe partial access via <code>Traversal&lt;S, A&gt;</code>.</p>
<hr />
<p><a href="optics/setters.html">Previous: Setters</a> | <a href="optics/ixed.html">Next: Ixed Type Class</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="ixed-type-class-safe-indexed-access"><a class="header" href="#ixed-type-class-safe-indexed-access">Ixed Type Class: Safe Indexed Access</a></h1>
<h2 id="zero-or-one-element-traversals"><a class="header" href="#zero-or-one-element-traversals"><em>Zero-or-One Element Traversals</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="optics/ixed.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to safely access and update existing elements in indexed structures</li>
<li>Understanding the <code>Traversal&lt;S, A&gt;</code> pattern for partial access</li>
<li>Factory methods: <code>mapIx()</code>, <code>listIx()</code>, <code>fromAt()</code></li>
<li>The key difference between Ixed (read/update only) and At (full CRUD)</li>
<li>Composing Ixed with Lenses for safe deep access into nested collections</li>
<li>How Ixed is built on At internally using <code>Prisms.some()</code></li>
<li>When to use Ixed vs At vs direct collection operations</li>
<li>Building safe, structure-preserving data pipelines</li>
</ul>
</div>
</div>
<div id="admonition-example-code" class="admonition admonish-note" role="note" aria-labelledby="admonition-example-code-title">
<div class="admonition-title">
<div id="admonition-example-code-title">
<p>Example Code</p>
</div>
<a class="admonition-anchor-link" href="optics/ixed.html#admonition-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/IxedUsageExample.java">IxedUsageExample</a></p>
</div>
</div>
<p>In the previous guide on <a href="optics/at.html">At</a>, we explored how to perform full CRUD operations on indexed structures‚Äîinserting new entries, deleting existing ones, and updating values. But what if you only need to <em>read</em> and <em>update</em> elements that already exist, without the ability to insert or delete? What if you want operations that automatically become no-ops when an index is absent, preserving the structure unchanged?</p>
<p>This is where <strong><code>Ixed</code></strong> shines. It provides a <code>Traversal</code> that focuses on zero or one element at a given index‚Äîperfect for safe, partial access patterns where you want to modify existing data without changing the structure's shape.</p>
<hr />
<h2 id="the-scenario-safe-configuration-reading"><a class="header" href="#the-scenario-safe-configuration-reading">The Scenario: Safe Configuration Reading</a></h2>
<p>Consider a configuration system where you need to read and update existing settings, but deliberately want to avoid accidentally creating new entries:</p>
<p><strong>The Data Model:</strong></p>
<pre><code class="language-java">public record ServerConfig(
    String serverName,
    Map&lt;String, String&gt; environment,
    Map&lt;String, Integer&gt; ports,
    List&lt;String&gt; allowedHosts
) {}

public record DatabaseConfig(
    String connectionString,
    Map&lt;String, String&gt; poolSettings,
    List&lt;String&gt; replicaHosts
) {}

public record ApplicationSettings(
    ServerConfig server,
    DatabaseConfig database,
    Map&lt;String, String&gt; featureToggles
) {}
</code></pre>
<p><strong>Common Operations:</strong></p>
<ul>
<li>"Read the current database pool size setting"</li>
<li>"Update the max connections if it exists"</li>
<li>"Modify the port number for an existing service"</li>
<li>"Safely access the nth replica host if it exists"</li>
<li>"Never accidentally create new configuration keys"</li>
</ul>
<p>The key requirement here is <strong>safety</strong>: you want to interact with existing data without risk of accidentally expanding the structure. If a key doesn't exist, the operation should simply do nothing rather than insert a new entry.</p>
<hr />
<h2 id="think-of-ixed-like"><a class="header" href="#think-of-ixed-like">Think of Ixed Like...</a></h2>
<ul>
<li><strong>A read-only database view with UPDATE privileges</strong> üîç: You can SELECT and UPDATE existing rows, but cannot INSERT new ones or DELETE existing ones</li>
<li><strong>A safe array accessor</strong> üõ°Ô∏è: Returns nothing for out-of-bounds indices instead of throwing exceptions</li>
<li><strong>A peephole in a door</strong> üëÅÔ∏è: You can see what's there and modify it if present, but you can't add or remove anything</li>
<li><strong>A library card catalogue lookup</strong> üìö: You can find and update existing book entries, but adding new books requires different permissions</li>
<li><strong>A partial function</strong> üéØ: Operates only where defined, silently ignores undefined inputs</li>
</ul>
<hr />
<h2 id="ixed-vs-at-vs-traversal-vs-prism-understanding-the-relationships"><a class="header" href="#ixed-vs-at-vs-traversal-vs-prism-understanding-the-relationships">Ixed vs At vs Traversal vs Prism: Understanding the Relationships</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th>Ixed</th><th>At</th><th>Traversal</th><th>Prism</th></tr></thead><tbody>
<tr><td><strong>Focus</strong></td><td>Zero or one element at index</td><td>Optional presence at index</td><td>Zero or more elements</td><td>Zero or one variant case</td></tr>
<tr><td><strong>Can insert?</strong></td><td>‚ùå No</td><td>‚úÖ Yes</td><td>‚ùå No</td><td>‚úÖ Yes (via <code>build</code>)</td></tr>
<tr><td><strong>Can delete?</strong></td><td>‚ùå No</td><td>‚úÖ Yes</td><td>‚ùå No</td><td>‚ùå No</td></tr>
<tr><td><strong>Core operation</strong></td><td><code>Traversal&lt;S, A&gt;</code></td><td><code>Lens&lt;S, Optional&lt;A&gt;&gt;</code></td><td><code>modifyF(f, s, app)</code></td><td><code>getOptional</code>, <code>build</code></td></tr>
<tr><td><strong>Returns</strong></td><td>Traversal (0-or-1 focus)</td><td>Lens to Optional</td><td>Modified structure</td><td>Optional value</td></tr>
<tr><td><strong>Use case</strong></td><td>Safe partial access</td><td>Map/List CRUD</td><td>Bulk modifications</td><td>Sum type handling</td></tr>
<tr><td><strong>Intent</strong></td><td>"Access if exists"</td><td>"Manage entry at index"</td><td>"Transform all elements"</td><td>"Match this case"</td></tr>
<tr><td><strong>Structure change</strong></td><td>‚ùå Never changes</td><td>‚úÖ Can change size</td><td>‚ùå Preserves count</td><td>‚úÖ Can change type</td></tr>
</tbody></table>
</div>
<p><strong>Key Insight</strong>: <code>Ixed</code> is actually built <em>on top of</em> <code>At</code>. Internally, it composes <code>At.at(index)</code> with <code>Prisms.some()</code> to unwrap the Optional layer. This means <code>Ixed</code> inherits the precise boundary behaviour of <code>At</code> whilst removing the ability to insert or delete entries.</p>
<pre><code class="language-java">// Ixed is conceptually:
// at.at(index).asTraversal().andThen(Prisms.some().asTraversal())

// At gives:     Lens&lt;S, Optional&lt;A&gt;&gt;
// Prisms.some() gives: Prism&lt;Optional&lt;A&gt;, A&gt;
// Composed:     Traversal&lt;S, A&gt; focusing on 0-or-1 elements
</code></pre>
<hr />
<h2 id="a-step-by-step-walkthrough-11"><a class="header" href="#a-step-by-step-walkthrough-11">A Step-by-Step Walkthrough</a></h2>
<h3 id="step-1-creating-ixed-instances"><a class="header" href="#step-1-creating-ixed-instances">Step 1: Creating Ixed Instances</a></h3>
<p>Like <code>At</code>, <code>Ixed</code> instances are created using factory methods from <code>IxedInstances</code>:</p>
<pre><code class="language-java">import org.higherkindedj.optics.Ixed;
import org.higherkindedj.optics.ixed.IxedInstances;

// Ixed instance for Map&lt;String, Integer&gt;
Ixed&lt;Map&lt;String, Integer&gt;, String, Integer&gt; mapIx = IxedInstances.mapIx();

// Ixed instance for List&lt;String&gt;
Ixed&lt;List&lt;String&gt;, Integer, String&gt; listIx = IxedInstances.listIx();

// Create Ixed from any At instance
At&lt;Map&lt;String, String&gt;, String, String&gt; customAt = AtInstances.mapAt();
Ixed&lt;Map&lt;String, String&gt;, String, String&gt; customIx = IxedInstances.fromAt(customAt);
</code></pre>
<p>Each factory method returns an <code>Ixed</code> instance parameterised by:</p>
<ul>
<li><code>S</code> ‚Äì The structure type (e.g., <code>Map&lt;String, Integer&gt;</code>)</li>
<li><code>I</code> ‚Äì The index type (e.g., <code>String</code> for maps, <code>Integer</code> for lists)</li>
<li><code>A</code> ‚Äì The element type (e.g., <code>Integer</code>)</li>
</ul>
<h3 id="step-2-safe-read-operations"><a class="header" href="#step-2-safe-read-operations">Step 2: Safe Read Operations</a></h3>
<p><code>Ixed</code> provides safe reading that returns <code>Optional.empty()</code> for missing indices:</p>
<pre><code class="language-java">Map&lt;String, Integer&gt; ports = new HashMap&lt;&gt;();
ports.put("http", 8080);
ports.put("https", 8443);

Ixed&lt;Map&lt;String, Integer&gt;, String, Integer&gt; mapIx = IxedInstances.mapIx();

// Read existing key
Optional&lt;Integer&gt; httpPort = IxedInstances.get(mapIx, "http", ports);
// Result: Optional[8080]

// Read missing key - no exception, just empty
Optional&lt;Integer&gt; ftpPort = IxedInstances.get(mapIx, "ftp", ports);
// Result: Optional.empty()

// Check existence
boolean hasHttp = IxedInstances.contains(mapIx, "http", ports);
// Result: true

boolean hasFtp = IxedInstances.contains(mapIx, "ftp", ports);
// Result: false
</code></pre>
<p>Compare this to direct map access which might return <code>null</code> or require explicit containment checks.</p>
<h3 id="step-3-update-operations-no-insertion"><a class="header" href="#step-3-update-operations-no-insertion">Step 3: Update Operations (No Insertion!)</a></h3>
<p>The crucial difference from <code>At</code> is that <code>update</code> only modifies <em>existing</em> entries:</p>
<pre><code class="language-java">Map&lt;String, Integer&gt; ports = new HashMap&lt;&gt;();
ports.put("http", 8080);
ports.put("https", 8443);

Ixed&lt;Map&lt;String, Integer&gt;, String, Integer&gt; mapIx = IxedInstances.mapIx();

// Update existing key - works as expected
Map&lt;String, Integer&gt; updatedPorts = IxedInstances.update(mapIx, "http", 9000, ports);
// Result: {http=9000, https=8443}

// Attempt to "update" non-existent key - NO-OP!
Map&lt;String, Integer&gt; samePorts = IxedInstances.update(mapIx, "ftp", 21, ports);
// Result: {http=8080, https=8443} - NO ftp key added!

// Original unchanged (immutability)
System.out.println(ports); // {http=8080, https=8443}
</code></pre>
<p><strong>This is the defining characteristic of Ixed</strong>: it will never change the structure's shape. If an index doesn't exist, operations silently become no-ops.</p>
<h3 id="step-4-functional-modification"><a class="header" href="#step-4-functional-modification">Step 4: Functional Modification</a></h3>
<p>Apply functions to existing elements only:</p>
<pre><code class="language-java">Map&lt;String, Integer&gt; scores = new HashMap&lt;&gt;();
scores.put("alice", 100);
scores.put("bob", 85);

Ixed&lt;Map&lt;String, Integer&gt;, String, Integer&gt; mapIx = IxedInstances.mapIx();

// Modify existing value
Map&lt;String, Integer&gt; bonusAlice = IxedInstances.modify(mapIx, "alice", x -&gt; x + 10, scores);
// Result: {alice=110, bob=85}

// Modify non-existent key - no-op
Map&lt;String, Integer&gt; unchanged = IxedInstances.modify(mapIx, "charlie", x -&gt; x + 10, scores);
// Result: {alice=100, bob=85} - no charlie key created
</code></pre>
<p>This pattern is excellent for operations like "increment if exists" or "apply transformation to known entries".</p>
<h3 id="step-5-composition-with-other-optics"><a class="header" href="#step-5-composition-with-other-optics">Step 5: Composition with Other Optics</a></h3>
<p><code>Ixed</code> composes naturally with Lenses for deep, safe access:</p>
<pre><code class="language-java">record Config(Map&lt;String, Integer&gt; settings) {}

Lens&lt;Config, Map&lt;String, Integer&gt;&gt; settingsLens =
    Lens.of(Config::settings, (c, s) -&gt; new Config(s));

Ixed&lt;Map&lt;String, Integer&gt;, String, Integer&gt; mapIx = IxedInstances.mapIx();

// Compose: Config ‚Üí Map&lt;String, Integer&gt; ‚Üí Integer (0-or-1)
Traversal&lt;Config, Integer&gt; maxConnectionsTraversal =
    settingsLens.asTraversal().andThen(mapIx.ix("maxConnections"));

Config config = new Config(new HashMap&lt;&gt;(Map.of("maxConnections", 100, "timeout", 30)));

// Safe access through composed traversal
List&lt;Integer&gt; values = Traversals.getAll(maxConnectionsTraversal, config);
// Result: [100]

// Safe modification through composed traversal
Config updated = Traversals.modify(maxConnectionsTraversal, x -&gt; x * 2, config);
// Result: Config[settings={maxConnections=200, timeout=30}]

// Missing key = empty focus, modification is no-op
Traversal&lt;Config, Integer&gt; missingTraversal =
    settingsLens.asTraversal().andThen(mapIx.ix("nonexistent"));

Config unchanged = Traversals.modify(missingTraversal, x -&gt; x + 1, config);
// Result: Config unchanged, no "nonexistent" key added
</code></pre>
<p>This composition gives you type-safe, deep access that automatically handles missing intermediate keys.</p>
<hr />
<h2 id="list-operations-safe-indexed-access"><a class="header" href="#list-operations-safe-indexed-access">List Operations: Safe Indexed Access</a></h2>
<p><code>Ixed</code> for lists provides bounds-safe operations:</p>
<h3 id="safe-element-access"><a class="header" href="#safe-element-access">Safe Element Access</a></h3>
<pre><code class="language-java">Ixed&lt;List&lt;String&gt;, Integer, String&gt; listIx = IxedInstances.listIx();

List&lt;String&gt; items = new ArrayList&lt;&gt;(List.of("apple", "banana", "cherry"));

// Access valid index
Optional&lt;String&gt; second = IxedInstances.get(listIx, 1, items);
// Result: Optional["banana"]

// Access out-of-bounds - no exception!
Optional&lt;String&gt; tenth = IxedInstances.get(listIx, 10, items);
// Result: Optional.empty()

// Negative index - safely handled
Optional&lt;String&gt; negative = IxedInstances.get(listIx, -1, items);
// Result: Optional.empty()
</code></pre>
<h3 id="safe-element-update"><a class="header" href="#safe-element-update">Safe Element Update</a></h3>
<pre><code class="language-java">// Update existing index
List&lt;String&gt; updated = IxedInstances.update(listIx, 1, "BANANA", items);
// Result: ["apple", "BANANA", "cherry"]

// Update out-of-bounds - no-op, no exception
List&lt;String&gt; unchanged = IxedInstances.update(listIx, 10, "grape", items);
// Result: ["apple", "banana", "cherry"] - no element added!

// Modify with function
List&lt;String&gt; uppercased = IxedInstances.modify(listIx, 0, String::toUpperCase, items);
// Result: ["APPLE", "banana", "cherry"]

// Original always unchanged
System.out.println(items); // ["apple", "banana", "cherry"]
</code></pre>
<p><strong>Important Contrast with At</strong>: <code>At.insertOrUpdate()</code> on a list will throw <code>IndexOutOfBoundsException</code> for invalid indices (unless using padding), whilst <code>IxedInstances.update()</code> simply returns the list unchanged.</p>
<hr />
<h2 id="when-to-use-ixed-vs-other-approaches"><a class="header" href="#when-to-use-ixed-vs-other-approaches">When to Use Ixed vs Other Approaches</a></h2>
<h3 id="-use-ixed-when"><a class="header" href="#-use-ixed-when">‚úÖ Use <code>Ixed</code> When:</a></h3>
<ul>
<li><strong>You want safe partial access</strong>: Operations that become no-ops on missing indices</li>
<li><strong>Structure preservation is critical</strong>: You must not accidentally add or remove entries</li>
<li><strong>You're reading configuration files</strong>: Accessing known keys without creating defaults</li>
<li><strong>You need composable traversals</strong>: Building deep access paths that handle missing intermediates</li>
<li><strong>You want to avoid exceptions</strong>: Out-of-bounds list access should be safe, not throw</li>
<li><strong>Immutability matters</strong>: All operations return new structures</li>
</ul>
<h3 id="-avoid-ixed-when"><a class="header" href="#-avoid-ixed-when">‚ùå Avoid <code>Ixed</code> When:</a></h3>
<ul>
<li><strong>You need to insert new entries</strong>: Use <code>At.insertOrUpdate()</code> instead</li>
<li><strong>You need to delete entries</strong>: Use <code>At.remove()</code> instead</li>
<li><strong>You want to set defaults for missing keys</strong>: Use <code>At</code> with <code>Optional.of(defaultValue)</code></li>
<li><strong>You need bulk operations</strong>: Use <code>Traversal</code> for all-element modifications</li>
<li><strong>Performance is critical</strong>: Direct collection access may be faster (measure first!)</li>
</ul>
<h3 id="ixed-vs-at-choosing-the-right-tool"><a class="header" href="#ixed-vs-at-choosing-the-right-tool">Ixed vs At: Choosing the Right Tool</a></h3>
<pre><code class="language-java">// Scenario: Update user's email if they exist, do nothing if they don't
Map&lt;String, String&gt; users = new HashMap&lt;&gt;(Map.of("alice", "alice@example.com"));

// With At - DANGER: Might accidentally create user!
At&lt;Map&lt;String, String&gt;, String, String&gt; at = AtInstances.mapAt();
Map&lt;String, String&gt; result1 = at.insertOrUpdate("bob", "bob@example.com", users);
// Result: {alice=alice@example.com, bob=bob@example.com} - Bob added!

// With Ixed - SAFE: Will not create if missing
Ixed&lt;Map&lt;String, String&gt;, String, String&gt; ix = IxedInstances.mapIx();
Map&lt;String, String&gt; result2 = IxedInstances.update(ix, "bob", "bob@example.com", users);
// Result: {alice=alice@example.com} - No Bob, as intended!
</code></pre>
<p>Use <strong>At</strong> when you explicitly want CRUD semantics; use <strong>Ixed</strong> when you want read/update-only with automatic no-ops for missing indices.</p>
<hr />
<h2 id="common-pitfalls-12"><a class="header" href="#common-pitfalls-12">Common Pitfalls</a></h2>
<h3 id="-dont-expect-ixed-to-insert-new-entries"><a class="header" href="#-dont-expect-ixed-to-insert-new-entries">‚ùå Don't: Expect Ixed to insert new entries</a></h3>
<pre><code class="language-java">Ixed&lt;Map&lt;String, Integer&gt;, String, Integer&gt; mapIx = IxedInstances.mapIx();
Map&lt;String, Integer&gt; empty = new HashMap&lt;&gt;();

Map&lt;String, Integer&gt; result = IxedInstances.update(mapIx, "key", 100, empty);
// Result: {} - STILL EMPTY! No insertion occurred.

// If you need insertion, use At instead:
At&lt;Map&lt;String, Integer&gt;, String, Integer&gt; mapAt = AtInstances.mapAt();
Map&lt;String, Integer&gt; withKey = mapAt.insertOrUpdate("key", 100, empty);
// Result: {key=100}
</code></pre>
<h3 id="-do-use-ixed-for-safe-non-inserting-updates"><a class="header" href="#-do-use-ixed-for-safe-non-inserting-updates">‚úÖ Do: Use Ixed for safe, non-inserting updates</a></h3>
<pre><code class="language-java">// Perfect for updating known configuration keys
Map&lt;String, String&gt; config = new HashMap&lt;&gt;(Map.of("theme", "dark", "language", "en"));

Ixed&lt;Map&lt;String, String&gt;, String, String&gt; ix = IxedInstances.mapIx();

// Only updates keys that exist
Map&lt;String, String&gt; updated = IxedInstances.update(ix, "theme", "light", config);
// Result: {theme=light, language=en}

// Typo in key name? No problem - just a no-op
Map&lt;String, String&gt; unchanged = IxedInstances.update(ix, "tehme", "light", config); // typo!
// Result: {theme=dark, language=en} - no new key created
</code></pre>
<hr />
<h3 id="-dont-assume-update-failure-means-an-error"><a class="header" href="#-dont-assume-update-failure-means-an-error">‚ùå Don't: Assume update failure means an error</a></h3>
<pre><code class="language-java">Ixed&lt;List&lt;String&gt;, Integer, String&gt; listIx = IxedInstances.listIx();
List&lt;String&gt; items = new ArrayList&lt;&gt;(List.of("a", "b", "c"));

List&lt;String&gt; result = IxedInstances.update(listIx, 10, "z", items);
// Result is the same list - but this is SUCCESS, not failure!
// The operation correctly did nothing because index 10 doesn't exist.
</code></pre>
<h3 id="-do-check-for-existence-first-if-you-need-to-know"><a class="header" href="#-do-check-for-existence-first-if-you-need-to-know">‚úÖ Do: Check for existence first if you need to know</a></h3>
<pre><code class="language-java">Ixed&lt;Map&lt;String, Integer&gt;, String, Integer&gt; mapIx = IxedInstances.mapIx();
Map&lt;String, Integer&gt; scores = new HashMap&lt;&gt;(Map.of("alice", 100));

// If you need to know whether update will succeed:
if (IxedInstances.contains(mapIx, "bob", scores)) {
    Map&lt;String, Integer&gt; updated = IxedInstances.update(mapIx, "bob", 90, scores);
    System.out.println("Updated Bob's score");
} else {
    System.out.println("Bob not found - consider using At to insert");
}
</code></pre>
<hr />
<h3 id="-dont-forget-that-ixed-inherits-ats-null-value-limitations"><a class="header" href="#-dont-forget-that-ixed-inherits-ats-null-value-limitations">‚ùå Don't: Forget that Ixed inherits At's null value limitations</a></h3>
<pre><code class="language-java">Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
map.put("nullValue", null);

Ixed&lt;Map&lt;String, Integer&gt;, String, Integer&gt; mapIx = IxedInstances.mapIx();
Optional&lt;Integer&gt; result = IxedInstances.get(mapIx, "nullValue", map);
// Result: Optional.empty() - NOT Optional.of(null)!

// Java's Optional cannot hold null values
// This is inherited from the underlying At implementation
</code></pre>
<h3 id="-do-avoid-null-values-in-collections"><a class="header" href="#-do-avoid-null-values-in-collections">‚úÖ Do: Avoid null values in collections</a></h3>
<pre><code class="language-java">// Use sentinel values or wrapper types if you need to distinguish null from absent
Map&lt;String, Optional&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;();
map.put("maybeNull", Optional.empty()); // Explicitly absent value
map.put("hasValue", Optional.of(42));   // Present value

// Or use At directly if you need to distinguish presence from null
At&lt;Map&lt;String, Integer&gt;, String, Integer&gt; at = AtInstances.mapAt();
// at.contains("key", map) checks key presence, not value
</code></pre>
<hr />
<h2 id="performance-considerations-6"><a class="header" href="#performance-considerations-6">Performance Considerations</a></h2>
<h3 id="immutability-overhead"><a class="header" href="#immutability-overhead">Immutability Overhead</a></h3>
<p>Like <code>At</code>, all <code>Ixed</code> operations create new collection instances:</p>
<pre><code class="language-java">Ixed&lt;Map&lt;String, Integer&gt;, String, Integer&gt; mapIx = IxedInstances.mapIx();

// Each operation creates a new HashMap copy - O(n)
Map&lt;String, Integer&gt; step1 = IxedInstances.update(mapIx, "a", 1, original);   // Copy
Map&lt;String, Integer&gt; step2 = IxedInstances.modify(mapIx, "b", x -&gt; x + 1, step1); // Copy
Map&lt;String, Integer&gt; step3 = IxedInstances.update(mapIx, "c", 3, step2);     // Copy
</code></pre>
<p><strong>Best Practice</strong>: Batch modifications when possible, or accept the immutability overhead for correctness:</p>
<pre><code class="language-java">// For multiple updates, consider direct immutable construction
Map&lt;String, Integer&gt; result = new HashMap&lt;&gt;(original);
result.put("a", 1);  // Mutable during construction
result.compute("b", (k, v) -&gt; v != null ? v + 1 : v);
result.put("c", 3);
// Now use Ixed for subsequent safe operations
</code></pre>
<h3 id="composition-overhead"><a class="header" href="#composition-overhead">Composition Overhead</a></h3>
<p>Composed traversals have minimal overhead since they're just function compositions:</p>
<pre><code class="language-java">// Composition is cheap - just wraps functions
Traversal&lt;Config, Integer&gt; deep = lens.asTraversal().andThen(mapIx.ix("key"));

// The overhead is in the actual modification, not the composition
Config result = Traversals.modify(deep, x -&gt; x + 1, config);
</code></pre>
<h3 id="compared-to-at"><a class="header" href="#compared-to-at">Compared to At</a></h3>
<p><code>Ixed</code> has essentially the same performance characteristics as <code>At</code> since it's built on top of it. The additional Prism composition adds negligible overhead.</p>
<hr />
<h2 id="real-world-example-safe-feature-toggle-reader"><a class="header" href="#real-world-example-safe-feature-toggle-reader">Real-World Example: Safe Feature Toggle Reader</a></h2>
<p>Consider a system where feature toggles are read from external configuration but should never be accidentally created:</p>
<pre><code class="language-java">public class SafeFeatureReader {

    private final Ixed&lt;Map&lt;String, Boolean&gt;, String, Boolean&gt; featureIx =
        IxedInstances.mapIx();
    private final Map&lt;String, Boolean&gt; features;

    public SafeFeatureReader(Map&lt;String, Boolean&gt; initialFeatures) {
        // Create immutable snapshot
        this.features = new HashMap&lt;&gt;(initialFeatures);
    }

    public boolean isEnabled(String featureName) {
        // Safe read - returns false for unknown features
        return IxedInstances.get(featureIx, featureName, features).orElse(false);
    }

    public boolean isKnownFeature(String featureName) {
        return IxedInstances.contains(featureIx, featureName, features);
    }

    public Map&lt;String, Boolean&gt; withFeatureUpdated(String featureName, boolean enabled) {
        // Safe update - only modifies existing features
        // Will NOT add new features even if called with unknown name
        return IxedInstances.update(featureIx, featureName, enabled, features);
    }

    public Map&lt;String, Boolean&gt; withFeatureToggled(String featureName) {
        // Safe toggle - flips value if exists, no-op if missing
        return IxedInstances.modify(featureIx, featureName, current -&gt; !current, features);
    }

    public Set&lt;String&gt; getKnownFeatures() {
        return Collections.unmodifiableSet(features.keySet());
    }
}

// Usage
Map&lt;String, Boolean&gt; config = Map.of(
    "dark_mode", true,
    "new_dashboard", false,
    "beta_features", true
);

SafeFeatureReader reader = new SafeFeatureReader(config);

// Safe reads
System.out.println(reader.isEnabled("dark_mode"));      // true
System.out.println(reader.isEnabled("unknown"));        // false (default)
System.out.println(reader.isKnownFeature("unknown"));   // false

// Safe updates - won't create new features
Map&lt;String, Boolean&gt; updated = reader.withFeatureUpdated("new_dashboard", true);
// Result: {dark_mode=true, new_dashboard=true, beta_features=true}

Map&lt;String, Boolean&gt; unchanged = reader.withFeatureUpdated("typo_feature", true);
// Result: {dark_mode=true, new_dashboard=false, beta_features=true}
// No "typo_feature" added!

// Safe toggle
Map&lt;String, Boolean&gt; toggled = reader.withFeatureToggled("beta_features");
// Result: {dark_mode=true, new_dashboard=false, beta_features=false}
</code></pre>
<p>This pattern ensures configuration integrity‚Äîyou can never accidentally pollute your feature flags with typos or unknown keys.</p>
<hr />
<h2 id="complete-runnable-example-8"><a class="header" href="#complete-runnable-example-8">Complete, Runnable Example</a></h2>
<p>Here's a comprehensive example demonstrating all major Ixed features:</p>
<pre><code class="language-java">package org.higherkindedj.example.optics;

import java.util.*;
import org.higherkindedj.optics.At;
import org.higherkindedj.optics.Ixed;
import org.higherkindedj.optics.Lens;
import org.higherkindedj.optics.Traversal;
import org.higherkindedj.optics.annotations.GenerateLenses;
import org.higherkindedj.optics.at.AtInstances;
import org.higherkindedj.optics.ixed.IxedInstances;
import org.higherkindedj.optics.util.Traversals;

public class IxedUsageExample {

    @GenerateLenses
    public record ServerConfig(
        String name,
        Map&lt;String, Integer&gt; ports,
        Map&lt;String, String&gt; environment,
        List&lt;String&gt; allowedOrigins
    ) {}

    public static void main(String[] args) {
        System.out.println("=== Ixed Type Class Usage Examples ===\n");

        // 1. Basic Map Operations - Safe Access Only
        System.out.println("--- Map Safe Access (No Insertion) ---");

        Ixed&lt;Map&lt;String, Integer&gt;, String, Integer&gt; mapIx = IxedInstances.mapIx();
        Map&lt;String, Integer&gt; ports = new HashMap&lt;&gt;(Map.of("http", 8080, "https", 8443));

        System.out.println("Initial ports: " + ports);

        // Safe read
        System.out.println("HTTP port: " + IxedInstances.get(mapIx, "http", ports));
        System.out.println("FTP port (missing): " + IxedInstances.get(mapIx, "ftp", ports));

        // Safe update - only existing keys
        Map&lt;String, Integer&gt; updatedPorts = IxedInstances.update(mapIx, "http", 9000, ports);
        System.out.println("After update 'http': " + updatedPorts);

        // Attempted update of non-existent key - NO-OP!
        Map&lt;String, Integer&gt; samePorts = IxedInstances.update(mapIx, "ftp", 21, ports);
        System.out.println("After 'update' non-existent 'ftp': " + samePorts);
        System.out.println("FTP was NOT added (Ixed doesn't insert)");

        // Modify with function
        Map&lt;String, Integer&gt; doubled = IxedInstances.modify(mapIx, "https", x -&gt; x * 2, ports);
        System.out.println("After doubling 'https': " + doubled);

        System.out.println("Original unchanged: " + ports);
        System.out.println();

        // 2. Contrast with At (CRUD)
        System.out.println("--- Ixed vs At: Insertion Behaviour ---");

        At&lt;Map&lt;String, Integer&gt;, String, Integer&gt; mapAt = AtInstances.mapAt();

        Map&lt;String, Integer&gt; empty = new HashMap&lt;&gt;();

        // At CAN insert
        Map&lt;String, Integer&gt; withNew = mapAt.insertOrUpdate("newKey", 42, empty);
        System.out.println("At.insertOrUpdate on empty map: " + withNew);

        // Ixed CANNOT insert
        Map&lt;String, Integer&gt; stillEmpty = IxedInstances.update(mapIx, "newKey", 42, empty);
        System.out.println("Ixed.update on empty map: " + stillEmpty);
        System.out.println("Ixed preserves structure - no insertion occurred");
        System.out.println();

        // 3. List Safe Indexed Access
        System.out.println("--- List Safe Indexed Access ---");

        Ixed&lt;List&lt;String&gt;, Integer, String&gt; listIx = IxedInstances.listIx();
        List&lt;String&gt; origins = new ArrayList&lt;&gt;(List.of("localhost", "example.com", "api.example.com"));

        System.out.println("Initial origins: " + origins);

        // Safe bounds checking
        System.out.println("Index 1: " + IxedInstances.get(listIx, 1, origins));
        System.out.println("Index 10 (out of bounds): " + IxedInstances.get(listIx, 10, origins));
        System.out.println("Index -1 (negative): " + IxedInstances.get(listIx, -1, origins));

        // Safe update within bounds
        List&lt;String&gt; updated = IxedInstances.update(listIx, 1, "www.example.com", origins);
        System.out.println("After update index 1: " + updated);

        // Update out of bounds - no-op, no exception!
        List&lt;String&gt; unchanged = IxedInstances.update(listIx, 10, "invalid.com", origins);
        System.out.println("After 'update' out-of-bounds index 10: " + unchanged);
        System.out.println("No exception thrown, list unchanged");

        // Functional modification
        List&lt;String&gt; uppercased = IxedInstances.modify(listIx, 0, String::toUpperCase, origins);
        System.out.println("After uppercase index 0: " + uppercased);

        System.out.println("Original unchanged: " + origins);
        System.out.println();

        // 4. Composition with Lenses
        System.out.println("--- Deep Composition: Lens + Ixed ---");

        // Use generated lenses from @GenerateLenses annotation
        Lens&lt;ServerConfig, Map&lt;String, Integer&gt;&gt; portsLens = ServerConfigLenses.ports();
        Lens&lt;ServerConfig, Map&lt;String, String&gt;&gt; envLens = ServerConfigLenses.environment();

        ServerConfig config = new ServerConfig(
            "production",
            new HashMap&lt;&gt;(Map.of("http", 8080, "https", 8443, "ws", 8765)),
            new HashMap&lt;&gt;(Map.of("NODE_ENV", "production", "LOG_LEVEL", "info")),
            new ArrayList&lt;&gt;(List.of("*.example.com"))
        );

        System.out.println("Initial config: " + config);

        // Compose: ServerConfig ‚Üí Map&lt;String, Integer&gt; ‚Üí Integer (0-or-1)
        Ixed&lt;Map&lt;String, Integer&gt;, String, Integer&gt; portIx = IxedInstances.mapIx();
        Traversal&lt;ServerConfig, Integer&gt; httpPortTraversal =
            portsLens.asTraversal().andThen(portIx.ix("http"));

        // Safe access through composition
        List&lt;Integer&gt; httpPorts = Traversals.getAll(httpPortTraversal, config);
        System.out.println("HTTP port via traversal: " + httpPorts);

        // Safe modification through composition
        ServerConfig updatedConfig = Traversals.modify(httpPortTraversal, p -&gt; p + 1000, config);
        System.out.println("After incrementing HTTP port: " + updatedConfig.ports());

        // Non-existent key = empty focus
        Traversal&lt;ServerConfig, Integer&gt; ftpPortTraversal =
            portsLens.asTraversal().andThen(portIx.ix("ftp"));

        List&lt;Integer&gt; ftpPorts = Traversals.getAll(ftpPortTraversal, config);
        System.out.println("FTP port (missing): " + ftpPorts);

        ServerConfig stillSameConfig = Traversals.modify(ftpPortTraversal, p -&gt; p + 1, config);
        System.out.println("After 'modify' missing FTP: " + stillSameConfig.ports());
        System.out.println("Config unchanged - Ixed didn't insert FTP");
        System.out.println();

        // 5. Checking existence
        System.out.println("--- Existence Checking ---");

        System.out.println("Contains 'http': " + IxedInstances.contains(portIx, "http", config.ports()));
        System.out.println("Contains 'ftp': " + IxedInstances.contains(portIx, "ftp", config.ports()));

        // Pattern: Check before deciding on operation
        String keyToUpdate = "ws";
        if (IxedInstances.contains(portIx, keyToUpdate, config.ports())) {
            Map&lt;String, Integer&gt; newPorts = IxedInstances.update(portIx, keyToUpdate, 9999, config.ports());
            System.out.println("WebSocket port updated to 9999: " + newPorts);
        } else {
            System.out.println(keyToUpdate + " not found - would need At to insert");
        }
        System.out.println();

        // 6. Building Ixed from At
        System.out.println("--- Creating Ixed from At ---");

        At&lt;Map&lt;String, String&gt;, String, String&gt; stringMapAt = AtInstances.mapAt();
        Ixed&lt;Map&lt;String, String&gt;, String, String&gt; envIx = IxedInstances.fromAt(stringMapAt);

        Map&lt;String, String&gt; env = config.environment();
        System.out.println("Initial environment: " + env);

        // Use derived Ixed for safe operations
        Map&lt;String, String&gt; updatedEnv = IxedInstances.update(envIx, "LOG_LEVEL", "debug", env);
        System.out.println("After update LOG_LEVEL: " + updatedEnv);

        Map&lt;String, String&gt; unchangedEnv = IxedInstances.update(envIx, "NEW_VAR", "value", env);
        System.out.println("After 'update' non-existent NEW_VAR: " + unchangedEnv);
        System.out.println("NEW_VAR not added - Ixed from At still can't insert");

        System.out.println("\n=== All operations maintain immutability and structure ===");
    }
}
</code></pre>
<p><strong>Expected Output:</strong></p>
<pre><code>=== Ixed Type Class Usage Examples ===

--- Map Safe Access (No Insertion) ---
Initial ports: {http=8080, https=8443}
HTTP port: Optional[8080]
FTP port (missing): Optional.empty
After update 'http': {http=9000, https=8443}
After 'update' non-existent 'ftp': {http=8080, https=8443}
FTP was NOT added (Ixed doesn't insert)
After doubling 'https': {http=8080, https=16886}
Original unchanged: {http=8080, https=8443}

--- Ixed vs At: Insertion Behaviour ---
At.insertOrUpdate on empty map: {newKey=42}
Ixed.update on empty map: {}
Ixed preserves structure - no insertion occurred

--- List Safe Indexed Access ---
Initial origins: [localhost, example.com, api.example.com]
Index 1: Optional[example.com]
Index 10 (out of bounds): Optional.empty
Index -1 (negative): Optional.empty
After update index 1: [localhost, www.example.com, api.example.com]
After 'update' out-of-bounds index 10: [localhost, example.com, api.example.com]
No exception thrown, list unchanged
After uppercase index 0: [LOCALHOST, example.com, api.example.com]
Original unchanged: [localhost, example.com, api.example.com]

--- Deep Composition: Lens + Ixed ---
Initial config: ServerConfig[name=production, ports={http=8080, https=8443, ws=8765}, environment={NODE_ENV=production, LOG_LEVEL=info}, allowedOrigins=[*.example.com]]
HTTP port via traversal: [8080]
After incrementing HTTP port: {http=9080, https=8443, ws=8765}
FTP port (missing): []
After 'modify' missing FTP: {http=8080, https=8443, ws=8765}
Config unchanged - Ixed didn't insert FTP

--- Existence Checking ---
Contains 'http': true
Contains 'ftp': false
WebSocket port updated to 9999: {http=8080, https=8443, ws=9999}

--- Creating Ixed from At ---
Initial environment: {NODE_ENV=production, LOG_LEVEL=info}
After update LOG_LEVEL: {NODE_ENV=production, LOG_LEVEL=debug}
After 'update' non-existent NEW_VAR: {NODE_ENV=production, LOG_LEVEL=info}
NEW_VAR not added - Ixed from At still can't insert

=== All operations maintain immutability and structure ===
</code></pre>
<hr />
<h2 id="further-reading-10"><a class="header" href="#further-reading-10">Further Reading</a></h2>
<ul>
<li><a href="https://hackage.haskell.org/package/lens/docs/Control-Lens-At.html#t:Ixed">Haskell Lens Library - Ixed Type Class</a></li>
<li><a href="https://leanpub.com/optics-by-example">Optics By Example</a> - Comprehensive optics guide</li>
<li><a href="optics/at.html">At Type Class Guide</a> - Full CRUD operations with insert/delete</li>
<li><a href="optics/traversals.html">Traversals Guide</a> - Bulk operations on collections</li>
<li><a href="optics/prisms.html">Prisms Guide</a> - Understanding the <code>some()</code> Prism used internally</li>
</ul>
<hr />
<h2 id="summary-5"><a class="header" href="#summary-5">Summary</a></h2>
<p>The <strong>Ixed</strong> type class provides a powerful abstraction for safe, partial access to indexed structures:</p>
<ul>
<li><strong>Traversal to existing elements</strong>: <code>ix(index)</code> returns <code>Traversal&lt;S, A&gt;</code> focusing on 0-or-1 elements</li>
<li><strong>No insertion or deletion</strong>: Operations become no-ops for missing indices</li>
<li><strong>Structure preservation</strong>: The shape of your data never changes unexpectedly</li>
<li><strong>Built on At</strong>: Inherits precise semantics whilst removing CRUD mutations</li>
<li><strong>Composable</strong>: Chains naturally with other optics for safe deep access</li>
<li><strong>Exception-free</strong>: Out-of-bounds access returns empty, doesn't throw</li>
</ul>
<p>Ixed complements At by providing read/update-only semantics when you need safe partial access without the risk of accidentally modifying your data structure's shape. Use Ixed when correctness and structure preservation matter more than the ability to insert or delete entries.</p>
<hr />
<p><a href="optics/at.html">Previous: At Type Class</a> | <a href="optics/profunctor_optics.html">Next: Profunctor Optics</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="profunctor-optics-advanced-data-transformation"><a class="header" href="#profunctor-optics-advanced-data-transformation">Profunctor Optics: Advanced Data Transformation</a></h1>
<h2 id="adapting-optics-to-different-data-types"><a class="header" href="#adapting-optics-to-different-data-types"><em>Adapting Optics to Different Data Types</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="optics/profunctor_optics.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to adapt existing optics to work with different data types</li>
<li>Using <code>contramap</code> to change source types and <code>map</code> to change target types</li>
<li>Combining both adaptations with <code>dimap</code> for complete format conversion</li>
<li>Creating reusable adapter patterns for API integration</li>
<li>Working with type-safe wrapper classes and legacy system integration</li>
<li>When to use profunctor adaptations vs creating new optics from scratch</li>
</ul>
</div>
</div>
<div id="admonition-example-code" class="admonition admonish-note" role="note" aria-labelledby="admonition-example-code-title">
<div class="admonition-title">
<div id="admonition-example-code-title">
<p>Example Code</p>
</div>
<a class="admonition-anchor-link" href="optics/profunctor_optics.html#admonition-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/profunctor/OpticProfunctorExample.java">OpticProfunctorExample</a></p>
</div>
</div>
<p>In the previous optics guides, we explored how to work with data structures directly using <code>Lens</code>, <code>Prism</code>, <code>Iso</code>, and <code>Traversal</code>. But what happens when you need to use an optic designed for one data type with a completely different data structure? What if you want to adapt an existing optic to work with new input or output formats?</p>
<p>This is where the <strong>profunctor</strong> nature of optics becomes invaluable. Every optic in higher-kinded-j is fundamentally a profunctor, which means it can be adapted to work with different source and target types using powerful transformation operations.</p>
<hr />
<h2 id="the-challenge-type-mismatch-in-real-systems"><a class="header" href="#the-challenge-type-mismatch-in-real-systems">The Challenge: Type Mismatch in Real Systems</a></h2>
<p>In real-world applications, you frequently encounter situations where:</p>
<ul>
<li><strong>Legacy Integration</strong>: You have optics designed for old data structures but need to work with new ones</li>
<li><strong>API Adaptation</strong>: External APIs use different field names or data formats than your internal models</li>
<li><strong>Type Safety</strong>: You want to work with strongly-typed wrapper classes but reuse optics designed for raw values</li>
<li><strong>Data Migration</strong>: You're transitioning between data formats and need optics that work with both</li>
</ul>
<p>Consider this scenario: you have a well-tested <code>Lens</code> that operates on a <code>Person</code> record, but you need to use it with an <code>Employee</code> record that contains a <code>Person</code> as a nested field. Rather than rewriting the lens, you can <strong>adapt</strong> it.</p>
<h2 id="think-of-profunctor-adaptations-like"><a class="header" href="#think-of-profunctor-adaptations-like">Think of Profunctor Adaptations Like...</a></h2>
<ul>
<li><strong>Universal adapters</strong>: Like electrical plug adapters that make devices work in different countries</li>
<li><strong>Translation layers</strong>: Converting between different "languages" of data representation</li>
<li><strong>Lens filters</strong>: Modifying what the optic sees (input) and what it produces (output)</li>
<li><strong>Pipeline adapters</strong>: Connecting optics that weren't originally designed to work together</li>
</ul>
<h2 id="the-three-profunctor-operations"><a class="header" href="#the-three-profunctor-operations">The Three Profunctor Operations</a></h2>
<p>Every optic provides three powerful adaptation methods that mirror the core profunctor operations:</p>
<h3 id="1-contramap-adapting-the-source-type"><a class="header" href="#1-contramap-adapting-the-source-type">1. <strong><code>contramap</code></strong>: Adapting the Source Type</a></h3>
<p>The <code>contramap</code> operation allows you to adapt an optic to work with a different source type by providing a function that converts from the new source to the original source.</p>
<p><strong>Use Case</strong>: You have a <code>Lens&lt;Person, String&gt;</code> for getting a person's first name, but you want to use it with <code>Employee</code> objects.</p>
<pre><code class="language-java">// Original lens: Person -&gt; String (first name)
Lens&lt;Person, String&gt; firstNameLens = PersonLenses.firstName();

// Adapt it to work with Employee by providing the conversion
Lens&lt;Employee, String&gt; employeeFirstNameLens = 
    firstNameLens.contramap(employee -&gt; employee.personalInfo());

// Now you can use the adapted lens directly on Employee objects
Employee employee = new Employee(123, new Person("Alice", "Johnson", ...), "Engineering");
String firstName = employeeFirstNameLens.get(employee); // "Alice"
</code></pre>
<h3 id="2-map-adapting-the-target-type"><a class="header" href="#2-map-adapting-the-target-type">2. <strong><code>map</code></strong>: Adapting the Target Type</a></h3>
<p>The <code>map</code> operation adapts an optic to work with a different target type by providing a function that converts from the original target to the new target.</p>
<p><strong>Use Case</strong>: You have a <code>Lens&lt;Person, LocalDate&gt;</code> for birth dates, but you want to work with formatted strings instead.</p>
<pre><code class="language-java">// Original lens: Person -&gt; LocalDate
Lens&lt;Person, LocalDate&gt; birthDateLens = PersonLenses.birthDate();

// Adapt it to work with formatted strings
Lens&lt;Person, String&gt; birthDateStringLens = 
    birthDateLens.map(date -&gt; date.format(DateTimeFormatter.ISO_LOCAL_DATE));

// The adapted lens now returns strings
Person person = new Person("Bob", "Smith", LocalDate.of(1985, 12, 25), ...);
String dateString = birthDateStringLens.get(person); // "1985-12-25"
</code></pre>
<h3 id="3-dimap-adapting-both-source-and-target-types"><a class="header" href="#3-dimap-adapting-both-source-and-target-types">3. <strong><code>dimap</code></strong>: Adapting Both Source and Target Types</a></h3>
<p>The <code>dimap</code> operation is the most powerful‚Äîit adapts both the source and target types simultaneously. This is perfect for converting between completely different data representations.</p>
<p><strong>Use Case</strong>: You have optics designed for internal <code>Person</code> objects but need to work with external <code>PersonDto</code> objects that use different field structures.</p>
<pre><code class="language-java">// Original traversal: Person -&gt; String (hobbies)
Traversal&lt;Person, String&gt; hobbiesTraversal = PersonTraversals.hobbies();

// Adapt it to work with PersonDto (different source) and call them "interests" (different context)
Traversal&lt;PersonDto, String&gt; interestsTraversal = 
    hobbiesTraversal.dimap(
        // Convert PersonDto to Person
        dto -&gt; new Person(
            dto.fullName().split(" ")[0],
            dto.fullName().split(" ")[1], 
            LocalDate.parse(dto.birthDateString()),
            dto.interests()
        ),
        // Convert Person back to PersonDto  
        person -&gt; new PersonDto(
            person.firstName() + " " + person.lastName(),
            person.birthDate().format(DateTimeFormatter.ISO_LOCAL_DATE),
            person.hobbies()
        )
    );
</code></pre>
<hr />
<h2 id="decision-guide-when-to-use-each-operation"><a class="header" href="#decision-guide-when-to-use-each-operation">Decision Guide: When to Use Each Operation</a></h2>
<h3 id="use-contramap-when"><a class="header" href="#use-contramap-when">Use <code>contramap</code> When:</a></h3>
<ul>
<li><strong>Different source type, same target</strong> - Existing optic works perfectly, just need different input</li>
<li><strong>Extracting nested data</strong> - Your new type contains the old type as a field</li>
<li><strong>Wrapper type handling</strong> - Working with strongly-typed wrappers around base types</li>
</ul>
<p>java</p>
<pre><code class="language-java">// Perfect for extracting nested data
Lens&lt;Order, String&gt; customerNameLens = 
    OrderLenses.customer().contramap(invoice -&gt; invoice.order());
</code></pre>
<h3 id="use-map-when"><a class="header" href="#use-map-when">Use <code>map</code> When:</a></h3>
<ul>
<li><strong>Same source, different target format</strong> - You want to transform the output</li>
<li><strong>Data presentation</strong> - Converting raw data to display formats</li>
<li><strong>Type strengthening</strong> - Wrapping raw values in type-safe containers</li>
</ul>
<p>java</p>
<pre><code class="language-java">// Perfect for presentation formatting
Lens&lt;Product, String&gt; formattedPriceLens = 
    ProductLenses.price().map(price -&gt; "¬£" + price.setScale(2));
</code></pre>
<h3 id="use-dimap-when"><a class="header" href="#use-dimap-when">Use <code>dimap</code> When:</a></h3>
<ul>
<li><strong>Complete format conversion</strong> - Both input and output need transformation</li>
<li><strong>API integration</strong> - External systems use completely different data structures</li>
<li><strong>Legacy system support</strong> - Bridging between old and new data formats</li>
<li><strong>Data migration</strong> - Supporting multiple data representations simultaneously</li>
</ul>
<p>java</p>
<pre><code class="language-java">// Perfect for API integration
Traversal&lt;ApiUserDto, String&gt; apiRolesTraversal = 
    UserTraversals.roles().dimap(
        dto -&gt; convertApiDtoToUser(dto),
        userLogin -&gt; convertUserToApiDto(userLogin)
    );
</code></pre>
<hr />
<h2 id="common-pitfalls-13"><a class="header" href="#common-pitfalls-13">Common Pitfalls</a></h2>
<h3 id="-dont-do-this-9"><a class="header" href="#-dont-do-this-9">‚ùå Don't Do This:</a></h3>
<pre><code class="language-java">// Creating adapters inline repeatedly
var lens1 = PersonLenses.firstName().contramap(emp -&gt; emp.person());
var lens2 = PersonLenses.firstName().contramap(emp -&gt; emp.person());
var lens3 = PersonLenses.firstName().contramap(emp -&gt; emp.person());

// Over-adapting simple cases
Lens&lt;Person, String&gt; nameUpper = PersonLenses.firstName()
    .map(String::toUpperCase)
    .map(s -&gt; s.trim())
    .map(s -&gt; s.replace(" ", "_")); // Just write one function!

// Forgetting null safety in conversions
Lens&lt;EmployeeDto, String&gt; unsafeLens = PersonLenses.firstName()
    .contramap(dto -&gt; dto.person()); // What if dto.person() is null?

// Complex conversions without error handling
Traversal&lt;String, LocalDate&gt; fragileParser = 
    Iso.of(LocalDate::toString, LocalDate::parse).asTraversal()
    .contramap(complexString -&gt; extractDatePart(complexString)); // Might throw!
</code></pre>
<h3 id="-do-this-instead-9"><a class="header" href="#-do-this-instead-9">‚úÖ Do This Instead:</a></h3>
<pre><code class="language-java">// Create adapters once, reuse everywhere
public static final Lens&lt;Employee, String&gt; EMPLOYEE_FIRST_NAME = 
    PersonLenses.firstName().contramap(Employee::personalInfo);

// Combine transformations efficiently
Function&lt;String, String&gt; normalise = name -&gt; 
    name.toUpperCase().trim().replace(" ", "_");
Lens&lt;Person, String&gt; normalisedNameLens = PersonLenses.firstName().map(normalise);

// Handle null safety explicitly
Lens&lt;EmployeeDto, Optional&lt;String&gt;&gt; safeNameLens = PersonLenses.firstName()
    .contramap((EmployeeDto dto) -&gt; Optional.ofNullable(dto.person()))
    .map(Optional::of);

// Use safe conversions with proper error handling
Function&lt;String, Either&lt;String, LocalDate&gt;&gt; safeParse = str -&gt; {
    try {
        return Either.right(LocalDate.parse(extractDatePart(str)));
    } catch (Exception e) {
        return Either.left("Invalid date: " + str);
    }
};
</code></pre>
<hr />
<h2 id="performance-notes-9"><a class="header" href="#performance-notes-9">Performance Notes</a></h2>
<p>Profunctor adaptations are designed for efficiency:</p>
<ul>
<li><strong>Automatic fusion</strong>: Multiple <code>contramap</code> or <code>map</code> operations are automatically combined</li>
<li><strong>Lazy evaluation</strong>: Conversions only happen when the optic is actually used</li>
<li><strong>No boxing overhead</strong>: Simple transformations are inlined by the JVM</li>
<li><strong>Reusable adapters</strong>: Create once, use many times without additional overhead</li>
</ul>
<p><strong>Best Practice</strong>: Create adapted optics as constants and reuse them:</p>
<pre><code class="language-java">public class OpticAdapters {
    // Create once, use everywhere
    public static final Lens&lt;Employee, String&gt; FIRST_NAME = 
        PersonLenses.firstName().contramap(Employee::personalInfo);
  
    public static final Lens&lt;Employee, String&gt; FORMATTED_BIRTH_DATE = 
        PersonLenses.birthDate()
            .contramap(Employee::personalInfo)
            .map(date -&gt; date.format(DateTimeFormatter.DD_MM_YYYY));
      
    public static final Traversal&lt;CompanyDto, String&gt; EMPLOYEE_EMAILS = 
        CompanyTraversals.employees()
            .contramap((CompanyDto dto) -&gt; convertDtoToCompany(dto))
            .andThen(EmployeeTraversals.contacts())
            .andThen(ContactLenses.email().asTraversal());
}
</code></pre>
<hr />
<h2 id="real-world-example-api-integration"><a class="header" href="#real-world-example-api-integration">Real-World Example: API Integration</a></h2>
<p>Let's explore a comprehensive example where you need to integrate with an external API that uses different field names and data structures than your internal models.</p>
<p><strong>The Scenario</strong>: Your internal system uses <code>Employee</code> records, but the external API expects <code>EmployeeDto</code> objects with different field names:</p>
<pre><code class="language-java">// Internal model
@GenerateLenses
@GenerateTraversals
public record Employee(int id, Person personalInfo, String department) {}

@GenerateLenses
@GenerateTraversals  
public record Person(String firstName, String lastName, LocalDate birthDate, List&lt;String&gt; skills) {}

// External API model  
@GenerateLenses
public record EmployeeDto(int employeeId, PersonDto person, String dept) {}

@GenerateLenses
public record PersonDto(String fullName, String birthDateString, List&lt;String&gt; expertise) {}
</code></pre>
<p><strong>The Solution</strong>: Create an adapter that converts between these formats while reusing your existing optics:</p>
<pre><code class="language-java">public class ApiIntegration {
  
    // Conversion utilities
    private static Employee dtoToEmployee(EmployeeDto dto) {
        PersonDto personDto = dto.person();
        String[] nameParts = personDto.fullName().split(" ", 2);
        Person person = new Person(
            nameParts[0],
            nameParts.length &gt; 1 ? nameParts[1] : "",
            LocalDate.parse(personDto.birthDateString()),
            personDto.expertise()
        );
        return new Employee(dto.employeeId(), person, dto.dept());
    }
  
    private static EmployeeDto employeeToDto(Employee employee) {
        Person person = employee.personalInfo();
        PersonDto personDto = new PersonDto(
            person.firstName() + " " + person.lastName(),
            person.birthDate().toString(),
            person.skills()
        );
        return new EmployeeDto(employee.id(), personDto, employee.department());
    }
  
    // Adapted optics for API integration
    public static final Lens&lt;EmployeeDto, String&gt; API_EMPLOYEE_DEPARTMENT = 
        EmployeeLenses.department().dimap(
            ApiIntegration::dtoToEmployee,
            ApiIntegration::employeeToDto
        );
  
    public static final Lens&lt;EmployeeDto, String&gt; API_EMPLOYEE_FIRST_NAME = 
        EmployeeLenses.personalInfo()
            .andThen(PersonLenses.firstName())
            .dimap(
                ApiIntegration::dtoToEmployee,
                ApiIntegration::employeeToDto
            );
  
    public static final Traversal&lt;EmployeeDto, String&gt; API_EMPLOYEE_SKILLS = 
        EmployeeTraversals.personalInfo()
            .andThen(PersonTraversals.skills())
            .dimap(
                ApiIntegration::dtoToEmployee,
                ApiIntegration::employeeToDto
            );
  
    // Use the adapters seamlessly with external data
    public void processApiData(EmployeeDto externalEmployee) {
        // Update department using existing business logic
        EmployeeDto promoted = API_EMPLOYEE_DEPARTMENT.modify(
            dept -&gt; "Senior " + dept, 
            externalEmployee
        );
    
        // Normalise skills using existing traversal logic
        EmployeeDto normalisedSkills = Traversals.modify(
            API_EMPLOYEE_SKILLS,
            skill -&gt; skill.toLowerCase().trim(),
            externalEmployee
        );
    
        sendToApi(promoted);
        sendToApi(normalisedSkills);
    }
}
</code></pre>
<hr />
<h2 id="working-with-type-safe-wrappers"><a class="header" href="#working-with-type-safe-wrappers">Working with Type-Safe Wrappers</a></h2>
<p>Another powerful use case is adapting optics to work with strongly-typed wrapper classes while maintaining type safety.</p>
<p><strong>The Challenge</strong>: You want to use string manipulation functions on wrapper types:</p>
<pre><code class="language-java">// Strongly-typed wrappers
public record UserId(String value) {}
public record UserName(String value) {}
public record Email(String value) {}

@GenerateLenses
public record User(UserId id, UserName name, Email email, LocalDate createdAt) {}
</code></pre>
<p><strong>The Solution</strong>: Create adapted lenses that unwrap and rewrap values:</p>
<pre><code class="language-java">public class WrapperAdapters {
  
    // Generic wrapper lens creator
    public static &lt;W&gt; Lens&lt;W, String&gt; stringWrapperLens(
        Function&lt;W, String&gt; unwrap,
        Function&lt;String, W&gt; wrap
    ) {
        return Lens.of(unwrap, (wrapper, newValue) -&gt; wrap.apply(newValue));
    }
  
    // Specific wrapper lenses
    public static final Lens&lt;UserId, String&gt; USER_ID_STRING = 
        stringWrapperLens(UserId::value, UserId::new);
      
    public static final Lens&lt;UserName, String&gt; USER_NAME_STRING = 
        stringWrapperLens(UserName::value, UserName::new);
      
    public static final Lens&lt;Email, String&gt; EMAIL_STRING = 
        stringWrapperLens(Email::value, Email::new);
  
    // Composed lenses for User operations
    public static final Lens&lt;User, String&gt; USER_NAME_VALUE = 
        UserLenses.name().andThen(USER_NAME_STRING);
      
    public static final Lens&lt;User, String&gt; USER_EMAIL_VALUE = 
        UserLenses.email().andThen(EMAIL_STRING);
  
    // Usage examples
    public User normaliseUser(User userLogin) {
        return USER_NAME_VALUE.modify(name -&gt; 
            Arrays.stream(name.toLowerCase().split(" "))
                .map(word -&gt; Character.toUpperCase(word.charAt(0)) + word.substring(1))
                .collect(joining(" ")),
            userLogin
        );
    }
  
    public User updateEmailDomain(User userLogin, String newDomain) {
        return USER_EMAIL_VALUE.modify(email -&gt; {
            String localPart = email.substring(0, email.indexOf('@'));
            return localPart + "@" + newDomain;
        }, userLogin);
    }
}
</code></pre>
<hr />
<h2 id="migration-patterns"><a class="header" href="#migration-patterns">Migration Patterns</a></h2>
<p>Profunctor adaptations are particularly valuable during system migrations:</p>
<h3 id="legacy-system-integration"><a class="header" href="#legacy-system-integration">Legacy System Integration</a></h3>
<pre><code class="language-java">// You have optics for PersonV1, but data is now PersonV2
public record PersonV1(String name, int age) {}

@GenerateLenses
public record PersonV2(String firstName, String lastName, LocalDate birthDate) {}

public class MigrationAdapters {
  
    // Convert between versions
    private static PersonV1 v2ToV1(PersonV2 v2) {
        return new PersonV1(
            v2.firstName() + " " + v2.lastName(),
            Period.between(v2.birthDate(), LocalDate.now()).getYears()
        );
    }
  
    private static PersonV2 v1ToV2(PersonV1 v1) {
        String[] nameParts = v1.name().split(" ", 2);
        return new PersonV2(
            nameParts[0],
            nameParts.length &gt; 1 ? nameParts[1] : "",
            LocalDate.now().minusYears(v1.age())
        );
    }
  
    // Existing V1 optics work with V2 data
    public static final Lens&lt;PersonV2, String&gt; V2_NAME_FROM_V1_LENS = 
        // Assume we have a V1 name lens
        Lens.of(PersonV1::name, (p1, name) -&gt; new PersonV1(name, p1.age()))
            .dimap(MigrationAdapters::v2ToV1, MigrationAdapters::v1ToV2);
}
</code></pre>
<h3 id="database-schema-evolution"><a class="header" href="#database-schema-evolution">Database Schema Evolution</a></h3>
<pre><code class="language-java">// Old database entity
public record CustomerEntityV1(Long id, String name, String email) {}

// New database entity  
@GenerateLenses
public record CustomerEntityV2(Long id, String firstName, String lastName, String emailAddress, boolean active) {}

public class SchemaAdapters {
  
    // Adapter for name field
    public static final Lens&lt;CustomerEntityV2, String&gt; FULL_NAME_ADAPTER = 
        Lens.of(CustomerEntityV1::name, (v1, name) -&gt; new CustomerEntityV1(v1.id(), name, v1.email()))
            .dimap(
                // V2 -&gt; V1 conversion
                v2 -&gt; new CustomerEntityV1(v2.id(), v2.firstName() + " " + v2.lastName(), v2.emailAddress()),
                // V1 -&gt; V2 conversion  
                v1 -&gt; {
                    String[] parts = v1.name().split(" ", 2);
                    return new CustomerEntityV2(
                        v1.id(),
                        parts[0],
                        parts.length &gt; 1 ? parts[1] : "",
                        v1.email(),
                        true // Default active status
                    );
                }
            );
}
</code></pre>
<hr />
<h2 id="complete-runnable-example-9"><a class="header" href="#complete-runnable-example-9">Complete, Runnable Example</a></h2>
<p>This comprehensive example demonstrates all three profunctor operations in a realistic scenario:</p>
<pre><code class="language-java">package org.higherkindedj.example.optics.profunctor;

import org.higherkindedj.optics.Lens;
import org.higherkindedj.optics.Traversal;
import org.higherkindedj.optics.annotations.GenerateLenses;
import org.higherkindedj.optics.annotations.GenerateTraversals;
import org.higherkindedj.optics.util.Traversals;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.Optional;

public class OpticProfunctorExample {

    // Internal data model
    @GenerateLenses
    @GenerateTraversals
    public record Person(String firstName, String lastName, LocalDate birthDate, List&lt;String&gt; hobbies) {}
  
    @GenerateLenses
    public record Employee(int id, Person personalInfo, String department) {}
  
    // External API model
    @GenerateLenses
    public record PersonDto(String fullName, String birthDateString, List&lt;String&gt; interests) {}
  
    @GenerateLenses  
    public record EmployeeDto(int employeeId, PersonDto person, String dept) {}
  
    // Type-safe wrapper
    public record UserId(long value) {}
  
    @GenerateLenses
    public record UserProfile(UserId id, String displayName, boolean active) {}

    public static void main(String[] args) {
        System.out.println("=== PROFUNCTOR OPTICS EXAMPLE ===");
      
        // Test data
        var person = new Person("Alice", "Johnson", 
            LocalDate.of(1985, 6, 15), 
            List.of("reading", "cycling", "photography"));
        var employee = new Employee(123, person, "Engineering");
      
        // --- SCENARIO 1: contramap - Adapt source type ---
        System.out.println("--- Scenario 1: contramap (Source Adaptation) ---");
      
        // Original lens works on Person, adapt it for Employee
        Lens&lt;Person, String&gt; firstNameLens = PersonLenses.firstName();
        Lens&lt;Employee, String&gt; employeeFirstNameLens = 
            firstNameLens.contramap(Employee::personalInfo);
      
        String name = employeeFirstNameLens.get(employee);
        Employee renamedEmployee = employeeFirstNameLens.set("Alicia", employee);
      
        System.out.println("Original employee: " + employee);
        System.out.println("Extracted name: " + name);
        System.out.println("Renamed employee: " + renamedEmployee);
        System.out.println();
      
        // --- SCENARIO 2: map - Adapt target type ---
        System.out.println("--- Scenario 2: map (Target Adaptation) ---");
      
        // Original lens returns LocalDate, adapt it to return formatted string
        Lens&lt;Person, LocalDate&gt; birthDateLens = PersonLenses.birthDate();
        Lens&lt;Person, String&gt; birthDateStringLens = 
            birthDateLens.map(date -&gt; date.format(DateTimeFormatter.ISO_LOCAL_DATE));
      
        String formattedDate = birthDateStringLens.get(person);
        // Note: set operation would need to parse the string back to LocalDate
        System.out.println("Person: " + person);
        System.out.println("Formatted birth date: " + formattedDate);
        System.out.println();
      
        // --- SCENARIO 3: dimap - Adapt both source and target ---
        System.out.println("--- Scenario 3: dimap (Both Source and Target Adaptation) ---");
      
        // Convert between internal Person and external PersonDto
        Traversal&lt;Person, String&gt; hobbiesTraversal = PersonTraversals.hobbies();
        Traversal&lt;PersonDto, String&gt; interestsTraversal = hobbiesTraversal.dimap(
            // PersonDto -&gt; Person
            dto -&gt; {
                String[] nameParts = dto.fullName().split(" ", 2);
                return new Person(
                    nameParts[0],
                    nameParts.length &gt; 1 ? nameParts[1] : "",
                    LocalDate.parse(dto.birthDateString()),
                    dto.interests()
                );
            },
            // Person -&gt; PersonDto  
            p -&gt; new PersonDto(
                p.firstName() + " " + p.lastName(),
                p.birthDate().toString(),
                p.hobbies()
            )
        );
      
        var personDto = new PersonDto("Bob Smith", "1990-03-20", 
            List.of("gaming", "cooking", "travel"));
      
        List&lt;String&gt; extractedInterests = Traversals.getAll(interestsTraversal, personDto);
        PersonDto updatedDto = Traversals.modify(interestsTraversal, 
            interest -&gt; interest.toUpperCase(), personDto);
      
        System.out.println("Original DTO: " + personDto);
        System.out.println("Extracted interests: " + extractedInterests);
        System.out.println("Updated DTO: " + updatedDto);
        System.out.println();
      
        // --- SCENARIO 4: Working with wrapper types ---
        System.out.println("--- Scenario 4: Wrapper Type Integration ---");
      
        // Create a lens that works directly with the wrapped value
        Lens&lt;UserId, Long&gt; userIdValueLens = Lens.of(UserId::value, (id, newValue) -&gt; new UserId(newValue));
        Lens&lt;UserProfile, Long&gt; profileIdValueLens = 
            UserProfileLenses.id().andThen(userIdValueLens);
      
        var userProfile = new UserProfile(new UserId(456L), "Alice J.", true);
      
        Long idValue = profileIdValueLens.get(userProfile);
        UserProfile updatedProfile = profileIdValueLens.modify(id -&gt; id + 1000, userProfile);
      
        System.out.println("Original profile: " + userProfile);
        System.out.println("Extracted ID value: " + idValue);
        System.out.println("Updated profile: " + updatedProfile);
        System.out.println();
      
        // --- SCENARIO 5: Chaining adaptations ---
        System.out.println("--- Scenario 5: Chaining Adaptations ---");
      
        // Chain multiple adaptations: Employee -&gt; Person -&gt; String (formatted)
        Lens&lt;Employee, String&gt; formattedEmployeeName = 
            PersonLenses.firstName()
                .contramap(Employee::personalInfo)  // Employee -&gt; Person
                .map(name -&gt; "Mr/Ms. " + name.toUpperCase()); // String -&gt; Formatted String
      
        String formalName = formattedEmployeeName.get(employee);
        Employee formalEmployee = formattedEmployeeName.set("Mr/Ms. ROBERT", employee);
      
        System.out.println("Original employee: " + employee);
        System.out.println("Formal name: " + formalName);
        System.out.println("Employee with formal name: " + formalEmployee);
        System.out.println();
      
        // --- SCENARIO 6: Safe adaptations with Optional ---
        System.out.println("--- Scenario 6: Safe Adaptations ---");
      
        // Handle potentially null fields safely
        Lens&lt;Optional&lt;Person&gt;, Optional&lt;String&gt;&gt; safeNameLens = 
            PersonLenses.firstName()
                .map(Optional::of)
                .contramap(optPerson -&gt; optPerson.orElse(new Person("", "", LocalDate.now(), List.of())));
      
        Optional&lt;Person&gt; maybePerson = Optional.of(person);
        Optional&lt;Person&gt; emptyPerson = Optional.empty();
      
        Optional&lt;String&gt; safeName1 = safeNameLens.get(maybePerson);
        Optional&lt;String&gt; safeName2 = safeNameLens.get(emptyPerson);
      
        System.out.println("Safe name from present person: " + safeName1);
        System.out.println("Safe name from empty person: " + safeName2);
    }
}
</code></pre>
<p><strong>Expected Output:</strong></p>
<pre><code>=== PROFUNCTOR OPTICS EXAMPLE ===
--- Scenario 1: contramap (Source Adaptation) ---
Original employee: Employee[id=123, personalInfo=Person[firstName=Alice, lastName=Johnson, birthDate=1985-06-15, hobbies=[reading, cycling, photography]], department=Engineering]
Extracted name: Alice
Renamed employee: Employee[id=123, personalInfo=Person[firstName=Alicia, lastName=Johnson, birthDate=1985-06-15, hobbies=[reading, cycling, photography]], department=Engineering]

--- Scenario 2: map (Target Adaptation) ---
Person: Person[firstName=Alice, lastName=Johnson, birthDate=1985-06-15, hobbies=[reading, cycling, photography]]
Formatted birth date: 1985-06-15

--- Scenario 3: dimap (Both Source and Target Adaptation) ---
Original DTO: PersonDto[fullName=Bob Smith, birthDateString=1990-03-20, interests=[gaming, cooking, travel]]
Extracted interests: [gaming, cooking, travel]
Updated DTO: PersonDto[fullName=Bob Smith, birthDateString=1990-03-20, interests=[GAMING, COOKING, TRAVEL]]

--- Scenario 4: Wrapper Type Integration ---
Original profile: UserProfile[id=UserId[value=456], displayName=Alice J., active=true]
Extracted ID value: 456
Updated profile: UserProfile[id=UserId[value=1456], displayName=Alice J., active=true]

--- Scenario 5: Chaining Adaptations ---
Original employee: Employee[id=123, personalInfo=Person[firstName=Alice, lastName=Johnson, birthDate=1985-06-15, hobbies=[reading, cycling, photography]], department=Engineering]
Formal name: Mr/Ms. ALICE
Employee with formal name: Employee[id=123, personalInfo=Person[firstName=ROBERT, lastName=Johnson, birthDate=1985-06-15, hobbies=[reading, cycling, photography]], department=Engineering]

--- Scenario 6: Safe Adaptations ---
Safe name from present person: Optional[Alice]
Safe name from empty person: Optional[]
</code></pre>
<hr />
<h2 id="integration-with-existing-optics"><a class="header" href="#integration-with-existing-optics">Integration with Existing Optics</a></h2>
<p>Profunctor adaptations work seamlessly with all the optic types and features you've already learned:</p>
<h3 id="with-effectful-updates"><a class="header" href="#with-effectful-updates">With Effectful Updates</a></h3>
<pre><code class="language-java">// Original effectful lens
Lens&lt;Person, String&gt; emailLens = PersonLenses.email();

// Adapt it for Employee and use with validation
Lens&lt;Employee, String&gt; employeeEmailLens = emailLens.contramap(Employee::personalInfo);

// Use with effectful validation as normal
Kind&lt;ValidatedKind.Witness&lt;String&gt;, Employee&gt; result = 
    employeeEmailLens.modifyF(this::validateEmail, employee, validatedApplicative);
</code></pre>
<h3 id="with-deep-composition"><a class="header" href="#with-deep-composition">With Deep Composition</a></h3>
<pre><code class="language-java">// Compose adapted optics just like regular optics
Traversal&lt;EmployeeDto, String&gt; deepPath = 
    apiAdapter.asTraversal()
        .andThen(PersonTraversals.hobbies())
        .andThen(stringProcessor);
</code></pre>
<p>This profunctor capability makes higher-kinded-j optics incredibly flexible and reusable, allowing you to adapt existing, well-tested optics to work with new data formats and requirements without rewriting your core business logic.</p>
<hr />
<p><strong>Previous:</strong> <a href="optics/setters.html">Setters: Composable Write-Only Modifications</a>
<strong>Next:</strong> <a href="optics/composing_optics.html">Capstone Example: Deep Validation</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="capstone-example"><a class="header" href="#capstone-example">Capstone Example:</a></h1>
<h2 id="composing-optics-for-deep-validation"><a class="header" href="#composing-optics-for-deep-validation"><em>Composing Optics for Deep Validation</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="optics/composing_optics.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to compose multiple optic types into powerful processing pipelines</li>
<li>Building type-safe validation workflows with error accumulation</li>
<li>Using <code>asTraversal()</code> to ensure safe optic composition</li>
<li>Creating reusable validation paths with effectful operations</li>
<li>Simplified validation with <code>modifyAllValidated</code>, <code>modifyAllEither</code>, and <code>modifyMaybe</code></li>
<li>Understanding when composition is superior to manual validation logic</li>
<li>Advanced patterns for multi-level and conditional validation scenarios</li>
</ul>
</div>
</div>
<div id="admonition-example-code" class="admonition admonish-note" role="note" aria-labelledby="admonition-example-code-title">
<div class="admonition-title">
<div id="admonition-example-code-title">
<p>Example Code</p>
</div>
<a class="admonition-anchor-link" href="optics/composing_optics.html#admonition-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/ValidatedTraversalExample.java">ValidatedTraversalExample</a></p>
</div>
</div>
<p>In the previous guides, we explored each core optic‚Äî<code>Lens</code>, <code>Prism</code>, <code>Iso</code> and <code>Traversal</code>‚Äîas individual tools. We've seen how they provide focused, reusable, and composable access to immutable data.</p>
<p>Now, it's time to put it all together.</p>
<p>This guide showcases the true power of the optics approach by composing multiple different optics to solve a single, complex, real-world problem: performing deep, effectful validation on a nested data structure.</p>
<hr />
<h2 id="the-scenario-validating-user-permissions"><a class="header" href="#the-scenario-validating-user-permissions">The Scenario: Validating User Permissions</a></h2>
<p>Imagine a data model for a form that can be filled out by either a registered <code>User</code> or a <code>Guest</code>. Our goal is to validate that every <code>Permission</code> held by a <code>User</code> has a valid name.</p>
<p>This single task requires us to:</p>
<ol>
<li>Focus on the form's <code>principal</code> field (<strong>a job for a Lens</strong>).</li>
<li>Safely "select" the <code>User</code> case, ignoring any <code>Guest</code>s (<strong>a job for a Prism</strong>).</li>
<li>Operate on every <code>Permission</code> in the userLogin's list (<strong>a job for a Traversal</strong>).</li>
</ol>
<hr />
<h2 id="think-of-this-composition-like"><a class="header" href="#think-of-this-composition-like">Think of This Composition Like...</a></h2>
<ul>
<li><strong>A telescope with multiple lenses</strong>: Each optic focuses deeper into the data structure</li>
<li><strong>A manufacturing pipeline</strong>: Each stage processes and refines the data further</li>
<li><strong>A filter chain</strong>: Data flows through multiple filters, each handling a specific concern</li>
<li><strong>A surgical procedure</strong>: Precise, layered operations that work together for a complex outcome</li>
</ul>
<hr />
<h3 id="1-the-data-model"><a class="header" href="#1-the-data-model">1. The Data Model</a></h3>
<p>Here is the nested data structure, annotated to generate all the optics we will need.</p>
<pre><code class="language-java">import org.higherkindedj.optics.annotations.GenerateLenses;
import org.higherkindedj.optics.annotations.GeneratePrisms;
import org.higherkindedj.optics.annotations.GenerateTraversals;
import java.util.List;

@GenerateLenses
public record Permission(String name) {}

@GeneratePrisms
public sealed interface Principal {}

@GenerateLenses
@GenerateTraversals
public record User(String username, List&lt;Permission&gt; permissions) implements Principal {}

public record Guest() implements Principal {}

@GenerateLenses
public record Form(int formId, Principal principal) {}
</code></pre>
<h3 id="2-the-validation-logic"><a class="header" href="#2-the-validation-logic">2. The Validation Logic</a></h3>
<p>Our validation function will take a permission name (<code>String</code>) and return a <code>Validated&lt;String, String&gt;</code>. The <code>Validated</code> applicative functor will automatically handle accumulating any errors found.</p>
<pre><code class="language-java">import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.validated.Validated;
import org.higherkindedj.hkt.validated.ValidatedKind;
import static org.higherkindedj.hkt.validated.ValidatedKindHelper.VALIDATED;
import java.util.Set;

private static final Set&lt;String&gt; VALID_PERMISSIONS = Set.of("PERM_READ", "PERM_WRITE", "PERM_DELETE");

public static Kind&lt;ValidatedKind.Witness&lt;String&gt;, String&gt; validatePermissionName(String name) {
    if (VALID_PERMISSIONS.contains(name)) {
        return VALIDATED.widen(Validated.valid(name));
    } else {
        return VALIDATED.widen(Validated.invalid("Invalid permission: " + name));
    }
}
</code></pre>
<h3 id="3-understanding-the-composition-strategy"><a class="header" href="#3-understanding-the-composition-strategy">3. Understanding the Composition Strategy</a></h3>
<p>Before diving into the code, let's understand why we need each type of optic and how they work together:</p>
<p><strong>Why a Lens for <code>principal</code>?</strong></p>
<ul>
<li>The <code>principal</code> field always exists in a <code>Form</code></li>
<li>We need guaranteed access to focus on this field</li>
<li>A <code>Lens</code> provides exactly this: reliable access to required data</li>
</ul>
<p><strong>Why a Prism for <code>User</code>?</strong></p>
<ul>
<li>The <code>principal</code> could be either a <code>User</code> or a <code>Guest</code></li>
<li>We only want to validate <code>User</code> permissions, ignoring <code>Guest</code>s</li>
<li>A <code>Prism</code> provides safe, optional access to specific sum type cases</li>
</ul>
<p><strong>Why a Traversal for <code>permissions</code>?</strong></p>
<ul>
<li>We need to validate <em>every</em> permission in the list</li>
<li>We want to accumulate <em>all</em> validation errors, not stop at the first one</li>
<li>A <code>Traversal</code> provides bulk operations over collections</li>
</ul>
<p><strong>Why convert everything to <code>Traversal</code>?</strong></p>
<ul>
<li><code>Traversal</code> is the most general optic type</li>
<li>It can represent zero-or-more targets (perfect for our "might be empty" scenario)</li>
<li>All other optics can be converted to <code>Traversal</code> for seamless composition</li>
</ul>
<h3 id="4-composing-the-master-optic"><a class="header" href="#4-composing-the-master-optic">4. Composing the Master Optic</a></h3>
<p>Now for the main event. We will compose our generated optics to create a single <code>Traversal</code> that declaratively represents the path from a <code>Form</code> all the way down to each permission <code>name</code>. While the new <code>with*</code> helpers are great for simple, shallow updates, a deep and conditional update like this requires composition.</p>
<p>To ensure type-safety across different optic types, we convert each <code>Lens</code> and <code>Prism</code> in the chain to a <code>Traversal</code> using the <code>.asTraversal()</code> method.</p>
<pre><code class="language-java">import org.higherkindedj.optics.Lens;
import org.higherkindedj.optics.Prism;
import org.higherkindedj.optics.Traversal;

// Get the individual generated optics
Lens&lt;Form, Principal&gt; formPrincipalLens = FormLenses.principal();
Prism&lt;Principal, User&gt; principalUserPrism = PrincipalPrisms.userLogin();
Traversal&lt;User, Permission&gt; userPermissionsTraversal = UserTraversals.permissions();
Lens&lt;Permission, String&gt; permissionNameLens = PermissionLenses.name();

// Compose them into a single, deep Traversal
Traversal&lt;Form, String&gt; formToPermissionNameTraversal =
    formPrincipalLens.asTraversal()
        .andThen(principalUserPrism.asTraversal())
        .andThen(userPermissionsTraversal)
        .andThen(permissionNameLens.asTraversal());
</code></pre>
<p>This single <code>formToPermissionNameTraversal</code> object now encapsulates the entire complex path.</p>
<hr />
<h2 id="when-to-use-optic-composition-vs-other-approaches"><a class="header" href="#when-to-use-optic-composition-vs-other-approaches">When to Use Optic Composition vs Other Approaches</a></h2>
<h3 id="use-optic-composition-when"><a class="header" href="#use-optic-composition-when">Use Optic Composition When:</a></h3>
<ul>
<li><strong>Complex nested validation</strong> - Multiple levels of data structure with conditional logic</li>
<li><strong>Reusable validation paths</strong> - The same validation logic applies to multiple scenarios</li>
<li><strong>Type-safe bulk operations</strong> - You need to ensure compile-time safety for collection operations</li>
<li><strong>Error accumulation</strong> - You want to collect all errors, not stop at the first failure</li>
</ul>
<pre><code class="language-java">// Perfect for reusable, complex validation
Traversal&lt;Company, String&gt; allEmployeeEmails = 
    CompanyTraversals.departments()
        .andThen(DepartmentTraversals.employees())
        .andThen(EmployeePrisms.active().asTraversal())  // Only active employees
        .andThen(EmployeeLenses.email().asTraversal());

// Use across multiple validation scenarios
Validated&lt;List&lt;String&gt;, Company&gt; result1 = validateEmails(company1);
Validated&lt;List&lt;String&gt;, Company&gt; result2 = validateEmails(company2);
</code></pre>
<h3 id="use-direct-validation-when"><a class="header" href="#use-direct-validation-when">Use Direct Validation When:</a></h3>
<ul>
<li><strong>Simple, flat structures</strong> - No deep nesting or conditional access needed</li>
<li><strong>One-off validation</strong> - Logic won't be reused elsewhere</li>
<li><strong>Performance critical</strong> - Minimal abstraction overhead required</li>
</ul>
<pre><code class="language-java">// Simple validation doesn't need optics
public Validated&lt;String, User&gt; validateUser(User userLogin) {
    if (userLogin.username().length() &lt; 3) {
        return Validated.invalid("Username too short");
    }
    return Validated.valid(userLogin);
}
</code></pre>
<h3 id="use-stream-processing-when"><a class="header" href="#use-stream-processing-when">Use Stream Processing When:</a></h3>
<ul>
<li><strong>Complex transformations</strong> - Multiple operations that don't map to optic patterns</li>
<li><strong>Aggregation logic</strong> - Computing statistics or summaries</li>
<li><strong>Filtering and collecting</strong> - Changing the structure of collections</li>
</ul>
<pre><code class="language-java">// Better with streams for aggregation
Map&lt;String, Long&gt; permissionCounts = forms.stream()
    .map(Form::principal)
    .filter(User.class::isInstance)
    .map(User.class::cast)
    .flatMap(userLogin -&gt; userLogin.permissions().stream())
    .collect(groupingBy(Permission::name, counting()));
</code></pre>
<hr />
<h2 id="common-pitfalls-14"><a class="header" href="#common-pitfalls-14">Common Pitfalls</a></h2>
<h3 id="-dont-do-this-10"><a class="header" href="#-dont-do-this-10">‚ùå Don't Do This:</a></h3>
<pre><code class="language-java">// Over-composing simple cases
Traversal&lt;Form, Integer&gt; formIdTraversal = FormLenses.formId().asTraversal();
// Just use: form.formId()

// Forgetting error accumulation setup
// This won't accumulate errors properly without the right Applicative
var badResult = traversal.modifyF(validatePermissionName, form, /* wrong applicative */);

// Creating complex compositions inline
var inlineResult = FormLenses.principal().asTraversal()
    .andThen(PrincipalPrisms.userLogin().asTraversal())
    .andThen(UserTraversals.permissions())
    .andThen(PermissionLenses.name().asTraversal())
    .modifyF(validatePermissionName, form, applicative); // Hard to read and reuse

// Ignoring the path semantics
// This tries to validate ALL strings, not just permission names
Traversal&lt;Form, String&gt; badTraversal = /* any string traversal */;
</code></pre>
<h3 id="-do-this-instead-10"><a class="header" href="#-do-this-instead-10">‚úÖ Do This Instead:</a></h3>
<pre><code class="language-java">// Use direct access for simple cases
int formId = form.formId(); // Clear and direct

// Set up error accumulation properly
Applicative&lt;ValidatedKind.Witness&lt;String&gt;&gt; validatedApplicative =
    ValidatedMonad.instance(Semigroups.string("; "));

// Create reusable, well-named compositions
public static final Traversal&lt;Form, String&gt; FORM_TO_PERMISSION_NAMES =
    FormLenses.principal().asTraversal()
        .andThen(PrincipalPrisms.userLogin().asTraversal())
        .andThen(UserTraversals.permissions())
        .andThen(PermissionLenses.name().asTraversal());

// Use the well-named traversal
var result = FORM_TO_PERMISSION_NAMES.modifyF(validatePermissionName, form, validatedApplicative);

// Be specific about what you're validating
// This traversal has clear semantics: Form -&gt; User permissions -&gt; permission names
</code></pre>
<hr />
<h2 id="performance-notes-10"><a class="header" href="#performance-notes-10">Performance Notes</a></h2>
<p>Optic composition is designed for efficiency:</p>
<ul>
<li><strong>Lazy evaluation</strong>: Only processes data when actually used</li>
<li><strong>Structural sharing</strong>: Unchanged parts of data structures are reused</li>
<li><strong>Single-pass processing</strong>: <code>modifyF</code> traverses the structure only once</li>
<li><strong>Memory efficient</strong>: Only creates new objects for changed data</li>
<li><strong>JIT compiler optimisation</strong>: Complex compositions are optimised by the JVM's just-in-time compiler through method inlining</li>
</ul>
<p><strong>Best Practice</strong>: Create composed optics as constants for reuse:</p>
<pre><code class="language-java">public class ValidationOptics {
    // Reusable validation paths
    public static final Traversal&lt;Form, String&gt; USER_PERMISSION_NAMES =
        FormLenses.principal().asTraversal()
            .andThen(PrincipalPrisms.userLogin().asTraversal())
            .andThen(UserTraversals.permissions())
            .andThen(PermissionLenses.name().asTraversal());
  
    public static final Traversal&lt;Company, String&gt; EMPLOYEE_EMAILS =
        CompanyTraversals.employees()
            .andThen(EmployeeLenses.contactInfo().asTraversal())
            .andThen(ContactInfoLenses.email().asTraversal());
  
    // Helper methods for common validations
    public static Validated&lt;List&lt;String&gt;, Form&gt; validatePermissions(Form form) {
        return VALIDATED.narrow(USER_PERMISSION_NAMES.modifyF(
            ValidationOptics::validatePermissionName,
            form,
            getValidatedApplicative()
        ));
    }
}
</code></pre>
<hr />
<h2 id="advanced-composition-patterns"><a class="header" href="#advanced-composition-patterns">Advanced Composition Patterns</a></h2>
<h3 id="1-multi-level-validation"><a class="header" href="#1-multi-level-validation">1. Multi-Level Validation</a></h3>
<pre><code class="language-java">// Validate both userLogin data AND permissions in one pass
public static Validated&lt;List&lt;String&gt;, Form&gt; validateFormCompletely(Form form) {
    // First validate userLogin basic info
    var userValidation = FormLenses.principal().asTraversal()
        .andThen(PrincipalPrisms.userLogin().asTraversal())
        .andThen(UserLenses.username().asTraversal())
        .modifyF(ValidationOptics::validateUsername, form, getValidatedApplicative());
  
    // Then validate permissions
    var permissionValidation = FORM_TO_PERMISSION_NAMES
        .modifyF(ValidationOptics::validatePermissionName, form, getValidatedApplicative());
  
    // Combine both validations
    return VALIDATED.narrow(getValidatedApplicative().map2(
        userValidation,
        permissionValidation,
        (validForm1, validForm2) -&gt; validForm2 // Return the final form
    ));
}
</code></pre>
<h3 id="2-conditional-validation-paths"><a class="header" href="#2-conditional-validation-paths">2. Conditional Validation Paths</a></h3>
<pre><code class="language-java">// Different validation rules for different userLogin types
public static final Traversal&lt;Form, String&gt; ADMIN_USER_PERMISSIONS =
    FormLenses.principal().asTraversal()
        .andThen(PrincipalPrisms.userLogin().asTraversal())
        .andThen(UserPrisms.adminUser().asTraversal())  // Only admin users
        .andThen(AdminUserTraversals.permissions())
        .andThen(PermissionLenses.name().asTraversal());

public static final Traversal&lt;Form, String&gt; REGULAR_USER_PERMISSIONS =
    FormLenses.principal().asTraversal()
        .andThen(PrincipalPrisms.userLogin().asTraversal())
        .andThen(UserPrisms.regularUser().asTraversal())  // Only regular users
        .andThen(RegularUserTraversals.permissions())
        .andThen(PermissionLenses.name().asTraversal());
</code></pre>
<h3 id="3-cross-field-validation"><a class="header" href="#3-cross-field-validation">3. Cross-Field Validation</a></h3>
<pre><code class="language-java">// Validate that permissions are appropriate for userLogin role
public static Validated&lt;List&lt;String&gt;, Form&gt; validatePermissionsForRole(Form form) {
    return FormLenses.principal().asTraversal()
        .andThen(PrincipalPrisms.userLogin().asTraversal())
        .modifyF(userLogin -&gt; {
            // Custom validation that checks both role and permissions
            Set&lt;String&gt; allowedPerms = getAllowedPermissionsForRole(userLogin.role());
            List&lt;String&gt; errors = userLogin.permissions().stream()
                .map(Permission::name)
                .filter(perm -&gt; !allowedPerms.contains(perm))
                .map(perm -&gt; "Permission '" + perm + "' not allowed for role " + userLogin.role())
                .toList();
          
            return errors.isEmpty() 
                ? VALIDATED.widen(Validated.valid(userLogin))
                : VALIDATED.widen(Validated.invalid(String.join("; ", errors)));
        }, form, getValidatedApplicative());
}
</code></pre>
<hr />
<h2 id="complete-runnable-example-10"><a class="header" href="#complete-runnable-example-10">Complete, Runnable Example</a></h2>
<p>With our composed <code>Traversal</code>, we can now use <code>modifyF</code> to run our validation logic. The <code>Traversal</code> handles the navigation and filtering, while the <code>Validated</code> applicative (created with a <code>Semigroup</code> for joining error strings) handles the effects and error accumulation.</p>
<pre><code class="language-java">package org.higherkindedj.example.optics;

import static org.higherkindedj.hkt.validated.ValidatedKindHelper.VALIDATED;

import java.util.List;
import java.util.Set;
import org.higherkindedj.hkt.Applicative;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.Semigroups;
import org.higherkindedj.hkt.validated.Validated;
import org.higherkindedj.hkt.validated.ValidatedKind;
import org.higherkindedj.hkt.validated.ValidatedMonad;
import org.higherkindedj.optics.Lens;
import org.higherkindedj.optics.Prism;
import org.higherkindedj.optics.Traversal;
import org.higherkindedj.optics.annotations.GenerateLenses;
import org.higherkindedj.optics.annotations.GeneratePrisms;
import org.higherkindedj.optics.annotations.GenerateTraversals;

public class ValidatedTraversalExample {

    // --- Data Model ---
    @GenerateLenses
    public record Permission(String name) {}

    @GeneratePrisms
    public sealed interface Principal {}

    @GenerateLenses
    @GenerateTraversals
    public record User(String username, List&lt;Permission&gt; permissions) implements Principal {}

    public record Guest() implements Principal {}

    @GenerateLenses
    public record Form(int formId, Principal principal) {}

    // --- Validation Logic ---
    private static final Set&lt;String&gt; VALID_PERMISSIONS = Set.of("PERM_READ", "PERM_WRITE", "PERM_DELETE");

    public static Kind&lt;ValidatedKind.Witness&lt;String&gt;, String&gt; validatePermissionName(String name) {
        if (VALID_PERMISSIONS.contains(name)) {
            return VALIDATED.widen(Validated.valid(name));
        } else {
            return VALIDATED.widen(Validated.invalid("Invalid permission: " + name));
        }
    }

    // --- Reusable Optic Compositions ---
    public static final Traversal&lt;Form, String&gt; FORM_TO_PERMISSION_NAMES =
            FormLenses.principal().asTraversal()
                    .andThen(PrincipalPrisms.userLogin().asTraversal())
                    .andThen(UserTraversals.permissions())
                    .andThen(PermissionLenses.name().asTraversal());

    // --- Helper Methods ---
    private static Applicative&lt;ValidatedKind.Witness&lt;String&gt;&gt; getValidatedApplicative() {
        return ValidatedMonad.instance(Semigroups.string("; "));
    }

    public static Validated&lt;String, Form&gt; validateFormPermissions(Form form) {
        Kind&lt;ValidatedKind.Witness&lt;String&gt;, Form&gt; result =
                FORM_TO_PERMISSION_NAMES.modifyF(
                        ValidatedTraversalExample::validatePermissionName,
                        form,
                        getValidatedApplicative()
                );
        return VALIDATED.narrow(result);
    }

    public static void main(String[] args) {
        System.out.println("=== OPTIC COMPOSITION VALIDATION EXAMPLE ===");
        System.out.println();

        // --- SCENARIO 1: Form with valid permissions ---
        System.out.println("--- Scenario 1: Valid Permissions ---");
        var validUser = new User("alice", List.of(
                new Permission("PERM_READ"),
                new Permission("PERM_WRITE")
        ));
        var validForm = new Form(1, validUser);

        System.out.println("Input: " + validForm);
        Validated&lt;String, Form&gt; validResult = validateFormPermissions(validForm);
        System.out.println("Result: " + validResult);
        System.out.println();

        // --- SCENARIO 2: Form with multiple invalid permissions ---
        System.out.println("--- Scenario 2: Multiple Invalid Permissions ---");
        var invalidUser = new User("charlie", List.of(
                new Permission("PERM_EXECUTE"),  // Invalid
                new Permission("PERM_WRITE"),    // Valid
                new Permission("PERM_SUDO"),     // Invalid
                new Permission("PERM_READ")      // Valid
        ));
        var multipleInvalidForm = new Form(3, invalidUser);

        System.out.println("Input: " + multipleInvalidForm);
        Validated&lt;String, Form&gt; invalidResult = validateFormPermissions(multipleInvalidForm);
        System.out.println("Result (errors accumulated): " + invalidResult);
        System.out.println();

        // --- SCENARIO 3: Form with Guest principal (no targets for traversal) ---
        System.out.println("--- Scenario 3: Guest Principal (No Validation Targets) ---");
        var guestForm = new Form(4, new Guest());

        System.out.println("Input: " + guestForm);
        Validated&lt;String, Form&gt; guestResult = validateFormPermissions(guestForm);
        System.out.println("Result (path does not match): " + guestResult);
        System.out.println();

        // --- SCENARIO 4: Form with empty permissions list ---
        System.out.println("--- Scenario 4: Empty Permissions List ---");
        var emptyPermissionsUser = new User("diana", List.of());
        var emptyPermissionsForm = new Form(5, emptyPermissionsUser);

        System.out.println("Input: " + emptyPermissionsForm);
        Validated&lt;String, Form&gt; emptyResult = validateFormPermissions(emptyPermissionsForm);
        System.out.println("Result (empty list): " + emptyResult);
        System.out.println();

        // --- SCENARIO 5: Demonstrating optic reusability ---
        System.out.println("--- Scenario 5: Optic Reusability ---");

        List&lt;Form&gt; formsToValidate = List.of(validForm, multipleInvalidForm, guestForm);

        System.out.println("Batch validation results:");
        formsToValidate.forEach(form -&gt; {
            Validated&lt;String, Form&gt; result = validateFormPermissions(form);
            String status = result.isValid() ? "‚úì VALID" : "‚úó INVALID";
            System.out.println("  Form " + form.formId() + ": " + status);
            if (result.isInvalid()) {
                // Fix: Use getError() instead of getInvalid()
                System.out.println("    Errors: " + result.getError());
            }
        });
        System.out.println();

        // --- SCENARIO 6: Alternative validation with different error accumulation ---
        System.out.println("--- Scenario 6: Different Error Accumulation Strategy ---");

        // Use list-based error accumulation instead of string concatenation
        Applicative&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;&gt; listApplicative =
                ValidatedMonad.instance(Semigroups.list());

        // Fix: Create a proper function for list validation
        java.util.function.Function&lt;String, Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, String&gt;&gt; listValidation =
                name -&gt; VALID_PERMISSIONS.contains(name)
                        ? VALIDATED.widen(Validated.valid(name))
                        : VALIDATED.widen(Validated.invalid(List.of("Invalid permission: " + name)));

        Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Form&gt; listResult =
                FORM_TO_PERMISSION_NAMES.modifyF(listValidation, multipleInvalidForm, listApplicative);

        System.out.println("Input: " + multipleInvalidForm);
        System.out.println("Result with list accumulation: " + VALIDATED.narrow(listResult));
    }
}
</code></pre>
<p><strong>Expected Output:</strong></p>
<pre><code>=== OPTIC COMPOSITION VALIDATION EXAMPLE ===

--- Scenario 1: Valid Permissions ---
Input: Form[formId=1, principal=User[username=alice, permissions=[Permission[name=PERM_READ], Permission[name=PERM_WRITE]]]]
Result: Valid(Form[formId=1, principal=User[username=alice, permissions=[Permission[name=PERM_READ], Permission[name=PERM_WRITE]]]])

--- Scenario 2: Multiple Invalid Permissions ---
Input: Form[formId=3, principal=User[username=charlie, permissions=[Permission[name=PERM_EXECUTE], Permission[name=PERM_WRITE], Permission[name=PERM_SUDO], Permission[name=PERM_READ]]]]
Result (errors accumulated): Invalid(Invalid permission: PERM_EXECUTE; Invalid permission: PERM_SUDO)

--- Scenario 3: Guest Principal (No Validation Targets) ---
Input: Form[formId=4, principal=Guest[]]
Result (path does not match): Valid(Form[formId=4, principal=Guest[]])

--- Scenario 4: Empty Permissions List ---
Input: Form[formId=5, principal=User[username=diana, permissions=[]]]
Result (empty list): Valid(Form[formId=5, principal=User[username=diana, permissions=[]]])

--- Scenario 5: Optic Reusability ---
Batch validation results:
  Form 1: ‚úì VALID
  Form 3: ‚úó INVALID
    Errors: Invalid permission: PERM_EXECUTE; Invalid permission: PERM_SUDO
  Form 4: ‚úì VALID

--- Scenario 6: Different Error Accumulation Strategy ---
Input: Form[formId=3, principal=User[username=charlie, permissions=[Permission[name=PERM_EXECUTE], Permission[name=PERM_WRITE], Permission[name=PERM_SUDO], Permission[name=PERM_READ]]]]
Result with list accumulation: Invalid([Invalid permission: PERM_EXECUTE, Invalid permission: PERM_SUDO])
</code></pre>
<p>This shows how our single, composed optic correctly handled all cases: it accumulated multiple failures into a single <code>Invalid</code> result, and it correctly did nothing (resulting in a <code>Valid</code> state) when the path did not match. This is the power of composing simple, reusable optics to solve complex problems in a safe, declarative, and boilerplate-free way.</p>
<hr />
<h2 id="why-this-approach-is-powerful"><a class="header" href="#why-this-approach-is-powerful">Why This Approach is Powerful</a></h2>
<p>This capstone example demonstrates several key advantages of the optics approach:</p>
<h3 id="declarative-composition"><a class="header" href="#declarative-composition"><strong>Declarative Composition</strong></a></h3>
<p>The <code>formToPermissionNameTraversal</code> reads like a clear path specification: "From a Form, go to the principal, if it's a User, then to each permission, then to each name." This is self-documenting code.</p>
<h3 id="type-safety"><a class="header" href="#type-safety"><strong>Type Safety</strong></a></h3>
<p>Every step in the composition is checked at compile time. It's impossible to accidentally apply permission validation to Guest data or to skip the User filtering step.</p>
<h3 id="automatic-error-accumulation"><a class="header" href="#automatic-error-accumulation"><strong>Automatic Error Accumulation</strong></a></h3>
<p>The <code>Validated</code> applicative automatically collects all validation errors without us having to write any error-handling boilerplate. We get comprehensive validation reports for free.</p>
<h3 id="reusability"><a class="header" href="#reusability"><strong>Reusability</strong></a></h3>
<p>The same composed optic can be used for validation, data extraction, transformation, or any other operation. We write the path once and reuse it everywhere.</p>
<h3 id="composability"><a class="header" href="#composability"><strong>Composability</strong></a></h3>
<p>Each individual optic (Lens, Prism, Traversal) can be tested and reasoned about independently, then composed to create more complex behaviour.</p>
<h3 id="graceful-handling-of-edge-cases"><a class="header" href="#graceful-handling-of-edge-cases"><strong>Graceful Handling of Edge Cases</strong></a></h3>
<p>The composition automatically handles empty collections, missing data, and type mismatches without special case code.</p>
<p>By mastering optic composition, you gain a powerful tool for building robust, maintainable data processing pipelines that are both expressive and efficient.</p>
<hr />
<h2 id="modern-simplification-validation-aware-methods"><a class="header" href="#modern-simplification-validation-aware-methods">Modern Simplification: Validation-Aware Methods</a></h2>
<div id="admonition-enhanced-validation-patterns" class="admonition admonish-tip" role="note" aria-labelledby="admonition-enhanced-validation-patterns-title">
<div class="admonition-title">
<div id="admonition-enhanced-validation-patterns-title">
<p>Enhanced Validation Patterns</p>
</div>
<a class="admonition-anchor-link" href="optics/composing_optics.html#admonition-enhanced-validation-patterns"></a>
</div>
<div>
<p>Higher-kinded-j provides specialised validation methods that simplify the patterns shown above. These methods eliminate the need for explicit <code>Applicative</code> setup whilst maintaining full type safety and error accumulation capabilities.</p>
</div>
</div>
<h3 id="the-traditional-approach-revisited"><a class="header" href="#the-traditional-approach-revisited">The Traditional Approach (Revisited)</a></h3>
<p>In the examples above, we used the general <code>modifyF</code> method with explicit <code>Applicative</code> configuration:</p>
<pre><code class="language-java">// Traditional approach: requires explicit Applicative setup
Applicative&lt;ValidatedKind.Witness&lt;String&gt;&gt; applicative =
    ValidatedMonad.instance(Semigroups.string("; "));

Kind&lt;ValidatedKind.Witness&lt;String&gt;, Form&gt; result =
    FORM_TO_PERMISSION_NAMES.modifyF(
        ValidatedTraversalExample::validatePermissionName,
        form,
        applicative
    );

Validated&lt;String, Form&gt; validated = VALIDATED.narrow(result);
</code></pre>
<p>Whilst powerful and flexible, this approach requires:</p>
<ul>
<li>Understanding of <code>Applicative</code> functors</li>
<li>Manual creation of the <code>Applicative</code> instance</li>
<li>Explicit narrowing of <code>Kind</code> results</li>
<li>Knowledge of <code>Witness</code> types and HKT encoding</li>
</ul>
<h3 id="the-simplified-approach-validation-aware-methods"><a class="header" href="#the-simplified-approach-validation-aware-methods">The Simplified Approach: Validation-Aware Methods</a></h3>
<p>The new validation-aware methods provide a more direct API for common validation patterns:</p>
<h4 id="1-error-accumulation-with-modifyallvalidated"><a class="header" href="#1-error-accumulation-with-modifyallvalidated">1. <strong>Error Accumulation with <code>modifyAllValidated</code></strong></a></h4>
<p>Simplifies the most common case: validating multiple fields and accumulating all errors.</p>
<pre><code class="language-java">import static org.higherkindedj.optics.fluent.OpticOps.modifyAllValidated;

// Simplified: direct Validated result, automatic error accumulation
Validated&lt;List&lt;String&gt;, Form&gt; result = modifyAllValidated(
    FORM_TO_PERMISSION_NAMES,
    name -&gt; VALID_PERMISSIONS.contains(name)
        ? Validated.valid(name)
        : Validated.invalid(List.of("Invalid permission: " + name)),
    form
);
</code></pre>
<p><strong>Benefits:</strong></p>
<ul>
<li>No <code>Applicative</code> setup required</li>
<li>Direct <code>Validated</code> result (no <code>Kind</code> wrapping)</li>
<li>Automatic error accumulation with <code>List&lt;E&gt;</code></li>
<li>Clear intent: "validate all and collect errors"</li>
</ul>
<h4 id="2-short-circuit-validation-with-modifyalleither"><a class="header" href="#2-short-circuit-validation-with-modifyalleither">2. <strong>Short-Circuit Validation with <code>modifyAllEither</code></strong></a></h4>
<p>For performance-critical validation that stops at the first error:</p>
<pre><code class="language-java">import static org.higherkindedj.optics.fluent.OpticOps.modifyAllEither;

// Short-circuit: stops at first error
Either&lt;String, Form&gt; result = modifyAllEither(
    FORM_TO_PERMISSION_NAMES,
    name -&gt; VALID_PERMISSIONS.contains(name)
        ? Either.right(name)
        : Either.left("Invalid permission: " + name),
    form
);
</code></pre>
<p><strong>Benefits:</strong></p>
<ul>
<li>Stops processing on first error (performance optimisation)</li>
<li>Direct <code>Either</code> result</li>
<li>Perfect for fail-fast validation</li>
<li>No unnecessary computation after failure</li>
</ul>
<h3 id="comparison-traditional-vs-validation-aware-methods"><a class="header" href="#comparison-traditional-vs-validation-aware-methods">Comparison: Traditional vs Validation-Aware Methods</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th>Traditional <code>modifyF</code></th><th>Validation-Aware Methods</th></tr></thead><tbody>
<tr><td><strong>Applicative Setup</strong></td><td>‚úÖ Required (explicit)</td><td>‚ùå Not required (automatic)</td></tr>
<tr><td><strong>Type Complexity</strong></td><td>‚ö†Ô∏è High (<code>Kind</code>, <code>Witness</code>)</td><td>‚úÖ Low (direct types)</td></tr>
<tr><td><strong>Error Accumulation</strong></td><td>‚úÖ Yes (via Applicative)</td><td>‚úÖ Yes (<code>modifyAllValidated</code>)</td></tr>
<tr><td><strong>Short-Circuiting</strong></td><td>‚ö†Ô∏è Manual (via Either Applicative)</td><td>‚úÖ Built-in (<code>modifyAllEither</code>)</td></tr>
<tr><td><strong>Learning Curve</strong></td><td>‚ö†Ô∏è Steep (HKT knowledge)</td><td>‚úÖ Gentle (familiar types)</td></tr>
<tr><td><strong>Flexibility</strong></td><td>‚úÖ Maximum (any Applicative)</td><td>‚ö†Ô∏è Focused (common patterns)</td></tr>
<tr><td><strong>Boilerplate</strong></td><td>‚ö†Ô∏è More (setup code)</td><td>‚úÖ Less (direct API)</td></tr>
<tr><td><strong>Use Case</strong></td><td>Generic effectful operations</td><td>Validation-specific scenarios</td></tr>
</tbody></table>
</div>
<h3 id="when-to-use-each-approach"><a class="header" href="#when-to-use-each-approach">When to Use Each Approach</a></h3>
<p><strong>Use <code>modifyAllValidated</code> when:</strong></p>
<ul>
<li>You need to <strong>collect all validation errors</strong></li>
<li>Building <strong>form validation</strong> or <strong>data quality checks</strong></li>
<li>Users need <strong>comprehensive error reports</strong></li>
</ul>
<pre><code class="language-java">// Perfect for form validation
Validated&lt;List&lt;String&gt;, OrderForm&gt; validated = modifyAllValidated(
    ORDER_TO_PRICES,
    price -&gt; validatePrice(price),
    orderForm
);
</code></pre>
<p><strong>Use <code>modifyAllEither</code> when:</strong></p>
<ul>
<li>You want <strong>fail-fast behaviour</strong></li>
<li>Working in <strong>performance-critical</strong> paths</li>
<li>First error is <strong>sufficient feedback</strong></li>
</ul>
<pre><code class="language-java">// Perfect for quick validation in high-throughput scenarios
Either&lt;String, OrderForm&gt; validated = modifyAllEither(
    ORDER_TO_PRICES,
    price -&gt; validatePrice(price),
    orderForm
);
</code></pre>
<p><strong>Use <code>modifyMaybe</code> when:</strong></p>
<ul>
<li>Invalid items should be <strong>silently filtered</strong></li>
<li>Building <strong>data enrichment</strong> pipelines</li>
<li>Failures are <strong>expected and ignorable</strong></li>
</ul>
<pre><code class="language-java">// Perfect for optional enrichment
Maybe&lt;OrderForm&gt; enriched = modifyMaybe(
    ORDER_TO_OPTIONAL_DISCOUNTS,
    discount -&gt; tryApplyDiscount(discount),
    orderForm
);
</code></pre>
<p><strong>Use traditional <code>modifyF</code> when:</strong></p>
<ul>
<li>Working with <strong>custom Applicative</strong> functors</li>
<li>Need <strong>maximum flexibility</strong></li>
<li>Building <strong>generic abstractions</strong></li>
<li>Using effects <strong>beyond validation</strong> (IO, Future, etc.)</li>
</ul>
<pre><code class="language-java">// Still valuable for generic effectful operations
Kind&lt;F, Form&gt; result = FORM_TO_PERMISSION_NAMES.modifyF(
    effectfulValidation,
    form,
    customApplicative
);
</code></pre>
<h3 id="real-world-example-simplified-validation"><a class="header" href="#real-world-example-simplified-validation">Real-World Example: Simplified Validation</a></h3>
<p>Here's how the original example can be simplified using the new methods:</p>
<pre><code class="language-java">import static org.higherkindedj.optics.fluent.OpticOps.modifyAllValidated;
import org.higherkindedj.hkt.validated.Validated;
import java.util.List;

public class SimplifiedValidation {
    // Same traversal as before
    public static final Traversal&lt;Form, String&gt; FORM_TO_PERMISSION_NAMES =
        FormLenses.principal().asTraversal()
            .andThen(PrincipalPrisms.userLogin().asTraversal())
            .andThen(UserTraversals.permissions())
            .andThen(PermissionLenses.name().asTraversal());

    // Simplified validation - no Applicative setup needed
    public static Validated&lt;List&lt;String&gt;, Form&gt; validateFormPermissions(Form form) {
        return modifyAllValidated(
            FORM_TO_PERMISSION_NAMES,
            name -&gt; VALID_PERMISSIONS.contains(name)
                ? Validated.valid(name)
                : Validated.invalid(List.of("Invalid permission: " + name)),
            form
        );
    }

    // Alternative: fail-fast validation
    public static Either&lt;String, Form&gt; validateFormPermissionsFast(Form form) {
        return modifyAllEither(
            FORM_TO_PERMISSION_NAMES,
            name -&gt; VALID_PERMISSIONS.contains(name)
                ? Either.right(name)
                : Either.left("Invalid permission: " + name),
            form
        );
    }
}
</code></pre>
<p><strong>Benefits of the Simplified Approach:</strong></p>
<ul>
<li><strong>~60% less code</strong>: No <code>Applicative</code> setup, no <code>Kind</code> wrapping, no narrowing</li>
<li><strong>Clearer intent</strong>: Method name explicitly states the validation strategy</li>
<li><strong>Easier to learn</strong>: Uses familiar types (<code>Validated</code>, <code>Either</code>, <code>Maybe</code>)</li>
<li><strong>Equally powerful</strong>: Same type safety, same error accumulation, same composition</li>
</ul>
<div id="admonition-complete-example" class="admonition admonish-note" role="note" aria-labelledby="admonition-complete-example-title">
<div class="admonition-title">
<div id="admonition-complete-example-title">
<p>Complete Example</p>
</div>
<a class="admonition-anchor-link" href="optics/composing_optics.html#admonition-complete-example"></a>
</div>
<div>
<p>See <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/fluent/FluentValidationExample.java">FluentValidationExample.java</a> for comprehensive demonstrations of all validation-aware methods, including complex real-world scenarios like order validation and bulk data import.</p>
</div>
</div>
<h3 id="further-reading-11"><a class="header" href="#further-reading-11">Further Reading</a></h3>
<p>For a complete guide to validation-aware modifications including:</p>
<ul>
<li>Fluent builder API with method chaining</li>
<li>Integration with existing validation frameworks (Jakarta Bean Validation)</li>
<li>Performance optimisation techniques</li>
<li>Additional real-world scenarios</li>
</ul>
<p>See: <a href="optics/fluent_api.html#part-25-validation-aware-modifications">Fluent API for Optics - Part 2.5: Validation-Aware Modifications</a></p>
<hr />
<p><strong>Previous:</strong> <a href="optics/profunctor_optics.html">Profunctor Optics: Advanced Data Transformation</a>
<strong>Next:</strong> <a href="optics/optics_examples.html">Optics Examples</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="fluent-api-for-optics-java-friendly-optic-operations"><a class="header" href="#fluent-api-for-optics-java-friendly-optic-operations">Fluent API for Optics: Java-Friendly Optic Operations</a></h1>
<p><img src="optics/../images/lens2.jpg" alt="Illustration of fluent API patterns for Java-friendly optic operations" /></p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="optics/fluent_api.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>Two styles of optic operations: static methods and fluent builders</li>
<li>When to use each style for maximum clarity and productivity</li>
<li>How to perform common optic operations with Java-friendly syntax</li>
<li>Validation-aware modifications with <code>Either</code>, <code>Maybe</code>, and <code>Validated</code></li>
<li>Four validation strategies for different error-handling scenarios</li>
<li>Effectful modifications using type classes</li>
<li>Practical patterns for real-world Java applications</li>
</ul>
</div>
</div>
<div id="admonition-example-code" class="admonition admonish-note" role="note" aria-labelledby="admonition-example-code-title">
<div class="admonition-title">
<div id="admonition-example-code-title">
<p>Example Code</p>
</div>
<a class="admonition-anchor-link" href="optics/fluent_api.html#admonition-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/fluent/FluentOpticOpsExample.java">FluentOpticOpsExample</a></p>
</div>
</div>
<h2 id="introduction-making-optics-feel-natural-in-java"><a class="header" href="#introduction-making-optics-feel-natural-in-java">Introduction: Making Optics Feel Natural in Java</a></h2>
<p>While optics provide immense power for working with immutable data structures, their traditional functional programming syntax can feel foreign to Java developers. Method names like <code>view</code>, <code>over</code>, and <code>preview</code> don't match Java conventions, and the order of parameters can be unintuitive.</p>
<p>The <code>OpticOps</code> fluent API bridges this gap, providing two complementary styles that make optics feel natural in Java:</p>
<ol>
<li><strong>Static methods</strong> - Concise, direct operations for simple cases</li>
<li><strong>Fluent builders</strong> - Method chaining with IDE-discoverable operations</li>
</ol>
<p>Both styles operate on the same underlying optics, so you can mix and match based on what feels most natural for each situation.</p>
<hr />
<h2 id="the-two-styles-a-quick-comparison"><a class="header" href="#the-two-styles-a-quick-comparison">The Two Styles: A Quick Comparison</a></h2>
<p>Let's see both styles in action with a simple example:</p>
<pre><code class="language-java">@GenerateLenses
public record Person(String name, int age, String status) {}

Person person = new Person("Alice", 25, "ACTIVE");
Lens&lt;Person, Integer&gt; ageLens = PersonLenses.age();
</code></pre>
<h3 id="static-method-style-concise"><a class="header" href="#static-method-style-concise">Static Method Style (Concise)</a></h3>
<pre><code class="language-java">// Get a value
int age = OpticOps.get(person, ageLens);

// Set a value
Person updated = OpticOps.set(person, ageLens, 30);

// Modify a value
Person modified = OpticOps.modify(person, ageLens, a -&gt; a + 1);
</code></pre>
<h3 id="fluent-builder-style-explicit"><a class="header" href="#fluent-builder-style-explicit">Fluent Builder Style (Explicit)</a></h3>
<pre><code class="language-java">// Get a value
int age = OpticOps.getting(person).through(ageLens);

// Set a value
Person updated = OpticOps.setting(person).through(ageLens, 30);

// Modify a value
Person modified = OpticOps.modifying(person).through(ageLens, a -&gt; a + 1);
</code></pre>
<p>Both produce identical results. The choice is about <strong>readability</strong> and <strong>discoverability</strong> for your specific use case.</p>
<hr />
<h2 id="part-1-static-methods---simple-and-direct"><a class="header" href="#part-1-static-methods---simple-and-direct">Part 1: Static Methods - Simple and Direct</a></h2>
<p>Static methods provide the most concise syntax. They follow a consistent pattern: operation name, source object, optic, and optional parameters.</p>
<h3 id="getting-values"><a class="header" href="#getting-values">Getting Values</a></h3>
<h4 id="basic-get-operations"><a class="header" href="#basic-get-operations">Basic Get Operations</a></h4>
<pre><code class="language-java">// Get a required value (Lens or Getter)
String name = OpticOps.get(person, PersonLenses.name());

// Get an optional value (Prism or Traversal)
Optional&lt;Address&gt; address = OpticOps.preview(person, PersonPrisms.homeAddress());

// Get all values (Traversal or Fold)
List&lt;String&gt; playerNames = OpticOps.getAll(team, TeamTraversals.playerNames());
</code></pre>
<div id="admonition-practical-example-extracting-data" class="admonition admonish-example" role="note" aria-labelledby="admonition-practical-example-extracting-data-title">
<div class="admonition-title">
<div id="admonition-practical-example-extracting-data-title">
<p>Practical Example: Extracting Data</p>
</div>
<a class="admonition-anchor-link" href="optics/fluent_api.html#admonition-practical-example-extracting-data"></a>
</div>
<div>
<pre><code class="language-java">@GenerateLenses
@GenerateTraversals
public record Team(String name, List&lt;Player&gt; players) {}

@GenerateLenses
public record Player(String name, int score) {}

Team team = new Team("Wildcats",
    List.of(
        new Player("Alice", 100),
        new Player("Bob", 85)
    ));

// Get all player names
List&lt;String&gt; names = OpticOps.getAll(
    team,
    TeamTraversals.players().andThen(PlayerLenses.name().asTraversal())
);
// Result: ["Alice", "Bob"]
</code></pre>
</div>
</div>
<h3 id="setting-values"><a class="header" href="#setting-values">Setting Values</a></h3>
<pre><code class="language-java">// Set a single value (Lens)
Person updated = OpticOps.set(person, PersonLenses.age(), 30);

// Set all values (Traversal)
Team teamWithBonuses = OpticOps.setAll(
    team,
    TeamTraversals.players().andThen(PlayerLenses.score().asTraversal()),
    100  // Everyone gets 100 points!
);
</code></pre>
<h3 id="modifying-values"><a class="header" href="#modifying-values">Modifying Values</a></h3>
<p>The <code>modify</code> operations are particularly powerful because they transform existing values rather than replacing them:</p>
<pre><code class="language-java">// Modify a single value
Person olderPerson = OpticOps.modify(
    person,
    PersonLenses.age(),
    age -&gt; age + 1
);

// Modify all values
Team teamWithDoubledScores = OpticOps.modifyAll(
    team,
    TeamTraversals.players().andThen(PlayerLenses.score().asTraversal()),
    score -&gt; score * 2
);
</code></pre>
<h3 id="querying-data"><a class="header" href="#querying-data">Querying Data</a></h3>
<p>These operations work with <code>Fold</code> and <code>Traversal</code> to query data without modification:</p>
<pre><code class="language-java">// Check if any element matches
boolean hasHighScorer = OpticOps.exists(
    team,
    TeamTraversals.players().andThen(PlayerLenses.score().asTraversal()),
    score -&gt; score &gt; 90
);

// Check if all elements match
boolean allPassed = OpticOps.all(
    team,
    TeamTraversals.players().andThen(PlayerLenses.score().asTraversal()),
    score -&gt; score &gt;= 50
);

// Count elements
int playerCount = OpticOps.count(team, TeamTraversals.players());

// Check if empty
boolean noPlayers = OpticOps.isEmpty(team, TeamTraversals.players());

// Find first matching element
Optional&lt;Player&gt; topScorer = OpticOps.find(
    team,
    TeamTraversals.players(),
    player -&gt; player.score() &gt; 90
);
</code></pre>
<h3 id="effectful-modifications"><a class="header" href="#effectful-modifications">Effectful Modifications</a></h3>
<p>These are the most powerful operations, allowing modifications that can fail, accumulate errors, or execute asynchronously:</p>
<pre><code class="language-java">// Modify with an effect (e.g., validation)
// Note: Error should be your application's error type (e.g., String, List&lt;String&gt;, or a custom error class)
Functor&lt;Validated.Witness&lt;Error&gt;&gt; validatedFunctor =
    ValidatedApplicative.instance(ErrorSemigroup.instance());

Validated&lt;Error, Person&gt; result = OpticOps.modifyF(
    person,
    PersonLenses.age(),
    age -&gt; validateAge(age + 1),  // Returns Validated&lt;Error, Integer&gt;
    validatedFunctor
);

// Modify all with effects (e.g., async operations)
Applicative&lt;CompletableFutureKind.Witness&gt; cfApplicative =
    CompletableFutureMonad.instance();

CompletableFuture&lt;Team&gt; asyncResult = OpticOps.modifyAllF(
    team,
    TeamTraversals.players().andThen(PlayerLenses.score().asTraversal()),
    score -&gt; fetchBonusAsync(score),  // Returns CompletableFuture&lt;Integer&gt;
    cfApplicative
).thenApply(CompletableFutureKind::narrow);
</code></pre>
<hr />
<h2 id="part-2-fluent-builders---explicit-and-discoverable"><a class="header" href="#part-2-fluent-builders---explicit-and-discoverable">Part 2: Fluent Builders - Explicit and Discoverable</a></h2>
<p>Fluent builders provide excellent IDE support through method chaining. They make the intent of your code crystal clear.</p>
<h3 id="the-getbuilder-pattern"><a class="header" href="#the-getbuilder-pattern">The GetBuilder Pattern</a></h3>
<pre><code class="language-java">// Start with getting(source), then specify the optic
int age = OpticOps.getting(person).through(PersonLenses.age());

Optional&lt;Address&gt; addr = OpticOps.getting(person)
    .maybeThrough(PersonPrisms.homeAddress());

List&lt;String&gt; names = OpticOps.getting(team)
    .allThrough(TeamTraversals.playerNames());
</code></pre>
<h3 id="the-setbuilder-pattern"><a class="header" href="#the-setbuilder-pattern">The SetBuilder Pattern</a></h3>
<pre><code class="language-java">// Start with setting(source), then specify optic and value
Person updated = OpticOps.setting(person)
    .through(PersonLenses.age(), 30);

Team updatedTeam = OpticOps.setting(team)
    .allThrough(
        TeamTraversals.players().andThen(PlayerLenses.score().asTraversal()),
        100
    );
</code></pre>
<h3 id="the-modifybuilder-pattern"><a class="header" href="#the-modifybuilder-pattern">The ModifyBuilder Pattern</a></h3>
<pre><code class="language-java">// Start with modifying(source), then specify optic and function
Person modified = OpticOps.modifying(person)
    .through(PersonLenses.age(), age -&gt; age + 1);

Team modifiedTeam = OpticOps.modifying(team)
    .allThrough(
        TeamTraversals.players().andThen(PlayerLenses.score().asTraversal()),
        score -&gt; score * 2
    );

// Effectful modifications
Validated&lt;Error, Person&gt; result = OpticOps.modifying(person)
    .throughF(
        PersonLenses.age(),
        age -&gt; validateAge(age + 1),
        validatedFunctor
    );
</code></pre>
<h3 id="the-querybuilder-pattern"><a class="header" href="#the-querybuilder-pattern">The QueryBuilder Pattern</a></h3>
<pre><code class="language-java">// Start with querying(source), then specify checks
boolean hasHighScorer = OpticOps.querying(team)
    .anyMatch(
        TeamTraversals.players().andThen(PlayerLenses.score().asTraversal()),
        score -&gt; score &gt; 90
    );

boolean allPassed = OpticOps.querying(team)
    .allMatch(
        TeamTraversals.players().andThen(PlayerLenses.score().asTraversal()),
        score -&gt; score &gt;= 50
    );

Optional&lt;Player&gt; found = OpticOps.querying(team)
    .findFirst(TeamTraversals.players(), player -&gt; player.score() &gt; 90);

int count = OpticOps.querying(team)
    .count(TeamTraversals.players());

boolean empty = OpticOps.querying(team)
    .isEmpty(TeamTraversals.players());
</code></pre>
<hr />
<h2 id="part-25-validation-aware-modifications"><a class="header" href="#part-25-validation-aware-modifications">Part 2.5: Validation-Aware Modifications</a></h2>
<div id="admonition-core-types-integration" class="admonition admonish-tip" role="note" aria-labelledby="admonition-core-types-integration-title">
<div class="admonition-title">
<div id="admonition-core-types-integration-title">
<p>Core Types Integration</p>
</div>
<a class="admonition-anchor-link" href="optics/fluent_api.html#admonition-core-types-integration"></a>
</div>
<div>
<p>This section demonstrates <strong>Phase 2</strong> of the optics core types integration, which brings validation-aware modifications directly into <code>OpticOps</code>. These methods integrate seamlessly with higher-kinded-j's core types (<code>Either</code>, <code>Maybe</code>, <code>Validated</code>) to provide type-safe, composable validation workflows.</p>
</div>
</div>
<div id="admonition-comprehensive-example" class="admonition admonish-note" role="note" aria-labelledby="admonition-comprehensive-example-title">
<div class="admonition-title">
<div id="admonition-comprehensive-example-title">
<p>Comprehensive Example</p>
</div>
<a class="admonition-anchor-link" href="optics/fluent_api.html#admonition-comprehensive-example"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/fluent/FluentValidationExample.java">FluentValidationExample</a></p>
</div>
</div>
<h3 id="think-of-validation-aware-modifications-like"><a class="header" href="#think-of-validation-aware-modifications-like">Think of Validation-Aware Modifications Like...</a></h3>
<ul>
<li><strong>A quality control checkpoint</strong> üîç - Every modification must pass validation before being applied</li>
<li><strong>Airport security screening</strong> üõÇ - Some checks stop at the first issue (fast-track), others collect all problems (thorough inspection)</li>
<li><strong>Form validation on a website</strong> üìã - You can show either the first error or all errors at once</li>
<li><strong>Code review process</strong> ‚úÖ - Accumulate all feedback rather than stopping at the first comment</li>
</ul>
<h3 id="the-challenge-validation-during-updates"><a class="header" href="#the-challenge-validation-during-updates">The Challenge: Validation During Updates</a></h3>
<p>Traditional optic operations assume modifications always succeed. But in real applications, updates often need validation:</p>
<pre><code class="language-java">// ‚ùå Problem: No validation during modification
Person updated = OpticOps.modify(person, PersonLenses.age(), age -&gt; age + 1);
// What if the new age is invalid? No way to handle errors!

// ‚ùå Problem: Manual validation is verbose and error-prone
int currentAge = OpticOps.get(person, PersonLenses.age());
if (currentAge + 1 &gt;= 0 &amp;&amp; currentAge + 1 &lt;= 120) {
    person = OpticOps.set(person, PersonLenses.age(), currentAge + 1);
} else {
    // Handle error... but how do we return both success and failure?
}
</code></pre>
<p><strong>Validation-aware modifications</strong> solve this by integrating validation directly into the optic operation, returning a result type that represents either success or failure.</p>
<h3 id="the-solution-four-validation-strategies"><a class="header" href="#the-solution-four-validation-strategies">The Solution: Four Validation Strategies</a></h3>
<p><code>OpticOps</code> provides four complementary validation methods, each suited to different scenarios:</p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Core Type</th><th>Behaviour</th><th>Best For</th></tr></thead><tbody>
<tr><td><code>modifyEither</code></td><td><code>Either&lt;E, S&gt;</code></td><td>Short-circuit on first error</td><td>Sequential validation, fail-fast workflows</td></tr>
<tr><td><code>modifyMaybe</code></td><td><code>Maybe&lt;S&gt;</code></td><td>Success or nothing (no error details)</td><td>Optional enrichment, silent failure</td></tr>
<tr><td><code>modifyAllValidated</code></td><td><code>Validated&lt;List&lt;E&gt;, S&gt;</code></td><td>Accumulate ALL errors</td><td>Form validation, comprehensive feedback</td></tr>
<tr><td><code>modifyAllEither</code></td><td><code>Either&lt;E, S&gt;</code></td><td>Stop at first error in collection</td><td>Performance-critical batch validation</td></tr>
</tbody></table>
</div><div id="admonition-quick-comparison" class="admonition admonish-example" role="note" aria-labelledby="admonition-quick-comparison-title">
<div class="admonition-title">
<div id="admonition-quick-comparison-title">
<p>Quick Comparison</p>
</div>
<a class="admonition-anchor-link" href="optics/fluent_api.html#admonition-quick-comparison"></a>
</div>
<div>
<pre><code class="language-java">// Same validation logic, different error handling strategies
Order order = new Order("ORD-123", List.of(
    new BigDecimal("-10.00"),    // Invalid: negative
    new BigDecimal("15000.00")   // Invalid: too high
));

// Strategy 1: Either - stops at FIRST error
Either&lt;String, Order&gt; result1 = OpticOps.modifyAllEither(
    order, orderPricesTraversal, price -&gt; validatePrice(price)
);
// Result: Left("Price cannot be negative: -10.00")

// Strategy 2: Validated - collects ALL errors
Validated&lt;List&lt;String&gt;, Order&gt; result2 = OpticOps.modifyAllValidated(
    order, orderPricesTraversal, price -&gt; validatePrice(price)
);
// Result: Invalid(["Price cannot be negative: -10.00",
//                  "Price exceeds maximum: 15000.00"])
</code></pre>
</div>
</div>
<h3 id="static-method-style-validation-operations"><a class="header" href="#static-method-style-validation-operations">Static Method Style: Validation Operations</a></h3>
<h4 id="single-field-validation-with-modifyeither"><a class="header" href="#single-field-validation-with-modifyeither">Single-Field Validation with <code>modifyEither</code></a></h4>
<p>Perfect for validating and modifying a single field where you want to fail fast with detailed error messages.</p>
<pre><code class="language-java">@GenerateLenses
public record User(String username, String email, int age) {}

// Validate email format
Either&lt;String, User&gt; result = OpticOps.modifyEither(
    user,
    UserLenses.email(),
    email -&gt; {
        if (email.matches("^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$")) {
            return Either.right(email);  // Valid
        } else {
            return Either.left("Invalid email format: " + email);  // Error
        }
    }
);

// Handle the result
result.fold(
    error -&gt; {
        log.error("Validation failed: {}", error);
        return null;
    },
    validUser -&gt; {
        log.info("User updated: {}", validUser.email());
        return null;
    }
);
</code></pre>
<h4 id="optional-validation-with-modifymaybe"><a class="header" href="#optional-validation-with-modifymaybe">Optional Validation with <code>modifyMaybe</code></a></h4>
<p>Useful when validation failure shouldn't produce error messages‚Äîeither it works or it doesn't.</p>
<pre><code class="language-java">// Trim and validate bio (silent failure if too long)
Maybe&lt;User&gt; result = OpticOps.modifyMaybe(
    user,
    UserLenses.bio(),
    bio -&gt; {
        String trimmed = bio.trim();
        if (trimmed.length() &lt;= 500) {
            return Maybe.just(trimmed);  // Success
        } else {
            return Maybe.nothing();  // Too long, fail silently
        }
    }
);

// Check if validation succeeded
if (result.isJust()) {
    User validUser = result.get();
    // Proceed with valid user
} else {
    // Validation failed, use fallback logic
}
</code></pre>
<h4 id="multi-field-validation-with-error-accumulation"><a class="header" href="#multi-field-validation-with-error-accumulation">Multi-Field Validation with Error Accumulation</a></h4>
<p>The most powerful option: validate multiple fields and collect <strong>all</strong> validation errors, not just the first one.</p>
<pre><code class="language-java">@GenerateTraversals
public record Order(String orderId, List&lt;BigDecimal&gt; itemPrices) {}

// Validate ALL prices and accumulate errors
Validated&lt;List&lt;String&gt;, Order&gt; result = OpticOps.modifyAllValidated(
    order,
    orderPricesTraversal,
    price -&gt; {
        if (price.compareTo(BigDecimal.ZERO) &lt; 0) {
            return Validated.invalid("Price cannot be negative: " + price);
        } else if (price.compareTo(new BigDecimal("10000")) &gt; 0) {
            return Validated.invalid("Price exceeds maximum: " + price);
        } else {
            return Validated.valid(price);  // Valid price
        }
    }
);

// Handle accumulated errors
result.fold(
    errors -&gt; {
        System.out.println("Validation failed with " + errors.size() + " errors:");
        errors.forEach(error -&gt; System.out.println("  - " + error));
        return null;
    },
    validOrder -&gt; {
        System.out.println("All prices validated successfully!");
        return null;
    }
);
</code></pre>
<h4 id="multi-field-validation-with-short-circuiting"><a class="header" href="#multi-field-validation-with-short-circuiting">Multi-Field Validation with Short-Circuiting</a></h4>
<p>When you have many fields to validate but want to stop at the first error (better performance, less detailed feedback):</p>
<pre><code class="language-java">// Validate all prices, stop at FIRST error
Either&lt;String, Order&gt; result = OpticOps.modifyAllEither(
    order,
    orderPricesTraversal,
    price -&gt; validatePrice(price)  // Returns Either&lt;String, BigDecimal&gt;
);

// Only the first error is reported
result.fold(
    firstError -&gt; System.out.println("Failed: " + firstError),
    validOrder -&gt; System.out.println("Success!")
);
</code></pre>
<h3 id="fluent-builder-style-modifyingwithvalidation"><a class="header" href="#fluent-builder-style-modifyingwithvalidation">Fluent Builder Style: ModifyingWithValidation</a></h3>
<p>The fluent API provides a dedicated builder for validation-aware modifications, making the intent even clearer:</p>
<pre><code class="language-java">// Start with modifyingWithValidation(source), then choose validation strategy

// Single field with Either
Either&lt;String, User&gt; result1 = OpticOps.modifyingWithValidation(user)
    .throughEither(UserLenses.email(), email -&gt; validateEmail(email));

// Single field with Maybe
Maybe&lt;User&gt; result2 = OpticOps.modifyingWithValidation(user)
    .throughMaybe(UserLenses.bio(), bio -&gt; validateBio(bio));

// All fields with Validated (error accumulation)
Validated&lt;List&lt;String&gt;, Order&gt; result3 = OpticOps.modifyingWithValidation(order)
    .allThroughValidated(orderPricesTraversal, price -&gt; validatePrice(price));

// All fields with Either (short-circuit)
Either&lt;String, Order&gt; result4 = OpticOps.modifyingWithValidation(order)
    .allThroughEither(orderPricesTraversal, price -&gt; validatePrice(price));
</code></pre>
<h3 id="real-world-scenario-user-registration"><a class="header" href="#real-world-scenario-user-registration">Real-World Scenario: User Registration</a></h3>
<p>Let's see how to use validation-aware modifications for a complete user registration workflow:</p>
<pre><code class="language-java">@GenerateLenses
public record UserRegistration(String username, String email, int age, String bio) {}

// Scenario: Sequential validation (stop at first error)
Either&lt;String, UserRegistration&gt; validateRegistration(UserRegistration form) {
    return OpticOps.modifyEither(form, UserLenses.username(), this::validateUsername)
        .flatMap(user -&gt; OpticOps.modifyEither(user, UserLenses.email(), this::validateEmail))
        .flatMap(user -&gt; OpticOps.modifyEither(user, UserLenses.age(), this::validateAge))
        .flatMap(user -&gt; OpticOps.modifyEither(user, UserLenses.bio(), this::validateBio));
}

private Either&lt;String, String&gt; validateUsername(String username) {
    if (username.length() &lt; 3) {
        return Either.left("Username must be at least 3 characters");
    }
    if (username.length() &gt; 20) {
        return Either.left("Username must not exceed 20 characters");
    }
    if (!username.matches("^[a-zA-Z0-9_]+$")) {
        return Either.left("Username can only contain letters, numbers, and underscores");
    }
    return Either.right(username);
}

// Usage
validateRegistration(formData).fold(
    error -&gt; {
        System.out.println("Registration failed: " + error);
        // Show error to user, stop processing
        return null;
    },
    validForm -&gt; {
        System.out.println("Registration successful!");
        // Proceed with user creation
        return null;
    }
);
</code></pre>
<h3 id="real-world-scenario-bulk-data-import"><a class="header" href="#real-world-scenario-bulk-data-import">Real-World Scenario: Bulk Data Import</a></h3>
<p>When importing data, you often want to collect <strong>all</strong> validation errors to give comprehensive feedback:</p>
<pre><code class="language-java">@GenerateTraversals
public record DataImport(List&lt;String&gt; emailAddresses, String importedBy) {}

// Validate all emails, accumulate ALL errors
Validated&lt;List&lt;String&gt;, DataImport&gt; validateImport(DataImport importData) {
    return OpticOps.modifyingWithValidation(importData)
        .allThroughValidated(
            DataImportTraversals.emailAddresses(),
            email -&gt; {
                if (!email.matches("^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$")) {
                    return Validated.invalid("Invalid email: " + email);
                } else {
                    return Validated.valid(email.toLowerCase().trim());  // Normalise
                }
            }
        );
}

// Usage
validateImport(importBatch).fold(
    errors -&gt; {
        System.out.println("Import failed with " + errors.size() + " invalid emails:");
        errors.forEach(error -&gt; System.out.println("  - " + error));
        // User can fix ALL errors at once
        return null;
    },
    validImport -&gt; {
        System.out.println("Import successful! " +
                          validImport.emailAddresses().size() +
                          " emails validated.");
        return null;
    }
);
</code></pre>
<h3 id="when-to-use-each-validation-strategy"><a class="header" href="#when-to-use-each-validation-strategy">When to Use Each Validation Strategy</a></h3>
<h4 id="use-modifyeither-when"><a class="header" href="#use-modifyeither-when">Use <code>modifyEither</code> When:</a></h4>
<p>‚úÖ <strong>Sequential workflows</strong> where you want to stop at the first error</p>
<pre><code class="language-java">// Login validation - stop at first failure
OpticOps.modifyEither(credentials, CredentialsLenses.username(), this::validateUsername)
    .flatMap(c -&gt; OpticOps.modifyEither(c, CredentialsLenses.password(), this::checkPassword))
</code></pre>
<p>‚úÖ <strong>Single-field validation</strong> with detailed error messages</p>
<p>‚úÖ <strong>Early exit is beneficial</strong> (no point continuing if a critical field is invalid)</p>
<h4 id="use-modifymaybe-when"><a class="header" href="#use-modifymaybe-when">Use <code>modifyMaybe</code> When:</a></h4>
<p>‚úÖ <strong>Optional enrichment</strong> where failure is acceptable</p>
<pre><code class="language-java">// Try to geocode address, but it's okay if it fails
OpticOps.modifyMaybe(order, OrderLenses.address(), addr -&gt; geocodeAddress(addr))
</code></pre>
<p>‚úÖ <strong>Error details aren't needed</strong> (just success/failure)</p>
<p>‚úÖ <strong>Silent failures are acceptable</strong></p>
<h4 id="use-modifyallvalidated-when"><a class="header" href="#use-modifyallvalidated-when">Use <code>modifyAllValidated</code> When:</a></h4>
<p>‚úÖ <strong>Form validation</strong> where users need to see all errors at once</p>
<pre><code class="language-java">// Show all validation errors on a registration form
OpticOps.modifyAllValidated(form, formFieldsTraversal, this::validateField)
</code></pre>
<p>‚úÖ <strong>Comprehensive feedback is important</strong></p>
<p>‚úÖ <strong>User experience matters</strong> (fixing all errors in one go)</p>
<h4 id="use-modifyalleither-when"><a class="header" href="#use-modifyalleither-when">Use <code>modifyAllEither</code> When:</a></h4>
<p>‚úÖ <strong>Performance is critical</strong> and you have many fields to validate</p>
<p>‚úÖ <strong>First error is sufficient</strong> for debugging or logging</p>
<p>‚úÖ <strong>Resource-intensive validation</strong> where stopping early saves time</p>
<h3 id="comparison-with-traditional-modifyf"><a class="header" href="#comparison-with-traditional-modifyf">Comparison with Traditional <code>modifyF</code></a></h3>
<p>The validation methods simplify common patterns that previously required manual <code>Applicative</code> wiring:</p>
<p><strong>Before (using <code>modifyF</code>):</strong></p>
<pre><code class="language-java">// Manual applicative construction with explicit error type conversion
Applicative&lt;Validated.Witness&lt;List&lt;String&gt;&gt;&gt; app =
    ValidatedApplicative.instance(ListSemigroup.instance());

Validated&lt;List&lt;String&gt;, Order&gt; result = OpticOps.modifyAllF(
    order,
    orderPricesTraversal,
    price -&gt; {
        Validated&lt;String, BigDecimal&gt; validatedPrice = validatePrice(price);
        // Must convert error type from String to List&lt;String&gt;
        return ValidatedKindHelper.VALIDATED.widen(
            validatedPrice.bimap(List::of, Function.identity())
        );
    },
    app
).narrow();
</code></pre>
<p><strong>After (using <code>modifyAllValidated</code>):</strong></p>
<pre><code class="language-java">// Clean, concise, and clear intent
Validated&lt;List&lt;String&gt;, Order&gt; result = OpticOps.modifyAllValidated(
    order,
    orderPricesTraversal,
    price -&gt; validatePrice(price)
);
</code></pre>
<div id="admonition-when-to-use-modifyf" class="admonition admonish-info" role="note" aria-labelledby="admonition-when-to-use-modifyf-title">
<div class="admonition-title">
<div id="admonition-when-to-use-modifyf-title">
<p>When to Use modifyF</p>
</div>
<a class="admonition-anchor-link" href="optics/fluent_api.html#admonition-when-to-use-modifyf"></a>
</div>
<div>
<p>The traditional <code>modifyF</code> methods are still valuable for:</p>
<ul>
<li>Custom effect types beyond <code>Either</code>, <code>Maybe</code>, and <code>Validated</code></li>
<li>Advanced applicative scenarios with custom combinators</li>
<li>Asynchronous validation (e.g., <code>CompletableFuture</code>)</li>
<li>Integration with third-party effect systems</li>
</ul>
<p>For standard validation scenarios, the dedicated methods are clearer and more concise.</p>
</div>
</div>
<h3 id="performance-considerations-7"><a class="header" href="#performance-considerations-7">Performance Considerations</a></h3>
<ul>
<li><strong><code>Either</code> short-circuiting</strong>: Stops at first error, potentially faster for large collections</li>
<li><strong><code>Validated</code> accumulation</strong>: Checks all elements, more work but better UX</li>
<li><strong><code>Maybe</code></strong>: Minimal overhead, just success/nothing</li>
<li><strong>Object allocation</strong>: All methods create new result objects (standard immutable pattern)</li>
</ul>
<div id="admonition-optimisation-strategy" class="admonition admonish-tip" role="note" aria-labelledby="admonition-optimisation-strategy-title">
<div class="admonition-title">
<div id="admonition-optimisation-strategy-title">
<p>Optimisation Strategy</p>
</div>
<a class="admonition-anchor-link" href="optics/fluent_api.html#admonition-optimisation-strategy"></a>
</div>
<div>
<p>For performance-critical code with large collections:</p>
<ol>
<li>Use <code>modifyAllEither</code> if first-error is acceptable</li>
<li>Use <code>modifyAllValidated</code> if comprehensive errors are required</li>
<li>Consider pre-filtering with <code>Stream</code> API before validation</li>
<li>Cache compiled validators (e.g., compiled regex patterns)</li>
</ol>
</div>
</div>
<h3 id="integration-with-existing-validation"><a class="header" href="#integration-with-existing-validation">Integration with Existing Validation</a></h3>
<p>Validation-aware modifications work seamlessly with existing validation libraries:</p>
<pre><code class="language-java">// Jakarta Bean Validation integration
import jakarta.validation.Validator;
import jakarta.validation.ConstraintViolation;

Either&lt;List&lt;String&gt;, User&gt; validateWithJakarta(User user, Validator validator) {
    return OpticOps.modifyEither(
        user,
        UserLenses.email(),
        email -&gt; {
            Set&lt;ConstraintViolation&lt;String&gt;&gt; violations =
                validator.validate(email);

            if (violations.isEmpty()) {
                return Either.right(email);
            } else {
                return Either.left(
                    violations.stream()
                        .map(ConstraintViolation::getMessage)
                        .collect(Collectors.toList())
                );
            }
        }
    );
}
</code></pre>
<hr />
<h2 id="part-3-real-world-examples"><a class="header" href="#part-3-real-world-examples">Part 3: Real-World Examples</a></h2>
<h3 id="example-1-e-commerce-order-processing"><a class="header" href="#example-1-e-commerce-order-processing">Example 1: E-Commerce Order Processing</a></h3>
<pre><code class="language-java">@GenerateLenses
@GenerateTraversals
public record Order(String orderId,
                    OrderStatus status,
                    List&lt;OrderItem&gt; items,
                    ShippingAddress address) {}

@GenerateLenses
public record OrderItem(String productId, int quantity, BigDecimal price) {}

@GenerateLenses
public record ShippingAddress(String street, String city, String postCode) {}

// Scenario: Apply bulk discount and update shipping
Order processOrder(Order order, BigDecimal discountPercent) {
    // Apply discount using fluent API
    Order discountedOrder = OpticOps.modifying(order)
        .allThrough(
            OrderTraversals.items().andThen(OrderItemLenses.price().asTraversal()),
            price -&gt; price.multiply(BigDecimal.ONE.subtract(discountPercent))
        );

    // Update status using static method
    return OpticOps.set(
        discountedOrder,
        OrderLenses.status(),
        OrderStatus.PROCESSING
    );
}
</code></pre>
<h3 id="example-2-validation-with-error-accumulation"><a class="header" href="#example-2-validation-with-error-accumulation">Example 2: Validation with Error Accumulation</a></h3>
<pre><code class="language-java">// Using Validated to accumulate all validation errors
Validated&lt;List&lt;String&gt;, Order&gt; validateOrder(Order order) {
    Applicative&lt;Validated.Witness&lt;List&lt;String&gt;&gt;&gt; applicative =
        ValidatedApplicative.instance(ListSemigroup.instance());

    // Validate all item quantities
    return OpticOps.modifyAllF(
        order,
        OrderTraversals.items().andThen(OrderItemLenses.quantity().asTraversal()),
        qty -&gt; {
            if (qty &gt; 0 &amp;&amp; qty &lt;= 1000) {
                return Validated.valid(qty);
            } else {
                return Validated.invalid(List.of(
                    "Quantity must be between 1 and 1000, got: " + qty
                ));
            }
        },
        applicative
    ).narrow();
}
</code></pre>
<h3 id="example-3-async-database-updates"><a class="header" href="#example-3-async-database-updates">Example 3: Async Database Updates</a></h3>
<pre><code class="language-java">// Using CompletableFuture for async operations
CompletableFuture&lt;Team&gt; updatePlayerScoresAsync(
    Team team,
    Function&lt;Player, CompletableFuture&lt;Integer&gt;&gt; fetchNewScore
) {
    Applicative&lt;CompletableFutureKind.Witness&gt; cfApplicative =
        CompletableFutureMonad.instance();

    return OpticOps.modifyAllF(
        team,
        TeamTraversals.players(),
        player -&gt; fetchNewScore.apply(player)
            .thenApply(newScore -&gt;
                OpticOps.set(player, PlayerLenses.score(), newScore)
            )
            .thenApply(CompletableFutureKind::of),
        cfApplicative
    ).thenApply(kind -&gt; CompletableFutureKind.narrow(kind).join());
}
</code></pre>
<hr />
<h2 id="when-to-use-each-style"><a class="header" href="#when-to-use-each-style">When to Use Each Style</a></h2>
<h3 id="use-static-methods-when"><a class="header" href="#use-static-methods-when">Use Static Methods When:</a></h3>
<p>‚úÖ <strong>Performing simple, one-off operations</strong></p>
<pre><code class="language-java">// Clear and concise
String name = OpticOps.get(person, PersonLenses.name());
</code></pre>
<p>‚úÖ <strong>Chaining is not needed</strong></p>
<pre><code class="language-java">// Direct transformation
Person older = OpticOps.modify(person, PersonLenses.age(), a -&gt; a + 1);
</code></pre>
<p>‚úÖ <strong>Performance is critical</strong> (slightly less object allocation)</p>
<h3 id="use-fluent-builders-when"><a class="header" href="#use-fluent-builders-when">Use Fluent Builders When:</a></h3>
<p>‚úÖ <strong>Building complex workflows</strong></p>
<pre><code class="language-java">import static java.util.stream.Collectors.toList;

// Clear intent at each step
return OpticOps.getting(order)
    .allThrough(OrderTraversals.items())
    .stream()
    .filter(item -&gt; item.quantity() &gt; 10)
    .map(OrderItem::productId)
    .collect(toList());
</code></pre>
<p>‚úÖ <strong>IDE autocomplete is important</strong> (great for discovery)</p>
<p>‚úÖ <strong>Code reviews matter</strong> (explicit intent)</p>
<p>‚úÖ <strong>Teaching or documentation</strong> (self-explanatory)</p>
<hr />
<h2 id="common-patterns-and-idioms"><a class="header" href="#common-patterns-and-idioms">Common Patterns and Idioms</a></h2>
<h3 id="pattern-1-pipeline-transformations"><a class="header" href="#pattern-1-pipeline-transformations">Pattern 1: Pipeline Transformations</a></h3>
<pre><code class="language-java">// Sequential transformations for multi-step pipeline
// Note: Result and Data should be your application's domain types with appropriate lenses
Result processData(Data input) {
    Data afterStage1 = OpticOps.modifying(input)
        .through(DataLenses.stage1(), this::transformStage1);

    Data afterStage2 = OpticOps.modifying(afterStage1)
        .through(DataLenses.stage2(), this::transformStage2);

    return OpticOps.modifying(afterStage2)
        .through(DataLenses.stage3(), this::transformStage3);
}
</code></pre>
<h3 id="pattern-2-conditional-updates"><a class="header" href="#pattern-2-conditional-updates">Pattern 2: Conditional Updates</a></h3>
<pre><code class="language-java">// Static style for simple conditionals
Person updateIfAdult(Person person) {
    int age = OpticOps.get(person, PersonLenses.age());
    return age &gt;= 18
        ? OpticOps.set(person, PersonLenses.status(), "ADULT")
        : person;
}
</code></pre>
<h3 id="pattern-3-bulk-operations-with-filtering"><a class="header" href="#pattern-3-bulk-operations-with-filtering">Pattern 3: Bulk Operations with Filtering</a></h3>
<pre><code class="language-java">// Combine both styles for clarity
Team updateTopPerformers(Team team, int threshold) {
    // Use fluent for query
    List&lt;Player&gt; topPerformers = OpticOps.querying(team)
        .allThrough(TeamTraversals.players())
        .stream()
        .filter(p -&gt; p.score() &gt;= threshold)
        .toList();

    // Use static for transformation
    return OpticOps.modifyAll(
        team,
        TeamTraversals.players(),
        player -&gt; topPerformers.contains(player)
            ? OpticOps.set(player, PlayerLenses.status(), "STAR")
            : player
    );
}
</code></pre>
<hr />
<h2 id="performance-considerations-8"><a class="header" href="#performance-considerations-8">Performance Considerations</a></h2>
<h3 id="object-allocation"><a class="header" href="#object-allocation">Object Allocation</a></h3>
<ul>
<li><strong>Static methods</strong>: Minimal allocation (just the result)</li>
<li><strong>Fluent builders</strong>: Create intermediate builder objects</li>
<li><strong>Impact</strong>: Negligible for most applications; avoid in tight loops</li>
</ul>
<h3 id="optic-composition"><a class="header" href="#optic-composition">Optic Composition</a></h3>
<p>Both styles benefit from composing optics once and reusing them:</p>
<pre><code class="language-java">// ‚úÖ Good: Compose once, use many times
Lens&lt;Order, BigDecimal&gt; orderToTotalPrice =
    OrderTraversals.items()
        .andThen(OrderItemLenses.price().asTraversal())
        .andThen(someAggregationLens);

orders.stream()
    .map(order -&gt; OpticOps.getAll(order, orderToTotalPrice))
    .collect(toList());

// ‚ùå Avoid: Recomposing in loop
orders.stream()
    .map(order -&gt; OpticOps.getAll(
        order,
        OrderTraversals.items()
            .andThen(OrderItemLenses.price().asTraversal())  // Recomposed each time!
    ))
    .collect(toList());
</code></pre>
<hr />
<h2 id="integration-with-existing-java-code"><a class="header" href="#integration-with-existing-java-code">Integration with Existing Java Code</a></h2>
<h3 id="working-with-streams"><a class="header" href="#working-with-streams">Working with Streams</a></h3>
<pre><code class="language-java">// Optics integrate naturally with Stream API
List&lt;String&gt; highScorerNames = OpticOps.getting(team)
    .allThrough(TeamTraversals.players())
    .stream()
    .filter(p -&gt; p.score() &gt; 90)
    .map(p -&gt; OpticOps.get(p, PlayerLenses.name()))
    .collect(toList());
</code></pre>
<h3 id="working-with-optional"><a class="header" href="#working-with-optional">Working with Optional</a></h3>
<pre><code class="language-java">// Optics and Optional work together
Optional&lt;Person&gt; maybePerson = findPerson(id);

Optional&lt;Integer&gt; age = maybePerson
    .map(p -&gt; OpticOps.get(p, PersonLenses.age()));

Person updated = maybePerson
    .map(p -&gt; OpticOps.modify(p, PersonLenses.age(), a -&gt; a + 1))
    .orElse(new Person("Default", 0, "UNKNOWN"));
</code></pre>
<hr />
<h2 id="common-pitfalls-15"><a class="header" href="#common-pitfalls-15">Common Pitfalls</a></h2>
<h3 id="-dont-call-get-then-set"><a class="header" href="#-dont-call-get-then-set">‚ùå Don't: Call <code>get</code> then <code>set</code></a></h3>
<pre><code class="language-java">// Inefficient - two traversals
int age = OpticOps.get(person, PersonLenses.age());
Person updated = OpticOps.set(person, PersonLenses.age(), age + 1);
</code></pre>
<h3 id="-do-use-modify"><a class="header" href="#-do-use-modify">‚úÖ Do: Use <code>modify</code></a></h3>
<pre><code class="language-java">// Efficient - single traversal
Person updated = OpticOps.modify(person, PersonLenses.age(), a -&gt; a + 1);
</code></pre>
<h3 id="-dont-recompose-optics-unnecessarily"><a class="header" href="#-dont-recompose-optics-unnecessarily">‚ùå Don't: Recompose optics unnecessarily</a></h3>
<pre><code class="language-java">// Bad - composing in a loop
for (Order order : orders) {
    var itemPrices = OrderTraversals.items()
        .andThen(OrderItemLenses.price().asTraversal());  // Composed each iteration!
    process(OpticOps.getAll(order, itemPrices));
}
</code></pre>
<h3 id="-do-compose-once-reuse"><a class="header" href="#-do-compose-once-reuse">‚úÖ Do: Compose once, reuse</a></h3>
<pre><code class="language-java">// Good - compose outside loop
var itemPrices = OrderTraversals.items()
    .andThen(OrderItemLenses.price().asTraversal());

for (Order order : orders) {
    process(OpticOps.getAll(order, itemPrices));
}
</code></pre>
<hr />
<h2 id="further-reading-12"><a class="header" href="#further-reading-12">Further Reading</a></h2>
<ul>
<li><strong>Fluent Interfaces</strong>: <a href="https://martinfowler.com/bliki/FluentInterface.html">Martin Fowler's article</a> on designing fluent APIs</li>
<li><strong>Builder Pattern</strong>: <a href="https://www.oracle.com/java/technologies/effective-java.html">Effective Java, 3rd Edition</a> by Joshua Bloch</li>
<li><strong>Method Chaining</strong>: <a href="https://martinfowler.com/eaaCatalog/">Patterns of Enterprise Application Architecture</a></li>
<li><strong>Lens Tutorial</strong>: <a href="https://hackage.haskell.org/package/lens-tutorial">Haskell lens tutorial</a> for deeper theoretical understanding</li>
</ul>
<hr />
<p><strong>Next Steps:</strong></p>
<ul>
<li><a href="optics/free_monad_dsl.html">Free Monad DSL for Optics</a> - Build composable programs</li>
<li><a href="optics/interpreters.html">Optic Interpreters</a> - Multiple execution strategies</li>
<li><a href="optics/composing_optics.html">Advanced Patterns</a> - Complex real-world scenarios</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="free-monad-dsl-composable-optic-programs"><a class="header" href="#free-monad-dsl-composable-optic-programs">Free Monad DSL: Composable Optic Programs</a></h1>
<p><img src="optics/../images/lens2.jpg" alt="free_monad.jpg" /></p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="optics/free_monad_dsl.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>What Free monads are and why they're powerful for optics</li>
<li>How to build composable optic programs step by step</li>
<li>Separating program description from execution</li>
<li>Using conditional logic and branching in programs</li>
<li>Real-world scenarios: audit trails, validation, and testing</li>
<li>Creating reusable program fragments</li>
</ul>
</div>
</div>
<div id="admonition-example-code" class="admonition admonish-note" role="note" aria-labelledby="admonition-example-code-title">
<div class="admonition-title">
<div id="admonition-example-code-title">
<p>Example Code</p>
</div>
<a class="admonition-anchor-link" href="optics/free_monad_dsl.html#admonition-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/free/FreeMonadOpticDSLExample.java">FreeMonadOpticDSLExample</a></p>
</div>
</div>
<h2 id="introduction-beyond-immediate-execution"><a class="header" href="#introduction-beyond-immediate-execution">Introduction: Beyond Immediate Execution</a></h2>
<p>When you use optics directly, they execute immediately. You read a value, transform a field, update a structure‚Äîall happens right away. This direct execution is perfect for simple cases, but what if you need more?</p>
<p>Consider these real-world requirements:</p>
<ul>
<li><strong>Audit trails</strong>: Record every data change for compliance</li>
<li><strong>Validation</strong>: Check all constraints before making any changes</li>
<li><strong>Testing</strong>: Verify your logic without touching real data</li>
<li><strong>Optimisation</strong>: Analyse and fuse multiple operations for efficiency</li>
<li><strong>Dry-runs</strong>: See what would change without actually changing it</li>
</ul>
<p>This is where the Free monad DSL comes in. It lets you <strong>describe</strong> a sequence of optic operations as data, then <strong>interpret</strong> that description in different ways.</p>
<div id="admonition-the-core-insight" class="admonition admonish-tip" role="note" aria-labelledby="admonition-the-core-insight-title">
<div class="admonition-title">
<div id="admonition-the-core-insight-title">
<p>The Core Insight</p>
</div>
<a class="admonition-anchor-link" href="optics/free_monad_dsl.html#admonition-the-core-insight"></a>
</div>
<div>
<p>A Free monad program is like a recipe. Writing the recipe doesn't cook the meal‚Äîit just describes what to do. You can review the recipe, validate it, translate it, or follow it to cook. The Free monad DSL gives you that same power with optic operations.</p>
</div>
</div>
<hr />
<h2 id="part-1-understanding-free-monads-gently"><a class="header" href="#part-1-understanding-free-monads-gently">Part 1: Understanding Free Monads (Gently)</a></h2>
<h3 id="what-is-a-free-monad"><a class="header" href="#what-is-a-free-monad">What Is a Free Monad?</a></h3>
<p>A Free monad is a way to build a <strong>program as data</strong>. Instead of executing operations immediately, you construct a data structure that describes what operations to perform. Later, you choose how to execute (interpret) that structure.</p>
<p>Think of it like this:</p>
<pre><code class="language-java">// Direct execution (happens immediately)
Person updated = PersonLenses.age().set(30, person);

// Free monad (just builds a description)
Free&lt;OpticOpKind.Witness, Person&gt; program =
    OpticPrograms.set(person, PersonLenses.age(), 30);
// Nothing happened yet! We just described what to do.

// Now we choose how to interpret it
Person result = OpticInterpreters.direct().run(program);
// NOW it executed
</code></pre>
<h3 id="why-is-this-useful"><a class="header" href="#why-is-this-useful">Why Is This Useful?</a></h3>
<p>By separating <strong>description</strong> from <strong>execution</strong>, you can:</p>
<ol>
<li><strong>Review</strong> the program before running it</li>
<li><strong>Validate</strong> all operations without executing them</li>
<li><strong>Log</strong> every operation for audit trails</li>
<li><strong>Test</strong> the logic with mock data</li>
<li><strong>Transform</strong> the program (optimise, translate, etc.)</li>
</ol>
<p>For optics specifically, this means you can build complex data transformation workflows and then choose how to execute them based on your needs.</p>
<hr />
<h2 id="part-2-building-your-first-optic-program"><a class="header" href="#part-2-building-your-first-optic-program">Part 2: Building Your First Optic Program</a></h2>
<h3 id="simple-programs-get-set-modify"><a class="header" href="#simple-programs-get-set-modify">Simple Programs: Get, Set, Modify</a></h3>
<p>Let's start with the basics:</p>
<pre><code class="language-java">@GenerateLenses
public record Person(String name, int age, String status) {}

Person person = new Person("Alice", 25, "ACTIVE");

// Build a program that gets the age
Free&lt;OpticOpKind.Witness, Integer&gt; getProgram =
    OpticPrograms.get(person, PersonLenses.age());

// Build a program that sets the age
Free&lt;OpticOpKind.Witness, Person&gt; setProgram =
    OpticPrograms.set(person, PersonLenses.age(), 30);

// Build a program that modifies the age
Free&lt;OpticOpKind.Witness, Person&gt; modifyProgram =
    OpticPrograms.modify(person, PersonLenses.age(), age -&gt; age + 1);
</code></pre>
<p>At this point, <strong>nothing has executed</strong>. We've just built descriptions of operations. To actually run them:</p>
<pre><code class="language-java">// Execute with direct interpreter
DirectOpticInterpreter interpreter = OpticInterpreters.direct();

Integer age = interpreter.run(getProgram);           // 25
Person updated = interpreter.run(setProgram);         // age is now 30
Person modified = interpreter.run(modifyProgram);     // age is now 26
</code></pre>
<hr />
<h3 id="composing-programs-the-power-of-flatmap"><a class="header" href="#composing-programs-the-power-of-flatmap">Composing Programs: The Power of <code>flatMap</code></a></h3>
<p>The real power emerges when you compose multiple operations. The <code>flatMap</code> method lets you sequence operations where each step can depend on previous results:</p>
<pre><code class="language-java">// Program: Get the age, then if they're an adult, increment it
Free&lt;OpticOpKind.Witness, Person&gt; adultBirthdayProgram =
    OpticPrograms.get(person, PersonLenses.age())
        .flatMap(age -&gt; {
            if (age &gt;= 18) {
                return OpticPrograms.modify(
                    person,
                    PersonLenses.age(),
                    a -&gt; a + 1
                );
            } else {
                // Return unchanged person
                return OpticPrograms.pure(person);
            }
        });

// Execute it
Person result = OpticInterpreters.direct().run(adultBirthdayProgram);
</code></pre>
<p>Let's break down what's happening:</p>
<ol>
<li><code>get</code> creates a program that will retrieve the age</li>
<li><code>flatMap</code> says "once you have the age, use it to decide what to do next"</li>
<li>Inside <code>flatMap</code>, we make a decision based on the age value</li>
<li>We return a new program (either <code>modify</code> or <code>pure</code>)</li>
<li>The interpreter executes the composed program step by step</li>
</ol>
<hr />
<h3 id="multi-step-programmes-complex-workflows"><a class="header" href="#multi-step-programmes-complex-workflows">Multi-Step Programmes: Complex Workflows</a></h3>
<p>You can chain multiple <code>flatMap</code> calls to build sophisticated workflows:</p>
<pre><code class="language-java">@GenerateLenses
public record Employee(String name, int salary, EmployeeStatus status) {}

enum EmployeeStatus { JUNIOR, SENIOR, RETIRED }

// Program: Annual review and potential promotion
Free&lt;OpticOpKind.Witness, Employee&gt; annualReviewProgram(Employee employee) {
    return OpticPrograms.get(employee, EmployeeLenses.salary())
        .flatMap(currentSalary -&gt; {
            // Step 1: Give a 10% raise
            int newSalary = currentSalary + (currentSalary / 10);
            return OpticPrograms.set(employee, EmployeeLenses.salary(), newSalary);
        })
        .flatMap(raisedEmployee -&gt;
            // Step 2: Check if salary justifies promotion
            OpticPrograms.get(raisedEmployee, EmployeeLenses.salary())
                .flatMap(salary -&gt; {
                    if (salary &gt; 100_000) {
                        return OpticPrograms.set(
                            raisedEmployee,
                            EmployeeLenses.status(),
                            EmployeeStatus.SENIOR
                        );
                    } else {
                        return OpticPrograms.pure(raisedEmployee);
                    }
                })
        );
}

// Execute for an employee
Employee alice = new Employee("Alice", 95_000, EmployeeStatus.JUNIOR);
Free&lt;OpticOpKind.Witness, Employee&gt; program = annualReviewProgram(alice);

Employee promoted = OpticInterpreters.direct().run(program);
// Result: Employee("Alice", 104_500, SENIOR)
</code></pre>
<hr />
<h2 id="part-3-working-with-collections-traversals-and-folds"><a class="header" href="#part-3-working-with-collections-traversals-and-folds">Part 3: Working with Collections (Traversals and Folds)</a></h2>
<p>The DSL works beautifully with traversals for batch operations:</p>
<pre><code class="language-java">@GenerateLenses
@GenerateTraversals
public record Team(String name, List&lt;Player&gt; players) {}

@GenerateLenses
public record Player(String name, int score) {}

Team team = new Team("Wildcats",
    List.of(
        new Player("Alice", 80),
        new Player("Bob", 90)
    ));

// Program: Double all scores and check if everyone passes
Free&lt;OpticOpKind.Witness, Boolean&gt; scoreUpdateProgram =
    OpticPrograms.modifyAll(
        team,
        TeamTraversals.players().andThen(PlayerLenses.score().asTraversal()),
        score -&gt; score * 2
    )
    .flatMap(updatedTeam -&gt;
        // Now check if all players have passing scores
        OpticPrograms.all(
            updatedTeam,
            TeamTraversals.players().andThen(PlayerLenses.score().asTraversal()),
            score -&gt; score &gt;= 100
        )
    );

// Execute
Boolean allPass = OpticInterpreters.direct().run(scoreUpdateProgram);
// Result: true (Alice: 160, Bob: 180)
</code></pre>
<h3 id="querying-with-programmes"><a class="header" href="#querying-with-programmes">Querying with Programmes</a></h3>
<pre><code class="language-java">// Program: Find all high scorers
Free&lt;OpticOpKind.Witness, List&lt;Player&gt;&gt; findHighScorers =
    OpticPrograms.getAll(team, TeamTraversals.players())
        .flatMap(players -&gt; {
            List&lt;Player&gt; highScorers = players.stream()
                .filter(p -&gt; p.score() &gt; 85)
                .toList();
            return OpticPrograms.pure(highScorers);
        });

// Execute
List&lt;Player&gt; topPlayers = OpticInterpreters.direct().run(findHighScorers);
</code></pre>
<hr />
<h2 id="part-4-real-world-scenarios"><a class="header" href="#part-4-real-world-scenarios">Part 4: Real-World Scenarios</a></h2>
<h3 id="scenario-1-data-migration-with-validation"><a class="header" href="#scenario-1-data-migration-with-validation">Scenario 1: Data Migration with Validation</a></h3>
<pre><code class="language-java">@GenerateLenses
public record UserV1(String username, String email) {}

@GenerateLenses
public record UserV2(String username, String email, boolean verified) {}

// Note: Either is from higher-kinded-j (org.higherkindedj.hkt.either.Either)
// It represents a value that can be either a Left (error) or Right (success)

// Program: Migrate user with email validation
Free&lt;OpticOpKind.Witness, Either&lt;String, UserV2&gt;&gt; migrateUser(UserV1 oldUser) {
    return OpticPrograms.get(oldUser, UserV1Lenses.email())
        .flatMap(email -&gt; {
            if (email.contains("@") &amp;&amp; email.contains(".")) {
                // Valid email - proceed with migration
                UserV2 newUser = new UserV2(
                    oldUser.username(),
                    email,
                    false  // Will be verified later
                );
                return OpticPrograms.pure(Either.right(newUser));
            } else {
                // Invalid email - fail migration
                return OpticPrograms.pure(Either.left(
                    "Invalid email: " + email
                ));
            }
        });
}

// Execute migration
Free&lt;OpticOpKind.Witness, Either&lt;String, UserV2&gt;&gt; program =
    migrateUser(new UserV1("alice", "alice@example.com"));

Either&lt;String, UserV2&gt; result = OpticInterpreters.direct().run(program);
</code></pre>
<div id="admonition-why-use-free-monad-here" class="admonition admonish-tip" role="note" aria-labelledby="admonition-why-use-free-monad-here-title">
<div class="admonition-title">
<div id="admonition-why-use-free-monad-here-title">
<p>Why Use Free Monad Here?</p>
</div>
<a class="admonition-anchor-link" href="optics/free_monad_dsl.html#admonition-why-use-free-monad-here"></a>
</div>
<div>
<p>By building the migration as a program, you can:</p>
<ul>
<li>Validate the entire migration plan before executing</li>
<li>Log every transformation for audit purposes</li>
<li>Test the migration logic without touching real data</li>
<li>Roll back if any step fails</li>
</ul>
</div>
</div>
<hr />
<h3 id="scenario-2-audit-trail-for-financial-transactions"><a class="header" href="#scenario-2-audit-trail-for-financial-transactions">Scenario 2: Audit Trail for Financial Transactions</a></h3>
<pre><code class="language-java">@GenerateLenses
public record Account(String accountId, BigDecimal balance) {}

@GenerateLenses
public record Transaction(Account from, Account to, BigDecimal amount) {}

// Program: Transfer money between accounts
Free&lt;OpticOpKind.Witness, Transaction&gt; transferProgram(
    Transaction transaction
) {
    return OpticPrograms.get(transaction, TransactionLenses.amount())
        .flatMap(amount -&gt;
            // Deduct from source account
            OpticPrograms.modify(
                transaction,
                TransactionLenses.from().andThen(AccountLenses.balance()),
                balance -&gt; balance.subtract(amount)
            )
        )
        .flatMap(txn -&gt;
            // Add to destination account
            OpticPrograms.modify(
                txn,
                TransactionLenses.to().andThen(AccountLenses.balance()),
                balance -&gt; balance.add(txn.amount())
            )
        );
}

// Execute with logging for audit trail
Account acc1 = new Account("ACC001", new BigDecimal("1000.00"));
Account acc2 = new Account("ACC002", new BigDecimal("500.00"));
Transaction txn = new Transaction(acc1, acc2, new BigDecimal("100.00"));

Free&lt;OpticOpKind.Witness, Transaction&gt; program = transferProgram(txn);

// Use logging interpreter to record every operation
LoggingOpticInterpreter logger = OpticInterpreters.logging();
Transaction result = logger.run(program);

// Review audit trail
logger.getLog().forEach(System.out::println);
/* Output:
GET: TransactionLenses.amount() -&gt; 100.00
MODIFY: TransactionLenses.from().andThen(AccountLenses.balance()) from 1000.00 to 900.00
MODIFY: TransactionLenses.to().andThen(AccountLenses.balance()) from 500.00 to 600.00
*/
</code></pre>
<hr />
<h3 id="scenario-3-dry-run-validation-before-production"><a class="header" href="#scenario-3-dry-run-validation-before-production">Scenario 3: Dry-Run Validation Before Production</a></h3>
<pre><code class="language-java">@GenerateLenses
@GenerateTraversals
public record ProductCatalogue(List&lt;Product&gt; products) {}

@GenerateLenses
public record Product(String id, BigDecimal price, int stock) {}

// Program: Bulk price update
Free&lt;OpticOpKind.Witness, ProductCatalogue&gt; bulkPriceUpdate(
    ProductCatalogue catalogue,
    BigDecimal markup
) {
    return OpticPrograms.modifyAll(
        catalogue,
        ProductCatalogueTraversals.products()
            .andThen(ProductLenses.price().asTraversal()),
        price -&gt; price.multiply(BigDecimal.ONE.add(markup))
    );
}

// First, validate without executing
ProductCatalogue catalogue = new ProductCatalogue(
    List.of(
        new Product("P001", new BigDecimal("99.99"), 10),
        new Product("P002", new BigDecimal("49.99"), 5)
    )
);

Free&lt;OpticOpKind.Witness, ProductCatalogue&gt; program =
    bulkPriceUpdate(catalogue, new BigDecimal("0.10"));  // 10% markup

// Validate first
ValidationOpticInterpreter validator = OpticInterpreters.validating();
ValidationOpticInterpreter.ValidationResult validation =
    validator.validate(program);

if (validation.isValid()) {
    // All good - now execute for real
    ProductCatalogue updated = OpticInterpreters.direct().run(program);
    System.out.println("Price update successful!");
} else {
    // Something wrong - review errors
    validation.errors().forEach(System.err::println);
    validation.warnings().forEach(System.out::println);
}
</code></pre>
<hr />
<h2 id="part-5-advanced-patterns"><a class="header" href="#part-5-advanced-patterns">Part 5: Advanced Patterns</a></h2>
<h3 id="pattern-1-reusable-program-fragments"><a class="header" href="#pattern-1-reusable-program-fragments">Pattern 1: Reusable Program Fragments</a></h3>
<p>You can build libraries of reusable program fragments:</p>
<pre><code class="language-java">// Library of common operations
public class PersonPrograms {
    public static Free&lt;OpticOpKind.Witness, Person&gt; celebrateBirthday(
        Person person
    ) {
        return OpticPrograms.modify(
            person,
            PersonLenses.age(),
            age -&gt; age + 1
        );
    }

    public static Free&lt;OpticOpKind.Witness, Person&gt; promoteIfEligible(
        Person person
    ) {
        return OpticPrograms.get(person, PersonLenses.age())
            .flatMap(age -&gt; {
                if (age &gt;= 30) {
                    return OpticPrograms.set(
                        person,
                        PersonLenses.status(),
                        "SENIOR"
                    );
                } else {
                    return OpticPrograms.pure(person);
                }
            });
    }

    // Combine operations
    public static Free&lt;OpticOpKind.Witness, Person&gt; annualUpdate(
        Person person
    ) {
        return celebrateBirthday(person)
            .flatMap(PersonPrograms::promoteIfEligible);
    }
}

// Use them
Person alice = new Person("Alice", 29, "JUNIOR");
Free&lt;OpticOpKind.Witness, Person&gt; program = PersonPrograms.annualUpdate(alice);
Person updated = OpticInterpreters.direct().run(program);
</code></pre>
<hr />
<h3 id="pattern-2-conditional-branching"><a class="header" href="#pattern-2-conditional-branching">Pattern 2: Conditional Branching</a></h3>
<pre><code class="language-java">enum PerformanceRating { EXCELLENT, GOOD, SATISFACTORY, POOR }

// Program with complex branching logic
Free&lt;OpticOpKind.Witness, Employee&gt; processPerformanceReview(
    Employee employee,
    PerformanceRating rating
) {
    return switch (rating) {
        case EXCELLENT -&gt; OpticPrograms.modify(
            employee,
            EmployeeLenses.salary(),
            salary -&gt; salary + (salary / 5)  // 20% raise
        ).flatMap(emp -&gt;
            OpticPrograms.set(emp, EmployeeLenses.status(), EmployeeStatus.SENIOR)
        );

        case GOOD -&gt; OpticPrograms.modify(
            employee,
            EmployeeLenses.salary(),
            salary -&gt; salary + (salary / 10)  // 10% raise
        );

        case SATISFACTORY -&gt; OpticPrograms.pure(employee);  // No change

        case POOR -&gt; OpticPrograms.set(
            employee,
            EmployeeLenses.status(),
            EmployeeStatus.PROBATION
        );
    };
}
</code></pre>
<hr />
<h3 id="pattern-3-accumulating-results"><a class="header" href="#pattern-3-accumulating-results">Pattern 3: Accumulating Results</a></h3>
<pre><code class="language-java">// Note: Tuple and Tuple2 are from higher-kinded-j (org.higherkindedj.hkt.tuple.Tuple, Tuple2)
// Tuple.of() creates a Tuple2 instance to pair two values together

// Program that accumulates statistics while processing
record ProcessingStats(int processed, int modified, int skipped) {}

Free&lt;OpticOpKind.Witness, Tuple2&lt;Team, ProcessingStats&gt;&gt; processTeamWithStats(
    Team team
) {
    // This is simplified - in practice you'd thread stats through flatMaps
    return OpticPrograms.getAll(team, TeamTraversals.players())
        .flatMap(players -&gt; {
            int processed = players.size();
            int modified = (int) players.stream()
                .filter(p -&gt; p.score() &lt; 50)
                .count();
            int skipped = processed - modified;

            return OpticPrograms.modifyAll(
                team,
                TeamTraversals.players(),
                player -&gt; player.score() &lt; 50
                    ? OpticOps.set(player, PlayerLenses.score(), 50)
                    : player
            ).map(updatedTeam -&gt;
                Tuple.of(
                    updatedTeam,
                    new ProcessingStats(processed, modified, skipped)
                )
            );
        });
}
</code></pre>
<hr />
<h2 id="part-6-comparison-with-direct-execution"><a class="header" href="#part-6-comparison-with-direct-execution">Part 6: Comparison with Direct Execution</a></h2>
<h3 id="when-to-use-free-monad-dsl"><a class="header" href="#when-to-use-free-monad-dsl">When to Use Free Monad DSL</a></h3>
<p>‚úÖ <strong>Use Free Monad DSL when you need:</strong></p>
<ul>
<li>Audit trails and logging</li>
<li>Validation before execution</li>
<li>Testing complex logic</li>
<li>Multiple execution strategies</li>
<li>Optimisation opportunities</li>
<li>Dry-run capabilities</li>
</ul>
<h3 id="when-to-use-direct-execution"><a class="header" href="#when-to-use-direct-execution">When to Use Direct Execution</a></h3>
<p>‚úÖ <strong>Use Direct Execution (<a href="optics/fluent_api.html">Fluent API</a>) when:</strong></p>
<ul>
<li>Simple, straightforward operations</li>
<li>No need for introspection</li>
<li>Performance is critical</li>
<li>The workflow is stable and well-understood</li>
</ul>
<hr />
<h3 id="side-by-side-comparison"><a class="header" href="#side-by-side-comparison">Side-by-Side Comparison</a></h3>
<pre><code class="language-java">// Direct execution (immediate)
Person result = OpticOps.modify(
    person,
    PersonLenses.age(),
    age -&gt; age + 1
);

// Free monad (deferred)
Free&lt;OpticOpKind.Witness, Person&gt; program =
    OpticPrograms.modify(
        person,
        PersonLenses.age(),
        age -&gt; age + 1
    );

Person result = OpticInterpreters.direct().run(program);
</code></pre>
<p>The Free monad version requires more code, but gives you the power to:</p>
<pre><code class="language-java">// Log it
LoggingOpticInterpreter logger = OpticInterpreters.logging();
Person result = logger.run(program);
logger.getLog().forEach(System.out::println);

// Validate it
ValidationOpticInterpreter validator = OpticInterpreters.validating();
ValidationResult validation = validator.validate(program);

// Test it with mocks
MockOpticInterpreter mock = new MockOpticInterpreter();
Person mockResult = mock.run(program);
</code></pre>
<hr />
<h2 id="common-pitfalls-16"><a class="header" href="#common-pitfalls-16">Common Pitfalls</a></h2>
<h3 id="-dont-forget-that-programs-are-immutable"><a class="header" href="#-dont-forget-that-programs-are-immutable">‚ùå Don't: Forget that programs are immutable</a></h3>
<pre><code class="language-java">// Wrong - trying to "modify" a program
Free&lt;OpticOpKind.Witness, Person&gt; program = OpticPrograms.get(person, PersonLenses.age());
program.flatMap(age -&gt; ...);  // This returns a NEW program!

// The original program is unchanged
</code></pre>
<h3 id="-do-assign-the-result-of-flatmap"><a class="header" href="#-do-assign-the-result-of-flatmap">‚úÖ Do: Assign the result of <code>flatMap</code></a></h3>
<pre><code class="language-java">// Correct - capture the new program
Free&lt;OpticOpKind.Witness, Person&gt; program =
    OpticPrograms.get(person, PersonLenses.age())
        .flatMap(age -&gt; OpticPrograms.modify(person, PersonLenses.age(), a -&gt; a + 1));
</code></pre>
<hr />
<h3 id="-dont-mix-side-effects-in-program-construction"><a class="header" href="#-dont-mix-side-effects-in-program-construction">‚ùå Don't: Mix side effects in program construction</a></h3>
<pre><code class="language-java">// Wrong - side effect during construction
Free&lt;OpticOpKind.Witness, Person&gt; program =
    OpticPrograms.get(person, PersonLenses.age())
        .flatMap(age -&gt; {
            System.out.println("Age: " + age);  // Side effect!
            return OpticPrograms.pure(person);
        });
</code></pre>
<h3 id="-do-keep-program-construction-pure"><a class="header" href="#-do-keep-program-construction-pure">‚úÖ Do: Keep program construction pure</a></h3>
<pre><code class="language-java">// Correct - side effects only in interpreters
Free&lt;OpticOpKind.Witness, Person&gt; program =
    OpticPrograms.get(person, PersonLenses.age())
        .flatMap(age -&gt; OpticPrograms.pure(person));

// Side effects happen during interpretation
LoggingOpticInterpreter logger = OpticInterpreters.logging();
Person result = logger.run(program);
logger.getLog().forEach(System.out::println);  // Side effect here is fine
</code></pre>
<hr />
<h2 id="further-reading-13"><a class="header" href="#further-reading-13">Further Reading</a></h2>
<ul>
<li><strong>Free Monads Explained</strong>: <a href="http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html">Why Free Monads Matter</a> by Gabriel Gonzalez</li>
<li><strong>Interpreter Pattern</strong>: <a href="https://en.wikipedia.org/wiki/Interpreter_pattern">Design Patterns: Elements of Reusable Object-Oriented Software</a></li>
<li><strong>Tagless Final vs Free</strong>: <a href="http://okmij.org/ftp/tagless-final/">Typed Tagless Final Interpreters</a></li>
<li><strong>Railway-Oriented Programming</strong>: <a href="https://fsharpforfunandprofit.com/rop/">Railway Oriented Programming</a> by Scott Wlaschin</li>
<li><strong>Separation of Concerns</strong>: <a href="https://www.win.tue.nl/~wstomv/edu/2ip30/references/criteria_for_modularization.pdf">On the Criteria To Be Used in Decomposing Systems into Modules</a> by David Parnas</li>
</ul>
<hr />
<p><strong>Next Steps:</strong></p>
<ul>
<li><a href="optics/interpreters.html">Optic Interpreters</a> - Deep dive into execution strategies</li>
<li><a href="optics/fluent_api.html">Fluent API for Optics</a> - Direct execution patterns</li>
<li><a href="optics/composing_optics.html">Advanced Patterns</a> - Complex real-world scenarios</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="optic-interpreters-multiple-execution-strategies"><a class="header" href="#optic-interpreters-multiple-execution-strategies">Optic Interpreters: Multiple Execution Strategies</a></h1>
<p><img src="optics/../images/lens2.jpg" alt="interpreters.jpg" /></p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="optics/interpreters.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How the Interpreter pattern separates description from execution</li>
<li>The three built-in interpreters: Direct, Logging, and Validation</li>
<li>When to use each interpreter effectively</li>
<li>How to create custom interpreters for specific needs</li>
<li>Combining interpreters for powerful workflows</li>
<li>Real-world applications: audit trails, testing, and optimisation</li>
</ul>
</div>
</div>
<div id="admonition-example-code" class="admonition admonish-note" role="note" aria-labelledby="admonition-example-code-title">
<div class="admonition-title">
<div id="admonition-example-code-title">
<p>Example Code</p>
</div>
<a class="admonition-anchor-link" href="optics/interpreters.html#admonition-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/free/OpticInterpretersExample.java">OpticInterpretersExample</a></p>
</div>
</div>
<h2 id="introduction-the-power-of-interpretation"><a class="header" href="#introduction-the-power-of-interpretation">Introduction: The Power of Interpretation</a></h2>
<p>In the <a href="optics/free_monad_dsl.html">Free Monad DSL</a> guide, we learnt how to build optic operations as programmes‚Äîdata structures that describe what to do, rather than doing it immediately. But a description alone is useless without execution. That's where <strong>interpreters</strong> come in.</p>
<p>An interpreter takes a programme and executes it in a specific way. By providing different interpreters, you can run the same programme with completely different behaviours:</p>
<ul>
<li><strong>DirectOpticInterpreter</strong>: Executes operations immediately (production use)</li>
<li><strong>LoggingOpticInterpreter</strong>: Records every operation for audit trails</li>
<li><strong>ValidationOpticInterpreter</strong>: Checks constraints without modifying data</li>
<li><strong>Custom interpreters</strong>: Performance profiling, testing, mocking, and more</li>
</ul>
<p>This separation of concerns‚Äî<em>what to do</em> vs <em>how to do it</em>‚Äîis the essence of the Interpreter pattern and the key to the Free monad's flexibility.</p>
<div id="admonition-the-core-benefit" class="admonition admonish-tip" role="note" aria-labelledby="admonition-the-core-benefit-title">
<div class="admonition-title">
<div id="admonition-the-core-benefit-title">
<p>The Core Benefit</p>
</div>
<a class="admonition-anchor-link" href="optics/interpreters.html#admonition-the-core-benefit"></a>
</div>
<div>
<p>Write your business logic once as a programme. Execute it in multiple ways: validate it in tests, log it in production, mock it during development, and optimise it for performance‚Äîall without changing the business logic itself.</p>
</div>
</div>
<hr />
<h2 id="part-1-the-interpreter-pattern-explained"><a class="header" href="#part-1-the-interpreter-pattern-explained">Part 1: The Interpreter Pattern Explained</a></h2>
<h3 id="from-design-patterns-to-functional-programming"><a class="header" href="#from-design-patterns-to-functional-programming">From Design Patterns to Functional Programming</a></h3>
<p>The Interpreter pattern, described in the Gang of Four's <em>Design Patterns</em>, suggests representing operations as objects in an abstract syntax tree (AST), then traversing that tree to execute them. The Free monad is essentially a functional programming implementation of this pattern.</p>
<pre><code class="language-java">// Our "AST" - a programme built from operations
Free&lt;OpticOpKind.Witness, Person&gt; program =
    OpticPrograms.get(person, PersonLenses.age())
        .flatMap(age -&gt;
            OpticPrograms.modify(person, PersonLenses.age(), a -&gt; a + 1)
        );

// Our "interpreter" - executes the AST
DirectOpticInterpreter interpreter = OpticInterpreters.direct();
Person result = interpreter.run(program);
</code></pre>
<h3 id="why-multiple-interpreters"><a class="header" href="#why-multiple-interpreters">Why Multiple Interpreters?</a></h3>
<p>Different situations require different execution strategies:</p>
<div class="table-wrapper"><table><thead><tr><th><strong>Situation</strong></th><th><strong>Interpreter</strong></th><th><strong>Why</strong></th></tr></thead><tbody>
<tr><td>Production execution</td><td>Direct</td><td>Fast, straightforward</td></tr>
<tr><td>Compliance &amp; auditing</td><td>Logging</td><td>Records every change</td></tr>
<tr><td>Pre-flight checks</td><td>Validation</td><td>Verifies without executing</td></tr>
<tr><td>Unit testing</td><td>Mock/Custom</td><td>No real data needed</td></tr>
<tr><td>Performance tuning</td><td>Profiling/Custom</td><td>Measures execution time</td></tr>
<tr><td>Dry-run simulations</td><td>Validation</td><td>See what would happen</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="part-2-the-direct-interpreter"><a class="header" href="#part-2-the-direct-interpreter">Part 2: The Direct Interpreter</a></h2>
<p>The <code>DirectOpticInterpreter</code> is the simplest interpreter‚Äîit executes optic operations immediately, exactly as you'd expect.</p>
<h3 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h3>
<pre><code class="language-java">@GenerateLenses
public record Person(String name, int age) {}

Person person = new Person("Alice", 25);

// Build a programme
Free&lt;OpticOpKind.Witness, Person&gt; program =
    OpticPrograms.modify(person, PersonLenses.age(), age -&gt; age + 1);

// Execute with direct interpreter
DirectOpticInterpreter interpreter = OpticInterpreters.direct();
Person result = interpreter.run(program);

System.out.println(result);  // Person("Alice", 26)
</code></pre>
<h3 id="when-to-use"><a class="header" href="#when-to-use">When to Use</a></h3>
<p>‚úÖ <strong>Production execution</strong>: When you just want to run the operations
‚úÖ <strong>Simple workflows</strong>: When audit trails or validation aren't needed
‚úÖ <strong>Performance-critical paths</strong>: Minimal overhead</p>
<h3 id="characteristics"><a class="header" href="#characteristics">Characteristics</a></h3>
<ul>
<li><strong>Fast</strong>: No additional processing</li>
<li><strong>Simple</strong>: Executes exactly as described</li>
<li><strong>No Side Effects</strong>: Pure optic operations only</li>
</ul>
<div id="admonition-production-workflow" class="admonition admonish-example" role="note" aria-labelledby="admonition-production-workflow-title">
<div class="admonition-title">
<div id="admonition-production-workflow-title">
<p>Production Workflow</p>
</div>
<a class="admonition-anchor-link" href="optics/interpreters.html#admonition-production-workflow"></a>
</div>
<div>
<pre><code class="language-java">@GenerateLenses
record Employee(String name, int salary, String status) {}

enum PerformanceRating { EXCELLENT, GOOD, SATISFACTORY, POOR }

// Employee management system
public Employee processAnnualReview(
    Employee employee,
    PerformanceRating rating
) {
    Free&lt;OpticOpKind.Witness, Employee&gt; program =
        buildReviewProgram(employee, rating);

    // Direct execution in production
    return OpticInterpreters.direct().run(program);
}
</code></pre>
</div>
</div>
<hr />
<h2 id="part-3-the-logging-interpreter"><a class="header" href="#part-3-the-logging-interpreter">Part 3: The Logging Interpreter</a></h2>
<p>The <code>LoggingOpticInterpreter</code> executes operations whilst recording detailed logs of every operation performed. This is invaluable for:</p>
<ul>
<li><strong>Audit trails</strong>: Compliance requirements (GDPR, SOX, etc.)</li>
<li><strong>Debugging</strong>: Understanding what happened when</li>
<li><strong>Monitoring</strong>: Tracking data changes in production</li>
</ul>
<h3 id="basic-usage-1"><a class="header" href="#basic-usage-1">Basic Usage</a></h3>
<pre><code class="language-java">@GenerateLenses
public record Account(String accountId, BigDecimal balance) {}

Account account = new Account("ACC001", new BigDecimal("1000.00"));

// Build a programme
Free&lt;OpticOpKind.Witness, Account&gt; program =
    OpticPrograms.modify(
        account,
        AccountLenses.balance(),
        balance -&gt; balance.subtract(new BigDecimal("100.00"))
    );

// Execute with logging
LoggingOpticInterpreter logger = OpticInterpreters.logging();
Account result = logger.run(program);

// Review the log
List&lt;String&gt; log = logger.getLog();
log.forEach(System.out::println);
/* Output:
MODIFY: AccountLenses.balance() from 1000.00 to 900.00
*/
</code></pre>
<h3 id="comprehensive-example-financial-transaction-audit"><a class="header" href="#comprehensive-example-financial-transaction-audit">Comprehensive Example: Financial Transaction Audit</a></h3>
<pre><code class="language-java">@GenerateLenses
public record Transaction(
    String txnId,
    Account from,
    Account to,
    BigDecimal amount,
    LocalDateTime timestamp
) {}

// Build a transfer programme
Free&lt;OpticOpKind.Witness, Transaction&gt; transferProgram(Transaction txn) {
    return OpticPrograms.get(txn, TransactionLenses.amount())
        .flatMap(amount -&gt;
            // Debit source account
            OpticPrograms.modify(
                txn,
                TransactionLenses.from().andThen(AccountLenses.balance()),
                balance -&gt; balance.subtract(amount)
            )
        )
        .flatMap(debited -&gt;
            // Credit destination account
            OpticPrograms.modify(
                debited,
                TransactionLenses.to().andThen(AccountLenses.balance()),
                balance -&gt; balance.add(debited.amount())
            )
        );
}

// Execute with audit logging
Transaction txn = new Transaction(
    "TXN-12345",
    new Account("ACC001", new BigDecimal("1000.00")),
    new Account("ACC002", new BigDecimal("500.00")),
    new BigDecimal("250.00"),
    LocalDateTime.now()
);

LoggingOpticInterpreter logger = OpticInterpreters.logging();
Transaction result = logger.run(transferProgram(txn));

// Persist audit trail to database
logger.getLog().forEach(entry -&gt; auditService.record(txn.txnId(), entry));
</code></pre>
<h3 id="log-format"><a class="header" href="#log-format">Log Format</a></h3>
<p>The logging interpreter provides detailed, human-readable logs:</p>
<pre><code>GET: TransactionLenses.amount() -&gt; 250.00
MODIFY: TransactionLenses.from().andThen(AccountLenses.balance()) from 1000.00 to 750.00
MODIFY: TransactionLenses.to().andThen(AccountLenses.balance()) from 500.00 to 750.00
</code></pre>
<h3 id="managing-logs"><a class="header" href="#managing-logs">Managing Logs</a></h3>
<pre><code class="language-java">LoggingOpticInterpreter logger = OpticInterpreters.logging();

// Run first programme
logger.run(program1);
List&lt;String&gt; firstLog = logger.getLog();

// Clear for next programme
logger.clearLog();

// Run second programme
logger.run(program2);
List&lt;String&gt; secondLog = logger.getLog();
</code></pre>
<div id="admonition-performance-consideration" class="admonition admonish-warning" role="note" aria-labelledby="admonition-performance-consideration-title">
<div class="admonition-title">
<div id="admonition-performance-consideration-title">
<p>Performance Consideration</p>
</div>
<a class="admonition-anchor-link" href="optics/interpreters.html#admonition-performance-consideration"></a>
</div>
<div>
<p>The logging interpreter does add overhead (string formatting, list management). For high-frequency operations, consider:</p>
<ul>
<li>Using sampling (log every Nth transaction)</li>
<li>Async logging (log to queue, process later)</li>
<li>Conditional logging (only for high-value transactions)</li>
</ul>
</div>
</div>
<hr />
<h2 id="part-4-the-validation-interpreter"><a class="header" href="#part-4-the-validation-interpreter">Part 4: The Validation Interpreter</a></h2>
<p>The <code>ValidationOpticInterpreter</code> performs a "dry-run" of your programme, checking constraints and collecting errors/warnings <strong>without actually executing the operations</strong>. This is perfect for:</p>
<ul>
<li><strong>Pre-flight checks</strong>: Validate before committing</li>
<li><strong>Testing</strong>: Verify logic without side effects</li>
<li><strong>What-if scenarios</strong>: See what would happen</li>
</ul>
<h3 id="basic-usage-2"><a class="header" href="#basic-usage-2">Basic Usage</a></h3>
<pre><code class="language-java">@GenerateLenses
public record Person(String name, int age) {}

Person person = new Person("Alice", 25);

// Build a programme
Free&lt;OpticOpKind.Witness, Person&gt; program =
    OpticPrograms.set(person, PersonLenses.name(), null);  // Oops!

// Validate without executing
ValidationOpticInterpreter validator = OpticInterpreters.validating();
ValidationOpticInterpreter.ValidationResult result = validator.validate(program);

if (!result.isValid()) {
    // Has errors
    result.errors().forEach(System.err::println);
}

if (result.hasWarnings()) {
    // Has warnings
    result.warnings().forEach(System.out::println);
    // Output: "SET operation with null value: PersonLenses.name()"
}
</code></pre>
<h3 id="validation-rules"><a class="header" href="#validation-rules">Validation Rules</a></h3>
<p>The validation interpreter checks for:</p>
<ol>
<li><strong>Null values</strong>: Warns when setting null</li>
<li><strong>Modifier failures</strong>: Errors when modifiers throw exceptions</li>
<li><strong>Custom constraints</strong>: (via custom interpreter subclass)</li>
</ol>
<h3 id="real-world-example-data-migration-validation"><a class="header" href="#real-world-example-data-migration-validation">Real-World Example: Data Migration Validation</a></h3>
<pre><code class="language-java">@GenerateLenses
public record UserV1(String username, String email, Integer age) {}

@GenerateLenses
public record UserV2(
    String username,
    String email,
    int age,  // Now non-null!
    boolean verified
) {}

// Migration programme
Free&lt;OpticOpKind.Witness, UserV2&gt; migrateUser(UserV1 oldUser) {
    return OpticPrograms.get(oldUser, UserV1Lenses.age())
        .flatMap(age -&gt; {
            if (age == null) {
                // This would fail!
                throw new IllegalArgumentException("Age cannot be null in V2");
            }

            UserV2 newUser = new UserV2(
                oldUser.username(),
                oldUser.email(),
                age,
                false
            );

            return OpticPrograms.pure(newUser);
        });
}

// Validate migration for each user
List&lt;UserV1&gt; oldUsers = loadOldUsers();
List&lt;ValidationResult&gt; validations = new ArrayList&lt;&gt;();

for (UserV1 user : oldUsers) {
    Free&lt;OpticOpKind.Witness, UserV2&gt; program = migrateUser(user);

    ValidationOpticInterpreter validator = OpticInterpreters.validating();
    ValidationResult validation = validator.validate(program);

    validations.add(validation);

    if (!validation.isValid()) {
        System.err.println("User " + user.username() + " failed validation:");
        validation.errors().forEach(System.err::println);
    }
}

// Only proceed if all valid
if (validations.stream().allMatch(ValidationResult::isValid)) {
    // Execute migrations with direct interpreter
    oldUsers.forEach(user -&gt; {
        Free&lt;OpticOpKind.Witness, UserV2&gt; program = migrateUser(user);
        UserV2 migrated = OpticInterpreters.direct().run(program);
        saveNewUser(migrated);
    });
}
</code></pre>
<h3 id="validation-result-api"><a class="header" href="#validation-result-api">Validation Result API</a></h3>
<pre><code class="language-java">// Simple exception for validation failures
class ValidationException extends RuntimeException {
    public ValidationException(String message) {
        super(message);
    }
    public ValidationException(List&lt;String&gt; errors) {
        super("Validation failed: " + String.join(", ", errors));
    }
}

// Simple exception for business logic failures
class BusinessException extends RuntimeException {
    public BusinessException(String message, Throwable cause) {
        super(message, cause);
    }
}

public record ValidationResult(
    List&lt;String&gt; errors,    // Blocking issues
    List&lt;String&gt; warnings   // Non-blocking concerns
) {
    public boolean isValid() {
        return errors.isEmpty();
    }

    public boolean hasWarnings() {
        return !warnings.isEmpty();
    }
}
</code></pre>
<div id="admonition-testing-tip" class="admonition admonish-tip" role="note" aria-labelledby="admonition-testing-tip-title">
<div class="admonition-title">
<div id="admonition-testing-tip-title">
<p>Testing Tip</p>
</div>
<a class="admonition-anchor-link" href="optics/interpreters.html#admonition-testing-tip"></a>
</div>
<div>
<p>Use the validation interpreter in unit tests to verify programme structure without executing operations:</p>
<pre><code class="language-java">@Test
void testProgrammeLogic() {
    Free&lt;OpticOpKind.Witness, Person&gt; program =
        buildComplexProgram(testData);

    ValidationOpticInterpreter validator = OpticInterpreters.validating();
    ValidationResult result = validator.validate(program);

    // Verify no errors in logic
    assertTrue(result.isValid());
}
</code></pre>
</div>
</div>
<hr />
<h2 id="part-5-creating-custom-interpreters"><a class="header" href="#part-5-creating-custom-interpreters">Part 5: Creating Custom Interpreters</a></h2>
<p>You can create custom interpreters for specific needs: performance profiling, mocking, optimisation, or any other execution strategy.</p>
<h3 id="the-interpreter-interface"><a class="header" href="#the-interpreter-interface">The Interpreter Interface</a></h3>
<p>All interpreters implement a natural transformation from <code>OpticOp</code> to some effect type (usually <code>Id</code> for simplicity):</p>
<pre><code class="language-java">public interface OpticInterpreter {
    &lt;A&gt; A run(Free&lt;OpticOpKind.Witness, A&gt; program);
}
</code></pre>
<h3 id="example-1-performance-profiling-interpreter"><a class="header" href="#example-1-performance-profiling-interpreter">Example 1: Performance Profiling Interpreter</a></h3>
<pre><code class="language-java">public final class ProfilingOpticInterpreter {
    private final Map&lt;String, Long&gt; executionTimes = new HashMap&lt;&gt;();
    private final Map&lt;String, Integer&gt; executionCounts = new HashMap&lt;&gt;();

    public &lt;A&gt; A run(Free&lt;OpticOpKind.Witness, A&gt; program) {
        Function&lt;Kind&lt;OpticOpKind.Witness, ?&gt;, Kind&lt;IdKind.Witness, ?&gt;&gt; transform =
            kind -&gt; {
                OpticOp&lt;?, ?&gt; op = OpticOpKindHelper.OP.narrow(
                    (Kind&lt;OpticOpKind.Witness, Object&gt;) kind
                );

                String opName = getOperationName(op);
                long startTime = System.nanoTime();

                // Execute the operation
                Object result = executeOperation(op);

                long endTime = System.nanoTime();
                long duration = endTime - startTime;

                // Record metrics
                executionTimes.merge(opName, duration, Long::sum);
                executionCounts.merge(opName, 1, Integer::sum);

                return Id.of(result);
            };

        Kind&lt;IdKind.Witness, A&gt; resultKind =
            program.foldMap(transform, IdMonad.instance());
        return IdKindHelper.ID.narrow(resultKind).value();
    }

    public Map&lt;String, Long&gt; getAverageExecutionTimes() {
        Map&lt;String, Long&gt; averages = new HashMap&lt;&gt;();
        executionTimes.forEach((op, totalTime) -&gt; {
            int count = executionCounts.get(op);
            averages.put(op, totalTime / count);
        });
        return averages;
    }

    private String getOperationName(OpticOp&lt;?, ?&gt; op) {
        return switch (op) {
            case OpticOp.Get&lt;?, ?&gt; get -&gt; "GET: " + get.optic().getClass().getSimpleName();
            case OpticOp.Set&lt;?, ?&gt; set -&gt; "SET: " + set.optic().getClass().getSimpleName();
            case OpticOp.Modify&lt;?, ?&gt; mod -&gt; "MODIFY: " + mod.optic().getClass().getSimpleName();
            // ... other cases
            default -&gt; "UNKNOWN";
        };
    }

    private Object executeOperation(OpticOp&lt;?, ?&gt; op) {
        // Execute using direct interpretation logic
        return switch (op) {
            case OpticOp.Get&lt;?, ?&gt; get -&gt; get.optic().get(get.source());
            case OpticOp.Set&lt;?, ?&gt; set -&gt; set.optic().set(set.newValue(), set.source());
            case OpticOp.Modify&lt;?, ?&gt; mod -&gt; {
                var current = mod.optic().get(mod.source());
                var updated = mod.modifier().apply(current);
                yield mod.optic().set(updated, mod.source());
            }
            // ... other cases
        };
    }
}
</code></pre>
<p><strong>Usage:</strong></p>
<pre><code class="language-java">Free&lt;OpticOpKind.Witness, Team&gt; program = buildComplexTeamUpdate(team);

ProfilingOpticInterpreter profiler = new ProfilingOpticInterpreter();
Team result = profiler.run(program);

// Analyse performance
Map&lt;String, Long&gt; avgTimes = profiler.getAverageExecutionTimes();
avgTimes.forEach((op, time) -&gt;
    System.out.println(op + ": " + time + "ns average")
);
</code></pre>
<hr />
<h3 id="example-2-mock-interpreter-for-testing"><a class="header" href="#example-2-mock-interpreter-for-testing">Example 2: Mock Interpreter for Testing</a></h3>
<pre><code class="language-java">public final class MockOpticInterpreter&lt;S&gt; {
    private final S mockData;

    public MockOpticInterpreter(S mockData) {
        this.mockData = mockData;
    }

    @SuppressWarnings("unchecked")
    public &lt;A&gt; A run(Free&lt;OpticOpKind.Witness, A&gt; program) {
        Function&lt;Kind&lt;OpticOpKind.Witness, ?&gt;, Kind&lt;IdKind.Witness, ?&gt;&gt; transform =
            kind -&gt; {
                OpticOp&lt;?, ?&gt; op = OpticOpKindHelper.OP.narrow(
                    (Kind&lt;OpticOpKind.Witness, Object&gt;) kind
                );

                // All operations just return mock data
                Object result = switch (op) {
                    case OpticOp.Get&lt;?, ?&gt; ignored -&gt; mockData;
                    case OpticOp.Set&lt;?, ?&gt; ignored -&gt; mockData;
                    case OpticOp.Modify&lt;?, ?&gt; ignored -&gt; mockData;
                    case OpticOp.GetAll&lt;?, ?&gt; ignored -&gt; List.of(mockData);
                    case OpticOp.Preview&lt;?, ?&gt; ignored -&gt; Optional.of(mockData);
                    default -&gt; throw new UnsupportedOperationException(
                        "Unsupported operation: " + op.getClass().getSimpleName()
                    );
                };

                return Id.of(result);
            };

        Kind&lt;IdKind.Witness, A&gt; resultKind =
            program.foldMap(transform, IdMonad.instance());
        return IdKindHelper.ID.narrow(resultKind).value();
    }
}
</code></pre>
<p><strong>Usage in tests:</strong></p>
<pre><code class="language-java">@Test
void testBusinessLogic() {
    // Create mock data
    Person mockPerson = new Person("MockUser", 99);

    // Build programme (business logic)
    Free&lt;OpticOpKind.Witness, Person&gt; program =
        buildComplexBusinessLogic(mockPerson);

    // Execute with mock interpreter (no real data needed!)
    MockOpticInterpreter&lt;Person&gt; mock = new MockOpticInterpreter&lt;&gt;(mockPerson);
    Person result = mock.run(program);

    // Verify result
    assertEquals("MockUser", result.name());
}
</code></pre>
<hr />
<h2 id="part-6-combining-interpreters"><a class="header" href="#part-6-combining-interpreters">Part 6: Combining Interpreters</a></h2>
<p>You can run the same programme through multiple interpreters for powerful workflows:</p>
<h3 id="pattern-1-validate-then-execute"><a class="header" href="#pattern-1-validate-then-execute">Pattern 1: Validate-Then-Execute</a></h3>
<pre><code class="language-java">Free&lt;OpticOpKind.Witness, Order&gt; orderProcessing = buildOrderProgramme(order);

// Step 1: Validate
ValidationOpticInterpreter validator = OpticInterpreters.validating();
ValidationResult validation = validator.validate(orderProcessing);

if (!validation.isValid()) {
    validation.errors().forEach(System.err::println);
    throw new ValidationException("Order processing failed validation");
}

// Step 2: Execute with logging
LoggingOpticInterpreter logger = OpticInterpreters.logging();
Order result = logger.run(orderProcessing);

// Step 3: Persist audit trail
logger.getLog().forEach(entry -&gt; auditRepository.save(order.id(), entry));
</code></pre>
<hr />
<h3 id="pattern-2-profile-optimise-execute"><a class="header" href="#pattern-2-profile-optimise-execute">Pattern 2: Profile-Optimise-Execute</a></h3>
<pre><code class="language-java">Free&lt;OpticOpKind.Witness, Dataset&gt; dataProcessing = buildDataPipeline(dataset);

// Step 1: Profile to find bottlenecks
ProfilingOpticInterpreter profiler = new ProfilingOpticInterpreter();
profiler.run(dataProcessing);

Map&lt;String, Long&gt; times = profiler.getAverageExecutionTimes();
String slowest = times.entrySet().stream()
    .max(Map.Entry.comparingByValue())
    .map(Map.Entry::getKey)
    .orElse("none");

System.out.println("Slowest operation: " + slowest);

// Step 2: Optimise programme based on profiling
Free&lt;OpticOpKind.Witness, Dataset&gt; optimised = optimiseProgramme(
    dataProcessing,
    slowest
);

// Step 3: Execute optimised programme
Dataset result = OpticInterpreters.direct().run(optimised);
</code></pre>
<hr />
<h3 id="pattern-3-test-validate-execute-pipeline"><a class="header" href="#pattern-3-test-validate-execute-pipeline">Pattern 3: Test-Validate-Execute Pipeline</a></h3>
<pre><code class="language-java">// Development: Mock interpreter
MockOpticInterpreter&lt;Order&gt; mockInterp = new MockOpticInterpreter&lt;&gt;(mockOrder);
Order mockResult = mockInterp.run(programme);
assert mockResult.status() == OrderStatus.COMPLETED;

// Staging: Validation interpreter
ValidationResult validation = OpticInterpreters.validating().validate(programme);
assert validation.isValid();

// Production: Logging interpreter
LoggingOpticInterpreter logger = OpticInterpreters.logging();
Order prodResult = logger.run(programme);
logger.getLog().forEach(auditService::record);
</code></pre>
<hr />
<h2 id="part-7-best-practices"><a class="header" href="#part-7-best-practices">Part 7: Best Practices</a></h2>
<h3 id="choose-the-right-interpreter"><a class="header" href="#choose-the-right-interpreter">Choose the Right Interpreter</a></h3>
<div class="table-wrapper"><table><thead><tr><th><strong>Use Case</strong></th><th><strong>Interpreter</strong></th><th><strong>Reason</strong></th></tr></thead><tbody>
<tr><td>Production CRUD</td><td>Direct</td><td>Fast, simple</td></tr>
<tr><td>Financial transactions</td><td>Logging</td><td>Audit trail</td></tr>
<tr><td>Data migration</td><td>Validation</td><td>Safety checks</td></tr>
<tr><td>Unit tests</td><td>Mock/Custom</td><td>No dependencies</td></tr>
<tr><td>Performance tuning</td><td>Profiling</td><td>Measure impact</td></tr>
<tr><td>Compliance</td><td>Logging</td><td>Regulatory requirements</td></tr>
</tbody></table>
</div>
<hr />
<h3 id="interpreter-lifecycle"><a class="header" href="#interpreter-lifecycle">Interpreter Lifecycle</a></h3>
<pre><code class="language-java">// ‚úÖ Good: Reuse interpreter for multiple programmes
LoggingOpticInterpreter logger = OpticInterpreters.logging();

for (Transaction txn : transactions) {
    Free&lt;OpticOpKind.Witness, Transaction&gt; program = buildTransfer(txn);
    Transaction result = logger.run(program);
    // Log accumulates across programmes
}

List&lt;String&gt; fullAuditTrail = logger.getLog();

// ‚ùå Bad: Creating new interpreter each time loses history
for (Transaction txn : transactions) {
    LoggingOpticInterpreter logger = OpticInterpreters.logging();  // New each time!
    Transaction result = logger.run(buildTransfer(txn));
    // Can only see this programme's log
}
</code></pre>
<hr />
<h3 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h3>
<pre><code class="language-java">Free&lt;OpticOpKind.Witness, Order&gt; program = buildOrderProcessing(order);

// Wrap interpreter execution in try-catch
try {
    // Validate first
    ValidationResult validation = OpticInterpreters.validating().validate(program);

    if (!validation.isValid()) {
        throw new ValidationException(validation.errors());
    }

    // Execute with logging
    LoggingOpticInterpreter logger = OpticInterpreters.logging();
    Order result = logger.run(program);

    // Success - persist log
    auditRepository.saveAll(logger.getLog());

    return result;

} catch (ValidationException e) {
    // Handle validation errors
    logger.error("Validation failed", e);
    throw new BusinessException("Order processing failed validation", e);

} catch (Exception e) {
    // Handle execution errors
    logger.error("Execution failed", e);
    throw new BusinessException("Order processing failed", e);
}
</code></pre>
<hr />
<h2 id="further-reading-14"><a class="header" href="#further-reading-14">Further Reading</a></h2>
<ul>
<li><strong>Interpreter Pattern</strong>: <a href="https://en.wikipedia.org/wiki/Interpreter_pattern">Design Patterns: Elements of Reusable Object-Oriented Software</a> - Gang of Four</li>
<li><strong>Natural Transformations</strong>: <a href="https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/">Category Theory for Programmers</a> by Bartosz Milewski</li>
<li><strong>Free Monad Interpreters</strong>: <a href="http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html">Why free monads matter</a> by Gabriel Gonzalez</li>
<li><strong>Aspect-Oriented Programming</strong>: <a href="https://www.manning.com/books/aspectj-in-action-second-edition">AspectJ in Action</a> by Ramnivas Laddad</li>
<li><strong>Cross-Cutting Concerns</strong>: <a href="https://www.win.tue.nl/~wstomv/edu/2ip30/references/criteria_for_modularization.pdf">On the Criteria To Be Used in Decomposing Systems into Modules</a> by David Parnas</li>
</ul>
<hr />
<p><strong>Next Steps:</strong></p>
<ul>
<li><a href="optics/free_monad_dsl.html">Free Monad DSL for Optics</a> - Building composable programmes</li>
<li><a href="optics/fluent_api.html">Fluent API for Optics</a> - Direct execution patterns</li>
<li><a href="optics/optics_examples.html">Practical Examples</a> - Real-world applications</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="optics---basic-usage-examples"><a class="header" href="#optics---basic-usage-examples">Optics - Basic Usage Examples</a></h1>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="optics/optics_examples.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>Practical application patterns for optics across diverse problem domains</li>
<li>Building configuration processors, data validators, and API adapters with optics</li>
<li>Creating reusable optic libraries tailored to your specific business needs</li>
<li>Performance Optimisation techniques and benchmarking for complex optic compositions</li>
<li>Testing strategies for optic-based data processing pipelines</li>
<li>Decision frameworks for choosing the right optic combinations for real-world scenarios</li>
<li>Common anti-patterns to avoid and best practices for maintainable optic code</li>
</ul>
</div>
</div>
<div id="admonition-example-code" class="admonition admonish-note" role="note" aria-labelledby="admonition-example-code-title">
<div class="admonition-title">
<div id="admonition-example-code-title">
<p>Example Code</p>
</div>
<a class="admonition-anchor-link" href="optics/optics_examples.html#admonition-example-code"></a>
</div>
<div>
<p>This document provides a brief summary of the example classes found in the  <code>org.higherkindedj.example.optics</code> package in the <a href="https://github.com/higher-kinded-j/higher-kinded-j/tree/main/hkj-examples/src/main/java/org/higherkindedj/example/optics">HKJ-Examples</a>.</p>
</div>
</div>
<p>These examples showcase how to use the code generation features (<code>@GenerateLenses</code>, <code>@GeneratePrisms</code>, <code>@GenerateTraversals</code>) and the resulting optics to work with immutable data structures in a clean and powerful way.</p>
<h2 id="lensusageexamplejava"><a class="header" href="#lensusageexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/tree/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/LensUsageExample.java">LensUsageExample.java</a></a></h2>
<p>This example is the primary introduction to <strong>Lenses</strong>. It demonstrates how to automatically generate <code>Lens</code> optics for immutable records and then compose them to read and update deeply nested fields.</p>
<ul>
<li><strong>Key Concept</strong>: A <code>Lens</code> provides a focus on a single field within a product type (like a record or class).</li>
<li><strong>Demonstrates</strong>:
<ul>
<li>Defining a nested data model (<code>League</code>, <code>Team</code>, <code>Player</code>).</li>
<li>Using <code>@GenerateLenses</code> on records to trigger code generation.</li>
<li>Accessing generated Lenses (e.g., <code>LeagueLenses.teams()</code>).</li>
<li>Composing Lenses with <code>andThen()</code> to create a path to a deeply nested field.</li>
<li>Using <code>get()</code> to read a value and <code>set()</code> to perform an immutable update.</li>
</ul>
</li>
</ul>
<pre><code class="language-java">// Composing lenses to focus from League -&gt; Team -&gt; name
Lens&lt;League, String&gt; leagueToTeamName = LeagueLenses.teams().andThen(TeamLenses.name());

// Use the composed lens to get and set a value
String teamName = leagueToTeamName.get(league);
League updatedLeague = leagueToTeamName.set("New Team Name").apply(league);
</code></pre>
<h2 id="prismusageexamplejava"><a class="header" href="#prismusageexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/tree/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/PrismUsageExample.java">PrismUsageExample.java</a></a></h2>
<p>This example introduces <strong>Prisms</strong>. It shows how to generate optics for a sealed interface (a sum type) and use the resulting <code>Prism</code> to focus on a specific implementation of that interface.</p>
<ul>
<li><strong>Key Concept</strong>: A <code>Prism</code> provides a focus on a specific case within a sum type (like a sealed interface or enum). It succeeds if the object is an instance of that case.</li>
<li><strong>Demonstrates</strong>:
<ul>
<li>Defining a <code>sealed interface</code> (<code>Shape</code>) with different implementations (<code>Rectangle</code>, <code>Circle</code>).</li>
<li>Using <code>@GeneratePrisms</code> on the sealed interface.</li>
<li>Using the generated <code>Prism</code> to safely "get" an instance of a specific subtype.</li>
<li>Using <code>modify()</code> to apply a function only if the object is of the target type.</li>
</ul>
</li>
</ul>
<pre><code class="language-java">  // Get the generated prism for the Rectangle case
  Prism&lt;Shape, Rectangle&gt; rectanglePrism = ShapePrisms.rectangle();
  
  // Safely attempt to modify a shape, which only works if it's a Rectangle
  Optional&lt;Shape&gt; maybeUpdated = rectanglePrism.modify(r -&gt; new Rectangle(r.width() + 10, r.height()))
                                    .apply(new Rectangle(5, 10)); // Returns Optional[Rectangle[width=15, height=10]]
  
  Optional&lt;Shape&gt; maybeNotUpdated = rectanglePrism.modify(...)
                                       .apply(new Circle(20.0)); // Returns Optional.empty
</code></pre>
<h2 id="traversalusageexamplejava"><a class="header" href="#traversalusageexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/tree/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/TraversalUsageExample.java">TraversalUsageExample.java</a></a></h2>
<p>This example showcases the power of composing <strong>Traversals</strong> and <strong>Lenses</strong> to perform bulk updates on items within nested collections.</p>
<ul>
<li><strong>Key Concept</strong>: A <code>Traversal</code> provides a focus on zero or more elements, such as all items in a <code>List</code> or all values in a <code>Map</code>.</li>
<li><strong>Demonstrates</strong>:
<ul>
<li>Using <code>@GenerateTraversals</code> to create optics for fields that are collections (<code>List&lt;Team&gt;</code>, <code>List&lt;Player&gt;</code>).</li>
<li>Composing a <code>Traversal</code> with another <code>Traversal</code> and a <code>Lens</code> to create a single optic that focuses on a field within every element of a nested collection.</li>
<li>Using <code>modifyF()</code> with the <code>Id</code> monad to perform a pure, bulk update (e.g., adding bonus points to every player's score).</li>
</ul>
</li>
</ul>
<pre><code class="language-java">  // Compose a path from League -&gt; each Team -&gt; each Player -&gt; score
  Traversal&lt;League, Integer&gt; leagueToAllPlayerScores =
      LeagueTraversals.teams()
          .andThen(TeamTraversals.players())
          .andThen(PlayerLenses.score());

  // Use the composed traversal to add 5 to every player's score
  var updatedLeague = IdKindHelper.ID.narrow(
      leagueToAllPlayerScores.modifyF(
          score -&gt; Id.of(score + 5), league, IdMonad.instance()
      )
  ).value();
</code></pre>
<h2 id="partsoftraversalexamplejava"><a class="header" href="#partsoftraversalexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/tree/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/PartsOfTraversalExample.java">PartsOfTraversalExample.java</a></a></h2>
<p>This example demonstrates the <strong>partsOf</strong> combinator for list-level manipulation of traversal focuses. It shows how to convert a <code>Traversal</code> into a <code>Lens</code> on a <code>List</code>, enabling powerful operations like sorting, reversing, and deduplicating focused elements whilst maintaining structure integrity.</p>
<ul>
<li><strong>Key Concept</strong>: <code>partsOf</code> bridges element-wise traversal operations and collection-level algorithms by treating all focuses as a single list.</li>
<li><strong>Demonstrates</strong>:
<ul>
<li>Converting a <code>Traversal&lt;S, A&gt;</code> into a <code>Lens&lt;S, List&lt;A&gt;&gt;</code> with <code>Traversals.partsOf()</code>.</li>
<li>Extracting all focused elements as a list for group-level operations.</li>
<li>Using convenience methods: <code>Traversals.sorted()</code>, <code>Traversals.reversed()</code>, <code>Traversals.distinct()</code>.</li>
<li>Custom comparator sorting (case-insensitive, by length, reverse order).</li>
<li>Combining <code>partsOf</code> with filtered traversals for selective list operations.</li>
<li>Understanding size mismatch behaviour (graceful degradation).</li>
<li>Real-world use case: normalising prices across an e-commerce catalogue.</li>
</ul>
</li>
</ul>
<pre><code class="language-java">  // Convert traversal to lens on list of all prices
  Traversal&lt;Catalogue, Double&gt; allPrices = CatalogueTraversals.categories()
      .andThen(CategoryTraversals.products())
      .andThen(ProductLenses.price().asTraversal());
  Lens&lt;Catalogue, List&lt;Double&gt;&gt; pricesLens = Traversals.partsOf(allPrices);

  // Sort all prices across the entire catalogue
  Catalogue sortedCatalogue = Traversals.sorted(allPrices, catalogue);

  // Reverse prices (highest to lowest)
  Catalogue reversedCatalogue = Traversals.reversed(allPrices, sortedCatalogue);

  // Remove duplicate product names
  List&lt;Product&gt; deduplicatedProducts = Traversals.distinct(nameTraversal, products);

  // Sort only in-stock product prices (combining with filtered traversals)
  Traversal&lt;List&lt;Product&gt;, Double&gt; inStockPrices = Traversals.&lt;Product&gt;forList()
      .filtered(p -&gt; p.stockLevel() &gt; 0)
      .andThen(ProductLenses.price().asTraversal());
  List&lt;Product&gt; result = Traversals.sorted(inStockPrices, products);
</code></pre>
<h2 id="foldusageexamplejava"><a class="header" href="#foldusageexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/tree/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/FoldUsageExample.java">FoldUsageExample.java</a></a></h2>
<p>This example demonstrates <strong>Folds</strong> for read-only querying and data extraction from complex structures.</p>
<ul>
<li><strong>Key Concept</strong>: A <code>Fold</code> is a read-only optic that focuses on zero or more elements, perfect for queries, searches, and aggregations without modification.</li>
<li><strong>Demonstrates</strong>:
<ul>
<li>Using <code>@GenerateFolds</code> to create query optics automatically.</li>
<li>Using <code>getAll()</code>, <code>preview()</code>, <code>find()</code>, <code>exists()</code>, <code>all()</code>, <code>isEmpty()</code>, and <code>length()</code> operations for querying data.</li>
<li>Composing folds for deep queries across nested structures.</li>
<li>Using standard monoids from <code>Monoids</code> utility class (<code>Monoids.doubleAddition()</code>, <code>Monoids.booleanAnd()</code>, <code>Monoids.booleanOr()</code>).</li>
<li>Using <code>foldMap</code> with monoids for custom aggregations (sum, product, boolean operations).</li>
<li>Contrasting Fold (read-only) with Traversal (read-write) to express intent clearly.</li>
</ul>
</li>
</ul>
<pre><code class="language-java">  // Get all products from an order
  Fold&lt;Order, ProductItem&gt; items = OrderFolds.items();
  List&lt;ProductItem&gt; allProducts = items.getAll(order);

  // Check if any product is out of stock
  boolean hasOutOfStock = items.exists(p -&gt; !p.inStock(), order);

  // Calculate total price using standard monoid from Monoids utility class
  Monoid&lt;Double&gt; sumMonoid = Monoids.doubleAddition();
  double total = items.foldMap(sumMonoid, ProductItem::price, order);

  // Use boolean monoids for condition checking
  Monoid&lt;Boolean&gt; andMonoid = Monoids.booleanAnd();
  boolean allAffordable = items.foldMap(andMonoid, p -&gt; p.price() &lt; 1000, order);

  // Compose folds for deep queries
  Fold&lt;OrderHistory, ProductItem&gt; allProductsInHistory =
      OrderHistoryFolds.orders().andThen(OrderFolds.items());
  List&lt;ProductItem&gt; allProds = allProductsInHistory.getAll(history);
</code></pre>
<h2 id="validatedtraversalexamplejava"><a class="header" href="#validatedtraversalexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/tree/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/ValidatedTraversalExample.java">ValidatedTraversalExample.java</a></a></h2>
<p>This example demonstrates a more advanced use case for <strong>Traversals</strong> where the goal is to validate multiple fields on a single object and accumulate all errors.</p>
<ul>
<li><strong>Key Concept</strong>: A <code>Traversal</code> can focus on multiple fields <em>of the same type</em> within a single object.</li>
<li><strong>Demonstrates</strong>:
<ul>
<li>Defining a <code>RegistrationForm</code> with several <code>String</code> fields.</li>
<li>Using <code>@GenerateTraversals</code> with a custom <code>name</code> parameter to create a single <code>Traversal</code> that groups multiple fields (<code>name</code>, <code>email</code>, <code>password</code>).</li>
<li>Using this traversal with <code>Validated</code> to run a validation function on each field.</li>
<li>Because <code>Validated</code> has an <code>Applicative</code> that accumulates errors, the end result is a <code>Validated</code> object containing either the original form or a list of all validation failures.</li>
</ul>
</li>
</ul>
<h2 id="opticprofunctorexamplejava"><a class="header" href="#opticprofunctorexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/tree/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/profunctor/OpticProfunctorExample.java">OpticProfunctorExample.java</a></a></h2>
<p>This comprehensive example demonstrates the <strong>profunctor</strong> capabilities of optics, showing how to adapt existing optics to work with different data types and structures.</p>
<ul>
<li>
<p><strong>Key Concept</strong>: Every optic is a profunctor, meaning it can be adapted using <code>contramap</code>, <code>map</code>, and <code>dimap</code> operations to work with different source and target types.</p>
</li>
<li>
<p><strong>Demonstrates</strong>:</p>
<ul>
<li><strong>Contramap-style adaptation</strong>: Using an existing <code>Person</code> lens with <code>Employee</code> objects by providing a conversion function.</li>
<li><strong>Map-style adaptation</strong>: Transforming the target type of a lens (e.g., <code>LocalDate</code> to formatted <code>String</code>).</li>
<li><strong>Dimap-style adaptation</strong>: Converting between completely different data representations (e.g., internal models vs external DTOs).</li>
<li><strong>API Integration</strong>: Creating adapters for external API formats whilst reusing internal optics.</li>
<li><strong>Type-safe wrappers</strong>: Working with strongly-typed wrapper classes efficiently.</li>
</ul>
<pre><code class="language-java">// Adapt a Person lens to work with Employee objects
Lens&lt;Person, String&gt; firstNameLens = PersonLenses.firstName();
Lens&lt;Employee, String&gt; employeeFirstNameLens = 
    firstNameLens.contramap(employee -&gt; employee.personalInfo());

// Adapt a lens to work with different target types
Lens&lt;Person, LocalDate&gt; birthDateLens = PersonLenses.birthDate();
Lens&lt;Person, String&gt; birthDateStringLens = 
    birthDateLens.map(date -&gt; date.format(DateTimeFormatter.ISO_LOCAL_DATE));
</code></pre>
</li>
</ul>
<h2 id="traversal-examples"><a class="header" href="#traversal-examples">Traversal Examples</a></h2>
<p>These examples focus on using generated traversals for specific collection and container types, often demonstrating "effectful" traversals where each operation can succeed or fail.</p>
<h3 id="listtraversalexamplejava"><a class="header" href="#listtraversalexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/tree/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/traversal/list/ListTraversalExample.java">ListTraversalExample.java</a></a></h3>
<ul>
<li><strong>Demonstrates</strong>: Traversing a <code>List&lt;String&gt;</code> field.</li>
<li><strong>Scenario</strong>: A <code>Project</code> has a list of team members. The traversal is used with a <code>lookupUser</code> function that returns a <code>Validated</code> type. This allows validating every member in the list. If any lookup fails, the entire operation results in an <code>Invalid</code>.</li>
</ul>
<h3 id="arraytraversalexamplejava"><a class="header" href="#arraytraversalexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/tree/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/traversal/array/ArrayTraversalExample.java">ArrayTraversalExample.java</a></a></h3>
<ul>
<li><strong>Demonstrates</strong>: Traversing an <code>Integer[]</code> field.</li>
<li><strong>Scenario</strong>: A <code>Survey</code> has an array of answers. The traversal is used with a validation function to ensure every answer is within a valid range (1-5), accumulating errors with <code>Validated</code>.</li>
</ul>
<h3 id="settraversalexamplejava"><a class="header" href="#settraversalexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/tree/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/traversal/set/SetTraversalExample.java">SetTraversalExample.java</a></a></h3>
<ul>
<li><strong>Demonstrates</strong>: Traversing a <code>Set&lt;String&gt;</code> field.</li>
<li><strong>Scenario</strong>: A <code>UserGroup</code> has a set of member emails. The traversal validates that every email in the set has a valid format (<code>contains "@"</code>).</li>
</ul>
<h3 id="mapvaluetraversalexamplejava"><a class="header" href="#mapvaluetraversalexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/tree/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/traversal/map/MapValueTraversalExample.java">MapValueTraversalExample.java</a></a></h3>
<ul>
<li><strong>Demonstrates</strong>: Traversing the <em>values</em> of a <code>Map&lt;String, Boolean&gt;</code> field.</li>
<li><strong>Scenario</strong>: A <code>FeatureToggles</code> record holds a map of flags. The traversal focuses on every <code>Boolean</code> value in the map, allowing for a bulk update to disable all features at once.</li>
</ul>
<h3 id="eithertraversalexamplejava"><a class="header" href="#eithertraversalexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/tree/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/traversal/either/EitherTraversalExample.java">EitherTraversalExample.java</a></a></h3>
<ul>
<li><strong>Demonstrates</strong>: Traversing an <code>Either&lt;String, Integer&gt;</code> field.</li>
<li><strong>Scenario</strong>: A <code>Computation</code> can result in a success (<code>Right</code>) or failure (<code>Left</code>). The traversal shows that <code>modifyF</code> only affects the value if the <code>Either</code> is a <code>Right</code>, leaving a <code>Left</code> untouched.</li>
</ul>
<h3 id="maybetraversalexamplejava"><a class="header" href="#maybetraversalexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/tree/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/traversal/maybe/MaybeTraversalExample.java">MaybeTraversalExample.java</a></a></h3>
<ul>
<li><strong>Demonstrates</strong>: Traversing a <code>Maybe&lt;String&gt;</code> field.</li>
<li><strong>Scenario</strong>: A <code>Configuration</code> has an optional <code>proxyHost</code>. The traversal shows that an operation is only applied if the <code>Maybe</code> is a <code>Just</code>, leaving a <code>Nothing</code> untouched, which is analogous to the <code>Either</code> example.</li>
</ul>
<h3 id="optionaltraversalexamplejava"><a class="header" href="#optionaltraversalexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/tree/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/traversal/optional/OptionalTraversalExample.java">OptionalTraversalExample.java</a></a></h3>
<ul>
<li><strong>Demonstrates</strong>: Traversing a <code>java.util.Optional&lt;String&gt;</code> field.</li>
<li><strong>Scenario</strong>: A <code>User</code> record has an optional <code>middleName</code>. The traversal is used to apply a function (like <code>toUpperCase</code>) to the middle name only if it is present. This shows how to work with standard Java types in a functional way.</li>
</ul>
<h3 id="trytraversalexamplejava"><a class="header" href="#trytraversalexamplejava"><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/traversal/trymonad/TryTraversalExample.java">TryTraversalExample.java</a></a></h3>
<ul>
<li><strong>Demonstrates</strong>: Traversing a <code>Try&lt;Integer&gt;</code> field.</li>
<li><strong>Scenario</strong>: A <code>NetworkRequest</code> record holds the result of an operation that could have thrown an exception, wrapped in a <code>Try</code>. The traversal allows modification of the value only if the <code>Try</code> is a <code>Success</code>, leaving a <code>Failure</code> (containing an exception) unchanged.</li>
</ul>
<p><strong>Previous:</strong> <a href="optics/composing_optics.html">Profunctor Optics: Advanced Data Transformation</a>
<strong>Next:</strong> <a href="optics/auditing_complex_data_example.html">Auditing Complex Data: The Power of Optics</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="auditing-complex-data-with-optics"><a class="header" href="#auditing-complex-data-with-optics">Auditing Complex Data with Optics</a></h1>
<h2 id="a-real-world-deep-dive-the-power-of-optics"><a class="header" href="#a-real-world-deep-dive-the-power-of-optics"><em>A Real-World Deep Dive</em>: The Power of Optics</a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="optics/auditing_complex_data_example.html#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>Solving complex, real-world data processing challenges with optics</li>
<li>Building conditional filtering and transformation pipelines</li>
<li>Combining all four core optic types in a single, powerful composition</li>
<li>Creating declarative, type-safe alternatives to nested loops and type casting</li>
<li>Advanced patterns like safe decoding, profunctor adaptations, and audit trails</li>
<li>When optic composition provides superior solutions to imperative approaches</li>
</ul>
</div>
</div>
<p>In modern software, we often work with complex, nested data structures. Performing a seemingly simple task‚Äîlike "find and decode all production database passwords"‚Äîcan lead to messy, error-prone code with nested loops, <code>if</code> statements, and manual type casting.</p>
<p>This tutorial demonstrates how to solve a sophisticated, real-world problem elegantly using the full power of <strong>higher-kinded-j optics</strong>. We'll build a single, declarative, type-safe optic that performs a deep, conditional data transformation.</p>
<div id="admonition-example-code" class="admonition admonish-note" role="note" aria-labelledby="admonition-example-code-title">
<div class="admonition-title">
<div id="admonition-example-code-title">
<p>Example Code</p>
</div>
<a class="admonition-anchor-link" href="optics/auditing_complex_data_example.html#admonition-example-code"></a>
</div>
<div>
<p>All the example code for this tutorial can be found in the  `org.higherkindedj.example package in the <a href="https://github.com/higher-kinded-j/higher-kinded-j/tree/main/hkj-examples/src/main/java/org/higherkindedj/example/configaudit">Config Audit example</a>.</p>
<p>Other examples of using Optics can be found here.
<a href="https://github.com/higher-kinded-j/higher-kinded-j/tree/main/hkj-examples/src/main/java/org/higherkindedj/example/optics">Optics examples</a>.</p>
</div>
</div>
<hr />
<h2 id="-the-challenge-a-conditional-config-audit"><a class="header" href="#-the-challenge-a-conditional-config-audit">üéØ The Challenge: A Conditional Config Audit</a></h2>
<p>Imagine you're responsible for auditing application configurations. Your task is:</p>
<blockquote>
<p>Find every encrypted database password, but <strong>only</strong> for applications deployed to the <strong>Google Cloud Platform (<code>gcp</code>)</strong> that are running in the <strong><code>live</code> environment</strong>. For each password found, <strong>decode it from Base64</strong> into a raw <code>byte[]</code> for an audit service.</p>
</blockquote>
<p>This single sentence implies several operations:</p>
<ol>
<li><strong>Deep Traversal</strong>: Navigate from a top-level config object down into a list of settings.</li>
<li><strong>Filtering</strong>: Select only settings of a specific type (<code>EncryptedValue</code>).</li>
<li><strong>Conditional Logic</strong>: Apply this logic <em>only</em> if the top-level config meets specific criteria (<code>gcp</code> and <code>live</code>).</li>
<li><strong>Data Transformation</strong>: Decode the Base64 string into another type (<code>byte[]</code>).</li>
</ol>
<p>Doing this imperatively is a recipe for complexity. Let's build it with optics instead.</p>
<hr />
<h2 id="think-of-this-problem-like"><a class="header" href="#think-of-this-problem-like">Think of This Problem Like...</a></h2>
<ul>
<li><strong>A treasure hunt with conditional maps</strong>: Only certain maps (GCP/Live configs) contain the treasures (encrypted passwords)</li>
<li><strong>A selective mining operation</strong>: Drill down only into the right geological formations (config types) to extract specific minerals (encrypted data)</li>
<li><strong>A security scanner with filters</strong>: Only scan certain types of systems (matching deployment criteria) for specific vulnerabilities (encrypted values)</li>
<li><strong>A data archaeology expedition</strong>: Excavate only specific sites (qualified configs) to uncover particular artifacts (encoded passwords)</li>
</ul>
<hr />
<h2 id="-the-four-tools-for-the-job"><a class="header" href="#-the-four-tools-for-the-job">üõ†Ô∏è The Four Tools for the Job</a></h2>
<p>Our solution will compose the four primary optic types, each solving a specific part of the problem.</p>
<h3 id="1-lens-the-magnifying-glass-"><a class="header" href="#1-lens-the-magnifying-glass-">1. <strong>Lens</strong>: The Magnifying Glass üîé</a></h3>
<p>A <code>Lens</code> provides focused access to a field within a product type (like a Java <code>record</code>). We'll use lenses to look inside our configuration objects.</p>
<ul>
<li><code>AppConfigLenses.settings()</code>: Zooms from an <code>AppConfig</code> to its <code>List&lt;Setting&gt;</code>.</li>
<li><code>SettingLenses.value()</code>: Zooms from a <code>Setting</code> to its <code>SettingValue</code>.</li>
</ul>
<h3 id="2-iso-the-universal-translator-"><a class="header" href="#2-iso-the-universal-translator-">2. <strong>Iso</strong>: The Universal Translator üîÑ</a></h3>
<p>An <code>Iso</code> (Isomorphism) defines a lossless, two-way conversion between two types. It's perfect for handling different representations of the same data.</p>
<ul>
<li><code>DeploymentTarget &lt;-&gt; String</code>: We model our deployment target as a structured record but recognise it's isomorphic to a raw string like <code>"gcp|live"</code>. An <code>Iso</code> lets us switch between these representations.</li>
<li><code>String &lt;-&gt; byte[]</code>: Base64 is just an encoded representation of a byte array. An <code>Iso</code> is the perfect tool for handling this encoding and decoding.</li>
</ul>
<h3 id="3-prism-the-safe-filter-"><a class="header" href="#3-prism-the-safe-filter-">3. <strong>Prism</strong>: The Safe Filter üî¨</a></h3>
<p>A <code>Prism</code> provides focused access to a specific case within a sum type (like a <code>sealed interface</code>). It lets us safely attempt to "zoom in" on one variant, failing gracefully if the data is of a different kind.</p>
<ul>
<li><code>SettingValuePrisms.encryptedValue()</code>: This is our key filter. It will look at a <code>SettingValue</code> and only succeed if it's the <code>EncryptedValue</code> variant.</li>
</ul>
<h3 id="4-traversal-the-bulk-operator-"><a class="header" href="#4-traversal-the-bulk-operator-">4. <strong>Traversal</strong>: The Bulk Operator üó∫Ô∏è</a></h3>
<p>A <code>Traversal</code> lets us operate on zero or more targets within a larger structure. It's the ideal optic for working with collections.</p>
<ul>
<li><code>AppConfigTraversals.settings()</code>: This generated optic gives us a single tool to go from an <code>AppConfig</code> to every <code>Setting</code> inside its list.</li>
</ul>
<hr />
<h2 id="when-to-use-this-approach-vs-alternatives"><a class="header" href="#when-to-use-this-approach-vs-alternatives">When to Use This Approach vs Alternatives</a></h2>
<h3 id="use-optic-composition-when-1"><a class="header" href="#use-optic-composition-when-1">Use Optic Composition When:</a></h3>
<ul>
<li><strong>Complex conditional filtering</strong> - Multiple levels of filtering based on different criteria</li>
<li><strong>Reusable audit logic</strong> - The same audit pattern applies to different config types</li>
<li><strong>Type-safe data extraction</strong> - Ensuring compile-time safety for complex transformations</li>
<li><strong>Declarative data processing</strong> - Building self-documenting processing pipelines</li>
</ul>
<pre><code class="language-java">
// Perfect for reusable, conditional audit logic Traversal&lt;ServerConfig, byte[]&gt; sensitiveDataAuditor = ServerConfigTraversals.environments() .andThen(EnvironmentPrisms.production().asTraversal()) .andThen(EnvironmentTraversals.credentials()) .andThen(CredentialPrisms.encrypted().asTraversal()) .andThen(EncryptedCredentialIsos.base64ToBytes.asTraversal());

</code></pre>
<h3 id="use-stream-processing-when-1"><a class="header" href="#use-stream-processing-when-1">Use Stream Processing When:</a></h3>
<ul>
<li><strong>Simple filtering</strong> - Basic collection operations without complex nesting</li>
<li><strong>Performance critical paths</strong> - Minimal abstraction overhead needed</li>
<li><strong>Aggregation logic</strong> - Computing statistics or summaries</li>
</ul>
<pre><code class="language-java">
// Better with streams for simple collection processing List&lt;String&gt; allConfigNames = configs.stream() .map(AppConfig::name) .filter(name -&gt; name.startsWith("prod-")) .collect(toList());

</code></pre>
<h3 id="use-manual-iteration-when"><a class="header" href="#use-manual-iteration-when">Use Manual Iteration When:</a></h3>
<ul>
<li><strong>Early termination</strong> - You might want to stop processing on first match</li>
<li><strong>Complex business logic</strong> - Multiple conditions and branches that don't map cleanly</li>
<li><strong>Legacy integration</strong> - Working with existing imperative codebases</li>
</ul>
<pre><code class="language-java">
// Sometimes manual loops are clearest for complex logic for (AppConfig config : configs) { if (shouldAudit(config) &amp;&amp; hasEncryptedData(config)) { auditResults.add(performDetailedAudit(config)); if (auditResults.size() &gt;= MAX\_AUDITS) break; } }

</code></pre>
<hr />
<h2 id="common-pitfalls-17"><a class="header" href="#common-pitfalls-17">Common Pitfalls</a></h2>
<h3 id="-dont-do-this-11"><a class="header" href="#-dont-do-this-11">‚ùå Don't Do This:</a></h3>
<pre><code class="language-java">
// Over-engineering simple cases Traversal&lt;String, String&gt; stringIdentity = Iso.of(s -&gt; s, s -&gt; s).asTraversal(); // Just use the string directly!

// Creating complex compositions inline var passwords = AppConfigLenses.settings().asTraversal() .andThen(SettingLenses.value().asTraversal()) .andThen(SettingValuePrisms.encryptedValue().asTraversal()) // ... 10 more lines of composition .getAll(config); // Hard to understand and reuse

// Ignoring error handling in transformations Iso&lt;String, byte[]&gt; unsafeBase64 = Iso.of( Base64.getDecoder()::decode,  // Can throw IllegalArgumentException! Base64.getEncoder()::encodeToString );

// Forgetting to test round-trip properties // No verification that encode(decode(x)) == x

</code></pre>
<h3 id="-do-this-instead-11"><a class="header" href="#-do-this-instead-11">‚úÖ Do This Instead:</a></h3>
<pre><code class="language-java">
// Use appropriate tools for simple cases String configName = config.name(); // Direct access is fine

// Create well-named, reusable compositions public static final Traversal&lt;AppConfig, byte[]&gt; GCP\_LIVE\_ENCRYPTED\_PASSWORDS = gcpLiveOnlyPrism.asTraversal() .andThen(AppConfigTraversals.settings()) .andThen(SettingLenses.value().asTraversal()) .andThen(SettingValuePrisms.encryptedValue().asTraversal()) .andThen(EncryptedValueLenses.base64Value().asTraversal()) .andThen(EncryptedValueIsos.base64.asTraversal());

// Handle errors gracefully Prism&lt;String, byte[]&gt; safeBase64Prism = Prism.of( str -&gt; { try { return Optional.of(Base64.getDecoder().decode(str)); } catch (IllegalArgumentException e) { return Optional.empty(); } }, bytes -&gt; Base64.getEncoder().encodeToString(bytes) );

// Test your compositions @Test public void testBase64RoundTrip() { String original = "test data"; String encoded = Base64.getEncoder().encodeToString(original.getBytes()); byte[] decoded = EncryptedValueIsos.base64.get(encoded); String roundTrip = new String(decoded); assertEquals(original, roundTrip); }

</code></pre>
<hr />
<h2 id="performance-notes-11"><a class="header" href="#performance-notes-11">Performance Notes</a></h2>
<p>Optic compositions are optimised for complex data processing:</p>
<ul>
<li><strong>Lazy evaluation</strong>: Complex filters only run when data actually matches</li>
<li><strong>Single-pass processing</strong>: Compositions traverse data structures only once</li>
<li><strong>Memory efficient</strong>: Only creates new objects for actual transformations</li>
<li><strong>Compile-time optimisation</strong>: Complex optic chains are inlined by the JVM</li>
<li><strong>Structural sharing</strong>: Unchanged parts of data structures are reused</li>
</ul>
<p><strong>Best Practice</strong>: Profile your specific use case and compare with stream-based alternatives:</p>
<pre><code class="language-java">
public class AuditPerformance { // For frequent auditing, create optics once and reuse 
    private static final Traversal&lt;AppConfig, byte[]&gt; AUDIT_TRAVERSAL = createAuditTraversal();

    @Benchmark
    public List&lt;byte[]&gt; opticBasedAudit(List&lt;AppConfig&gt; configs) {
        return configs.stream()
            .flatMap(config -&gt; Traversals.getAll(AUDIT_TRAVERSAL, config).stream())
            .collect(toList());
    }
  
    @Benchmark  
    public List&lt;byte[]&gt; streamBasedAudit(List&lt;AppConfig&gt; configs) {
        return configs.stream()
            .filter(this::isGcpLive)
            .flatMap(config -&gt; config.settings().stream())
            .map(Setting::value)
            .filter(EncryptedValue.class::isInstance)
            .map(EncryptedValue.class::cast)
            .map(encrypted -&gt; Base64.getDecoder().decode(encrypted.base64Value()))
            .collect(toList());
    }

}
</code></pre>
<h2 id="-composing-the-solution"><a class="header" href="#-composing-the-solution">‚ú® Composing the Solution</a></h2>
<p>Here's how we chain these optics together. To create the most robust and general-purpose optic (a <code>Traversal</code>), we convert each part of our chain into a <code>Traversal</code> using <code>.asTraversal()</code> before composing it. This ensures type-safety and clarity throughout the process.</p>
<p>The final composed optic has the type <code>Traversal&lt;AppConfig, byte[]&gt;</code> and reads like a declarative path: <strong><code>AppConfig -&gt; (Filter for GCP/Live) -&gt; each Setting -&gt; its Value -&gt; (Filter for Encrypted) -&gt; the inner String -&gt; the raw bytes</code></strong></p>
<pre><code class="language-java">// Inside ConfigAuditExample.java

// A. First, create a Prism to act as our top-level filter.
Prism&lt;AppConfig, AppConfig&gt; gcpLiveOnlyPrism = Prism.of(
    config -&gt; {
        String rawTarget = DeploymentTarget.toRawString().get(config.target());
        return "gcp|live".equals(rawTarget) ? Optional.of(config) : Optional.empty();
    },
    config -&gt; config // The 'build' function is just identity
);

// B. Define the main traversal path to get to the data we want to audit.
Traversal&lt;AppConfig, byte[]&gt; auditTraversal =
    AppConfigTraversals.settings()                             // Traversal&lt;AppConfig, Setting&gt;
        .andThen(SettingLenses.value().asTraversal())        // Traversal&lt;AppConfig, SettingValue&gt;
        .andThen(SettingValuePrisms.encryptedValue().asTraversal()) // Traversal&lt;AppConfig, EncryptedValue&gt;
        .andThen(EncryptedValueLenses.base64Value().asTraversal())  // Traversal&lt;AppConfig, String&gt;
        .andThen(EncryptedValueIsos.base64.asTraversal());   // Traversal&lt;AppConfig, byte[]&gt;

// C. Combine the filter and the main traversal into the final optic.
Traversal&lt;AppConfig, byte[]&gt; finalAuditor = gcpLiveOnlyPrism.asTraversal().andThen(auditTraversal);

// D. Using the final optic is now trivial.
// We call a static helper method from our Traversals utility class.
List&lt;byte[]&gt; passwords = Traversals.getAll(finalAuditor, someConfig);
</code></pre>
<p>When we call <code>Traversals.getAll(finalAuditor, config)</code>, it performs the entire, complex operation and returns a simple <code>List&lt;byte[]&gt;</code> containing only the data we care about.</p>
<hr />
<h2 id="-why-this-is-a-powerful-approach"><a class="header" href="#-why-this-is-a-powerful-approach">üöÄ Why This is a Powerful Approach</a></h2>
<ul>
<li><strong>Declarative &amp; Readable</strong>: The optic chain describes <em>what</em> data to get, not <em>how</em> to loop and check for it. The logic reads like a path, making it self-documenting.</li>
<li><strong>Composable &amp; Reusable</strong>: Every optic, and every composition, is a reusable component. We could reuse <code>gcpLiveOnlyPrism</code> for other tasks, or swap out the final <code>base64</code> Iso to perform a different transformation.</li>
<li><strong>Type-Safe</strong>: The entire operation is checked by the Java compiler. It's impossible to, for example, try to decode a <code>StringValue</code> as if it were encrypted. A mismatch in the optic chain results in a compile-time error, not a runtime <code>ClassCastException</code>.</li>
<li><strong>Architectural Purity</strong>: By having all optics share a common abstract parent (<code>Optic</code>), the library provides universal, lawful composition while allowing for specialised, efficient implementations.</li>
<li><strong>Testable</strong>: Each component can be tested independently, and the composition can be tested as a whole.</li>
</ul>
<hr />
<h2 id="-taking-it-further"><a class="header" href="#-taking-it-further">üß† Taking It Further</a></h2>
<p>This example is just the beginning. Here are some ideas for extending this solution into a real-world application:</p>
<h3 id="1-safe-decoding-with-validated"><a class="header" href="#1-safe-decoding-with-validated">1. <strong>Safe Decoding with <code>Validated</code></strong></a></h3>
<p>The <code>Base64.getDecoder().decode()</code> can throw an <code>IllegalArgumentException</code>. Instead of an <code>Iso</code>, create an <code>AffineTraversal</code> (an optional <code>Prism</code>) that returns a <code>Validated&lt;String, byte[]&gt;</code>, separating successes from failures gracefully.</p>
<pre><code class="language-java">public static final Prism&lt;String, byte[]&gt; SAFE_BASE64_PRISM = Prism.of(
    encoded -&gt; {
        try {
            return Optional.of(Base64.getDecoder().decode(encoded));
        } catch (IllegalArgumentException e) {
            return Optional.empty();
        }
    },
    bytes -&gt; Base64.getEncoder().encodeToString(bytes)
);

// Use in a traversal that accumulates both successes and failures
public static AuditResult auditWithErrorReporting(AppConfig config) {
    var validatedApplicative = ValidatedMonad.instance(Semigroups.list());
  
    Traversal&lt;AppConfig, String&gt; base64Strings = /* ... path to base64 strings ... */;
  
    Validated&lt;List&lt;String&gt;, List&lt;byte[]&gt;&gt; result = VALIDATED.narrow(
        base64Strings.modifyF(
            encoded -&gt; SAFE_BASE64_PRISM.getOptional(encoded)
                .map(bytes -&gt; VALIDATED.widen(Validated.valid(bytes)))
                .orElse(VALIDATED.widen(Validated.invalid(List.of("Invalid base64: " + encoded)))),
            config,
            validatedApplicative
        )
    );
  
    return new AuditResult(result);
}
</code></pre>
<h3 id="2-data-migration-with-modify"><a class="header" href="#2-data-migration-with-modify">2. <strong>Data Migration with <code>modify</code></strong></a></h3>
<p>What if you need to re-encrypt all passwords with a new algorithm? The same <code>finalAuditor</code> optic can be used with a modify function from the <code>Traversals</code> utility class. You'd write a function <code>byte[] -&gt; byte[]</code> and apply it:</p>
<pre><code class="language-java">// A function that re-encrypts the raw password bytes
Function&lt;byte[], byte[]&gt; reEncryptFunction = oldBytes -&gt; newCipher.encrypt(oldBytes);

// Use the *exact same optic* to update the config in-place
AppConfig updatedConfig = Traversals.modify(finalAuditor, reEncryptFunction, originalConfig);
</code></pre>
<h3 id="3-profunctor-adaptations-for-legacy-systems"><a class="header" href="#3-profunctor-adaptations-for-legacy-systems">3. <strong>Profunctor Adaptations for Legacy Systems</strong></a></h3>
<p>Suppose your audit service expects a different data format‚Äîperhaps it works with <code>ConfigDto</code> objects instead of <code>AppConfig</code>. Rather than rewriting your carefully crafted optic, you can adapt it using profunctor operations:</p>
<pre><code class="language-java">// Adapt the auditor to work with legacy DTO format
Traversal&lt;ConfigDto, byte[]&gt; legacyAuditor = finalAuditor.contramap(dto -&gt; convertToAppConfig(dto));

// Or adapt both input and output formats simultaneously
Traversal&lt;ConfigDto, AuditRecord&gt; fullyAdaptedAuditor = finalAuditor.dimap(
    dto -&gt; convertToAppConfig(dto),           // Convert input format
    bytes -&gt; new AuditRecord(bytes, timestamp()) // Convert output format
);
</code></pre>
<p>This profunctor capability means your core business logic (the auditing path) remains unchanged whilst adapting to different system interfaces‚Äîa powerful example of the <a href="optics/profunctor_optics.html">Profunctor Optics</a> capabilities.</p>
<h3 id="4-more-complex-filters"><a class="header" href="#4-more-complex-filters">4. <strong>More Complex Filters</strong></a></h3>
<p>Create an optic that filters for deployments on <em>either</em><code>gcp</code> or <code>aws</code> but <em>only</em> in the <code>live</code> environment. The composable nature of optics makes building up these complex predicate queries straightforward.</p>
<pre><code class="language-java">// Multi-cloud live environment filter
Prism&lt;AppConfig, AppConfig&gt; cloudLiveOnlyPrism = Prism.of(
    config -&gt; {
        String rawTarget = DeploymentTarget.toRawString().get(config.target());
        boolean isLiveCloud = rawTarget.equals("gcp|live") || 
                             rawTarget.equals("aws|live") || 
                             rawTarget.equals("azure|live");
        return isLiveCloud ? Optional.of(config) : Optional.empty();
    },
    config -&gt; config
);

// Environment-specific processing
public static final Map&lt;String, Traversal&lt;AppConfig, byte[]&gt;&gt; ENVIRONMENT_AUDITORS = Map.of(
    "development", devEnvironmentPrism.asTraversal().andThen(auditTraversal),
    "staging", stagingEnvironmentPrism.asTraversal().andThen(auditTraversal),
    "production", cloudLiveOnlyPrism.asTraversal().andThen(auditTraversal)
);

public static List&lt;byte[]&gt; auditForEnvironment(String environment, AppConfig config) {
    return ENVIRONMENT_AUDITORS.getOrDefault(environment, Traversal.empty())
        .getAll(config);
}
</code></pre>
<h3 id="5-configuration-validation"><a class="header" href="#5-configuration-validation">5. <strong>Configuration Validation</strong></a></h3>
<p>Use the same optics to validate your configuration. You could compose a traversal that finds all <code>IntValue</code> settings with the key <code>"server.port"</code> and use <code>.getAll()</code> to check if their values are within a valid range (e.g., &gt; 1024).</p>
<pre><code class="language-java">public static final Traversal&lt;AppConfig, Integer&gt; SERVER_PORTS = 
    AppConfigTraversals.settings()
        .andThen(settingWithKey("server.port"))
        .andThen(SettingLenses.value().asTraversal())
        .andThen(SettingValuePrisms.intValue().asTraversal())
        .andThen(IntValueLenses.value().asTraversal());

public static List&lt;String&gt; validatePorts(AppConfig config) {
    return Traversals.getAll(SERVER_PORTS, config).stream()
        .filter(port -&gt; port &lt;= 1024 || port &gt; 65535)
        .map(port -&gt; "Invalid port: " + port + " (must be 1024-65535)")
        .collect(toList());
}
</code></pre>
<h3 id="6-audit-trail-generation"><a class="header" href="#6-audit-trail-generation">6. <strong>Audit Trail Generation</strong></a></h3>
<p>Extend the auditor to generate comprehensive audit trails:</p>
<pre><code class="language-java">public record AuditEntry(String configName, String settingKey, String encryptedValue, 
                        Instant auditTime, String auditorId) {}

public static final Traversal&lt;AppConfig, AuditEntry&gt; AUDIT_TRAIL_GENERATOR =
    gcpLiveOnlyPrism.asTraversal()
        .andThen(AppConfigTraversals.settings())
        .andThen(settingFilter)
        .andThen(auditEntryMapper);

// Generate complete audit report
public static AuditReport generateAuditReport(List&lt;AppConfig&gt; configs, String auditorId) {
    List&lt;AuditEntry&gt; entries = configs.stream()
        .flatMap(config -&gt; Traversals.getAll(AUDIT_TRAIL_GENERATOR, config).stream())
        .collect(toList());
  
    return new AuditReport(entries, Instant.now(), auditorId);
}
</code></pre>
<p>This combination of composability, type safety, and profunctor adaptability makes higher-kinded-j optics incredibly powerful for real-world data processing scenarios, particularly in enterprise environments where data formats, security requirements, and compliance needs are constantly evolving.</p>
<hr />
<p><strong>Previous:</strong> <a href="optics/optics_examples.html">Optics Examples</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="working-with-core-types-and-optics"><a class="header" href="#working-with-core-types-and-optics">Working with Core Types and Optics</a></h1>
<p><img src="optics/../images/optics.jpg" alt="Diagram illustrating optics integration with functional core types like Maybe, Either, and Validated" /></p>
<p>As you've learnt from the previous chapters, optics provide a powerful way to focus on and modify immutable data structures. But what happens when the data you're working with is wrapped in Higher-Kinded-J's core types‚Äî<code>Maybe</code>, <code>Either</code>, <code>Validated</code>, or <code>Try</code>?</p>
<p>Traditional optics work brilliantly with straightforward, deterministic data. However, real-world applications rarely deal with such certainty. Fields might be <code>null</code>, operations might fail, validation might produce errors, and database calls might throw exceptions. Handling these scenarios whilst maintaining clean, composable optics code requires a bridge between these two powerful abstractions.</p>
<p>This is where <strong>Core Type Integration</strong> comes in.</p>
<h2 id="the-challenge-6"><a class="header" href="#the-challenge-6">The Challenge</a></h2>
<p>Consider a typical scenario: updating a user profile where some fields are optional, validation might fail, and the database operation might throw an exception.</p>
<div id="admonition--the-traditional-approach" class="admonition admonish-failure" role="note" aria-labelledby="admonition--the-traditional-approach-title">
<div class="admonition-title">
<div id="admonition--the-traditional-approach-title">
<p>‚ùå The Traditional Approach</p>
</div>
<a class="admonition-anchor-link" href="optics/core_type_integration.html#admonition--the-traditional-approach"></a>
</div>
<div>
<pre><code class="language-java">public User updateUserProfile(User user, String newEmail) {
    // Null checking
    if (user == null || user.getProfile() == null) {
        return null; // Or throw exception?
    }

    // Validation
    if (newEmail == null || !newEmail.contains("@")) {
        throw new ValidationException("Invalid email");
    }

    // Try to update
    try {
        String validated = validateEmailFormat(newEmail);
        Profile updated = user.getProfile().withEmail(validated);
        return user.withProfile(updated);
    } catch (Exception e) {
        // Now what? Log and return null? Re-throw?
        log.error("Failed to update email", e);
        return null;
    }
}
</code></pre>
<p>This code is a mess of concerns: null handling, validation logic, exception management, and the actual update logic are all tangled together.</p>
</div>
</div>
<div id="admonition--the-functional-approach" class="admonition admonish-success" role="note" aria-labelledby="admonition--the-functional-approach-title">
<div class="admonition-title">
<div id="admonition--the-functional-approach-title">
<p>‚úÖ The Functional Approach</p>
</div>
<a class="admonition-anchor-link" href="optics/core_type_integration.html#admonition--the-functional-approach"></a>
</div>
<div>
<pre><code class="language-java">public Either&lt;String, User&gt; updateUserProfile(User user, String newEmail) {
    Lens&lt;User, Profile&gt; profileLens = UserLenses.profile();
    Lens&lt;Profile, String&gt; emailLens = ProfileLenses.email();
    Lens&lt;User, String&gt; userToEmail = profileLens.andThen(emailLens);

    return modifyEither(
        userToEmail,
        email -&gt; validateEmail(email),
        user
    );
}

private Either&lt;String, String&gt; validateEmail(String email) {
    if (email == null || !email.contains("@")) {
        return Either.left("Invalid email format");
    }
    return Either.right(email.toLowerCase());
}
</code></pre>
<p>Clean separation of concerns:</p>
<ul>
<li>Optics define the path to the data</li>
<li>Core types handle the errors</li>
<li>Business logic stays pure and testable</li>
</ul>
</div>
</div>
<h2 id="three-complementary-approaches"><a class="header" href="#three-complementary-approaches">Three Complementary Approaches</a></h2>
<p>Higher-Kinded-J provides three integrated solutions for working with core types and optics:</p>
<div id="admonition--using-with-the-fluent-api" class="admonition admonish-note" role="note" aria-labelledby="admonition--using-with-the-fluent-api-title">
<div class="admonition-title">
<div id="admonition--using-with-the-fluent-api-title">
<p>üí° Using with the Fluent API</p>
</div>
<a class="admonition-anchor-link" href="optics/core_type_integration.html#admonition--using-with-the-fluent-api"></a>
</div>
<div>
<p>All the extension methods shown here can also be accessed through Higher-Kinded-J's <a href="optics/fluent_api.html">Fluent API</a>, which provides a more Java-friendly syntax for optic operations. The examples below use static imports for conciseness, but you can also use <code>OpticOps</code> methods for a more discoverable API.</p>
</div>
</div>
<h3 id="1-core-type-prisms---pattern-matching-on-functional-types"><a class="header" href="#1-core-type-prisms---pattern-matching-on-functional-types">1. <strong>Core Type Prisms</strong> üî¨ ‚Äî Pattern Matching on Functional Types</a></h3>
<p>Extract values from <code>Maybe</code>, <code>Either</code>, <code>Validated</code>, and <code>Try</code> using prisms, just as you would with sealed interfaces.</p>
<pre><code class="language-java">Prism&lt;Maybe&lt;User&gt;, User&gt; justPrism = Prisms.just();
Prism&lt;Try&lt;Order&gt;, Order&gt; successPrism = Prisms.success();

// Extract user if present
Optional&lt;User&gt; user = justPrism.getOptional(maybeUser);

// Extract order if successful
Optional&lt;Order&gt; order = successPrism.getOptional(tryOrder);
</code></pre>
<p><strong>Best for:</strong> Safe extraction and pattern matching on core types, composing with other optics.</p>
<p><a href="optics/core_type_prisms.html">Learn more ‚Üí</a></p>
<h3 id="2-lens-extensions---safety-rails-for-lens-operations"><a class="header" href="#2-lens-extensions---safety-rails-for-lens-operations">2. <strong>Lens Extensions</strong> üõ°Ô∏è ‚Äî Safety Rails for Lens Operations</a></h3>
<p>Augment lenses with built-in null safety, validation, and exception handling.</p>
<pre><code class="language-java">Lens&lt;User, String&gt; emailLens = UserLenses.email();

// Null-safe access
Maybe&lt;String&gt; email = getMaybe(emailLens, user);

// Validated modification
Either&lt;String, User&gt; updated = modifyEither(
    emailLens,
    email -&gt; validateEmail(email),
    user
);

// Exception-safe database operation
Try&lt;User&gt; saved = modifyTry(
    emailLens,
    email -&gt; Try.of(() -&gt; updateInDatabase(email)),
    user
);
</code></pre>
<p><strong>Best for:</strong> Individual field operations with validation, null-safe access, exception handling.</p>
<p><a href="optics/lens_extensions.html">Learn more ‚Üí</a></p>
<h3 id="3-traversal-extensions---bulk-operations-with-error-handling"><a class="header" href="#3-traversal-extensions---bulk-operations-with-error-handling">3. <strong>Traversal Extensions</strong> üó∫Ô∏è ‚Äî Bulk Operations with Error Handling</a></h3>
<p>Process collections using traversals whilst accumulating errors or failing fast.</p>
<pre><code class="language-java">Traversal&lt;List&lt;Order&gt;, BigDecimal&gt; allPrices =
    Traversals.forList().andThen(OrderLenses.price().asTraversal());

// Validate all prices (accumulate errors)
Validated&lt;List&lt;String&gt;, List&lt;Order&gt;&gt; result = modifyAllValidated(
    allPrices,
    price -&gt; validatePrice(price),
    orders
);

// Or fail fast at first error
Either&lt;String, List&lt;Order&gt;&gt; fastResult = modifyAllEither(
    allPrices,
    price -&gt; validatePrice(price),
    orders
);
</code></pre>
<p><strong>Best for:</strong> Bulk validation, batch processing, error accumulation vs fail-fast strategies.</p>
<p><a href="optics/traversal_extensions.html">Learn more ‚Üí</a></p>
<h2 id="when-to-use-each-approach-1"><a class="header" href="#when-to-use-each-approach-1">When to Use Each Approach</a></h2>
<h3 id="use-core-type-prisms-when"><a class="header" href="#use-core-type-prisms-when">Use <strong>Core Type Prisms</strong> when:</a></h3>
<ul>
<li>‚úÖ Extracting values from <code>Maybe</code>, <code>Either</code>, <code>Validated</code>, or <code>Try</code></li>
<li>‚úÖ Pattern matching on functional types without <code>instanceof</code></li>
<li>‚úÖ Composing core types with other optics for deep navigation</li>
<li>‚úÖ Safely handling optional API responses or database results</li>
</ul>
<h3 id="use-lens-extensions-when"><a class="header" href="#use-lens-extensions-when">Use <strong>Lens Extensions</strong> when:</a></h3>
<ul>
<li>‚úÖ Accessing potentially null fields</li>
<li>‚úÖ Validating single field updates</li>
<li>‚úÖ Performing operations that might throw exceptions</li>
<li>‚úÖ Implementing form validation with immediate feedback</li>
</ul>
<h3 id="use-traversal-extensions-when"><a class="header" href="#use-traversal-extensions-when">Use <strong>Traversal Extensions</strong> when:</a></h3>
<ul>
<li>‚úÖ Validating collections of data</li>
<li>‚úÖ Batch processing with error accumulation</li>
<li>‚úÖ Applying bulk updates with validation</li>
<li>‚úÖ Counting valid items or collecting errors</li>
</ul>
<h2 id="the-power-of-composition"><a class="header" href="#the-power-of-composition">The Power of Composition</a></h2>
<p>The real magic happens when you combine these approaches:</p>
<pre><code class="language-java">// Complete order processing pipeline
Order order = ...;

// 1. Extract customer using prism (Maybe)
Prism&lt;Maybe&lt;Customer&gt;, Customer&gt; justPrism = Prisms.just();
Maybe&lt;Customer&gt; maybeCustomer = order.getCustomer();

// 2. Validate customer email using lens extension
Lens&lt;Customer, String&gt; emailLens = CustomerLenses.email();
Either&lt;String, Customer&gt; validatedCustomer =
    maybeCustomer.map(customer -&gt;
        modifyEither(emailLens, email -&gt; validateEmail(email), customer)
    ).orElse(Either.left("No customer"));

// 3. Validate all order items using traversal extension
Traversal&lt;List&lt;OrderItem&gt;, BigDecimal&gt; allPrices =
    Traversals.forList().andThen(OrderItemLenses.price().asTraversal());

Validated&lt;List&lt;String&gt;, List&lt;OrderItem&gt;&gt; validatedItems =
    modifyAllValidated(
        allPrices,
        price -&gt; validatePrice(price),
        order.getItems()
    );

// Combine results...
</code></pre>
<h2 id="real-world-examples-1"><a class="header" href="#real-world-examples-1">Real-World Examples</a></h2>
<p>All three approaches are demonstrated with comprehensive, runnable examples:</p>
<div id="admonition-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-code-title">
<div class="admonition-title">
<div id="admonition-example-code-title">
<p>Example Code</p>
</div>
<a class="admonition-anchor-link" href="optics/core_type_integration.html#admonition-example-code"></a>
</div>
<div>
<ul>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/CoreTypePrismsExample.java">CoreTypePrismsExample</a> ‚Äî API response processing</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/LensExtensionsExample.java">LensExtensionsExample</a> ‚Äî User profile validation</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/TraversalExtensionsExample.java">TraversalExtensionsExample</a> ‚Äî Bulk order processing</li>
<li><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/IntegrationPatternsExample.java">IntegrationPatternsExample</a> ‚Äî Complete e-commerce workflow</li>
</ul>
</div>
</div>
<h2 id="key-benefits-2"><a class="header" href="#key-benefits-2">Key Benefits</a></h2>
<h3 id="-separation-of-concerns"><a class="header" href="#-separation-of-concerns">üéØ <strong>Separation of Concerns</strong></a></h3>
<p>Business logic, validation, and error handling remain cleanly separated. Optics define the structure, core types handle the effects.</p>
<h3 id="-composability"><a class="header" href="#-composability">üîÑ <strong>Composability</strong></a></h3>
<p>All three approaches compose seamlessly with each other and with standard optics operations.</p>
<h3 id="-error-accumulation"><a class="header" href="#-error-accumulation">üìä <strong>Error Accumulation</strong></a></h3>
<p>Choose between fail-fast (stop at first error) or error accumulation (collect all errors) based on your requirements.</p>
<h3 id="-type-safety"><a class="header" href="#-type-safety">üõ°Ô∏è <strong>Type Safety</strong></a></h3>
<p>The compiler ensures you handle all cases. No silent failures, no unexpected nulls.</p>
<h3 id="-readability"><a class="header" href="#-readability">üìñ <strong>Readability</strong></a></h3>
<p>Code reads like the business logic it implements, without defensive programming clutter.</p>
<h2 id="understanding-the-core-types"><a class="header" href="#understanding-the-core-types">Understanding the Core Types</a></h2>
<p>Before diving into the integration patterns, ensure you're familiar with Higher-Kinded-J's core types:</p>
<ul>
<li><a href="optics/../monads/maybe_monad.html"><strong>Maybe</strong></a> ‚Äî Represents optional values (similar to <code>Optional</code>)</li>
<li><a href="optics/../monads/either_monad.html"><strong>Either</strong></a> ‚Äî Represents a value that can be one of two types (success or error)</li>
<li><a href="optics/../monads/validated_monad.html"><strong>Validated</strong></a> ‚Äî Like <code>Either</code>, but accumulates errors</li>
<li><a href="optics/../monads/try_monad.html"><strong>Try</strong></a> ‚Äî Represents a computation that may throw an exception</li>
</ul>
<h2 id="common-pitfalls-18"><a class="header" href="#common-pitfalls-18">Common Pitfalls</a></h2>
<div id="admonition--dont-mix-effect-types-carelessly" class="admonition admonish-warning" role="note" aria-labelledby="admonition--dont-mix-effect-types-carelessly-title">
<div class="admonition-title">
<div id="admonition--dont-mix-effect-types-carelessly-title">
<p>‚ö†Ô∏è Don't Mix Effect Types Carelessly</p>
</div>
<a class="admonition-anchor-link" href="optics/core_type_integration.html#admonition--dont-mix-effect-types-carelessly"></a>
</div>
<div>
<p>Whilst all three core type families work with optics, mixing them inappropriately can lead to confusing code:</p>
<pre><code class="language-java">// ‚ùå Confusing: Mixing Maybe and Either unnecessarily
Maybe&lt;Either&lt;String, User&gt;&gt; confusing = ...;

// ‚úÖ Better: Choose one based on your needs
Either&lt;String, User&gt; clear = ...; // If you have an error message
Maybe&lt;User&gt; simple = ...;          // If it's just presence/absence
</code></pre>
</div>
</div>
<div id="admonition--start-with-either" class="admonition admonish-tip" role="note" aria-labelledby="admonition--start-with-either-title">
<div class="admonition-title">
<div id="admonition--start-with-either-title">
<p>üí° Start with Either</p>
</div>
<a class="admonition-anchor-link" href="optics/core_type_integration.html#admonition--start-with-either"></a>
</div>
<div>
<p>When in doubt, start with <code>Either</code>. It's the most versatile:</p>
<ul>
<li>Carries error information (unlike <code>Maybe</code>)</li>
<li>Fails fast (unlike <code>Validated</code>)</li>
<li>Doesn't catch exceptions automatically (unlike <code>Try</code>)</li>
</ul>
<p>You can always switch to <code>Validated</code> for error accumulation or <code>Try</code> for exception handling when needed.</p>
</div>
</div>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>Now that you understand the three complementary approaches, dive into each one:</p>
<ol>
<li><strong><a href="optics/core_type_prisms.html">Core Type Prisms</a></strong> ‚Äî Start here to learn safe extraction</li>
<li><strong><a href="optics/lens_extensions.html">Lens Extensions</a></strong> ‚Äî Master validated field operations</li>
<li><strong><a href="optics/traversal_extensions.html">Traversal Extensions</a></strong> ‚Äî Handle bulk operations</li>
</ol>
<p>Each guide includes detailed examples, best practices, and common patterns you'll use every day.</p>
<hr />
<p><strong>Next:</strong> <a href="optics/core_type_prisms.html">Core Type Prisms: Safe Extraction</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="core-type-prisms-safe-extraction-and-pattern-matching"><a class="header" href="#core-type-prisms-safe-extraction-and-pattern-matching">Core Type Prisms: Safe Extraction and Pattern Matching</a></h1>
<p><img src="optics/../images/optics.jpg" alt="prisms.jpg" /></p>
<p>Prisms are optics that focus on <strong>one case</strong> of a sum type. They're perfect for safely extracting values from <code>Maybe</code>, <code>Either</code>, <code>Validated</code>, and <code>Try</code> without verbose pattern matching or null checks.</p>
<p>Think of a prism like a quality inspector at a factory sorting line. It can:</p>
<ul>
<li><strong>Identify</strong> whether an item matches a specific case (<code>matches()</code>)</li>
<li><strong>Extract</strong> the value if it matches (<code>getOptional()</code>)</li>
<li><strong>Construct</strong> a new value of that case (<code>build()</code>)</li>
</ul>
<p>This chapter shows you how to use prisms to work elegantly with Higher-Kinded-J's core types.</p>
<h2 id="the-problem-verbose-pattern-matching"><a class="header" href="#the-problem-verbose-pattern-matching">The Problem: Verbose Pattern Matching</a></h2>
<p>Before we dive into prisms, let's see the traditional approach:</p>
<div id="admonition--traditional-pattern-matching" class="admonition admonish-failure" role="note" aria-labelledby="admonition--traditional-pattern-matching-title">
<div class="admonition-title">
<div id="admonition--traditional-pattern-matching-title">
<p>‚ùå Traditional Pattern Matching</p>
</div>
<a class="admonition-anchor-link" href="optics/core_type_prisms.html#admonition--traditional-pattern-matching"></a>
</div>
<div>
<pre><code class="language-java">// Extracting from Maybe
Maybe&lt;User&gt; maybeUser = getUserById("u123");
if (maybeUser.isJust()) {
    User user = maybeUser.get();
    processUser(user);
} else {
    handleMissingUser();
}

// Extracting from Either
Either&lt;String, Order&gt; result = createOrder(request);
if (result.isRight()) {
    Order order = result.fold(err -&gt; null, ord -&gt; ord);
    saveOrder(order);
} else {
    String error = result.fold(err -&gt; err, ord -&gt; null);
    logError(error);
}

// Extracting from Try
Try&lt;Connection&gt; tryConnection = connectToDatabase();
if (tryConnection.isSuccess()) {
    Connection conn = tryConnection.fold(c -&gt; c, ex -&gt; null);
    useConnection(conn);
} else {
    Throwable error = tryConnection.fold(c -&gt; null, ex -&gt; ex);
    handleError(error);
}
</code></pre>
<p>This code is repetitive, error-prone, and hard to compose with other operations.</p>
</div>
</div>
<div id="admonition--with-prisms" class="admonition admonish-success" role="note" aria-labelledby="admonition--with-prisms-title">
<div class="admonition-title">
<div id="admonition--with-prisms-title">
<p>‚úÖ With Prisms</p>
</div>
<a class="admonition-anchor-link" href="optics/core_type_prisms.html#admonition--with-prisms"></a>
</div>
<div>
<pre><code class="language-java">// Extracting from Maybe
Prism&lt;Maybe&lt;User&gt;, User&gt; justPrism = Prisms.just();
getUserById("u123")
    .flatMap(justPrism::getOptional)
    .ifPresent(this::processUser);

// Extracting from Either
Prism&lt;Either&lt;String, Order&gt;, Order&gt; rightPrism = Prisms.right();
Prism&lt;Either&lt;String, Order&gt;, String&gt; leftPrism = Prisms.left();

Either&lt;String, Order&gt; result = createOrder(request);
rightPrism.getOptional(result).ifPresent(this::saveOrder);
leftPrism.getOptional(result).ifPresent(this::logError);

// Extracting from Try
Prism&lt;Try&lt;Connection&gt;, Connection&gt; successPrism = Prisms.success();
Prism&lt;Try&lt;Connection&gt;, Throwable&gt; failurePrism = Prisms.failure();

Try&lt;Connection&gt; tryConnection = connectToDatabase();
successPrism.getOptional(tryConnection).ifPresent(this::useConnection);
failurePrism.getOptional(tryConnection).ifPresent(this::handleError);
</code></pre>
<p>Clean, composable, and type-safe. The prisms handle the pattern matching internally.</p>
</div>
</div>
<h2 id="available-prisms"><a class="header" href="#available-prisms">Available Prisms</a></h2>
<p>Higher-Kinded-J provides prisms for all core types in the <code>Prisms</code> utility class:</p>
<div id="admonition--alternative-fluent-api" class="admonition admonish-note" role="note" aria-labelledby="admonition--alternative-fluent-api-title">
<div class="admonition-title">
<div id="admonition--alternative-fluent-api-title">
<p>üí° Alternative: Fluent API</p>
</div>
<a class="admonition-anchor-link" href="optics/core_type_prisms.html#admonition--alternative-fluent-api"></a>
</div>
<div>
<p>Prisms can also be used through the <a href="optics/fluent_api.html">Fluent API</a> for method chaining and better discoverability. For example, prism operations like <code>getOptional</code> and <code>modify</code> can be accessed through <code>OpticOps</code> methods for a more fluent interface.</p>
</div>
</div>
<h3 id="maybe-prisms"><a class="header" href="#maybe-prisms">Maybe Prisms</a></h3>
<pre><code class="language-java">// Extract value from Just, returns empty Optional for Nothing
Prism&lt;Maybe&lt;A&gt;, A&gt; justPrism = Prisms.just();

Maybe&lt;String&gt; present = Maybe.just("Hello");
Maybe&lt;String&gt; absent = Maybe.nothing();

Optional&lt;String&gt; value = justPrism.getOptional(present);  // Optional["Hello"]
Optional&lt;String&gt; empty = justPrism.getOptional(absent);   // Optional.empty()

// Construct Maybe.just() from a value
Maybe&lt;String&gt; built = justPrism.build("World");  // Maybe.just("World")

// Check if it's a Just
boolean isJust = justPrism.matches(present);  // true
boolean isNothing = justPrism.matches(absent); // false
</code></pre>
<div id="admonition--when-to-use-maybe-prisms" class="admonition admonish-tip" role="note" aria-labelledby="admonition--when-to-use-maybe-prisms-title">
<div class="admonition-title">
<div id="admonition--when-to-use-maybe-prisms-title">
<p>üí° When to Use Maybe Prisms</p>
</div>
<a class="admonition-anchor-link" href="optics/core_type_prisms.html#admonition--when-to-use-maybe-prisms"></a>
</div>
<div>
<p>Use <code>Prisms.just()</code> when:</p>
<ul>
<li>Extracting optional API response data</li>
<li>Composing with other optics to navigate nested structures</li>
<li>Converting <code>Maybe</code> to <code>Optional</code> for interop with Java APIs</li>
<li>Filtering collections of <code>Maybe</code> values</li>
</ul>
</div>
</div>
<h3 id="either-prisms"><a class="header" href="#either-prisms">Either Prisms</a></h3>
<pre><code class="language-java">// Extract from Left and Right cases
Prism&lt;Either&lt;L, R&gt;, L&gt; leftPrism = Prisms.left();
Prism&lt;Either&lt;L, R&gt;, R&gt; rightPrism = Prisms.right();

Either&lt;String, Integer&gt; success = Either.right(42);
Either&lt;String, Integer&gt; failure = Either.left("Error");

// Extract success value
Optional&lt;Integer&gt; value = rightPrism.getOptional(success);   // Optional[42]
Optional&lt;Integer&gt; noValue = rightPrism.getOptional(failure); // Optional.empty()

// Extract error value
Optional&lt;String&gt; noError = leftPrism.getOptional(success);   // Optional.empty()
Optional&lt;String&gt; error = leftPrism.getOptional(failure);     // Optional["Error"]

// Construct Either values
Either&lt;String, Integer&gt; newSuccess = rightPrism.build(100);  // Either.right(100)
Either&lt;String, Integer&gt; newFailure = leftPrism.build("Oops"); // Either.left("Oops")

// Check which case
boolean isRight = rightPrism.matches(success);  // true
boolean isLeft = leftPrism.matches(failure);    // true
</code></pre>
<div id="admonition-real-world-example-processing-validation-results" class="admonition admonish-example" role="note" aria-labelledby="admonition-real-world-example-processing-validation-results-title">
<div class="admonition-title">
<div id="admonition-real-world-example-processing-validation-results-title">
<p>Real-World Example: Processing Validation Results</p>
</div>
<a class="admonition-anchor-link" href="optics/core_type_prisms.html#admonition-real-world-example-processing-validation-results"></a>
</div>
<div>
<pre><code class="language-java">List&lt;Either&lt;String, User&gt;&gt; validationResults = validateUsers(requests);

Prism&lt;Either&lt;String, User&gt;, User&gt; validPrism = Prisms.right();
Prism&lt;Either&lt;String, User&gt;, String&gt; errorPrism = Prisms.left();

// Collect all successful users
List&lt;User&gt; validUsers = validationResults.stream()
    .flatMap(result -&gt; validPrism.getOptional(result).stream())
    .toList();

// Collect all error messages
List&lt;String&gt; errors = validationResults.stream()
    .flatMap(result -&gt; errorPrism.getOptional(result).stream())
    .toList();

System.out.println("Successfully validated: " + validUsers.size() + " users");
System.out.println("Validation errors: " + errors);
</code></pre>
</div>
</div>
<h3 id="validated-prisms"><a class="header" href="#validated-prisms">Validated Prisms</a></h3>
<pre><code class="language-java">// Extract from Valid and Invalid cases
Prism&lt;Validated&lt;E, A&gt;, A&gt; validPrism = Prisms.valid();
Prism&lt;Validated&lt;E, A&gt;, E&gt; invalidPrism = Prisms.invalid();

Validated&lt;String, Integer&gt; valid = Validated.valid(30);
Validated&lt;String, Integer&gt; invalid = Validated.invalid("Age must be positive");

// Extract valid value
Optional&lt;Integer&gt; age = validPrism.getOptional(valid);       // Optional[30]
Optional&lt;Integer&gt; noAge = validPrism.getOptional(invalid);   // Optional.empty()

// Extract validation error
Optional&lt;String&gt; noError = invalidPrism.getOptional(valid);  // Optional.empty()
Optional&lt;String&gt; error = invalidPrism.getOptional(invalid);  // Optional["Age must be positive"]

// Construct Validated values
Validated&lt;String, Integer&gt; newValid = validPrism.build(25);           // Validated.valid(25)
Validated&lt;String, Integer&gt; newInvalid = invalidPrism.build("Error");  // Validated.invalid("Error")
</code></pre>
<div id="admonition--validated-vs-either-prisms" class="admonition admonish-tip" role="note" aria-labelledby="admonition--validated-vs-either-prisms-title">
<div class="admonition-title">
<div id="admonition--validated-vs-either-prisms-title">
<p>üí° Validated vs Either Prisms</p>
</div>
<a class="admonition-anchor-link" href="optics/core_type_prisms.html#admonition--validated-vs-either-prisms"></a>
</div>
<div>
<p><code>Validated</code> and <code>Either</code> have similar prisms, but serve different purposes:</p>
<ul>
<li><strong>Either prisms</strong>: Use for fail-fast validation (stop at first error)</li>
<li><strong>Validated prisms</strong>: Use with error accumulation (collect all errors)</li>
</ul>
<p>The prisms themselves work identically‚Äîthe difference is in how you combine multiple validations.</p>
</div>
</div>
<h3 id="try-prisms"><a class="header" href="#try-prisms">Try Prisms</a></h3>
<pre><code class="language-java">// Extract from Success and Failure cases
Prism&lt;Try&lt;A&gt;, A&gt; successPrism = Prisms.success();
Prism&lt;Try&lt;A&gt;, Throwable&gt; failurePrism = Prisms.failure();

Try&lt;Integer&gt; success = Try.success(42);
Try&lt;Integer&gt; failure = Try.failure(new RuntimeException("Database error"));

// Extract success value
Optional&lt;Integer&gt; value = successPrism.getOptional(success);    // Optional[42]
Optional&lt;Integer&gt; noValue = successPrism.getOptional(failure);  // Optional.empty()

// Extract exception
Optional&lt;Throwable&gt; noEx = failurePrism.getOptional(success);   // Optional.empty()
Optional&lt;Throwable&gt; ex = failurePrism.getOptional(failure);     // Optional[RuntimeException]

// Construct Try values
Try&lt;Integer&gt; newSuccess = successPrism.build(100);  // Try.success(100)
Try&lt;Integer&gt; newFailure = failurePrism.build(new IllegalStateException("Oops"));
</code></pre>
<div id="admonition-real-world-example-database-operation-results" class="admonition admonish-example" role="note" aria-labelledby="admonition-real-world-example-database-operation-results-title">
<div class="admonition-title">
<div id="admonition-real-world-example-database-operation-results-title">
<p>Real-World Example: Database Operation Results</p>
</div>
<a class="admonition-anchor-link" href="optics/core_type_prisms.html#admonition-real-world-example-database-operation-results"></a>
</div>
<div>
<pre><code class="language-java">List&lt;Try&lt;User&gt;&gt; dbResults = List.of(
    Try.of(() -&gt; fetchUser("u1")),
    Try.of(() -&gt; fetchUser("u2")),
    Try.of(() -&gt; fetchUser("u3"))
);

Prism&lt;Try&lt;User&gt;, User&gt; successPrism = Prisms.success();
Prism&lt;Try&lt;User&gt;, Throwable&gt; failurePrism = Prisms.failure();

// Count successful loads
long successCount = dbResults.stream()
    .filter(successPrism::matches)
    .count();

// Log all errors
dbResults.stream()
    .flatMap(result -&gt; failurePrism.getOptional(result).stream())
    .forEach(error -&gt; logger.error("Database error: {}", error.getMessage()));

System.out.println("Loaded " + successCount + "/" + dbResults.size() + " users");
</code></pre>
</div>
</div>
<h2 id="traversals-for-core-types"><a class="header" href="#traversals-for-core-types">Traversals for Core Types</a></h2>
<p>Whilst prisms <em>extract</em> values, traversals <em>modify</em> values inside core types. Higher-Kinded-J provides traversal utilities for all core types:</p>
<h3 id="maybe-traversals"><a class="header" href="#maybe-traversals">Maybe Traversals</a></h3>
<pre><code class="language-java">import org.higherkindedj.optics.util.MaybeTraversals;

Traversal&lt;Maybe&lt;String&gt;, String&gt; justTraversal = MaybeTraversals.just();

// Modify value inside Just
Maybe&lt;String&gt; original = Maybe.just("hello");
Maybe&lt;String&gt; modified = Traversals.modify(justTraversal, String::toUpperCase, original);
// Result: Maybe.just("HELLO")

// No effect on Nothing
Maybe&lt;String&gt; nothing = Maybe.nothing();
Maybe&lt;String&gt; unchanged = Traversals.modify(justTraversal, String::toUpperCase, nothing);
// Result: Maybe.nothing()
</code></pre>
<h3 id="either-traversals"><a class="header" href="#either-traversals">Either Traversals</a></h3>
<pre><code class="language-java">import org.higherkindedj.optics.util.EitherTraversals;

Traversal&lt;Either&lt;String, Integer&gt;, Integer&gt; rightTraversal = EitherTraversals.right();
Traversal&lt;Either&lt;String, Integer&gt;, String&gt; leftTraversal = EitherTraversals.left();

// Modify Right value
Either&lt;String, Integer&gt; success = Either.right(100);
Either&lt;String, Integer&gt; doubled = Traversals.modify(rightTraversal, n -&gt; n * 2, success);
// Result: Either.right(200)

// Enrich Left value (error enrichment)
Either&lt;String, Integer&gt; error = Either.left("Connection failed");
Either&lt;String, Integer&gt; enriched = Traversals.modify(
    leftTraversal,
    msg -&gt; "[ERROR] " + msg,
    error
);
// Result: Either.left("[ERROR] Connection failed")
</code></pre>
<div id="admonition--error-enrichment-with-left-traversal" class="admonition admonish-tip" role="note" aria-labelledby="admonition--error-enrichment-with-left-traversal-title">
<div class="admonition-title">
<div id="admonition--error-enrichment-with-left-traversal-title">
<p>üí° Error Enrichment with Left Traversal</p>
</div>
<a class="admonition-anchor-link" href="optics/core_type_prisms.html#admonition--error-enrichment-with-left-traversal"></a>
</div>
<div>
<p>The <code>EitherTraversals.left()</code> traversal is excellent for error enrichment‚Äîadding context or formatting to error messages without unwrapping the Either:</p>
<pre><code class="language-java">Either&lt;String, Order&gt; result = processOrder(request);

// Add request ID to all errors
Either&lt;String, Order&gt; enriched = Traversals.modify(
    EitherTraversals.left(),
    error -&gt; String.format("[Request %s] %s", requestId, error),
    result
);
</code></pre>
</div>
</div>
<h3 id="validated-traversals"><a class="header" href="#validated-traversals">Validated Traversals</a></h3>
<pre><code class="language-java">import org.higherkindedj.optics.util.ValidatedTraversals;

Traversal&lt;Validated&lt;String, Integer&gt;, Integer&gt; validTraversal = ValidatedTraversals.valid();
Traversal&lt;Validated&lt;String, Integer&gt;, String&gt; invalidTraversal = ValidatedTraversals.invalid();

// Modify valid value
Validated&lt;String, Integer&gt; valid = Validated.valid(30);
Validated&lt;String, Integer&gt; incremented = Traversals.modify(validTraversal, age -&gt; age + 1, valid);
// Result: Validated.valid(31)

// Modify error
Validated&lt;String, Integer&gt; invalid = Validated.invalid("Age required");
Validated&lt;String, Integer&gt; formatted = Traversals.modify(
    invalidTraversal,
    err -&gt; "Validation Error: " + err,
    invalid
);
// Result: Validated.invalid("Validation Error: Age required")
</code></pre>
<h3 id="try-traversals"><a class="header" href="#try-traversals">Try Traversals</a></h3>
<pre><code class="language-java">import org.higherkindedj.optics.util.TryTraversals;

Traversal&lt;Try&lt;Integer&gt;, Integer&gt; successTraversal = TryTraversals.success();
Traversal&lt;Try&lt;Integer&gt;, Throwable&gt; failureTraversal = TryTraversals.failure();

// Modify success value
Try&lt;Integer&gt; success = Try.success(42);
Try&lt;Integer&gt; doubled = Traversals.modify(successTraversal, n -&gt; n * 2, success);
// Result: Try.success(84)

// Wrap exceptions
Try&lt;Integer&gt; failure = Try.failure(new SQLException("Connection lost"));
Try&lt;Integer&gt; wrapped = Traversals.modify(
    failureTraversal,
    cause -&gt; new DatabaseException("Database error", cause),
    failure
);
// Result: Try.failure(DatabaseException wrapping SQLException)
</code></pre>
<h2 id="composition-the-real-power"><a class="header" href="#composition-the-real-power">Composition: The Real Power</a></h2>
<p>Prisms compose seamlessly with lenses and other optics to navigate deeply nested structures:</p>
<div id="admonition-example-extracting-nested-optional-data" class="admonition admonish-example" role="note" aria-labelledby="admonition-example-extracting-nested-optional-data-title">
<div class="admonition-title">
<div id="admonition-example-extracting-nested-optional-data-title">
<p>Example: Extracting Nested Optional Data</p>
</div>
<a class="admonition-anchor-link" href="optics/core_type_prisms.html#admonition-example-extracting-nested-optional-data"></a>
</div>
<div>
<pre><code class="language-java">@GenerateLenses
record ApiResponse(int statusCode, Maybe&lt;Order&gt; data, List&lt;String&gt; warnings) {}

@GenerateLenses
record Order(String orderId, Customer customer, List&lt;OrderItem&gt; items) {}

@GenerateLenses
record Customer(String customerId, String name, String email) {}

// Get customer email from API response (if present)
ApiResponse response = fetchOrder("ORD-123");

// Method 1: Using prism directly
Prism&lt;Maybe&lt;Order&gt;, Order&gt; justPrism = Prisms.just();
Optional&lt;String&gt; email = justPrism.getOptional(response.data())
    .map(order -&gt; order.customer().email());

// Method 2: Compose with lenses for a complete path
Lens&lt;ApiResponse, Maybe&lt;Order&gt;&gt; dataLens = ApiResponseLenses.data();
Traversal&lt;Maybe&lt;Order&gt;, Order&gt; orderTraversal = MaybeTraversals.just();
Lens&lt;Order, Customer&gt; customerLens = OrderLenses.customer();
Lens&lt;Customer, String&gt; emailLens = CustomerLenses.email();

// Full composition: ApiResponse -&gt; Maybe&lt;Order&gt; -&gt; Order -&gt; Customer -&gt; email
Traversal&lt;ApiResponse, String&gt; emailPath = dataLens
    .andThen(orderTraversal)
    .andThen(customerLens.asTraversal())
    .andThen(emailLens.asTraversal());

List&lt;String&gt; emails = Traversals.toListOf(emailPath, response);
// Result: ["customer@example.com"] or [] if no order data
</code></pre>
</div>
</div>
<h2 id="processing-collections-of-core-types"><a class="header" href="#processing-collections-of-core-types">Processing Collections of Core Types</a></h2>
<p>Prisms excel at filtering and extracting from collections of <code>Maybe</code>, <code>Either</code>, <code>Validated</code>, or <code>Try</code>:</p>
<h3 id="extracting-successes"><a class="header" href="#extracting-successes">Extracting Successes</a></h3>
<pre><code class="language-java">List&lt;Try&lt;User&gt;&gt; dbResults = loadUsersFromDatabase(userIds);

Prism&lt;Try&lt;User&gt;, User&gt; successPrism = Prisms.success();

// Get all successfully loaded users
List&lt;User&gt; users = dbResults.stream()
    .flatMap(result -&gt; successPrism.getOptional(result).stream())
    .toList();
</code></pre>
<h3 id="extracting-failures"><a class="header" href="#extracting-failures">Extracting Failures</a></h3>
<pre><code class="language-java">List&lt;Either&lt;ValidationError, Order&gt;&gt; validations = validateOrders(requests);

Prism&lt;Either&lt;ValidationError, Order&gt;, ValidationError&gt; errorPrism = Prisms.left();

// Collect all validation errors
List&lt;ValidationError&gt; errors = validations.stream()
    .flatMap(result -&gt; errorPrism.getOptional(result).stream())
    .toList();

if (!errors.isEmpty()) {
    displayErrorsToUser(errors);
}
</code></pre>
<h3 id="counting-cases"><a class="header" href="#counting-cases">Counting Cases</a></h3>
<pre><code class="language-java">List&lt;Validated&lt;List&lt;String&gt;, Product&gt;&gt; validations = validateProducts(products);

Prism&lt;Validated&lt;List&lt;String&gt;, Product&gt;, Product&gt; validPrism = Prisms.valid();

long validCount = validations.stream()
    .filter(validPrism::matches)
    .count();

System.out.println(validCount + "/" + validations.size() + " products valid");
</code></pre>
<h2 id="common-patterns-2"><a class="header" href="#common-patterns-2">Common Patterns</a></h2>
<h3 id="pattern-1-optional-chaining-with-maybe"><a class="header" href="#pattern-1-optional-chaining-with-maybe">Pattern 1: Optional Chaining with Maybe</a></h3>
<p>Instead of nested <code>if (isJust())</code> checks:</p>
<pre><code class="language-java">// ‚ùå Traditional
Maybe&lt;User&gt; maybeUser = findUser(id);
if (maybeUser.isJust()) {
    User user = maybeUser.get();
    Maybe&lt;Address&gt; maybeAddress = user.getAddress();
    if (maybeAddress.isJust()) {
        Address address = maybeAddress.get();
        processAddress(address);
    }
}

// ‚úÖ With prisms
Prism&lt;Maybe&lt;User&gt;, User&gt; justUserPrism = Prisms.just();
Prism&lt;Maybe&lt;Address&gt;, Address&gt; justAddressPrism = Prisms.just();

findUser(id)
    .flatMap(justUserPrism::getOptional)
    .flatMap(user -&gt; user.getAddress())
    .flatMap(justAddressPrism::getOptional)
    .ifPresent(this::processAddress);
</code></pre>
<h3 id="pattern-2-error-handling-with-either"><a class="header" href="#pattern-2-error-handling-with-either">Pattern 2: Error Handling with Either</a></h3>
<p>Extracting specific error types:</p>
<pre><code class="language-java">sealed interface AppError permits ValidationError, DatabaseError, NetworkError {}

Either&lt;AppError, User&gt; result = createUser(request);

Prism&lt;Either&lt;AppError, User&gt;, User&gt; successPrism = Prisms.right();
Prism&lt;Either&lt;AppError, User&gt;, AppError&gt; errorPrism = Prisms.left();

// Handle success
successPrism.getOptional(result).ifPresent(user -&gt; {
    logger.info("User created: {}", user.id());
    sendWelcomeEmail(user);
});

// Handle errors
errorPrism.getOptional(result).ifPresent(error -&gt; {
    switch (error) {
        case ValidationError ve -&gt; displayFormErrors(ve);
        case DatabaseError de -&gt; retryOrFallback(de);
        case NetworkError ne -&gt; scheduleRetry(ne);
    }
});
</code></pre>
<h3 id="pattern-3-exception-recovery-with-try"><a class="header" href="#pattern-3-exception-recovery-with-try">Pattern 3: Exception Recovery with Try</a></h3>
<pre><code class="language-java">Try&lt;Config&gt; configResult = Try.of(() -&gt; loadConfig(configPath));

Prism&lt;Try&lt;Config&gt;, Config&gt; successPrism = Prisms.success();
Prism&lt;Try&lt;Config&gt;, Throwable&gt; failurePrism = Prisms.failure();

// Use config if loaded successfully
Config config = successPrism.getOptional(configResult)
    .orElseGet(() -&gt; {
        // Log the failure
        failurePrism.getOptional(configResult).ifPresent(error -&gt;
            logger.error("Failed to load config", error)
        );
        // Return default config
        return Config.defaults();
    });
</code></pre>
<h2 id="beforeafter-comparison"><a class="header" href="#beforeafter-comparison">Before/After Comparison</a></h2>
<p>Let's see a complete real-world scenario comparing traditional approaches with prisms:</p>
<p><strong>Scenario:</strong> Processing a batch of API responses, each containing optional user data.</p>
<div id="admonition--traditional-approach" class="admonition admonish-failure" role="note" aria-labelledby="admonition--traditional-approach-title">
<div class="admonition-title">
<div id="admonition--traditional-approach-title">
<p>‚ùå Traditional Approach</p>
</div>
<a class="admonition-anchor-link" href="optics/core_type_prisms.html#admonition--traditional-approach"></a>
</div>
<div>
<pre><code class="language-java">public List&lt;String&gt; extractUserEmails(List&lt;ApiResponse&lt;User&gt;&gt; responses) {
    List&lt;String&gt; emails = new ArrayList&lt;&gt;();

    for (ApiResponse&lt;User&gt; response : responses) {
        if (response.statusCode() == 200) {
            Maybe&lt;User&gt; data = response.data();
            if (data.isJust()) {
                User user = data.get();
                if (user.email() != null) {
                    emails.add(user.email());
                }
            }
        }
    }

    return emails;
}
</code></pre>
<p>Problems:</p>
<ul>
<li>Deeply nested conditionals</li>
<li>Manual null checking</li>
<li>Imperative style with mutable list</li>
<li>Easy to introduce bugs</li>
</ul>
</div>
</div>
<div id="admonition--with-prisms-and-functional-style" class="admonition admonish-success" role="note" aria-labelledby="admonition--with-prisms-and-functional-style-title">
<div class="admonition-title">
<div id="admonition--with-prisms-and-functional-style-title">
<p>‚úÖ With Prisms and Functional Style</p>
</div>
<a class="admonition-anchor-link" href="optics/core_type_prisms.html#admonition--with-prisms-and-functional-style"></a>
</div>
<div>
<pre><code class="language-java">public List&lt;String&gt; extractUserEmails(List&lt;ApiResponse&lt;User&gt;&gt; responses) {
    Prism&lt;Maybe&lt;User&gt;, User&gt; justPrism = Prisms.just();

    return responses.stream()
        .filter(r -&gt; r.statusCode() == 200)
        .flatMap(r -&gt; justPrism.getOptional(r.data()).stream())
        .map(User::email)
        .filter(Objects::nonNull)
        .toList();
}
</code></pre>
<p>Benefits:</p>
<ul>
<li>Flat, readable pipeline</li>
<li>Prism handles the Maybe extraction</li>
<li>Declarative, functional style</li>
<li>Harder to introduce bugs</li>
</ul>
</div>
</div>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<div id="admonition--choose-the-right-tool" class="admonition admonish-tip" role="note" aria-labelledby="admonition--choose-the-right-tool-title">
<div class="admonition-title">
<div id="admonition--choose-the-right-tool-title">
<p>üí° Choose the Right Tool</p>
</div>
<a class="admonition-anchor-link" href="optics/core_type_prisms.html#admonition--choose-the-right-tool"></a>
</div>
<div>
<p><strong>Use prisms when:</strong></p>
<ul>
<li>Extracting values from core types</li>
<li>Pattern matching on sum types</li>
<li>Composing with other optics for deep navigation</li>
<li>Processing collections of core types</li>
</ul>
<p><strong>Use traversals when:</strong></p>
<ul>
<li>Modifying values inside core types</li>
<li>Applying transformations conditionally</li>
<li>Error enrichment or exception wrapping</li>
</ul>
</div>
</div>
<div id="admonition--prisms-return-optional" class="admonition admonish-warning" role="note" aria-labelledby="admonition--prisms-return-optional-title">
<div class="admonition-title">
<div id="admonition--prisms-return-optional-title">
<p>‚ö†Ô∏è Prisms Return Optional</p>
</div>
<a class="admonition-anchor-link" href="optics/core_type_prisms.html#admonition--prisms-return-optional"></a>
</div>
<div>
<p>Remember that <code>prism.getOptional()</code> returns Java's <code>Optional</code>, not <code>Maybe</code>:</p>
<pre><code class="language-java">Prism&lt;Maybe&lt;String&gt;, String&gt; justPrism = Prisms.just();
Maybe&lt;String&gt; maybeValue = Maybe.just("Hello");

// Returns Optional, not Maybe
Optional&lt;String&gt; value = justPrism.getOptional(maybeValue);

// Convert back to Maybe if needed
Maybe&lt;String&gt; backToMaybe = value
    .map(Maybe::just)
    .orElse(Maybe.nothing());
</code></pre>
</div>
</div>
<div id="admonition--compose-for-deep-navigation" class="admonition admonish-tip" role="note" aria-labelledby="admonition--compose-for-deep-navigation-title">
<div class="admonition-title">
<div id="admonition--compose-for-deep-navigation-title">
<p>üí° Compose for Deep Navigation</p>
</div>
<a class="admonition-anchor-link" href="optics/core_type_prisms.html#admonition--compose-for-deep-navigation"></a>
</div>
<div>
<p>Don't extract and re-wrap manually. Compose prisms with lenses and traversals for deep navigation:</p>
<pre><code class="language-java">// ‚ùå Manual extraction
Optional&lt;User&gt; user = justPrism.getOptional(maybeUser);
Optional&lt;String&gt; email = user.map(u -&gt; emailLens.get(u));

// ‚úÖ Compose
Traversal&lt;Maybe&lt;User&gt;, String&gt; path = MaybeTraversals.just()
    .andThen(emailLens.asTraversal());
List&lt;String&gt; emails = Traversals.toListOf(path, maybeUser);
</code></pre>
</div>
</div>
<h2 id="working-example"><a class="header" href="#working-example">Working Example</a></h2>
<p>For a complete, runnable demonstration of all these patterns, see:</p>
<div id="admonition-coretypeprismsexamplejava" class="admonition admonish-example" role="note" aria-labelledby="admonition-coretypeprismsexamplejava-title">
<div class="admonition-title">
<div id="admonition-coretypeprismsexamplejava-title">
<p>CoreTypePrismsExample.java</p>
</div>
<a class="admonition-anchor-link" href="optics/core_type_prisms.html#admonition-coretypeprismsexamplejava"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/CoreTypePrismsExample.java">View the complete example ‚Üí</a></p>
<p>This example demonstrates:</p>
<ul>
<li>All core type prisms (Maybe, Either, Validated, Try)</li>
<li>All core type traversals</li>
<li>Composition with lenses</li>
<li>Processing collections</li>
<li>Before/after comparisons</li>
<li>Real-world API response processing</li>
</ul>
</div>
</div>
<h2 id="summary-6"><a class="header" href="#summary-6">Summary</a></h2>
<p>Core type prisms provide:</p>
<p>üéØ <strong>Safe Extraction</strong> ‚Äî Extract values from <code>Maybe</code>, <code>Either</code>, <code>Validated</code>, and <code>Try</code> without null checks or verbose pattern matching</p>
<p>üîç <strong>Pattern Matching</strong> ‚Äî Use <code>matches()</code> to check cases, <code>getOptional()</code> to extract values</p>
<p>üîÑ <strong>Composability</strong> ‚Äî Combine with lenses and traversals for deep navigation</p>
<p>üìä <strong>Collection Processing</strong> ‚Äî Filter, extract, and count different cases in collections</p>
<p>üõ°Ô∏è <strong>Type Safety</strong> ‚Äî The compiler ensures you handle all cases correctly</p>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<p>Now that you understand core type prisms, learn how to enhance lens operations with validation and error handling:</p>
<p><strong>Next:</strong> <a href="optics/lens_extensions.html">Lens Extensions: Validated Field Operations</a></p>
<p>Or return to the overview:</p>
<p><strong>Back:</strong> <a href="optics/core_type_integration.html">Working with Core Types and Optics</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="lens-extensions-validated-field-operations"><a class="header" href="#lens-extensions-validated-field-operations">Lens Extensions: Validated Field Operations</a></h1>
<p><img src="optics/../images/optics.jpg" alt="lenses.jpg" /></p>
<p>Lenses provide a composable way to focus on and update fields in immutable data structures. But what happens when those fields might be <code>null</code>, updates require validation, or operations might throw exceptions?</p>
<p>Traditional lenses work brilliantly with clean, valid data. Real-world applications, however, deal with nullable fields, validation requirements, and exception-prone operations. <strong>Lens Extensions</strong> bridge this gap by augmenting lenses with built-in support for Higher-Kinded-J's core types.</p>
<p>Think of lens extensions as <strong>safety rails</strong> for your lenses‚Äîthey catch null values, validate modifications, and handle exceptions whilst maintaining the elegance of functional composition.</p>
<h2 id="the-problem-defensive-programming-clutter"><a class="header" href="#the-problem-defensive-programming-clutter">The Problem: Defensive Programming Clutter</a></h2>
<p>Let's see what happens when we try to use lenses with real-world messy data:</p>
<div id="admonition--traditional-lens-usage-with-validation" class="admonition admonish-failure" role="note" aria-labelledby="admonition--traditional-lens-usage-with-validation-title">
<div class="admonition-title">
<div id="admonition--traditional-lens-usage-with-validation-title">
<p>‚ùå Traditional Lens Usage with Validation</p>
</div>
<a class="admonition-anchor-link" href="optics/lens_extensions.html#admonition--traditional-lens-usage-with-validation"></a>
</div>
<div>
<pre><code class="language-java">public User updateUserEmail(User user, String newEmail) {
    Lens&lt;User, String&gt; emailLens = UserLenses.email();

    // Null checking
    if (user == null) {
        throw new NullPointerException("User cannot be null");
    }

    String currentEmail = emailLens.get(user);
    if (currentEmail == null) {
        // Now what? Set default? Throw exception?
    }

    // Validation
    if (newEmail == null || !newEmail.contains("@")) {
        throw new ValidationException("Invalid email format");
    }

    // Update
    try {
        String validated = validateEmailFormat(newEmail);
        return emailLens.set(validated, user);
    } catch (Exception e) {
        // Handle exception, but lens already called set()
        throw new RuntimeException("Update failed", e);
    }
}
</code></pre>
<p>The lens operation is buried under layers of null checks, validation, and exception handling.</p>
</div>
</div>
<div id="admonition--with-lens-extensions" class="admonition admonish-success" role="note" aria-labelledby="admonition--with-lens-extensions-title">
<div class="admonition-title">
<div id="admonition--with-lens-extensions-title">
<p>‚úÖ With Lens Extensions</p>
</div>
<a class="admonition-anchor-link" href="optics/lens_extensions.html#admonition--with-lens-extensions"></a>
</div>
<div>
<pre><code class="language-java">public Either&lt;String, User&gt; updateUserEmail(User user, String newEmail) {
    Lens&lt;User, String&gt; emailLens = UserLenses.email();

    return modifyEither(
        emailLens,
        email -&gt; validateEmail(email),  // Returns Either&lt;String, String&gt;
        user
    );
}

private Either&lt;String, String&gt; validateEmail(String email) {
    if (email == null || !email.contains("@")) {
        return Either.left("Invalid email format");
    }
    return Either.right(email.toLowerCase());
}
</code></pre>
<p>Clean separation: the lens defines <strong>where</strong> to update, the validation function defines <strong>what</strong> is valid, and <code>Either</code> carries the result or error. No defensive programming clutter.</p>
</div>
</div>
<h2 id="available-lens-extensions"><a class="header" href="#available-lens-extensions">Available Lens Extensions</a></h2>
<p>Higher-Kinded-J provides lens extensions in the <code>LensExtensions</code> utility class. All methods are static, designed for import with <code>import static</code>:</p>
<pre><code class="language-java">import static org.higherkindedj.optics.extensions.LensExtensions.*;
</code></pre>
<div id="admonition--alternative-fluent-api" class="admonition admonish-note" role="note" aria-labelledby="admonition--alternative-fluent-api-title">
<div class="admonition-title">
<div id="admonition--alternative-fluent-api-title">
<p>üí° Alternative: Fluent API</p>
</div>
<a class="admonition-anchor-link" href="optics/lens_extensions.html#admonition--alternative-fluent-api"></a>
</div>
<div>
<p>These extension methods are also available through the <a href="optics/fluent_api.html">Fluent API</a>, which provides method chaining and a more discoverable interface. For example, <code>getMaybe(lens, source)</code> can also be written as <code>OpticOps.getting(source).through(lens).asMaybe()</code>.</p>
</div>
</div>
<h3 id="safe-access-methods"><a class="header" href="#safe-access-methods">Safe Access Methods</a></h3>
<p>These methods safely <strong>get</strong> values from fields that might be <code>null</code>:</p>
<h4 id="getmaybe--null-safe-field-access"><a class="header" href="#getmaybe--null-safe-field-access"><code>getMaybe</code> ‚Äî Null-Safe Field Access</a></h4>
<pre><code class="language-java">public static &lt;S, A&gt; Maybe&lt;A&gt; getMaybe(Lens&lt;S, A&gt; lens, S source)
</code></pre>
<p>Returns <code>Maybe.just(value)</code> if the field is non-null, <code>Maybe.nothing()</code> otherwise.</p>
<pre><code class="language-java">Lens&lt;UserProfile, String&gt; bioLens = UserProfileLenses.bio();

UserProfile withBio = new UserProfile("u1", "Alice", "alice@example.com", 30, "Software Engineer");
Maybe&lt;String&gt; bio = getMaybe(bioLens, withBio);  // Maybe.just("Software Engineer")

UserProfile withoutBio = new UserProfile("u2", "Bob", "bob@example.com", 25, null);
Maybe&lt;String&gt; noBio = getMaybe(bioLens, withoutBio);  // Maybe.nothing()

// Use with default
String displayBio = bio.orElse("No bio provided");
</code></pre>
<div id="admonition--when-to-use-getmaybe" class="admonition admonish-tip" role="note" aria-labelledby="admonition--when-to-use-getmaybe-title">
<div class="admonition-title">
<div id="admonition--when-to-use-getmaybe-title">
<p>üí° When to Use getMaybe</p>
</div>
<a class="admonition-anchor-link" href="optics/lens_extensions.html#admonition--when-to-use-getmaybe"></a>
</div>
<div>
<p>Use <code>getMaybe</code> when:</p>
<ul>
<li>Accessing optional fields (bio, middle name, phone number)</li>
<li>Avoiding <code>NullPointerException</code> when calling methods on the field</li>
<li>Composing multiple optional accesses</li>
<li>Converting between optics and functional style</li>
</ul>
</div>
</div>
<h4 id="geteither--access-with-default-error"><a class="header" href="#geteither--access-with-default-error"><code>getEither</code> ‚Äî Access with Default Error</a></h4>
<pre><code class="language-java">public static &lt;S, A, E&gt; Either&lt;E, A&gt; getEither(Lens&lt;S, A&gt; lens, E error, S source)
</code></pre>
<p>Returns <code>Either.right(value)</code> if non-null, <code>Either.left(error)</code> if null.</p>
<pre><code class="language-java">Lens&lt;UserProfile, Integer&gt; ageLens = UserProfileLenses.age();

UserProfile validProfile = new UserProfile("u1", "Alice", "alice@example.com", 30, "Engineer");
Either&lt;String, Integer&gt; age = getEither(ageLens, "Age not provided", validProfile);
// Either.right(30)

UserProfile invalidProfile = new UserProfile("u2", "Bob", "bob@example.com", null, "Student");
Either&lt;String, Integer&gt; noAge = getEither(ageLens, "Age not provided", invalidProfile);
// Either.left("Age not provided")

// Use in a pipeline
String message = age.fold(
    error -&gt; "Error: " + error,
    a -&gt; "Age: " + a
);
</code></pre>
<h4 id="getvalidated--access-with-validation-error"><a class="header" href="#getvalidated--access-with-validation-error"><code>getValidated</code> ‚Äî Access with Validation Error</a></h4>
<pre><code class="language-java">public static &lt;S, A, E&gt; Validated&lt;E, A&gt; getValidated(Lens&lt;S, A&gt; lens, E error, S source)
</code></pre>
<p>Like <code>getEither</code>, but returns <code>Validated</code> for consistency with validation workflows.</p>
<pre><code class="language-java">Lens&lt;UserProfile, String&gt; emailLens = UserProfileLenses.email();

UserProfile profile = new UserProfile("u1", "Alice", "alice@example.com", 30, "Engineer");
Validated&lt;String, String&gt; email = getValidated(emailLens, "Email is required", profile);
// Validated.valid("alice@example.com")

UserProfile noEmail = new UserProfile("u2", "Bob", null, 25, "Student");
Validated&lt;String, String&gt; missing = getValidated(emailLens, "Email is required", noEmail);
// Validated.invalid("Email is required")
</code></pre>
<h3 id="modification-methods"><a class="header" href="#modification-methods">Modification Methods</a></h3>
<p>These methods <strong>modify</strong> fields with validation, null-safety, or exception handling:</p>
<h4 id="modifymaybe--optional-modifications"><a class="header" href="#modifymaybe--optional-modifications"><code>modifyMaybe</code> ‚Äî Optional Modifications</a></h4>
<pre><code class="language-java">public static &lt;S, A&gt; Maybe&lt;S&gt; modifyMaybe(
    Lens&lt;S, A&gt; lens,
    Function&lt;A, Maybe&lt;A&gt;&gt; modifier,
    S source)
</code></pre>
<p>Apply a modification that might not succeed. Returns <code>Maybe.just(updated)</code> if the modification succeeds, <code>Maybe.nothing()</code> if it fails.</p>
<pre><code class="language-java">Lens&lt;UserProfile, String&gt; nameLens = UserProfileLenses.name();
UserProfile profile = new UserProfile("u1", "Alice", "alice@example.com", 30, "Engineer");

// Successful modification
Maybe&lt;UserProfile&gt; updated = modifyMaybe(
    nameLens,
    name -&gt; name.length() &gt;= 2 ? Maybe.just(name.toUpperCase()) : Maybe.nothing(),
    profile
);
// Maybe.just(UserProfile with name "ALICE")

// Failed modification
UserProfile shortName = new UserProfile("u2", "A", "a@example.com", 25, "Student");
Maybe&lt;UserProfile&gt; failed = modifyMaybe(
    nameLens,
    name -&gt; name.length() &gt;= 2 ? Maybe.just(name.toUpperCase()) : Maybe.nothing(),
    shortName
);
// Maybe.nothing()

// Use result
String result = updated
    .map(p -&gt; "Updated: " + p.name())
    .orElse("Update failed");
</code></pre>
<div id="admonition-real-world-example-optional-formatting" class="admonition admonish-example" role="note" aria-labelledby="admonition-real-world-example-optional-formatting-title">
<div class="admonition-title">
<div id="admonition-real-world-example-optional-formatting-title">
<p>Real-World Example: Optional Formatting</p>
</div>
<a class="admonition-anchor-link" href="optics/lens_extensions.html#admonition-real-world-example-optional-formatting"></a>
</div>
<div>
<pre><code class="language-java">Lens&lt;Product, String&gt; skuLens = ProductLenses.sku();

// Only format SKU if it matches a pattern
Maybe&lt;Product&gt; formatted = modifyMaybe(
    skuLens,
    sku -&gt; sku.matches("^[A-Z]{3}-\\d{4}$")
        ? Maybe.just(sku.toUpperCase())
        : Maybe.nothing(),  // Leave invalid SKUs unchanged
    product
);
</code></pre>
</div>
</div>
<h4 id="modifyeither--fail-fast-validation"><a class="header" href="#modifyeither--fail-fast-validation"><code>modifyEither</code> ‚Äî Fail-Fast Validation</a></h4>
<pre><code class="language-java">public static &lt;S, A, E&gt; Either&lt;E, S&gt; modifyEither(
    Lens&lt;S, A&gt; lens,
    Function&lt;A, Either&lt;E, A&gt;&gt; modifier,
    S source)
</code></pre>
<p>Apply a modification with validation. Returns <code>Either.right(updated)</code> if valid, <code>Either.left(error)</code> if invalid. <strong>Stops at first error</strong>.</p>
<pre><code class="language-java">Lens&lt;UserProfile, Integer&gt; ageLens = UserProfileLenses.age();
UserProfile profile = new UserProfile("u1", "Alice", "alice@example.com", 30, "Engineer");

// Valid modification
Either&lt;String, UserProfile&gt; updated = modifyEither(
    ageLens,
    age -&gt; {
        if (age &lt; 0) return Either.left("Age cannot be negative");
        if (age &gt; 150) return Either.left("Age must be realistic");
        return Either.right(age + 1);  // Birthday!
    },
    profile
);
// Either.right(UserProfile with age 31)

// Invalid modification
UserProfile invalidAge = new UserProfile("u2", "Bob", "bob@example.com", 200, "Time traveller");
Either&lt;String, UserProfile&gt; failed = modifyEither(
    ageLens,
    age -&gt; {
        if (age &lt; 0) return Either.left("Age cannot be negative");
        if (age &gt; 150) return Either.left("Age must be realistic");
        return Either.right(age + 1);
    },
    invalidAge
);
// Either.left("Age must be realistic")

// Display result
String message = updated.fold(
    error -&gt; "‚ùå " + error,
    user -&gt; "‚úÖ Updated age to " + user.age()
);
</code></pre>
<div id="admonition--when-to-use-modifyeither" class="admonition admonish-tip" role="note" aria-labelledby="admonition--when-to-use-modifyeither-title">
<div class="admonition-title">
<div id="admonition--when-to-use-modifyeither-title">
<p>üí° When to Use modifyEither</p>
</div>
<a class="admonition-anchor-link" href="optics/lens_extensions.html#admonition--when-to-use-modifyeither"></a>
</div>
<div>
<p>Use <code>modifyEither</code> for <strong>fail-fast</strong> validation:</p>
<ul>
<li>Single field updates where you want to stop at the first error</li>
<li>API request validation (reject immediately if any field is invalid)</li>
<li>Form submissions where you show the first error encountered</li>
<li>Operations where continuing after an error doesn't make sense</li>
</ul>
</div>
</div>
<h4 id="modifyvalidated--validated-modifications"><a class="header" href="#modifyvalidated--validated-modifications"><code>modifyValidated</code> ‚Äî Validated Modifications</a></h4>
<pre><code class="language-java">public static &lt;S, A, E&gt; Validated&lt;E, S&gt; modifyValidated(
    Lens&lt;S, A&gt; lens,
    Function&lt;A, Validated&lt;E, A&gt;&gt; modifier,
    S source)
</code></pre>
<p>Like <code>modifyEither</code>, but returns <code>Validated</code> for consistency with error accumulation workflows.</p>
<pre><code class="language-java">Lens&lt;UserProfile, String&gt; emailLens = UserProfileLenses.email();
UserProfile profile = new UserProfile("u1", "Alice", "old@example.com", 30, "Engineer");

// Valid email format
Validated&lt;String, UserProfile&gt; updated = modifyValidated(
    emailLens,
    email -&gt; {
        if (!email.contains("@")) {
            return Validated.invalid("Email must contain @");
        }
        if (!email.endsWith(".com") &amp;&amp; !email.endsWith(".co.uk")) {
            return Validated.invalid("Email must end with .com or .co.uk");
        }
        return Validated.valid(email.toLowerCase());
    },
    profile
);
// Validated.valid(UserProfile with email "old@example.com")

// Invalid email format
UserProfile badEmail = new UserProfile("u2", "Bob", "invalid-email", 25, "Student");
Validated&lt;String, UserProfile&gt; failed = modifyValidated(
    emailLens,
    email -&gt; {
        if (!email.contains("@")) {
            return Validated.invalid("Email must contain @");
        }
        if (!email.endsWith(".com") &amp;&amp; !email.endsWith(".co.uk")) {
            return Validated.invalid("Email must end with .com or .co.uk");
        }
        return Validated.valid(email.toLowerCase());
    },
    badEmail
);
// Validated.invalid("Email must contain @")
</code></pre>
<div id="admonition--either-vs-validated-for-single-fields" class="admonition admonish-tip" role="note" aria-labelledby="admonition--either-vs-validated-for-single-fields-title">
<div class="admonition-title">
<div id="admonition--either-vs-validated-for-single-fields-title">
<p>üí° Either vs Validated for Single Fields</p>
</div>
<a class="admonition-anchor-link" href="optics/lens_extensions.html#admonition--either-vs-validated-for-single-fields"></a>
</div>
<div>
<p>For <strong>single field</strong> validation, <code>modifyEither</code> and <code>modifyValidated</code> behave identically (both fail fast). The difference matters when validating <strong>multiple fields</strong>‚Äîuse <code>Validated</code> when you want to accumulate errors across fields.</p>
</div>
</div>
<h4 id="modifytry--exception-safe-modifications"><a class="header" href="#modifytry--exception-safe-modifications"><code>modifyTry</code> ‚Äî Exception-Safe Modifications</a></h4>
<pre><code class="language-java">public static &lt;S, A&gt; Try&lt;S&gt; modifyTry(
    Lens&lt;S, A&gt; lens,
    Function&lt;A, Try&lt;A&gt;&gt; modifier,
    S source)
</code></pre>
<p>Apply a modification that might throw exceptions. Returns <code>Try.success(updated)</code> if successful, <code>Try.failure(exception)</code> if an exception occurred.</p>
<pre><code class="language-java">Lens&lt;UserProfile, String&gt; emailLens = UserProfileLenses.email();
UserProfile profile = new UserProfile("u1", "Alice", "alice@example.com", 30, "Engineer");

// Successful database update
Try&lt;UserProfile&gt; updated = modifyTry(
    emailLens,
    email -&gt; Try.of(() -&gt; updateEmailInDatabase(email)),
    profile
);
// Try.success(UserProfile with updated email)

// Failed database update
UserProfile badEmail = new UserProfile("u2", "Bob", "fail@example.com", 25, "Student");
Try&lt;UserProfile&gt; failed = modifyTry(
    emailLens,
    email -&gt; Try.of(() -&gt; updateEmailInDatabase(email)),
    badEmail
);
// Try.failure(RuntimeException: "Database connection failed")

// Handle result
updated.match(
    user -&gt; logger.info("Email updated: {}", user.email()),
    error -&gt; logger.error("Update failed", error)
);
</code></pre>
<div id="admonition-real-world-example-database-operations" class="admonition admonish-example" role="note" aria-labelledby="admonition-real-world-example-database-operations-title">
<div class="admonition-title">
<div id="admonition-real-world-example-database-operations-title">
<p>Real-World Example: Database Operations</p>
</div>
<a class="admonition-anchor-link" href="optics/lens_extensions.html#admonition-real-world-example-database-operations"></a>
</div>
<div>
<pre><code class="language-java">// Update user's profile picture by uploading to S3
Lens&lt;User, String&gt; profilePictureLens = UserLenses.profilePictureUrl();

Try&lt;User&gt; result = modifyTry(
    profilePictureLens,
    oldUrl -&gt; Try.of(() -&gt; {
        // Upload new image to S3 (might throw IOException, AmazonS3Exception)
        String newUrl = s3Client.uploadImage(imageData);
        // Delete old image if it exists
        if (oldUrl != null &amp;&amp; !oldUrl.isEmpty()) {
            s3Client.deleteImage(oldUrl);
        }
        return newUrl;
    }),
    user
);

result.match(
    updated -&gt; sendSuccessResponse(updated),
    error -&gt; sendErrorResponse("Image upload failed: " + error.getMessage())
);
</code></pre>
</div>
</div>
<h4 id="setifvalid--conditional-updates"><a class="header" href="#setifvalid--conditional-updates"><code>setIfValid</code> ‚Äî Conditional Updates</a></h4>
<pre><code class="language-java">public static &lt;S, A, E&gt; Either&lt;E, S&gt; setIfValid(
    Lens&lt;S, A&gt; lens,
    Function&lt;A, Either&lt;E, A&gt;&gt; validator,
    A newValue,
    S source)
</code></pre>
<p>Set a new value <strong>only if it passes validation</strong>. Unlike <code>modifyEither</code>, you provide the new value directly rather than deriving it from the old value.</p>
<pre><code class="language-java">Lens&lt;UserProfile, String&gt; nameLens = UserProfileLenses.name();
UserProfile profile = new UserProfile("u1", "Alice", "alice@example.com", 30, "Engineer");

// Valid name format
Either&lt;String, UserProfile&gt; updated = setIfValid(
    nameLens,
    name -&gt; {
        if (name.length() &lt; 2) {
            return Either.left("Name must be at least 2 characters");
        }
        if (!name.matches("[A-Z][a-z]+")) {
            return Either.left("Name must start with capital letter");
        }
        return Either.right(name);
    },
    "Robert",
    profile
);
// Either.right(UserProfile with name "Robert")

// Invalid name format
Either&lt;String, UserProfile&gt; failed = setIfValid(
    nameLens,
    name -&gt; {
        if (name.length() &lt; 2) {
            return Either.left("Name must be at least 2 characters");
        }
        if (!name.matches("[A-Z][a-z]+")) {
            return Either.left("Name must start with capital letter");
        }
        return Either.right(name);
    },
    "bob123",
    profile
);
// Either.left("Name must start with capital letter")
</code></pre>
<div id="admonition--setifvalid-vs-modifyeither" class="admonition admonish-tip" role="note" aria-labelledby="admonition--setifvalid-vs-modifyeither-title">
<div class="admonition-title">
<div id="admonition--setifvalid-vs-modifyeither-title">
<p>üí° setIfValid vs modifyEither</p>
</div>
<a class="admonition-anchor-link" href="optics/lens_extensions.html#admonition--setifvalid-vs-modifyeither"></a>
</div>
<div>
<p><strong>Use <code>setIfValid</code> when:</strong></p>
<ul>
<li>The new value comes from user input or external source</li>
<li>You're not transforming the old value</li>
<li>You want to validate before setting</li>
</ul>
<p><strong>Use <code>modifyEither</code> when:</strong></p>
<ul>
<li>The new value is derived from the old value (e.g., incrementing, formatting)</li>
<li>You're transforming the current value</li>
</ul>
</div>
</div>
<h2 id="composing-lens-extensions"><a class="header" href="#composing-lens-extensions">Composing Lens Extensions</a></h2>
<p>Lens extensions compose naturally with other optics operations:</p>
<h3 id="chaining-multiple-updates"><a class="header" href="#chaining-multiple-updates">Chaining Multiple Updates</a></h3>
<pre><code class="language-java">UserProfile original = new UserProfile("u1", "alice", "ALICE@EXAMPLE.COM", 30, null);

Lens&lt;UserProfile, String&gt; nameLens = UserProfileLenses.name();
Lens&lt;UserProfile, String&gt; emailLens = UserProfileLenses.email();

// Chain multiple validations
Either&lt;String, UserProfile&gt; result = modifyEither(
    nameLens,
    name -&gt; Either.right(capitalize(name)),
    original
).flatMap(user -&gt;
    modifyEither(
        emailLens,
        email -&gt; Either.right(email.toLowerCase()),
        user
    )
);
// Either.right(UserProfile with name "Alice", email "alice@example.com")
</code></pre>
<h3 id="nested-structure-updates"><a class="header" href="#nested-structure-updates">Nested Structure Updates</a></h3>
<pre><code class="language-java">@GenerateLenses
record Address(String street, String city, String postcode) {}

@GenerateLenses
record User(String name, Address address) {}

Lens&lt;User, Address&gt; addressLens = UserLenses.address();
Lens&lt;Address, String&gt; postcodeLens = AddressLenses.postcode();
Lens&lt;User, String&gt; userPostcodeLens = addressLens.andThen(postcodeLens);

User user = new User("Alice", new Address("123 Main St", "London", "SW1A 1AA"));

// Validate and update nested field
Either&lt;String, User&gt; updated = modifyEither(
    userPostcodeLens,
    postcode -&gt; validatePostcode(postcode),
    user
);
</code></pre>
<h2 id="common-patterns-3"><a class="header" href="#common-patterns-3">Common Patterns</a></h2>
<h3 id="pattern-1-form-validation"><a class="header" href="#pattern-1-form-validation">Pattern 1: Form Validation</a></h3>
<p>Validating individual form fields with immediate feedback:</p>
<pre><code class="language-java">public Either&lt;String, UserProfile&gt; validateAndUpdateEmail(
    UserProfile profile,
    String newEmail
) {
    Lens&lt;UserProfile, String&gt; emailLens = UserProfileLenses.email();

    return modifyEither(
        emailLens,
        email -&gt; {
            if (email == null || email.isEmpty()) {
                return Either.left("Email is required");
            }
            if (!email.contains("@")) {
                return Either.left("Email must contain @");
            }
            if (!email.matches("^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+$")) {
                return Either.left("Email format is invalid");
            }
            return Either.right(email.toLowerCase());
        },
        profile
    );
}
</code></pre>
<h3 id="pattern-2-safe-field-access-with-default"><a class="header" href="#pattern-2-safe-field-access-with-default">Pattern 2: Safe Field Access with Default</a></h3>
<p>Safely accessing nullable fields and providing defaults:</p>
<pre><code class="language-java">Lens&lt;UserProfile, String&gt; bioLens = UserProfileLenses.bio();

String displayBio = getMaybe(bioLens, profile)
    .orElse("No bio provided");

// Or with transformation
String formattedBio = getMaybe(bioLens, profile)
    .map(bio -&gt; bio.length() &gt; 100 ? bio.substring(0, 100) + "..." : bio)
    .orElse("No bio");
</code></pre>
<h3 id="pattern-3-database-operations-with-exception-handling"><a class="header" href="#pattern-3-database-operations-with-exception-handling">Pattern 3: Database Operations with Exception Handling</a></h3>
<p>Performing database updates that might fail:</p>
<pre><code class="language-java">public Try&lt;User&gt; updateUserInDatabase(User user, String newEmail) {
    Lens&lt;User, String&gt; emailLens = UserLenses.email();

    return modifyTry(
        emailLens,
        email -&gt; Try.of(() -&gt; {
            // Validate email is unique in database
            if (emailExists(email)) {
                throw new DuplicateEmailException("Email already in use");
            }
            // Update in database
            database.updateEmail(user.id(), email);
            return email;
        }),
        user
    );
}
</code></pre>
<h2 id="beforeafter-comparison-1"><a class="header" href="#beforeafter-comparison-1">Before/After Comparison</a></h2>
<p>Let's see a complete real-world scenario:</p>
<p><strong>Scenario:</strong> User profile update form with validation.</p>
<div id="admonition--traditional-approach" class="admonition admonish-failure" role="note" aria-labelledby="admonition--traditional-approach-title">
<div class="admonition-title">
<div id="admonition--traditional-approach-title">
<p>‚ùå Traditional Approach</p>
</div>
<a class="admonition-anchor-link" href="optics/lens_extensions.html#admonition--traditional-approach"></a>
</div>
<div>
<pre><code class="language-java">public class UserProfileUpdater {
    public UserProfile updateProfile(
        UserProfile profile,
        String newEmail,
        Integer newAge,
        String newBio
    ) throws ValidationException {
        // Email validation
        if (newEmail != null) {
            if (!newEmail.contains("@")) {
                throw new ValidationException("Invalid email");
            }
            profile = new UserProfile(
                profile.userId(),
                profile.name(),
                newEmail.toLowerCase(),
                profile.age(),
                profile.bio()
            );
        }

        // Age validation
        if (newAge != null) {
            if (newAge &lt; 0 || newAge &gt; 150) {
                throw new ValidationException("Invalid age");
            }
            profile = new UserProfile(
                profile.userId(),
                profile.name(),
                profile.email(),
                newAge,
                profile.bio()
            );
        }

        // Bio update (optional)
        if (newBio != null &amp;&amp; newBio.length() &gt; 10) {
            profile = new UserProfile(
                profile.userId(),
                profile.name(),
                profile.email(),
                profile.age(),
                newBio
            );
        }

        return profile;
    }
}
</code></pre>
<p>Problems:</p>
<ul>
<li>Repeated record construction (error-prone)</li>
<li>Mixed validation and update logic</li>
<li>Throws exceptions (not functional)</li>
<li>Can't collect multiple errors</li>
<li>Hard to test individual validations</li>
</ul>
</div>
</div>
<div id="admonition--with-lens-extensions-1" class="admonition admonish-success" role="note" aria-labelledby="admonition--with-lens-extensions-1-title">
<div class="admonition-title">
<div id="admonition--with-lens-extensions-1-title">
<p>‚úÖ With Lens Extensions</p>
</div>
<a class="admonition-anchor-link" href="optics/lens_extensions.html#admonition--with-lens-extensions-1"></a>
</div>
<div>
<pre><code class="language-java">public class UserProfileUpdater {
    public Either&lt;List&lt;String&gt;, UserProfile&gt; updateProfile(
        UserProfile profile,
        String newEmail,
        Integer newAge,
        String newBio
    ) {
        Lens&lt;UserProfile, String&gt; emailLens = UserProfileLenses.email();
        Lens&lt;UserProfile, Integer&gt; ageLens = UserProfileLenses.age();
        Lens&lt;UserProfile, String&gt; bioLens = UserProfileLenses.bio();

        // Update email
        Either&lt;String, UserProfile&gt; emailResult =
            modifyEither(emailLens, this::validateEmail, profile);

        // Update age
        Either&lt;String, UserProfile&gt; ageResult =
            emailResult.flatMap(p -&gt; modifyEither(ageLens, this::validateAge, p));

        // Update bio (optional)
        Either&lt;String, UserProfile&gt; finalResult =
            ageResult.flatMap(p -&gt; modifyMaybe(bioLens, this::formatBio, p)
                .map(Either::&lt;String, UserProfile&gt;right)
                .orElse(Either.right(p)));

        return finalResult.mapLeft(List::of);
    }

    private Either&lt;String, String&gt; validateEmail(String email) {
        if (!email.contains("@")) {
            return Either.left("Email must contain @");
        }
        return Either.right(email.toLowerCase());
    }

    private Either&lt;String, Integer&gt; validateAge(Integer age) {
        if (age &lt; 0 || age &gt; 150) {
            return Either.left("Age must be between 0 and 150");
        }
        return Either.right(age);
    }

    private Maybe&lt;String&gt; formatBio(String bio) {
        return bio.length() &gt; 10 ? Maybe.just(bio) : Maybe.nothing();
    }
}
</code></pre>
<p>Benefits:</p>
<ul>
<li>Clean separation of concerns</li>
<li>Functional error handling</li>
<li>Each validation is testable in isolation</li>
<li>Lenses handle immutable updates</li>
<li>Clear data flow</li>
</ul>
</div>
</div>
<h2 id="best-practices-1"><a class="header" href="#best-practices-1">Best Practices</a></h2>
<div id="admonition--choose-the-right-extension-method" class="admonition admonish-tip" role="note" aria-labelledby="admonition--choose-the-right-extension-method-title">
<div class="admonition-title">
<div id="admonition--choose-the-right-extension-method-title">
<p>üí° Choose the Right Extension Method</p>
</div>
<a class="admonition-anchor-link" href="optics/lens_extensions.html#admonition--choose-the-right-extension-method"></a>
</div>
<div>
<p><strong>Use <code>getMaybe</code></strong> when accessing optional fields</p>
<p><strong>Use <code>modifyEither</code></strong> for fail-fast single field validation</p>
<p><strong>Use <code>modifyValidated</code></strong> for consistency with multi-field validation (error accumulation)</p>
<p><strong>Use <code>modifyTry</code></strong> for operations that throw exceptions (database, I/O, network)</p>
<p><strong>Use <code>setIfValid</code></strong> when setting user-provided values with validation</p>
</div>
</div>
<div id="admonition--keep-validation-functions-pure" class="admonition admonish-tip" role="note" aria-labelledby="admonition--keep-validation-functions-pure-title">
<div class="admonition-title">
<div id="admonition--keep-validation-functions-pure-title">
<p>üí° Keep Validation Functions Pure</p>
</div>
<a class="admonition-anchor-link" href="optics/lens_extensions.html#admonition--keep-validation-functions-pure"></a>
</div>
<div>
<p>Your validation and modification functions should be pure:</p>
<pre><code class="language-java">// ‚úÖ Pure validation
private Either&lt;String, String&gt; validateEmail(String email) {
    if (!email.contains("@")) {
        return Either.left("Invalid email");
    }
    return Either.right(email.toLowerCase());
}

// ‚ùå Impure validation (has side effects)
private Either&lt;String, String&gt; validateEmail(String email) {
    logger.info("Validating email: {}", email);  // Side effect!
    if (!email.contains("@")) {
        return Either.left("Invalid email");
    }
    return Either.right(email.toLowerCase());
}
</code></pre>
<p>Pure functions are easier to test, reason about, and compose.</p>
</div>
</div>
<div id="admonition--lens-extensions-dont-handle-null-sources" class="admonition admonish-warning" role="note" aria-labelledby="admonition--lens-extensions-dont-handle-null-sources-title">
<div class="admonition-title">
<div id="admonition--lens-extensions-dont-handle-null-sources-title">
<p>‚ö†Ô∏è Lens Extensions Don't Handle Null Sources</p>
</div>
<a class="admonition-anchor-link" href="optics/lens_extensions.html#admonition--lens-extensions-dont-handle-null-sources"></a>
</div>
<div>
<p>Lens extensions handle <code>null</code> <strong>field values</strong>, but not <code>null</code> <strong>source objects</strong>:</p>
<pre><code class="language-java">UserProfile profile = null;
Maybe&lt;String&gt; bio = getMaybe(bioLens, profile);  // NullPointerException!

// Wrap the source in Maybe first
Maybe&lt;UserProfile&gt; maybeProfile = Maybe.fromNullable(profile);
Maybe&lt;String&gt; safeBio = maybeProfile.flatMap(p -&gt; getMaybe(bioLens, p));
</code></pre>
</div>
</div>
<h2 id="working-example-1"><a class="header" href="#working-example-1">Working Example</a></h2>
<p>For a complete, runnable demonstration of all lens extension patterns, see:</p>
<div id="admonition-lensextensionsexamplejava" class="admonition admonish-example" role="note" aria-labelledby="admonition-lensextensionsexamplejava-title">
<div class="admonition-title">
<div id="admonition-lensextensionsexamplejava-title">
<p>LensExtensionsExample.java</p>
</div>
<a class="admonition-anchor-link" href="optics/lens_extensions.html#admonition-lensextensionsexamplejava"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/LensExtensionsExample.java">View the complete example ‚Üí</a></p>
<p>This example demonstrates:</p>
<ul>
<li>All lens extension methods</li>
<li>User profile management with validation</li>
<li>Null-safe field access</li>
<li>Exception-safe database operations</li>
<li>Form validation patterns</li>
<li>Real-world scenarios with before/after comparisons</li>
</ul>
</div>
</div>
<h2 id="summary-7"><a class="header" href="#summary-7">Summary</a></h2>
<p>Lens extensions provide:</p>
<p>üõ°Ô∏è <strong>Safety Rails</strong> ‚Äî Handle null values, validation, and exceptions without cluttering business logic</p>
<p>üéØ <strong>Separation of Concerns</strong> ‚Äî Lenses define structure, validators define rules, core types carry results</p>
<p>üîÑ <strong>Composability</strong> ‚Äî Chain multiple validations and updates in a functional pipeline</p>
<p>üìä <strong>Error Handling</strong> ‚Äî Choose fail-fast (<code>Either</code>) or exception-safe (<code>Try</code>) based on your needs</p>
<p>üß™ <strong>Testability</strong> ‚Äî Validation logic is pure and easy to test in isolation</p>
<h2 id="next-steps-2"><a class="header" href="#next-steps-2">Next Steps</a></h2>
<p>Now that you understand lens extensions for individual fields, learn how to process collections with validation and error handling:</p>
<p><strong>Next:</strong> <a href="optics/traversal_extensions.html">Traversal Extensions: Bulk Operations</a></p>
<p>Or return to the overview:</p>
<p><strong>Back:</strong> <a href="optics/core_type_integration.html">Working with Core Types and Optics</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="traversal-extensions-bulk-operations-with-error-handling"><a class="header" href="#traversal-extensions-bulk-operations-with-error-handling">Traversal Extensions: Bulk Operations with Error Handling</a></h1>
<p><img src="optics/../images/optics.jpg" alt="traversals.jpg" /></p>
<p>Traversals are optics that focus on <strong>zero or more elements</strong> in a structure‚Äîperfect for working with collections. But what happens when you need to validate all items in a list, accumulate errors, or selectively update elements?</p>
<p>Traditional traversal operations work well with clean, valid data. Real-world applications, however, require <strong>bulk validation</strong>, <strong>error accumulation</strong>, and <strong>partial updates</strong>. <strong>Traversal Extensions</strong> provide these capabilities whilst maintaining the elegance of functional composition.</p>
<p>Think of traversal extensions as <strong>quality control for production lines</strong>‚Äîthey can inspect all items, reject the batch at the first defect (fail-fast), collect all defects for review (error accumulation), or fix what's fixable and flag the rest (selective modification).</p>
<h2 id="the-problem-bulk-operations-without-error-handling"><a class="header" href="#the-problem-bulk-operations-without-error-handling">The Problem: Bulk Operations Without Error Handling</a></h2>
<p>Let's see the traditional approach to processing collections with validation:</p>
<div id="admonition--traditional-collection-processing" class="admonition admonish-failure" role="note" aria-labelledby="admonition--traditional-collection-processing-title">
<div class="admonition-title">
<div id="admonition--traditional-collection-processing-title">
<p>‚ùå Traditional Collection Processing</p>
</div>
<a class="admonition-anchor-link" href="optics/traversal_extensions.html#admonition--traditional-collection-processing"></a>
</div>
<div>
<pre><code class="language-java">public List&lt;OrderItem&gt; validateAndUpdatePrices(List&lt;OrderItem&gt; items) {
    List&lt;OrderItem&gt; result = new ArrayList&lt;&gt;();
    List&lt;String&gt; errors = new ArrayList&lt;&gt;();

    for (OrderItem item : items) {
        BigDecimal price = item.price();

        // Validation
        if (price.compareTo(BigDecimal.ZERO) &lt; 0) {
            errors.add("Invalid price for " + item.sku());
            // Now what? Skip this item? Throw exception? Continue?
        } else if (price.compareTo(new BigDecimal("10000")) &gt; 0) {
            errors.add("Price too high for " + item.sku());
        } else {
            // Apply discount
            BigDecimal discounted = price.multiply(new BigDecimal("0.9"));
            result.add(new OrderItem(
                item.sku(),
                item.name(),
                discounted,
                item.quantity(),
                item.status()
            ));
        }
    }

    if (!errors.isEmpty()) {
        // What do we do with the errors?
        // Throw exception and lose all progress?
        // Log them and continue with partial results?
    }

    return result;
}
</code></pre>
<p>Problems:</p>
<ul>
<li>Validation and transformation logic intertwined</li>
<li>Error handling strategy unclear</li>
<li>Manual loop with mutable state</li>
<li>Unclear what happens on partial failure</li>
<li>Imperative, hard to test</li>
</ul>
</div>
</div>
<div id="admonition--with-traversal-extensions" class="admonition admonish-success" role="note" aria-labelledby="admonition--with-traversal-extensions-title">
<div class="admonition-title">
<div id="admonition--with-traversal-extensions-title">
<p>‚úÖ With Traversal Extensions</p>
</div>
<a class="admonition-anchor-link" href="optics/traversal_extensions.html#admonition--with-traversal-extensions"></a>
</div>
<div>
<pre><code class="language-java">public Validated&lt;List&lt;String&gt;, List&lt;OrderItem&gt;&gt; validateAndUpdatePrices(
    List&lt;OrderItem&gt; items
) {
    Lens&lt;OrderItem, BigDecimal&gt; priceLens = OrderItemLenses.price();
    Traversal&lt;List&lt;OrderItem&gt;, BigDecimal&gt; allPrices =
        Traversals.&lt;OrderItem&gt;forList().andThen(priceLens.asTraversal());

    return modifyAllValidated(
        allPrices,
        price -&gt; validateAndDiscount(price),
        items
    );
}

private Validated&lt;String, BigDecimal&gt; validateAndDiscount(BigDecimal price) {
    if (price.compareTo(BigDecimal.ZERO) &lt; 0) {
        return Validated.invalid("Price cannot be negative");
    }
    if (price.compareTo(new BigDecimal("10000")) &gt; 0) {
        return Validated.invalid("Price exceeds maximum");
    }
    return Validated.valid(price.multiply(new BigDecimal("0.9")));
}
</code></pre>
<p>Clean separation: the traversal defines <strong>where</strong> (all prices), the validator defines <strong>what</strong> (validation rules), and <code>Validated</code> accumulates <strong>all</strong> errors or returns <strong>all</strong> results.</p>
</div>
</div>
<h2 id="available-traversal-extensions"><a class="header" href="#available-traversal-extensions">Available Traversal Extensions</a></h2>
<p>Higher-Kinded-J provides traversal extensions in the <code>TraversalExtensions</code> utility class. All methods are static, designed for import with <code>import static</code>:</p>
<pre><code class="language-java">import static org.higherkindedj.optics.extensions.TraversalExtensions.*;
</code></pre>
<div id="admonition--alternative-fluent-api" class="admonition admonish-note" role="note" aria-labelledby="admonition--alternative-fluent-api-title">
<div class="admonition-title">
<div id="admonition--alternative-fluent-api-title">
<p>üí° Alternative: Fluent API</p>
</div>
<a class="admonition-anchor-link" href="optics/traversal_extensions.html#admonition--alternative-fluent-api"></a>
</div>
<div>
<p>These extension methods are also available through the <a href="optics/fluent_api.html">Fluent API</a>, providing method chaining and better discoverability. For example, <code>modifyAllEither(traversal, f, source)</code> can also be written using <code>OpticOps</code> for a more fluent syntax.</p>
</div>
</div>
<h3 id="extraction-methods"><a class="header" href="#extraction-methods">Extraction Methods</a></h3>
<h4 id="getallmaybe--extract-all-values"><a class="header" href="#getallmaybe--extract-all-values"><code>getAllMaybe</code> ‚Äî Extract All Values</a></h4>
<pre><code class="language-java">public static &lt;S, A&gt; Maybe&lt;List&lt;A&gt;&gt; getAllMaybe(Traversal&lt;S, A&gt; traversal, S source)
</code></pre>
<p>Extract all focused values into a list. Returns <code>Maybe.just(values)</code> if any elements exist, <code>Maybe.nothing()</code> for empty collections.</p>
<pre><code class="language-java">List&lt;OrderItem&gt; items = List.of(
    new OrderItem("SKU001", "Laptop", new BigDecimal("999.99"), 1, "pending"),
    new OrderItem("SKU002", "Mouse", new BigDecimal("29.99"), 2, "pending")
);

Lens&lt;OrderItem, BigDecimal&gt; priceLens = OrderItemLenses.price();
Traversal&lt;List&lt;OrderItem&gt;, BigDecimal&gt; allPrices =
    Traversals.&lt;OrderItem&gt;forList().andThen(priceLens.asTraversal());

Maybe&lt;List&lt;BigDecimal&gt;&gt; prices = getAllMaybe(allPrices, items);
// Maybe.just([999.99, 29.99])

List&lt;OrderItem&gt; empty = List.of();
Maybe&lt;List&lt;BigDecimal&gt;&gt; noPrices = getAllMaybe(allPrices, empty);
// Maybe.nothing()

// Calculate total
BigDecimal total = prices
    .map(list -&gt; list.stream().reduce(BigDecimal.ZERO, BigDecimal::add))
    .orElse(BigDecimal.ZERO);
</code></pre>
<h3 id="bulk-modification-methods"><a class="header" href="#bulk-modification-methods">Bulk Modification Methods</a></h3>
<h4 id="modifyallmaybe--all-or-nothing-modifications"><a class="header" href="#modifyallmaybe--all-or-nothing-modifications"><code>modifyAllMaybe</code> ‚Äî All-or-Nothing Modifications</a></h4>
<pre><code class="language-java">public static &lt;S, A&gt; Maybe&lt;S&gt; modifyAllMaybe(
    Traversal&lt;S, A&gt; traversal,
    Function&lt;A, Maybe&lt;A&gt;&gt; modifier,
    S source)
</code></pre>
<p>Apply a modification to <strong>all</strong> elements. Returns <code>Maybe.just(updated)</code> if <strong>all</strong> modifications succeed, <code>Maybe.nothing()</code> if <strong>any</strong> fail. This is an <strong>atomic</strong> operation‚Äîeither everything updates or nothing does.</p>
<pre><code class="language-java">List&lt;OrderItem&gt; items = List.of(
    new OrderItem("SKU001", "Laptop", new BigDecimal("100.00"), 1, "pending"),
    new OrderItem("SKU002", "Mouse", new BigDecimal("20.00"), 2, "pending"),
    new OrderItem("SKU003", "Keyboard", new BigDecimal("50.00"), 1, "pending")
);

Lens&lt;OrderItem, BigDecimal&gt; priceLens = OrderItemLenses.price();
Traversal&lt;List&lt;OrderItem&gt;, BigDecimal&gt; allPrices =
    Traversals.&lt;OrderItem&gt;forList().andThen(priceLens.asTraversal());

// Successful: all prices ‚â• ¬£10
Maybe&lt;List&lt;OrderItem&gt;&gt; updated = modifyAllMaybe(
    allPrices,
    price -&gt; price.compareTo(new BigDecimal("10")) &gt;= 0
        ? Maybe.just(price.multiply(new BigDecimal("1.1")))  // 10% increase
        : Maybe.nothing(),
    items
);
// Maybe.just([updated items with 10% price increase])

// Failed: one price &lt; ¬£10
List&lt;OrderItem&gt; withLowPrice = List.of(
    new OrderItem("SKU001", "Laptop", new BigDecimal("100.00"), 1, "pending"),
    new OrderItem("SKU002", "Cheap Item", new BigDecimal("5.00"), 2, "pending")
);

Maybe&lt;List&lt;OrderItem&gt;&gt; failed = modifyAllMaybe(
    allPrices,
    price -&gt; price.compareTo(new BigDecimal("10")) &gt;= 0
        ? Maybe.just(price.multiply(new BigDecimal("1.1")))
        : Maybe.nothing(),
    withLowPrice
);
// Maybe.nothing() - entire update rolled back
</code></pre>
<div id="admonition--when-to-use-modifyallmaybe" class="admonition admonish-tip" role="note" aria-labelledby="admonition--when-to-use-modifyallmaybe-title">
<div class="admonition-title">
<div id="admonition--when-to-use-modifyallmaybe-title">
<p>üí° When to Use modifyAllMaybe</p>
</div>
<a class="admonition-anchor-link" href="optics/traversal_extensions.html#admonition--when-to-use-modifyallmaybe"></a>
</div>
<div>
<p>Use <code>modifyAllMaybe</code> for <strong>atomic updates</strong> where:</p>
<ul>
<li>All modifications must succeed or none should apply</li>
<li>Partial updates would leave data in an inconsistent state</li>
<li>You want "all-or-nothing" semantics</li>
</ul>
<p><strong>Example:</strong> Applying currency conversion to all prices‚Äîif the exchange rate service fails for one item, you don't want some prices converted and others not.</p>
</div>
</div>
<h4 id="modifyalleither--fail-fast-validation"><a class="header" href="#modifyalleither--fail-fast-validation"><code>modifyAllEither</code> ‚Äî Fail-Fast Validation</a></h4>
<pre><code class="language-java">public static &lt;S, A, E&gt; Either&lt;E, S&gt; modifyAllEither(
    Traversal&lt;S, A&gt; traversal,
    Function&lt;A, Either&lt;E, A&gt;&gt; modifier,
    S source)
</code></pre>
<p>Apply a modification with validation. Returns <code>Either.right(updated)</code> if <strong>all</strong> validations pass, <code>Either.left(firstError)</code> if <strong>any</strong> fail. <strong>Stops at the first error</strong> (fail-fast).</p>
<pre><code class="language-java">List&lt;OrderItem&gt; items = List.of(
    new OrderItem("SKU001", "Laptop", new BigDecimal("999.99"), 1, "pending"),
    new OrderItem("SKU002", "Mouse", new BigDecimal("-10.00"), 2, "pending"),  // Invalid!
    new OrderItem("SKU003", "Keyboard", new BigDecimal("79.99"), 1, "pending")
);

Lens&lt;OrderItem, BigDecimal&gt; priceLens = OrderItemLenses.price();
Traversal&lt;List&lt;OrderItem&gt;, BigDecimal&gt; allPrices =
    Traversals.&lt;OrderItem&gt;forList().andThen(priceLens.asTraversal());

// Fail-fast: stops at first invalid price
Either&lt;String, List&lt;OrderItem&gt;&gt; result = modifyAllEither(
    allPrices,
    price -&gt; {
        if (price.compareTo(BigDecimal.ZERO) &lt; 0) {
            return Either.left("Price cannot be negative");
        }
        if (price.compareTo(new BigDecimal("10000")) &gt; 0) {
            return Either.left("Price exceeds maximum");
        }
        return Either.right(price);
    },
    items
);
// Either.left("Price cannot be negative")
// Stopped at SKU002, didn't check SKU003

result.match(
    error -&gt; System.out.println("‚ùå Validation failed: " + error),
    updated -&gt; System.out.println("‚úÖ All items valid")
);
</code></pre>
<div id="admonition--when-to-use-modifyalleither" class="admonition admonish-tip" role="note" aria-labelledby="admonition--when-to-use-modifyalleither-title">
<div class="admonition-title">
<div id="admonition--when-to-use-modifyalleither-title">
<p>üí° When to Use modifyAllEither</p>
</div>
<a class="admonition-anchor-link" href="optics/traversal_extensions.html#admonition--when-to-use-modifyalleither"></a>
</div>
<div>
<p>Use <code>modifyAllEither</code> for <strong>fail-fast validation</strong> where:</p>
<ul>
<li>You want to stop immediately at the first error</li>
<li>Subsequent validations depend on earlier ones passing</li>
<li>You want efficient rejection of invalid data</li>
<li>The first error is sufficient feedback</li>
</ul>
<p><strong>Example:</strong> API request validation‚Äîreject the request immediately if any field is invalid.</p>
</div>
</div>
<h4 id="modifyallvalidated--error-accumulation"><a class="header" href="#modifyallvalidated--error-accumulation"><code>modifyAllValidated</code> ‚Äî Error Accumulation</a></h4>
<pre><code class="language-java">public static &lt;S, A, E&gt; Validated&lt;List&lt;E&gt;, S&gt; modifyAllValidated(
    Traversal&lt;S, A&gt; traversal,
    Function&lt;A, Validated&lt;E, A&gt;&gt; modifier,
    S source)
</code></pre>
<p>Apply a modification with validation. Returns <code>Validated.valid(updated)</code> if <strong>all</strong> validations pass, <code>Validated.invalid(allErrors)</code> if <strong>any</strong> fail. <strong>Collects all errors</strong> (error accumulation).</p>
<pre><code class="language-java">List&lt;OrderItem&gt; items = List.of(
    new OrderItem("SKU001", "Laptop", new BigDecimal("-100.00"), 1, "pending"),  // Error 1
    new OrderItem("SKU002", "Mouse", new BigDecimal("29.99"), -5, "pending"),
    new OrderItem("SKU003", "Keyboard", new BigDecimal("-50.00"), 1, "pending")  // Error 2
);

Lens&lt;OrderItem, BigDecimal&gt; priceLens = OrderItemLenses.price();
Traversal&lt;List&lt;OrderItem&gt;, BigDecimal&gt; allPrices =
    Traversals.&lt;OrderItem&gt;forList().andThen(priceLens.asTraversal());

// Accumulate ALL errors
Validated&lt;List&lt;String&gt;, List&lt;OrderItem&gt;&gt; result = modifyAllValidated(
    allPrices,
    price -&gt; {
        if (price.compareTo(BigDecimal.ZERO) &lt; 0) {
            return Validated.invalid("Price cannot be negative: " + price);
        }
        if (price.compareTo(new BigDecimal("10000")) &gt; 0) {
            return Validated.invalid("Price exceeds maximum: " + price);
        }
        return Validated.valid(price);
    },
    items
);
// Validated.invalid(["Price cannot be negative: -100.00", "Price cannot be negative: -50.00"])
// Checked ALL items and collected ALL errors

result.match(
    errors -&gt; {
        System.out.println("‚ùå Validation failed with " + errors.size() + " errors:");
        errors.forEach(err -&gt; System.out.println("   ‚Ä¢ " + err));
    },
    updated -&gt; System.out.println("‚úÖ All items valid")
);
</code></pre>
<div id="admonition--when-to-use-modifyallvalidated" class="admonition admonish-tip" role="note" aria-labelledby="admonition--when-to-use-modifyallvalidated-title">
<div class="admonition-title">
<div id="admonition--when-to-use-modifyallvalidated-title">
<p>üí° When to Use modifyAllValidated</p>
</div>
<a class="admonition-anchor-link" href="optics/traversal_extensions.html#admonition--when-to-use-modifyallvalidated"></a>
</div>
<div>
<p>Use <code>modifyAllValidated</code> for <strong>error accumulation</strong> where:</p>
<ul>
<li>You want to collect <strong>all</strong> errors, not just the first one</li>
<li>Better user experience (show all problems at once)</li>
<li>Form validation where users need to fix all fields</li>
<li>Batch processing where you want a complete error report</li>
</ul>
<p><strong>Example:</strong> User registration form‚Äîshow all validation errors (invalid email, weak password, missing fields) rather than one at a time.</p>
</div>
</div>
<div id="admonition-fail-fast-vs-error-accumulation-when-to-use-each" class="admonition admonish-example" role="note" aria-labelledby="admonition-fail-fast-vs-error-accumulation-when-to-use-each-title">
<div class="admonition-title">
<div id="admonition-fail-fast-vs-error-accumulation-when-to-use-each-title">
<p>Fail-Fast vs Error Accumulation: When to Use Each</p>
</div>
<a class="admonition-anchor-link" href="optics/traversal_extensions.html#admonition-fail-fast-vs-error-accumulation-when-to-use-each"></a>
</div>
<div>
<p><strong>Fail-Fast (<code>modifyAllEither</code>):</strong></p>
<pre><code class="language-java">// API request validation - reject immediately
Either&lt;String, List&lt;Item&gt;&gt; result = modifyAllEither(
    allPrices,
    price -&gt; validatePrice(price),
    items
);
return result.fold(
    error -&gt; ResponseEntity.badRequest().body(error),
    valid -&gt; ResponseEntity.ok(processOrder(valid))
);
</code></pre>
<p><strong>Error Accumulation (<code>modifyAllValidated</code>):</strong></p>
<pre><code class="language-java">// Form validation - show all errors
Validated&lt;List&lt;String&gt;, List&lt;Item&gt;&gt; result = modifyAllValidated(
    allPrices,
    price -&gt; validatePrice(price),
    items
);
return result.fold(
    errors -&gt; showFormErrors(errors),  // Display ALL errors to user
    valid -&gt; submitForm(valid)
);
</code></pre>
</div>
</div>
<h4 id="modifywherepossible--selective-modification"><a class="header" href="#modifywherepossible--selective-modification"><code>modifyWherePossible</code> ‚Äî Selective Modification</a></h4>
<pre><code class="language-java">public static &lt;S, A&gt; S modifyWherePossible(
    Traversal&lt;S, A&gt; traversal,
    Function&lt;A, Maybe&lt;A&gt;&gt; modifier,
    S source)
</code></pre>
<p>Apply a modification <strong>selectively</strong>. Modifies elements where the function returns <code>Maybe.just(value)</code>, leaves others unchanged. This is a <strong>best-effort</strong> operation‚Äîalways succeeds, modifying what it can.</p>
<pre><code class="language-java">List&lt;OrderItem&gt; items = List.of(
    new OrderItem("SKU001", "Laptop", new BigDecimal("999.99"), 1, "pending"),
    new OrderItem("SKU002", "Mouse", new BigDecimal("29.99"), 2, "shipped"),    // Don't modify
    new OrderItem("SKU003", "Keyboard", new BigDecimal("79.99"), 1, "pending")
);

Lens&lt;OrderItem, String&gt; statusLens = OrderItemLenses.status();
Traversal&lt;List&lt;OrderItem&gt;, String&gt; allStatuses =
    Traversals.&lt;OrderItem&gt;forList().andThen(statusLens.asTraversal());

// Update only "pending" items
List&lt;OrderItem&gt; updated = modifyWherePossible(
    allStatuses,
    status -&gt; status.equals("pending")
        ? Maybe.just("processing")
        : Maybe.nothing(),  // Leave non-pending unchanged
    items
);
// [
//   OrderItem(..., "processing"),  // SKU001 updated
//   OrderItem(..., "shipped"),     // SKU002 unchanged
//   OrderItem(..., "processing")   // SKU003 updated
// ]

System.out.println("Updated statuses:");
updated.forEach(item -&gt;
    System.out.println("  " + item.sku() + ": " + item.status())
);
</code></pre>
<div id="admonition-real-world-example-conditional-price-adjustment" class="admonition admonish-example" role="note" aria-labelledby="admonition-real-world-example-conditional-price-adjustment-title">
<div class="admonition-title">
<div id="admonition-real-world-example-conditional-price-adjustment-title">
<p>Real-World Example: Conditional Price Adjustment</p>
</div>
<a class="admonition-anchor-link" href="optics/traversal_extensions.html#admonition-real-world-example-conditional-price-adjustment"></a>
</div>
<div>
<pre><code class="language-java">// Apply 10% discount to items over ¬£100 (premium items only)
Lens&lt;OrderItem, BigDecimal&gt; priceLens = OrderItemLenses.price();
Traversal&lt;List&lt;OrderItem&gt;, BigDecimal&gt; allPrices =
    Traversals.&lt;OrderItem&gt;forList().andThen(priceLens.asTraversal());

List&lt;OrderItem&gt; discounted = modifyWherePossible(
    allPrices,
    price -&gt; price.compareTo(new BigDecimal("100")) &gt; 0
        ? Maybe.just(price.multiply(new BigDecimal("0.9")))
        : Maybe.nothing(),  // Leave cheaper items at full price
    items
);
</code></pre>
</div>
</div>
<div id="admonition--when-to-use-modifywherepossible" class="admonition admonish-tip" role="note" aria-labelledby="admonition--when-to-use-modifywherepossible-title">
<div class="admonition-title">
<div id="admonition--when-to-use-modifywherepossible-title">
<p>üí° When to Use modifyWherePossible</p>
</div>
<a class="admonition-anchor-link" href="optics/traversal_extensions.html#admonition--when-to-use-modifywherepossible"></a>
</div>
<div>
<p>Use <code>modifyWherePossible</code> for <strong>selective updates</strong> where:</p>
<ul>
<li>Only some elements should be modified based on a condition</li>
<li>Partial updates are acceptable and expected</li>
<li>You want to "fix what's fixable"</li>
<li>The operation should never fail</li>
</ul>
<p><strong>Example:</strong> Status transitions‚Äîupdate items in "pending" status to "processing", but leave "shipped" items unchanged.</p>
</div>
</div>
<h3 id="analysis-methods"><a class="header" href="#analysis-methods">Analysis Methods</a></h3>
<h4 id="countvalid--count-passing-validation"><a class="header" href="#countvalid--count-passing-validation"><code>countValid</code> ‚Äî Count Passing Validation</a></h4>
<pre><code class="language-java">public static &lt;S, A, E&gt; int countValid(
    Traversal&lt;S, A&gt; traversal,
    Function&lt;A, Either&lt;E, A&gt;&gt; validator,
    S source)
</code></pre>
<p>Count how many elements pass validation without modifying anything.</p>
<pre><code class="language-java">List&lt;OrderItem&gt; items = List.of(
    new OrderItem("SKU001", "Laptop", new BigDecimal("999.99"), 1, "pending"),
    new OrderItem("SKU002", "Mouse", new BigDecimal("-10.00"), 2, "pending"),   // Invalid
    new OrderItem("SKU003", "Keyboard", new BigDecimal("79.99"), 1, "pending"),
    new OrderItem("SKU004", "Monitor", new BigDecimal("-50.00"), 1, "pending")  // Invalid
);

Lens&lt;OrderItem, BigDecimal&gt; priceLens = OrderItemLenses.price();
Traversal&lt;List&lt;OrderItem&gt;, BigDecimal&gt; allPrices =
    Traversals.&lt;OrderItem&gt;forList().andThen(priceLens.asTraversal());

int validCount = countValid(
    allPrices,
    price -&gt; price.compareTo(BigDecimal.ZERO) &gt;= 0
        ? Either.right(price)
        : Either.left("Negative price"),
    items
);
// 2

System.out.println("Valid items: " + validCount + " out of " + items.size());
System.out.println("Invalid items: " + (items.size() - validCount));
</code></pre>
<div id="admonition--when-to-use-countvalid" class="admonition admonish-tip" role="note" aria-labelledby="admonition--when-to-use-countvalid-title">
<div class="admonition-title">
<div id="admonition--when-to-use-countvalid-title">
<p>üí° When to Use countValid</p>
</div>
<a class="admonition-anchor-link" href="optics/traversal_extensions.html#admonition--when-to-use-countvalid"></a>
</div>
<div>
<p>Use <code>countValid</code> for <strong>reporting and metrics</strong> where:</p>
<ul>
<li>You need to know how many items are valid without modifying them</li>
<li>Generating validation reports or dashboards</li>
<li>Pre-checking before bulk operations</li>
<li>Displaying progress to users</li>
</ul>
<p><strong>Example:</strong> Show user "3 out of 5 addresses are valid" before allowing checkout.</p>
</div>
</div>
<h4 id="collecterrors--gather-validation-failures"><a class="header" href="#collecterrors--gather-validation-failures"><code>collectErrors</code> ‚Äî Gather Validation Failures</a></h4>
<pre><code class="language-java">public static &lt;S, A, E&gt; List&lt;E&gt; collectErrors(
    Traversal&lt;S, A&gt; traversal,
    Function&lt;A, Either&lt;E, A&gt;&gt; validator,
    S source)
</code></pre>
<p>Collect all validation errors without modifying anything. Returns empty list if all valid.</p>
<pre><code class="language-java">List&lt;OrderItem&gt; items = List.of(
    new OrderItem("SKU001", "Laptop", new BigDecimal("999.99"), 1, "pending"),
    new OrderItem("SKU002", "Mouse", new BigDecimal("-10.00"), 2, "pending"),
    new OrderItem("SKU003", "Keyboard", new BigDecimal("79.99"), 1, "pending"),
    new OrderItem("SKU004", "Monitor", new BigDecimal("-50.00"), -1, "pending")
);

Lens&lt;OrderItem, BigDecimal&gt; priceLens = OrderItemLenses.price();
Traversal&lt;List&lt;OrderItem&gt;, BigDecimal&gt; allPrices =
    Traversals.&lt;OrderItem&gt;forList().andThen(priceLens.asTraversal());

List&lt;String&gt; errors = collectErrors(
    allPrices,
    price -&gt; price.compareTo(BigDecimal.ZERO) &gt;= 0
        ? Either.right(price)
        : Either.left("Negative price: " + price),
    items
);
// ["Negative price: -10.00", "Negative price: -50.00"]

if (errors.isEmpty()) {
    System.out.println("‚úÖ All prices valid");
} else {
    System.out.println("‚ùå Found " + errors.size() + " invalid prices:");
    errors.forEach(err -&gt; System.out.println("   ‚Ä¢ " + err));
}
</code></pre>
<div id="admonition--when-to-use-collecterrors" class="admonition admonish-tip" role="note" aria-labelledby="admonition--when-to-use-collecterrors-title">
<div class="admonition-title">
<div id="admonition--when-to-use-collecterrors-title">
<p>üí° When to Use collectErrors</p>
</div>
<a class="admonition-anchor-link" href="optics/traversal_extensions.html#admonition--when-to-use-collecterrors"></a>
</div>
<div>
<p>Use <code>collectErrors</code> for <strong>error reporting</strong> where:</p>
<ul>
<li>You want a list of all problems without modifying data</li>
<li>Generating validation reports</li>
<li>Pre-flight checks before expensive operations</li>
<li>Displaying errors to users</li>
</ul>
<p><strong>Example:</strong> Validate uploaded CSV file and show all errors before importing.</p>
</div>
</div>
<h2 id="complete-real-world-example"><a class="header" href="#complete-real-world-example">Complete Real-World Example</a></h2>
<p>Let's see a complete order validation pipeline combining multiple traversal extensions:</p>
<div id="admonition-e-commerce-order-validation-pipeline" class="admonition admonish-example" role="note" aria-labelledby="admonition-e-commerce-order-validation-pipeline-title">
<div class="admonition-title">
<div id="admonition-e-commerce-order-validation-pipeline-title">
<p>E-Commerce Order Validation Pipeline</p>
</div>
<a class="admonition-anchor-link" href="optics/traversal_extensions.html#admonition-e-commerce-order-validation-pipeline"></a>
</div>
<div>
<pre><code class="language-java">public sealed interface ValidationResult permits OrderApproved, OrderRejected {}
record OrderApproved(Order order) implements ValidationResult {}
record OrderRejected(List&lt;String&gt; errors) implements ValidationResult {}

public ValidationResult validateOrder(Order order) {
    Lens&lt;OrderItem, BigDecimal&gt; priceLens = OrderItemLenses.price();
    Lens&lt;OrderItem, Integer&gt; quantityLens = OrderItemLenses.quantity();

    Traversal&lt;List&lt;OrderItem&gt;, BigDecimal&gt; allPrices =
        Traversals.&lt;OrderItem&gt;forList().andThen(priceLens.asTraversal());
    Traversal&lt;List&lt;OrderItem&gt;, Integer&gt; allQuantities =
        Traversals.&lt;OrderItem&gt;forList().andThen(quantityLens.asTraversal());

    // Step 1: Validate all prices (accumulate errors)
    List&lt;String&gt; priceErrors = collectErrors(
        allPrices,
        price -&gt; validatePrice(price),
        order.items()
    );

    // Step 2: Validate all quantities (accumulate errors)
    List&lt;String&gt; quantityErrors = collectErrors(
        allQuantities,
        qty -&gt; validateQuantity(qty),
        order.items()
    );

    // Step 3: Combine all errors
    List&lt;String&gt; allErrors = Stream.of(priceErrors, quantityErrors)
        .flatMap(List::stream)
        .toList();

    if (!allErrors.isEmpty()) {
        return new OrderRejected(allErrors);
    }

    // Step 4: Apply discounts to valid items
    List&lt;OrderItem&gt; discounted = modifyWherePossible(
        allPrices,
        price -&gt; price.compareTo(new BigDecimal("100")) &gt; 0
            ? Maybe.just(price.multiply(new BigDecimal("0.9")))
            : Maybe.nothing(),
        order.items()
    );

    Order finalOrder = new Order(
        order.orderId(),
        discounted,
        order.customerEmail()
    );

    return new OrderApproved(finalOrder);
}

private Either&lt;String, BigDecimal&gt; validatePrice(BigDecimal price) {
    if (price.compareTo(BigDecimal.ZERO) &lt; 0) {
        return Either.left("Price cannot be negative");
    }
    if (price.compareTo(new BigDecimal("10000")) &gt; 0) {
        return Either.left("Price exceeds maximum");
    }
    return Either.right(price);
}

private Either&lt;String, Integer&gt; validateQuantity(Integer qty) {
    if (qty &lt;= 0) {
        return Either.left("Quantity must be positive");
    }
    if (qty &gt; 100) {
        return Either.left("Quantity exceeds maximum");
    }
    return Either.right(qty);
}

// Usage
ValidationResult result = validateOrder(order);
switch (result) {
    case OrderApproved approved -&gt; processOrder(approved.order());
    case OrderRejected rejected -&gt; displayErrors(rejected.errors());
}
</code></pre>
</div>
</div>
<h2 id="beforeafter-comparison-2"><a class="header" href="#beforeafter-comparison-2">Before/After Comparison</a></h2>
<p><strong>Scenario:</strong> Validating and updating prices for all items in a shopping cart.</p>
<div id="admonition--traditional-approach" class="admonition admonish-failure" role="note" aria-labelledby="admonition--traditional-approach-title">
<div class="admonition-title">
<div id="admonition--traditional-approach-title">
<p>‚ùå Traditional Approach</p>
</div>
<a class="admonition-anchor-link" href="optics/traversal_extensions.html#admonition--traditional-approach"></a>
</div>
<div>
<pre><code class="language-java">public class CartValidator {
    public ValidationResult validateCart(List&lt;CartItem&gt; items) {
        List&lt;String&gt; errors = new ArrayList&lt;&gt;();
        List&lt;CartItem&gt; validated = new ArrayList&lt;&gt;();
        boolean hasErrors = false;

        for (int i = 0; i &lt; items.size(); i++) {
            CartItem item = items.get(i);
            BigDecimal price = item.price();

            // Validate price
            if (price == null) {
                errors.add("Item " + i + ": Price is required");
                hasErrors = true;
                continue;
            }

            if (price.compareTo(BigDecimal.ZERO) &lt; 0) {
                errors.add("Item " + i + ": Price cannot be negative");
                hasErrors = true;
                continue;
            }

            if (price.compareTo(new BigDecimal("10000")) &gt; 0) {
                errors.add("Item " + i + ": Price too high");
                hasErrors = true;
                continue;
            }

            // Apply tax
            BigDecimal withTax = price.multiply(new BigDecimal("1.2"));
            CartItem updated = new CartItem(
                item.id(),
                item.name(),
                withTax,
                item.quantity()
            );
            validated.add(updated);
        }

        if (hasErrors) {
            return new ValidationFailure(errors);
        }
        return new ValidationSuccess(validated);
    }
}
</code></pre>
<p>Problems:</p>
<ul>
<li>Manual loop with index tracking</li>
<li>Mutable state (<code>errors</code>, <code>validated</code>, <code>hasErrors</code>)</li>
<li>Validation and transformation intertwined</li>
<li>Hard to test validation logic separately</li>
<li>Imperative, hard to reason about</li>
</ul>
</div>
</div>
<div id="admonition--with-traversal-extensions-1" class="admonition admonish-success" role="note" aria-labelledby="admonition--with-traversal-extensions-1-title">
<div class="admonition-title">
<div id="admonition--with-traversal-extensions-1-title">
<p>‚úÖ With Traversal Extensions</p>
</div>
<a class="admonition-anchor-link" href="optics/traversal_extensions.html#admonition--with-traversal-extensions-1"></a>
</div>
<div>
<pre><code class="language-java">public class CartValidator {
    public Validated&lt;List&lt;String&gt;, List&lt;CartItem&gt;&gt; validateCart(List&lt;CartItem&gt; items) {
        Lens&lt;CartItem, BigDecimal&gt; priceLens = CartItemLenses.price();
        Traversal&lt;List&lt;CartItem&gt;, BigDecimal&gt; allPrices =
            Traversals.&lt;CartItem&gt;forList().andThen(priceLens.asTraversal());

        return modifyAllValidated(
            allPrices,
            price -&gt; validateAndApplyTax(price),
            items
        );
    }

    private Validated&lt;String, BigDecimal&gt; validateAndApplyTax(BigDecimal price) {
        if (price == null) {
            return Validated.invalid("Price is required");
        }
        if (price.compareTo(BigDecimal.ZERO) &lt; 0) {
            return Validated.invalid("Price cannot be negative");
        }
        if (price.compareTo(new BigDecimal("10000")) &gt; 0) {
            return Validated.invalid("Price too high");
        }
        return Validated.valid(price.multiply(new BigDecimal("1.2")));
    }
}
</code></pre>
<p>Benefits:</p>
<ul>
<li>Declarative, functional style</li>
<li>No mutable state</li>
<li>Validation logic is pure and testable</li>
<li>Automatic error accumulation</li>
<li>Clear separation of concerns</li>
<li>Composable with other operations</li>
</ul>
</div>
</div>
<h2 id="best-practices-2"><a class="header" href="#best-practices-2">Best Practices</a></h2>
<div id="admonition--choose-the-right-strategy" class="admonition admonish-tip" role="note" aria-labelledby="admonition--choose-the-right-strategy-title">
<div class="admonition-title">
<div id="admonition--choose-the-right-strategy-title">
<p>üí° Choose the Right Strategy</p>
</div>
<a class="admonition-anchor-link" href="optics/traversal_extensions.html#admonition--choose-the-right-strategy"></a>
</div>
<div>
<p><strong>Use <code>modifyAllEither</code></strong> for fail-fast validation:</p>
<ul>
<li>API requests (reject immediately)</li>
<li>Critical validations (stop on first error)</li>
<li>When errors are independent</li>
</ul>
<p><strong>Use <code>modifyAllValidated</code></strong> for error accumulation:</p>
<ul>
<li>Form validation (show all errors)</li>
<li>Batch processing (complete error report)</li>
<li>Better user experience</li>
</ul>
<p><strong>Use <code>modifyWherePossible</code></strong> for selective updates:</p>
<ul>
<li>Conditional modifications</li>
<li>Best-effort operations</li>
<li>Status transitions</li>
</ul>
</div>
</div>
<div id="admonition--keep-validators-pure" class="admonition admonish-tip" role="note" aria-labelledby="admonition--keep-validators-pure-title">
<div class="admonition-title">
<div id="admonition--keep-validators-pure-title">
<p>üí° Keep Validators Pure</p>
</div>
<a class="admonition-anchor-link" href="optics/traversal_extensions.html#admonition--keep-validators-pure"></a>
</div>
<div>
<p>Your validation functions should be pure (no side effects):</p>
<pre><code class="language-java">// ‚úÖ Pure validator
private Validated&lt;String, BigDecimal&gt; validatePrice(BigDecimal price) {
    if (price.compareTo(BigDecimal.ZERO) &lt; 0) {
        return Validated.invalid("Price cannot be negative");
    }
    return Validated.valid(price);
}

// ‚ùå Impure validator (has side effects)
private Validated&lt;String, BigDecimal&gt; validatePrice(BigDecimal price) {
    logger.info("Validating price: {}", price);  // Side effect!
    database.recordValidation(price);            // Side effect!
    if (price.compareTo(BigDecimal.ZERO) &lt; 0) {
        return Validated.invalid("Price cannot be negative");
    }
    return Validated.valid(price);
}
</code></pre>
<p>Pure validators are easier to test, compose, and reason about.</p>
</div>
</div>
<div id="admonition--error-order-with-modifyallvalidated" class="admonition admonish-warning" role="note" aria-labelledby="admonition--error-order-with-modifyallvalidated-title">
<div class="admonition-title">
<div id="admonition--error-order-with-modifyallvalidated-title">
<p>‚ö†Ô∏è Error Order with modifyAllValidated</p>
</div>
<a class="admonition-anchor-link" href="optics/traversal_extensions.html#admonition--error-order-with-modifyallvalidated"></a>
</div>
<div>
<p>When using <code>modifyAllValidated</code>, errors are accumulated in the order elements are traversed:</p>
<pre><code class="language-java">List&lt;OrderItem&gt; items = List.of(item1, item2, item3);  // item1 and item3 have errors

Validated&lt;List&lt;String&gt;, List&lt;OrderItem&gt;&gt; result = modifyAllValidated(...);
// Errors will be: [error from item1, error from item3]
// Order is preserved
</code></pre>
<p>This is usually what you want, but be aware if error order matters for your use case.</p>
</div>
</div>
<div id="admonition--combine-with-analysis-methods" class="admonition admonish-tip" role="note" aria-labelledby="admonition--combine-with-analysis-methods-title">
<div class="admonition-title">
<div id="admonition--combine-with-analysis-methods-title">
<p>üí° Combine with Analysis Methods</p>
</div>
<a class="admonition-anchor-link" href="optics/traversal_extensions.html#admonition--combine-with-analysis-methods"></a>
</div>
<div>
<p>Use <code>countValid</code> and <code>collectErrors</code> for pre-flight checks:</p>
<pre><code class="language-java">// Check before expensive operation
List&lt;String&gt; errors = collectErrors(allPrices, this::validatePrice, items);

if (!errors.isEmpty()) {
    logger.warn("Validation would fail with {} errors", errors.size());
    return Either.left("Pre-flight check failed");
}

// Proceed with expensive operation
return modifyAllEither(allPrices, this::applyComplexTransformation, items);
</code></pre>
</div>
</div>
<h2 id="working-example-2"><a class="header" href="#working-example-2">Working Example</a></h2>
<p>For a complete, runnable demonstration of all traversal extension patterns, see:</p>
<div id="admonition-traversalextensionsexamplejava" class="admonition admonish-example" role="note" aria-labelledby="admonition-traversalextensionsexamplejava-title">
<div class="admonition-title">
<div id="admonition-traversalextensionsexamplejava-title">
<p>TraversalExtensionsExample.java</p>
</div>
<a class="admonition-anchor-link" href="optics/traversal_extensions.html#admonition-traversalextensionsexamplejava"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/TraversalExtensionsExample.java">View the complete example ‚Üí</a></p>
<p>This example demonstrates:</p>
<ul>
<li>All traversal extension methods</li>
<li>Fail-fast vs error accumulation strategies</li>
<li>Selective modification patterns</li>
<li>Counting and error collection</li>
<li>Complete order validation pipeline</li>
<li>Real-world e-commerce scenarios</li>
</ul>
</div>
</div>
<h2 id="summary-8"><a class="header" href="#summary-8">Summary</a></h2>
<p>Traversal extensions provide:</p>
<p>üó∫Ô∏è <strong>Bulk Operations</strong> ‚Äî Process entire collections with validation and error handling</p>
<p>üìä <strong>Error Strategies</strong> ‚Äî Choose fail-fast (<code>Either</code>) or error accumulation (<code>Validated</code>)</p>
<p>üéØ <strong>Selective Updates</strong> ‚Äî Modify only elements that meet criteria</p>
<p>üìà <strong>Analysis Tools</strong> ‚Äî Count valid items and collect errors without modification</p>
<p>üîÑ <strong>Composability</strong> ‚Äî Chain with lenses and other optics for complex workflows</p>
<p>üß™ <strong>Testability</strong> ‚Äî Pure validation functions are easy to test in isolation</p>
<h2 id="next-steps-3"><a class="header" href="#next-steps-3">Next Steps</a></h2>
<p>You've now learned all three core type integration approaches! Return to the overview to see how they work together:</p>
<p><strong>Back:</strong> <a href="optics/core_type_integration.html">Working with Core Types and Optics</a></p>
<p>Or explore complete integration patterns:</p>
<p><strong>See Also:</strong> <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/IntegrationPatternsExample.java">Integration Patterns Example</a> ‚Äî Complete e-commerce workflow combining all approaches</p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="a-blog-on-types-and-functional-patterns"><a class="header" href="#a-blog-on-types-and-functional-patterns">A Blog on Types and Functional Patterns</a></h1>
<p>This blog series provides excellent background reading whilst you're learning the techniques used in Higher-Kinded-J. Each post builds foundational knowledge that will deepen your understanding of functional programming patterns in Java.</p>
<p>This web series explores the foundational ideas that inspired Higher-Kinded-J's development.</p>
<ul>
<li><a href="https://blog.scottlogic.com/2025/01/20/algebraic-data-types-with-java.html">Algebraic Data Types and Pattern Matching with Java</a></li>
</ul>
<p>In this post, we explore the power of Algebraic Data Types (ADT) with Pattern Matching in Java. We look at how they help us model complex business domains and how using them together gives improvements on the traditional Visitor Pattern.</p>
<ul>
<li><a href="http://blog.scottlogic.com/2025/02/17/variance-in-java-and-scala.html">Variance in Generics, Phantom and Existential types with Java and Scala</a></li>
</ul>
<p>In this post, we look at Variance in Generics and how it is handled in Java and Scala. We consider use-site and declaration-site approaches and the trade-offs of erasure. Finally, we take a look at Phantom and Existential types and how they can enhance the capabilities of the type system when it comes to modelling.</p>
<ul>
<li><a href="https://blog.scottlogic.com/2025/03/05/intersection-and-union-types-with-java-and-scala.html">Intersection and Union types with Java and Scala</a></li>
</ul>
<p>In this post, we will see how Intersection types help us better model type constraints, promoting reuse, and how Union types increase code flexibility. We will compare and contrast approaches and how to use them in the latest Java and Scala.</p>
<ul>
<li><a href="https://blog.scottlogic.com/2025/03/31/functors-monads-with-java-and-scala.html">Functors and Monads with Java and Scala</a></li>
</ul>
<p>Learn about how Functors and Monads provide patterns to write cleaner, more composable, and robust code that helps us deal with operations like handling nulls, managing errors and sequencing asynchronous actions.</p>
<ul>
<li><a href="https://blog.scottlogic.com/2025/04/11/higher-kinded-types-with-java-and-scala.html">Higher Kinded Types with Java and Scala</a></li>
</ul>
<p>In this post, we will see how Higher Kinded Types can help increase the flexibility of our code and reduce duplication.</p>
<ul>
<li><a href="https://blog.scottlogic.com/2025/05/02/recursion-thunks-trampolines-with-java-and-scala.html">Recursion, Thunks and Trampolines with Java and Scala</a></li>
</ul>
<p>In this post, we will see how Thunks and Trampolines can help solve problems by converting deep stack-based recursion into heap-based iteration, helping to prevent StackOverflowErrors.</p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="glossary-of-functional-programming-terms"><a class="header" href="#glossary-of-functional-programming-terms">Glossary of Functional Programming Terms</a></h1>
<div id="admonition-what-this-section-covers" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-this-section-covers-title">
<div class="admonition-title">
<div id="admonition-what-this-section-covers-title">
<p>What This Section Covers</p>
</div>
<a class="admonition-anchor-link" href="glossary.html#admonition-what-this-section-covers"></a>
</div>
<div>
<ul>
<li>Key terminology used throughout Higher-Kinded-J documentation</li>
<li>Explanations tailored for mid-level Java developers</li>
<li>Practical examples to reinforce understanding</li>
<li>Quick reference for concepts you encounter whilst coding</li>
</ul>
</div>
</div>
<p>This glossary provides clear, practical explanations of functional programming and Higher-Kinded-J concepts. Each term includes Java-friendly explanations and examples where helpful.</p>
<hr />
<h2 id="type-system-concepts"><a class="header" href="#type-system-concepts">Type System Concepts</a></h2>
<h3 id="contravariant"><a class="header" href="#contravariant">Contravariant</a></h3>
<p><strong>Definition:</strong> A type parameter is contravariant when it appears in an "input" or "consumer" position. If <code>A</code> is a subtype of <code>B</code>, then <code>F&lt;B&gt;</code> can be treated as a subtype of <code>F&lt;A&gt;</code> when accepting values (note the direction reversal!).</p>
<p><strong>Java Analogy:</strong> Think of <code>? super T</code> in Java generics‚Äîthis is contravariant. Also, function parameters are contravariant.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Contravariant behaviour in Java (function parameters)
// A function accepting Object can be used where one accepting String is expected
Comparator&lt;Object&gt; objectComparator = (a, b) -&gt; a.toString().compareTo(b.toString());
Comparator&lt;String&gt; stringComparator = objectComparator; // ‚úÖ Valid - contravariance in action

// Note: Java's Consumer&lt;T&gt; is invariant, so Consumer&lt;Object&gt; ‚â† Consumer&lt;String&gt;
// But function *parameters* are naturally contravariant

// In Higher-Kinded-J: Profunctor's first parameter is contravariant
Profunctor&lt;FunctionKind.Witness&gt; prof = FunctionProfunctor.INSTANCE;

Function&lt;String, Integer&gt; stringLength = String::length;
// lmap is contravariant - we pre-process the INPUT
Kind2&lt;FunctionKind.Witness, Integer, Integer&gt; intLength =
    prof.lmap(Object::toString, FUNCTION.widen(stringLength));
// Now accepts Integer input by converting it to String first
</code></pre>
<p><strong>Think Of It As:</strong> "Values flow INTO the container" - you're consuming/accepting data.</p>
<p><strong>Important:</strong> The direction is reversed! A function that accepts <code>Object</code> is more flexible than one that accepts only <code>String</code>, so <code>Function&lt;Object, R&gt;</code> is a "subtype" of <code>Function&lt;String, R&gt;</code> in terms of what it can handle.</p>
<p><strong>Where You'll See It:</strong></p>
<ul>
<li>The first parameter of Profunctor (input side)</li>
<li>Function parameters</li>
<li>Consumer types</li>
</ul>
<hr />
<h3 id="covariant"><a class="header" href="#covariant">Covariant</a></h3>
<p><strong>Definition:</strong> A type parameter is covariant when it appears in an "output" or "producer" position. If <code>A</code> is a subtype of <code>B</code>, then <code>F&lt;A&gt;</code> can be treated as a subtype of <code>F&lt;B&gt;</code> when reading values.</p>
<p><strong>Java Analogy:</strong> Think of <code>? extends T</code> in Java generics‚Äîthis is covariant.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Covariant behaviour in Java collections (read-only)
List&lt;? extends Number&gt; numbers = new ArrayList&lt;Integer&gt;();
Number n = numbers.get(0); // ‚úÖ Safe to read out as Number

// In Higher-Kinded-J: Functor is covariant in its type parameter
Functor&lt;ListKind.Witness&gt; functor = ListFunctor.INSTANCE;
Kind&lt;ListKind.Witness, Integer&gt; ints = LIST.widen(List.of(1, 2, 3));
Kind&lt;ListKind.Witness, String&gt; strings = functor.map(Object::toString, ints);
// Integer -&gt; String transformation (output direction)
</code></pre>
<p><strong>Think Of It As:</strong> "Values flow OUT of the container" - you're producing/reading data.</p>
<p><strong>Where You'll See It:</strong></p>
<ul>
<li>Functor's type parameter (transforms outputs)</li>
<li>Bifunctor's both parameters (both are outputs)</li>
<li>The second parameter of Profunctor (output side)</li>
<li>Return types of functions</li>
</ul>
<hr />
<h3 id="invariant"><a class="header" href="#invariant">Invariant</a></h3>
<p><strong>Definition:</strong> A type parameter is invariant when it appears in both input and output positions, or when the type doesn't allow any subtype substitution.</p>
<p><strong>Java Analogy:</strong> Most mutable collections in Java are invariant‚Äî<code>List&lt;Integer&gt;</code> is not a subtype of <code>List&lt;Number&gt;</code>.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Invariant behaviour in Java
List&lt;Integer&gt; ints = new ArrayList&lt;&gt;();
List&lt;Number&gt; nums = ints; // ‚ùå Compilation error!
// Not allowed because:
// - You could read Number (covariant)
// - You could write Number (contravariant)
// Both directions would violate type safety with mutable collections

// In Higher-Kinded-J: MonadError's error type is typically invariant
MonadError&lt;EitherKind.Witness&lt;String&gt;, String&gt; monadError = EitherMonadError.instance();
// The String error type is fixed‚Äîyou can't substitute it with Object or CharSequence
</code></pre>
<p><strong>Think Of It As:</strong> "Locked to exactly this type" - no flexibility in either direction.</p>
<p><strong>Where You'll See It:</strong></p>
<ul>
<li>Mutable collections</li>
<li>Types used in both input and output positions</li>
<li>Type parameters that don't participate in transformation operations</li>
</ul>
<hr />
<h3 id="variance-summary-table"><a class="header" href="#variance-summary-table">Variance Summary Table</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Variance</th><th>Direction</th><th>Java Analogy</th><th>Example Type Class</th><th>Intuition</th></tr></thead><tbody>
<tr><td><strong>Covariant</strong></td><td>Output/Producer</td><td><code>? extends T</code></td><td>Functor, Applicative, Monad</td><td>"Reading out"</td></tr>
<tr><td><strong>Contravariant</strong></td><td>Input/Consumer</td><td><code>? super T</code></td><td>Profunctor (first param)</td><td>"Writing in" (reversed)</td></tr>
<tr><td><strong>Invariant</strong></td><td>Neither/Both</td><td>No wildcards</td><td>Monad error type</td><td>"Exact match required"</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="higher-kinded-type-simulation"><a class="header" href="#higher-kinded-type-simulation">Higher-Kinded Type Simulation</a></h2>
<h3 id="defunctionalisation"><a class="header" href="#defunctionalisation">Defunctionalisation</a></h3>
<p><strong>Definition:</strong> A technique for simulating higher-kinded types in languages that don't natively support them. Instead of passing type constructors as parameters, we represent them with marker types (witnesses) and use these as ordinary type parameters.</p>
<p><strong>The Problem It Solves:</strong> Java's type system cannot parametrise over type constructors. You cannot write <code>&lt;F&lt;_&gt;&gt;</code> in Java to mean "any container type F". Defunctionalisation works around this by using witness types to represent type constructors.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// ‚ùå What we'd like to write but can't in Java:
public &lt;F&lt;_&gt;, A, B&gt; F&lt;B&gt; map(Function&lt;A, B&gt; f, F&lt;A&gt; fa) { ... }

// ‚úÖ What we write using defunctionalisation:
public &lt;F, A, B&gt; Kind&lt;F, B&gt; map(Function&lt;A, B&gt; f, Kind&lt;F, A&gt; fa) { ... }
// Where F is a witness type like OptionalKind.Witness or ListKind.Witness
</code></pre>
<p><strong>How It Works:</strong></p>
<ol>
<li>Define a marker interface (witness type) for each type constructor (e.g., <code>ListKind.Witness</code> for <code>List</code>)</li>
<li>Use <code>Kind&lt;F, A&gt;</code> where <code>F</code> is the witness and <code>A</code> is the type parameter</li>
<li>Provide helper methods to convert between concrete types and their <code>Kind</code> representations</li>
</ol>
<p><strong>Where You'll See It:</strong> Throughout the Higher-Kinded-J library - it's the foundation of the entire HKT simulation.</p>
<p><strong>Related:</strong> <a href="hkts/core-concepts.html">Core Concepts</a></p>
<hr />
<h3 id="higher-kinded-type-hkt"><a class="header" href="#higher-kinded-type-hkt">Higher-Kinded Type (HKT)</a></h3>
<p><strong>Definition:</strong> A type that abstracts over type constructors. In languages with HKT support, you can write generic code that works with any "container" type like <code>List</code>, <code>Optional</code>, or <code>CompletableFuture</code> without knowing which one at compile time.</p>
<p><strong>Java Analogy:</strong> Regular generics let you abstract over types (<code>&lt;T&gt;</code>). Higher-kinded types let you abstract over type constructors (<code>&lt;F&lt;_&gt;&gt;</code>).</p>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Regular generics (abstracting over types):
public &lt;T&gt; T identity(T value) { return value; }

// Higher-kinded types (abstracting over type constructors):
public &lt;F&gt; Kind&lt;F, Integer&gt; increment(Functor&lt;F&gt; functor, Kind&lt;F, Integer&gt; fa) {
    return functor.map(x -&gt; x + 1, fa);
}

// Works with any Functor:
increment(OptionalFunctor.INSTANCE, OPTIONAL.widen(Optional.of(5)));  // Optional[6]
increment(ListFunctor.INSTANCE, LIST.widen(List.of(1, 2, 3)));        // [2, 3, 4]
</code></pre>
<p><strong>Why It Matters:</strong> Enables writing truly generic, reusable functional code that works across different container types.</p>
<p><strong>Related:</strong> <a href="hkts/hkt_introduction.html">HKT Introduction</a></p>
<hr />
<h3 id="kind"><a class="header" href="#kind">Kind</a></h3>
<p><strong>Definition:</strong> The core interface in Higher-Kinded-J that simulates higher-kinded types. <code>Kind&lt;F, A&gt;</code> represents a type constructor <code>F</code> applied to a type <code>A</code>.</p>
<p><strong>Structure:</strong></p>
<ul>
<li><code>Kind&lt;F, A&gt;</code> - Single type parameter (e.g., <code>List&lt;A&gt;</code>, <code>Optional&lt;A&gt;</code>)</li>
<li><code>Kind2&lt;F, A, B&gt;</code> - Two type parameters (e.g., <code>Either&lt;A, B&gt;</code>, <code>Function&lt;A, B&gt;</code>)</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Standard Java types and their Kind representations:
Optional&lt;String&gt;           ‚âà Kind&lt;OptionalKind.Witness, String&gt;
List&lt;Integer&gt;              ‚âà Kind&lt;ListKind.Witness, Integer&gt;
Either&lt;String, Integer&gt;    ‚âà Kind2&lt;EitherKind2.Witness, String, Integer&gt;
Function&lt;String, Integer&gt;  ‚âà Kind2&lt;FunctionKind.Witness, String, Integer&gt;

// Converting between representations:
Optional&lt;String&gt; opt = Optional.of("hello");
Kind&lt;OptionalKind.Witness, String&gt; kindOpt = OPTIONAL.widen(opt);
Optional&lt;String&gt; backToOpt = OPTIONAL.narrow(kindOpt);
</code></pre>
<p><strong>Think Of It As:</strong> A wrapper that allows Java's type system to work with type constructors generically.</p>
<p><strong>Note on Either:</strong> Either has two witness types depending on usage:</p>
<ul>
<li><code>EitherKind.Witness&lt;L&gt;</code> for <code>Kind&lt;EitherKind.Witness&lt;L&gt;, R&gt;</code> - used with Functor/Monad (right-biased)</li>
<li><code>EitherKind2.Witness</code> for <code>Kind2&lt;EitherKind2.Witness, L, R&gt;</code> - used with Bifunctor (both sides)</li>
</ul>
<p><strong>Related:</strong> <a href="hkts/core-concepts.html">Core Concepts</a></p>
<hr />
<h3 id="type-constructor"><a class="header" href="#type-constructor">Type Constructor</a></h3>
<p><strong>Definition:</strong> A type that takes one or more type parameters to produce a concrete type. In other words, it's a "type function" that constructs types.</p>
<p><strong>Examples:</strong></p>
<pre><code class="language-java">// List is a type constructor
List      // Not a complete type (needs a parameter)
List&lt;T&gt;   // Type constructor applied to parameter T
List&lt;String&gt;  // Concrete type

// Either is a type constructor with two parameters
Either           // Not a complete type
Either&lt;L, R&gt;     // Type constructor applied to parameters L and R
Either&lt;String, Integer&gt;  // Concrete type

// Optional is a type constructor
Optional         // Not a complete type
Optional&lt;T&gt;      // Type constructor applied to parameter T
Optional&lt;String&gt; // Concrete type
</code></pre>
<p><strong>Notation:</strong> Often written with an underscore to show the "hole": <code>List&lt;_&gt;</code>, <code>Either&lt;String, _&gt;</code>, <code>Optional&lt;_&gt;</code></p>
<p><strong>Why It Matters:</strong> Type constructors are what we abstract over with higher-kinded types. Understanding them is key to understanding HKTs.</p>
<hr />
<h3 id="witness-type"><a class="header" href="#witness-type">Witness Type</a></h3>
<p><strong>Definition:</strong> A marker type used to represent a type constructor in the defunctionalisation pattern. Each type constructor has a corresponding witness type.</p>
<p><strong>Examples:</strong></p>
<pre><code class="language-java">// List type constructor ‚Üí ListKind.Witness
public interface ListKind&lt;A&gt; extends Kind&lt;ListKind.Witness, A&gt; {
    final class Witness { private Witness() {} }
}

// Optional type constructor ‚Üí OptionalKind.Witness
public interface OptionalKind&lt;A&gt; extends Kind&lt;OptionalKind.Witness, A&gt; {
    final class Witness { private Witness() {} }
}

// Either type constructor ‚Üí EitherKind.Witness&lt;L&gt;
public interface EitherKind&lt;L, R&gt; extends Kind2&lt;EitherKind.Witness&lt;L&gt;, L, R&gt; {
    final class Witness&lt;L&gt; { private Witness() {} }
}
</code></pre>
<p><strong>Usage:</strong></p>
<pre><code class="language-java">// The Witness type is used as the F parameter:
Functor&lt;ListKind.Witness&gt; listFunctor = ListFunctor.INSTANCE;
Functor&lt;OptionalKind.Witness&gt; optionalFunctor = OptionalFunctor.INSTANCE;
MonadError&lt;EitherKind.Witness&lt;String&gt;, String&gt; eitherMonad = EitherMonadError.instance();
</code></pre>
<p><strong>Think Of It As:</strong> A compile-time tag that identifies which type constructor we're working with.</p>
<p><strong>Related:</strong> <a href="hkts/core-concepts.html">Core Concepts</a></p>
<hr />
<h3 id="phantom-type"><a class="header" href="#phantom-type">Phantom Type</a></h3>
<p><strong>Definition:</strong> A type parameter that appears in a type signature but has no corresponding runtime representation‚Äîit exists purely for compile-time type safety and doesn't store any actual data of that type.</p>
<p><strong>Key Characteristics:</strong></p>
<ul>
<li>Present in the type signature for type-level information</li>
<li>Never instantiated or stored at runtime</li>
<li>Used for type-safe APIs without runtime overhead</li>
<li>Enables compile-time guarantees whilst maintaining efficiency</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Const&lt;C, A&gt; uses A as a phantom type
Const&lt;String, Integer&gt; stringConst = new Const&lt;&gt;("hello");
// The Integer type parameter is phantom - no Integer is stored!

String value = stringConst.value(); // "hello"

// Mapping over the phantom type changes the signature but not the value
Const&lt;String, Double&gt; doubleConst = stringConst.mapSecond(i -&gt; i * 2.0);
System.out.println(doubleConst.value()); // Still "hello" (unchanged!)
</code></pre>
<p><strong>Common Use Cases:</strong></p>
<ul>
<li><strong>State tracking at compile time</strong>: Phantom types in state machines (e.g., <code>DatabaseConnection&lt;Closed&gt;</code> vs <code>DatabaseConnection&lt;Open&gt;</code>)</li>
<li><strong>Units of measure</strong>: Tracking units without runtime overhead (e.g., <code>Measurement&lt;Metres&gt;</code> vs <code>Measurement&lt;Feet&gt;</code>)</li>
<li><strong>Const type</strong>: The second type parameter in <code>Const&lt;C, A&gt;</code> is phantom, enabling fold and getter patterns</li>
<li><strong>Type-safe builders</strong>: Ensuring build steps are called in the correct order</li>
</ul>
<p><strong>Real-World Example:</strong></p>
<pre><code class="language-java">// State machine with phantom types
class FileHandle&lt;State&gt; {
    private File file;

    // Only available when Closed
    FileHandle&lt;Open&gt; open() { ... }
}

class Open {}
class Closed {}

// Type-safe at compile time:
FileHandle&lt;Closed&gt; closed = new FileHandle&lt;&gt;();
FileHandle&lt;Open&gt; opened = closed.open();  // ‚úÖ Allowed
// opened.open();  // ‚ùå Compile error - already open!
</code></pre>
<p><strong>Benefits:</strong></p>
<ul>
<li>Zero runtime cost - no additional memory or processing</li>
<li>Compile-time safety - prevents incorrect API usage</li>
<li>Self-documenting APIs - type signature conveys intent</li>
<li>Enables advanced patterns like GADTs (Generalised Algebraic Data Types)</li>
</ul>
<p><strong>Where You'll See It:</strong></p>
<ul>
<li><code>Const&lt;C, A&gt;</code> - the <code>A</code> parameter is phantom</li>
<li>Witness types in HKT encoding (though serving a different purpose)</li>
<li>State machines and protocol enforcement</li>
<li>Type-level programming patterns</li>
</ul>
<p><strong>Related:</strong> <a href="monads/const_type.html">Const Type Documentation</a>, <a href="glossary.html#witness-type">Witness Type</a></p>
<hr />
<h2 id="functional-type-classes"><a class="header" href="#functional-type-classes">Functional Type Classes</a></h2>
<h3 id="applicative-1"><a class="header" href="#applicative-1">Applicative</a></h3>
<p><strong>Definition:</strong> A type class that extends Functor with the ability to lift pure values into a context and combine multiple independent computations.</p>
<p><strong>Core Operations:</strong></p>
<ul>
<li><code>of(A value)</code> - Lift a pure value into the context</li>
<li><code>ap(Kind&lt;F, Function&lt;A,B&gt;&gt; ff, Kind&lt;F, A&gt; fa)</code> - Apply a wrapped function to a wrapped value</li>
<li><code>map2</code>, <code>map3</code>, etc. - Combine multiple wrapped values</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">Applicative&lt;OptionalKind.Witness&gt; app = OptionalApplicative.INSTANCE;

// Lift pure values
Kind&lt;OptionalKind.Witness, Integer&gt; five = app.of(5);  // Optional[5]

// Combine independent values
Kind&lt;OptionalKind.Witness, String&gt; result = app.map2(
    app.of("Hello"),
    app.of("World"),
    (a, b) -&gt; a + " " + b
);  // Optional["Hello World"]
</code></pre>
<p><strong>When To Use:</strong> Combining multiple independent effects (form validation, parallel computations, configuration assembly).</p>
<p><strong>Related:</strong> <a href="functional/applicative.html">Applicative Documentation</a></p>
<hr />
<h3 id="bifunctor"><a class="header" href="#bifunctor">Bifunctor</a></h3>
<p><strong>Definition:</strong> A type class for types with two covariant parameters, allowing transformation of both sides independently or simultaneously.</p>
<p><strong>Core Operations:</strong></p>
<ul>
<li><code>bimap(Function&lt;A,C&gt; f, Function&lt;B,D&gt; g, Kind2&lt;F,A,B&gt; fab)</code> - Transform both parameters</li>
<li><code>first(Function&lt;A,C&gt; f, Kind2&lt;F,A,B&gt; fab)</code> - Transform only the first parameter</li>
<li><code>second(Function&lt;B,D&gt; g, Kind2&lt;F,A,B&gt; fab)</code> - Transform only the second parameter</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">Bifunctor&lt;EitherKind.Witness&gt; bifunctor = EitherBifunctor.INSTANCE;

Either&lt;String, Integer&gt; either = Either.right(42);
Kind2&lt;EitherKind.Witness, String, Integer&gt; kindEither = EITHER.widen(either);

// Transform both sides
Kind2&lt;EitherKind.Witness, Integer, String&gt; transformed =
    bifunctor.bimap(String::length, Object::toString, kindEither);
// Right("42")
</code></pre>
<p><strong>When To Use:</strong> Transforming error and success channels, working with pairs/tuples, API format conversion.</p>
<p><strong>Related:</strong> <a href="functional/bifunctor.html">Bifunctor Documentation</a></p>
<hr />
<h3 id="functor-1"><a class="header" href="#functor-1">Functor</a></h3>
<p><strong>Definition:</strong> The most basic type class for types that can be "mapped over". Allows transforming values inside a context without changing the context structure.</p>
<p><strong>Core Operation:</strong></p>
<ul>
<li><code>map(Function&lt;A,B&gt; f, Kind&lt;F,A&gt; fa)</code> - Apply a function to the wrapped value</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">Functor&lt;ListKind.Witness&gt; functor = ListFunctor.INSTANCE;

Kind&lt;ListKind.Witness, String&gt; strings = LIST.widen(List.of("one", "two"));
Kind&lt;ListKind.Witness, Integer&gt; lengths = functor.map(String::length, strings);
// [3, 3]
</code></pre>
<p><strong>Laws:</strong></p>
<ul>
<li>Identity: <code>map(x -&gt; x, fa) == fa</code></li>
<li>Composition: <code>map(g.compose(f), fa) == map(g, map(f, fa))</code></li>
</ul>
<p><strong>When To Use:</strong> Simple transformations where the context (container structure) stays the same.</p>
<p><strong>Related:</strong> <a href="functional/functor.html">Functor Documentation</a></p>
<hr />
<h3 id="monad-1"><a class="header" href="#monad-1">Monad</a></h3>
<p><strong>Definition:</strong> A type class that extends Applicative with the ability to chain dependent computations (flatMap/bind).</p>
<p><strong>Core Operation:</strong></p>
<ul>
<li><code>flatMap(Function&lt;A, Kind&lt;F,B&gt;&gt; f, Kind&lt;F,A&gt; ma)</code> - Chain computations where each depends on the previous result</li>
</ul>
<p><strong>Additional Operations:</strong></p>
<ul>
<li><code>flatMap2/3/4/5(...)</code> - Combine multiple monadic values with a function that returns a monadic value (similar to <code>map2/3/4/5</code> but with effectful combining function)</li>
<li><code>as(B value, Kind&lt;F,A&gt; ma)</code> - Replace the result while preserving the effect</li>
<li><code>peek(Consumer&lt;A&gt; action, Kind&lt;F,A&gt; ma)</code> - Perform side effect without changing the value</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">Monad&lt;OptionalKind.Witness&gt; monad = OptionalMonad.INSTANCE;

// Chain dependent operations
Kind&lt;OptionalKind.Witness, String&gt; result =
    monad.flatMap(
        userId -&gt; monad.flatMap(
            profile -&gt; findAccount(profile.accountId()),
            findProfile(userId)
        ),
        findUser("user123")
    );

// Combine multiple monadic values with effectful result
Kind&lt;OptionalKind.Witness, Order&gt; order =
    monad.flatMap2(
        findUser("user123"),
        findProduct("prod456"),
        (user, product) -&gt; validateAndCreateOrder(user, product)
    );
</code></pre>
<p><strong>Laws:</strong></p>
<ul>
<li>Left Identity: <code>flatMap(f, of(a)) == f(a)</code></li>
<li>Right Identity: <code>flatMap(of, m) == m</code></li>
<li>Associativity: <code>flatMap(g, flatMap(f, m)) == flatMap(x -&gt; flatMap(g, f(x)), m)</code></li>
</ul>
<p><strong>When To Use:</strong> Sequential operations where each step depends on the previous result (database queries, async workflows, error handling pipelines).</p>
<p><strong>Related:</strong> <a href="functional/monad.html">Monad Documentation</a></p>
<hr />
<h3 id="monoid-1"><a class="header" href="#monoid-1">Monoid</a></h3>
<p><strong>Definition:</strong> A type class for types that have an associative binary operation (<code>combine</code>) and an identity element (<code>empty</code>). Extends Semigroup by adding the identity element, making it safe for reducing empty collections.</p>
<p><strong>Core Operations:</strong></p>
<ul>
<li><code>empty()</code> - The identity element</li>
<li><code>combine(A a1, A a2)</code> - Associative binary operation (from Semigroup)</li>
<li><code>combineAll(Iterable&lt;A&gt; elements)</code> - Combine all elements in a collection</li>
<li><code>combineN(A value, int n)</code> - Combine a value with itself n times</li>
<li><code>isEmpty(A value)</code> - Test if a value equals the empty element</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">Monoid&lt;Integer&gt; intAddition = Monoids.integerAddition();

// Identity law: empty is the neutral element
intAddition.combine(5, intAddition.empty());  // 5
intAddition.combine(intAddition.empty(), 5);  // 5

// Combine a collection
List&lt;Integer&gt; numbers = List.of(1, 2, 3, 4, 5);
Integer sum = intAddition.combineAll(numbers);  // 15

// Repeated application
Integer result = intAddition.combineN(3, 4);  // 12 (3+3+3+3)

// Working with Optional values
Monoid&lt;Optional&lt;Integer&gt;&gt; maxMonoid = Monoids.maximum();
Optional&lt;Integer&gt; max = maxMonoid.combineAll(
    List.of(Optional.of(5), Optional.empty(), Optional.of(10))
);  // Optional[10]
</code></pre>
<p><strong>Common Instances in <code>Monoids</code> utility:</strong></p>
<ul>
<li><code>integerAddition()</code>, <code>longAddition()</code>, <code>doubleAddition()</code> - Numeric addition</li>
<li><code>integerMultiplication()</code>, <code>longMultiplication()</code>, <code>doubleMultiplication()</code> - Numeric multiplication</li>
<li><code>string()</code> - String concatenation</li>
<li><code>list()</code>, <code>set()</code> - Collection concatenation/union</li>
<li><code>booleanAnd()</code>, <code>booleanOr()</code> - Boolean operations</li>
<li><code>firstOptional()</code>, <code>lastOptional()</code> - First/last non-empty Optional</li>
<li><code>maximum()</code>, <code>minimum()</code> - Max/min value aggregation with Optional</li>
</ul>
<p><strong>Laws:</strong></p>
<ul>
<li>Left Identity: <code>combine(empty(), a) == a</code></li>
<li>Right Identity: <code>combine(a, empty()) == a</code></li>
<li>Associativity: <code>combine(a, combine(b, c)) == combine(combine(a, b), c)</code> (from Semigroup)</li>
</ul>
<p><strong>When To Use:</strong> Aggregating data (summing values, concatenating strings), reducing collections, folding data structures, accumulating results in parallel computations.</p>
<p><strong>Related:</strong> <a href="functional/semigroup_and_monoid.html">Semigroup and Monoid Documentation</a></p>
<hr />
<h3 id="semigroup-1"><a class="header" href="#semigroup-1">Semigroup</a></h3>
<p><strong>Definition:</strong> A type class for types that have an associative binary operation. The most fundamental algebraic structure for combining values.</p>
<p><strong>Core Operation:</strong></p>
<ul>
<li><code>combine(A a1, A a2)</code> - Associative binary operation</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">Semigroup&lt;String&gt; stringConcat = Semigroups.string();
String result = stringConcat.combine("Hello", " World");  // "Hello World"

// With custom delimiter
Semigroup&lt;String&gt; csvConcat = Semigroups.string(", ");
String csv = csvConcat.combine("apple", "banana");  // "apple, banana"

// For error accumulation in Validated
Semigroup&lt;String&gt; errorAccumulator = Semigroups.string("; ");
Applicative&lt;Validated.Witness&lt;String&gt;&gt; validator =
    ValidatedMonad.instance(errorAccumulator);
// Errors are combined: "Field A is invalid; Field B is required"
</code></pre>
<p><strong>Common Instances in <code>Semigroups</code> utility:</strong></p>
<ul>
<li><code>string()</code> - Basic string concatenation</li>
<li><code>string(String delimiter)</code> - String concatenation with delimiter</li>
<li><code>list()</code> - List concatenation</li>
<li><code>set()</code> - Set union</li>
<li><code>first()</code> - Always takes the first value</li>
<li><code>last()</code> - Always takes the last value</li>
</ul>
<p><strong>Laws:</strong></p>
<ul>
<li>Associativity: <code>combine(a, combine(b, c)) == combine(combine(a, b), c)</code></li>
</ul>
<p><strong>When To Use:</strong> Error accumulation (especially with Validated), combining partial results, building aggregators where an empty/identity value doesn't make sense.</p>
<p><strong>Related:</strong> <a href="functional/semigroup_and_monoid.html">Semigroup and Monoid Documentation</a></p>
<hr />
<h3 id="monaderror-1"><a class="header" href="#monaderror-1">MonadError</a></h3>
<p><strong>Definition:</strong> A type class that extends Monad with explicit error handling capabilities for a specific error type.</p>
<p><strong>Core Operations:</strong></p>
<ul>
<li><code>raiseError(E error)</code> - Create an error state</li>
<li><code>handleErrorWith(Kind&lt;F,A&gt; ma, Function&lt;E, Kind&lt;F,A&gt;&gt; handler)</code> - Recover from errors</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">MonadError&lt;EitherKind.Witness&lt;String&gt;, String&gt; monadError = EitherMonadError.instance();

Kind&lt;EitherKind.Witness&lt;String&gt;, Double&gt; result =
    monadError.handleErrorWith(
        divideOperation,
        error -&gt; monadError.of(0.0)  // Provide default on error
    );
</code></pre>
<p><strong>When To Use:</strong> Workflows that need explicit error handling and recovery (validation, I/O operations, API calls).</p>
<p><strong>Related:</strong> <a href="functional/monad_error.html">MonadError Documentation</a></p>
<hr />
<h3 id="profunctor-1"><a class="header" href="#profunctor-1">Profunctor</a></h3>
<p><strong>Definition:</strong> A type class for types that are contravariant in their first parameter (input) and covariant in their second parameter (output). The canonical example is <code>Function&lt;A, B&gt;</code>.</p>
<p><strong>Core Operations:</strong></p>
<ul>
<li><code>lmap(Function&lt;C,A&gt; f, Kind2&lt;P,A,B&gt; pab)</code> - Pre-process the input (contravariant)</li>
<li><code>rmap(Function&lt;B,D&gt; g, Kind2&lt;P,A,B&gt; pab)</code> - Post-process the output (covariant)</li>
<li><code>dimap(Function&lt;C,A&gt; f, Function&lt;B,D&gt; g, Kind2&lt;P,A,B&gt; pab)</code> - Transform both simultaneously</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">Profunctor&lt;FunctionKind.Witness&gt; prof = FunctionProfunctor.INSTANCE;

Function&lt;String, Integer&gt; stringLength = String::length;
Kind2&lt;FunctionKind.Witness, String, Integer&gt; kindFunc = FUNCTION.widen(stringLength);

// Adapt to work with integers (converting to string first)
Kind2&lt;FunctionKind.Witness, Integer, Integer&gt; intLength =
    prof.lmap(Object::toString, kindFunc);
</code></pre>
<p><strong>When To Use:</strong> Building adaptable pipelines, API adapters, validation frameworks that need to work with different input/output formats.</p>
<p><strong>Related:</strong> <a href="functional/profunctor.html">Profunctor Documentation</a></p>
<hr />
<h3 id="selective-1"><a class="header" href="#selective-1">Selective</a></h3>
<p><strong>Definition:</strong> A type class that sits between Applicative and Monad, providing conditional effects with static structure. All branches must be known upfront, enabling static analysis.</p>
<p><strong>Core Operations:</strong></p>
<ul>
<li><code>select(Kind&lt;F, Choice&lt;A,B&gt;&gt; fab, Kind&lt;F, Function&lt;A,B&gt;&gt; ff)</code> - Conditionally apply a function</li>
<li><code>whenS(Kind&lt;F, Boolean&gt; cond, Kind&lt;F, Unit&gt; effect)</code> - Execute effect only if condition is true</li>
<li><code>ifS(Kind&lt;F, Boolean&gt; cond, Kind&lt;F, A&gt; then, Kind&lt;F, A&gt; else)</code> - If-then-else with visible branches</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">Selective&lt;IOKind.Witness&gt; selective = IOSelective.INSTANCE;

// Only log if debug is enabled
Kind&lt;IOKind.Witness, Boolean&gt; debugEnabled =
    IO_KIND.widen(IO.delay(() -&gt; config.isDebug()));
Kind&lt;IOKind.Witness, Unit&gt; logEffect =
    IO_KIND.widen(IO.fromRunnable(() -&gt; log.debug("Debug info")));

Kind&lt;IOKind.Witness, Unit&gt; conditionalLog = selective.whenS(debugEnabled, logEffect);
</code></pre>
<p><strong>When To Use:</strong> Feature flags, conditional logging, configuration-based behaviour, multi-source fallback strategies.</p>
<p><strong>Related:</strong> <a href="functional/selective.html">Selective Documentation</a></p>
<hr />
<h2 id="data-types-and-structures"><a class="header" href="#data-types-and-structures">Data Types and Structures</a></h2>
<h3 id="choice"><a class="header" href="#choice">Choice</a></h3>
<p><strong>Definition:</strong> A type representing a choice between two alternatives, similar to <code>Either</code> but used specifically in the context of Selective functors. Can be <code>Left&lt;A&gt;</code> (needs processing) or <code>Right&lt;B&gt;</code> (already processed).</p>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Helper methods in Selective interface
Choice&lt;String, Integer&gt; needsParsing = Selective.left("42");
Choice&lt;String, Integer&gt; alreadyParsed = Selective.right(42);

// In selective operations
Kind&lt;F, Choice&lt;String, Integer&gt;&gt; input = ...;
Kind&lt;F, Function&lt;String, Integer&gt;&gt; parser = ...;
Kind&lt;F, Integer&gt; result = selective.select(input, parser);
// Parser only applied if Choice is Left
</code></pre>
<p><strong>Related:</strong> <a href="functional/selective.html">Selective Documentation</a></p>
<hr />
<h3 id="unit"><a class="header" href="#unit">Unit</a></h3>
<p><strong>Definition:</strong> A type with exactly one value (<code>Unit.INSTANCE</code>), representing the completion of an operation that doesn't produce a meaningful result. The functional equivalent of <code>void</code>, but usable as a type parameter.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// IO action that performs a side effect
Kind&lt;IOKind.Witness, Unit&gt; printAction =
    IO_KIND.widen(IO.fromRunnable(() -&gt; System.out.println("Hello")));

// Optional as MonadError&lt;..., Unit&gt;
MonadError&lt;OptionalKind.Witness, Unit&gt; optionalMonad = OptionalMonad.INSTANCE;
Kind&lt;OptionalKind.Witness, String&gt; empty =
    optionalMonad.raiseError(Unit.INSTANCE);  // Creates Optional.empty()
</code></pre>
<p><strong>When To Use:</strong></p>
<ul>
<li>Effects that don't return a value (logging, printing, etc.)</li>
<li>Error types for contexts where absence is the only error (Optional, Maybe)</li>
</ul>
<p><strong>Related:</strong> <a href="hkts/core-concepts.html">Core Concepts</a></p>
<hr />
<h3 id="const"><a class="header" href="#const">Const</a></h3>
<p><strong>Definition:</strong> A constant functor that wraps a value of type <code>C</code> whilst ignoring a phantom type parameter <code>A</code>. The second type parameter exists purely for type-level information and has no runtime representation.</p>
<p><strong>Structure:</strong> <code>Const&lt;C, A&gt;</code> where <code>C</code> is the concrete value type and <code>A</code> is phantom.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// Store a String, phantom type is Integer
Const&lt;String, Integer&gt; stringConst = new Const&lt;&gt;("hello");

String value = stringConst.value(); // "hello"

// Mapping over the phantom type changes the signature but not the value
Const&lt;String, Double&gt; doubleConst = stringConst.mapSecond(i -&gt; i * 2.0);
System.out.println(doubleConst.value()); // Still "hello" (unchanged!)

// Bifunctor allows transforming the actual value
Bifunctor&lt;ConstKind2.Witness&gt; bifunctor = ConstBifunctor.INSTANCE;
Const&lt;Integer, Double&gt; intConst = CONST.narrow2(bifunctor.bimap(
    String::length,
    i -&gt; i * 2.0,
    CONST.widen2(stringConst)
));
System.out.println(intConst.value()); // 5
</code></pre>
<p><strong>When To Use:</strong></p>
<ul>
<li>Implementing van Laarhoven lenses and folds</li>
<li>Accumulating values whilst traversing structures</li>
<li>Teaching phantom types and their practical applications</li>
<li>Building optics that extract rather than modify data</li>
</ul>
<p><strong>Related:</strong> <a href="glossary.html#phantom-type">Phantom Type</a>, <a href="glossary.html#bifunctor">Bifunctor</a>, <a href="monads/const_type.html">Const Type Documentation</a></p>
<hr />
<h2 id="optics-terminology"><a class="header" href="#optics-terminology">Optics Terminology</a></h2>
<h3 id="at"><a class="header" href="#at">At</a></h3>
<p><strong>Definition:</strong> A type class for structures that support indexed access with insertion and deletion semantics. Provides a <code>Lens&lt;S, Optional&lt;A&gt;&gt;</code> where setting to <code>Optional.empty()</code> deletes the entry and setting to <code>Optional.of(value)</code> inserts or updates it.</p>
<p><strong>Core Operations:</strong></p>
<ul>
<li><code>at(I index)</code> - Returns <code>Lens&lt;S, Optional&lt;A&gt;&gt;</code> for the index</li>
<li><code>get(I index, S source)</code> - Read value at index (returns Optional)</li>
<li><code>insertOrUpdate(I index, A value, S source)</code> - Insert or update entry</li>
<li><code>remove(I index, S source)</code> - Delete entry at index</li>
<li><code>modify(I index, Function&lt;A,A&gt; f, S source)</code> - Update value if present</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">At&lt;Map&lt;String, Integer&gt;, String, Integer&gt; mapAt = AtInstances.mapAt();

Map&lt;String, Integer&gt; scores = new HashMap&lt;&gt;(Map.of("alice", 100));

// Insert new entry
Map&lt;String, Integer&gt; withBob = mapAt.insertOrUpdate("bob", 85, scores);
// Result: {alice=100, bob=85}

// Remove entry
Map&lt;String, Integer&gt; noAlice = mapAt.remove("alice", withBob);
// Result: {bob=85}

// Compose with Lens for deep access
Lens&lt;UserProfile, Optional&lt;String&gt;&gt; themeLens =
    settingsLens.andThen(mapAt.at("theme"));
</code></pre>
<p><strong>When To Use:</strong> CRUD operations on maps or lists where you need to insert new entries or delete existing ones whilst maintaining immutability and optics composability.</p>
<p><strong>Related:</strong> <a href="optics/at.html">At Type Class Documentation</a></p>
<hr />
<h3 id="iso-isomorphism"><a class="header" href="#iso-isomorphism">Iso (Isomorphism)</a></h3>
<p><strong>Definition:</strong> An optic representing a lossless, bidirectional conversion between two types. If you can convert <code>A</code> to <code>B</code> and back to <code>A</code> without losing information, you have an isomorphism.</p>
<p><strong>Core Operations:</strong></p>
<ul>
<li><code>get(S source)</code> - Convert from S to A</li>
<li><code>reverseGet(A value)</code> - Convert from A to S</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">// String and List&lt;Character&gt; are isomorphic
Iso&lt;String, List&lt;Character&gt;&gt; stringToChars = Iso.iso(
    s -&gt; s.chars().mapToObj(c -&gt; (char) c).collect(Collectors.toList()),
    chars -&gt; chars.stream().map(String::valueOf).collect(Collectors.joining())
);

List&lt;Character&gt; chars = stringToChars.get("Hello");  // ['H', 'e', 'l', 'l', 'o']
String back = stringToChars.reverseGet(chars);       // "Hello"
</code></pre>
<p><strong>When To Use:</strong> Converting between equivalent representations (e.g., Celsius/Fahrenheit, String/ByteArray, domain models and DTOs with no information loss).</p>
<p><strong>Related:</strong> <a href="optics/iso.html">Iso Documentation</a></p>
<hr />
<h3 id="lens"><a class="header" href="#lens">Lens</a></h3>
<p><strong>Definition:</strong> An optic for working with product types (records with fields). Provides a composable way to get and set fields in immutable data structures.</p>
<p><strong>Core Operations:</strong></p>
<ul>
<li><code>get(S source)</code> - Extract a field value</li>
<li><code>set(A newValue, S source)</code> - Create a new copy with updated field</li>
<li><code>modify(Function&lt;A,A&gt; f, S source)</code> - Update field using a function</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">@GenerateLenses
public record Address(String street, String city) {}

@GenerateLenses
public record Company(String name, Address address) {}

@GenerateLenses
public record Employee(String name, Company company) {}

// Compose lenses for deep updates
Lens&lt;Employee, String&gt; employeeToStreet =
    EmployeeLenses.company()
        .andThen(CompanyLenses.address())
        .andThen(AddressLenses.street());

// Update nested field in one line
Employee updated = employeeToStreet.set("456 New St", originalEmployee);
</code></pre>
<p><strong>Related:</strong> <a href="optics/lenses.html">Lenses Documentation</a></p>
<hr />
<h3 id="prism"><a class="header" href="#prism">Prism</a></h3>
<p><strong>Definition:</strong> An optic for working with sum types (sealed interfaces, Optional, Either). Provides safe access to specific variants within a discriminated union.</p>
<p><strong>Core Operations:</strong></p>
<ul>
<li><code>preview(S source)</code> - Try to extract a variant (returns Optional)</li>
<li><code>review(A value)</code> - Construct the sum type from a variant</li>
<li><code>modify(Function&lt;A,A&gt; f, S source)</code> - Update if variant matches</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">@GeneratePrisms
public sealed interface PaymentMethod {
    record CreditCard(String number) implements PaymentMethod {}
    record BankTransfer(String iban) implements PaymentMethod {}
}

Prism&lt;PaymentMethod, String&gt; creditCardPrism =
    PaymentMethodPrisms.creditCard().andThen(CreditCardLenses.number());

// Safe extraction
Optional&lt;String&gt; cardNumber = creditCardPrism.preview(payment);

// Conditional update
PaymentMethod masked = creditCardPrism.modify(num -&gt; "****" + num.substring(12), payment);
</code></pre>
<p><strong>Related:</strong> <a href="optics/prisms.html">Prisms Documentation</a></p>
<hr />
<h3 id="traversal"><a class="header" href="#traversal">Traversal</a></h3>
<p><strong>Definition:</strong> An optic for working with multiple values within a structure (lists, sets, trees). Allows bulk operations on all elements.</p>
<p><strong>Core Operations:</strong></p>
<ul>
<li><code>modifyF(Applicative&lt;F&gt; app, Function&lt;A, Kind&lt;F,A&gt;&gt; f, S source)</code> - Effectful modification of all elements</li>
<li><code>toList(S source)</code> - Extract all focused values as a list</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-java">@GenerateLenses
public record Order(String id, List&lt;LineItem&gt; items) {}

Traversal&lt;Order, LineItem&gt; orderItems =
    OrderLenses.items().asTraversal();

// Apply bulk update
Order discounted = orderItems.modify(
    item -&gt; item.withPrice(item.price() * 0.9),
    order
);
</code></pre>
<p><strong>Related:</strong> <a href="optics/traversals.html">Traversals Documentation</a></p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="contributing-to-java-hkt-simulation"><a class="header" href="#contributing-to-java-hkt-simulation">Contributing to Java HKT Simulation</a></h1>
<p>First off, thank you for considering contributing! This project is a simulation to explore Higher-Kinded Types in Java, and contributions are welcome.</p>
<p>This document provides guidelines for contributing to this project.</p>
<h2 id="code-of-conduct"><a class="header" href="#code-of-conduct">Code of Conduct</a></h2>
<p>This project and everyone participating in it is governed by the <a href="CODE_OF_CONDUCT.html">Code of Conduct</a>. By participating, you are expected to uphold this code. Please report unacceptable behavior to simulation.hkt@gmail.com.</p>
<h2 id="how-can-i-contribute"><a class="header" href="#how-can-i-contribute">How Can I Contribute?</a></h2>
<h3 id="reporting-bugs"><a class="header" href="#reporting-bugs">Reporting Bugs</a></h3>
<ul>
<li>Ensure the bug was not already reported by searching on GitHub under <a href="https://github.com/higher-kinded-j/higher-kinded-j/issues">Issues</a>.</li>
<li>If you're unable to find an open issue addressing the problem, <a href="https://github.com/higher-kinded-j/higher-kinded-j/issues/new">open a new one</a>. Be sure to include a <strong>title and clear description</strong>, as much relevant information as possible, and a <strong>code sample or an executable test case</strong> demonstrating the expected behavior that is not occurring.</li>
<li>Use the "Bug Report" issue template if available.</li>
</ul>
<h3 id="suggesting-enhancements"><a class="header" href="#suggesting-enhancements">Suggesting Enhancements</a></h3>
<ul>
<li>Open a new issue to discuss your enhancement suggestion. Please provide details about the motivation and potential implementation.</li>
<li>Use the "Feature Request" issue template if available.</li>
</ul>
<h3 id="your-first-code-contribution"><a class="header" href="#your-first-code-contribution">Your First Code Contribution</a></h3>
<p>Unsure where to begin contributing? You can start by looking through <code>good first issue</code> or <code>help wanted</code> issues (you can add these labels yourself to issues you think fit).</p>
<h3 id="pull-requests"><a class="header" href="#pull-requests">Pull Requests</a></h3>
<ol>
<li><strong>Fork the repository</strong> on GitHub.</li>
<li><strong>Clone your fork</strong> locally: <code>git clone git@github.com:higher-kinded-j/higher-kinded-j.git</code></li>
<li><strong>Create a new branch</strong> for your changes: <code>git checkout -b name-of-your-feature-or-fix</code></li>
<li><strong>Make your changes.</strong> Ensure you adhere to standard Java coding conventions.</li>
<li><strong>Add tests</strong> for your changes. This is important!</li>
<li><strong>Run the tests:</strong> Make sure the full test suite passes using <code>./gradlew test</code>.</li>
<li><strong>Build the project:</strong> Ensure the project builds without errors using <code>./gradlew build</code>.</li>
<li><strong>Commit your changes:</strong> Use clear and descriptive commit messages. <code>git commit -am 'Add some feature'</code></li>
<li><strong>Push to your fork:</strong> <code>git push origin name-of-your-feature-or-fix</code></li>
<li><strong>Open a Pull Request</strong> against the <code>main</code> branch of the original repository.</li>
<li><strong>Describe your changes</strong> in the Pull Request description. Link to any relevant issues (e.g., "Closes #123").</li>
<li>Ensure the <strong>GitHub Actions CI checks pass</strong>.</li>
</ol>
<h2 id="development-setup"><a class="header" href="#development-setup">Development Setup</a></h2>
<ul>
<li>You need a Java Development Kit (JDK), version <strong>24</strong> or later.</li>
<li>This project uses Gradle. You can use the included Gradle Wrapper (<code>gradlew</code>) to build and test.
<ul>
<li>Build the project: <code>./gradlew build</code></li>
<li>Run tests: <code>./gradlew test</code></li>
<li>Generate JaCoCo coverage reports: <code>./gradlew test jacocoTestReport</code> (HTML report at <code>build/reports/jacoco/test/html/index.html</code>)</li>
</ul>
</li>
</ul>
<h2 id="coding-style"><a class="header" href="#coding-style">Coding Style</a></h2>
<p>Please follow the <a href="https://google.github.io/styleguide/javaguide.html"><strong>Google Java Style Guide</strong></a>. Keep code simple, readable, and well-tested. Consistent formatting is encouraged.</p>
<p>Thank you for contributing!</p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="contributor-covenant-code-of-conduct"><a class="header" href="#contributor-covenant-code-of-conduct">Contributor Covenant Code of Conduct</a></h1>
<h2 id="our-pledge"><a class="header" href="#our-pledge">Our Pledge</a></h2>
<p>We as members, contributors, and leaders pledge to make participation in our
community a harassment-free experience for everyone, regardless of age, body
size, visible or invisible disability, ethnicity, sex characteristics, gender
identity and expression, level of experience, education, socio-economic status,
nationality, personal appearance, race, religion, or sexual identity
and orientation.</p>
<p>We pledge to act and interact in ways that contribute to an open, welcoming,
diverse, inclusive, and healthy community.</p>
<h2 id="our-standards"><a class="header" href="#our-standards">Our Standards</a></h2>
<p>Examples of behavior that contributes to a positive environment for our
community include:</p>
<ul>
<li>Demonstrating empathy and kindness toward other people</li>
<li>Being respectful of differing opinions, viewpoints, and experiences</li>
<li>Giving and gracefully accepting constructive feedback</li>
<li>Accepting responsibility and apologizing to those affected by our mistakes,
and learning from the experience</li>
<li>Focusing on what is best not just for us as individuals, but for the
overall community</li>
</ul>
<p>Examples of unacceptable behavior include:</p>
<ul>
<li>The use of sexualized language or imagery, and sexual attention or
advances of any kind</li>
<li>Trolling, insulting or derogatory comments, and personal or political attacks</li>
<li>Public or private harassment</li>
<li>Publishing others' private information, such as a physical or email
address, without their explicit permission</li>
<li>Other conduct which could reasonably be considered inappropriate in a
professional setting</li>
</ul>
<h2 id="enforcement-responsibilities"><a class="header" href="#enforcement-responsibilities">Enforcement Responsibilities</a></h2>
<p>Community leaders are responsible for clarifying and enforcing our standards of
acceptable behavior and will take appropriate and fair corrective action in
response to any behavior that they deem inappropriate, threatening, offensive,
or harmful.</p>
<p>Community leaders have the right and responsibility to remove, edit, or reject
comments, commits, code, wiki edits, issues, and other contributions that are
not aligned to this Code of Conduct, and will communicate reasons for moderation
decisions when appropriate.</p>
<h2 id="scope"><a class="header" href="#scope">Scope</a></h2>
<p>This Code of Conduct applies within all community spaces, and also applies when
an individual is officially representing the community in public spaces.
Examples of representing our community include using an official e-mail address,
posting via an official social media account, or acting as an appointed
representative at an online or offline event.</p>
<h2 id="enforcement"><a class="header" href="#enforcement">Enforcement</a></h2>
<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported to the community leaders responsible for enforcement at
simulation.hkt@gmail.com.
All complaints will be reviewed and investigated promptly and fairly.</p>
<p>All community leaders are obligated to respect the privacy and security of the
reporter of any incident.</p>
<h2 id="enforcement-guidelines"><a class="header" href="#enforcement-guidelines">Enforcement Guidelines</a></h2>
<p>Community leaders will follow these Community Impact Guidelines in determining
the consequences for any action they deem in violation of this Code of Conduct:</p>
<h3 id="1-correction"><a class="header" href="#1-correction">1. Correction</a></h3>
<p><strong>Community Impact</strong>: Use of inappropriate language or other behavior deemed
unprofessional or unwelcome in the community.</p>
<p><strong>Consequence</strong>: A private, written warning from community leaders, providing
clarity around the nature of the violation and an explanation of why the
behavior was inappropriate. A public apology may be requested.</p>
<h3 id="2-warning"><a class="header" href="#2-warning">2. Warning</a></h3>
<p><strong>Community Impact</strong>: A violation through a single incident or series
of actions.</p>
<p><strong>Consequence</strong>: A warning with consequences for continued behavior. No
interaction with the people involved, including unsolicited interaction with
those enforcing the Code of Conduct, for a specified period of time. This
includes avoiding interactions in community spaces as well as external channels
like social media. Violating these terms may lead to a temporary or
permanent ban.</p>
<h3 id="3-temporary-ban"><a class="header" href="#3-temporary-ban">3. Temporary Ban</a></h3>
<p><strong>Community Impact</strong>: A serious violation of community standards, including
sustained inappropriate behavior.</p>
<p><strong>Consequence</strong>: A temporary ban from any sort of interaction or public
communication with the community for a specified period of time. No public or
private interaction with the people involved, including unsolicited interaction
with those enforcing the Code of Conduct, is allowed during this period.
Violating these terms may lead to a permanent ban.</p>
<h3 id="4-permanent-ban"><a class="header" href="#4-permanent-ban">4. Permanent Ban</a></h3>
<p><strong>Community Impact</strong>: Demonstrating a pattern of violation of community
standards, including sustained inappropriate behavior, harassment of an
individual, or aggression toward or disparagement of classes of individuals.</p>
<p><strong>Consequence</strong>: A permanent ban from any sort of public interaction within
the community.</p>
<h2 id="attribution"><a class="header" href="#attribution">Attribution</a></h2>
<p>This Code of Conduct is adapted from the <a href="https://www.contributor-covenant.org">Contributor Covenant</a>,
version 2.1, available at
<a href="https://www.contributor-covenant.org/version/2/1/code_of_conduct.html">https://www.contributor-covenant.org/version/2/1/code_of_conduct.html</a>.</p>
<p>Community Impact Guidelines were inspired by <a href="https://github.com/mozilla/diversity">Mozilla's code of conduct
enforcement ladder</a>.</p>
<p>For answers to common questions about this code of conduct, see the FAQ at
<a href="https://www.contributor-covenant.org/faq">https://www.contributor-covenant.org/faq</a>. Translations are available at
<a href="https://www.contributor-covenant.org/translations">https://www.contributor-covenant.org/translations</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<p>MIT License</p>
<p>Copyright (c) 2025 Magnus Smith</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="version-switcher.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
