<!DOCTYPE HTML>
<html lang="en" class="latte sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Prisms - Higher-Kinded-J: Composable Effects and Advanced Optics for Java</title>


        <!-- Custom HTML head -->


            <meta name="description" content="The most comprehensive functional programming library for Java. Unify error handling, optional values, and immutable data navigation with the Effect Path API and Focus DSL. Features advanced optics with code generation for Java records, filtered traversals, indexed optics, and seamless Spring Boot integration.">


        <meta name="keywords" content="Higher-Kinded Types, Higher-Kinded-J, HKT, Java, Optics, Lens, Prism, Traversal, Iso, Affine, Focus DSL, Effect Path API, Functional Programming, Monad, Functor, Applicative, EitherPath, MaybePath, TryPath, ValidationPath, Java Records, Sealed Interface, Error Handling, Immutable Data">
        
        <meta property="og:title" content="Prisms - Higher-Kinded-J: Composable Effects and Advanced Optics for Java">
            <meta property="og:description" content="The most comprehensive functional programming library for Java. Unify error handling, optional values, and immutable data navigation with the Effect Path API and Focus DSL. Features advanced optics with code generation for Java records, filtered traversals, indexed optics, and seamless Spring Boot integration.">
        <meta property="og:type" content="website">
        <meta property="og:url" content="https://higher-kinded-j.github.io/">
        <meta property="og:image" content="https://higher-kinded-j.github.io/preview.png">
        <meta property="og:image:width" content="1200">
        <meta property="og:image:height" content="630">
        <meta property="og:site_name" content="Higher-Kinded-J Documentation">
        <meta property="og:locale" content="en_GB">
        
        <meta name="twitter:card" content="summary_large_image">
        <meta name="twitter:title" content="Prisms - Higher-Kinded-J: Composable Effects and Advanced Optics for Java">
        <meta name="twitter:description" content="Unifying Composable Effects and Advanced Optics for Java. Effect Path API, Focus DSL, and the most comprehensive optics implementation in the Java ecosystem.">
        <meta name="twitter:image" content="https://higher-kinded-j.github.io/preview.png">
        <meta name="twitter:image:alt" content="Higher-Kinded-J: Composable Effects and Advanced Optics for Java">
        <meta name="description" content="The most comprehensive functional programming library for Java. Unify error handling, optional values, and immutable data navigation with the Effect Path API and Focus DSL. Features advanced optics with code generation for Java records, filtered traversals, indexed optics, and seamless Spring Boot integration.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">
        <meta name="google-site-verification" content="X-xsiAq2cKMLOzh9dexUrX8Onx2h_YMUFgp5lHHUwSg" />
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href=".././mdbook-admonish.css">
        <link rel="stylesheet" href=".././theme/catppuccin.css">
        <link rel="stylesheet" href=".././theme/catppuccin-admonish.css">
        <link rel="stylesheet" href=".././theme/catppuccin-alerts.css">
        <link rel="stylesheet" href=".././theme/additional-hkj.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "latte";
            const default_dark_theme = "macchiato";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('latte')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="latte">Latte</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="frappe">Frapp√©</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="macchiato">Macchiato</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mocha">Mocha</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        <div class="version-selector-container">
                            <select id="version-selector" class="version-selector" aria-label="Select documentation version" title="Select documentation version">
                                <option value="">Loading versions...</option>
                            </select>
                        </div>
                    </div>

                    <h1 class="menu-title">Higher-Kinded-J: Composable Effects and Advanced Optics for Java</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/higher-kinded-j/higher-kinded-j" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/higher-kinded-j/higher-kinded-j/edit/main/hkj-book/src/optics/prisms.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="prisms-a-practical-guide"><a class="header" href="#prisms-a-practical-guide">Prisms: A Practical Guide</a></h1>
<h2 id="working-with-sum-types"><a class="header" href="#working-with-sum-types"><em>Working with Sum Types</em></a></h2>
<p><img src="../images/prism.jpeg" alt="Visual representation of a prism safely extracting one variant from a sum type" /></p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to safely work with sum types and sealed interfaces</li>
<li>Using <code>@GeneratePrisms</code> to create type-safe variant accessors</li>
<li>The difference between <code>getOptional</code> and <code>build</code> operations</li>
<li>Composing prisms with other optics for deep conditional access</li>
<li>Handling optional data extraction without <code>instanceof</code> chains</li>
<li>When to use prisms vs pattern matching vs traditional type checking</li>
</ul>
</div>
</div>
<div id="admonition-hands-on-practice" class="admonition admonish-note" role="note" aria-labelledby="admonition-hands-on-practice-title">
<div class="admonition-title">
<div id="admonition-hands-on-practice-title">
<p>Hands On Practice</p>
</div>
<a class="admonition-anchor-link" href="#admonition-hands-on-practice"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/optics/Tutorial03_PrismBasics.java">Tutorial03_PrismBasics.java</a></p>
</div>
</div>
<div id="admonition-example-code" class="admonition admonish-note" role="note" aria-labelledby="admonition-example-code-title">
<div class="admonition-title">
<div id="admonition-example-code-title">
<p>Example Code</p>
</div>
<a class="admonition-anchor-link" href="#admonition-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/PrismUsageExample.java">PrismUsageExample</a>
<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/PrismConvenienceMethodsExample.java">PrismConvenienceMethodsExample</a>
<a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/PrismsUtilityExample.java">PrismsUtilityExample</a></p>
</div>
</div>
<p>The previous guide demonstrated how a <strong><code>Lens</code></strong> gives us a powerful, composable way to work with "has-a" relationships: a field that is guaranteed to exist within a record.</p>
<p>But what happens when the data doesn't have a guaranteed structure? What if a value can be one of <em>several different types</em>? This is the domain of "is-a" relationships, or <strong>sum types</strong>, commonly modeled in Java using <code>sealed interface</code> or <code>enum</code>.</p>
<p>For this, we need a different kind of optic: the <strong>Prism</strong>.</p>
<hr />
<h2 id="the-scenario-working-with-json-like-data"><a class="header" href="#the-scenario-working-with-json-like-data">The Scenario: Working with JSON-like Data</a></h2>
<p>A <code>Lens</code> is like a sniper rifle, targeting a single, known field. A <strong><code>Prism</code></strong> is like a safe-cracker's tool; it attempts to open a specific "lock" (a particular type) and only succeeds if it has the right key.</p>
<p>Consider a common scenario: modelling a JSON structure. A value can be a string, a number, a boolean, or a nested object.</p>
<p><strong>The Data Model:</strong> We can represent this with a <code>sealed interface</code>.</p>
<pre><code class="language-java">import org.higherkindedj.optics.annotations.GeneratePrisms;
import org.higherkindedj.optics.annotations.GenerateLenses;
import java.util.Map;

@GeneratePrisms // Generates Prisms for each case of the sealed interface
public sealed interface JsonValue {}

public record JsonString(String value) implements JsonValue {}
public record JsonNumber(double value) implements JsonValue {}

@GenerateLenses // We can still use Lenses on the product types within the sum type
public record JsonObject(Map&lt;String, JsonValue&gt; fields) implements JsonValue {}
</code></pre>
<p><strong>Our Goal:</strong> We need to safely access and update the <code>value</code> of a <code>JsonString</code> that is deeply nested within another <code>JsonObject</code>. An <code>instanceof</code> and casting approach would be unsafe and verbose. A <code>Lens</code> won't work because a <code>JsonValue</code> might be a <code>JsonNumber</code>, not the <code>JsonObject</code> we expect.</p>
<hr />
<h2 id="think-of-prisms-like"><a class="header" href="#think-of-prisms-like">Think of Prisms Like...</a></h2>
<ul>
<li><strong>A type-safe filter</strong>: Only "lets through" values that match a specific shape</li>
<li><strong>A safe cast</strong>: Like <code>instanceof</code> + cast, but functional and composable</li>
<li><strong>A conditional lens</strong>: Works like a lens, but might return empty if the type doesn't match</li>
<li><strong>A pattern matcher</strong>: Focuses on one specific case of a sum type</li>
</ul>
<hr />
<h2 id="a-step-by-step-walkthrough"><a class="header" href="#a-step-by-step-walkthrough">A Step-by-Step Walkthrough</a></h2>
<h3 id="step-1-generating-the-prisms"><a class="header" href="#step-1-generating-the-prisms">Step 1: Generating the Prisms</a></h3>
<p>Just as with lenses, we annotate our <code>sealed interface</code> with <strong><code>@GeneratePrisms</code></strong>. This automatically creates a companion class (e.g., <code>JsonValuePrisms</code>) with a <code>Prism</code> for each permitted subtype.</p>
<pre><code class="language-java">// Generated automatically:
// JsonValuePrisms.jsonString() -&gt; Prism&lt;JsonValue, JsonString&gt;
// JsonValuePrisms.jsonNumber() -&gt; Prism&lt;JsonValue, JsonNumber&gt;
// JsonValuePrisms.jsonBoolean() -&gt; Prism&lt;JsonValue, JsonBoolean&gt;
// JsonValuePrisms.jsonObject() -&gt; Prism&lt;JsonValue, JsonObject&gt;
</code></pre>
<h4 id="customising-the-generated-package"><a class="header" href="#customising-the-generated-package">Customising the Generated Package</a></h4>
<p>By default, generated classes are placed in the same package as the annotated type. You can specify a different package using the <code>targetPackage</code> attribute:</p>
<pre><code class="language-java">// Generated class will be placed in org.example.generated.optics
@GeneratePrisms(targetPackage = "org.example.generated.optics")
public sealed interface JsonValue {}
</code></pre>
<p>This is useful when you need to avoid name collisions or organise generated code separately.</p>
<h3 id="step-2-the-core-prism-operations"><a class="header" href="#step-2-the-core-prism-operations">Step 2: The Core Prism Operations</a></h3>
<p>A <code>Prism</code> is defined by two unique, failable operations:</p>
<ul>
<li><strong><code>getOptional(source)</code></strong>: Attempts to focus on the target. It returns an <code>Optional</code> which is non-empty only if the <code>source</code> matches the Prism's specific case. This is the safe alternative to an <code>instanceof</code> check and cast.</li>
<li><strong><code>build(value)</code></strong>: Constructs the top-level type from a part. This is the reverse operation, used to wrap a value back into its specific case (e.g., taking a <code>String</code> and building a <code>JsonString</code>).</li>
</ul>
<pre><code class="language-java">Prism&lt;JsonValue, JsonString&gt; jsonStringPrism = JsonValuePrisms.jsonString();

// --- Using getOptional (the safe "cast") ---
Optional&lt;JsonString&gt; result1 = jsonStringPrism.getOptional(new JsonString("hello")); 
// -&gt; Optional.of(JsonString("hello"))

Optional&lt;JsonString&gt; result2 = jsonStringPrism.getOptional(new JsonNumber(123));   
// -&gt; Optional.empty()

// --- Using build (construct the sum type from a part) ---
JsonValue result3 = jsonStringPrism.build(new JsonString("world")); 
// -&gt; JsonString("world") (as JsonValue)
</code></pre>
<h3 id="step-3-composing-prisms-for-deep-access"><a class="header" href="#step-3-composing-prisms-for-deep-access">Step 3: Composing Prisms for Deep Access</a></h3>
<p>The true power is composing <code>Prism</code>s with other optics. When a composition might fail (any time a <code>Prism</code> is involved), the result is an <code>Affine</code> (or <code>Traversal</code> when combining with traversals).</p>
<div id="admonition-direct-composition-methods" class="admonition admonish-tip" role="note" aria-labelledby="admonition-direct-composition-methods-title">
<div class="admonition-title">
<div id="admonition-direct-composition-methods-title">
<p>Direct Composition Methods</p>
</div>
<a class="admonition-anchor-link" href="#admonition-direct-composition-methods"></a>
</div>
<div>
<p>higher-kinded-j provides direct composition methods that automatically return the correct type:</p>
<ul>
<li><code>Lens.andThen(Prism)</code> returns <code>Affine</code></li>
<li><code>Prism.andThen(Lens)</code> returns <code>Affine</code></li>
<li><code>Prism.andThen(Prism)</code> returns <code>Prism</code></li>
<li><code>Affine.andThen(Affine)</code> returns <code>Affine</code></li>
</ul>
<p>See <a href="composition_rules.html">Composition Rules</a> for the complete reference.</p>
</div>
</div>
<pre><code class="language-java">// Create all the optics we need
Prism&lt;JsonValue, JsonObject&gt; jsonObjectPrism = JsonValuePrisms.jsonObject();
Prism&lt;JsonValue, JsonString&gt; jsonStringPrism = JsonValuePrisms.jsonString();
Lens&lt;JsonObject, Map&lt;String, JsonValue&gt;&gt; fieldsLens = JsonObjectLenses.fields();
Lens&lt;JsonString, String&gt; valueLens = JsonStringLenses.value();

// Direct composition: Prism &gt;&gt;&gt; Lens = Traversal
Traversal&lt;JsonValue, String&gt; jsonStringValue =
    jsonStringPrism.andThen(valueLens);

// The composed optic: safely navigate from JsonObject -&gt; userLogin field -&gt; name field -&gt; string value
Traversal&lt;JsonObject, String&gt; userNameTraversal =
    fieldsLens.asTraversal()                      // JsonObject -&gt; Map&lt;String, JsonValue&gt;
        .andThen(Traversals.forMap("userLogin"))  // -&gt; JsonValue (if "userLogin" key exists)
        .andThen(jsonObjectPrism.asTraversal())   // -&gt; JsonObject (if it's an object)
        .andThen(fieldsLens.asTraversal())        // -&gt; Map&lt;String, JsonValue&gt;
        .andThen(Traversals.forMap("name"))       // -&gt; JsonValue (if "name" key exists)
        .andThen(jsonStringValue);                // -&gt; String (if it's a string)
</code></pre>
<p>This composed <code>Traversal</code> now represents a safe, deep path that will only succeed if every step in the chain matches.</p>
<hr />
<h2 id="when-to-use-prisms-vs-other-approaches"><a class="header" href="#when-to-use-prisms-vs-other-approaches">When to Use Prisms vs Other Approaches</a></h2>
<h3 id="use-prisms-when"><a class="header" href="#use-prisms-when">Use Prisms When:</a></h3>
<ul>
<li><strong>Type-safe variant handling</strong> - Working with <code>sealed interface</code> or <code>enum</code> cases</li>
<li><strong>Optional data extraction</strong> - You need to safely "try" to get a specific type</li>
<li><strong>Composable type checking</strong> - Building reusable type-safe paths</li>
<li><strong>Functional pattern matching</strong> - Avoiding <code>instanceof</code> chains</li>
</ul>
<pre><code class="language-java">// Perfect for safe type extraction
Optional&lt;String&gt; errorMessage = DomainErrorPrisms.validationError()
    .andThen(ValidationErrorLenses.message())
    .getOptional(someError);
</code></pre>
<h3 id="use-traditional-instanceof-when"><a class="header" href="#use-traditional-instanceof-when">Use Traditional instanceof When:</a></h3>
<ul>
<li><strong>One-off type checks</strong> - Not building reusable logic</li>
<li><strong>Imperative control flow</strong> - You need if/else branching</li>
<li><strong>Performance critical paths</strong> - Minimal abstraction overhead needed</li>
</ul>
<pre><code class="language-java">// Sometimes instanceof is clearer for simple cases
if (jsonValue instanceof JsonString jsonStr) {
    return jsonStr.value().toUpperCase();
}
</code></pre>
<h3 id="use-pattern-matching-when"><a class="header" href="#use-pattern-matching-when">Use Pattern Matching When:</a></h3>
<ul>
<li><strong>Exhaustive case handling</strong> - You need to handle all variants</li>
<li><strong>Complex extraction logic</strong> - Multiple levels of pattern matching</li>
<li><strong>Modern codebases</strong> - Using recent Java features</li>
</ul>
<pre><code class="language-java">// Pattern matching for comprehensive handling
return switch (jsonValue) {
    case JsonString(var str) -&gt; str.toUpperCase();
    case JsonNumber(var num) -&gt; String.valueOf(num);
    case JsonBoolean(var bool) -&gt; String.valueOf(bool);
    case JsonObject(var fields) -&gt; "Object with " + fields.size() + " fields";
};
</code></pre>
<hr />
<h2 id="common-pitfalls"><a class="header" href="#common-pitfalls">Common Pitfalls</a></h2>
<h3 id="dont-do-this"><a class="header" href="#dont-do-this">Don't Do This:</a></h3>
<pre><code class="language-java">// Unsafe: Assuming the cast will succeed
JsonString jsonStr = (JsonString) jsonValue; // Can throw ClassCastException!

// Verbose: Repeated instanceof checks
if (jsonValue instanceof JsonObject obj1) {
    var userValue = obj1.fields().get("userLogin");
    if (userValue instanceof JsonObject obj2) {
        var nameValue = obj2.fields().get("name");
        if (nameValue instanceof JsonString str) {
            return str.value().toUpperCase();
        }
    }
}

// Inefficient: Creating prisms repeatedly
var name1 = JsonValuePrisms.jsonString().getOptional(value1);
var name2 = JsonValuePrisms.jsonString().getOptional(value2);
var name3 = JsonValuePrisms.jsonString().getOptional(value3);
</code></pre>
<h3 id="do-this-instead"><a class="header" href="#do-this-instead">Do This Instead:</a></h3>
<pre><code class="language-java">// Safe: Use prism's getOptional
Optional&lt;JsonString&gt; maybeJsonStr = JsonValuePrisms.jsonString().getOptional(jsonValue);

// Composable: Build reusable safe paths
var userNamePath = JsonValuePrisms.jsonObject()
    .andThen(JsonObjectLenses.fields())
    .andThen(mapValue("userLogin"))
    .andThen(JsonValuePrisms.jsonObject())
    // ... continue composition

// Efficient: Reuse prisms and composed paths
var stringPrism = JsonValuePrisms.jsonString();
var name1 = stringPrism.getOptional(value1);
var name2 = stringPrism.getOptional(value2);
var name3 = stringPrism.getOptional(value3);
</code></pre>
<hr />
<h2 id="performance-notes"><a class="header" href="#performance-notes">Performance Notes</a></h2>
<p>Prisms are optimised for type safety and composability:</p>
<ul>
<li><strong>Fast type checking</strong>: Prisms use <code>instanceof</code> under the hood, which is optimised by the JVM</li>
<li><strong>Lazy evaluation</strong>: Composed prisms only perform checks when needed</li>
<li><strong>Memory efficient</strong>: No boxing or wrapper allocation for failed matches</li>
<li><strong>Composable</strong>: Complex type-safe paths can be built once and reused</li>
</ul>
<p><strong>Best Practice</strong>: For frequently used prism combinations, create them once and store as constants:</p>
<pre><code class="language-java">public class JsonOptics {
    public static final Prism&lt;JsonValue, JsonString&gt; STRING = 
        JsonValuePrisms.jsonString();
  
    public static final Traversal&lt;JsonValue, String&gt; STRING_VALUE = 
        STRING.andThen(JsonStringLenses.value());
  
    public static final Traversal&lt;JsonObject, String&gt; USER_NAME = 
        fieldsLens.asTraversal()
            .andThen(Traversals.forMap("userLogin"))
            .andThen(JsonValuePrisms.jsonObject().asTraversal())
            .andThen(fieldsLens.asTraversal())
            .andThen(Traversals.forMap("name"))
            .andThen(STRING.asTraversal())
            .andThen(JsonStringLenses.value().asTraversal());
}
</code></pre>
<h2 id="real-world-example-api-response-handling"><a class="header" href="#real-world-example-api-response-handling">Real-World Example: API Response Handling</a></h2>
<p>Here's a practical example of using prisms to handle different API response types safely:</p>
<pre><code class="language-java">@GeneratePrisms
public sealed interface ApiResponse {}
public record SuccessResponse(String data, int statusCode) implements ApiResponse {}
public record ErrorResponse(String message, String errorCode) implements ApiResponse {}
public record TimeoutResponse(long timeoutMs) implements ApiResponse {}

public class ApiHandler {
    // Reusable prisms for different response types
    private static final Prism&lt;ApiResponse, SuccessResponse&gt; SUCCESS = 
        ApiResponsePrisms.successResponse();
    private static final Prism&lt;ApiResponse, ErrorResponse&gt; ERROR = 
        ApiResponsePrisms.errorResponse();
    private static final Prism&lt;ApiResponse, TimeoutResponse&gt; TIMEOUT = 
        ApiResponsePrisms.timeoutResponse();
  
    public String handleResponse(ApiResponse response) {
        // Type-safe extraction and handling
        return SUCCESS.getOptional(response)
            .map(success -&gt; "Success: " + success.data())
            .or(() -&gt; ERROR.getOptional(response)
                .map(error -&gt; "Error " + error.errorCode() + ": " + error.message()))
            .or(() -&gt; TIMEOUT.getOptional(response)
                .map(timeout -&gt; "Request timed out after " + timeout.timeoutMs() + "ms"))
            .orElse("Unknown response type");
    }
  
    // Use prisms for conditional processing
    public boolean isRetryable(ApiResponse response) {
        return ERROR.getOptional(response)
            .map(error -&gt; "RATE_LIMIT".equals(error.errorCode()) || "TEMPORARY".equals(error.errorCode()))
            .or(() -&gt; TIMEOUT.getOptional(response).map(t -&gt; true))
            .orElse(false);
    }
}
</code></pre>
<h2 id="complete-runnable-example"><a class="header" href="#complete-runnable-example">Complete, Runnable Example</a></h2>
<p>This example puts it all together, showing how to use the composed <code>Traversal</code> to perform a safe update.</p>
<pre><code class="language-java">package org.higherkindedj.example.prism;

import org.higherkindedj.optics.Lens;
import org.higherkindedj.optics.Prism;
import org.higherkindedj.optics.Traversal;
import org.higherkindedj.optics.annotations.GenerateLenses;
import org.higherkindedj.optics.annotations.GeneratePrisms;
import org.higherkindedj.optics.util.Traversals;
import java.util.*;

public class PrismUsageExample {

    // 1. Define the nested data model with sum types.
    @GeneratePrisms
    public sealed interface JsonValue {}
    public record JsonString(String value) implements JsonValue {}
    public record JsonNumber(double value) implements JsonValue {}
  
    @GenerateLenses
    public record JsonObject(Map&lt;String, JsonValue&gt; fields) implements JsonValue {}


    public static void main(String[] args) {
        // 2. Create the initial nested structure.
        var userData = Map.of(
            "userLogin", new JsonObject(Map.of(
                "name", new JsonString("Alice"),
                "age", new JsonNumber(30),
                "active", new JsonBoolean(true)
            )),
            "metadata", new JsonObject(Map.of(
                "version", new JsonString("1.0")
            ))
        );
        var data = new JsonObject(userData);
    
        System.out.println("Original Data: " + data);
        System.out.println("------------------------------------------");


        // 3. Get the generated and manually created optics.
        Prism&lt;JsonValue, JsonObject&gt; jsonObjectPrism = JsonValuePrisms.jsonObject();
        Prism&lt;JsonValue, JsonString&gt; jsonStringPrism = JsonValuePrisms.jsonString();
        Lens&lt;JsonObject, Map&lt;String, JsonValue&gt;&gt; fieldsLens = JsonObjectLenses.fields();
        Lens&lt;JsonString, String&gt; jsonStringValueLens = Lens.of(JsonString::value, (js, s) -&gt; new JsonString(s));
    
        // 4. Demonstrate individual prism operations
        System.out.println("--- Individual Prism Operations ---");
    
        // Safe type extraction
        JsonValue userValue = data.fields().get("userLogin");
        Optional&lt;JsonObject&gt; userObject = jsonObjectPrism.getOptional(userValue);
        System.out.println("User object: " + userObject);
    
        // Attempting to extract wrong type
        JsonValue nameValue = ((JsonObject) userValue).fields().get("name");
        Optional&lt;JsonNumber&gt; nameAsNumber = JsonValuePrisms.jsonNumber().getOptional(nameValue);
        System.out.println("Name as number (should be empty): " + nameAsNumber);
    
        // Building new values
        JsonValue newString = jsonStringPrism.build(new JsonString("Bob"));
        System.out.println("Built new string: " + newString);
        System.out.println("------------------------------------------");
    
        // 5. Compose the full traversal.
        Traversal&lt;JsonObject, String&gt; userToJsonName =
            fieldsLens.asTraversal()
                .andThen(Traversals.forMap("userLogin")) 
                .andThen(jsonObjectPrism.asTraversal())
                .andThen(fieldsLens.asTraversal())
                .andThen(Traversals.forMap("name"))
                .andThen(jsonStringPrism.asTraversal())
                .andThen(jsonStringValueLens.asTraversal());

          // 6. Use the composed traversal to perform safe updates
        JsonObject updatedData = Traversals.modify(userNameTraversal, String::toUpperCase, data);
        System.out.println("After safe `modify`:  " + updatedData);
    
        // 7. Demonstrate that the traversal safely handles missing paths
        var dataWithoutUser = new JsonObject(Map.of("metadata", new JsonString("test")));
        JsonObject safeUpdate = Traversals.modify(userNameTraversal, String::toUpperCase, dataWithoutUser);
        System.out.println("Safe update on missing path: " + safeUpdate);
    
        System.out.println("Original is unchanged: " + data);
        System.out.println("------------------------------------------");
    
        // 8. Demonstrate error-resistant operations
        System.out.println("--- Error-Resistant Operations ---");
    
        // Get all string values safely
        List&lt;String&gt; allStrings = List.of(
            new JsonString("hello"),
            new JsonNumber(42),
            new JsonString("world"),
            new JsonBoolean(true)
        ).stream()
        .map(jsonStringPrism::getOptional)
        .filter(Optional::isPresent)
        .map(Optional::get)
        .map(JsonString::value)
        .toList();
    
        System.out.println("Extracted strings only: " + allStrings);
    }
}
</code></pre>
<p><strong>Expected Output:</strong></p>
<pre><code>Original Data: JsonObject[fields={userLogin=JsonObject[fields={name=JsonString[value=Alice], age=JsonNumber[value=30.0], active=JsonBoolean[value=true]}], metadata=JsonObject[fields={version=JsonString[value=1.0]}]}]
------------------------------------------
--- Individual Prism Operations ---
User object: Optional[JsonObject[fields={name=JsonString[value=Alice], age=JsonNumber[value=30.0], active=JsonBoolean[value=true]}]]
Name as number (should be empty): Optional.empty
Built new string: JsonString[value=Bob]
------------------------------------------
--- Composed Traversal Operations ---
After safe `modify`:  JsonObject[fields={userLogin=JsonObject[fields={name=JsonString[value=ALICE], age=JsonNumber[value=30.0], active=JsonBoolean[value=true]}], metadata=JsonObject[fields={version=JsonString[value=1.0]}]}]
Safe update on missing path: JsonObject[fields={metadata=JsonString[value=test]}]
Original is unchanged: JsonObject[fields={userLogin=JsonObject[fields={name=JsonString[value=Alice], age=JsonNumber[value=30.0], active=JsonBoolean[value=true]}], metadata=JsonObject[fields={version=JsonString[value=1.0]}]}]
------------------------------------------
--- Error-Resistant Operations ---
Extracted strings only: [hello, world]
</code></pre>
<hr />
<h2 id="prism-convenience-methods"><a class="header" href="#prism-convenience-methods">Prism Convenience Methods</a></h2>
<h3 id="streamlined-operations-for-common-patterns"><a class="header" href="#streamlined-operations-for-common-patterns"><em>Streamlined Operations for Common Patterns</em></a></h3>
<p>Whilst <code>getOptional()</code> and <code>build()</code> are the core operations, the <code>Prism</code> interface provides several convenience methods that make everyday tasks more ergonomic and expressive.</p>
<p><strong>Quick Reference:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Purpose</th><th>Returns</th></tr></thead><tbody>
<tr><td><code>matches(S source)</code></td><td>Check if prism matches without extraction</td><td><code>boolean</code></td></tr>
<tr><td><code>getOrElse(A default, S source)</code></td><td>Extract value or return default</td><td><code>A</code></td></tr>
<tr><td><code>mapOptional(Function&lt;A, B&gt; f, S source)</code></td><td>Transform matched value</td><td><code>Optional&lt;B&gt;</code></td></tr>
<tr><td><code>modify(Function&lt;A, A&gt; f, S source)</code></td><td>Modify if matches, else return original</td><td><code>S</code></td></tr>
<tr><td><code>modifyWhen(Predicate&lt;A&gt; p, Function&lt;A, A&gt; f, S source)</code></td><td>Modify only when predicate satisfied</td><td><code>S</code></td></tr>
<tr><td><code>setWhen(Predicate&lt;A&gt; p, A value, S source)</code></td><td>Set only when predicate satisfied</td><td><code>S</code></td></tr>
<tr><td><code>orElse(Prism&lt;S, A&gt; other)</code></td><td>Try this prism, then fallback</td><td><code>Prism&lt;S, A&gt;</code></td></tr>
</tbody></table>
</div>
<h3 id="type-checking-with-matches"><a class="header" href="#type-checking-with-matches">Type Checking with <code>matches()</code></a></h3>
<p>The <code>matches()</code> method provides a clean alternative to <code>getOptional(source).isPresent()</code>:</p>
<pre><code class="language-java">Prism&lt;JsonValue, JsonString&gt; stringPrism = JsonValuePrisms.jsonString();

// Clear, declarative type checking
if (stringPrism.matches(value)) {
    // Process as string
}

// Useful in streams and filters
List&lt;JsonValue&gt; onlyStrings = values.stream()
    .filter(stringPrism::matches)
    .collect(Collectors.toList());
</code></pre>
<p><strong>Real-World Example</strong>: Filtering polymorphic domain events:</p>
<pre><code class="language-java">@GeneratePrisms
sealed interface DomainEvent permits UserEvent, OrderEvent, PaymentEvent {}

// Business logic: process only payment events
public void processPayments(List&lt;DomainEvent&gt; events) {
    Prism&lt;DomainEvent, PaymentEvent&gt; paymentPrism =
        DomainEventPrisms.paymentEvent();

    long paymentCount = events.stream()
        .filter(paymentPrism::matches)
        .count();

    logger.info("Processing {} payment events", paymentCount);

    events.stream()
        .filter(paymentPrism::matches)
        .map(paymentPrism::getOptional)
        .flatMap(Optional::stream)
        .forEach(this::processPayment);
}
</code></pre>
<h3 id="default-values-with-getorelse"><a class="header" href="#default-values-with-getorelse">Default Values with <code>getOrElse()</code></a></h3>
<p>When you need fallback values, <code>getOrElse()</code> is more concise than <code>getOptional().orElse()</code>:</p>
<pre><code class="language-java">Prism&lt;ApiResponse, SuccessResponse&gt; successPrism =
    ApiResponsePrisms.successResponse();

// Extract success data or use default
String data = successPrism.getOrElse(
    new SuccessResponse("fallback", 200),
    response
).data();

// Particularly useful for configuration
Config config = Prisms.some()
    .getOrElse(Config.DEFAULT, optionalConfig);
</code></pre>
<p><strong>Real-World Example</strong>: Parsing user input with graceful degradation:</p>
<pre><code class="language-java">@GeneratePrisms
sealed interface ParsedValue permits IntValue, StringValue, InvalidValue {}

public int parseUserQuantity(String input, int defaultQty) {
    ParsedValue parsed = parseInput(input);

    Prism&lt;ParsedValue, IntValue&gt; intPrism = ParsedValuePrisms.intValue();

    // Extract integer or use sensible default
    return intPrism.getOrElse(
        new IntValue(defaultQty),
        parsed
    ).value();
}

// Application settings with fallback
public DatabaseConfig getDatabaseConfig(ApplicationConfig config) {
    Prism&lt;ConfigSource, DatabaseConfig&gt; dbConfigPrism =
        ConfigSourcePrisms.databaseConfig();

    return dbConfigPrism.getOrElse(
        DatabaseConfig.DEFAULT_POSTGRES,
        config.source()
    );
}
</code></pre>
<h3 id="transforming-matches-with-mapoptional"><a class="header" href="#transforming-matches-with-mapoptional">Transforming Matches with <code>mapOptional()</code></a></h3>
<p>The <code>mapOptional()</code> method transforms matched values without building them back into the source type:</p>
<pre><code class="language-java">Prism&lt;JsonValue, JsonNumber&gt; numberPrism = JsonValuePrisms.jsonNumber();

// Extract and transform in one operation
Optional&lt;String&gt; formatted = numberPrism.mapOptional(
    num -&gt; String.format("%.2f", num.value()),
    jsonValue
);

// Compose transformations
Optional&lt;Boolean&gt; isLarge = numberPrism.mapOptional(
    num -&gt; num.value() &gt; 1000,
    jsonValue
);
</code></pre>
<p><strong>Real-World Example</strong>: ETL data transformation pipeline:</p>
<pre><code class="language-java">@GeneratePrisms
sealed interface SourceData permits CsvRow, JsonObject, XmlNode {}

public List&lt;CustomerRecord&gt; extractCustomers(List&lt;SourceData&gt; sources) {
    Prism&lt;SourceData, CsvRow&gt; csvPrism = SourceDataPrisms.csvRow();

    return sources.stream()
        .map(source -&gt; csvPrism.mapOptional(
            csv -&gt; new CustomerRecord(
                csv.column("customer_id"),
                csv.column("name"),
                csv.column("email")
            ),
            source
        ))
        .flatMap(Optional::stream)
        .collect(Collectors.toList());
}

// Extract business metrics from polymorphic events
public Optional&lt;BigDecimal&gt; extractRevenue(DomainEvent event) {
    Prism&lt;DomainEvent, OrderCompleted&gt; orderPrism =
        DomainEventPrisms.orderCompleted();

    return orderPrism.mapOptional(
        order -&gt; order.lineItems().stream()
            .map(LineItem::totalPrice)
            .reduce(BigDecimal.ZERO, BigDecimal::add),
        event
    );
}
</code></pre>
<h3 id="simple-modifications-with-modify"><a class="header" href="#simple-modifications-with-modify">Simple Modifications with <code>modify()</code></a></h3>
<p>Instead of manually calling <code>getOptional().map(f).map(build)</code>, use <code>modify()</code>:</p>
<pre><code class="language-java">Prism&lt;JsonValue, JsonString&gt; stringPrism = JsonValuePrisms.jsonString();

// Clean modification
JsonValue uppercased = stringPrism.modify(
    str -&gt; new JsonString(str.value().toUpperCase()),
    jsonValue
);

// Verbose alternative
JsonValue verboseResult = stringPrism.getOptional(jsonValue)
    .map(str -&gt; new JsonString(str.value().toUpperCase()))
    .map(stringPrism::build)
    .orElse(jsonValue);
</code></pre>
<p>If the prism doesn't match, <code>modify()</code> safely returns the original structure unchanged.</p>
<h3 id="conditional-operations-with-modifywhen-and-setwhen"><a class="header" href="#conditional-operations-with-modifywhen-and-setwhen">Conditional Operations with <code>modifyWhen()</code> and <code>setWhen()</code></a></h3>
<p>These methods combine matching with predicate-based filtering:</p>
<pre><code class="language-java">Prism&lt;ConfigValue, StringConfig&gt; stringConfig =
    ConfigValuePrisms.stringConfig();

// Only modify non-empty strings
ConfigValue sanitised = stringConfig.modifyWhen(
    str -&gt; !str.value().isEmpty(),
    str -&gt; new StringConfig(str.value().trim()),
    configValue
);

// Only update if validation passes
ConfigValue validated = stringConfig.setWhen(
    str -&gt; str.value().length() &lt;= 255,
    new StringConfig("validated"),
    configValue
);
</code></pre>
<p><strong>Real-World Example</strong>: Business rule enforcement in order processing:</p>
<pre><code class="language-java">@GeneratePrisms
sealed interface OrderStatus permits Draft, Submitted, Approved, Rejected {}

public class OrderProcessor {
    private static final Prism&lt;OrderStatus, Submitted&gt; SUBMITTED =
        OrderStatusPrisms.submitted();

    // Only approve orders above minimum value
    public OrderStatus approveIfEligible(
        OrderStatus status,
        BigDecimal orderValue,
        BigDecimal minValue
    ) {
        return SUBMITTED.setWhen(
            submitted -&gt; orderValue.compareTo(minValue) &gt;= 0,
            new Approved(Instant.now(), "AUTO_APPROVED"),
            status
        );
    }

    // Apply discount only to high-value draft orders
    public OrderStatus applyVipDiscount(OrderStatus status, Order order) {
        Prism&lt;OrderStatus, Draft&gt; draftPrism = OrderStatusPrisms.draft();

        return draftPrism.modifyWhen(
            draft -&gt; order.totalValue().compareTo(VIP_THRESHOLD) &gt; 0,
            draft -&gt; draft.withDiscount(VIP_DISCOUNT_RATE),
            status
        );
    }
}
</code></pre>
<p><strong>Use Cases:</strong></p>
<ul>
<li><strong>Conditional validation</strong>: Update only if current value meets criteria</li>
<li><strong>Guarded transformations</strong>: Apply changes only to valid states</li>
<li><strong>Business rules</strong>: Enforce constraints during updates</li>
<li><strong>Workflow automation</strong>: Apply state transitions based on business logic</li>
</ul>
<h3 id="fallback-matching-with-orelse"><a class="header" href="#fallback-matching-with-orelse">Fallback Matching with <code>orElse()</code></a></h3>
<p>The <code>orElse()</code> method chains prisms to try multiple matches:</p>
<pre><code class="language-java">Prism&lt;JsonValue, JsonNumber&gt; intPrism = JsonValuePrisms.jsonInt();
Prism&lt;JsonValue, JsonNumber&gt; doublePrism = JsonValuePrisms.jsonDouble();

// Try int first, fall back to double
Prism&lt;JsonValue, JsonNumber&gt; anyNumber = intPrism.orElse(doublePrism);

Optional&lt;JsonNumber&gt; result = anyNumber.getOptional(jsonValue);
// Matches either integer or double JSON values

// Building always uses the first prism's constructor
JsonValue built = anyNumber.build(new JsonNumber(42)); // Uses intPrism.build
</code></pre>
<p><strong>Real-World Example</strong>: Handling multiple error types in API responses:</p>
<pre><code class="language-java">Prism&lt;ApiResponse, String&gt; errorMessage =
    ApiResponsePrisms.validationError()
        .andThen(ValidationErrorLenses.message())
        .orElse(
            ApiResponsePrisms.serverError()
                .andThen(ServerErrorLenses.message())
        );

// Extracts error message from either error type
Optional&lt;String&gt; message = errorMessage.getOptional(response);
</code></pre>
<div id="admonition-when-to-use-convenience-methods" class="admonition admonish-tip" role="note" aria-labelledby="admonition-when-to-use-convenience-methods-title">
<div class="admonition-title">
<div id="admonition-when-to-use-convenience-methods-title">
<p>When to Use Convenience Methods</p>
</div>
<a class="admonition-anchor-link" href="#admonition-when-to-use-convenience-methods"></a>
</div>
<div>
<ul>
<li><strong>matches()</strong>: Type guards, stream filters, conditional logic</li>
<li><strong>getOrElse()</strong>: Configuration, default values, fallback data</li>
<li><strong>mapOptional()</strong>: Projections, transformations without reconstruction</li>
<li><strong>modify()</strong>: Simple transformations of matching cases</li>
<li><strong>modifyWhen()</strong>: Conditional updates based on current state</li>
<li><strong>setWhen()</strong>: Guarded updates with validation</li>
<li><strong>orElse()</strong>: Handling multiple variants, fallback strategies</li>
</ul>
</div>
</div>
<hr />
<h2 id="common-prism-patterns-with-the-prisms-utility"><a class="header" href="#common-prism-patterns-with-the-prisms-utility">Common Prism Patterns with the Prisms Utility</a></h2>
<h3 id="ready-made-prisms-for-standard-types"><a class="header" href="#ready-made-prisms-for-standard-types"><em>Ready-Made Prisms for Standard Types</em></a></h3>
<p>The <code>Prisms</code> utility class (in <code>org.higherkindedj.optics.util</code>) provides factory methods for common prism patterns, saving you from writing boilerplate for standard Java types.</p>
<p><strong>Quick Reference:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Factory Method</th><th>Type Signature</th><th>Use Case</th></tr></thead><tbody>
<tr><td><code>some()</code></td><td><code>Prism&lt;Optional&lt;A&gt;, A&gt;</code></td><td>Extract present Optional values</td></tr>
<tr><td><code>left()</code></td><td><code>Prism&lt;Either&lt;L, R&gt;, L&gt;</code></td><td>Focus on Left case</td></tr>
<tr><td><code>right()</code></td><td><code>Prism&lt;Either&lt;L, R&gt;, R&gt;</code></td><td>Focus on Right case</td></tr>
<tr><td><code>only(A value)</code></td><td><code>Prism&lt;A, Unit&gt;</code></td><td>Match specific value</td></tr>
<tr><td><code>notNull()</code></td><td><code>Prism&lt;@Nullable A, A&gt;</code></td><td>Filter null values</td></tr>
<tr><td><code>instanceOf(Class&lt;A&gt;)</code></td><td><code>Prism&lt;S, A&gt;</code></td><td>Safe type-based casting</td></tr>
<tr><td><code>listHead()</code></td><td><code>Prism&lt;List&lt;A&gt;, A&gt;</code></td><td>First element (if exists)</td></tr>
<tr><td><code>listLast()</code></td><td><code>Prism&lt;List&lt;A&gt;, A&gt;</code></td><td>Last element (if exists)</td></tr>
<tr><td><code>listAt(int)</code></td><td><code>Prism&lt;List&lt;A&gt;, A&gt;</code></td><td>Element at index (read-only)</td></tr>
</tbody></table>
</div>
<h3 id="working-with-optional-prismssome"><a class="header" href="#working-with-optional-prismssome">Working with Optional: <code>Prisms.some()</code></a></h3>
<pre><code class="language-java">import org.higherkindedj.optics.util.Prisms;

Prism&lt;Optional&lt;String&gt;, String&gt; somePrism = Prisms.some();

Optional&lt;String&gt; present = Optional.of("hello");
Optional&lt;String&gt; value = somePrism.getOptional(present); // Optional.of("hello")

Optional&lt;String&gt; empty = Optional.empty();
Optional&lt;String&gt; noMatch = somePrism.getOptional(empty); // Optional.empty()

// Useful for nested Optionals
Optional&lt;Optional&lt;Config&gt;&gt; nestedConfig = loadConfig();
Optional&lt;Config&gt; flattened = somePrism.getOptional(nestedConfig)
    .flatMap(Function.identity());
</code></pre>
<h3 id="either-case-handling-prismsleft-and-prismsright"><a class="header" href="#either-case-handling-prismsleft-and-prismsright">Either Case Handling: <code>Prisms.left()</code> and <code>Prisms.right()</code></a></h3>
<pre><code class="language-java">Prism&lt;Either&lt;String, Integer&gt;, String&gt; leftPrism = Prisms.left();
Prism&lt;Either&lt;String, Integer&gt;, Integer&gt; rightPrism = Prisms.right();

Either&lt;String, Integer&gt; error = Either.left("Failed");
Optional&lt;String&gt; errorMsg = leftPrism.getOptional(error); // Optional.of("Failed")
Optional&lt;Integer&gt; noValue = rightPrism.getOptional(error); // Optional.empty()

// Compose with lenses for deep access
record ValidationError(String code, String message) {}
Lens&lt;ValidationError, String&gt; messageLens = ValidationErrorLenses.message();

Prism&lt;Either&lt;ValidationError, Data&gt;, String&gt; errorMessage =
    Prisms.&lt;ValidationError, Data&gt;left()
        .andThen(messageLens);

Either&lt;ValidationError, Data&gt; result = validate(data);
Optional&lt;String&gt; msg = errorMessage.getOptional(result);
</code></pre>
<h3 id="sentinel-values-prismsonly"><a class="header" href="#sentinel-values-prismsonly">Sentinel Values: <code>Prisms.only()</code></a></h3>
<p>Perfect for matching specific constant values:</p>
<pre><code class="language-java">Prism&lt;String, Unit&gt; httpOkPrism = Prisms.only("200 OK");

// Check for specific status
if (httpOkPrism.matches(statusCode)) {
    // Handle success case
}

// Filter for specific values
List&lt;String&gt; onlyErrors = statusCodes.stream()
    .filter(Prisms.only("500 ERROR")::matches)
    .collect(Collectors.toList());

// Null sentinel handling
Prism&lt;String, Unit&gt; nullPrism = Prisms.only(null);
boolean isNull = nullPrism.matches(value);
</code></pre>
<h3 id="null-safety-prismsnotnull"><a class="header" href="#null-safety-prismsnotnull">Null Safety: <code>Prisms.notNull()</code></a></h3>
<pre><code class="language-java">Prism&lt;String, String&gt; notNullPrism = Prisms.notNull();

// Safe extraction
@Nullable String nullable = getDatabaseValue();
Optional&lt;String&gt; safe = notNullPrism.getOptional(nullable);

// Compose to filter null values in pipelines
Traversal&lt;List&lt;String&gt;, String&gt; nonNullStrings =
    Traversals.&lt;String&gt;forList()
        .andThen(Prisms.&lt;String&gt;notNull().asTraversal());

List&lt;@Nullable String&gt; mixedList = List.of("hello", null, "world", null);
List&lt;String&gt; filtered = Traversals.getAll(nonNullStrings, mixedList);
// Result: ["hello", "world"]
</code></pre>
<h3 id="type-safe-casting-prismsinstanceof"><a class="header" href="#type-safe-casting-prismsinstanceof">Type-Safe Casting: <code>Prisms.instanceOf()</code></a></h3>
<p>Elegant alternative to <code>instanceof</code> checks in type hierarchies:</p>
<pre><code class="language-java">sealed interface Animal permits Dog, Cat, Bird {}
record Dog(String name, String breed) implements Animal {}
record Cat(String name, int lives) implements Animal {}
record Bird(String name, boolean canFly) implements Animal {}

Prism&lt;Animal, Dog&gt; dogPrism = Prisms.instanceOf(Dog.class);

Animal animal = new Dog("Buddy", "Labrador");
Optional&lt;Dog&gt; maybeDog = dogPrism.getOptional(animal); // Optional.of(Dog(...))

// Compose with lenses for deep access
Lens&lt;Dog, String&gt; breedLens = DogLenses.breed();
Traversal&lt;Animal, String&gt; dogBreed =
    dogPrism.asTraversal().andThen(breedLens.asTraversal());

List&lt;Animal&gt; animals = List.of(
    new Dog("Rex", "German Shepherd"),
    new Cat("Whiskers", 9),
    new Dog("Max", "Beagle")
);

List&lt;String&gt; breeds = Traversals.getAll(
    Traversals.&lt;Animal&gt;forList().andThen(dogBreed),
    animals
);
// Result: ["German Shepherd", "Beagle"]
</code></pre>
<h3 id="collection-element-access"><a class="header" href="#collection-element-access">Collection Element Access</a></h3>
<pre><code class="language-java">// First element (if list is non-empty)
Prism&lt;List&lt;String&gt;, String&gt; headPrism = Prisms.listHead();
List&lt;String&gt; names = List.of("Alice", "Bob", "Charlie");
Optional&lt;String&gt; first = headPrism.getOptional(names); // Optional.of("Alice")

// Last element
Prism&lt;List&lt;String&gt;, String&gt; lastPrism = Prisms.listLast();
Optional&lt;String&gt; last = lastPrism.getOptional(names); // Optional.of("Charlie")

// Element at specific index (read-only for queries)
Prism&lt;List&lt;String&gt;, String&gt; secondPrism = Prisms.listAt(1);
Optional&lt;String&gt; second = secondPrism.getOptional(names); // Optional.of("Bob")

// Safe access patterns
String firstOrDefault = headPrism.getOrElse("Unknown", names);
boolean hasList = headPrism.matches(names);
</code></pre>
<div id="admonition-list-prism-limitations" class="admonition admonish-warning" role="note" aria-labelledby="admonition-list-prism-limitations-title">
<div class="admonition-title">
<div id="admonition-list-prism-limitations-title">
<p>List Prism Limitations</p>
</div>
<a class="admonition-anchor-link" href="#admonition-list-prism-limitations"></a>
</div>
<div>
<p>The <code>listHead()</code> and <code>listLast()</code> prisms have limited <code>build()</code> operations: they create singleton lists. The <code>listAt(int)</code> prism throws <code>UnsupportedOperationException</code> on <code>build()</code> since there's no meaningful way to construct a complete list from a single indexed element.</p>
<p><strong>Use these prisms for:</strong></p>
<ul>
<li>Safe element extraction</li>
<li>Conditional checks (with <code>matches()</code>)</li>
<li>Query operations (with <code>getOptional()</code>)</li>
</ul>
<p><strong>For list modification</strong>, use <code>Traversal</code> or <code>Lens</code> instead:</p>
<pre><code class="language-java">// ‚úÖ For modifications, use proper traversals
Lens&lt;List&lt;String&gt;, String&gt; firstLens = listFirstElementLens();
List&lt;String&gt; updated = firstLens.modify(String::toUpperCase, names);
</code></pre>
</div>
</div>
<h3 id="composing-utility-prisms"><a class="header" href="#composing-utility-prisms">Composing Utility Prisms</a></h3>
<p>The real power emerges when composing these utility prisms with your domain optics:</p>
<pre><code class="language-java">record Config(Optional&lt;Either&lt;String, DatabaseSettings&gt;&gt; database) {}
record DatabaseSettings(String host, int port) {}

// Build a path through Optional -&gt; Either -&gt; Settings -&gt; host
Prism&lt;Config, String&gt; databaseHost =
    ConfigLenses.database()                    // Lens&lt;Config, Optional&lt;Either&lt;...&gt;&gt;&gt;
        .asTraversal()
        .andThen(Prisms.some().asTraversal())  // -&gt; Either&lt;String, DatabaseSettings&gt;
        .andThen(Prisms.right().asTraversal()) // -&gt; DatabaseSettings
        .andThen(DatabaseSettingsLenses.host().asTraversal()); // -&gt; String

Config config = loadConfig();
Optional&lt;String&gt; host = Traversals.getAll(databaseHost, config)
    .stream().findFirst();
</code></pre>
<div id="admonition-performance-considerations" class="admonition admonish-tip" role="note" aria-labelledby="admonition-performance-considerations-title">
<div class="admonition-title">
<div id="admonition-performance-considerations-title">
<p>Performance Considerations</p>
</div>
<a class="admonition-anchor-link" href="#admonition-performance-considerations"></a>
</div>
<div>
<p>Utility prisms are lightweight and stateless; they're safe to create on-demand or cache as constants:</p>
<pre><code class="language-java">public class AppPrisms {
    public static final Prism&lt;Optional&lt;User&gt;, User&gt; SOME_USER = Prisms.some();
    public static final Prism&lt;Response, SuccessResponse&gt; SUCCESS =
        Prisms.instanceOf(SuccessResponse.class);
}
</code></pre>
</div>
</div>
<hr />
<h2 id="why-prisms-are-essential"><a class="header" href="#why-prisms-are-essential">Why Prisms are Essential</a></h2>
<p><code>Lens</code> handles the "what" and <code>Prism</code> handles the "what if." Together, they allow you to model and operate on virtually any immutable data structure you can design. Prisms are essential for:</p>
<ul>
<li><strong>Safety</strong>: Eliminating <code>instanceof</code> checks and unsafe casts.</li>
<li><strong>Clarity</strong>: Expressing failable focus in a clean, functional way.</li>
<li><strong>Composability</strong>: Combining checks for different data shapes into a single, reusable optic.</li>
<li><strong>Maintainability</strong>: Creating type-safe paths that won't break when data structures evolve.</li>
</ul>
<p>By adding Prisms to your toolkit, you can write even more robust, declarative, and maintainable code that gracefully handles the complexity of real-world data structures.</p>
<div id="admonition-ready-for-more" class="admonition admonish-tip" role="note" aria-labelledby="admonition-ready-for-more-title">
<div class="admonition-title">
<div id="admonition-ready-for-more-title">
<p>Ready for More?</p>
</div>
<a class="admonition-anchor-link" href="#admonition-ready-for-more"></a>
</div>
<div>
<p>Once you're comfortable with these prism fundamentals, explore <a href="advanced_prism_patterns.html">Advanced Prism Patterns</a> for production-ready patterns including:</p>
<ul>
<li>Configuration management with layered prism composition</li>
<li>API response handling with type-safe error recovery</li>
<li>Data validation pipelines and event processing systems</li>
<li>State machine implementations and plugin architectures</li>
<li>Performance optimisation and testing strategies</li>
</ul>
</div>
</div>
<div id="admonition-for-comprehension-integration" class="admonition admonish-tip" role="note" aria-labelledby="admonition-for-comprehension-integration-title">
<div class="admonition-title">
<div id="admonition-for-comprehension-integration-title">
<p>For Comprehension Integration</p>
</div>
<a class="admonition-anchor-link" href="#admonition-for-comprehension-integration"></a>
</div>
<div>
<p>Prisms integrate with For comprehensions via the <code>match()</code> operation, which provides prism-based pattern matching with short-circuit semantics. When the prism match fails, the computation short-circuits using the monad's zero value (empty list, Nothing, etc.). See <a href="../functional/for_comprehension.html#pattern-matching-with-match">For Comprehensions: Pattern Matching with match()</a>.</p>
</div>
</div>
<div id="admonition-hands-on-learning" class="admonition admonish-info" role="note" aria-labelledby="admonition-hands-on-learning-title">
<div class="admonition-title">
<div id="admonition-hands-on-learning-title">
<p>Hands-On Learning</p>
</div>
<a class="admonition-anchor-link" href="#admonition-hands-on-learning"></a>
</div>
<div>
<p>Practice prism basics in <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/optics/Tutorial03_PrismBasics.java">Tutorial 03: Prism Basics</a> (9 exercises, ~12 minutes).</p>
</div>
</div>
<hr />
<div id="admonition-further-reading" class="admonition admonish-tip" role="note" aria-labelledby="admonition-further-reading-title">
<div class="admonition-title">
<div id="admonition-further-reading-title">
<p>Further Reading</p>
</div>
<a class="admonition-anchor-link" href="#admonition-further-reading"></a>
</div>
<div>
<ul>
<li><strong>Monocle</strong>: <a href="https://www.optics.dev/Monocle/">Scala Optics Library</a> - Production-ready Scala optics with extensive examples</li>
<li><strong>Haskell Lens</strong>: <a href="https://hackage.haskell.org/package/lens">Canonical Reference</a> - The original comprehensive optics library</li>
<li><strong>Lens Tutorial</strong>: <a href="https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial">A Little Lens Starter Tutorial</a> - Beginner-friendly introduction</li>
</ul>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="lenses.html">Lenses: Working with Product Types</a>
<strong>Next:</strong> <a href="affine.html">Affines: Working with Optional Fields</a> | <a href="advanced_prism_patterns.html">Advanced Prism Patterns</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../optics/lenses.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../optics/affine.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../optics/lenses.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../optics/affine.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../version-switcher.js"></script>
        <script src=".././theme/version-switcher.js"></script>
        <script src=".././theme/sidebar-nav-link.js"></script>


    </div>
    </body>
</html>
