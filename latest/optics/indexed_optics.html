<!DOCTYPE HTML>
<html lang="en" class="latte sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Indexed Optics - Higher-Kinded-J: Composable Effects and Advanced Optics for Java</title>


        <!-- Custom HTML head -->


            <meta name="description" content="The most comprehensive functional programming library for Java. Unify error handling, optional values, and immutable data navigation with the Effect Path API and Focus DSL. Features advanced optics with code generation for Java records, filtered traversals, indexed optics, and seamless Spring Boot integration.">


        <meta name="keywords" content="Higher-Kinded Types, Higher-Kinded-J, HKT, Java, Optics, Lens, Prism, Traversal, Iso, Affine, Focus DSL, Effect Path API, Functional Programming, Monad, Functor, Applicative, EitherPath, MaybePath, TryPath, ValidationPath, Java Records, Sealed Interface, Error Handling, Immutable Data">
        
        <meta property="og:title" content="Indexed Optics - Higher-Kinded-J: Composable Effects and Advanced Optics for Java">
            <meta property="og:description" content="The most comprehensive functional programming library for Java. Unify error handling, optional values, and immutable data navigation with the Effect Path API and Focus DSL. Features advanced optics with code generation for Java records, filtered traversals, indexed optics, and seamless Spring Boot integration.">
        <meta property="og:type" content="website">
        <meta property="og:url" content="https://higher-kinded-j.github.io/">
        <meta property="og:image" content="https://higher-kinded-j.github.io/preview.png">
        <meta property="og:image:width" content="1200">
        <meta property="og:image:height" content="630">
        <meta property="og:site_name" content="Higher-Kinded-J Documentation">
        <meta property="og:locale" content="en_GB">
        
        <meta name="twitter:card" content="summary_large_image">
        <meta name="twitter:title" content="Indexed Optics - Higher-Kinded-J: Composable Effects and Advanced Optics for Java">
        <meta name="twitter:description" content="Unifying Composable Effects and Advanced Optics for Java. Effect Path API, Focus DSL, and the most comprehensive optics implementation in the Java ecosystem.">
        <meta name="twitter:image" content="https://higher-kinded-j.github.io/preview.png">
        <meta name="twitter:image:alt" content="Higher-Kinded-J: Composable Effects and Advanced Optics for Java">
        <meta name="description" content="The most comprehensive functional programming library for Java. Unify error handling, optional values, and immutable data navigation with the Effect Path API and Focus DSL. Features advanced optics with code generation for Java records, filtered traversals, indexed optics, and seamless Spring Boot integration.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">
        <meta name="google-site-verification" content="X-xsiAq2cKMLOzh9dexUrX8Onx2h_YMUFgp5lHHUwSg" />
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href=".././mdbook-admonish.css">
        <link rel="stylesheet" href=".././theme/catppuccin.css">
        <link rel="stylesheet" href=".././theme/catppuccin-admonish.css">
        <link rel="stylesheet" href=".././theme/catppuccin-alerts.css">
        <link rel="stylesheet" href=".././theme/additional-hkj.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "latte";
            const default_dark_theme = "macchiato";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('latte')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="latte">Latte</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="frappe">Frappé</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="macchiato">Macchiato</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mocha">Mocha</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        <div class="version-selector-container">
                            <select id="version-selector" class="version-selector" aria-label="Select documentation version" title="Select documentation version">
                                <option value="">Loading versions...</option>
                            </select>
                        </div>
                    </div>

                    <h1 class="menu-title">Higher-Kinded-J: Composable Effects and Advanced Optics for Java</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/higher-kinded-j/higher-kinded-j" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/higher-kinded-j/higher-kinded-j/edit/main/hkj-book/src/optics/indexed_optics.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="indexed-optics-position-aware-operations"><a class="header" href="#indexed-optics-position-aware-operations">Indexed Optics: Position-Aware Operations</a></h1>
<h2 id="tracking-indices-during-transformations"><a class="header" href="#tracking-indices-during-transformations"><em>Tracking Indices During Transformations</em></a></h2>
<p><img src="../images/indexed-optics.jpg" alt="indexed-optics.jpg" /></p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to access both index and value during optic operations</li>
<li>Using IndexedTraversal for position-aware bulk updates</li>
<li>Using IndexedFold for queries that need position information</li>
<li>Using IndexedLens for field name tracking and debugging</li>
<li>Creating indexed traversals for Lists and Maps with IndexedTraversals utility</li>
<li>Composing indexed optics with paired indices (Pair&lt;I, J&gt;)</li>
<li>Converting between indexed and non-indexed optics</li>
<li>When to use indexed optics vs standard optics</li>
<li>Real-world patterns for debugging, audit trails, and position-based logic</li>
</ul>
</div>
</div>
<div id="admonition-example-code" class="admonition admonish-note" role="note" aria-labelledby="admonition-example-code-title">
<div class="admonition-title">
<div id="admonition-example-code-title">
<p>Example Code</p>
</div>
<a class="admonition-anchor-link" href="#admonition-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/IndexedOpticsExample.java">IndexedOpticsExample</a></p>
</div>
</div>
<p>In our journey through optics, we've mastered how to focus on parts of immutable data structures, whether it's a single field with <strong>Lens</strong>, an optional value with <strong>Prism</strong>, or multiple elements with <strong>Traversal</strong>. But sometimes, knowing <em>where</em> you are is just as important as knowing <em>what</em> you're looking at.</p>
<p>Consider these scenarios:</p>
<ul>
<li><strong>Numbering items</strong> in a packing list: "Item 1: Laptop, Item 2: Mouse..."</li>
<li><strong>Tracking field names</strong> for audit logs: "User modified field 'email' from..."</li>
<li><strong>Processing map entries</strong> where both key and value matter: "For metadata key 'priority', set value to..."</li>
<li><strong>Debugging nested updates</strong> by seeing the complete path: "Changed scores[2] from 100 to 150"</li>
</ul>
<p>Standard optics give you the <em>value</em>. <strong>Indexed optics</strong> give you both the <em>index</em> and the <em>value</em>.</p>
<hr />
<h2 id="the-scenario-e-commerce-order-processing"><a class="header" href="#the-scenario-e-commerce-order-processing">The Scenario: E-Commerce Order Processing</a></h2>
<p>Imagine building an order fulfilment system where position information drives business logic.</p>
<p><strong>The Data Model:</strong></p>
<pre><code class="language-java">@GenerateLenses
public record LineItem(String productName, int quantity, double price) {}

@GenerateLenses
@GenerateTraversals
public record Order(String orderId, List&lt;LineItem&gt; items, Map&lt;String, String&gt; metadata) {}

@GenerateLenses
public record Customer(String name, String email) {}
</code></pre>
<p><strong>Business Requirements:</strong></p>
<ol>
<li><strong>Generate packing slips</strong> with numbered items: "Item 1: Laptop (£999.99)"</li>
<li><strong>Process metadata</strong> with key awareness: "Set shipping method based on 'priority' key"</li>
<li><strong>Audit trail</strong> showing which fields were modified: "Updated Customer.email at 2025-01-15 10:30"</li>
<li><strong>Position-based pricing</strong> for bulk orders: "Items at even positions get 10% discount"</li>
</ol>
<p><strong>The Traditional Approach:</strong></p>
<pre><code class="language-java">// Verbose: Manual index tracking
List&lt;String&gt; packingSlip = new ArrayList&lt;&gt;();
for (int i = 0; i &lt; order.items().size(); i++) {
    LineItem item = order.items().get(i);
    packingSlip.add("Item " + (i + 1) + ": " + item.productName());
}

// Or with streams, losing type-safety
AtomicInteger counter = new AtomicInteger(1);
order.items().stream()
    .map(item -&gt; "Item " + counter.getAndIncrement() + ": " + item.productName())
    .collect(toList());

// Map processing requires breaking into entries
order.metadata().entrySet().stream()
    .map(entry -&gt; processWithKey(entry.getKey(), entry.getValue()))
    .collect(toMap(Entry::getKey, Entry::getValue));
</code></pre>
<p>This approach forces manual index management, mixing the <em>what</em> (transformation logic) with the <em>how</em> (index tracking). <strong>Indexed optics</strong> provide a declarative, type-safe solution.</p>
<hr />
<h2 id="think-of-indexed-optics-like"><a class="header" href="#think-of-indexed-optics-like">Think of Indexed Optics Like...</a></h2>
<ul>
<li><strong>GPS coordinates</strong>: Not just the destination, but the latitude and longitude</li>
<li><strong>Line numbers in an editor</strong>: Every line knows its position in the file</li>
<li><strong>Map.Entry</strong>: Provides both key and value instead of just the value</li>
<li><strong>Breadcrumbs in a file system</strong>: Showing the complete path to each file</li>
<li><strong>A numbered list</strong>: Each element has both content and a position</li>
<li><strong>Spreadsheet cells</strong>: Both the cell reference (A1, B2) and the value</li>
</ul>
<p>The key insight: indexed optics make <em>position</em> a first-class citizen, accessible during every operation.</p>
<hr />
<h2 id="part-i-the-basics"><a class="header" href="#part-i-the-basics">Part I: The Basics</a></h2>
<h3 id="the-three-indexed-optics"><a class="header" href="#the-three-indexed-optics">The Three Indexed Optics</a></h3>
<p>Higher-kinded-j provides three indexed optics that mirror their standard counterparts:</p>
<div class="table-wrapper"><table><thead><tr><th>Standard Optic</th><th>Indexed Variant</th><th>Index Type</th><th>Use Case</th></tr></thead><tbody>
<tr><td><strong>Traversal&lt;S, A&gt;</strong></td><td><strong>IndexedTraversal&lt;I, S, A&gt;</strong></td><td><code>I</code> (any type)</td><td>Position-aware bulk updates (List indices, Map keys)</td></tr>
<tr><td><strong>Fold&lt;S, A&gt;</strong></td><td><strong>IndexedFold&lt;I, S, A&gt;</strong></td><td><code>I</code> (any type)</td><td>Position-aware read-only queries</td></tr>
<tr><td><strong>Lens&lt;S, A&gt;</strong></td><td><strong>IndexedLens&lt;I, S, A&gt;</strong></td><td><code>I</code> (any type)</td><td>Field name tracking for single-field access</td></tr>
</tbody></table>
</div>
<p>The additional type parameter <code>I</code> represents the <strong>index type</strong>:</p>
<ul>
<li>For <code>List&lt;A&gt;</code>: <code>I</code> is <code>Integer</code> (position 0, 1, 2...)</li>
<li>For <code>Map&lt;K, V&gt;</code>: <code>I</code> is <code>K</code> (the key type)</li>
<li>For record fields: <code>I</code> is <code>String</code> (field name)</li>
<li>Custom: Any type that makes sense for your domain</li>
</ul>
<hr />
<h2 id="a-step-by-step-walkthrough"><a class="header" href="#a-step-by-step-walkthrough">A Step-by-Step Walkthrough</a></h2>
<h3 id="step-1-creating-indexed-traversals"><a class="header" href="#step-1-creating-indexed-traversals">Step 1: Creating Indexed Traversals</a></h3>
<p>The <code>IndexedTraversals</code> utility class provides factory methods for common cases.</p>
<h4 id="for-lists-integer-indices"><a class="header" href="#for-lists-integer-indices">For Lists: Integer Indices</a></h4>
<pre><code class="language-java">import org.higherkindedj.optics.indexed.IndexedTraversal;
import org.higherkindedj.optics.util.IndexedTraversals;

// Create an indexed traversal for List elements
IndexedTraversal&lt;Integer, List&lt;LineItem&gt;, LineItem&gt; itemsWithIndex =
    IndexedTraversals.forList();

List&lt;LineItem&gt; items = List.of(
    new LineItem("Laptop", 1, 999.99),
    new LineItem("Mouse", 2, 24.99),
    new LineItem("Keyboard", 1, 79.99)
);
</code></pre>
<p>The <code>forList()</code> factory creates a traversal where each element is paired with its zero-based index.</p>
<h4 id="for-maps-key-based-indices"><a class="header" href="#for-maps-key-based-indices">For Maps: Key-Based Indices</a></h4>
<pre><code class="language-java">// Create an indexed traversal for Map values
IndexedTraversal&lt;String, Map&lt;String, String&gt;, String&gt; metadataWithKeys =
    IndexedTraversals.forMap();

Map&lt;String, String&gt; metadata = Map.of(
    "priority", "express",
    "gift-wrap", "true",
    "delivery-note", "Leave at door"
);
</code></pre>
<p>The <code>forMap()</code> factory creates a traversal where each value is paired with its key.</p>
<div id="admonition-alternative-eacheachwithindex" class="admonition admonish-tip" role="note" aria-labelledby="admonition-alternative-eacheachwithindex-title">
<div class="admonition-title">
<div id="admonition-alternative-eacheachwithindex-title">
<p>Alternative: Each.eachWithIndex()</p>
</div>
<a class="admonition-anchor-link" href="#admonition-alternative-eacheachwithindex"></a>
</div>
<div>
<p>You can also obtain indexed traversals through the <a href="each_typeclass.html">Each typeclass</a>. If a container's <code>Each</code> instance supports indexed access, <code>eachWithIndex()</code> returns an <code>Optional&lt;IndexedTraversal&gt;</code>:</p>
<pre><code class="language-java">Each&lt;List&lt;String&gt;, String&gt; listEach = EachInstances.listEach();
listEach.&lt;Integer&gt;eachWithIndex().ifPresent(indexed -&gt; {
    // Use the indexed traversal
});
</code></pre>
<p>This is useful when working with custom containers that implement <code>Each</code> or when integrating with the Focus DSL.</p>
</div>
</div>
<hr />
<h3 id="step-2-accessing-index-value-pairs"><a class="header" href="#step-2-accessing-index-value-pairs">Step 2: Accessing Index-Value Pairs</a></h3>
<p>Indexed optics provide specialized methods that give you access to both the index and the value.</p>
<h4 id="extracting-all-index-value-pairs"><a class="header" href="#extracting-all-index-value-pairs">Extracting All Index-Value Pairs</a></h4>
<pre><code class="language-java">import org.higherkindedj.optics.indexed.Pair;

// Get list of (index, item) pairs
List&lt;Pair&lt;Integer, LineItem&gt;&gt; indexedItems = itemsWithIndex.toIndexedList(items);

for (Pair&lt;Integer, LineItem&gt; pair : indexedItems) {
    int position = pair.first();
    LineItem item = pair.second();
    System.out.println("Position " + position + ": " + item.productName());
}
// Output:
// Position 0: Laptop
// Position 1: Mouse
// Position 2: Keyboard
</code></pre>
<h4 id="using-indexedfold-for-queries"><a class="header" href="#using-indexedfold-for-queries">Using IndexedFold for Queries</a></h4>
<pre><code class="language-java">import org.higherkindedj.optics.indexed.IndexedFold;

// Convert to read-only indexed fold
IndexedFold&lt;Integer, List&lt;LineItem&gt;, LineItem&gt; itemsFold =
    itemsWithIndex.asIndexedFold();

// Find item at a specific position
Pair&lt;Integer, LineItem&gt; found = itemsFold.findWithIndex(
    (index, item) -&gt; index == 1,
    items
).orElse(null);

System.out.println("Item at index 1: " + found.second().productName());
// Output: Item at index 1: Mouse

// Check if any even-positioned item is expensive
boolean hasExpensiveEven = itemsFold.existsWithIndex(
    (index, item) -&gt; index % 2 == 0 &amp;&amp; item.price() &gt; 500,
    items
);
</code></pre>
<hr />
<h3 id="step-3-position-aware-modifications"><a class="header" href="#step-3-position-aware-modifications">Step 3: Position-Aware Modifications</a></h3>
<p>The real power emerges when you modify elements based on their position.</p>
<h4 id="numbering-items-in-a-packing-slip"><a class="header" href="#numbering-items-in-a-packing-slip">Numbering Items in a Packing Slip</a></h4>
<pre><code class="language-java">// Modify product names to include position numbers
List&lt;LineItem&gt; numbered = IndexedTraversals.imodify(
    itemsWithIndex,
    (index, item) -&gt; new LineItem(
        "Item " + (index + 1) + ": " + item.productName(),
        item.quantity(),
        item.price()
    ),
    items
);

for (LineItem item : numbered) {
    System.out.println(item.productName());
}
// Output:
// Item 1: Laptop
// Item 2: Mouse
// Item 3: Keyboard
</code></pre>
<h4 id="position-based-discount-logic"><a class="header" href="#position-based-discount-logic">Position-Based Discount Logic</a></h4>
<pre><code class="language-java">// Apply 10% discount to items at even positions (0, 2, 4...)
List&lt;LineItem&gt; discounted = IndexedTraversals.imodify(
    itemsWithIndex,
    (index, item) -&gt; {
        if (index % 2 == 0) {
            double discountedPrice = item.price() * 0.9;
            return new LineItem(item.productName(), item.quantity(), discountedPrice);
        }
        return item;
    },
    items
);

// Position 0 (Laptop): £999.99 → £899.99
// Position 1 (Mouse): £24.99 (unchanged)
// Position 2 (Keyboard): £79.99 → £71.99
</code></pre>
<h4 id="map-processing-with-key-awareness"><a class="header" href="#map-processing-with-key-awareness">Map Processing with Key Awareness</a></h4>
<pre><code class="language-java">IndexedTraversal&lt;String, Map&lt;String, String&gt;, String&gt; metadataTraversal =
    IndexedTraversals.forMap();

Map&lt;String, String&gt; processed = IndexedTraversals.imodify(
    metadataTraversal,
    (key, value) -&gt; {
        // Add key prefix to all values for debugging
        return "[" + key + "] " + value;
    },
    metadata
);

// Results:
// "priority" → "[priority] express"
// "gift-wrap" → "[gift-wrap] true"
// "delivery-note" → "[delivery-note] Leave at door"
</code></pre>
<hr />
<h3 id="step-4-filtering-with-index-awareness"><a class="header" href="#step-4-filtering-with-index-awareness">Step 4: Filtering with Index Awareness</a></h3>
<p>Indexed traversals support filtering, allowing you to focus on specific positions or keys.</p>
<h4 id="filter-by-index"><a class="header" href="#filter-by-index">Filter by Index</a></h4>
<pre><code class="language-java">// Focus only on even-positioned items
IndexedTraversal&lt;Integer, List&lt;LineItem&gt;, LineItem&gt; evenPositions =
    itemsWithIndex.filterIndex(index -&gt; index % 2 == 0);

List&lt;Pair&lt;Integer, LineItem&gt;&gt; evenItems =
    IndexedTraversals.toIndexedList(evenPositions, items);
// Returns: [(0, Laptop), (2, Keyboard)]

// Modify only even-positioned items
List&lt;LineItem&gt; result = IndexedTraversals.imodify(
    evenPositions,
    (index, item) -&gt; new LineItem(
        item.productName() + " [SALE]",
        item.quantity(),
        item.price()
    ),
    items
);
// Laptop and Keyboard get "[SALE]" suffix, Mouse unchanged
</code></pre>
<h4 id="filter-by-value-with-index-available"><a class="header" href="#filter-by-value-with-index-available">Filter by Value with Index Available</a></h4>
<pre><code class="language-java">// Focus on expensive items, but still track their original positions
IndexedTraversal&lt;Integer, List&lt;LineItem&gt;, LineItem&gt; expensiveItems =
    itemsWithIndex.filteredWithIndex((index, item) -&gt; item.price() &gt; 50);

List&lt;Pair&lt;Integer, LineItem&gt;&gt; expensive =
    IndexedTraversals.toIndexedList(expensiveItems, items);
// Returns: [(0, Laptop), (2, Keyboard)]
// Notice: indices are preserved (0 and 2), not renumbered
</code></pre>
<h4 id="filter-map-by-key-pattern"><a class="header" href="#filter-map-by-key-pattern">Filter Map by Key Pattern</a></h4>
<pre><code class="language-java">// Focus on metadata keys starting with "delivery"
IndexedTraversal&lt;String, Map&lt;String, String&gt;, String&gt; deliveryMetadata =
    metadataTraversal.filterIndex(key -&gt; key.startsWith("delivery"));

List&lt;Pair&lt;String, String&gt;&gt; deliveryEntries =
    deliveryMetadata.toIndexedList(metadata);
// Returns: [("delivery-note", "Leave at door")]
</code></pre>
<hr />
<h3 id="step-5-indexedlens-for-field-tracking"><a class="header" href="#step-5-indexedlens-for-field-tracking">Step 5: IndexedLens for Field Tracking</a></h3>
<p>An <code>IndexedLens</code> focuses on exactly one field whilst providing its name or identifier.</p>
<pre><code class="language-java">import org.higherkindedj.optics.indexed.IndexedLens;

// Create an indexed lens for the customer email field
IndexedLens&lt;String, Customer, String&gt; emailLens = IndexedLens.of(
    "email",                 // The index: field name
    Customer::email,         // Getter
    (customer, newEmail) -&gt; new Customer(customer.name(), newEmail)  // Setter
);

Customer customer = new Customer("Alice", "alice@example.com");

// Get both field name and value
Pair&lt;String, String&gt; fieldInfo = emailLens.iget(customer);
System.out.println("Field: " + fieldInfo.first());      // email
System.out.println("Value: " + fieldInfo.second());     // alice@example.com

// Modify with field name awareness
Customer updated = emailLens.imodify(
    (fieldName, oldValue) -&gt; {
        System.out.println("Updating field '" + fieldName + "' from " + oldValue);
        return "alice.smith@example.com";
    },
    customer
);
// Output: Updating field 'email' from alice@example.com
</code></pre>
<p><strong>Use case</strong>: Audit logging that records <em>which</em> field changed, not just the new value.</p>
<hr />
<h3 id="step-6-converting-between-indexed-and-non-indexed"><a class="header" href="#step-6-converting-between-indexed-and-non-indexed">Step 6: Converting Between Indexed and Non-Indexed</a></h3>
<p>Every indexed optic can be converted to its standard (non-indexed) counterpart.</p>
<pre><code class="language-java">import org.higherkindedj.optics.Traversal;

// Start with indexed traversal
IndexedTraversal&lt;Integer, List&lt;LineItem&gt;, LineItem&gt; indexed =
    IndexedTraversals.forList();

// Drop the index to get a standard traversal
Traversal&lt;List&lt;LineItem&gt;, LineItem&gt; standard = indexed.unindexed();

// Now you can use standard traversal methods
List&lt;LineItem&gt; uppercased = Traversals.modify(
    standard.andThen(Lens.of(
        LineItem::productName,
        (item, name) -&gt; new LineItem(name, item.quantity(), item.price())
    ).asTraversal()),
    String::toUpperCase,
    items
);
</code></pre>
<p><strong>When to convert</strong>: When you need the index for <em>some</em> operations but not others, start indexed and convert as needed.</p>
<hr />
<h3 id="when-to-use-indexed-optics-vs-standard-optics"><a class="header" href="#when-to-use-indexed-optics-vs-standard-optics">When to Use Indexed Optics vs Standard Optics</a></h3>
<p>Understanding when indexed optics add value is crucial for writing clear, maintainable code.</p>
<h4 id="use-indexed-optics-when"><a class="header" href="#use-indexed-optics-when">Use Indexed Optics When:</a></h4>
<ul>
<li><strong>Position-based logic</strong> - Different behaviour for even/odd indices, first/last elements</li>
<li><strong>Numbering or labelling</strong> - Adding sequence numbers, prefixes, or position markers</li>
<li><strong>Map operations</strong> - Both key and value are needed during transformation</li>
<li><strong>Audit trails</strong> - Recording which field or position was modified</li>
<li><strong>Debugging complex updates</strong> - Tracking the path to each change</li>
<li><strong>Index-based filtering</strong> - Operating on specific positions or key patterns</li>
</ul>
<pre><code class="language-java">// Perfect: Position drives the logic
IndexedTraversal&lt;Integer, List&lt;Product&gt;, Product&gt; productsIndexed =
    IndexedTraversals.forList();

List&lt;Product&gt; prioritised = productsIndexed.imodify(
    (index, product) -&gt; {
        // First 3 products get express shipping
        String shipping = index &lt; 3 ? "express" : "standard";
        return product.withShipping(shipping);
    },
    products
);
</code></pre>
<h4 id="use-standard-optics-when"><a class="header" href="#use-standard-optics-when">Use Standard Optics When:</a></h4>
<ul>
<li><strong>Position irrelevant</strong> - Pure value transformations</li>
<li><strong>Simpler code</strong> - Index tracking adds unnecessary complexity</li>
<li><strong>Performance critical</strong> - Minimal overhead needed (though indexed optics are optimised)</li>
<li><strong>No positional logic</strong> - All elements treated identically</li>
</ul>
<pre><code class="language-java">// Better with standard optics: Index not needed
Traversal&lt;List&lt;Product&gt;, Double&gt; prices =
    Traversals.&lt;Product&gt;forList()
        .andThen(ProductLenses.price().asTraversal());

List&lt;Product&gt; inflated = Traversals.modify(prices, price -&gt; price * 1.1, products);
// All prices increased by 10%, position doesn't matter
</code></pre>
<hr />
<h3 id="common-patterns-position-based-operations"><a class="header" href="#common-patterns-position-based-operations">Common Patterns: Position-Based Operations</a></h3>
<h4 id="pattern-1-adding-sequence-numbers"><a class="header" href="#pattern-1-adding-sequence-numbers">Pattern 1: Adding Sequence Numbers</a></h4>
<pre><code class="language-java">// Generate a numbered list for display
IndexedTraversal&lt;Integer, List&lt;String&gt;, String&gt; indexed = IndexedTraversals.forList();

List&lt;String&gt; tasks = List.of("Review PR", "Update docs", "Run tests");

List&lt;String&gt; numbered = IndexedTraversals.imodify(
    indexed,
    (i, task) -&gt; (i + 1) + ". " + task,
    tasks
);
// ["1. Review PR", "2. Update docs", "3. Run tests"]
</code></pre>
<h4 id="pattern-2-firstlast-element-special-handling"><a class="header" href="#pattern-2-firstlast-element-special-handling">Pattern 2: First/Last Element Special Handling</a></h4>
<pre><code class="language-java">IndexedTraversal&lt;Integer, List&lt;LineItem&gt;, LineItem&gt; itemsIndexed =
    IndexedTraversals.forList();

List&lt;LineItem&gt; items = List.of(/* ... */);
int lastIndex = items.size() - 1;

List&lt;LineItem&gt; marked = IndexedTraversals.imodify(
    itemsIndexed,
    (index, item) -&gt; {
        String marker = "";
        if (index == 0) marker = "[FIRST] ";
        if (index == lastIndex) marker = "[LAST] ";
        return new LineItem(
            marker + item.productName(),
            item.quantity(),
            item.price()
        );
    },
    items
);
</code></pre>
<h4 id="pattern-3-map-key-value-transformations"><a class="header" href="#pattern-3-map-key-value-transformations">Pattern 3: Map Key-Value Transformations</a></h4>
<pre><code class="language-java">IndexedTraversal&lt;String, Map&lt;String, Integer&gt;, Integer&gt; mapIndexed =
    IndexedTraversals.forMap();

Map&lt;String, Integer&gt; scores = Map.of(
    "alice", 100,
    "bob", 85,
    "charlie", 92
);

// Create display strings incorporating both key and value
List&lt;String&gt; results = IndexedTraversals.toIndexedList(mapIndexed, scores).stream()
    .map(pair -&gt; pair.first() + " scored " + pair.second())
    .toList();
// ["alice scored 100", "bob scored 85", "charlie scored 92"]
</code></pre>
<h4 id="pattern-4-position-based-filtering"><a class="header" href="#pattern-4-position-based-filtering">Pattern 4: Position-Based Filtering</a></h4>
<pre><code class="language-java">IndexedTraversal&lt;Integer, List&lt;String&gt;, String&gt; indexed = IndexedTraversals.forList();

List&lt;String&gt; values = List.of("a", "b", "c", "d", "e", "f");

// Take only odd positions (1, 3, 5)
IndexedTraversal&lt;Integer, List&lt;String&gt;, String&gt; oddPositions =
    indexed.filterIndex(i -&gt; i % 2 == 1);

List&lt;String&gt; odd = IndexedTraversals.getAll(oddPositions, values);
// ["b", "d", "f"]
</code></pre>
<hr />
<h3 id="common-pitfalls"><a class="header" href="#common-pitfalls">Common Pitfalls</a></h3>
<h4 id="dont-do-this"><a class="header" href="#dont-do-this">Don't Do This:</a></h4>
<pre><code class="language-java">// Inefficient: Recreating indexed traversals in loops
for (Order order : orders) {
    var indexed = IndexedTraversals.&lt;LineItem&gt;forList();
    IndexedTraversals.imodify(indexed, (i, item) -&gt; numberItem(i, item), order.items());
}

// Over-engineering: Using indexed optics when index isn't needed
IndexedTraversal&lt;Integer, List&lt;String&gt;, String&gt; indexed = IndexedTraversals.forList();
List&lt;String&gt; upper = IndexedTraversals.imodify(indexed, (i, s) -&gt; s.toUpperCase(), list);
// Index parameter 'i' is never used! Use standard Traversals.modify()

// Confusing: Manual index tracking alongside indexed optics
AtomicInteger counter = new AtomicInteger(0);
IndexedTraversals.imodify(indexed, (i, item) -&gt; {
    int myIndex = counter.getAndIncrement(); // Redundant!
    return process(myIndex, item);
}, items);

// Wrong: Expecting indices to be renumbered after filtering
IndexedTraversal&lt;Integer, List&lt;String&gt;, String&gt; evenOnly =
    indexed.filterIndex(i -&gt; i % 2 == 0);
List&lt;Pair&lt;Integer, String&gt;&gt; pairs = IndexedTraversals.toIndexedList(evenOnly, list);
// Indices are [0, 2, 4], NOT [0, 1, 2] - original positions preserved!
</code></pre>
<h4 id="do-this-instead"><a class="header" href="#do-this-instead">Do This Instead:</a></h4>
<pre><code class="language-java">// Efficient: Create indexed traversal once, reuse many times
IndexedTraversal&lt;Integer, List&lt;LineItem&gt;, LineItem&gt; itemsIndexed =
    IndexedTraversals.forList();

for (Order order : orders) {
    IndexedTraversals.imodify(itemsIndexed, (i, item) -&gt; numberItem(i, item), order.items());
}

// Simple: Use standard traversals when index isn't needed
Traversal&lt;List&lt;String&gt;, String&gt; standard = Traversals.forList();
List&lt;String&gt; upper = Traversals.modify(standard, String::toUpperCase, list);

// Clear: Trust the indexed optic to provide correct indices
IndexedTraversals.imodify(indexed, (providedIndex, item) -&gt; {
    // Use providedIndex directly, it's correct
    return process(providedIndex, item);
}, items);

// Understand: Filtered indexed traversals preserve original indices
IndexedTraversal&lt;Integer, List&lt;String&gt;, String&gt; evenOnly =
    indexed.filterIndex(i -&gt; i % 2 == 0);
List&lt;Pair&lt;Integer, String&gt;&gt; pairs = IndexedTraversals.toIndexedList(evenOnly, list);
// If you need renumbered indices, transform after extraction:
List&lt;Pair&lt;Integer, String&gt;&gt; renumbered = IntStream.range(0, pairs.size())
    .mapToObj(newIndex -&gt; new Pair&lt;&gt;(newIndex, pairs.get(newIndex).second()))
    .toList();
</code></pre>
<hr />
<h3 id="performance-notes"><a class="header" href="#performance-notes">Performance Notes</a></h3>
<p>Indexed optics are designed to be efficient:</p>
<ul>
<li><strong>No additional traversals</strong> - Index computed during normal iteration</li>
<li><strong>Lazy index creation</strong> - <code>Pair&lt;I, A&gt;</code> objects only created when needed</li>
<li><strong>Minimal overhead</strong> - Index tracking adds negligible cost</li>
<li><strong>Reusable compositions</strong> - Indexed optics can be composed and cached</li>
<li><strong>No boxing for primitives</strong> - When using integer indices directly</li>
</ul>
<p><strong>Best Practice</strong>: Create indexed optics once and store as constants:</p>
<pre><code class="language-java">public class OrderOptics {
    public static final IndexedTraversal&lt;Integer, List&lt;LineItem&gt;, LineItem&gt;
        ITEMS_WITH_INDEX = IndexedTraversals.forList();

    public static final IndexedTraversal&lt;String, Map&lt;String, String&gt;, String&gt;
        METADATA_WITH_KEYS = IndexedTraversals.forMap();

    // Compose with filtering
    public static final IndexedTraversal&lt;Integer, List&lt;LineItem&gt;, LineItem&gt;
        EVEN_POSITIONED_ITEMS = ITEMS_WITH_INDEX.filterIndex(i -&gt; i % 2 == 0);
}
</code></pre>
<hr />
<h2 id="part-ii-advanced-topics"><a class="header" href="#part-ii-advanced-topics">Part II: Advanced Topics</a></h2>
<h3 id="composing-indexed-optics-with-paired-indices"><a class="header" href="#composing-indexed-optics-with-paired-indices">Composing Indexed Optics with Paired Indices</a></h3>
<p>When you compose two indexed optics, the indices form a <strong>pair</strong> representing the path through nested structures.</p>
<pre><code class="language-java">import org.higherkindedj.optics.indexed.Pair;

// Nested structure: List of Orders, each with List of Items
record Order(String id, List&lt;LineItem&gt; items) {}

// First level: indexed traversal for orders
IndexedTraversal&lt;Integer, List&lt;Order&gt;, Order&gt; ordersIndexed =
    IndexedTraversals.forList();

// Second level: lens to items field
Lens&lt;Order, List&lt;LineItem&gt;&gt; itemsLens =
    Lens.of(Order::items, (order, items) -&gt; new Order(order.id(), items));

// Third level: indexed traversal for items
IndexedTraversal&lt;Integer, List&lt;LineItem&gt;, LineItem&gt; itemsIndexed =
    IndexedTraversals.forList();

// Compose: orders → items field → each item with PAIRED indices
IndexedTraversal&lt;Pair&lt;Integer, Integer&gt;, List&lt;Order&gt;, LineItem&gt; composed =
    ordersIndexed
        .iandThen(itemsLens)
        .iandThen(itemsIndexed);

List&lt;Order&gt; orders = List.of(
    new Order("ORD-1", List.of(
        new LineItem("Laptop", 1, 999.99),
        new LineItem("Mouse", 1, 24.99)
    )),
    new Order("ORD-2", List.of(
        new LineItem("Keyboard", 1, 79.99),
        new LineItem("Monitor", 1, 299.99)
    ))
);

// Access with paired indices: (order index, item index)
List&lt;Pair&lt;Pair&lt;Integer, Integer&gt;, LineItem&gt;&gt; all = composed.toIndexedList(orders);

for (Pair&lt;Pair&lt;Integer, Integer&gt;, LineItem&gt; entry : all) {
    Pair&lt;Integer, Integer&gt; indices = entry.first();
    LineItem item = entry.second();
    System.out.printf("Order %d, Item %d: %s%n",
        indices.first(), indices.second(), item.productName());
}
// Output:
// Order 0, Item 0: Laptop
// Order 0, Item 1: Mouse
// Order 1, Item 0: Keyboard
// Order 1, Item 1: Monitor
</code></pre>
<p><strong>Use case</strong>: Generating globally unique identifiers like "Order 3, Item 5" or "Row 2, Column 7".</p>
<hr />
<h3 id="index-transformation-and-mapping"><a class="header" href="#index-transformation-and-mapping">Index Transformation and Mapping</a></h3>
<p>You can transform indices whilst preserving the optic composition.</p>
<pre><code class="language-java">// Start with integer indices (0, 1, 2...)
IndexedTraversal&lt;Integer, List&lt;LineItem&gt;, LineItem&gt; zeroIndexed =
    IndexedTraversals.forList();

// Transform to 1-based indices (1, 2, 3...)
IndexedTraversal&lt;Integer, List&lt;LineItem&gt;, LineItem&gt; oneIndexed =
    zeroIndexed.reindex(i -&gt; i + 1);

List&lt;LineItem&gt; items = List.of(/* ... */);

List&lt;String&gt; numbered = oneIndexed.imodify(
    (index, item) -&gt; "Item " + index + ": " + item.productName(),
    items
).stream()
    .map(LineItem::productName)
    .toList();
// ["Item 1: Laptop", "Item 2: Mouse", "Item 3: Keyboard"]
</code></pre>
<p><strong>Note</strong>: The <code>reindex</code> method is conceptual. In practice, you'd transform indices in your <code>imodify</code> function:</p>
<pre><code class="language-java">zeroIndexed.imodify((zeroBasedIndex, item) -&gt; {
    int oneBasedIndex = zeroBasedIndex + 1;
    return new LineItem("Item " + oneBasedIndex + ": " + item.productName(),
                        item.quantity(), item.price());
}, items);
</code></pre>
<hr />
<h3 id="combining-index-filtering-with-value-filtering"><a class="header" href="#combining-index-filtering-with-value-filtering">Combining Index Filtering with Value Filtering</a></h3>
<p>You can layer multiple filters for precise control.</p>
<pre><code class="language-java">IndexedTraversal&lt;Integer, List&lt;LineItem&gt;, LineItem&gt; itemsIndexed =
    IndexedTraversals.forList();

// Filter: even positions AND expensive items
IndexedTraversal&lt;Integer, List&lt;LineItem&gt;, LineItem&gt; targeted =
    itemsIndexed
        .filterIndex(i -&gt; i % 2 == 0)              // Even positions only
        .filtered(item -&gt; item.price() &gt; 50);       // Expensive items only

List&lt;LineItem&gt; items = List.of(
    new LineItem("Laptop", 1, 999.99),    // Index 0, expensive ✓
    new LineItem("Pen", 1, 2.99),         // Index 1, cheap ✗
    new LineItem("Keyboard", 1, 79.99),   // Index 2, expensive ✓
    new LineItem("Mouse", 1, 24.99),      // Index 3, cheap ✗
    new LineItem("Monitor", 1, 299.99)    // Index 4, expensive ✓
);

List&lt;Pair&lt;Integer, LineItem&gt;&gt; results = targeted.toIndexedList(items);
// Returns: [(0, Laptop), (2, Keyboard), (4, Monitor)]
// All at even positions AND expensive
</code></pre>
<hr />
<h3 id="audit-trail-pattern-field-change-tracking"><a class="header" href="#audit-trail-pattern-field-change-tracking">Audit Trail Pattern: Field Change Tracking</a></h3>
<p>A powerful real-world pattern is tracking <em>which</em> fields change in your domain objects.</p>
<pre><code class="language-java">// Generic field audit logger
public class AuditLog {
    public record FieldChange&lt;A&gt;(
        String fieldName,
        A oldValue,
        A newValue,
        Instant timestamp
    ) {}

    public static &lt;A&gt; Function&lt;Pair&lt;String, A&gt;, A&gt; loggedModification(
        Function&lt;A, A&gt; transformation,
        List&lt;FieldChange&lt;?&gt;&gt; auditLog
    ) {
        return pair -&gt; {
            String fieldName = pair.first();
            A oldValue = pair.second();
            A newValue = transformation.apply(oldValue);

            if (!oldValue.equals(newValue)) {
                auditLog.add(new FieldChange&lt;&gt;(
                    fieldName,
                    oldValue,
                    newValue,
                    Instant.now()
                ));
            }

            return newValue;
        };
    }
}

// Usage with indexed lens
IndexedLens&lt;String, Customer, String&gt; emailLens = IndexedLens.of(
    "email",
    Customer::email,
    (c, email) -&gt; new Customer(c.name(), email)
);

List&lt;AuditLog.FieldChange&lt;?&gt;&gt; audit = new ArrayList&lt;&gt;();

Customer customer = new Customer("Alice", "alice@old.com");

Customer updated = emailLens.imodify(
    AuditLog.loggedModification(
        email -&gt; "alice@new.com",
        audit
    ),
    customer
);

// Check audit log
for (AuditLog.FieldChange&lt;?&gt; change : audit) {
    System.out.printf("Field '%s' changed from %s to %s at %s%n",
        change.fieldName(),
        change.oldValue(),
        change.newValue(),
        change.timestamp()
    );
}
// Output: Field 'email' changed from alice@old.com to alice@new.com at 2025-01-15T10:30:00Z
</code></pre>
<hr />
<h3 id="debugging-pattern-path-tracking-in-nested-updates"><a class="header" href="#debugging-pattern-path-tracking-in-nested-updates">Debugging Pattern: Path Tracking in Nested Updates</a></h3>
<p>When debugging complex nested updates, indexed optics reveal the complete path to each modification.</p>
<pre><code class="language-java">// Nested structure with multiple levels
record Item(String name, double price) {}
record Order(List&lt;Item&gt; items) {}
record Customer(String name, List&lt;Order&gt; orders) {}

// Build an indexed path through the structure
IndexedTraversal&lt;Integer, List&lt;Customer&gt;, Customer&gt; customersIdx =
    IndexedTraversals.forList();

Lens&lt;Customer, List&lt;Order&gt;&gt; ordersLens =
    Lens.of(Customer::orders, (c, o) -&gt; new Customer(c.name(), o));

IndexedTraversal&lt;Integer, List&lt;Order&gt;, Order&gt; ordersIdx =
    IndexedTraversals.forList();

Lens&lt;Order, List&lt;Item&gt;&gt; itemsLens =
    Lens.of(Order::items, (order, items) -&gt; new Order(items));

IndexedTraversal&lt;Integer, List&lt;Item&gt;, Item&gt; itemsIdx =
    IndexedTraversals.forList();

Lens&lt;Item, Double&gt; priceLens =
    Lens.of(Item::price, (item, price) -&gt; new Item(item.name(), price));

// Compose the full indexed path
IndexedTraversal&lt;Pair&lt;Pair&lt;Integer, Integer&gt;, Integer&gt;, List&lt;Customer&gt;, Double&gt; fullPath =
    customersIdx
        .iandThen(ordersLens)
        .iandThen(ordersIdx)
        .iandThen(itemsLens)
        .iandThen(itemsIdx)
        .iandThen(priceLens);

List&lt;Customer&gt; customers = List.of(/* ... */);

// Modify with full path visibility
List&lt;Customer&gt; updated = fullPath.imodify(
    (indices, price) -&gt; {
        int customerIdx = indices.first().first();
        int orderIdx = indices.first().second();
        int itemIdx = indices.second();

        System.out.printf(
            "Updating price at [customer=%d, order=%d, item=%d]: %.2f → %.2f%n",
            customerIdx, orderIdx, itemIdx, price, price * 1.1
        );

        return price * 1.1;  // 10% increase
    },
    customers
);
// Output shows complete path to every modified price:
// Updating price at [customer=0, order=0, item=0]: 999.99 → 1099.99
// Updating price at [customer=0, order=0, item=1]: 24.99 → 27.49
// Updating price at [customer=0, order=1, item=0]: 79.99 → 87.99
// ...
</code></pre>
<hr />
<h3 id="working-with-pair-utilities"><a class="header" href="#working-with-pair-utilities">Working with Pair Utilities</a></h3>
<p>The <code>Pair&lt;A, B&gt;</code> type provides utility methods for manipulation.</p>
<pre><code class="language-java">import org.higherkindedj.optics.indexed.Pair;

Pair&lt;Integer, String&gt; pair = new Pair&lt;&gt;(1, "Hello");

// Access components
int first = pair.first();       // 1
String second = pair.second();  // "Hello"

// Transform components
Pair&lt;Integer, String&gt; modified = pair.withSecond("World");
// Result: Pair(1, "World")

Pair&lt;String, String&gt; transformed = pair.withFirst("One");
// Result: Pair("One", "Hello")

// Swap
Pair&lt;String, Integer&gt; swapped = pair.swap();
// Result: Pair("Hello", 1)

// Factory method
Pair&lt;String, Integer&gt; created = Pair.of("Key", 42);
</code></pre>
<p>For converting to/from <code>Tuple2</code> (when working with hkj-core utilities):</p>
<pre><code class="language-java">import org.higherkindedj.hkt.Tuple2;
import org.higherkindedj.optics.util.IndexedTraversals;

Pair&lt;String, Integer&gt; pair = Pair.of("key", 100);

// Convert to Tuple2
Tuple2&lt;String, Integer&gt; tuple = IndexedTraversals.pairToTuple2(pair);

// Convert back to Pair
Pair&lt;String, Integer&gt; converted = IndexedTraversals.tuple2ToPair(tuple);
</code></pre>
<hr />
<h3 id="real-world-example-order-fulfilment-dashboard"><a class="header" href="#real-world-example-order-fulfilment-dashboard">Real-World Example: Order Fulfilment Dashboard</a></h3>
<p>Here's a comprehensive example demonstrating indexed optics in a business context.</p>
<pre><code class="language-java">package org.higherkindedj.example.optics;

import java.time.Instant;
import java.util.*;
import org.higherkindedj.optics.indexed.*;
import org.higherkindedj.optics.util.IndexedTraversals;

public class OrderFulfilmentDashboard {

    public record LineItem(String productName, int quantity, double price) {}

    public record Order(
        String orderId,
        List&lt;LineItem&gt; items,
        Map&lt;String, String&gt; metadata
    ) {}

    public static void main(String[] args) {
        Order order = new Order(
            "ORD-12345",
            List.of(
                new LineItem("Laptop", 1, 999.99),
                new LineItem("Mouse", 2, 24.99),
                new LineItem("Keyboard", 1, 79.99),
                new LineItem("Monitor", 1, 299.99)
            ),
            new LinkedHashMap&lt;&gt;(Map.of(
                "priority", "express",
                "gift-wrap", "true",
                "delivery-note", "Leave at door"
            ))
        );

        System.out.println("=== ORDER FULFILMENT DASHBOARD ===\n");

        // --- Task 1: Generate Packing Slip ---
        System.out.println("--- Packing Slip ---");
        generatePackingSlip(order);

        // --- Task 2: Apply Position-Based Discounts ---
        System.out.println("\n--- Position-Based Discounts ---");
        Order discounted = applyPositionDiscounts(order);
        System.out.println("Original total: £" + calculateTotal(order));
        System.out.println("Discounted total: £" + calculateTotal(discounted));

        // --- Task 3: Process Metadata with Key Awareness ---
        System.out.println("\n--- Metadata Processing ---");
        processMetadata(order);

        // --- Task 4: Identify High-Value Positions ---
        System.out.println("\n--- High-Value Items ---");
        identifyHighValuePositions(order);

        System.out.println("\n=== END OF DASHBOARD ===");
    }

    private static void generatePackingSlip(Order order) {
        IndexedTraversal&lt;Integer, List&lt;LineItem&gt;, LineItem&gt; itemsIndexed =
            IndexedTraversals.forList();

        List&lt;Pair&lt;Integer, LineItem&gt;&gt; indexedItems =
            itemsIndexed.toIndexedList(order.items());

        System.out.println("Order: " + order.orderId());
        for (Pair&lt;Integer, LineItem&gt; pair : indexedItems) {
            int position = pair.first() + 1;  // 1-based for display
            LineItem item = pair.second();
            System.out.printf("  Item %d: %s (Qty: %d) - £%.2f%n",
                position,
                item.productName(),
                item.quantity(),
                item.price() * item.quantity()
            );
        }
    }

    private static Order applyPositionDiscounts(Order order) {
        IndexedTraversal&lt;Integer, List&lt;LineItem&gt;, LineItem&gt; itemsIndexed =
            IndexedTraversals.forList();

        // Every 3rd item gets 15% off (positions 2, 5, 8...)
        List&lt;LineItem&gt; discounted = itemsIndexed.imodify(
            (index, item) -&gt; {
                if ((index + 1) % 3 == 0) {
                    double newPrice = item.price() * 0.85;
                    System.out.printf("  Position %d (%s): £%.2f → £%.2f (15%% off)%n",
                        index + 1, item.productName(), item.price(), newPrice);
                    return new LineItem(item.productName(), item.quantity(), newPrice);
                }
                return item;
            },
            order.items()
        );

        return new Order(order.orderId(), discounted, order.metadata());
    }

    private static void processMetadata(Order order) {
        IndexedTraversal&lt;String, Map&lt;String, String&gt;, String&gt; metadataIndexed =
            IndexedTraversals.forMap();

        IndexedFold&lt;String, Map&lt;String, String&gt;, String&gt; fold =
            metadataIndexed.asIndexedFold();

        List&lt;Pair&lt;String, String&gt;&gt; entries = fold.toIndexedList(order.metadata());

        for (Pair&lt;String, String&gt; entry : entries) {
            String key = entry.first();
            String value = entry.second();

            // Process based on key
            switch (key) {
                case "priority" -&gt;
                    System.out.println("  Shipping priority: " + value.toUpperCase());
                case "gift-wrap" -&gt;
                    System.out.println("  Gift wrapping: " +
                        (value.equals("true") ? "Required" : "Not required"));
                case "delivery-note" -&gt;
                    System.out.println("  Special instructions: " + value);
                default -&gt;
                    System.out.println("  " + key + ": " + value);
            }
        }
    }

    private static void identifyHighValuePositions(Order order) {
        IndexedTraversal&lt;Integer, List&lt;LineItem&gt;, LineItem&gt; itemsIndexed =
            IndexedTraversals.forList();

        // Filter to items over £100
        IndexedTraversal&lt;Integer, List&lt;LineItem&gt;, LineItem&gt; highValue =
            itemsIndexed.filteredWithIndex((index, item) -&gt; item.price() &gt; 100);

        List&lt;Pair&lt;Integer, LineItem&gt;&gt; expensive = highValue.toIndexedList(order.items());

        System.out.println("  Items over £100 (require special handling):");
        for (Pair&lt;Integer, LineItem&gt; pair : expensive) {
            System.out.printf("    Position %d: %s (£%.2f)%n",
                pair.first() + 1,
                pair.second().productName(),
                pair.second().price()
            );
        }
    }

    private static double calculateTotal(Order order) {
        return order.items().stream()
            .mapToDouble(item -&gt; item.price() * item.quantity())
            .sum();
    }
}
</code></pre>
<p><strong>Expected Output:</strong></p>
<pre><code>=== ORDER FULFILMENT DASHBOARD ===

--- Packing Slip ---
Order: ORD-12345
  Item 1: Laptop (Qty: 1) - £999.99
  Item 2: Mouse (Qty: 2) - £49.98
  Item 3: Keyboard (Qty: 1) - £79.99
  Item 4: Monitor (Qty: 1) - £299.99

--- Position-Based Discounts ---
  Position 3 (Keyboard): £79.99 → £67.99 (15% off)
Original total: £1429.95
Discounted total: £1417.95

--- Metadata Processing ---
  Shipping priority: EXPRESS
  Gift wrapping: Required
  Special instructions: Leave at door

--- High-Value Items ---
  Items over £100 (require special handling):
    Position 1: Laptop (£999.99)
    Position 4: Monitor (£299.99)

=== END OF DASHBOARD ===
</code></pre>
<hr />
<h2 id="the-relationship-to-haskells-lens-library"><a class="header" href="#the-relationship-to-haskells-lens-library">The Relationship to Haskell's Lens Library</a></h2>
<p>For those familiar with functional programming, higher-kinded-j's indexed optics are inspired by Haskell's <a href="https://hackage.haskell.org/package/lens">lens library</a>, specifically indexed traversals and indexed folds.</p>
<p>In Haskell:</p>
<pre><code class="language-haskell">itraversed :: IndexedTraversal Int ([] a) a
</code></pre>
<p>This creates an indexed traversal over lists where the index is an integer: exactly what our <code>IndexedTraversals.forList()</code> provides.</p>
<p><strong>Key differences:</strong></p>
<ul>
<li>Higher-kinded-j uses explicit <code>Applicative</code> instances rather than implicit type class resolution</li>
<li>Java's type system requires explicit <code>Pair&lt;I, A&gt;</code> for index-value pairs</li>
<li>The <code>imodify</code> and <code>iget</code> methods provide a more Java-friendly API</li>
<li>Map-based traversals (<code>forMap</code>) are a practical extension for Java's collection library</li>
</ul>
<p><strong>Further Reading:</strong></p>
<ul>
<li><a href="https://hackage.haskell.org/package/lens-tutorial-1.0.4/docs/Control-Lens-Tutorial.html">Haskell Lens Tutorial: Indexed Optics</a> - Original inspiration</li>
<li><a href="https://leanpub.com/optics-by-example">Optics By Example</a> by Chris Penner - Chapter on indexed optics</li>
<li><a href="https://www.optics.dev/Monocle/">Monocle (Scala)</a> - Similar indexed optics for Scala</li>
</ul>
<div id="admonition-for-comprehension-integration" class="admonition admonish-tip" role="note" aria-labelledby="admonition-for-comprehension-integration-title">
<div class="admonition-title">
<div id="admonition-for-comprehension-integration-title">
<p>For Comprehension Integration</p>
</div>
<a class="admonition-anchor-link" href="#admonition-for-comprehension-integration"></a>
</div>
<div>
<p>For a fluent, comprehension-style API for indexed traversal operations, see <a href="../functional/for_comprehension.html#position-aware-traversals-with-forindexed">For Comprehensions: Position-Aware Traversals with ForIndexed</a>. This provides an alternative syntax for position-based filtering, modifying, and collecting traversal targets.</p>
</div>
</div>
<hr />
<h2 id="summary-the-power-of-indexed-optics"><a class="header" href="#summary-the-power-of-indexed-optics">Summary: The Power of Indexed Optics</a></h2>
<p>Indexed optics bring <strong>position awareness</strong> into your functional data transformations:</p>
<ul>
<li><strong>IndexedTraversal&lt;I, S, A&gt;</strong>: Bulk operations with index tracking</li>
<li><strong>IndexedFold&lt;I, S, A&gt;</strong>: Read-only queries with position information</li>
<li><strong>IndexedLens&lt;I, S, A&gt;</strong>: Single-field access with field name tracking</li>
</ul>
<p>These tools transform how you work with collections and records:</p>
<div class="table-wrapper"><table><thead><tr><th>Before (Manual Index Tracking)</th><th>After (Declarative Indexed Optics)</th></tr></thead><tbody>
<tr><td>Manual loop counters</td><td>Built-in index access</td></tr>
<tr><td>AtomicInteger for streams</td><td>Type-safe <code>imodify</code></td></tr>
<tr><td>Breaking into Map.entrySet()</td><td>Direct key-value processing</td></tr>
<tr><td>Complex audit logging logic</td><td>Field tracking with <code>IndexedLens</code></td></tr>
<tr><td>Scattered position logic</td><td>Composable indexed transformations</td></tr>
</tbody></table>
</div>
<p>By incorporating indexed optics into your toolkit, you gain:</p>
<ul>
<li><strong>Expressiveness</strong>: Say "numbered list items" declaratively</li>
<li><strong>Type safety</strong>: Compile-time checked index types</li>
<li><strong>Composability</strong>: Chain indexed optics, filter by position, compose with standard optics</li>
<li><strong>Debugging power</strong>: Track complete paths through nested structures</li>
<li><strong>Audit trails</strong>: Record which fields changed, not just values</li>
<li><strong>Performance</strong>: Minimal overhead, lazy index computation</li>
</ul>
<p>Indexed optics represent the fusion of position awareness with functional composition: enabling you to write code that is simultaneously more declarative, more powerful, and more maintainable than traditional index-tracking approaches.</p>
<hr />
<p><strong>Previous:</strong> <a href="filtered_optics.html">Filtered Optics</a>
<strong>Next:</strong> <a href="each_typeclass.html">Each Typeclass</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../optics/filtered_optics.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../optics/each_typeclass.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../optics/filtered_optics.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../optics/each_typeclass.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../version-switcher.js"></script>
        <script src=".././theme/version-switcher.js"></script>
        <script src=".././theme/sidebar-nav-link.js"></script>


    </div>
    </body>
</html>
