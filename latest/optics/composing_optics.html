<!DOCTYPE HTML>
<html lang="en" class="latte sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Composing Optics - Higher-Kinded-J: Composable Effects and Advanced Optics for Java</title>


        <!-- Custom HTML head -->


            <meta name="description" content="The most comprehensive functional programming library for Java. Unify error handling, optional values, and immutable data navigation with the Effect Path API and Focus DSL. Features advanced optics with code generation for Java records, filtered traversals, indexed optics, and seamless Spring Boot integration.">


        <meta name="keywords" content="Higher-Kinded Types, Higher-Kinded-J, HKT, Java, Optics, Lens, Prism, Traversal, Iso, Affine, Focus DSL, Effect Path API, Functional Programming, Monad, Functor, Applicative, EitherPath, MaybePath, TryPath, ValidationPath, Java Records, Sealed Interface, Error Handling, Immutable Data">
        
        <meta property="og:title" content="Composing Optics - Higher-Kinded-J: Composable Effects and Advanced Optics for Java">
            <meta property="og:description" content="The most comprehensive functional programming library for Java. Unify error handling, optional values, and immutable data navigation with the Effect Path API and Focus DSL. Features advanced optics with code generation for Java records, filtered traversals, indexed optics, and seamless Spring Boot integration.">
        <meta property="og:type" content="website">
        <meta property="og:url" content="https://higher-kinded-j.github.io/">
        <meta property="og:image" content="https://higher-kinded-j.github.io/preview.png">
        <meta property="og:image:width" content="1200">
        <meta property="og:image:height" content="630">
        <meta property="og:site_name" content="Higher-Kinded-J Documentation">
        <meta property="og:locale" content="en_GB">
        
        <meta name="twitter:card" content="summary_large_image">
        <meta name="twitter:title" content="Composing Optics - Higher-Kinded-J: Composable Effects and Advanced Optics for Java">
        <meta name="twitter:description" content="Unifying Composable Effects and Advanced Optics for Java. Effect Path API, Focus DSL, and the most comprehensive optics implementation in the Java ecosystem.">
        <meta name="twitter:image" content="https://higher-kinded-j.github.io/preview.png">
        <meta name="twitter:image:alt" content="Higher-Kinded-J: Composable Effects and Advanced Optics for Java">
        <meta name="description" content="The most comprehensive functional programming library for Java. Unify error handling, optional values, and immutable data navigation with the Effect Path API and Focus DSL. Features advanced optics with code generation for Java records, filtered traversals, indexed optics, and seamless Spring Boot integration.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">
        <meta name="google-site-verification" content="X-xsiAq2cKMLOzh9dexUrX8Onx2h_YMUFgp5lHHUwSg" />
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href=".././mdbook-admonish.css">
        <link rel="stylesheet" href=".././theme/catppuccin.css">
        <link rel="stylesheet" href=".././theme/catppuccin-admonish.css">
        <link rel="stylesheet" href=".././theme/catppuccin-alerts.css">
        <link rel="stylesheet" href=".././theme/additional-hkj.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "latte";
            const default_dark_theme = "macchiato";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('latte')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="latte">Latte</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="frappe">Frappé</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="macchiato">Macchiato</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mocha">Mocha</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        <div class="version-selector-container">
                            <select id="version-selector" class="version-selector" aria-label="Select documentation version" title="Select documentation version">
                                <option value="">Loading versions...</option>
                            </select>
                        </div>
                    </div>

                    <h1 class="menu-title">Higher-Kinded-J: Composable Effects and Advanced Optics for Java</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/higher-kinded-j/higher-kinded-j" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/higher-kinded-j/higher-kinded-j/edit/main/hkj-book/src/optics/composing_optics.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="capstone-example"><a class="header" href="#capstone-example">Capstone Example:</a></h1>
<h2 id="composing-optics-for-deep-validation"><a class="header" href="#composing-optics-for-deep-validation"><em>Composing Optics for Deep Validation</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to compose multiple optic types into powerful processing pipelines</li>
<li>Building type-safe validation workflows with error accumulation</li>
<li>Using <code>asTraversal()</code> to ensure safe optic composition</li>
<li>Creating reusable validation paths with effectful operations</li>
<li>Simplified validation with <code>modifyAllValidated</code>, <code>modifyAllEither</code>, and <code>modifyMaybe</code></li>
<li>Understanding when composition is superior to manual validation logic</li>
<li>Advanced patterns for multi-level and conditional validation scenarios</li>
</ul>
</div>
</div>
<div id="admonition-hands-on-practice" class="admonition admonish-note" role="note" aria-labelledby="admonition-hands-on-practice-title">
<div class="admonition-title">
<div id="admonition-hands-on-practice-title">
<p>Hands On Practice</p>
</div>
<a class="admonition-anchor-link" href="#admonition-hands-on-practice"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/optics/Tutorial06_OpticsComposition.java">Tutorial06_OpticsComposition.java</a></p>
</div>
</div>
<div id="admonition-example-code" class="admonition admonish-note" role="note" aria-labelledby="admonition-example-code-title">
<div class="admonition-title">
<div id="admonition-example-code-title">
<p>Example Code</p>
</div>
<a class="admonition-anchor-link" href="#admonition-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/ValidatedTraversalExample.java">ValidatedTraversalExample</a></p>
</div>
</div>
<p>In the previous guides, we explored each core optic (<code>Lens</code>, <code>Prism</code>, <code>Iso</code> and <code>Traversal</code>) as individual tools. We've seen how they provide focused, reusable, and composable access to immutable data.</p>
<p>Now, it's time to put it all together.</p>
<p>This guide showcases the true power of the optics approach by composing multiple different optics to solve a single, complex, real-world problem: performing deep, effectful validation on a nested data structure.</p>
<hr />
<h2 id="the-scenario-validating-user-permissions"><a class="header" href="#the-scenario-validating-user-permissions">The Scenario: Validating User Permissions</a></h2>
<p>Imagine a data model for a form that can be filled out by either a registered <code>User</code> or a <code>Guest</code>. Our goal is to validate that every <code>Permission</code> held by a <code>User</code> has a valid name.</p>
<p>This single task requires us to:</p>
<ol>
<li>Focus on the form's <code>principal</code> field (<strong>a job for a Lens</strong>).</li>
<li>Safely "select" the <code>User</code> case, ignoring any <code>Guest</code>s (<strong>a job for a Prism</strong>).</li>
<li>Operate on every <code>Permission</code> in the userLogin's list (<strong>a job for a Traversal</strong>).</li>
</ol>
<hr />
<h2 id="think-of-this-composition-like"><a class="header" href="#think-of-this-composition-like">Think of This Composition Like...</a></h2>
<ul>
<li><strong>A telescope with multiple lenses</strong>: Each optic focuses deeper into the data structure</li>
<li><strong>A manufacturing pipeline</strong>: Each stage processes and refines the data further</li>
<li><strong>A filter chain</strong>: Data flows through multiple filters, each handling a specific concern</li>
<li><strong>A surgical procedure</strong>: Precise, layered operations that work together for a complex outcome</li>
</ul>
<hr />
<h3 id="1-the-data-model"><a class="header" href="#1-the-data-model">1. The Data Model</a></h3>
<p>Here is the nested data structure, annotated to generate all the optics we will need.</p>
<pre><code class="language-java">import org.higherkindedj.optics.annotations.GenerateLenses;
import org.higherkindedj.optics.annotations.GeneratePrisms;
import org.higherkindedj.optics.annotations.GenerateTraversals;
import java.util.List;

@GenerateLenses
public record Permission(String name) {}

@GeneratePrisms
public sealed interface Principal {}

@GenerateLenses
@GenerateTraversals
public record User(String username, List&lt;Permission&gt; permissions) implements Principal {}

public record Guest() implements Principal {}

@GenerateLenses
public record Form(int formId, Principal principal) {}
</code></pre>
<h3 id="2-the-validation-logic"><a class="header" href="#2-the-validation-logic">2. The Validation Logic</a></h3>
<p>Our validation function will take a permission name (<code>String</code>) and return a <code>Validated&lt;String, String&gt;</code>. The <code>Validated</code> applicative functor will automatically handle accumulating any errors found.</p>
<pre><code class="language-java">import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.validated.Validated;
import org.higherkindedj.hkt.validated.ValidatedKind;
import static org.higherkindedj.hkt.validated.ValidatedKindHelper.VALIDATED;
import java.util.Set;

private static final Set&lt;String&gt; VALID_PERMISSIONS = Set.of("PERM_READ", "PERM_WRITE", "PERM_DELETE");

public static Kind&lt;ValidatedKind.Witness&lt;String&gt;, String&gt; validatePermissionName(String name) {
    if (VALID_PERMISSIONS.contains(name)) {
        return VALIDATED.widen(Validated.valid(name));
    } else {
        return VALIDATED.widen(Validated.invalid("Invalid permission: " + name));
    }
}
</code></pre>
<h3 id="3-understanding-the-composition-strategy"><a class="header" href="#3-understanding-the-composition-strategy">3. Understanding the Composition Strategy</a></h3>
<p>Before diving into the code, let's understand why we need each type of optic and how they work together:</p>
<p><strong>Why a Lens for <code>principal</code>?</strong></p>
<ul>
<li>The <code>principal</code> field always exists in a <code>Form</code></li>
<li>We need guaranteed access to focus on this field</li>
<li>A <code>Lens</code> provides exactly this: reliable access to required data</li>
</ul>
<p><strong>Why a Prism for <code>User</code>?</strong></p>
<ul>
<li>The <code>principal</code> could be either a <code>User</code> or a <code>Guest</code></li>
<li>We only want to validate <code>User</code> permissions, ignoring <code>Guest</code>s</li>
<li>A <code>Prism</code> provides safe, optional access to specific sum type cases</li>
</ul>
<p><strong>Why a Traversal for <code>permissions</code>?</strong></p>
<ul>
<li>We need to validate <em>every</em> permission in the list</li>
<li>We want to accumulate <em>all</em> validation errors, not stop at the first one</li>
<li>A <code>Traversal</code> provides bulk operations over collections</li>
</ul>
<p><strong>Why convert everything to <code>Traversal</code>?</strong></p>
<ul>
<li><code>Traversal</code> is the most general optic type</li>
<li>It can represent zero-or-more targets (perfect for our "might be empty" scenario)</li>
<li>All other optics can be converted to <code>Traversal</code> for seamless composition</li>
</ul>
<h3 id="4-composing-the-master-optic"><a class="header" href="#4-composing-the-master-optic">4. Composing the Master Optic</a></h3>
<p>Now for the main event. We will compose our generated optics to create a single <code>Traversal</code> that declaratively represents the path from a <code>Form</code> all the way down to each permission <code>name</code>. While the new <code>with*</code> helpers are great for simple, shallow updates, a deep and conditional update like this requires composition.</p>
<p>To ensure type-safety across different optic types, we convert each <code>Lens</code> and <code>Prism</code> in the chain to a <code>Traversal</code> using the <code>.asTraversal()</code> method.</p>
<pre><code class="language-java">import org.higherkindedj.optics.Lens;
import org.higherkindedj.optics.Prism;
import org.higherkindedj.optics.Traversal;

// Get the individual generated optics
Lens&lt;Form, Principal&gt; formPrincipalLens = FormLenses.principal();
Prism&lt;Principal, User&gt; principalUserPrism = PrincipalPrisms.userLogin();
Traversal&lt;User, Permission&gt; userPermissionsTraversal = UserTraversals.permissions();
Lens&lt;Permission, String&gt; permissionNameLens = PermissionLenses.name();

// Compose them into a single, deep Traversal
Traversal&lt;Form, String&gt; formToPermissionNameTraversal =
    formPrincipalLens.asTraversal()
        .andThen(principalUserPrism.asTraversal())
        .andThen(userPermissionsTraversal)
        .andThen(permissionNameLens.asTraversal());
</code></pre>
<p>This single <code>formToPermissionNameTraversal</code> object now encapsulates the entire complex path.</p>
<hr />
<h2 id="when-to-use-optic-composition-vs-other-approaches"><a class="header" href="#when-to-use-optic-composition-vs-other-approaches">When to Use Optic Composition vs Other Approaches</a></h2>
<h3 id="use-optic-composition-when"><a class="header" href="#use-optic-composition-when">Use Optic Composition When:</a></h3>
<ul>
<li><strong>Complex nested validation</strong> - Multiple levels of data structure with conditional logic</li>
<li><strong>Reusable validation paths</strong> - The same validation logic applies to multiple scenarios</li>
<li><strong>Type-safe bulk operations</strong> - You need to ensure compile-time safety for collection operations</li>
<li><strong>Error accumulation</strong> - You want to collect all errors, not stop at the first failure</li>
</ul>
<pre><code class="language-java">// Perfect for reusable, complex validation
Traversal&lt;Company, String&gt; allEmployeeEmails = 
    CompanyTraversals.departments()
        .andThen(DepartmentTraversals.employees())
        .andThen(EmployeePrisms.active().asTraversal())  // Only active employees
        .andThen(EmployeeLenses.email().asTraversal());

// Use across multiple validation scenarios
Validated&lt;List&lt;String&gt;, Company&gt; result1 = validateEmails(company1);
Validated&lt;List&lt;String&gt;, Company&gt; result2 = validateEmails(company2);
</code></pre>
<h3 id="use-direct-validation-when"><a class="header" href="#use-direct-validation-when">Use Direct Validation When:</a></h3>
<ul>
<li><strong>Simple, flat structures</strong> - No deep nesting or conditional access needed</li>
<li><strong>One-off validation</strong> - Logic won't be reused elsewhere</li>
<li><strong>Performance critical</strong> - Minimal abstraction overhead required</li>
</ul>
<pre><code class="language-java">// Simple validation doesn't need optics
public Validated&lt;String, User&gt; validateUser(User userLogin) {
    if (userLogin.username().length() &lt; 3) {
        return Validated.invalid("Username too short");
    }
    return Validated.valid(userLogin);
}
</code></pre>
<h3 id="use-stream-processing-when"><a class="header" href="#use-stream-processing-when">Use Stream Processing When:</a></h3>
<ul>
<li><strong>Complex transformations</strong> - Multiple operations that don't map to optic patterns</li>
<li><strong>Aggregation logic</strong> - Computing statistics or summaries</li>
<li><strong>Filtering and collecting</strong> - Changing the structure of collections</li>
</ul>
<pre><code class="language-java">// Better with streams for aggregation
Map&lt;String, Long&gt; permissionCounts = forms.stream()
    .map(Form::principal)
    .filter(User.class::isInstance)
    .map(User.class::cast)
    .flatMap(userLogin -&gt; userLogin.permissions().stream())
    .collect(groupingBy(Permission::name, counting()));
</code></pre>
<hr />
<h2 id="common-pitfalls"><a class="header" href="#common-pitfalls">Common Pitfalls</a></h2>
<h3 id="dont-do-this"><a class="header" href="#dont-do-this">Don't Do This:</a></h3>
<pre><code class="language-java">// Over-composing simple cases
Traversal&lt;Form, Integer&gt; formIdTraversal = FormLenses.formId().asTraversal();
// Just use: form.formId()

// Forgetting error accumulation setup
// This won't accumulate errors properly without the right Applicative
var badResult = traversal.modifyF(validatePermissionName, form, /* wrong applicative */);

// Creating complex compositions inline
var inlineResult = FormLenses.principal().asTraversal()
    .andThen(PrincipalPrisms.userLogin().asTraversal())
    .andThen(UserTraversals.permissions())
    .andThen(PermissionLenses.name().asTraversal())
    .modifyF(validatePermissionName, form, applicative); // Hard to read and reuse

// Ignoring the path semantics
// This tries to validate ALL strings, not just permission names
Traversal&lt;Form, String&gt; badTraversal = /* any string traversal */;
</code></pre>
<h3 id="do-this-instead"><a class="header" href="#do-this-instead">Do This Instead:</a></h3>
<pre><code class="language-java">// Use direct access for simple cases
int formId = form.formId(); // Clear and direct

// Set up error accumulation properly
Applicative&lt;ValidatedKind.Witness&lt;String&gt;&gt; validatedApplicative =
    ValidatedMonad.instance(Semigroups.string("; "));

// Create reusable, well-named compositions
public static final Traversal&lt;Form, String&gt; FORM_TO_PERMISSION_NAMES =
    FormLenses.principal().asTraversal()
        .andThen(PrincipalPrisms.userLogin().asTraversal())
        .andThen(UserTraversals.permissions())
        .andThen(PermissionLenses.name().asTraversal());

// Use the well-named traversal
var result = FORM_TO_PERMISSION_NAMES.modifyF(validatePermissionName, form, validatedApplicative);

// Be specific about what you're validating
// This traversal has clear semantics: Form -&gt; User permissions -&gt; permission names
</code></pre>
<hr />
<h2 id="performance-notes"><a class="header" href="#performance-notes">Performance Notes</a></h2>
<p>Optic composition is designed for efficiency:</p>
<ul>
<li><strong>Lazy evaluation</strong>: Only processes data when actually used</li>
<li><strong>Structural sharing</strong>: Unchanged parts of data structures are reused</li>
<li><strong>Single-pass processing</strong>: <code>modifyF</code> traverses the structure only once</li>
<li><strong>Memory efficient</strong>: Only creates new objects for changed data</li>
<li><strong>JIT compiler optimisation</strong>: Complex compositions are optimised by the JVM's just-in-time compiler through method inlining</li>
</ul>
<p><strong>Best Practice</strong>: Create composed optics as constants for reuse:</p>
<pre><code class="language-java">public class ValidationOptics {
    // Reusable validation paths
    public static final Traversal&lt;Form, String&gt; USER_PERMISSION_NAMES =
        FormLenses.principal().asTraversal()
            .andThen(PrincipalPrisms.userLogin().asTraversal())
            .andThen(UserTraversals.permissions())
            .andThen(PermissionLenses.name().asTraversal());
  
    public static final Traversal&lt;Company, String&gt; EMPLOYEE_EMAILS =
        CompanyTraversals.employees()
            .andThen(EmployeeLenses.contactInfo().asTraversal())
            .andThen(ContactInfoLenses.email().asTraversal());
  
    // Helper methods for common validations
    public static Validated&lt;List&lt;String&gt;, Form&gt; validatePermissions(Form form) {
        return VALIDATED.narrow(USER_PERMISSION_NAMES.modifyF(
            ValidationOptics::validatePermissionName,
            form,
            getValidatedApplicative()
        ));
    }
}
</code></pre>
<hr />
<h2 id="advanced-composition-patterns"><a class="header" href="#advanced-composition-patterns">Advanced Composition Patterns</a></h2>
<h3 id="1-multi-level-validation"><a class="header" href="#1-multi-level-validation">1. Multi-Level Validation</a></h3>
<pre><code class="language-java">// Validate both userLogin data AND permissions in one pass
public static Validated&lt;List&lt;String&gt;, Form&gt; validateFormCompletely(Form form) {
    // First validate userLogin basic info
    var userValidation = FormLenses.principal().asTraversal()
        .andThen(PrincipalPrisms.userLogin().asTraversal())
        .andThen(UserLenses.username().asTraversal())
        .modifyF(ValidationOptics::validateUsername, form, getValidatedApplicative());
  
    // Then validate permissions
    var permissionValidation = FORM_TO_PERMISSION_NAMES
        .modifyF(ValidationOptics::validatePermissionName, form, getValidatedApplicative());
  
    // Combine both validations
    return VALIDATED.narrow(getValidatedApplicative().map2(
        userValidation,
        permissionValidation,
        (validForm1, validForm2) -&gt; validForm2 // Return the final form
    ));
}
</code></pre>
<h3 id="2-conditional-validation-paths"><a class="header" href="#2-conditional-validation-paths">2. Conditional Validation Paths</a></h3>
<pre><code class="language-java">// Different validation rules for different userLogin types
public static final Traversal&lt;Form, String&gt; ADMIN_USER_PERMISSIONS =
    FormLenses.principal().asTraversal()
        .andThen(PrincipalPrisms.userLogin().asTraversal())
        .andThen(UserPrisms.adminUser().asTraversal())  // Only admin users
        .andThen(AdminUserTraversals.permissions())
        .andThen(PermissionLenses.name().asTraversal());

public static final Traversal&lt;Form, String&gt; REGULAR_USER_PERMISSIONS =
    FormLenses.principal().asTraversal()
        .andThen(PrincipalPrisms.userLogin().asTraversal())
        .andThen(UserPrisms.regularUser().asTraversal())  // Only regular users
        .andThen(RegularUserTraversals.permissions())
        .andThen(PermissionLenses.name().asTraversal());
</code></pre>
<h3 id="3-cross-field-validation"><a class="header" href="#3-cross-field-validation">3. Cross-Field Validation</a></h3>
<pre><code class="language-java">// Validate that permissions are appropriate for userLogin role
public static Validated&lt;List&lt;String&gt;, Form&gt; validatePermissionsForRole(Form form) {
    return FormLenses.principal().asTraversal()
        .andThen(PrincipalPrisms.userLogin().asTraversal())
        .modifyF(userLogin -&gt; {
            // Custom validation that checks both role and permissions
            Set&lt;String&gt; allowedPerms = getAllowedPermissionsForRole(userLogin.role());
            List&lt;String&gt; errors = userLogin.permissions().stream()
                .map(Permission::name)
                .filter(perm -&gt; !allowedPerms.contains(perm))
                .map(perm -&gt; "Permission '" + perm + "' not allowed for role " + userLogin.role())
                .toList();
          
            return errors.isEmpty() 
                ? VALIDATED.widen(Validated.valid(userLogin))
                : VALIDATED.widen(Validated.invalid(String.join("; ", errors)));
        }, form, getValidatedApplicative());
}
</code></pre>
<hr />
<h2 id="complete-runnable-example"><a class="header" href="#complete-runnable-example">Complete, Runnable Example</a></h2>
<p>With our composed <code>Traversal</code>, we can now use <code>modifyF</code> to run our validation logic. The <code>Traversal</code> handles the navigation and filtering, while the <code>Validated</code> applicative (created with a <code>Semigroup</code> for joining error strings) handles the effects and error accumulation.</p>
<pre><code class="language-java">package org.higherkindedj.example.optics;

import static org.higherkindedj.hkt.validated.ValidatedKindHelper.VALIDATED;

import java.util.List;
import java.util.Set;
import org.higherkindedj.hkt.Applicative;
import org.higherkindedj.hkt.Kind;
import org.higherkindedj.hkt.Semigroups;
import org.higherkindedj.hkt.validated.Validated;
import org.higherkindedj.hkt.validated.ValidatedKind;
import org.higherkindedj.hkt.validated.ValidatedMonad;
import org.higherkindedj.optics.Lens;
import org.higherkindedj.optics.Prism;
import org.higherkindedj.optics.Traversal;
import org.higherkindedj.optics.annotations.GenerateLenses;
import org.higherkindedj.optics.annotations.GeneratePrisms;
import org.higherkindedj.optics.annotations.GenerateTraversals;

public class ValidatedTraversalExample {

    // --- Data Model ---
    @GenerateLenses
    public record Permission(String name) {}

    @GeneratePrisms
    public sealed interface Principal {}

    @GenerateLenses
    @GenerateTraversals
    public record User(String username, List&lt;Permission&gt; permissions) implements Principal {}

    public record Guest() implements Principal {}

    @GenerateLenses
    public record Form(int formId, Principal principal) {}

    // --- Validation Logic ---
    private static final Set&lt;String&gt; VALID_PERMISSIONS = Set.of("PERM_READ", "PERM_WRITE", "PERM_DELETE");

    public static Kind&lt;ValidatedKind.Witness&lt;String&gt;, String&gt; validatePermissionName(String name) {
        if (VALID_PERMISSIONS.contains(name)) {
            return VALIDATED.widen(Validated.valid(name));
        } else {
            return VALIDATED.widen(Validated.invalid("Invalid permission: " + name));
        }
    }

    // --- Reusable Optic Compositions ---
    public static final Traversal&lt;Form, String&gt; FORM_TO_PERMISSION_NAMES =
            FormLenses.principal().asTraversal()
                    .andThen(PrincipalPrisms.userLogin().asTraversal())
                    .andThen(UserTraversals.permissions())
                    .andThen(PermissionLenses.name().asTraversal());

    // --- Helper Methods ---
    private static Applicative&lt;ValidatedKind.Witness&lt;String&gt;&gt; getValidatedApplicative() {
        return ValidatedMonad.instance(Semigroups.string("; "));
    }

    public static Validated&lt;String, Form&gt; validateFormPermissions(Form form) {
        Kind&lt;ValidatedKind.Witness&lt;String&gt;, Form&gt; result =
                FORM_TO_PERMISSION_NAMES.modifyF(
                        ValidatedTraversalExample::validatePermissionName,
                        form,
                        getValidatedApplicative()
                );
        return VALIDATED.narrow(result);
    }

    public static void main(String[] args) {
        System.out.println("=== OPTIC COMPOSITION VALIDATION EXAMPLE ===");
        System.out.println();

        // --- SCENARIO 1: Form with valid permissions ---
        System.out.println("--- Scenario 1: Valid Permissions ---");
        var validUser = new User("alice", List.of(
                new Permission("PERM_READ"),
                new Permission("PERM_WRITE")
        ));
        var validForm = new Form(1, validUser);

        System.out.println("Input: " + validForm);
        Validated&lt;String, Form&gt; validResult = validateFormPermissions(validForm);
        System.out.println("Result: " + validResult);
        System.out.println();

        // --- SCENARIO 2: Form with multiple invalid permissions ---
        System.out.println("--- Scenario 2: Multiple Invalid Permissions ---");
        var invalidUser = new User("charlie", List.of(
                new Permission("PERM_EXECUTE"),  // Invalid
                new Permission("PERM_WRITE"),    // Valid
                new Permission("PERM_SUDO"),     // Invalid
                new Permission("PERM_READ")      // Valid
        ));
        var multipleInvalidForm = new Form(3, invalidUser);

        System.out.println("Input: " + multipleInvalidForm);
        Validated&lt;String, Form&gt; invalidResult = validateFormPermissions(multipleInvalidForm);
        System.out.println("Result (errors accumulated): " + invalidResult);
        System.out.println();

        // --- SCENARIO 3: Form with Guest principal (no targets for traversal) ---
        System.out.println("--- Scenario 3: Guest Principal (No Validation Targets) ---");
        var guestForm = new Form(4, new Guest());

        System.out.println("Input: " + guestForm);
        Validated&lt;String, Form&gt; guestResult = validateFormPermissions(guestForm);
        System.out.println("Result (path does not match): " + guestResult);
        System.out.println();

        // --- SCENARIO 4: Form with empty permissions list ---
        System.out.println("--- Scenario 4: Empty Permissions List ---");
        var emptyPermissionsUser = new User("diana", List.of());
        var emptyPermissionsForm = new Form(5, emptyPermissionsUser);

        System.out.println("Input: " + emptyPermissionsForm);
        Validated&lt;String, Form&gt; emptyResult = validateFormPermissions(emptyPermissionsForm);
        System.out.println("Result (empty list): " + emptyResult);
        System.out.println();

        // --- SCENARIO 5: Demonstrating optic reusability ---
        System.out.println("--- Scenario 5: Optic Reusability ---");

        List&lt;Form&gt; formsToValidate = List.of(validForm, multipleInvalidForm, guestForm);

        System.out.println("Batch validation results:");
        formsToValidate.forEach(form -&gt; {
            Validated&lt;String, Form&gt; result = validateFormPermissions(form);
            String status = result.isValid() ? "✓ VALID" : "✗ INVALID";
            System.out.println("  Form " + form.formId() + ": " + status);
            if (result.isInvalid()) {
                // Fix: Use getError() instead of getInvalid()
                System.out.println("    Errors: " + result.getError());
            }
        });
        System.out.println();

        // --- SCENARIO 6: Alternative validation with different error accumulation ---
        System.out.println("--- Scenario 6: Different Error Accumulation Strategy ---");

        // Use list-based error accumulation instead of string concatenation
        Applicative&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;&gt; listApplicative =
                ValidatedMonad.instance(Semigroups.list());

        // Fix: Create a proper function for list validation
        java.util.function.Function&lt;String, Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, String&gt;&gt; listValidation =
                name -&gt; VALID_PERMISSIONS.contains(name)
                        ? VALIDATED.widen(Validated.valid(name))
                        : VALIDATED.widen(Validated.invalid(List.of("Invalid permission: " + name)));

        Kind&lt;ValidatedKind.Witness&lt;List&lt;String&gt;&gt;, Form&gt; listResult =
                FORM_TO_PERMISSION_NAMES.modifyF(listValidation, multipleInvalidForm, listApplicative);

        System.out.println("Input: " + multipleInvalidForm);
        System.out.println("Result with list accumulation: " + VALIDATED.narrow(listResult));
    }
}
</code></pre>
<p><strong>Expected Output:</strong></p>
<pre><code>=== OPTIC COMPOSITION VALIDATION EXAMPLE ===

--- Scenario 1: Valid Permissions ---
Input: Form[formId=1, principal=User[username=alice, permissions=[Permission[name=PERM_READ], Permission[name=PERM_WRITE]]]]
Result: Valid(Form[formId=1, principal=User[username=alice, permissions=[Permission[name=PERM_READ], Permission[name=PERM_WRITE]]]])

--- Scenario 2: Multiple Invalid Permissions ---
Input: Form[formId=3, principal=User[username=charlie, permissions=[Permission[name=PERM_EXECUTE], Permission[name=PERM_WRITE], Permission[name=PERM_SUDO], Permission[name=PERM_READ]]]]
Result (errors accumulated): Invalid(Invalid permission: PERM_EXECUTE; Invalid permission: PERM_SUDO)

--- Scenario 3: Guest Principal (No Validation Targets) ---
Input: Form[formId=4, principal=Guest[]]
Result (path does not match): Valid(Form[formId=4, principal=Guest[]])

--- Scenario 4: Empty Permissions List ---
Input: Form[formId=5, principal=User[username=diana, permissions=[]]]
Result (empty list): Valid(Form[formId=5, principal=User[username=diana, permissions=[]]])

--- Scenario 5: Optic Reusability ---
Batch validation results:
  Form 1: ✓ VALID
  Form 3: ✗ INVALID
    Errors: Invalid permission: PERM_EXECUTE; Invalid permission: PERM_SUDO
  Form 4: ✓ VALID

--- Scenario 6: Different Error Accumulation Strategy ---
Input: Form[formId=3, principal=User[username=charlie, permissions=[Permission[name=PERM_EXECUTE], Permission[name=PERM_WRITE], Permission[name=PERM_SUDO], Permission[name=PERM_READ]]]]
Result with list accumulation: Invalid([Invalid permission: PERM_EXECUTE, Invalid permission: PERM_SUDO])
</code></pre>
<p>This shows how our single, composed optic correctly handled all cases: it accumulated multiple failures into a single <code>Invalid</code> result, and it correctly did nothing (resulting in a <code>Valid</code> state) when the path did not match. This is the power of composing simple, reusable optics to solve complex problems in a safe, declarative, and boilerplate-free way.</p>
<hr />
<h2 id="why-this-approach-is-powerful"><a class="header" href="#why-this-approach-is-powerful">Why This Approach is Powerful</a></h2>
<p>This capstone example demonstrates several key advantages of the optics approach:</p>
<h3 id="declarative-composition"><a class="header" href="#declarative-composition"><strong>Declarative Composition</strong></a></h3>
<p>The <code>formToPermissionNameTraversal</code> reads like a clear path specification: "From a Form, go to the principal, if it's a User, then to each permission, then to each name." This is self-documenting code.</p>
<h3 id="type-safety"><a class="header" href="#type-safety"><strong>Type Safety</strong></a></h3>
<p>Every step in the composition is checked at compile time. It's impossible to accidentally apply permission validation to Guest data or to skip the User filtering step.</p>
<h3 id="automatic-error-accumulation"><a class="header" href="#automatic-error-accumulation"><strong>Automatic Error Accumulation</strong></a></h3>
<p>The <code>Validated</code> applicative automatically collects all validation errors without us having to write any error-handling boilerplate. We get comprehensive validation reports for free.</p>
<h3 id="reusability"><a class="header" href="#reusability"><strong>Reusability</strong></a></h3>
<p>The same composed optic can be used for validation, data extraction, transformation, or any other operation. We write the path once and reuse it everywhere.</p>
<h3 id="composability"><a class="header" href="#composability"><strong>Composability</strong></a></h3>
<p>Each individual optic (Lens, Prism, Traversal) can be tested and reasoned about independently, then composed to create more complex behaviour.</p>
<h3 id="graceful-handling-of-edge-cases"><a class="header" href="#graceful-handling-of-edge-cases"><strong>Graceful Handling of Edge Cases</strong></a></h3>
<p>The composition automatically handles empty collections, missing data, and type mismatches without special case code.</p>
<p>By mastering optic composition, you gain a powerful tool for building robust, maintainable data processing pipelines that are both expressive and efficient.</p>
<hr />
<h2 id="modern-simplification-validation-aware-methods"><a class="header" href="#modern-simplification-validation-aware-methods">Modern Simplification: Validation-Aware Methods</a></h2>
<div id="admonition-enhanced-validation-patterns" class="admonition admonish-tip" role="note" aria-labelledby="admonition-enhanced-validation-patterns-title">
<div class="admonition-title">
<div id="admonition-enhanced-validation-patterns-title">
<p>Enhanced Validation Patterns</p>
</div>
<a class="admonition-anchor-link" href="#admonition-enhanced-validation-patterns"></a>
</div>
<div>
<p>Higher-kinded-j provides specialised validation methods that simplify the patterns shown above. These methods eliminate the need for explicit <code>Applicative</code> setup whilst maintaining full type safety and error accumulation capabilities.</p>
</div>
</div>
<h3 id="the-traditional-approach-revisited"><a class="header" href="#the-traditional-approach-revisited">The Traditional Approach (Revisited)</a></h3>
<p>In the examples above, we used the general <code>modifyF</code> method with explicit <code>Applicative</code> configuration:</p>
<pre><code class="language-java">// Traditional approach: requires explicit Applicative setup
Applicative&lt;ValidatedKind.Witness&lt;String&gt;&gt; applicative =
    ValidatedMonad.instance(Semigroups.string("; "));

Kind&lt;ValidatedKind.Witness&lt;String&gt;, Form&gt; result =
    FORM_TO_PERMISSION_NAMES.modifyF(
        ValidatedTraversalExample::validatePermissionName,
        form,
        applicative
    );

Validated&lt;String, Form&gt; validated = VALIDATED.narrow(result);
</code></pre>
<p>Whilst powerful and flexible, this approach requires:</p>
<ul>
<li>Understanding of <code>Applicative</code> functors</li>
<li>Manual creation of the <code>Applicative</code> instance</li>
<li>Explicit narrowing of <code>Kind</code> results</li>
<li>Knowledge of <code>Witness</code> types and HKT encoding</li>
</ul>
<h3 id="the-simplified-approach-validation-aware-methods"><a class="header" href="#the-simplified-approach-validation-aware-methods">The Simplified Approach: Validation-Aware Methods</a></h3>
<p>The new validation-aware methods provide a more direct API for common validation patterns:</p>
<h4 id="1-error-accumulation-with-modifyallvalidated"><a class="header" href="#1-error-accumulation-with-modifyallvalidated">1. <strong>Error Accumulation with <code>modifyAllValidated</code></strong></a></h4>
<p>Simplifies the most common case: validating multiple fields and accumulating all errors.</p>
<pre><code class="language-java">import static org.higherkindedj.optics.fluent.OpticOps.modifyAllValidated;

// Simplified: direct Validated result, automatic error accumulation
Validated&lt;List&lt;String&gt;, Form&gt; result = modifyAllValidated(
    FORM_TO_PERMISSION_NAMES,
    name -&gt; VALID_PERMISSIONS.contains(name)
        ? Validated.valid(name)
        : Validated.invalid(List.of("Invalid permission: " + name)),
    form
);
</code></pre>
<p><strong>Benefits:</strong></p>
<ul>
<li>No <code>Applicative</code> setup required</li>
<li>Direct <code>Validated</code> result (no <code>Kind</code> wrapping)</li>
<li>Automatic error accumulation with <code>List&lt;E&gt;</code></li>
<li>Clear intent: "validate all and collect errors"</li>
</ul>
<h4 id="2-short-circuit-validation-with-modifyalleither"><a class="header" href="#2-short-circuit-validation-with-modifyalleither">2. <strong>Short-Circuit Validation with <code>modifyAllEither</code></strong></a></h4>
<p>For performance-critical validation that stops at the first error:</p>
<pre><code class="language-java">import static org.higherkindedj.optics.fluent.OpticOps.modifyAllEither;

// Short-circuit: stops at first error
Either&lt;String, Form&gt; result = modifyAllEither(
    FORM_TO_PERMISSION_NAMES,
    name -&gt; VALID_PERMISSIONS.contains(name)
        ? Either.right(name)
        : Either.left("Invalid permission: " + name),
    form
);
</code></pre>
<p><strong>Benefits:</strong></p>
<ul>
<li>Stops processing on first error (performance optimisation)</li>
<li>Direct <code>Either</code> result</li>
<li>Perfect for fail-fast validation</li>
<li>No unnecessary computation after failure</li>
</ul>
<h3 id="comparison-traditional-vs-validation-aware-methods"><a class="header" href="#comparison-traditional-vs-validation-aware-methods">Comparison: Traditional vs Validation-Aware Methods</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th>Traditional <code>modifyF</code></th><th>Validation-Aware Methods</th></tr></thead><tbody>
<tr><td><strong>Applicative Setup</strong></td><td>Required (explicit)</td><td>Not required (automatic)</td></tr>
<tr><td><strong>Type Complexity</strong></td><td>High (<code>Kind</code>, <code>Witness</code>)</td><td>Low (direct types)</td></tr>
<tr><td><strong>Error Accumulation</strong></td><td>Yes (via Applicative)</td><td>Yes (<code>modifyAllValidated</code>)</td></tr>
<tr><td><strong>Short-Circuiting</strong></td><td>Manual (via Either Applicative)</td><td>Built-in (<code>modifyAllEither</code>)</td></tr>
<tr><td><strong>Learning Curve</strong></td><td>Steep (HKT knowledge)</td><td>Gentle (familiar types)</td></tr>
<tr><td><strong>Flexibility</strong></td><td>Maximum (any Applicative)</td><td>Focused (common patterns)</td></tr>
<tr><td><strong>Boilerplate</strong></td><td>More (setup code)</td><td>Less (direct API)</td></tr>
<tr><td><strong>Use Case</strong></td><td>Generic effectful operations</td><td>Validation-specific scenarios</td></tr>
</tbody></table>
</div>
<h3 id="when-to-use-each-approach"><a class="header" href="#when-to-use-each-approach">When to Use Each Approach</a></h3>
<p><strong>Use <code>modifyAllValidated</code> when:</strong></p>
<ul>
<li>You need to <strong>collect all validation errors</strong></li>
<li>Building <strong>form validation</strong> or <strong>data quality checks</strong></li>
<li>Users need <strong>comprehensive error reports</strong></li>
</ul>
<pre><code class="language-java">// Perfect for form validation
Validated&lt;List&lt;String&gt;, OrderForm&gt; validated = modifyAllValidated(
    ORDER_TO_PRICES,
    price -&gt; validatePrice(price),
    orderForm
);
</code></pre>
<p><strong>Use <code>modifyAllEither</code> when:</strong></p>
<ul>
<li>You want <strong>fail-fast behaviour</strong></li>
<li>Working in <strong>performance-critical</strong> paths</li>
<li>First error is <strong>sufficient feedback</strong></li>
</ul>
<pre><code class="language-java">// Perfect for quick validation in high-throughput scenarios
Either&lt;String, OrderForm&gt; validated = modifyAllEither(
    ORDER_TO_PRICES,
    price -&gt; validatePrice(price),
    orderForm
);
</code></pre>
<p><strong>Use <code>modifyMaybe</code> when:</strong></p>
<ul>
<li>Invalid items should be <strong>silently filtered</strong></li>
<li>Building <strong>data enrichment</strong> pipelines</li>
<li>Failures are <strong>expected and ignorable</strong></li>
</ul>
<pre><code class="language-java">// Perfect for optional enrichment
Maybe&lt;OrderForm&gt; enriched = modifyMaybe(
    ORDER_TO_OPTIONAL_DISCOUNTS,
    discount -&gt; tryApplyDiscount(discount),
    orderForm
);
</code></pre>
<p><strong>Use traditional <code>modifyF</code> when:</strong></p>
<ul>
<li>Working with <strong>custom Applicative</strong> functors</li>
<li>Need <strong>maximum flexibility</strong></li>
<li>Building <strong>generic abstractions</strong></li>
<li>Using effects <strong>beyond validation</strong> (IO, Future, etc.)</li>
</ul>
<pre><code class="language-java">// Still valuable for generic effectful operations
Kind&lt;F, Form&gt; result = FORM_TO_PERMISSION_NAMES.modifyF(
    effectfulValidation,
    form,
    customApplicative
);
</code></pre>
<h3 id="real-world-example-simplified-validation"><a class="header" href="#real-world-example-simplified-validation">Real-World Example: Simplified Validation</a></h3>
<p>Here's how the original example can be simplified using the new methods:</p>
<pre><code class="language-java">import static org.higherkindedj.optics.fluent.OpticOps.modifyAllValidated;
import org.higherkindedj.hkt.validated.Validated;
import java.util.List;

public class SimplifiedValidation {
    // Same traversal as before
    public static final Traversal&lt;Form, String&gt; FORM_TO_PERMISSION_NAMES =
        FormLenses.principal().asTraversal()
            .andThen(PrincipalPrisms.userLogin().asTraversal())
            .andThen(UserTraversals.permissions())
            .andThen(PermissionLenses.name().asTraversal());

    // Simplified validation - no Applicative setup needed
    public static Validated&lt;List&lt;String&gt;, Form&gt; validateFormPermissions(Form form) {
        return modifyAllValidated(
            FORM_TO_PERMISSION_NAMES,
            name -&gt; VALID_PERMISSIONS.contains(name)
                ? Validated.valid(name)
                : Validated.invalid(List.of("Invalid permission: " + name)),
            form
        );
    }

    // Alternative: fail-fast validation
    public static Either&lt;String, Form&gt; validateFormPermissionsFast(Form form) {
        return modifyAllEither(
            FORM_TO_PERMISSION_NAMES,
            name -&gt; VALID_PERMISSIONS.contains(name)
                ? Either.right(name)
                : Either.left("Invalid permission: " + name),
            form
        );
    }
}
</code></pre>
<p><strong>Benefits of the Simplified Approach:</strong></p>
<ul>
<li><strong>~60% less code</strong>: No <code>Applicative</code> setup, no <code>Kind</code> wrapping, no narrowing</li>
<li><strong>Clearer intent</strong>: Method name explicitly states the validation strategy</li>
<li><strong>Easier to learn</strong>: Uses familiar types (<code>Validated</code>, <code>Either</code>, <code>Maybe</code>)</li>
<li><strong>Equally powerful</strong>: Same type safety, same error accumulation, same composition</li>
</ul>
<div id="admonition-complete-example" class="admonition admonish-note" role="note" aria-labelledby="admonition-complete-example-title">
<div class="admonition-title">
<div id="admonition-complete-example-title">
<p>Complete Example</p>
</div>
<a class="admonition-anchor-link" href="#admonition-complete-example"></a>
</div>
<div>
<p>See <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/fluent/FluentValidationExample.java">FluentValidationExample.java</a> for comprehensive demonstrations of all validation-aware methods, including complex real-world scenarios like order validation and bulk data import.</p>
</div>
</div>
<div id="admonition-see-also" class="admonition admonish-tip" role="note" aria-labelledby="admonition-see-also-title">
<div class="admonition-title">
<div id="admonition-see-also-title">
<p>See Also</p>
</div>
<a class="admonition-anchor-link" href="#admonition-see-also"></a>
</div>
<div>
<p>For a complete guide to validation-aware modifications including fluent builder API, integration with Jakarta Bean Validation, and performance optimisation, see <a href="fluent_api.html#part-25-validation-aware-modifications">Fluent API for Optics</a>.</p>
</div>
</div>
<div id="admonition-hands-on-learning" class="admonition admonish-info" role="note" aria-labelledby="admonition-hands-on-learning-title">
<div class="admonition-title">
<div id="admonition-hands-on-learning-title">
<p>Hands-On Learning</p>
</div>
<a class="admonition-anchor-link" href="#admonition-hands-on-learning"></a>
</div>
<div>
<p>Practice optic composition in <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/test/java/org/higherkindedj/tutorial/optics/Tutorial06_OpticsComposition.java">Tutorial 06: Optics Composition</a> (7 exercises, ~10 minutes).</p>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="profunctor_optics.html">Profunctor Optics: Advanced Data Transformation</a>
<strong>Next:</strong> <a href="core_type_integration.html">Core Type Integration</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../optics/ch5_intro.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../optics/core_type_integration.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../optics/ch5_intro.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../optics/core_type_integration.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../version-switcher.js"></script>
        <script src=".././theme/version-switcher.js"></script>
        <script src=".././theme/sidebar-nav-link.js"></script>


    </div>
    </body>
</html>
