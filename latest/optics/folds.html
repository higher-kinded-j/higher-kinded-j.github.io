<!DOCTYPE HTML>
<html lang="en" class="latte sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Folds - Higher-Kinded Types and Optics for Java</title>


        <!-- Custom HTML head -->


            <meta name="description" content="Explore Higher-Kinded Types (HKTs) and Optcs in Java with the Higher-Kinded-J library. Learn about Functors, Applicatives, Monads, Transformers, practical functional patterns, and how to write cleaner, more composable Java code for your projects using Optics.">


        <meta name="keywords" content="Higher-Kinded Types, Higher-Kinded-J, Higher-Kinded Java, Higher Kinded Java, HKT, Java, Optics, Lens, Prism, Traversal, Iso, Functional Programming, Monad, Functor, Applicative, Transformer, Monoid, Traverse, higherkindedj">
        
        <meta property="og:title" content="Folds - Higher-Kinded Types and Optics for Java"> 
            <meta property="og:description" content="Explore Higher-Kinded Types (HKTs) and Optcs in Java with the Higher-Kinded-J library. Learn about Functors, Applicatives, Monads, Transformers, practical functional patterns, and how to write cleaner, more composable Java code for your projects using Optics.">
        <meta property="og:type" content="website">
        <meta property="og:url" content="https://higher-kinded-j.github.io/"> 
        
        <meta property="og:image" content="https://higher-kinded-j.github.io/preview.png" />
        <meta property="og:site_name" content="Higher-Kinded-J Documentation" />
        
        
        <meta name="twitter:card" content="summary_large_image" /> <meta name="twitter:title" content="Folds - Higher-Kinded Types and Optics for Java - Higher-Kinded-J" />
        <meta name="twitter:description" content="Bringing Higher-Kinded Types and Optics to Java functional patterns" />
        <meta name="twitter:image" content="https://higher-kinded-j.github.io/preview.png" />
        <meta name="description" content="Explore Higher-Kinded Types (HKTs) and Optcs in Java with the Higher-Kinded-J library. Learn about Functors, Applicatives, Monads, Transformers, practical functional patterns, and how to write cleaner, more composable Java code for your projects using Optics.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">
        <meta name="google-site-verification" content="X-xsiAq2cKMLOzh9dexUrX8Onx2h_YMUFgp5lHHUwSg" />
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href=".././mdbook-admonish.css">
        <link rel="stylesheet" href=".././theme/catppuccin.css">
        <link rel="stylesheet" href=".././theme/catppuccin-admonish.css">
        <link rel="stylesheet" href=".././theme/catppuccin-alerts.css">
        <link rel="stylesheet" href=".././theme/additional-hkj.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "latte";
            const default_dark_theme = "macchiato";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('latte')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="latte">Latte</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="frappe">Frapp√©</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="macchiato">Macchiato</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mocha">Mocha</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        <div class="version-selector-container">
                            <select id="version-selector" class="version-selector" aria-label="Select documentation version" title="Select documentation version">
                                <option value="">Loading versions...</option>
                            </select>
                        </div>
                    </div>

                    <h1 class="menu-title">Higher-Kinded Types and Optics for Java</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/higher-kinded-j/higher-kinded-j" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/higher-kinded-j/higher-kinded-j/edit/main/hkj-book/src/optics/folds.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="folds-a-practical-guide"><a class="header" href="#folds-a-practical-guide">Folds: A Practical Guide</a></h1>
<h2 id="querying-immutable-data"><a class="header" href="#querying-immutable-data"><em>Querying Immutable Data</em></a></h2>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to query and extract data from complex structures without modification</li>
<li>Using <code>@GenerateFolds</code> to create type-safe query optics automatically</li>
<li>Understanding the relationship between Fold and the Foldable type class</li>
<li>Aggregating data with monoids for sums, products, and custom combiners</li>
<li>Composing folds with other optics for deep, conditional queries</li>
<li>The difference between <code>getAll</code>, <code>preview</code>, <code>find</code>, <code>exists</code>, <code>all</code>, and <code>length</code></li>
<li>Maybe-based extensions for functional optional handling (<code>previewMaybe</code>, <code>findMaybe</code>, <code>getAllMaybe</code>)</li>
<li>When to use Fold vs Traversal vs direct field access vs Stream API</li>
<li>Building read-only data processing pipelines with clear intent</li>
</ul>
</div>
</div>
<div id="admonition-example-code" class="admonition admonish-note" role="note" aria-labelledby="admonition-example-code-title">
<div class="admonition-title">
<div id="admonition-example-code-title">
<p>Example Code</p>
</div>
<a class="admonition-anchor-link" href="#admonition-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/FoldUsageExample.java">FoldUsageExample</a></p>
</div>
</div>
<p>In previous guides, we explored optics that allow both reading and writing: <strong><code>Lens</code></strong> for required fields, <strong><code>Prism</code></strong> for conditional variants, <strong><code>Iso</code></strong> for lossless conversions, and <strong><code>Traversal</code></strong> for bulk operations on collections.</p>
<p>But what if you need to perform read-only operations? What if you want to query, search, filter, or aggregate data without any possibility of modification? This is where <strong><code>Fold</code></strong> shines.</p>
<hr />
<h2 id="the-scenario-analysing-e-commerce-orders"><a class="header" href="#the-scenario-analysing-e-commerce-orders">The Scenario: Analysing E-Commerce Orders</a></h2>
<p>A <strong><code>Fold</code></strong> is a read-only optic designed specifically for querying and data extraction. Think of it as a <strong>database query tool</strong> üîç or a <strong>telescope</strong> üî≠ that lets you peer into your data structures, extract information, and aggregate results‚Äîall without the ability to modify anything.</p>
<p>Consider an e-commerce system where you need to analyse orders:</p>
<p><strong>The Data Model:</strong></p>
<pre><code class="language-java">@GenerateLenses
public record Product(String name, double price, String category, boolean inStock) {}

@GenerateLenses
@GenerateFolds  // Generate Folds for querying
public record Order(String orderId, List&lt;Product&gt; items, String customerName) {}

@GenerateLenses
@GenerateFolds
public record OrderHistory(List&lt;Order&gt; orders) {}
</code></pre>
<p><strong>Common Query Needs:</strong></p>
<ul>
<li>"Find all products in this order"</li>
<li>"Get the first product or empty if none"</li>
<li>"Check if any product is out of stock"</li>
<li>"Count how many items are in the order"</li>
<li>"Calculate the total price of all items"</li>
<li>"Check if all items are under ¬£100"</li>
</ul>
<p>A <code>Fold</code> makes these queries type-safe, composable, and expressive.</p>
<hr />
<h2 id="think-of-folds-like"><a class="header" href="#think-of-folds-like">Think of Folds Like...</a></h2>
<ul>
<li><strong>A database query</strong>: Extracting specific data from complex structures</li>
<li><strong>A read-only telescope</strong>: Magnifying and examining data without touching it</li>
<li><strong>A search engine</strong>: Finding and collecting information efficiently</li>
<li><strong>An aggregation pipeline</strong>: Combining values according to rules (via monoids)</li>
<li><strong>A reporter</strong>: Summarising data into useful metrics</li>
</ul>
<hr />
<h2 id="fold-vs-traversal-understanding-the-difference"><a class="header" href="#fold-vs-traversal-understanding-the-difference">Fold vs Traversal: Understanding the Difference</a></h2>
<p>Before we dive deeper, it's crucial to understand how <code>Fold</code> relates to <code>Traversal</code>:</p>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th>Traversal</th><th>Fold</th></tr></thead><tbody>
<tr><td><strong>Purpose</strong></td><td>Read and modify collections</td><td>Read-only queries</td></tr>
<tr><td><strong>Can modify?</strong></td><td>‚úÖ Yes (<code>set</code>, <code>modify</code>)</td><td>‚ùå No</td></tr>
<tr><td><strong>Query operations</strong></td><td>‚úÖ Yes (via <code>getAll</code>, but not primary purpose)</td><td>‚úÖ Yes (designed for this)</td></tr>
<tr><td><strong>Intent clarity</strong></td><td>"I might modify this"</td><td>"I'm only reading this"</td></tr>
<tr><td><strong>Conversion</strong></td><td>Can be converted to Fold via <code>asFold()</code></td><td>Cannot be converted to Traversal</td></tr>
<tr><td><strong>Use cases</strong></td><td>Bulk updates, validation with modifications</td><td>Queries, searches, aggregations</td></tr>
</tbody></table>
</div>
<p><strong>Key Insight</strong>: Every <code>Traversal</code> can be viewed as a <code>Fold</code> (read-only subset), but not every <code>Fold</code> can be a <code>Traversal</code>. By choosing <code>Fold</code> when you only need reading, you make your code's intent clear and prevent accidental modifications.</p>
<hr />
<h2 id="a-step-by-step-walkthrough"><a class="header" href="#a-step-by-step-walkthrough">A Step-by-Step Walkthrough</a></h2>
<h3 id="step-1-generating-folds"><a class="header" href="#step-1-generating-folds">Step 1: Generating Folds</a></h3>
<p>Just like with other optics, we use annotations to trigger automatic code generation. Annotating a record with <strong><code>@GenerateFolds</code></strong> creates a companion class (e.g., <code>OrderFolds</code>) containing a <code>Fold</code> for each field.</p>
<pre><code class="language-java">import org.higherkindedj.optics.annotations.GenerateFolds;
import org.higherkindedj.optics.annotations.GenerateLenses;
import java.util.List;

@GenerateLenses
public record Product(String name, double price, String category, boolean inStock) {}

@GenerateLenses
@GenerateFolds
public record Order(String orderId, List&lt;Product&gt; items, String customerName) {}
</code></pre>
<p>This generates:</p>
<ul>
<li><code>OrderFolds.items()</code> ‚Üí <code>Fold&lt;Order, Product&gt;</code> (focuses on all products)</li>
<li><code>OrderFolds.orderId()</code> ‚Üí <code>Fold&lt;Order, String&gt;</code> (focuses on the order ID)</li>
<li><code>OrderFolds.customerName()</code> ‚Üí <code>Fold&lt;Order, String&gt;</code> (focuses on customer name)</li>
</ul>
<h3 id="step-2-the-core-fold-operations"><a class="header" href="#step-2-the-core-fold-operations">Step 2: The Core Fold Operations</a></h3>
<p>A <code>Fold&lt;S, A&gt;</code> provides these essential query operations:</p>
<h4 id="getallsource-extract-all-focused-values"><a class="header" href="#getallsource-extract-all-focused-values"><strong><code>getAll(source)</code></strong>: Extract All Focused Values</a></h4>
<p>Returns a <code>List&lt;A&gt;</code> containing all the values the Fold focuses on.</p>
<pre><code class="language-java">Fold&lt;Order, Product&gt; itemsFold = OrderFolds.items();
Order order = new Order("ORD-123", List.of(
    new Product("Laptop", 999.99, "Electronics", true),
    new Product("Mouse", 25.00, "Electronics", true),
    new Product("Desk", 350.00, "Furniture", false)
), "Alice");

List&lt;Product&gt; allProducts = itemsFold.getAll(order);
// Result: [Product[Laptop, 999.99, ...], Product[Mouse, 25.00, ...], Product[Desk, 350.00, ...]]
</code></pre>
<h4 id="previewsource-get-the-first-value"><a class="header" href="#previewsource-get-the-first-value"><strong><code>preview(source)</code></strong>: Get the First Value</a></h4>
<p>Returns an <code>Optional&lt;A&gt;</code> containing the first focused value, or <code>Optional.empty()</code> if none exist.</p>
<pre><code class="language-java">Optional&lt;Product&gt; firstProduct = itemsFold.preview(order);
// Result: Optional[Product[Laptop, 999.99, ...]]

Order emptyOrder = new Order("ORD-456", List.of(), "Bob");
Optional&lt;Product&gt; noProduct = itemsFold.preview(emptyOrder);
// Result: Optional.empty
</code></pre>
<h4 id="findpredicate-source-find-first-matching-value"><a class="header" href="#findpredicate-source-find-first-matching-value"><strong><code>find(predicate, source)</code></strong>: Find First Matching Value</a></h4>
<p>Returns an <code>Optional&lt;A&gt;</code> containing the first value that matches the predicate.</p>
<pre><code class="language-java">Optional&lt;Product&gt; expensiveProduct = itemsFold.find(
    product -&gt; product.price() &gt; 500.00,
    order
);
// Result: Optional[Product[Laptop, 999.99, ...]]
</code></pre>
<h4 id="existspredicate-source-check-if-any-match"><a class="header" href="#existspredicate-source-check-if-any-match"><strong><code>exists(predicate, source)</code></strong>: Check If Any Match</a></h4>
<p>Returns <code>true</code> if at least one focused value matches the predicate.</p>
<pre><code class="language-java">boolean hasOutOfStock = itemsFold.exists(
    product -&gt; !product.inStock(),
    order
);
// Result: true (Desk is out of stock)
</code></pre>
<h4 id="allpredicate-source-check-if-all-match"><a class="header" href="#allpredicate-source-check-if-all-match"><strong><code>all(predicate, source)</code></strong>: Check If All Match</a></h4>
<p>Returns <code>true</code> if all focused values match the predicate (returns <code>true</code> for empty collections).</p>
<pre><code class="language-java">boolean allInStock = itemsFold.all(
    product -&gt; product.inStock(),
    order
);
// Result: false (Desk is out of stock)
</code></pre>
<h4 id="isemptysource-check-for-empty"><a class="header" href="#isemptysource-check-for-empty"><strong><code>isEmpty(source)</code></strong>: Check for Empty</a></h4>
<p>Returns <code>true</code> if there are zero focused values.</p>
<pre><code class="language-java">boolean hasItems = !itemsFold.isEmpty(order);
// Result: true
</code></pre>
<h4 id="lengthsource-count-values"><a class="header" href="#lengthsource-count-values"><strong><code>length(source)</code></strong>: Count Values</a></h4>
<p>Returns the number of focused values as an <code>int</code>.</p>
<pre><code class="language-java">int itemCount = itemsFold.length(order);
// Result: 3
</code></pre>
<h3 id="step-25-maybe-based-fold-extensions"><a class="header" href="#step-25-maybe-based-fold-extensions">Step 2.5: Maybe-Based Fold Extensions</a></h3>
<div id="admonition-extension-methods" class="admonition admonish-note" role="note" aria-labelledby="admonition-extension-methods-title">
<div class="admonition-title">
<div id="admonition-extension-methods-title">
<p>Extension Methods</p>
</div>
<a class="admonition-anchor-link" href="#admonition-extension-methods"></a>
</div>
<div>
<p>Higher-kinded-j provides extension methods that integrate <code>Fold</code> with the <code>Maybe</code> type, offering a more functional approach to handling absent values compared to Java's <code>Optional</code>. These extensions are available via static imports from <code>FoldExtensions</code>.</p>
</div>
</div>
<h4 id="the-challenge-working-with-nullable-values"><a class="header" href="#the-challenge-working-with-nullable-values">The Challenge: Working with Nullable Values</a></h4>
<p>Standard Fold operations use <code>Optional&lt;A&gt;</code> for operations that might not find a value (like <code>preview</code> and <code>find</code>). While <code>Optional</code> works well, functional programming often prefers <code>Maybe</code> because it:</p>
<ul>
<li>Integrates seamlessly with Higher-Kinded Types (HKT)</li>
<li>Works consistently with other monadic operations (<code>flatMap</code>, <code>map</code>, <code>fold</code>)</li>
<li>Provides better composition with validation and error handling types</li>
<li>Offers a more principled functional API</li>
</ul>
<p>Think of <code>Maybe</code> as <code>Optional</code>'s more functional cousin‚Äîthey both represent "a value or nothing", but <code>Maybe</code> plays more nicely with the rest of the functional toolkit.</p>
<h4 id="think-of-maybe-based-extensions-like"><a class="header" href="#think-of-maybe-based-extensions-like">Think of Maybe-Based Extensions Like...</a></h4>
<ul>
<li><strong>A search that returns "found" or "not found"</strong> - <code>Maybe</code> explicitly models presence or absence</li>
<li><strong>A safe lookup in a dictionary</strong> - Either you get the value wrapped in <code>Just</code>, or you get <code>Nothing</code></li>
<li><strong>A nullable pointer that can't cause NPE</strong> - You must explicitly check before unwrapping</li>
<li><strong>Optional's functional sibling</strong> - Same concept, better integration with functional patterns</li>
</ul>
<h4 id="the-three-extension-methods"><a class="header" href="#the-three-extension-methods">The Three Extension Methods</a></h4>
<p>All three methods are static imports from <code>org.higherkindedj.optics.extensions.FoldExtensions</code>:</p>
<pre><code class="language-java">import static org.higherkindedj.optics.extensions.FoldExtensions.*;
</code></pre>
<h5 id="1-previewmaybefold-source---get-first-value-as-maybe"><a class="header" href="#1-previewmaybefold-source---get-first-value-as-maybe">1. <code>previewMaybe(fold, source)</code> - Get First Value as Maybe</a></h5>
<p>The <code>previewMaybe</code> method is the <code>Maybe</code>-based equivalent of <code>preview()</code>. It returns the first focused value wrapped in <code>Maybe</code>, or <code>Maybe.nothing()</code> if none exist.</p>
<pre><code class="language-java">import org.higherkindedj.hkt.maybe.Maybe;
import static org.higherkindedj.optics.extensions.FoldExtensions.previewMaybe;

Fold&lt;Order, Product&gt; itemsFold = OrderFolds.items();
Order order = new Order("ORD-123", List.of(
    new Product("Laptop", 999.99, "Electronics", true),
    new Product("Mouse", 25.00, "Electronics", true)
), "Alice");

Maybe&lt;Product&gt; firstProduct = previewMaybe(itemsFold, order);
// Result: Just(Product[Laptop, 999.99, ...])

Order emptyOrder = new Order("ORD-456", List.of(), "Bob");
Maybe&lt;Product&gt; noProduct = previewMaybe(itemsFold, emptyOrder);
// Result: Nothing
</code></pre>
<p><strong>When to use <code>previewMaybe</code> vs <code>preview</code>:</strong></p>
<ul>
<li>Use <code>previewMaybe</code> when working in a functional pipeline with other <code>Maybe</code> values</li>
<li>Use <code>preview</code> when interoperating with standard Java code expecting <code>Optional</code></li>
<li>Use <code>previewMaybe</code> when you need HKT compatibility for generic functional abstractions</li>
</ul>
<h5 id="2-findmaybefold-predicate-source---find-first-match-as-maybe"><a class="header" href="#2-findmaybefold-predicate-source---find-first-match-as-maybe">2. <code>findMaybe(fold, predicate, source)</code> - Find First Match as Maybe</a></h5>
<p>The <code>findMaybe</code> method is the <code>Maybe</code>-based equivalent of <code>find()</code>. It returns the first focused value matching the predicate, or <code>Maybe.nothing()</code> if no match is found.</p>
<pre><code class="language-java">import static org.higherkindedj.optics.extensions.FoldExtensions.findMaybe;

Fold&lt;Order, Product&gt; itemsFold = OrderFolds.items();

Maybe&lt;Product&gt; expensiveProduct = findMaybe(
    itemsFold,
    product -&gt; product.price() &gt; 500.00,
    order
);
// Result: Just(Product[Laptop, 999.99, ...])

Maybe&lt;Product&gt; luxuryProduct = findMaybe(
    itemsFold,
    product -&gt; product.price() &gt; 5000.00,
    order
);
// Result: Nothing
</code></pre>
<p><strong>Common Use Cases:</strong></p>
<ul>
<li><strong>Product search</strong>: Find first available item matching criteria</li>
<li><strong>Validation</strong>: Locate the first invalid field in a form</li>
<li><strong>Configuration</strong>: Find the first matching configuration option</li>
<li><strong>Inventory</strong>: Locate first in-stock item in a category</li>
</ul>
<h5 id="3-getallmaybefold-source---get-all-values-as-maybe-wrapped-list"><a class="header" href="#3-getallmaybefold-source---get-all-values-as-maybe-wrapped-list">3. <code>getAllMaybe(fold, source)</code> - Get All Values as Maybe-Wrapped List</a></h5>
<p>The <code>getAllMaybe</code> method returns all focused values as <code>Maybe&lt;List&lt;A&gt;&gt;</code>. If the Fold finds at least one value, you get <code>Just(List&lt;A&gt;)</code>. If it finds nothing, you get <code>Nothing</code>.</p>
<p>This is particularly useful when you want to distinguish between "found an empty collection" and "found no results".</p>
<pre><code class="language-java">import static org.higherkindedj.optics.extensions.FoldExtensions.getAllMaybe;

Fold&lt;Order, Product&gt; itemsFold = OrderFolds.items();

Maybe&lt;List&lt;Product&gt;&gt; allProducts = getAllMaybe(itemsFold, order);
// Result: Just([Product[Laptop, ...], Product[Mouse, ...]])

Order emptyOrder = new Order("ORD-456", List.of(), "Bob");
Maybe&lt;List&lt;Product&gt;&gt; noProducts = getAllMaybe(itemsFold, emptyOrder);
// Result: Nothing
</code></pre>
<p><strong>When to use <code>getAllMaybe</code> vs <code>getAll</code>:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Scenario</th><th>Use <code>getAll()</code></th><th>Use <code>getAllMaybe()</code></th></tr></thead><tbody>
<tr><td>You need the list regardless of emptiness</td><td>‚úÖ Returns <code>List&lt;A&gt;</code> (possibly empty)</td><td>‚ùå Overkill</td></tr>
<tr><td>You want to treat empty results as a failure case</td><td>‚ùå Must check <code>isEmpty()</code> manually</td><td>‚úÖ Returns <code>Nothing</code> for empty results</td></tr>
<tr><td>You're chaining functional operations with Maybe</td><td>‚ùå Requires conversion</td><td>‚úÖ Directly composable</td></tr>
<tr><td>Performance-critical batch processing</td><td>‚úÖ Direct list access</td><td>‚ùå Extra Maybe wrapping</td></tr>
</tbody></table>
</div>
<h4 id="real-world-scenario-product-search-with-maybe"><a class="header" href="#real-world-scenario-product-search-with-maybe">Real-World Scenario: Product Search with Maybe</a></h4>
<p>Here's a practical example showing how Maybe-based extensions simplify null-safe querying:</p>
<pre><code class="language-java">import org.higherkindedj.optics.Fold;
import org.higherkindedj.optics.annotations.GenerateFolds;
import org.higherkindedj.hkt.maybe.Maybe;
import static org.higherkindedj.optics.extensions.FoldExtensions.*;

@GenerateFolds
public record ProductCatalog(List&lt;Product&gt; products) {}

public class ProductSearchService {
    private static final Fold&lt;ProductCatalog, Product&gt; ALL_PRODUCTS =
        ProductCatalogFolds.products();

    // Find the cheapest in-stock product in a category
    public Maybe&lt;Product&gt; findCheapestInCategory(
        ProductCatalog catalog,
        String category
    ) {
        return getAllMaybe(ALL_PRODUCTS, catalog)
            .map(products -&gt; products.stream()
                .filter(p -&gt; category.equals(p.category()))
                .filter(Product::inStock)
                .min(Comparator.comparing(Product::price))
                .orElse(null)
            )
            .flatMap(Maybe::fromNullable);  // Convert null to Nothing
    }

    // Get first premium product (&gt;¬£1000)
    public Maybe&lt;Product&gt; findPremiumProduct(ProductCatalog catalog) {
        return findMaybe(
            ALL_PRODUCTS,
            product -&gt; product.price() &gt; 1000.00,
            catalog
        );
    }

    // Check if any products are available
    public boolean hasAvailableProducts(ProductCatalog catalog) {
        return getAllMaybe(ALL_PRODUCTS, catalog)
            .map(products -&gt; products.stream().anyMatch(Product::inStock))
            .getOrElse(false);
    }

    // Extract all product names (or empty message)
    public String getProductSummary(ProductCatalog catalog) {
        return getAllMaybe(ALL_PRODUCTS, catalog)
            .map(products -&gt; products.stream()
                .map(Product::name)
                .collect(Collectors.joining(", "))
            )
            .getOrElse("No products available");
    }
}
</code></pre>
<h4 id="optional-vs-maybe-a-comparison"><a class="header" href="#optional-vs-maybe-a-comparison">Optional vs Maybe: A Comparison</a></h4>
<p>Understanding when to use each type helps you make informed decisions:</p>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th><code>Optional&lt;A&gt;</code></th><th><code>Maybe&lt;A&gt;</code></th></tr></thead><tbody>
<tr><td><strong>Purpose</strong></td><td>Standard Java optional values</td><td>Functional optional values with HKT support</td></tr>
<tr><td><strong>Package</strong></td><td><code>java.util.Optional</code></td><td><code>org.higherkindedj.hkt.maybe.Maybe</code></td></tr>
<tr><td><strong>HKT Support</strong></td><td>‚ùå No</td><td>‚úÖ Yes (integrates with <code>Kind&lt;F, A&gt;</code>)</td></tr>
<tr><td><strong>Monadic Operations</strong></td><td>Limited (<code>map</code>, <code>flatMap</code>, <code>filter</code>)</td><td>Full (<code>map</code>, <code>flatMap</code>, <code>filter</code>, <code>fold</code>, <code>getOrElse</code>, etc.)</td></tr>
<tr><td><strong>Java Interop</strong></td><td>‚úÖ Native support</td><td>‚ùå Requires conversion</td></tr>
<tr><td><strong>Functional Composition</strong></td><td>Basic</td><td>‚úÖ Excellent (works with Applicative, Monad, etc.)</td></tr>
<tr><td><strong>Pattern Matching</strong></td><td><code>ifPresent()</code>, <code>orElse()</code></td><td><code>isJust()</code>, <code>isNothing()</code>, <code>fold()</code></td></tr>
<tr><td><strong>Use Cases</strong></td><td>Standard Java APIs, interop</td><td>Functional pipelines, HKT abstractions</td></tr>
<tr><td><strong>Conversion</strong></td><td><code>Maybe.fromOptional(opt)</code></td><td><code>maybe.toOptional()</code></td></tr>
</tbody></table>
</div>
<p><strong>Best Practice</strong>: Use <code>Optional</code> at API boundaries (public methods, external libraries) and <code>Maybe</code> internally in functional pipelines.</p>
<h4 id="when-to-use-each-extension-method"><a class="header" href="#when-to-use-each-extension-method">When to Use Each Extension Method</a></h4>
<p>Here's a decision matrix to help you choose the right method:</p>
<p><strong>Use <code>previewMaybe</code> when:</strong></p>
<ul>
<li>You need the first value from a Fold</li>
<li>You're working in a functional pipeline with other <code>Maybe</code> values</li>
<li>You want to chain operations (<code>map</code>, <code>flatMap</code>, <code>fold</code>) on the result</li>
<li>You need HKT compatibility</li>
</ul>
<pre><code class="language-java">// Example: Get first expensive product and calculate discount
Maybe&lt;Double&gt; discountedPrice = previewMaybe(productsFold, order)
    .filter(p -&gt; p.price() &gt; 100)
    .map(p -&gt; p.price() * 0.9);
</code></pre>
<p><strong>Use <code>findMaybe</code> when:</strong></p>
<ul>
<li>You need to locate a specific value matching a predicate</li>
<li>You want to avoid the verbosity of <code>getAll().stream().filter().findFirst()</code></li>
<li>You're building search functionality</li>
<li>You want to short-circuit on the first match (performance)</li>
</ul>
<pre><code class="language-java">// Example: Find first out-of-stock item
Maybe&lt;Product&gt; outOfStock = findMaybe(
    productsFold,
    p -&gt; !p.inStock(),
    order
);
</code></pre>
<p><strong>Use <code>getAllMaybe</code> when:</strong></p>
<ul>
<li>You want to treat empty results as a "nothing" case</li>
<li>You want to chain functional operations on the entire result set</li>
<li>You're building batch processing pipelines</li>
<li>You need to propagate "nothing found" through your computation</li>
</ul>
<pre><code class="language-java">// Example: Process all products or provide default behaviour
String report = getAllMaybe(productsFold, order)
    .map(products -&gt; generateReport(products))
    .getOrElse("No products to report");
</code></pre>
<h4 id="integration-with-existing-fold-operations"><a class="header" href="#integration-with-existing-fold-operations">Integration with Existing Fold Operations</a></h4>
<p>Maybe-based extensions work seamlessly alongside standard Fold operations. You can mix and match based on your needs:</p>
<pre><code class="language-java">Fold&lt;Order, Product&gt; itemsFold = OrderFolds.items();

// Standard Fold operations
List&lt;Product&gt; allItems = itemsFold.getAll(order);           // Always returns list
Optional&lt;Product&gt; firstOpt = itemsFold.preview(order);     // Optional-based
int count = itemsFold.length(order);                        // Primitive int

// Maybe-based extensions
Maybe&lt;Product&gt; firstMaybe = previewMaybe(itemsFold, order);     // Maybe-based
Maybe&lt;Product&gt; matchMaybe = findMaybe(itemsFold, p -&gt; ..., order);  // Maybe-based
Maybe&lt;List&lt;Product&gt;&gt; allMaybe = getAllMaybe(itemsFold, order);      // Maybe-wrapped list
</code></pre>
<p><strong>Conversion Between Optional and Maybe:</strong></p>
<pre><code class="language-java">// Convert Optional to Maybe
Optional&lt;Product&gt; optional = itemsFold.preview(order);
Maybe&lt;Product&gt; maybe = Maybe.fromOptional(optional);

// Convert Maybe to Optional
Maybe&lt;Product&gt; maybe = previewMaybe(itemsFold, order);
Optional&lt;Product&gt; optional = maybe.toOptional();
</code></pre>
<h4 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h4>
<p>Maybe-based extensions have minimal overhead:</p>
<ul>
<li><strong><code>previewMaybe</code></strong>: Same performance as <code>preview()</code>, just wraps in <code>Maybe</code> instead of <code>Optional</code></li>
<li><strong><code>findMaybe</code></strong>: Identical to <code>find()</code> - short-circuits on first match</li>
<li><strong><code>getAllMaybe</code></strong>: Adds one extra <code>Maybe</code> wrapping over <code>getAll()</code> - negligible cost</li>
</ul>
<p><strong>Optimisation Tip</strong>: For performance-critical code, prefer <code>getAll()</code> if you don't need the Maybe semantics. The extra wrapping and pattern matching adds a small but measurable cost in tight loops.</p>
<h4 id="practical-example-safe-navigation-with-maybe"><a class="header" href="#practical-example-safe-navigation-with-maybe">Practical Example: Safe Navigation with Maybe</a></h4>
<p>Combining <code>getAllMaybe</code> with composed folds creates powerful null-safe query pipelines:</p>
<pre><code class="language-java">import org.higherkindedj.optics.Fold;
import org.higherkindedj.hkt.maybe.Maybe;
import static org.higherkindedj.optics.extensions.FoldExtensions.*;

@GenerateFolds
public record OrderHistory(List&lt;Order&gt; orders) {}

public class OrderAnalytics {
    private static final Fold&lt;OrderHistory, Order&gt; ORDERS =
        OrderHistoryFolds.orders();
    private static final Fold&lt;Order, Product&gt; PRODUCTS =
        OrderFolds.items();

    // Calculate total revenue, handling empty history gracefully
    public double calculateRevenue(OrderHistory history) {
        return getAllMaybe(ORDERS, history)
            .flatMap(orders -&gt; {
                List&lt;Double&gt; prices = orders.stream()
                    .flatMap(order -&gt; getAllMaybe(PRODUCTS, order)
                        .map(products -&gt; products.stream().map(Product::price))
                        .getOrElse(Stream.empty()))
                    .toList();
                return prices.isEmpty() ? Maybe.nothing() : Maybe.just(prices);
            })
            .map(prices -&gt; prices.stream().mapToDouble(Double::doubleValue).sum())
            .getOrElse(0.0);
    }

    // Find most expensive product across all orders
    public Maybe&lt;Product&gt; findMostExpensive(OrderHistory history) {
        return getAllMaybe(ORDERS, history)
            .flatMap(orders -&gt; {
                List&lt;Product&gt; allProducts = orders.stream()
                    .flatMap(order -&gt; getAllMaybe(PRODUCTS, order)
                        .map(List::stream)
                        .getOrElse(Stream.empty()))
                    .toList();
                return allProducts.isEmpty()
                    ? Maybe.nothing()
                    : Maybe.fromNullable(allProducts.stream()
                        .max(Comparator.comparing(Product::price))
                        .orElse(null));
            });
    }
}
</code></pre>
<div id="admonition-complete-example" class="admonition admonish-note" role="note" aria-labelledby="admonition-complete-example-title">
<div class="admonition-title">
<div id="admonition-complete-example-title">
<p>Complete Example</p>
</div>
<a class="admonition-anchor-link" href="#admonition-complete-example"></a>
</div>
<div>
<p>See <a href="https://github.com/higher-kinded-j/higher-kinded-j/blob/main/hkj-examples/src/main/java/org/higherkindedj/example/optics/extensions/FoldExtensionsExample.java">FoldExtensionsExample.java</a> for a runnable demonstration of all Maybe-based Fold extensions.</p>
</div>
</div>
<hr />
<h3 id="step-3-composing-folds-for-deep-queries"><a class="header" href="#step-3-composing-folds-for-deep-queries">Step 3: Composing Folds for Deep Queries</a></h3>
<p>Folds can be composed with other optics to create deep query paths. When composing with <code>Lens</code>, <code>Prism</code>, or other <code>Fold</code> instances, use <code>andThen()</code>.</p>
<pre><code class="language-java">// Get all product names from all orders in history
Fold&lt;OrderHistory, Order&gt; historyToOrders = OrderHistoryFolds.orders();
Fold&lt;Order, Product&gt; orderToProducts = OrderFolds.items();
Lens&lt;Product, String&gt; productToName = ProductLenses.name();

Fold&lt;OrderHistory, String&gt; historyToAllProductNames =
    historyToOrders
        .andThen(orderToProducts)
        .andThen(productToName.asFold());

OrderHistory history = new OrderHistory(List.of(order1, order2, order3));
List&lt;String&gt; allProductNames = historyToAllProductNames.getAll(history);
// Result: ["Laptop", "Mouse", "Desk", "Keyboard", "Monitor", ...]
</code></pre>
<h3 id="step-4-aggregation-with-foldmap-and-monoids"><a class="header" href="#step-4-aggregation-with-foldmap-and-monoids">Step 4: Aggregation with <code>foldMap</code> and Monoids</a></h3>
<p>The most powerful feature of <code>Fold</code> is its ability to aggregate data using <strong>monoids</strong>. This is where Fold truly shines for combining values in flexible, reusable ways.</p>
<h4 id="understanding-monoids-the-simple-explanation"><a class="header" href="#understanding-monoids-the-simple-explanation">Understanding Monoids: The Simple Explanation</a></h4>
<p>Think of a monoid as a recipe for combining things. It needs two ingredients:</p>
<ol>
<li><strong>A starting value</strong> (called <code>empty</code>) - like starting with 0 when adding numbers, or "" when joining strings</li>
<li><strong>A combining rule</strong> (called <code>combine</code>) - like "add these two numbers" or "concatenate these two strings"</li>
</ol>
<p><strong>Simple Examples:</strong></p>
<ul>
<li><strong>Adding numbers</strong>: Start with 0, combine by adding ‚Üí <code>0 + 5 + 10 + 3 = 18</code></li>
<li><strong>Joining strings</strong>: Start with "", combine by concatenating ‚Üí <code>"" + "Hello" + " " + "World" = "Hello World"</code></li>
<li><strong>Finding maximum</strong>: Start with negative infinity, combine by taking larger value</li>
<li><strong>Checking all conditions</strong>: Start with <code>true</code>, combine with AND (&amp;&amp;) ‚Üí all must be true</li>
</ul>
<h4 id="the-power-of-foldmap"><a class="header" href="#the-power-of-foldmap">The Power of <code>foldMap</code></a></h4>
<p>The <code>foldMap</code> method lets you:</p>
<ol>
<li>Transform each focused value into a "combinable" type</li>
<li>Automatically merge all those values using a monoid</li>
</ol>
<p><strong>Example: Calculate Total Price</strong></p>
<pre><code class="language-java">import org.higherkindedj.hkt.Monoid;

Fold&lt;Order, Product&gt; products = OrderFolds.items();

// Define how to combine prices (addition)
Monoid&lt;Double&gt; sumMonoid = new Monoid&lt;&gt;() {
    @Override
    public Double empty() { return 0.0; }  // Start with zero
    @Override
    public Double combine(Double a, Double b) { return a + b; }  // Add them
};

// Extract each product's price and sum them all
double totalPrice = products.foldMap(
    sumMonoid,
    product -&gt; product.price(),  // Extract price from each product
    order
);
// Result: 1374.99 (999.99 + 25.00 + 350.00)
</code></pre>
<p><strong>What's happening here?</strong></p>
<ol>
<li>For each <code>Product</code> in the order, extract its <code>price</code> ‚Üí <code>[999.99, 25.00, 350.00]</code></li>
<li>Start with <code>0.0</code> (the empty value)</li>
<li>Combine them: <code>0.0 + 999.99 + 25.00 + 350.00 = 1374.99</code></li>
</ol>
<h4 id="common-monoid-patterns"><a class="header" href="#common-monoid-patterns">Common Monoid Patterns</a></h4>
<p>Here are the most useful monoid patterns for everyday use. <strong>Best Practice</strong>: Use the standard implementations from the <code>Monoids</code> utility class whenever possible:</p>
<pre><code class="language-java">import org.higherkindedj.hkt.Monoids;

// Standard monoids available out of the box:
Monoid&lt;Double&gt; sumDouble = Monoids.doubleAddition();
Monoid&lt;Double&gt; productDouble = Monoids.doubleMultiplication();
Monoid&lt;Integer&gt; sumInt = Monoids.integerAddition();
Monoid&lt;Integer&gt; productInt = Monoids.integerMultiplication();
Monoid&lt;Long&gt; sumLong = Monoids.longAddition();
Monoid&lt;Boolean&gt; andMonoid = Monoids.booleanAnd();
Monoid&lt;Boolean&gt; orMonoid = Monoids.booleanOr();
Monoid&lt;String&gt; stringConcat = Monoids.string();
Monoid&lt;List&lt;A&gt;&gt; listConcat = Monoids.list();
Monoid&lt;Set&lt;A&gt;&gt; setUnion = Monoids.set();
Monoid&lt;Optional&lt;A&gt;&gt; firstWins = Monoids.firstOptional();
Monoid&lt;Optional&lt;A&gt;&gt; lastWins = Monoids.lastOptional();
Monoid&lt;Optional&lt;A&gt;&gt; maxValue = Monoids.maximum();
Monoid&lt;Optional&lt;A&gt;&gt; minValue = Monoids.minimum();
</code></pre>
<p><strong>Sum (Adding Numbers)</strong></p>
<pre><code class="language-java">// Use standard monoid from Monoids class
Monoid&lt;Double&gt; sumMonoid = Monoids.doubleAddition();

// Calculate total revenue
double revenue = productsFold.foldMap(sumMonoid, ProductItem::price, order);
</code></pre>
<p><strong>Product (Multiplying Numbers)</strong></p>
<pre><code class="language-java">Monoid&lt;Double&gt; productMonoid = Monoids.doubleMultiplication();

// Calculate compound discount (e.g., 0.9 * 0.95 * 0.85)
double finalMultiplier = discountsFold.foldMap(productMonoid, d -&gt; d, discounts);
</code></pre>
<p><strong>String Concatenation</strong></p>
<pre><code class="language-java">Monoid&lt;String&gt; stringMonoid = Monoids.string();

// Join all product names
String allNames = productsFold.foldMap(stringMonoid, ProductItem::name, order);
</code></pre>
<p><strong>List Accumulation</strong></p>
<pre><code class="language-java">Monoid&lt;List&lt;String&gt;&gt; listMonoid = Monoids.list();

// Collect all categories (with duplicates)
List&lt;String&gt; categories = productsFold.foldMap(listMonoid,
    p -&gt; List.of(p.category()), order);
</code></pre>
<p><strong>Boolean AND (All Must Be True)</strong></p>
<pre><code class="language-java">Monoid&lt;Boolean&gt; andMonoid = Monoids.booleanAnd();

// Check if all products are in stock
boolean allInStock = productsFold.foldMap(andMonoid, ProductItem::inStock, order);
</code></pre>
<p><strong>Boolean OR (Any Can Be True)</strong></p>
<pre><code class="language-java">Monoid&lt;Boolean&gt; orMonoid = Monoids.booleanOr();

// Check if any product is expensive
boolean hasExpensive = productsFold.foldMap(orMonoid,
    p -&gt; p.price() &gt; 1000.0, order);
</code></pre>
<p><strong>Maximum Value</strong></p>
<pre><code class="language-java">// Use Optional-based maximum from Monoids
Monoid&lt;Optional&lt;Double&gt;&gt; maxMonoid = Monoids.maximum();

// Find highest price (returns Optional to handle empty collections)
Optional&lt;Double&gt; maxPrice = productsFold.foldMap(maxMonoid,
    p -&gt; Optional.of(p.price()), order);

// Or create a custom one for raw doubles:
Monoid&lt;Double&gt; rawMaxMonoid = new Monoid&lt;&gt;() {
    @Override public Double empty() { return Double.NEGATIVE_INFINITY; }
    @Override public Double combine(Double a, Double b) { return Math.max(a, b); }
};

double maxPriceRaw = productsFold.foldMap(rawMaxMonoid, ProductItem::price, order);
</code></pre>
<h4 id="why-monoids-matter"><a class="header" href="#why-monoids-matter">Why Monoids Matter</a></h4>
<p>Monoids give you:</p>
<ul>
<li><strong>Composability</strong>: Combine complex aggregations from simple building blocks</li>
<li><strong>Reusability</strong>: Define a monoid once, use it everywhere</li>
<li><strong>Correctness</strong>: The monoid laws guarantee consistent behaviour</li>
<li><strong>Flexibility</strong>: Create custom aggregations for your domain</li>
</ul>
<p><strong>Pro Tip</strong>: You can create custom monoids for any domain-specific aggregation logic, like calculating weighted averages, combining validation results, or merging configuration objects.</p>
<hr />
<h2 id="when-to-use-folds-vs-other-approaches"><a class="header" href="#when-to-use-folds-vs-other-approaches">When to Use Folds vs Other Approaches</a></h2>
<h3 id="use-fold-when"><a class="header" href="#use-fold-when">Use Fold When:</a></h3>
<ul>
<li><strong>Read-only queries</strong> - You only need to extract or check data</li>
<li><strong>Intent matters</strong> - You want to express "this is a query, not a modification"</li>
<li><strong>Composable searches</strong> - Building reusable query paths</li>
<li><strong>Aggregations</strong> - Using monoids for custom combining logic</li>
<li><strong>CQRS patterns</strong> - Separating queries from commands</li>
</ul>
<pre><code class="language-java">// Perfect for read-only analysis
Fold&lt;OrderHistory, Product&gt; allProducts =
    OrderHistoryFolds.orders()
        .andThen(OrderFolds.items());

boolean hasElectronics = allProducts.exists(
    p -&gt; "Electronics".equals(p.category()),
    history
);
</code></pre>
<h3 id="use-traversal-when"><a class="header" href="#use-traversal-when">Use Traversal When:</a></h3>
<ul>
<li><strong>Modifications needed</strong> - You need to update the data</li>
<li><strong>Effectful updates</strong> - Using <code>modifyF</code> for validation or async operations</li>
<li><strong>Bulk transformations</strong> - Changing multiple values at once</li>
</ul>
<pre><code class="language-java">// Use Traversal for modifications
Traversal&lt;Order, Product&gt; productTraversal = OrderTraversals.items();
Order discountedOrder = Traversals.modify(
    productTraversal.andThen(ProductLenses.price().asTraversal()),
    price -&gt; price * 0.9,
    order
);
</code></pre>
<h3 id="use-stream-api-when"><a class="header" href="#use-stream-api-when">Use Stream API When:</a></h3>
<ul>
<li><strong>Complex filtering</strong> - Multiple filter/map/reduce operations</li>
<li><strong>Parallel processing</strong> - Taking advantage of parallel streams</li>
<li><strong>Standard Java collections</strong> - Working with flat collections</li>
<li><strong>Stateful operations</strong> - Operations that require maintaining state</li>
</ul>
<pre><code class="language-java">// Better with streams for complex pipelines
List&lt;String&gt; topExpensiveItems = order.items().stream()
    .filter(p -&gt; p.price() &gt; 100)
    .sorted(Comparator.comparing(Product::price).reversed())
    .limit(5)
    .map(Product::name)
    .collect(toList());
</code></pre>
<h3 id="use-direct-field-access-when"><a class="header" href="#use-direct-field-access-when">Use Direct Field Access When:</a></h3>
<ul>
<li><strong>Simple cases</strong> - Single, straightforward field read</li>
<li><strong>Performance critical</strong> - Minimal abstraction overhead</li>
<li><strong>One-off operations</strong> - Not building reusable logic</li>
</ul>
<pre><code class="language-java">// Just use direct access for simple cases
String customerName = order.customerName();
</code></pre>
<hr />
<h2 id="common-pitfalls"><a class="header" href="#common-pitfalls">Common Pitfalls</a></h2>
<h3 id="-dont-do-this"><a class="header" href="#-dont-do-this">‚ùå Don't Do This:</a></h3>
<pre><code class="language-java">// Inefficient: Creating folds repeatedly in loops
for (Order order : orders) {
    Fold&lt;Order, Product&gt; fold = OrderFolds.items();
    List&lt;Product&gt; products = fold.getAll(order);
    // ... process products
}

// Over-engineering: Using Fold for trivial single-field access
Fold&lt;Order, String&gt; customerFold = OrderFolds.customerName();
String name = customerFold.getAll(order).get(0); // Just use order.customerName()!

// Wrong tool: Trying to modify data with a Fold
// Folds are read-only - this won't compile
// Fold&lt;Order, Product&gt; items = OrderFolds.items();
// Order updated = items.set(newProduct, order); // ‚ùå No 'set' method!

// Verbose: Unnecessary conversion when Traversal is already available
Traversal&lt;Order, Product&gt; traversal = OrderTraversals.items();
Fold&lt;Order, Product&gt; fold = traversal.asFold();
List&lt;Product&gt; products = fold.getAll(order); // Just use Traversals.getAll() directly!
</code></pre>
<h3 id="-do-this-instead"><a class="header" href="#-do-this-instead">‚úÖ Do This Instead:</a></h3>
<pre><code class="language-java">// Efficient: Create fold once, reuse many times
Fold&lt;Order, Product&gt; itemsFold = OrderFolds.items();
for (Order order : orders) {
    List&lt;Product&gt; products = itemsFold.getAll(order);
    // ... process products
}

// Right tool: Direct access for simple cases
String name = order.customerName();

// Clear intent: Use Traversal when you need modifications
Traversal&lt;Order, Product&gt; itemsTraversal = OrderTraversals.items();
Order updated = Traversals.modify(itemsTraversal, this::applyDiscount, order);

// Clear purpose: Use Fold when expressing query intent
Fold&lt;Order, Product&gt; queryItems = OrderFolds.items();
boolean hasExpensive = queryItems.exists(p -&gt; p.price() &gt; 1000, order);
</code></pre>
<hr />
<h2 id="performance-notes"><a class="header" href="#performance-notes">Performance Notes</a></h2>
<p>Folds are optimised for query operations:</p>
<ul>
<li><strong>Memory efficient</strong>: Uses iterators internally, no intermediate collections for most operations</li>
<li><strong>Lazy evaluation</strong>: Short-circuits on operations like <code>find</code> and <code>exists</code> (stops at first match)</li>
<li><strong>Reusable</strong>: Composed folds can be stored and reused across your application</li>
<li><strong>Type-safe</strong>: All operations checked at compile time</li>
<li><strong>Zero allocation</strong>: <code>foldMap</code> with monoids avoids creating intermediate collections</li>
</ul>
<p><strong>Best Practice</strong>: For frequently used query paths, create them once and store as constants:</p>
<pre><code class="language-java">public class OrderQueries {
    public static final Fold&lt;OrderHistory, Product&gt; ALL_PRODUCTS =
        OrderHistoryFolds.orders()
            .andThen(OrderFolds.items());

    public static final Fold&lt;OrderHistory, Double&gt; ALL_PRICES =
        ALL_PRODUCTS.andThen(ProductLenses.price().asFold());

    public static final Fold&lt;Order, Product&gt; ELECTRONICS =
        OrderFolds.items(); // Can filter with exists/find/getAll + stream filter
}
</code></pre>
<hr />
<h2 id="real-world-example-order-analytics"><a class="header" href="#real-world-example-order-analytics">Real-World Example: Order Analytics</a></h2>
<p>Here's a practical example showing comprehensive use of Fold for business analytics:</p>
<pre><code class="language-java">import org.higherkindedj.optics.Fold;
import org.higherkindedj.optics.Lens;
import org.higherkindedj.optics.annotations.GenerateFolds;
import org.higherkindedj.optics.annotations.GenerateLenses;
import org.higherkindedj.hkt.Monoid;
import java.time.LocalDate;
import java.util.*;

@GenerateLenses
@GenerateFolds
public record Product(String name, double price, String category, boolean inStock) {}

@GenerateLenses
@GenerateFolds
public record Order(String orderId, List&lt;Product&gt; items, String customerName, LocalDate orderDate) {}

@GenerateLenses
@GenerateFolds
public record OrderHistory(List&lt;Order&gt; orders) {}

public class OrderAnalytics {
    private static final Fold&lt;Order, Product&gt; ORDER_ITEMS = OrderFolds.items();
    private static final Fold&lt;OrderHistory, Order&gt; HISTORY_ORDERS = OrderHistoryFolds.orders();
    private static final Fold&lt;OrderHistory, Product&gt; ALL_PRODUCTS =
        HISTORY_ORDERS.andThen(ORDER_ITEMS);

    private static final Monoid&lt;Double&gt; SUM_MONOID = new Monoid&lt;&gt;() {
        @Override public Double empty() { return 0.0; }
        @Override public Double combine(Double a, Double b) { return a + b; }
    };

    // Calculate total revenue across all orders
    public static double calculateRevenue(OrderHistory history) {
        return ALL_PRODUCTS.foldMap(SUM_MONOID, Product::price, history);
    }

    // Find most expensive product across all orders
    public static Optional&lt;Product&gt; findMostExpensiveProduct(OrderHistory history) {
        return ALL_PRODUCTS.getAll(history).stream()
            .max(Comparator.comparing(Product::price));
    }

    // Check if any order has out-of-stock items
    public static boolean hasOutOfStockIssues(OrderHistory history) {
        return ALL_PRODUCTS.exists(p -&gt; !p.inStock(), history);
    }

    // Get all unique categories
    public static Set&lt;String&gt; getAllCategories(OrderHistory history) {
        Fold&lt;OrderHistory, String&gt; categories =
            ALL_PRODUCTS.andThen(ProductLenses.category().asFold());
        return new HashSet&lt;&gt;(categories.getAll(history));
    }

    // Count products in a specific category
    public static int countByCategory(OrderHistory history, String category) {
        return (int) ALL_PRODUCTS.getAll(history).stream()
            .filter(p -&gt; category.equals(p.category()))
            .count();
    }

    // Calculate average order value
    public static double calculateAverageOrderValue(OrderHistory history) {
        List&lt;Order&gt; allOrders = HISTORY_ORDERS.getAll(history);
        if (allOrders.isEmpty()) return 0.0;

        double totalRevenue = calculateRevenue(history);
        return totalRevenue / allOrders.size();
    }

    // Find orders with specific product
    public static List&lt;Order&gt; findOrdersContaining(OrderHistory history, String productName) {
        return HISTORY_ORDERS.getAll(history).stream()
            .filter(order -&gt; ORDER_ITEMS.exists(
                p -&gt; productName.equals(p.name()),
                order
            ))
            .toList();
    }
}
</code></pre>
<hr />
<h2 id="the-relationship-to-foldable"><a class="header" href="#the-relationship-to-foldable">The Relationship to Foldable</a></h2>
<h3 id="quick-summary"><a class="header" href="#quick-summary">Quick Summary</a></h3>
<p>If you're just getting started, here's what you need to know: A <code>Fold&lt;S, A&gt;</code> is closely related to the <code>Foldable</code> type class from functional programming. While <code>Foldable&lt;F&gt;</code> works with any container type <code>F</code> (like <code>List</code>, <code>Optional</code>, <code>Tree</code>), a <code>Fold&lt;S, A&gt;</code> lets you treat any structure <code>S</code> as if it were a foldable container of <code>A</code> values‚Äîeven when <code>S</code> isn't actually a collection.</p>
<p><strong>Key Connection</strong>: Both use <code>foldMap</code> to aggregate values using monoids. The <code>Fold</code> optic brings this powerful abstraction to arbitrary data structures, not just collections.</p>
<h3 id="in-depth-explanation"><a class="header" href="#in-depth-explanation">In-Depth Explanation</a></h3>
<p>For those familiar with functional programming or interested in the deeper theory:</p>
<h4 id="the-foldable-type-class"><a class="header" href="#the-foldable-type-class">The Foldable Type Class</a></h4>
<p>The <a href="../functional/foldable_and_traverse.html"><code>Foldable&lt;F&gt;</code> type class</a> in higher-kinded-j represents any data structure <code>F</code> that can be "folded up" or reduced to a summary value. It's defined with this signature:</p>
<pre><code class="language-java">public interface Foldable&lt;F&gt; {
  &lt;A, M&gt; M foldMap(
      Monoid&lt;M&gt; monoid,
      Function&lt;? super A, ? extends M&gt; f,
      Kind&lt;F, A&gt; fa
  );
}
</code></pre>
<p>Common instances include:</p>
<ul>
<li><code>List&lt;A&gt;</code> - fold over all elements</li>
<li><code>Optional&lt;A&gt;</code> - fold over zero or one element</li>
<li><code>Either&lt;E, A&gt;</code> - fold over the right value if present</li>
<li><code>Tree&lt;A&gt;</code> - fold over all nodes in a tree</li>
</ul>
<h4 id="how-fold-relates-to-foldable"><a class="header" href="#how-fold-relates-to-foldable">How Fold Relates to Foldable</a></h4>
<p>A <code>Fold&lt;S, A&gt;</code> can be thought of as a <strong>first-class, composable lens into a Foldable structure</strong>. More precisely:</p>
<ol>
<li><strong>Virtualization</strong>: <code>Fold&lt;S, A&gt;</code> lets you "view" any structure <code>S</code> as a virtual <code>Foldable</code> container of <code>A</code> values, even if <code>S</code> is not inherently a collection</li>
<li><strong>Composition</strong>: Unlike <code>Foldable&lt;F&gt;</code>, which is fixed to a specific container type <code>F</code>, <code>Fold&lt;S, A&gt;</code> can be composed with other optics to create deep query paths</li>
<li><strong>Reification</strong>: A <code>Fold</code> reifies (makes concrete) the act of folding, turning it into a first-class value you can pass around, store, and combine</li>
</ol>
<p><strong>Example Comparison</strong>:</p>
<pre><code class="language-java">// Using Foldable directly on a List
Foldable&lt;ListKind.Witness&gt; listFoldable = ListTraverse.INSTANCE;
List&lt;Integer&gt; numbers = List.of(1, 2, 3, 4, 5);
int sum = listFoldable.foldMap(sumMonoid, Function.identity(), LIST.widen(numbers));

// Using a Fold optic to query nested structure
Fold&lt;Order, Integer&gt; quantities = OrderFolds.items()
    .andThen(ProductLenses.quantity().asFold());
int totalQuantity = quantities.foldMap(sumMonoid, Function.identity(), order);
</code></pre>
<p>The <code>Fold</code> optic gives you the power of <code>Foldable</code>, but for <strong>arbitrary access paths</strong> through your domain model, not just direct containers.</p>
<h4 id="fold-laws-and-foldable-laws"><a class="header" href="#fold-laws-and-foldable-laws">Fold Laws and Foldable Laws</a></h4>
<p>Both <code>Fold</code> and <code>Foldable</code> obey the same monoid laws:</p>
<ol>
<li><strong>Left identity</strong>: <code>combine(empty, x) = x</code></li>
<li><strong>Right identity</strong>: <code>combine(x, empty) = x</code></li>
<li><strong>Associativity</strong>: <code>combine(combine(x, y), z) = combine(x, combine(y, z))</code></li>
</ol>
<p>This means <code>foldMap</code> produces consistent, predictable results regardless of how the fold is internally structured.</p>
<h4 id="practical-implications"><a class="header" href="#practical-implications">Practical Implications</a></h4>
<p>Understanding this relationship helps you:</p>
<ul>
<li><strong>Transfer knowledge</strong>: If you learn <code>Foldable</code>, you understand the core of <code>Fold</code></li>
<li><strong>Recognise patterns</strong>: Monoid aggregation is universal across both abstractions</li>
<li><strong>Build intuition</strong>: A <code>Fold</code> is like having a custom <code>Foldable</code> instance for each access path in your domain</li>
<li><strong>Compose freely</strong>: You can convert between optics and type classes when needed (e.g., <code>Lens.asFold()</code>)</li>
</ul>
<p><strong>Further Reading</strong>:</p>
<ul>
<li><a href="../functional/foldable_and_traverse.html">Foldable and Traverse in higher-kinded-j</a> - Deep dive into the type class</li>
<li><a href="https://hackage.haskell.org/package/lens-5.2.3/docs/Control-Lens-Fold.html">Haskell Lens Library - Folds</a> - The original inspiration</li>
<li><a href="https://leanpub.com/optics-by-example">Optics By Example (Book)</a> - Comprehensive treatment of folds in Haskell</li>
</ul>
<hr />
<h2 id="complete-runnable-example"><a class="header" href="#complete-runnable-example">Complete, Runnable Example</a></h2>
<p>This example demonstrates all major Fold operations in a single, cohesive application:</p>
<pre><code class="language-java">package org.higherkindedj.example.optics;

import org.higherkindedj.optics.Fold;
import org.higherkindedj.optics.Lens;
import org.higherkindedj.optics.annotations.GenerateFolds;
import org.higherkindedj.optics.annotations.GenerateLenses;
import org.higherkindedj.hkt.Monoid;
import org.higherkindedj.hkt.Monoids;
import java.util.*;

public class FoldUsageExample {

    @GenerateLenses
    @GenerateFolds
    public record ProductItem(String name, double price, String category, boolean inStock) {}

    @GenerateLenses
    @GenerateFolds
    public record Order(String orderId, List&lt;ProductItem&gt; items, String customerName) {}

    @GenerateLenses
    @GenerateFolds
    public record OrderHistory(List&lt;Order&gt; orders) {}

    public static void main(String[] args) {
        // Create sample data
        var order1 = new Order("ORD-001", List.of(
            new ProductItem("Laptop", 999.99, "Electronics", true),
            new ProductItem("Mouse", 25.00, "Electronics", true),
            new ProductItem("Desk", 350.00, "Furniture", false)
        ), "Alice");

        var order2 = new Order("ORD-002", List.of(
            new ProductItem("Keyboard", 75.00, "Electronics", true),
            new ProductItem("Monitor", 450.00, "Electronics", true),
            new ProductItem("Chair", 200.00, "Furniture", true)
        ), "Bob");

        var history = new OrderHistory(List.of(order1, order2));

        System.out.println("=== FOLD USAGE EXAMPLE ===\n");

        // --- SCENARIO 1: Basic Query Operations ---
        System.out.println("--- Scenario 1: Basic Query Operations ---");
        Fold&lt;Order, ProductItem&gt; itemsFold = OrderFolds.items();

        List&lt;ProductItem&gt; allItems = itemsFold.getAll(order1);
        System.out.println("All items: " + allItems.size() + " products");

        Optional&lt;ProductItem&gt; firstItem = itemsFold.preview(order1);
        System.out.println("First item: " + firstItem.map(ProductItem::name).orElse("none"));

        int count = itemsFold.length(order1);
        System.out.println("Item count: " + count);

        boolean isEmpty = itemsFold.isEmpty(order1);
        System.out.println("Is empty: " + isEmpty + "\n");

        // --- SCENARIO 2: Conditional Queries ---
        System.out.println("--- Scenario 2: Conditional Queries ---");

        boolean hasOutOfStock = itemsFold.exists(p -&gt; !p.inStock(), order1);
        System.out.println("Has out of stock items: " + hasOutOfStock);

        boolean allInStock = itemsFold.all(ProductItem::inStock, order1);
        System.out.println("All items in stock: " + allInStock);

        Optional&lt;ProductItem&gt; expensiveItem = itemsFold.find(p -&gt; p.price() &gt; 500, order1);
        System.out.println("First expensive item: " + expensiveItem.map(ProductItem::name).orElse("none") + "\n");

        // --- SCENARIO 3: Composition ---
        System.out.println("--- Scenario 3: Composed Folds ---");

        Fold&lt;OrderHistory, ProductItem&gt; allProducts =
            OrderHistoryFolds.orders().andThen(OrderFolds.items());

        List&lt;ProductItem&gt; allProductsFromHistory = allProducts.getAll(history);
        System.out.println("Total products across all orders: " + allProductsFromHistory.size());

        Fold&lt;OrderHistory, String&gt; allCategories =
            allProducts.andThen(ProductItemLenses.category().asFold());

        Set&lt;String&gt; uniqueCategories = new HashSet&lt;&gt;(allCategories.getAll(history));
        System.out.println("Unique categories: " + uniqueCategories + "\n");

        // --- SCENARIO 4: Monoid Aggregation ---
        System.out.println("--- Scenario 4: Monoid-Based Aggregation ---");

        // Use standard monoids from Monoids utility class
        Monoid&lt;Double&gt; sumMonoid = Monoids.doubleAddition();

        double orderTotal = itemsFold.foldMap(sumMonoid, ProductItem::price, order1);
        System.out.println("Order 1 total: ¬£" + String.format("%.2f", orderTotal));

        double historyTotal = allProducts.foldMap(sumMonoid, ProductItem::price, history);
        System.out.println("All orders total: ¬£" + String.format("%.2f", historyTotal));

        // Boolean AND monoid for checking conditions
        Monoid&lt;Boolean&gt; andMonoid = Monoids.booleanAnd();

        boolean allAffordable = itemsFold.foldMap(andMonoid, p -&gt; p.price() &lt; 1000, order1);
        System.out.println("All items under ¬£1000: " + allAffordable);

        // Boolean OR monoid for checking any condition
        Monoid&lt;Boolean&gt; orMonoid = Monoids.booleanOr();

        boolean hasElectronics = allProducts.foldMap(orMonoid,
            p -&gt; "Electronics".equals(p.category()), history);
        System.out.println("Has electronics: " + hasElectronics + "\n");

        // --- SCENARIO 5: Analytics ---
        System.out.println("--- Scenario 5: Real-World Analytics ---");

        // Most expensive product
        Optional&lt;ProductItem&gt; mostExpensive = allProducts.getAll(history).stream()
            .max(Comparator.comparing(ProductItem::price));
        System.out.println("Most expensive product: " +
            mostExpensive.map(p -&gt; p.name() + " (¬£" + p.price() + ")").orElse("none"));

        // Average price
        List&lt;ProductItem&gt; allProds = allProducts.getAll(history);
        double avgPrice = allProds.isEmpty() ? 0.0 :
            historyTotal / allProds.size();
        System.out.println("Average product price: ¬£" + String.format("%.2f", avgPrice));

        // Count by category
        long electronicsCount = allProducts.getAll(history).stream()
            .filter(p -&gt; "Electronics".equals(p.category()))
            .count();
        System.out.println("Electronics count: " + electronicsCount);

        System.out.println("\n=== END OF EXAMPLE ===");
    }
}
</code></pre>
<p><strong>Expected Output:</strong></p>
<pre><code>=== FOLD USAGE EXAMPLE ===

--- Scenario 1: Basic Query Operations ---
All items: 3 products
First item: Laptop
Item count: 3
Is empty: false

--- Scenario 2: Conditional Queries ---
Has out of stock items: true
All items in stock: false
First expensive item: Laptop

--- Scenario 3: Composed Folds ---
Total products across all orders: 6
Unique categories: [Electronics, Furniture]

--- Scenario 4: Monoid-Based Aggregation ---
Order 1 total: ¬£1374.99
All orders total: ¬£2099.99
All items under ¬£1000: true
Has electronics: true

--- Scenario 5: Real-World Analytics ---
Most expensive product: Laptop (¬£999.99)
Average product price: ¬£349.99
Electronics count: 4

=== END OF EXAMPLE ===
</code></pre>
<hr />
<h2 id="why-folds-are-essential"><a class="header" href="#why-folds-are-essential">Why Folds Are Essential</a></h2>
<p><code>Fold</code> completes the optics toolkit by providing:</p>
<ul>
<li><strong>Clear Intent</strong>: Explicitly read-only operations prevent accidental modifications</li>
<li><strong>Composability</strong>: Chain folds with other optics for deep queries</li>
<li><strong>Aggregation Power</strong>: Use monoids for flexible, reusable combining logic</li>
<li><strong>Type Safety</strong>: All queries checked at compile time</li>
<li><strong>Reusability</strong>: Build query libraries tailored to your domain</li>
<li><strong>CQRS Support</strong>: Separate query models from command models cleanly</li>
<li><strong>Performance</strong>: Optimised for read-only access with short-circuiting and lazy evaluation</li>
</ul>
<p>By adding <code>Fold</code> to your arsenal alongside <code>Lens</code>, <code>Prism</code>, <code>Iso</code>, and <code>Traversal</code>, you have complete coverage for both reading and writing immutable data structures in a type-safe, composable way.</p>
<p>The key insight: <strong>Folds make queries first-class citizens in your codebase</strong>, just as valuable and well-designed as the commands that modify state.</p>
<hr />
<p><strong>Previous:</strong> <a href="traversals.html">Traversals: Handling Bulk Updates</a>
<strong>Next:</strong> <a href="filtered_optics.html">Filtered Optics: Predicate-Based Composition</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../optics/traversals.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../optics/filtered_optics.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../optics/traversals.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../optics/filtered_optics.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../version-switcher.js"></script>


    </div>
    </body>
</html>
