<!DOCTYPE HTML>
<html lang="en" class="latte sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Draughts Game - Higher-Kinded-J: Composable Effects and Advanced Optics for Java</title>


        <!-- Custom HTML head -->


            <meta name="description" content="The most comprehensive functional programming library for Java. Unify error handling, optional values, and immutable data navigation with the Effect Path API and Focus DSL. Features advanced optics with code generation for Java records, filtered traversals, indexed optics, and seamless Spring Boot integration.">


        <meta name="keywords" content="Higher-Kinded Types, Higher-Kinded-J, HKT, Java, Optics, Lens, Prism, Traversal, Iso, Affine, Focus DSL, Effect Path API, Functional Programming, Monad, Functor, Applicative, EitherPath, MaybePath, TryPath, ValidationPath, Java Records, Sealed Interface, Error Handling, Immutable Data">
        
        <meta property="og:title" content="Draughts Game - Higher-Kinded-J: Composable Effects and Advanced Optics for Java">
            <meta property="og:description" content="The most comprehensive functional programming library for Java. Unify error handling, optional values, and immutable data navigation with the Effect Path API and Focus DSL. Features advanced optics with code generation for Java records, filtered traversals, indexed optics, and seamless Spring Boot integration.">
        <meta property="og:type" content="website">
        <meta property="og:url" content="https://higher-kinded-j.github.io/">
        <meta property="og:image" content="https://higher-kinded-j.github.io/preview.png">
        <meta property="og:image:width" content="1200">
        <meta property="og:image:height" content="630">
        <meta property="og:site_name" content="Higher-Kinded-J Documentation">
        <meta property="og:locale" content="en_GB">
        
        <meta name="twitter:card" content="summary_large_image">
        <meta name="twitter:title" content="Draughts Game - Higher-Kinded-J: Composable Effects and Advanced Optics for Java">
        <meta name="twitter:description" content="Unifying Composable Effects and Advanced Optics for Java. Effect Path API, Focus DSL, and the most comprehensive optics implementation in the Java ecosystem.">
        <meta name="twitter:image" content="https://higher-kinded-j.github.io/preview.png">
        <meta name="twitter:image:alt" content="Higher-Kinded-J: Composable Effects and Advanced Optics for Java">
        <meta name="description" content="The most comprehensive functional programming library for Java. Unify error handling, optional values, and immutable data navigation with the Effect Path API and Focus DSL. Features advanced optics with code generation for Java records, filtered traversals, indexed optics, and seamless Spring Boot integration.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">
        <meta name="google-site-verification" content="X-xsiAq2cKMLOzh9dexUrX8Onx2h_YMUFgp5lHHUwSg" />
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href=".././mdbook-admonish.css">
        <link rel="stylesheet" href=".././theme/catppuccin.css">
        <link rel="stylesheet" href=".././theme/catppuccin-admonish.css">
        <link rel="stylesheet" href=".././theme/catppuccin-alerts.css">
        <link rel="stylesheet" href=".././theme/additional-hkj.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "latte";
            const default_dark_theme = "macchiato";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('latte')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="latte">Latte</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="frappe">Frappé</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="macchiato">Macchiato</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mocha">Mocha</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        <div class="version-selector-container">
                            <select id="version-selector" class="version-selector" aria-label="Select documentation version" title="Select documentation version">
                                <option value="">Loading versions...</option>
                            </select>
                        </div>
                    </div>

                    <h1 class="menu-title">Higher-Kinded-J: Composable Effects and Advanced Optics for Java</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/higher-kinded-j/higher-kinded-j" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/higher-kinded-j/higher-kinded-j/edit/main/hkj-book/src/hkts/draughts.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="building-a-playable-draughts-game"><a class="header" href="#building-a-playable-draughts-game">Building a Playable Draughts Game</a></h1>
<p><img src="../images/draughts_board.png" alt="draughts_board.png" /></p>
<p>This tutorial guides you through building a complete command-line draughts (checkers) game using the Effects Path API and Focus DSL. We demonstrate how Higher-Kinded-J makes functional game development in Java both practical and elegant.</p>
<div id="admonition-what-youll-learn" class="admonition admonish-info" role="note" aria-labelledby="admonition-what-youll-learn-title">
<div class="admonition-title">
<div id="admonition-what-youll-learn-title">
<p>What You'll Learn</p>
</div>
<a class="admonition-anchor-link" href="#admonition-what-youll-learn"></a>
</div>
<div>
<ul>
<li>How to build a complete functional game using the Effects Path API</li>
<li>Managing immutable game state with <code>WithStatePath</code></li>
<li>Railway-oriented programming with <code>EitherPath</code> for validation pipelines</li>
<li>Type-safe error handling using the Focus-Effect bridge</li>
<li>Encapsulating side effects with <code>IOPath</code> while keeping core logic pure</li>
<li>Stream-based functional patterns for declarative iteration</li>
<li>Composing operations with <code>ForPath</code> for readable workflows</li>
<li>Using the Focus DSL and <code>@GenerateFocus</code> for type-safe data navigation</li>
</ul>
</div>
</div>
<div id="admonition-see-example-code" class="admonition admonish-example" role="note" aria-labelledby="admonition-see-example-code-title">
<div class="admonition-title">
<div id="admonition-see-example-code-title">
<p>See Example Code</p>
</div>
<a class="admonition-anchor-link" href="#admonition-see-example-code"></a>
</div>
<div>
<p><a href="https://github.com/higher-kinded-j/higher-kinded-j/tree/main/hkj-examples/src/main/java/org/higherkindedj/example/draughts">org.higherkindedj.example.draughts</a></p>
</div>
</div>
<hr />
<h2 id="the-effects-path-approach"><a class="header" href="#the-effects-path-approach">The Effects Path Approach</a></h2>
<p>At its core, a game like draughts involves several aspects where the Effects Path API shines:</p>
<pre><code>    ┌─────────────────────────────────────────────────────────────────────┐
    │                    DRAUGHTS GAME ARCHITECTURE                       │
    │                                                                     │
    │                        ┌──────────────┐                             │
    │                        │  Focus DSL   │                             │
    │                        │  Navigation  │                             │
    │                        └──────┬───────┘                             │
    │                               │                                     │
    │   User Input          Game Logic              Display               │
    │   ─────────           ──────────              ───────               │
    │                               │                                     │
    │   IOPath              WithStatePath           IOPath                │
    │   ┌──────────┐        ┌──────┴──────┐        ┌──────────┐           │
    │   │ Read     │───────►│ Validate    │───────►│ Render   │           │
    │   │ Parse    │ railway│ Navigate    │ stream │ Board    │           │
    │   │ Validate │───────►│ Update      │───────►│          │           │
    │   └──────────┘        └─────────────┘        └──────────┘           │
    │        │                    │                     │                 │
    │        ▼                    ▼                     ▼                 │
    │   EitherPath          WithStatePath           IOPath                │
    │   &lt;Error,             &lt;GameState,             &lt;Unit&gt;                │
    │   MoveCommand&gt;        MoveResult&gt;                                   │
    │                                                                     │
    │                    Composed via ForPath                             │
    └─────────────────────────────────────────────────────────────────────┘
</code></pre>
<p>The Effects Path API provides the tools for each concern:</p>
<div class="table-wrapper"><table><thead><tr><th>Concern</th><th>Path Type</th><th>Purpose</th></tr></thead><tbody>
<tr><td><strong>State Management</strong></td><td><code>WithStatePath&lt;S, A&gt;</code></td><td>Pure state transformations without mutable variables</td></tr>
<tr><td><strong>User Input</strong></td><td><code>IOPath&lt;A&gt;</code> + <code>EitherPath&lt;E, A&gt;</code></td><td>Side effects with railway-oriented validation</td></tr>
<tr><td><strong>Game Logic</strong></td><td><code>WithStatePath&lt;GameState, MoveResult&gt;</code></td><td>Railway-oriented validation and rule enforcement</td></tr>
<tr><td><strong>Side Effects</strong></td><td><code>IOPath&lt;A&gt;</code></td><td>Deferred console I/O</td></tr>
<tr><td><strong>Composition</strong></td><td><code>ForPath</code></td><td>Sequential workflow composition</td></tr>
<tr><td><strong>Data Navigation</strong></td><td>Focus DSL</td><td>Type-safe access to nested structures</td></tr>
<tr><td><strong>Iteration</strong></td><td><code>Stream</code> + <code>IntStream</code></td><td>Declarative, functional iteration patterns</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="step-1-defining-the-game-state-with-focus-dsl"><a class="header" href="#step-1-defining-the-game-state-with-focus-dsl">Step 1: Defining the Game State with Focus DSL</a></h2>
<p>Our game state uses immutable records annotated with <code>@GenerateFocus</code> to enable type-safe navigation via the Focus DSL.</p>
<pre><code class="language-java">import org.higherkindedj.optics.annotations.GenerateFocus;

// Enum for the two players
enum Player { RED, BLACK }

// Enum for the type of piece
enum PieceType { MAN, KING }

// A piece on the board, owned by a player with a certain type
@GenerateFocus
record Piece(Player owner, PieceType type) {}

// A square on the 8x8 board, identified by row and column
@GenerateFocus
record Square(int row, int col) {
  @Override
  public String toString() {
    return "" + (char)('a' + col) + (row + 1);
  }
}

// Represents an error during move parsing or validation
// The isQuit flag distinguishes quit commands from validation errors
@GenerateFocus
record GameError(String description, boolean isQuit) {
  public GameError(String description) { this(description, false); }
}

// The command to make a move from one square to another
@GenerateFocus
record MoveCommand(Square from, Square to) {}

// The outcome of a move attempt
enum MoveOutcome { SUCCESS, INVALID_MOVE, CAPTURE_MADE, GAME_WON }

@GenerateFocus
record MoveResult(MoveOutcome outcome, String message) {}
</code></pre>
<p>The main <code>GameState</code> record captures the complete game state. The initialisation uses a stream-based approach for a declarative, functional style:</p>
<pre><code class="language-java">@GenerateFocus
public record GameState(
    Map&lt;Square, Piece&gt; board,
    Player currentPlayer,
    String message,
    boolean isGameOver) {

  private static final int BLACK_START_ROW = 0;
  private static final int BLACK_END_ROW = 3;
  private static final int RED_START_ROW = 5;
  private static final int RED_END_ROW = 8;

  /**
   * Creates the initial game state using stream-based board initialisation.
   */
  public static GameState initial() {
    Map&lt;Square, Piece&gt; board =
        Stream.concat(
                placePieces(Player.BLACK, BLACK_START_ROW, BLACK_END_ROW),
                placePieces(Player.RED, RED_START_ROW, RED_END_ROW))
            .collect(Collectors.toUnmodifiableMap(Map.Entry::getKey, Map.Entry::getValue));

    return new GameState(board, Player.RED, "Game started. RED's turn.", false);
  }

  /**
   * Generates piece placements using flatMap to combine all squares across rows.
   */
  private static Stream&lt;Map.Entry&lt;Square, Piece&gt;&gt; placePieces(
      Player owner, int startRow, int endRow) {
    Piece piece = new Piece(owner, PieceType.MAN);

    return IntStream.range(startRow, endRow)
        .boxed()
        .flatMap(row -&gt;
            darkSquaresInRow(row).mapToObj(col -&gt; Map.entry(new Square(row, col), piece)));
  }

  /**
   * Returns column indices of dark (playable) squares using IntStream.iterate.
   */
  private static IntStream darkSquaresInRow(int row) {
    int startCol = (row % 2 != 0) ? 0 : 1;
    return IntStream.iterate(startCol, col -&gt; col &lt; 8, col -&gt; col + 2);
  }

  // Pure transformation methods
  GameState withMessage(String newMessage) { ... }
  GameState togglePlayer() { ... }
}
</code></pre>
<div id="admonition-functional-initialisation" class="admonition admonish-note" role="note" aria-labelledby="admonition-functional-initialisation-title">
<div class="admonition-title">
<div id="admonition-functional-initialisation-title">
<p>Functional Initialisation</p>
</div>
<a class="admonition-anchor-link" href="#admonition-functional-initialisation"></a>
</div>
<div>
<p>The stream-based approach replaces imperative nested loops with declarative operations:</p>
<ul>
<li><code>Stream.concat()</code> combines piece placements from both players</li>
<li><code>IntStream.range().flatMap()</code> generates squares across multiple rows</li>
<li><code>IntStream.iterate()</code> calculates playable squares on each row</li>
<li><code>Collectors.toUnmodifiableMap()</code> creates an immutable result</li>
</ul>
</div>
</div>
<p>The <code>@GenerateFocus</code> annotation generates Focus path classes that enable type-safe navigation:</p>
<pre><code class="language-java">// Generated: GameStateFocus, PieceFocus, SquareFocus, etc.
// Usage:
Player owner = PieceFocus.owner().get(piece);
GameState updated = GameStateFocus.message().set("New message", state);
</code></pre>
<hr />
<h2 id="step-2-handling-user-input-with-railway-oriented-programming"><a class="header" href="#step-2-handling-user-input-with-railway-oriented-programming">Step 2: Handling User Input with Railway-Oriented Programming</a></h2>
<p>The <code>InputHandler</code> class demonstrates railway-oriented programming for input parsing. The parsing pipeline uses <code>EitherPath</code> to chain validation steps, where errors automatically short-circuit to the error track:</p>
<pre><code>readLine → checkQuit → splitInput → parseSquares → MoveCommand
   ↓          ↓           ↓            ↓
 IOPath   EitherPath  EitherPath   EitherPath
</code></pre>
<p>Each step either continues on the success track or switches to the error track. The final result captures both the side effect of reading from console (<code>IOPath</code>) and the possibility of parse errors (<code>Either</code>).</p>
<pre><code class="language-java">import org.higherkindedj.hkt.effect.IOPath;
import org.higherkindedj.hkt.effect.EitherPath;
import org.higherkindedj.hkt.effect.Path;

class InputHandler {
  private static final Scanner scanner = new Scanner(System.in);

  /**
   * Reads a move command from the console.
   * Wraps the side-effecting input operation in IOPath and delegates parsing
   * to a pure function.
   */
  static IOPath&lt;Either&lt;GameError, MoveCommand&gt;&gt; readMoveCommand() {
    return Path.io(() -&gt; {
      System.out.print("Enter move (e.g., 'a3 b4') or 'quit': ");
      return parseLine(scanner.nextLine().trim());
    });
  }

  /**
   * Parses an input line using railway-oriented programming.
   * The pipeline chains validation steps with .via(), where any error
   * short-circuits the entire pipeline.
   */
  private static Either&lt;GameError, MoveCommand&gt; parseLine(String line) {
    return checkNotQuit(line)
        .via(InputHandler::splitIntoTwoParts)
        .via(InputHandler::parseSquarePair)
        .run();
  }

  // ===== Pipeline Steps =====

  /** First step: checks if input is the quit command. */
  private static EitherPath&lt;GameError, String&gt; checkNotQuit(String line) {
    return "quit".equalsIgnoreCase(line)
        ? Path.left(new GameError("Player quit the game.", true))
        : Path.right(line);
  }

  /** Second step: splits input into exactly two parts. */
  private static EitherPath&lt;GameError, String[]&gt; splitIntoTwoParts(String line) {
    String[] parts = line.split("\\s+");
    return parts.length == 2
        ? Path.right(parts)
        : Path.left(new GameError("Invalid input. Use 'from to' format (e.g., 'c3 d4')."));
  }

  /** Third step: parses both squares and combines into MoveCommand. */
  private static EitherPath&lt;GameError, MoveCommand&gt; parseSquarePair(String[] parts) {
    return parseSquare(parts[0]).zipWith(parseSquare(parts[1]), MoveCommand::new);
  }

  // ===== Square Parsing =====

  /**
   * Parses a square notation string (e.g., "a3") using railway-oriented programming.
   */
  private static EitherPath&lt;GameError, Square&gt; parseSquare(String input) {
    return validateFormat(input).via(InputHandler::validateBoundsAndCreate);
  }

  private static EitherPath&lt;GameError, String&gt; validateFormat(String input) {
    return (input != null &amp;&amp; input.length() == 2)
        ? Path.right(input)
        : Path.left(new GameError("Invalid square format: " + input));
  }

  private static EitherPath&lt;GameError, Square&gt; validateBoundsAndCreate(String input) {
    char colChar = input.charAt(0);
    char rowChar = input.charAt(1);

    boolean validCol = colChar &gt;= 'a' &amp;&amp; colChar &lt;= 'h';
    boolean validRow = rowChar &gt;= '1' &amp;&amp; rowChar &lt;= '8';

    if (!validCol || !validRow) {
      return Path.left(new GameError("Square out of bounds (a1-h8): " + input));
    }

    return Path.right(new Square(rowChar - '1', colChar - 'a'));
  }
}
</code></pre>
<div id="admonition-the-railway-model" class="admonition admonish-note" role="note" aria-labelledby="admonition-the-railway-model-title">
<div class="admonition-title">
<div id="admonition-the-railway-model-title">
<p>The Railway Model</p>
</div>
<a class="admonition-anchor-link" href="#admonition-the-railway-model"></a>
</div>
<div>
<p>The <code>EitherPath</code> follows the railway model: values flow on the success track (Right), while errors automatically switch to the failure track (Left). The <code>.via()</code> method chains dependent validations, and <code>zipWith</code> combines two validations, short-circuiting on the first error.</p>
</div>
</div>
<hr />
<h2 id="step-3-game-logic-with-railway-oriented-programming"><a class="header" href="#step-3-game-logic-with-railway-oriented-programming">Step 3: Game Logic with Railway-Oriented Programming</a></h2>
<p>The game logic uses railway-oriented programming where validations chain on the success track and errors automatically short-circuit to the error track. This replaces imperative if-else chains with a fluent, declarative pipeline.</p>
<pre><code class="language-java">import org.higherkindedj.hkt.effect.WithStatePath;
import org.higherkindedj.hkt.effect.EitherPath;
import org.higherkindedj.hkt.effect.Path;
import org.higherkindedj.hkt.state.State;
import org.higherkindedj.optics.focus.AffinePath;
import org.higherkindedj.optics.focus.FocusPaths;

public class GameLogic {

  /**
   * Applies a move command using railway-oriented programming.
   * Each step either continues on the success track or short-circuits to the error track.
   */
  public static WithStatePath&lt;GameState, MoveResult&gt; applyMove(MoveCommand command) {
    Square from = MoveCommandFocus.from().get(command);
    Square to = MoveCommandFocus.to().get(command);

    return Path.state(
        State.of(
            (GameState state) -&gt;
                // Railway: get piece → validate ownership → validate destination → apply move
                getPieceAt(from, state)
                    .via(piece -&gt; validateOwnership(piece, state))
                    .via(piece -&gt; validateDestinationEmpty(to, state).map(unit -&gt; piece))
                    .via(piece -&gt; validateAndApply(state, command, piece, from, to))
                    .fold(error -&gt; invalidMove(error, state), result -&gt; result)));
  }
</code></pre>
<p>Each validation step is a separate function that returns an <code>EitherPath</code>:</p>
<pre><code class="language-java">  // ===== Validation Pipeline Steps =====

  /** Gets the piece at a square using the Focus-Effect bridge. */
  private static EitherPath&lt;String, Piece&gt; getPieceAt(Square square, GameState state) {
    return AffinePath.of(FocusPaths.&lt;Square, Piece&gt;mapAt(square))
        .toEitherPath(state.board(), "No piece at " + square);
  }

  /** Validates that the piece belongs to the current player. */
  private static EitherPath&lt;String, Piece&gt; validateOwnership(Piece piece, GameState state) {
    Player currentPlayer = GameStateFocus.currentPlayer().get(state);
    Player pieceOwner = PieceFocus.owner().get(piece);

    return pieceOwner == currentPlayer
        ? Path.right(piece)
        : Path.left("Not your piece.");
  }

  /** Validates that the destination square is empty. */
  private static EitherPath&lt;String, Unit&gt; validateDestinationEmpty(Square to, GameState state) {
    boolean isEmpty =
        AffinePath.of(FocusPaths.&lt;Square, Piece&gt;mapAt(to)).getOptional(state.board()).isEmpty();

    return isEmpty
        ? Path.right(Unit.INSTANCE)
        : Path.left("Destination square " + to + " is occupied.");
  }

  /** Validates the move type and applies it if valid. */
  private static EitherPath&lt;String, StateTuple&lt;GameState, MoveResult&gt;&gt; validateAndApply(
      GameState state, MoveCommand command, Piece piece, Square from, Square to) {

    int rowDiff = SquareFocus.row().get(to) - SquareFocus.row().get(from);
    int colDiff = SquareFocus.col().get(to) - SquareFocus.col().get(from);

    if (Math.abs(rowDiff) == 1 &amp;&amp; Math.abs(colDiff) == 1) {
      return validateSimpleMove(piece, rowDiff).map(p -&gt; performMove(state, command, p));
    } else if (Math.abs(rowDiff) == 2 &amp;&amp; Math.abs(colDiff) == 2) {
      return validateJumpMove(state, command, piece, from, rowDiff, colDiff);
    } else {
      return Path.left("Move must be diagonal by 1 or 2 squares.");
    }
  }
</code></pre>
<p>State updates use the Focus DSL for cleaner transformations:</p>
<pre><code class="language-java">  /** Creates an invalid move result. */
  private static StateTuple&lt;GameState, MoveResult&gt; invalidMove(String message, GameState state) {
    return new StateTuple&lt;&gt;(
        new MoveResult(MoveOutcome.INVALID_MOVE, message),
        GameStateFocus.message().set(message, state));
  }

  /** Performs a simple move. */
  private static StateTuple&lt;GameState, MoveResult&gt; performMove(
      GameState state, MoveCommand command, Piece piece) {

    Map&lt;Square, Piece&gt; newBoard = new HashMap&lt;&gt;(state.board());
    newBoard.remove(command.from());
    newBoard.put(command.to(), piece);

    GameState movedState = GameStateFocus.board().set(newBoard, state);
    GameState finalState = checkAndKingPiece(movedState, command.to());

    return new StateTuple&lt;&gt;(
        new MoveResult(MoveOutcome.SUCCESS, "Move successful."),
        finalState.togglePlayer());
  }
</code></pre>
<div id="admonition-focus-effect-bridge" class="admonition admonish-tip" role="note" aria-labelledby="admonition-focus-effect-bridge-title">
<div class="admonition-title">
<div id="admonition-focus-effect-bridge-title">
<p>Focus-Effect Bridge</p>
</div>
<a class="admonition-anchor-link" href="#admonition-focus-effect-bridge"></a>
</div>
<div>
<p>The bridge between Focus DSL and Effects Path API enables powerful patterns:</p>
<ul>
<li><code>AffinePath.of(FocusPaths.mapAt(key)).toEitherPath(map, error)</code> - Navigate into a Map with error handling</li>
<li><code>AffinePath.of(FocusPaths.mapAt(key)).toMaybePath(map)</code> - Navigate with optional result</li>
<li><code>GameStateFocus.message().set(msg, state)</code> - Type-safe state updates</li>
</ul>
</div>
</div>
<hr />
<h2 id="step-4-composing-with-forpath-and-extracted-handlers"><a class="header" href="#step-4-composing-with-forpath-and-extracted-handlers">Step 4: Composing with ForPath and Extracted Handlers</a></h2>
<p>The main game class uses <code>ForPath</code> to compose the turn workflow, with error handling extracted into pure predicates and separate handler functions for improved readability:</p>
<pre><code class="language-java">import org.higherkindedj.hkt.effect.IOPath;
import org.higherkindedj.hkt.effect.Path;
import org.higherkindedj.hkt.expression.ForPath;

public class Draughts {

  /**
   * Processes a single turn using ForPath for composition.
   */
  private static IOPath&lt;GameState&gt; processTurn(GameState currentState) {
    return ForPath.from(BoardDisplay.displayBoard(currentState))
        .from(ignored -&gt; InputHandler.readMoveCommand())
        .yield((ignored, result) -&gt; result)
        .via(result -&gt; handleTurnResult(result, currentState));
  }

  /**
   * Handles the result using Either.fold() with extracted handler functions.
   */
  private static IOPath&lt;GameState&gt; handleTurnResult(
      Either&lt;GameError, MoveCommand&gt; result, GameState state) {
    return result.fold(
        error -&gt; handleError(error, state),
        command -&gt; applyMove(command, state));
  }

  // ===== Error Handling =====

  /**
   * Handles an error using a pure predicate to distinguish quit from other errors.
   */
  private static IOPath&lt;GameState&gt; handleError(GameError error, GameState state) {
    return isQuitCommand(error)
        ? handleQuit(state)
        : displayErrorAndContinue(error, state);
  }

  /** Pure predicate: checks if the error represents a quit command using Focus DSL. */
  private static boolean isQuitCommand(GameError error) {
    return GameErrorFocus.isQuit().get(error);
  }

  /** Handles the quit command by setting game over and displaying farewell. */
  private static IOPath&lt;GameState&gt; handleQuit(GameState state) {
    return Path.io(() -&gt; {
      System.out.println("Goodbye!");
      return GameStateFocus.isGameOver().set(true, state);
    });
  }

  /** Displays an error message and returns the unchanged state. */
  private static IOPath&lt;GameState&gt; displayErrorAndContinue(GameError error, GameState state) {
    return Path.io(() -&gt; {
      System.out.println("Error: " + GameErrorFocus.description().get(error));
      return state;
    });
  }

  // ===== Move Application =====

  /** Applies a valid move command to the game state. */
  private static IOPath&lt;GameState&gt; applyMove(MoveCommand command, GameState state) {
    return Path.ioPure(GameLogic.applyMove(command).run(state).state());
  }
}
</code></pre>
<div id="admonition-functional-error-handling" class="admonition admonish-note" role="note" aria-labelledby="admonition-functional-error-handling-title">
<div class="admonition-title">
<div id="admonition-functional-error-handling-title">
<p>Functional Error Handling</p>
</div>
<a class="admonition-anchor-link" href="#admonition-functional-error-handling"></a>
</div>
<div>
<p>The error handling demonstrates several functional patterns:</p>
<ul>
<li><strong>Pure predicates</strong>: <code>isQuitCommand()</code> uses <code>GameErrorFocus.isQuit()</code> for type-safe access</li>
<li><strong>Type-safe flags</strong>: The <code>isQuit</code> field in <code>GameError</code> avoids string matching</li>
<li><strong>Extracted handlers</strong>: Each error case has its own handler function</li>
<li><strong>Separation of concerns</strong>: Logic is cleanly separated from side effects</li>
</ul>
</div>
</div>
<p>The <code>ForPath</code> comprehension makes the workflow declarative:</p>
<ol>
<li>Display the board (side effect)</li>
<li>Read user input (side effect returning <code>Either</code>)</li>
<li>Yield the result for further processing</li>
<li>Handle errors or apply moves via extracted functions</li>
</ol>
<hr />
<h2 id="step-5-the-game-loop"><a class="header" href="#step-5-the-game-loop">Step 5: The Game Loop</a></h2>
<p>The game loop is a recursive <code>IOPath</code> computation that uses a ternary expression for clarity:</p>
<pre><code class="language-java">  /**
   * The main game loop as a recursive IOPath computation.
   * Creates an IOPath representing the entire game.
   */
  private static IOPath&lt;Unit&gt; gameLoop(GameState gameState) {
    return gameState.isGameOver()
        ? BoardDisplay.displayBoard(gameState)
        : processTurn(gameState).via(Draughts::gameLoop);
  }

  public static void main(String[] args) {
    // Build and execute the complete game
    IOPath&lt;Unit&gt; game =
        Path.ioPure(GameState.initial())
            .via(Draughts::gameLoop)
            .then(() -&gt; Path.ioRunnable(() -&gt; System.out.println("Thank you for playing!")));

    game.unsafeRun();
  }
</code></pre>
<div id="admonition-deferred-execution" class="admonition admonish-note" role="note" aria-labelledby="admonition-deferred-execution-title">
<div class="admonition-title">
<div id="admonition-deferred-execution-title">
<p>Deferred Execution</p>
</div>
<a class="admonition-anchor-link" href="#admonition-deferred-execution"></a>
</div>
<div>
<p>The entire game is constructed as a pure <code>IOPath</code> value. No side effects occur until <code>unsafeRun()</code> is called at the application boundary. This separation makes the code easier to test and reason about.</p>
</div>
</div>
<hr />
<h2 id="step-6-displaying-the-board-with-streams-and-maybepath"><a class="header" href="#step-6-displaying-the-board-with-streams-and-maybepath">Step 6: Displaying the Board with Streams and MaybePath</a></h2>
<p>The display uses <code>IOPath</code> to encapsulate console output, with streams for declarative rendering and <code>MaybePath</code> for optional piece handling:</p>
<pre><code class="language-java">public class BoardDisplay {

  private static final String BOARD_HEADER = "  a b c d e f g h";
  private static final String BOARD_BORDER = " +-----------------+";

  /**
   * Creates an IOPath that, when executed, displays the current game state.
   */
  public static IOPath&lt;Unit&gt; displayBoard(GameState gameState) {
    return Path.ioRunnable(() -&gt; System.out.println(renderGameState(gameState)));
  }

  /**
   * Renders the complete game state as a string using stream composition.
   */
  private static String renderGameState(GameState state) {
    return String.join("\n",
        "",
        BOARD_HEADER,
        BOARD_BORDER,
        renderBoard(state),
        BOARD_BORDER,
        BOARD_HEADER,
        "",
        state.message(),
        renderCurrentPlayer(state));
  }

  /**
   * Renders all board rows using streams.
   */
  private static String renderBoard(GameState state) {
    return IntStream.iterate(7, row -&gt; row &gt;= 0, row -&gt; row - 1)
        .mapToObj(row -&gt; renderRow(state, row))
        .collect(Collectors.joining("\n"));
  }

  /**
   * Renders a single row of the board.
   */
  private static String renderRow(GameState state, int row) {
    String squares = IntStream.range(0, 8)
        .mapToObj(col -&gt; renderSquare(state, row, col))
        .collect(Collectors.joining(" "));

    int displayRow = row + 1;
    return displayRow + "| " + squares + " |" + displayRow;
  }

  /**
   * Renders a single square using MaybePath for optional piece handling.
   */
  private static String renderSquare(GameState state, int row, int col) {
    return AffinePath.of(FocusPaths.&lt;Square, Piece&gt;mapAt(new Square(row, col)))
        .toMaybePath(state.board())
        .map(BoardDisplay::pieceToChar)
        .getOrElse(".");
  }

  /**
   * Pure function converting a piece to its display character.
   */
  private static String pieceToChar(Piece piece) {
    char base = PieceFocus.owner().get(piece) == Player.RED ? 'r' : 'b';
    char display = PieceFocus.type().get(piece) == PieceType.KING
        ? Character.toUpperCase(base)
        : base;
    return String.valueOf(display);
  }

  private static String renderCurrentPlayer(GameState state) {
    return state.isGameOver()
        ? ""
        : "Current Player: " + GameStateFocus.currentPlayer().get(state);
  }
}
</code></pre>
<div id="admonition-functional-rendering-patterns" class="admonition admonish-note" role="note" aria-labelledby="admonition-functional-rendering-patterns-title">
<div class="admonition-title">
<div id="admonition-functional-rendering-patterns-title">
<p>Functional Rendering Patterns</p>
</div>
<a class="admonition-anchor-link" href="#admonition-functional-rendering-patterns"></a>
</div>
<div>
<p>The display uses several functional patterns:</p>
<ul>
<li><strong>Streams</strong>: <code>IntStream.iterate()</code> and <code>mapToObj()</code> for declarative row/column iteration</li>
<li><strong>MaybePath</strong>: <code>toMaybePath().map().getOrElse()</code> safely handles absent pieces</li>
<li><strong>Pure functions</strong>: <code>pieceToChar()</code> has no side effects and uses Focus DSL</li>
<li><strong>String composition</strong>: <code>String.join()</code> and <code>Collectors.joining()</code> for clean concatenation</li>
</ul>
</div>
</div>
<h3 id="playing-the-game"><a class="header" href="#playing-the-game">Playing the Game</a></h3>
<p><img src="../images/draughts_game.png" alt="draughts_game.png" /></p>
<p>In the game we can see BLACK has "kinged" a piece by reaching <code>e8</code>.</p>
<hr />
<h2 id="step-7-adding-multi-jump-rules-with-stream-based-jump-detection"><a class="header" href="#step-7-adding-multi-jump-rules-with-stream-based-jump-detection">Step 7: Adding Multi-Jump Rules with Stream-Based Jump Detection</a></h2>
<p>A key rule in draughts is that captures must be completed: if a capture leads to another possible capture with the same piece, that jump must also be taken.</p>
<p>The beauty of the functional approach is that we only need to modify the core rules in <code>GameLogic.java</code>. The game loop, IO handlers, and data models remain unchanged.</p>
<p>The jump detection uses a stream-based approach instead of nested loops for cleaner functional style:</p>
<pre><code class="language-java">  /** Jump direction offsets for checking available jumps. */
  private static final int[] JUMP_OFFSETS = {-2, 2};

  /** Record representing a jump direction (row and column offsets). */
  private record JumpDirection(int rowOffset, int colOffset) {}

  /**
   * Checks if a piece can make any valid jump using MaybePath.
   */
  private static boolean canPieceJump(GameState state, Square from) {
    return AffinePath.of(FocusPaths.&lt;Square, Piece&gt;mapAt(from))
        .toMaybePath(state.board())
        .map(piece -&gt; hasAnyValidJump(state, from, piece))
        .getOrElse(false);
  }

  /**
   * Checks all directions for valid jumps using streams.
   */
  private static boolean hasAnyValidJump(GameState state, Square from, Piece piece) {
    Player owner = PieceFocus.owner().get(piece);
    PieceType type = PieceFocus.type().get(piece);

    return generateJumpDirections()
        .filter(dir -&gt; isValidJumpDirection(type, owner, dir.rowOffset()))
        .anyMatch(dir -&gt; isValidJump(state, from, dir, owner));
  }

  /**
   * Generates all possible jump direction pairs using flatMap.
   */
  private static Stream&lt;JumpDirection&gt; generateJumpDirections() {
    return IntStream.of(JUMP_OFFSETS)
        .boxed()
        .flatMap(row -&gt; IntStream.of(JUMP_OFFSETS).mapToObj(col -&gt; new JumpDirection(row, col)));
  }

  /** Checks if a jump direction is valid for the piece type. */
  private static boolean isValidJumpDirection(PieceType type, Player owner, int rowOffset) {
    if (type == PieceType.KING) return true;
    // Men can only jump forward
    return !((owner == Player.RED &amp;&amp; rowOffset &gt; 0) || (owner == Player.BLACK &amp;&amp; rowOffset &lt; 0));
  }

  /** Checks if a specific jump is valid using MaybePath. */
  private static boolean isValidJump(GameState state, Square from, JumpDirection dir, Player owner) {
    int toRow = from.row() + dir.rowOffset();
    int toCol = from.col() + dir.colOffset();

    if (toRow &lt; 0 || toRow &gt; 7 || toCol &lt; 0 || toCol &gt; 7) return false;

    Square to = new Square(toRow, toCol);
    Square jumpedSquare = new Square(from.row() + dir.rowOffset() / 2, from.col() + dir.colOffset() / 2);

    // Destination must be empty
    boolean destEmpty =
        AffinePath.of(FocusPaths.&lt;Square, Piece&gt;mapAt(to)).getOptional(state.board()).isEmpty();

    // Must have opponent piece to jump
    boolean hasOpponentPiece =
        AffinePath.of(FocusPaths.&lt;Square, Piece&gt;mapAt(jumpedSquare))
            .toMaybePath(state.board())
            .filter(p -&gt; PieceFocus.owner().get(p) != owner)
            .run()
            .isJust();

    return destEmpty &amp;&amp; hasOpponentPiece;
  }
</code></pre>
<div id="admonition-stream-based-iteration" class="admonition admonish-note" role="note" aria-labelledby="admonition-stream-based-iteration-title">
<div class="admonition-title">
<div id="admonition-stream-based-iteration-title">
<p>Stream-Based Iteration</p>
</div>
<a class="admonition-anchor-link" href="#admonition-stream-based-iteration"></a>
</div>
<div>
<p>The jump detection replaces nested imperative loops with:</p>
<ul>
<li><code>IntStream.of().flatMap()</code> - Generates all direction combinations</li>
<li><code>Stream.filter()</code> - Removes invalid directions for piece type</li>
<li><code>Stream.anyMatch()</code> - Short-circuits on first valid jump found</li>
<li><code>MaybePath.filter().run().isJust()</code> - Safely checks for opponent piece</li>
</ul>
</div>
</div>
<p>After a capture, we check for further jumps using <code>MaybePath</code>:</p>
<pre><code class="language-java">  private static StateTuple&lt;GameState, MoveResult&gt; performJump(...) {
    // ... perform the jump and update board ...

    // Check for win condition using MaybePath
    return checkWinCondition(stateAfterKinging)
        .map(winner -&gt; createWinResult(winner, stateAfterKinging))
        .getOrElseGet(() -&gt; checkMultiJumpOrEndTurn(stateAfterKinging, command.to()));
  }

  /** Checks for multi-jump or ends the turn. */
  private static StateTuple&lt;GameState, MoveResult&gt; checkMultiJumpOrEndTurn(
      GameState state, Square position) {
    return canPieceJump(state, position)
        ? new StateTuple&lt;&gt;(
            new MoveResult(MoveOutcome.CAPTURE_MADE,
                "Capture successful. You must jump again with the same piece."),
            GameStateFocus.message().set(
                "Capture successful. You must jump again with the same piece.", state))
        : new StateTuple&lt;&gt;(
            new MoveResult(MoveOutcome.CAPTURE_MADE, "Capture successful."),
            state.togglePlayer());
  }
</code></pre>
<hr />
<h2 id="under-the-hood-the-monads"><a class="header" href="#under-the-hood-the-monads">Under the Hood: The Monads</a></h2>
<p>The Effects Path API provides a user-friendly layer over powerful functional abstractions. Understanding these foundations helps when you need more advanced patterns.</p>
<h3 id="the-state-monad"><a class="header" href="#the-state-monad">The State Monad</a></h3>
<p><code>WithStatePath&lt;S, A&gt;</code> wraps the State monad, which represents computations that thread state through a sequence of operations:</p>
<pre><code class="language-java">// State&lt;S, A&gt; represents: S -&gt; (A, S)
// A function from initial state to (result, new state)

// WithStatePath provides a fluent API over State
WithStatePath&lt;Integer, String&gt; computation = WithStatePath.&lt;Integer&gt;get()
    .via(n -&gt; WithStatePath.modify((Integer x) -&gt; x + 1)
        .map(ignored -&gt; "Count: " + (n + 1)));

StateTuple&lt;Integer, String&gt; result = computation.run(0);
// result.value() = "Count: 1", result.state() = 1
</code></pre>
<h3 id="the-either-monad"><a class="header" href="#the-either-monad">The Either Monad</a></h3>
<p><code>EitherPath&lt;E, A&gt;</code> wraps Either, providing typed error handling that short-circuits on failure:</p>
<pre><code class="language-java">// Either&lt;E, A&gt; is either Left(error) or Right(value)
// Operations on Right continue; operations on Left propagate the error

EitherPath&lt;String, Integer&gt; result = Path.&lt;String, Integer&gt;right(10)
    .via(n -&gt; n &gt; 5 ? Path.right(n * 2) : Path.left("Too small"))
    .map(n -&gt; n + 1);
// result.run() = Right(21)
</code></pre>
<h3 id="the-io-monad"><a class="header" href="#the-io-monad">The IO Monad</a></h3>
<p><code>IOPath&lt;A&gt;</code> wraps IO, representing deferred side effects:</p>
<pre><code class="language-java">// IO&lt;A&gt; describes a computation that, when run, produces A
// Nothing happens until unsafeRun() is called

IOPath&lt;String&gt; readName = Path.io(() -&gt; {
    System.out.print("Name: ");
    return scanner.nextLine();
});

// readName is a value describing the action - no I/O yet
String name = readName.unsafeRun();  // Now the I/O happens
</code></pre>
<h3 id="higher-kinded-types"><a class="header" href="#higher-kinded-types">Higher-Kinded Types</a></h3>
<p>Java lacks native support for higher-kinded types. Higher-Kinded-J provides a simulation using <code>Kind&lt;F, A&gt;</code> as a bridge type:</p>
<pre><code class="language-java">// We cannot write: &lt;F&gt; F&lt;A&gt; map(F&lt;A&gt; fa, Function&lt;A, B&gt; f)
// But we can write: &lt;F&gt; Kind&lt;F, B&gt; map(Kind&lt;F, A&gt; fa, Function&lt;A, B&gt; f)

// The Path types unwrap the complexity for everyday use
</code></pre>
<p>The Effects Path API abstracts over these foundations, providing a consistent, fluent interface that works the same way regardless of which effect type you use.</p>
<hr />
<h2 id="why-this-functional-approach-is-better"><a class="header" href="#why-this-functional-approach-is-better">Why This Functional Approach is Better</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th>Traditional</th><th>Effects Path API</th></tr></thead><tbody>
<tr><td><strong>Testability</strong></td><td>Mock frameworks, complex setup</td><td>Pure functions, direct assertions</td></tr>
<tr><td><strong>Error Handling</strong></td><td>Exceptions, null checks</td><td>Railway-oriented (<code>EitherPath.via()</code>)</td></tr>
<tr><td><strong>Validation</strong></td><td>Nested if-else chains</td><td>Fluent pipelines that short-circuit</td></tr>
<tr><td><strong>State Management</strong></td><td>Mutable fields</td><td>Immutable transforms (<code>WithStatePath</code>)</td></tr>
<tr><td><strong>Side Effects</strong></td><td>Scattered throughout code</td><td>Isolated at boundaries (<code>IOPath</code>)</td></tr>
<tr><td><strong>Composability</strong></td><td>Nested callbacks</td><td>Fluent chaining (<code>via</code>, <code>map</code>)</td></tr>
<tr><td><strong>Iteration</strong></td><td>Imperative loops</td><td>Streams with <code>flatMap</code>, <code>filter</code>, <code>anyMatch</code></td></tr>
<tr><td><strong>Optional Data</strong></td><td>Manual null checks</td><td><code>MaybePath.map().getOrElse()</code></td></tr>
<tr><td><strong>Data Access</strong></td><td>Manual null checks</td><td>Type-safe paths (Focus DSL)</td></tr>
</tbody></table>
</div>
<p>The <code>GameLogic</code> class is completely pure; you can test the entire rules engine by providing a <code>GameState</code> and a <code>MoveCommand</code>, then asserting on the result. No mocking of console I/O required.</p>
<hr />
<div id="admonition-see-also" class="admonition admonish-tip" role="note" aria-labelledby="admonition-see-also-title">
<div class="admonition-title">
<div id="admonition-see-also-title">
<p>See Also</p>
</div>
<a class="admonition-anchor-link" href="#admonition-see-also"></a>
</div>
<div>
<ul>
<li><a href="../effect/effect_path_overview.html">Effect Path Overview</a> - The railway model for effect composition</li>
<li><a href="../optics/focus_dsl.html">Focus DSL</a> - Type-safe data navigation</li>
<li><a href="../effect/focus_integration.html">Focus-Effect Integration</a> - Bridging optics and effects</li>
<li><a href="../functional/for_comprehension.html">ForPath Comprehensions</a> - For-comprehension syntax</li>
<li><a href="../effect/path_types.html">WithStatePath</a> - State management patterns</li>
</ul>
</div>
</div>
<hr />
<p><strong>Previous:</strong> <a href="order-concurrency.html">Concurrency and Scale</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../hkts/order-concurrency.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../tutorials/ch_intro.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../hkts/order-concurrency.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../tutorials/ch_intro.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../version-switcher.js"></script>
        <script src=".././theme/version-switcher.js"></script>
        <script src=".././theme/sidebar-nav-link.js"></script>


    </div>
    </body>
</html>
